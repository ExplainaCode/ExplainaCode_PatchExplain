record_number,buggy_code,fixed_code
52001,public void setRows(int rows);,void setRows(int rows);
52002,public int[] getSelectedRows();,int[] getSelectedRows();
52003,public void clearSelection();,void clearSelection();
52004,public void setOnedit(String onedit);,void setOnedit(String onedit);
52005,public boolean isDisabled();,boolean isDisabled();
52006,public void setEnableColumnDrag(boolean drag);,void setEnableColumnDrag(boolean drag);
52007,public void setRootChildren(XulTreeChildren rootChildren);,void setRootChildren(XulTreeChildren rootChildren);
52008,"public void setActiveCellCoordinates(int row,int column);","void setActiveCellCoordinates(int row,int column);"
52009,public Object getData();,Object getData();
52010,public String getOnedit();,String getOnedit();
52011,public XulTreeChildren getRootChildren();,XulTreeChildren getRootChildren();
52012,public int[] getActiveCellCoordinates();,int[] getActiveCellCoordinates();
52013,public Object[][] getValues();,Object[][] getValues();
52014,public String getSeltype();,String getSeltype();
52015,public void setData(Object data);,void setData(Object data);
52016,public void setElements(Collection<T> elements);,<T>void setElements(Collection<T> elements);
52017,public void addTreeRow(XulTreeRow row);,void addTreeRow(XulTreeRow row);
52018,public boolean isHierarchical();,boolean isHierarchical();
52019,public void removeTreeRows(int[] rows);,void removeTreeRows(int[] rows);
52020,public boolean isEnableColumnDrag();,boolean isEnableColumnDrag();
52021,public void setSelectedRows(int[] rows);,void setSelectedRows(int[] rows);
52022,public void setEditable(boolean edit);,void setEditable(boolean edit);
52023,public Collection<T> getElements();,<T>Collection<T> getElements();
52024,public String getOnselect();,String getOnselect();
52025,public void setOnselect(String select);,void setOnselect(String select);
52026,public void setSeltype(String type);,void setSeltype(String type);
52027,"public void show(){
  if (dialog == null) {
    createDialog();
    dialog.pack();
  }
  dialog.setVisible(true);
}","public void show(){
  if (dialog == null) {
    createDialog();
    dialog.pack();
  }
  dialog.setLocationRelativeTo(frame);
  dialog.setVisible(true);
}"
52028,"private void createDialog(){
  Document doc=getDocument();
  Element rootElement=doc.getRootElement();
  XulWindow window=null;
  if (rootElement != this) {
    window=(XulWindow)rootElement;
  }
  if (window != null) {
    JFrame frame=(JFrame)window.getManagedObject();
    dialog=new JDialog(frame);
    dialog.setLocationRelativeTo(frame);
  }
 else {
    dialog=new JDialog();
    dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  }
  dialog.setLayout(new BorderLayout());
  JPanel mainPanel=new JPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  dialog.setTitle(title);
  dialog.setModal(true);
  dialog.add(mainPanel,BorderLayout.CENTER);
  mainPanel.add(container,BorderLayout.CENTER);
  if (this.header != null) {
    JPanel headerPanel=new JPanel(new BorderLayout());
    headerPanel.setBackground(Color.decode(""String_Node_Str""));
    headerPanel.setOpaque(true);
    JPanel headerPanelInner=new JPanel(new BorderLayout());
    headerPanelInner.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
    headerPanelInner.setOpaque(false);
    headerPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.decode(""String_Node_Str""),Color.decode(""String_Node_Str"")));
    JLabel title=new JLabel(this.header.getTitle());
    title.setForeground(Color.white);
    headerPanelInner.add(title,BorderLayout.WEST);
    JLabel desc=new JLabel(this.header.getDescription());
    desc.setForeground(Color.white);
    headerPanelInner.add(desc,BorderLayout.EAST);
    headerPanel.add(headerPanelInner,BorderLayout.CENTER);
    mainPanel.add(headerPanel,BorderLayout.NORTH);
  }
  Box buttonPanel=Box.createHorizontalBox();
  if (this.buttonAlignment == BUTTON_ALIGN.RIGHT || this.buttonAlignment == BUTTON_ALIGN.END || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  ArrayList<BUTTONS> buttonKeyList=new ArrayList<BUTTONS>(buttons.keySet());
  for (int i=buttonKeyList.size() - 1; i >= 0; i--) {
    buttonPanel.add(Box.createHorizontalStrut(5));
    buttonPanel.add((JButton)this.buttons.get(buttonKeyList.get(i)).getManagedObject());
    this.addChild(this.buttons.get(buttonKeyList.get(i)));
  }
  buttonPanel.add(Box.createHorizontalStrut(5));
  if (this.buttonAlignment == BUTTON_ALIGN.START || this.buttonAlignment == BUTTON_ALIGN.LEFT || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  mainPanel.add(buttonPanel,BorderLayout.SOUTH);
  dialog.setSize(new Dimension(getWidth(),getHeight()));
  dialog.setPreferredSize(new Dimension(getWidth(),getHeight()));
  dialog.setMinimumSize(new Dimension(getWidth(),getHeight()));
  if (buttons.containsKey(SwingDialog.BUTTONS.ACCEPT)) {
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setLabel(this.getButtonlabelaccept());
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setOnclick(this.getOndialogaccept());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.CANCEL)) {
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setLabel(this.getButtonlabelcancel());
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setOnclick(this.getOndialogcancel());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.EXTRA1)) {
    this.buttons.get(SwingDialog.BUTTONS.EXTRA1).setLabel(this.getButtonlabelextra1());
    this.buttons.get(SwingDialog.BUTTONS.EXTRA1).setOnclick(this.getOndialogextra1());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.EXTRA2)) {
    this.buttons.get(SwingDialog.BUTTONS.EXTRA2).setLabel(this.getButtonlabelextra2());
    this.buttons.get(SwingDialog.BUTTONS.EXTRA2).setOnclick(this.getOndialogextra2());
  }
}","private void createDialog(){
  Document doc=getDocument();
  Element rootElement=doc.getRootElement();
  XulWindow window=null;
  if (rootElement != this) {
    window=(XulWindow)rootElement;
  }
  if (window != null) {
    frame=(JFrame)window.getManagedObject();
    dialog=new JDialog(frame);
    dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  }
 else {
    dialog=new JDialog();
    dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
  }
  dialog.setLayout(new BorderLayout());
  JPanel mainPanel=new JPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  dialog.setTitle(title);
  dialog.setModal(true);
  dialog.add(mainPanel,BorderLayout.CENTER);
  mainPanel.add(container,BorderLayout.CENTER);
  if (this.header != null) {
    JPanel headerPanel=new JPanel(new BorderLayout());
    headerPanel.setBackground(Color.decode(""String_Node_Str""));
    headerPanel.setOpaque(true);
    JPanel headerPanelInner=new JPanel(new BorderLayout());
    headerPanelInner.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
    headerPanelInner.setOpaque(false);
    headerPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.decode(""String_Node_Str""),Color.decode(""String_Node_Str"")));
    JLabel title=new JLabel(this.header.getTitle());
    title.setForeground(Color.white);
    headerPanelInner.add(title,BorderLayout.WEST);
    JLabel desc=new JLabel(this.header.getDescription());
    desc.setForeground(Color.white);
    headerPanelInner.add(desc,BorderLayout.EAST);
    headerPanel.add(headerPanelInner,BorderLayout.CENTER);
    mainPanel.add(headerPanel,BorderLayout.NORTH);
  }
  Box buttonPanel=Box.createHorizontalBox();
  if (this.buttonAlignment == BUTTON_ALIGN.RIGHT || this.buttonAlignment == BUTTON_ALIGN.END || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  ArrayList<BUTTONS> buttonKeyList=new ArrayList<BUTTONS>(buttons.keySet());
  for (int i=buttonKeyList.size() - 1; i >= 0; i--) {
    buttonPanel.add(Box.createHorizontalStrut(5));
    buttonPanel.add((JButton)this.buttons.get(buttonKeyList.get(i)).getManagedObject());
    this.addChild(this.buttons.get(buttonKeyList.get(i)));
  }
  buttonPanel.add(Box.createHorizontalStrut(5));
  if (this.buttonAlignment == BUTTON_ALIGN.START || this.buttonAlignment == BUTTON_ALIGN.LEFT || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  mainPanel.add(buttonPanel,BorderLayout.SOUTH);
  dialog.setSize(new Dimension(getWidth(),getHeight()));
  dialog.setPreferredSize(new Dimension(getWidth(),getHeight()));
  dialog.setMinimumSize(new Dimension(getWidth(),getHeight()));
  if (buttons.containsKey(SwingDialog.BUTTONS.ACCEPT)) {
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setLabel(this.getButtonlabelaccept());
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setOnclick(this.getOndialogaccept());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.CANCEL)) {
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setLabel(this.getButtonlabelcancel());
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setOnclick(this.getOndialogcancel());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.EXTRA1)) {
    this.buttons.get(SwingDialog.BUTTONS.EXTRA1).setLabel(this.getButtonlabelextra1());
    this.buttons.get(SwingDialog.BUTTONS.EXTRA1).setOnclick(this.getOndialogextra1());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.EXTRA2)) {
    this.buttons.get(SwingDialog.BUTTONS.EXTRA2).setLabel(this.getButtonlabelextra2());
    this.buttons.get(SwingDialog.BUTTONS.EXTRA2).setOnclick(this.getOndialogextra2());
  }
}"
52029,"private void createDialog(){
  Document doc=getDocument();
  Element rootElement=doc.getRootElement();
  XulWindow window=(XulWindow)rootElement;
  JFrame frame=(JFrame)window.getManagedObject();
  dialog=new JDialog(frame);
  dialog.setLocationRelativeTo(frame);
  dialog.setLayout(new BorderLayout());
  JPanel mainPanel=new JPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  dialog.setTitle(title);
  dialog.setModal(true);
  dialog.add(mainPanel,BorderLayout.CENTER);
  mainPanel.add(container,BorderLayout.CENTER);
  if (this.header != null) {
    JPanel headerPanel=new JPanel(new BorderLayout());
    headerPanel.setBackground(Color.decode(""String_Node_Str""));
    JPanel headerPanelInner=new JPanel(new BorderLayout());
    headerPanelInner.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
    headerPanelInner.setOpaque(false);
    headerPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.decode(""String_Node_Str""),Color.decode(""String_Node_Str"")));
    JLabel title=new JLabel(this.header.getTitle());
    title.setForeground(Color.white);
    headerPanelInner.add(title,BorderLayout.WEST);
    JLabel desc=new JLabel(this.header.getDescription());
    desc.setForeground(Color.white);
    headerPanelInner.add(desc,BorderLayout.EAST);
    headerPanel.add(headerPanelInner,BorderLayout.CENTER);
    mainPanel.add(headerPanel,BorderLayout.NORTH);
  }
  Box buttonPanel=Box.createHorizontalBox();
  if (this.buttonAlignment == BUTTON_ALIGN.RIGHT || this.buttonAlignment == BUTTON_ALIGN.END || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  ArrayList<BUTTONS> buttonKeyList=new ArrayList<BUTTONS>(buttons.keySet());
  for (int i=buttonKeyList.size() - 1; i >= 0; i--) {
    buttonPanel.add(Box.createHorizontalStrut(5));
    buttonPanel.add((JButton)this.buttons.get(buttonKeyList.get(i)).getManagedObject());
    this.addChild(this.buttons.get(buttonKeyList.get(i)));
  }
  buttonPanel.add(Box.createHorizontalStrut(5));
  if (this.buttonAlignment == BUTTON_ALIGN.START || this.buttonAlignment == BUTTON_ALIGN.LEFT || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  mainPanel.add(buttonPanel,BorderLayout.SOUTH);
  dialog.setSize(new Dimension(getWidth(),getHeight()));
  dialog.setPreferredSize(new Dimension(getWidth(),getHeight()));
  dialog.setMinimumSize(new Dimension(getWidth(),getHeight()));
  if (buttons.containsKey(SwingDialog.BUTTONS.ACCEPT)) {
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setLabel(this.getButtonlabelaccept());
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setOnclick(this.getOndialogaccept());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.CANCEL)) {
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setLabel(this.getButtonlabelcancel());
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setOnclick(this.getOndialogcancel());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.EXTRA1)) {
    this.buttons.get(SwingDialog.BUTTONS.EXTRA1).setLabel(this.getButtonlabelextra1());
    this.buttons.get(SwingDialog.BUTTONS.EXTRA1).setOnclick(this.getOndialogextra1());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.EXTRA2)) {
    this.buttons.get(SwingDialog.BUTTONS.EXTRA2).setLabel(this.getButtonlabelextra2());
    this.buttons.get(SwingDialog.BUTTONS.EXTRA2).setOnclick(this.getOndialogextra2());
  }
}","private void createDialog(){
  Document doc=getDocument();
  Element rootElement=doc.getRootElement();
  XulWindow window=(XulWindow)rootElement;
  JFrame frame=(JFrame)window.getManagedObject();
  dialog=new JDialog(frame);
  dialog.setLocationRelativeTo(frame);
  dialog.setLayout(new BorderLayout());
  JPanel mainPanel=new JPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  dialog.setTitle(title);
  dialog.setModal(true);
  dialog.add(mainPanel,BorderLayout.CENTER);
  mainPanel.add(container,BorderLayout.CENTER);
  if (this.header != null) {
    JPanel headerPanel=new JPanel(new BorderLayout());
    headerPanel.setBackground(Color.decode(""String_Node_Str""));
    headerPanel.setOpaque(true);
    JPanel headerPanelInner=new JPanel(new BorderLayout());
    headerPanelInner.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
    headerPanelInner.setOpaque(false);
    headerPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.decode(""String_Node_Str""),Color.decode(""String_Node_Str"")));
    JLabel title=new JLabel(this.header.getTitle());
    title.setForeground(Color.white);
    headerPanelInner.add(title,BorderLayout.WEST);
    JLabel desc=new JLabel(this.header.getDescription());
    desc.setForeground(Color.white);
    headerPanelInner.add(desc,BorderLayout.EAST);
    headerPanel.add(headerPanelInner,BorderLayout.CENTER);
    mainPanel.add(headerPanel,BorderLayout.NORTH);
  }
  Box buttonPanel=Box.createHorizontalBox();
  if (this.buttonAlignment == BUTTON_ALIGN.RIGHT || this.buttonAlignment == BUTTON_ALIGN.END || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  ArrayList<BUTTONS> buttonKeyList=new ArrayList<BUTTONS>(buttons.keySet());
  for (int i=buttonKeyList.size() - 1; i >= 0; i--) {
    buttonPanel.add(Box.createHorizontalStrut(5));
    buttonPanel.add((JButton)this.buttons.get(buttonKeyList.get(i)).getManagedObject());
    this.addChild(this.buttons.get(buttonKeyList.get(i)));
  }
  buttonPanel.add(Box.createHorizontalStrut(5));
  if (this.buttonAlignment == BUTTON_ALIGN.START || this.buttonAlignment == BUTTON_ALIGN.LEFT || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  mainPanel.add(buttonPanel,BorderLayout.SOUTH);
  dialog.setSize(new Dimension(getWidth(),getHeight()));
  dialog.setPreferredSize(new Dimension(getWidth(),getHeight()));
  dialog.setMinimumSize(new Dimension(getWidth(),getHeight()));
  if (buttons.containsKey(SwingDialog.BUTTONS.ACCEPT)) {
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setLabel(this.getButtonlabelaccept());
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setOnclick(this.getOndialogaccept());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.CANCEL)) {
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setLabel(this.getButtonlabelcancel());
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setOnclick(this.getOndialogcancel());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.EXTRA1)) {
    this.buttons.get(SwingDialog.BUTTONS.EXTRA1).setLabel(this.getButtonlabelextra1());
    this.buttons.get(SwingDialog.BUTTONS.EXTRA1).setOnclick(this.getOndialogextra1());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.EXTRA2)) {
    this.buttons.get(SwingDialog.BUTTONS.EXTRA2).setLabel(this.getButtonlabelextra2());
    this.buttons.get(SwingDialog.BUTTONS.EXTRA2).setOnclick(this.getOndialogextra2());
  }
}"
52030,"public void layout(){
  double totalFlex=0.0;
  for (  XulComponent comp : children) {
    if (comp.getManagedObject() == null) {
      continue;
    }
    if (comp.getFlex() > 0) {
      flexLayout=true;
      totalFlex+=comp.getFlex();
    }
  }
  if (flexLayout)   gc.fill=GridBagConstraints.BOTH;
  double currentFlexTotal=0.0;
  for (int i=0; i < children.size(); i++) {
    XulComponent comp=children.get(i);
    if (comp instanceof XulSplitter) {
      JPanel prevContainer=container;
      container=new JPanel(new GridBagLayout());
      final JSplitPane splitter=new JSplitPane((this.getOrientation() == Orient.VERTICAL) ? JSplitPane.VERTICAL_SPLIT : JSplitPane.HORIZONTAL_SPLIT,prevContainer,container);
      splitter.setContinuousLayout(true);
      final double splitterSize=currentFlexTotal / totalFlex;
      splitter.setResizeWeight(splitterSize);
      if (totalFlex > 0) {
        splitter.addComponentListener(new ComponentListener(){
          public void componentHidden(          ComponentEvent arg0){
          }
          public void componentMoved(          ComponentEvent arg0){
          }
          public void componentShown(          ComponentEvent arg0){
          }
          public void componentResized(          ComponentEvent arg0){
            splitter.setDividerLocation(splitterSize);
            splitter.removeComponentListener(this);
          }
        }
);
      }
      if (!flexLayout) {
        if (this.getOrientation() == Orient.VERTICAL) {
          gc.weighty=1.0;
        }
 else {
          gc.weightx=1.0;
        }
        prevContainer.add(Box.createGlue(),gc);
      }
      managedObject=splitter;
    }
    Object maybeComponent=comp.getManagedObject();
    if (maybeComponent == null || !(maybeComponent instanceof Component)) {
      continue;
    }
    if (this.getOrientation() == Orient.VERTICAL) {
      gc.gridheight=comp.getFlex() + 1;
      gc.gridwidth=GridBagConstraints.REMAINDER;
      gc.weighty=(totalFlex == 0) ? 0 : (comp.getFlex() / totalFlex);
    }
 else {
      gc.gridwidth=comp.getFlex() + 1;
      gc.gridheight=GridBagConstraints.REMAINDER;
      gc.weightx=(totalFlex == 0) ? 0 : (comp.getFlex() / totalFlex);
    }
    currentFlexTotal+=comp.getFlex();
    Component component=(Component)maybeComponent;
    container.add(component,gc);
    if (i + 1 == children.size() && !flexLayout) {
      if (this.getOrientation() == Orient.VERTICAL) {
        gc.weighty=1.0;
      }
 else {
        gc.weightx=1.0;
      }
      container.add(Box.createGlue(),gc);
    }
  }
}","public void layout(){
  double totalFlex=0.0;
  for (  XulComponent comp : children) {
    if (comp.getManagedObject() == null) {
      continue;
    }
    if (comp.getFlex() > 0) {
      flexLayout=true;
      totalFlex+=comp.getFlex();
    }
  }
  if (flexLayout)   gc.fill=GridBagConstraints.BOTH;
  double currentFlexTotal=0.0;
  for (int i=0; i < children.size(); i++) {
    XulComponent comp=children.get(i);
    if (comp instanceof XulSplitter) {
      JPanel prevContainer=container;
      container=new ScrollablePanel(new GridBagLayout());
      JScrollPane leftScroll=new JScrollPane(prevContainer);
      leftScroll.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
      leftScroll.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
      final JSplitPane splitter=new JSplitPane((this.getOrientation() == Orient.VERTICAL) ? JSplitPane.VERTICAL_SPLIT : JSplitPane.HORIZONTAL_SPLIT,leftScroll,container);
      splitter.setContinuousLayout(true);
      final double splitterSize=currentFlexTotal / totalFlex;
      splitter.setResizeWeight(splitterSize);
      if (totalFlex > 0) {
        splitter.addComponentListener(new ComponentListener(){
          public void componentHidden(          ComponentEvent arg0){
          }
          public void componentMoved(          ComponentEvent arg0){
          }
          public void componentShown(          ComponentEvent arg0){
          }
          public void componentResized(          ComponentEvent arg0){
            splitter.setDividerLocation(splitterSize);
            splitter.removeComponentListener(this);
          }
        }
);
      }
      if (!flexLayout) {
        if (this.getOrientation() == Orient.VERTICAL) {
          gc.weighty=1.0;
        }
 else {
          gc.weightx=1.0;
        }
        prevContainer.add(Box.createGlue(),gc);
      }
      managedObject=splitter;
    }
    Object maybeComponent=comp.getManagedObject();
    if (maybeComponent == null || !(maybeComponent instanceof Component)) {
      continue;
    }
    if (this.getOrientation() == Orient.VERTICAL) {
      gc.gridheight=comp.getFlex() + 1;
      gc.gridwidth=GridBagConstraints.REMAINDER;
      gc.weighty=(totalFlex == 0) ? 0 : (comp.getFlex() / totalFlex);
    }
 else {
      gc.gridwidth=comp.getFlex() + 1;
      gc.gridheight=GridBagConstraints.REMAINDER;
      gc.weightx=(totalFlex == 0) ? 0 : (comp.getFlex() / totalFlex);
    }
    currentFlexTotal+=comp.getFlex();
    Component component=(Component)maybeComponent;
    container.add(component,gc);
    if (i + 1 == children.size() && !flexLayout) {
      if (this.getOrientation() == Orient.VERTICAL) {
        gc.weighty=1.0;
      }
 else {
        gc.weightx=1.0;
      }
      container.add(Box.createGlue(),gc);
    }
  }
}"
52031,"public SwingGroupbox(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  this.orientation=Orient.VERTICAL;
  children=new ArrayList<XulComponent>();
  container=new JPanel(new GridBagLayout());
  container.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  managedObject=container;
}","public SwingGroupbox(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  this.orientation=Orient.VERTICAL;
  children=new ArrayList<XulComponent>();
  container=new ScrollablePanel(new GridBagLayout());
  container.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  managedObject=container;
}"
52032,"public SwingHbox(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  children=new ArrayList<XulComponent>();
  container=new JPanel(new GridBagLayout());
  managedObject=container;
  resetContainer();
}","public SwingHbox(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  children=new ArrayList<XulComponent>();
  container=new ScrollablePanel(new GridBagLayout());
  managedObject=container;
  resetContainer();
}"
52033,"public SwingVbox(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  this.orientation=Orient.VERTICAL;
  container=new JPanel(new GridBagLayout());
  managedObject=container;
  resetContainer();
}","public SwingVbox(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  this.orientation=Orient.VERTICAL;
  container=new ScrollablePanel(new GridBagLayout());
  managedObject=container;
  resetContainer();
}"
52034,"public void show(){
  Document doc=getDocument();
  Element rootElement=doc.getRootElement();
  XulWindow window=(XulWindow)rootElement;
  dialog=new JDialog((JFrame)window.getManagedObject());
  dialog.setLayout(new BorderLayout());
  JPanel mainPanel=new JPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  dialog.setTitle(title);
  dialog.setModal(true);
  dialog.add(mainPanel,BorderLayout.CENTER);
  mainPanel.add(container,BorderLayout.CENTER);
  if (this.header != null) {
    JPanel headerPanel=new JPanel(new BorderLayout());
    headerPanel.setBackground(Color.decode(""String_Node_Str""));
    JPanel headerPanelInner=new JPanel(new BorderLayout());
    headerPanelInner.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
    headerPanelInner.setOpaque(false);
    headerPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.decode(""String_Node_Str""),Color.decode(""String_Node_Str"")));
    JLabel title=new JLabel(this.header.getTitle());
    title.setForeground(Color.white);
    headerPanelInner.add(title,BorderLayout.WEST);
    JLabel desc=new JLabel(this.header.getDescription());
    desc.setForeground(Color.white);
    headerPanelInner.add(desc,BorderLayout.EAST);
    headerPanel.add(headerPanelInner,BorderLayout.CENTER);
    mainPanel.add(headerPanel,BorderLayout.NORTH);
  }
  Box buttonPanel=Box.createHorizontalBox();
  if (this.buttonAlignment == BUTTON_ALIGN.RIGHT || this.buttonAlignment == BUTTON_ALIGN.END || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  ArrayList<BUTTONS> buttonKeyList=new ArrayList<BUTTONS>(buttons.keySet());
  for (int i=buttonKeyList.size() - 1; i >= 0; i--) {
    buttonPanel.add(Box.createHorizontalStrut(5));
    buttonPanel.add((JButton)this.buttons.get(buttonKeyList.get(i)).getManagedObject());
  }
  buttonPanel.add(Box.createHorizontalStrut(5));
  if (this.buttonAlignment == BUTTON_ALIGN.START || this.buttonAlignment == BUTTON_ALIGN.LEFT || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  mainPanel.add(buttonPanel,BorderLayout.SOUTH);
  dialog.setSize(new Dimension(getWidth(),getHeight()));
  dialog.setPreferredSize(new Dimension(getWidth(),getHeight()));
  dialog.setMinimumSize(new Dimension(getWidth(),getHeight()));
  if (buttons.containsKey(SwingDialog.BUTTONS.ACCEPT)) {
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setLabel(this.getButtonlabelaccept());
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setOnclick(this.getOndialogaccept());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.CANCEL)) {
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setLabel(this.getButtonlabelcancel());
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setOnclick(this.getOndialogcancel());
  }
  dialog.setVisible(true);
}","public void show(){
  Document doc=getDocument();
  Element rootElement=doc.getRootElement();
  XulWindow window=(XulWindow)rootElement;
  dialog=new JDialog((JFrame)window.getManagedObject());
  dialog.setLayout(new BorderLayout());
  JPanel mainPanel=new JPanel(new BorderLayout());
  mainPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  dialog.setTitle(title);
  dialog.setModal(true);
  dialog.add(mainPanel,BorderLayout.CENTER);
  mainPanel.add(container,BorderLayout.CENTER);
  if (this.header != null) {
    JPanel headerPanel=new JPanel(new BorderLayout());
    headerPanel.setBackground(Color.decode(""String_Node_Str""));
    JPanel headerPanelInner=new JPanel(new BorderLayout());
    headerPanelInner.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
    headerPanelInner.setOpaque(false);
    headerPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.decode(""String_Node_Str""),Color.decode(""String_Node_Str"")));
    JLabel title=new JLabel(this.header.getTitle());
    title.setForeground(Color.white);
    headerPanelInner.add(title,BorderLayout.WEST);
    JLabel desc=new JLabel(this.header.getDescription());
    desc.setForeground(Color.white);
    headerPanelInner.add(desc,BorderLayout.EAST);
    headerPanel.add(headerPanelInner,BorderLayout.CENTER);
    mainPanel.add(headerPanel,BorderLayout.NORTH);
  }
  Box buttonPanel=Box.createHorizontalBox();
  if (this.buttonAlignment == BUTTON_ALIGN.RIGHT || this.buttonAlignment == BUTTON_ALIGN.END || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  ArrayList<BUTTONS> buttonKeyList=new ArrayList<BUTTONS>(buttons.keySet());
  for (int i=buttonKeyList.size() - 1; i >= 0; i--) {
    buttonPanel.add(Box.createHorizontalStrut(5));
    buttonPanel.add((JButton)this.buttons.get(buttonKeyList.get(i)).getManagedObject());
    this.addChild(this.buttons.get(buttonKeyList.get(i)));
  }
  if (this.buttons.containsKey(BUTTONS.CANCEL)) {
    this.buttons.get(BUTTONS.CANCEL).setOnclick(this.getOndialogcancel());
  }
  buttonPanel.add(Box.createHorizontalStrut(5));
  if (this.buttonAlignment == BUTTON_ALIGN.START || this.buttonAlignment == BUTTON_ALIGN.LEFT || this.buttonAlignment == BUTTON_ALIGN.MIDDLE || this.buttonAlignment == BUTTON_ALIGN.CENTER) {
    buttonPanel.add(Box.createHorizontalGlue());
  }
  mainPanel.add(buttonPanel,BorderLayout.SOUTH);
  dialog.setSize(new Dimension(getWidth(),getHeight()));
  dialog.setPreferredSize(new Dimension(getWidth(),getHeight()));
  dialog.setMinimumSize(new Dimension(getWidth(),getHeight()));
  if (buttons.containsKey(SwingDialog.BUTTONS.ACCEPT)) {
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setLabel(this.getButtonlabelaccept());
    this.buttons.get(SwingDialog.BUTTONS.ACCEPT).setOnclick(this.getOndialogaccept());
  }
  if (buttons.containsKey(SwingDialog.BUTTONS.CANCEL)) {
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setLabel(this.getButtonlabelcancel());
    this.buttons.get(SwingDialog.BUTTONS.CANCEL).setOnclick(this.getOndialogcancel());
  }
  dialog.setVisible(true);
}"
52035,"public String getValue(){
  return textField.getText();
}","public String getValue(){
  if (managedObject != null) {
    return ((JTextComponent)managedObject).getText();
  }
 else {
    logger.error(""String_Node_Str"");
    return null;
  }
}"
52036,"public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
switch (col.getColumnType()) {
case CHECKBOX:
    JCheckBox checkbox=new JCheckBox();
  if (value instanceof String) {
    checkbox.setSelected(((String)value).equalsIgnoreCase(""String_Node_Str""));
  }
 else {
    checkbox.setSelected((Boolean)value);
  }
return checkbox;
case COMBOBOX:
SwingTreeCell cell=(SwingTreeCell)rootChildren.getItem(row).getRow().getCell(SwingTree.this.columns.getChildNodes().indexOf(col));
JComboBox comboBox=null;
Vector data=(Vector)cell.getValue();
if (data == null) {
logger.debug(""String_Node_Str"" + value);
if (value instanceof Vector) {
data=(Vector)value;
}
}
if (data != null) {
comboBox=new JComboBox(data);
comboBox.setSelectedIndex(cell.getSelectedIndex());
}
 else {
comboBox=new JComboBox();
}
return comboBox;
default :
JLabel label=new JLabel((String)value);
return label;
}
}","public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
switch (col.getColumnType()) {
case CHECKBOX:
    JCheckBox checkbox=new JCheckBox();
  if (value instanceof String) {
    checkbox.setSelected(((String)value).equalsIgnoreCase(""String_Node_Str""));
  }
 else   if (value instanceof Boolean) {
    checkbox.setSelected((Boolean)value);
  }
 else   if (value == null) {
    checkbox.setSelected(false);
  }
return checkbox;
case COMBOBOX:
SwingTreeCell cell=(SwingTreeCell)rootChildren.getItem(row).getRow().getCell(SwingTree.this.columns.getChildNodes().indexOf(col));
JComboBox comboBox=null;
Vector data=(Vector)cell.getValue();
if (data == null) {
logger.debug(""String_Node_Str"" + value);
if (value instanceof Vector) {
data=(Vector)value;
}
}
if (data != null) {
comboBox=new JComboBox(data);
comboBox.setSelectedIndex(cell.getSelectedIndex());
}
 else {
comboBox=new JComboBox();
}
return comboBox;
default :
JLabel label=new JLabel((String)value);
return label;
}
}"
52037,"private TableCellRenderer getCellRenderer(final SwingTreeCol col){
  return new DefaultTableCellRenderer(){
    public Component getTableCellRendererComponent(    JTable table,    Object value,    boolean isSelected,    boolean hasFocus,    int row,    int column){
switch (col.getColumnType()) {
case CHECKBOX:
        JCheckBox checkbox=new JCheckBox();
      if (value instanceof String) {
        checkbox.setSelected(((String)value).equalsIgnoreCase(""String_Node_Str""));
      }
 else {
        checkbox.setSelected((Boolean)value);
      }
    return checkbox;
case COMBOBOX:
  SwingTreeCell cell=(SwingTreeCell)rootChildren.getItem(row).getRow().getCell(SwingTree.this.columns.getChildNodes().indexOf(col));
JComboBox comboBox=null;
Vector data=(Vector)cell.getValue();
if (data == null) {
logger.debug(""String_Node_Str"" + value);
if (value instanceof Vector) {
data=(Vector)value;
}
}
if (data != null) {
comboBox=new JComboBox(data);
comboBox.setSelectedIndex(cell.getSelectedIndex());
}
 else {
comboBox=new JComboBox();
}
return comboBox;
default :
JLabel label=new JLabel((String)value);
return label;
}
}
}
;
}","private TableCellRenderer getCellRenderer(final SwingTreeCol col){
  return new DefaultTableCellRenderer(){
    public Component getTableCellRendererComponent(    JTable table,    Object value,    boolean isSelected,    boolean hasFocus,    int row,    int column){
switch (col.getColumnType()) {
case CHECKBOX:
        JCheckBox checkbox=new JCheckBox();
      if (value instanceof String) {
        checkbox.setSelected(((String)value).equalsIgnoreCase(""String_Node_Str""));
      }
 else       if (value instanceof Boolean) {
        checkbox.setSelected((Boolean)value);
      }
 else       if (value == null) {
        checkbox.setSelected(false);
      }
    return checkbox;
case COMBOBOX:
  SwingTreeCell cell=(SwingTreeCell)rootChildren.getItem(row).getRow().getCell(SwingTree.this.columns.getChildNodes().indexOf(col));
JComboBox comboBox=null;
Vector data=(Vector)cell.getValue();
if (data == null) {
logger.debug(""String_Node_Str"" + value);
if (value instanceof Vector) {
data=(Vector)value;
}
}
if (data != null) {
comboBox=new JComboBox(data);
comboBox.setSelectedIndex(cell.getSelectedIndex());
}
 else {
comboBox=new JComboBox();
}
return comboBox;
default :
JLabel label=new JLabel((String)value);
return label;
}
}
}
;
}"
52038,"@Override public Component getTableCellEditorComponent(JTable table,Object value,boolean isSelected,final int row,final int column){
switch (col.getColumnType()) {
case CHECKBOX:
    final JCheckBox checkbox=new JCheckBox();
  checkbox.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      SwingTree.this.table.setValueAt(checkbox.isSelected(),row,column);
    }
  }
);
control=checkbox;
if (value instanceof String) {
checkbox.setSelected(((String)value).equalsIgnoreCase(""String_Node_Str""));
}
 else {
checkbox.setSelected((Boolean)value);
}
return checkbox;
case COMBOBOX:
final JComboBox comboBox=new JComboBox((Vector)value);
comboBox.addActionListener(new ActionListener(){
public void actionPerformed(ActionEvent event){
SwingTree.logger.debug(""String_Node_Str"" + comboBox.getSelectedItem() + ""String_Node_Str""+ row+ ""String_Node_Str""+ column);
SwingTree.this.table.setValueAt(comboBox.getSelectedItem(),row,column);
}
}
);
control=comboBox;
return comboBox;
default :
final JTextField label=new JTextField((String)value);
label.getDocument().addDocumentListener(new DocumentListener(){
public void changedUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
public void insertUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
public void removeUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
}
);
control=label;
return label;
}
}","@Override public Component getTableCellEditorComponent(JTable table,Object value,boolean isSelected,final int row,final int column){
switch (col.getColumnType()) {
case CHECKBOX:
    final JCheckBox checkbox=new JCheckBox();
  checkbox.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      SwingTree.this.table.setValueAt(checkbox.isSelected(),row,column);
    }
  }
);
control=checkbox;
if (value instanceof String) {
checkbox.setSelected(((String)value).equalsIgnoreCase(""String_Node_Str""));
}
 else if (value instanceof Boolean) {
checkbox.setSelected((Boolean)value);
}
 else if (value == null) {
checkbox.setSelected(false);
}
return checkbox;
case COMBOBOX:
final JComboBox comboBox=new JComboBox((Vector)value);
comboBox.addActionListener(new ActionListener(){
public void actionPerformed(ActionEvent event){
SwingTree.logger.debug(""String_Node_Str"" + comboBox.getSelectedItem() + ""String_Node_Str""+ row+ ""String_Node_Str""+ column);
SwingTree.this.table.setValueAt(comboBox.getSelectedItem(),row,column);
}
}
);
control=comboBox;
return comboBox;
default :
final JTextField label=new JTextField((String)value);
label.getDocument().addDocumentListener(new DocumentListener(){
public void changedUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
public void insertUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
public void removeUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
}
);
control=label;
return label;
}
}"
52039,"private TableCellEditor getCellEditor(final SwingTreeCol col){
  return new DefaultCellEditor(new JComboBox()){
    JComponent control;
    @Override public Component getTableCellEditorComponent(    JTable table,    Object value,    boolean isSelected,    final int row,    final int column){
switch (col.getColumnType()) {
case CHECKBOX:
        final JCheckBox checkbox=new JCheckBox();
      checkbox.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent event){
          SwingTree.this.table.setValueAt(checkbox.isSelected(),row,column);
        }
      }
);
    control=checkbox;
  if (value instanceof String) {
    checkbox.setSelected(((String)value).equalsIgnoreCase(""String_Node_Str""));
  }
 else {
    checkbox.setSelected((Boolean)value);
  }
return checkbox;
case COMBOBOX:
final JComboBox comboBox=new JComboBox((Vector)value);
comboBox.addActionListener(new ActionListener(){
public void actionPerformed(ActionEvent event){
SwingTree.logger.debug(""String_Node_Str"" + comboBox.getSelectedItem() + ""String_Node_Str""+ row+ ""String_Node_Str""+ column);
SwingTree.this.table.setValueAt(comboBox.getSelectedItem(),row,column);
}
}
);
control=comboBox;
return comboBox;
default :
final JTextField label=new JTextField((String)value);
label.getDocument().addDocumentListener(new DocumentListener(){
public void changedUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
public void insertUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
public void removeUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
}
);
control=label;
return label;
}
}
@Override public Object getCellEditorValue(){
if (control instanceof JCheckBox) {
return ((JCheckBox)control).isSelected();
}
 else if (control instanceof JComboBox) {
return ((JComboBox)control).getSelectedItem();
}
 else {
return ((JTextField)control).getText();
}
}
}
;
}","private TableCellEditor getCellEditor(final SwingTreeCol col){
  return new DefaultCellEditor(new JComboBox()){
    JComponent control;
    @Override public Component getTableCellEditorComponent(    JTable table,    Object value,    boolean isSelected,    final int row,    final int column){
switch (col.getColumnType()) {
case CHECKBOX:
        final JCheckBox checkbox=new JCheckBox();
      checkbox.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent event){
          SwingTree.this.table.setValueAt(checkbox.isSelected(),row,column);
        }
      }
);
    control=checkbox;
  if (value instanceof String) {
    checkbox.setSelected(((String)value).equalsIgnoreCase(""String_Node_Str""));
  }
 else   if (value instanceof Boolean) {
    checkbox.setSelected((Boolean)value);
  }
 else   if (value == null) {
    checkbox.setSelected(false);
  }
return checkbox;
case COMBOBOX:
final JComboBox comboBox=new JComboBox((Vector)value);
comboBox.addActionListener(new ActionListener(){
public void actionPerformed(ActionEvent event){
SwingTree.logger.debug(""String_Node_Str"" + comboBox.getSelectedItem() + ""String_Node_Str""+ row+ ""String_Node_Str""+ column);
SwingTree.this.table.setValueAt(comboBox.getSelectedItem(),row,column);
}
}
);
control=comboBox;
return comboBox;
default :
final JTextField label=new JTextField((String)value);
label.getDocument().addDocumentListener(new DocumentListener(){
public void changedUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
public void insertUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
public void removeUpdate(DocumentEvent arg0){
SwingTree.this.table.setValueAt(label.getText(),row,column);
}
}
);
control=label;
return label;
}
}
@Override public Object getCellEditorValue(){
if (control instanceof JCheckBox) {
return ((JCheckBox)control).isSelected();
}
 else if (control instanceof JComboBox) {
return ((JComboBox)control).getSelectedItem();
}
 else {
return ((JTextField)control).getText();
}
}
}
;
}"
52040,"public Object[][] getValues(){
  TableModel model=table.getModel();
  Object[][] data=new Object[model.getRowCount()][model.getColumnCount()];
  int y=0;
  for (  XulComponent item : this.rootChildren.getChildNodes()) {
    int x=0;
    for (    XulComponent tempCell : ((XulTreeItem)item).getRow().getChildNodes()) {
      SwingTreeCell cell=(SwingTreeCell)tempCell;
switch (columns.getColumn(x).getColumnType()) {
case CHECKBOX:
        data[y][x]=cell.getValue();
      break;
case COMBOBOX:
    Vector values=(Vector)cell.getValue();
  int idx=cell.getSelectedIndex();
data[y][x]=values.get(idx);
break;
default :
data[y][x]=cell.getLabel();
break;
}
x++;
}
y++;
}
return data;
}","public Object[][] getValues(){
  TableModel model=table.getModel();
  Object[][] data=new Object[this.rootChildren.getChildNodes().size()][model.getColumnCount()];
  int y=0;
  for (  XulComponent item : this.rootChildren.getChildNodes()) {
    int x=0;
    for (    XulComponent tempCell : ((XulTreeItem)item).getRow().getChildNodes()) {
      SwingTreeCell cell=(SwingTreeCell)tempCell;
switch (columns.getColumn(x).getColumnType()) {
case CHECKBOX:
        data[y][x]=cell.getValue();
      break;
case COMBOBOX:
    Vector values=(Vector)cell.getValue();
  int idx=cell.getSelectedIndex();
data[y][x]=values.get(idx);
break;
default :
data[y][x]=cell.getLabel();
break;
}
x++;
}
y++;
}
return data;
}"
52041,"@Override public void layout(){
}","@Override public void layout(){
  for (  XulComponent comp : this.children) {
    if (comp instanceof XulTreeRow) {
      this.row=(SwingTreeRow)comp;
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
}"
52042,"public SwingRadioGroup(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  container=new JPanel(new GridBagLayout());
  managedObject=container;
  resetContainer();
}","public SwingRadioGroup(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  this.orientation=Orient.VERTICAL;
  container=new JPanel(new GridBagLayout());
  managedObject=container;
  resetContainer();
}"
52043,"@Override public Object getManagedObject(){
  if (managedObject == null) {
    if (this.multiline) {
      textArea=new JTextArea();
      managedObject=textArea;
      scrollPane=new JScrollPane(textArea);
      this.scrollPane.setMinimumSize(new Dimension(this.width,this.height));
      this.scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    }
 else {
      textField=new JTextField();
      managedObject=textField;
    }
  }
  return (this.multiline) ? scrollPane : textField;
}","@Override public Object getManagedObject(){
  if (managedObject == null) {
    if (this.multiline) {
      textArea=new JTextArea((value != null) ? value : ""String_Node_Str"");
      managedObject=textArea;
      scrollPane=new JScrollPane(textArea);
      this.scrollPane.setMinimumSize(new Dimension(this.width,this.height));
      this.scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    }
 else {
      textField=new JTextField((value != null) ? value : ""String_Node_Str"");
      textField.setPreferredSize(new Dimension(200,20));
      managedObject=textField;
    }
  }
  return (this.multiline) ? scrollPane : textField;
}"
52044,"public SwingTree(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  XulComponent primaryColumn=getElementByXPath(""String_Node_Str"");
  XulComponent isaContainer=getElementByXPath(""String_Node_Str"");
  isHierarchical=(primaryColumn != null) && (isaContainer != null);
  if (isHierarchical) {
    tree=new JTree();
  }
 else {
    table=new JTable();
  }
  ToolTipManager.sharedInstance().unregisterComponent(table);
  ToolTipManager.sharedInstance().unregisterComponent(table.getTableHeader());
  scrollpane=new JScrollPane(table);
  this.managedObject=scrollpane.getViewport();
}","public SwingTree(XulComponent parent,XulDomContainer domContainer,String tagName){
  super(""String_Node_Str"");
  XulComponent primaryColumn=getElementByXPath(""String_Node_Str"");
  XulComponent isaContainer=getElementByXPath(""String_Node_Str"");
  isHierarchical=(primaryColumn != null) && (isaContainer != null);
  if (isHierarchical) {
    tree=new JTree();
  }
 else {
    table=new JTable();
  }
  ToolTipManager.sharedInstance().unregisterComponent(table);
  ToolTipManager.sharedInstance().unregisterComponent(table.getTableHeader());
  table.setRowHeight(18);
  scrollpane=new JScrollPane(table);
  this.managedObject=scrollpane.getViewport();
}"
52045,"public Object[][] getValues(){
  TableModel model=table.getModel();
  Object[][] data=new Object[this.rootChildren.getChildNodes().size()][model.getColumnCount()];
  int y=0;
  for (  XulComponent item : this.rootChildren.getChildNodes()) {
    int x=0;
    for (    XulComponent tempCell : ((XulTreeItem)item).getRow().getChildNodes()) {
      SwingTreeCell cell=(SwingTreeCell)tempCell;
switch (columns.getColumn(x).getColumnType()) {
case CHECKBOX:
        data[y][x]=cell.getValue();
      break;
case COMBOBOX:
    Vector values=(Vector)cell.getValue();
  int idx=cell.getSelectedIndex();
data[y][x]=values.get(idx);
break;
default :
data[y][x]=cell.getLabel();
break;
}
x++;
}
y++;
}
return data;
}","public Object[][] getValues(){
  TableModel model=table.getModel();
  Object[][] data=new Object[this.rootChildren.getChildNodes().size()][model.getColumnCount()];
  int y=0;
  for (  XulComponent item : this.rootChildren.getChildNodes()) {
    int x=0;
    for (    XulComponent tempCell : ((XulTreeItem)item).getRow().getChildNodes()) {
      SwingTreeCell cell=(SwingTreeCell)tempCell;
switch (columns.getColumn(x).getColumnType()) {
case CHECKBOX:
        Boolean flag=(Boolean)cell.getValue();
      if (flag == null) {
        flag=Boolean.FALSE;
      }
    data[y][x]=flag;
  break;
case COMBOBOX:
Vector values=(Vector)cell.getValue();
int idx=cell.getSelectedIndex();
data[y][x]=values.get(idx);
break;
default :
data[y][x]=cell.getLabel();
break;
}
x++;
}
y++;
}
return data;
}"
52046,"public void evaluateHand(){
  byte tallyValues[]=new byte[13];
  byte tallySuits[]=new byte[4];
  byte fours=0;
  byte threes=0;
  byte pair1=0;
  byte pair2=0;
  for (int i=0; i < 5; i++) {
    tallyValues[cards[i].getRank()]++;
    tallySuits[cards[i].getSuit()]++;
  }
  for (byte i=12; i >= 0; i--) {
    if (tallyValues[i] == 4) {
      fours=i;
    }
 else     if (tallyValues[i] == 3) {
      threes=i;
    }
 else     if (tallyValues[i] == 2) {
      if (pair1 == 0)       pair1=i;
 else       pair2=i;
    }
  }
  List<Byte> sortedCardValues=new ArrayList<Byte>();
  for (byte i=0; i < 5; i++) {
    sortedCardValues.add(cards[i].getRank());
  }
  Collections.sort(sortedCardValues);
  float tempRank=0;
  if (sortedCardValues.get(0) + 4 == sortedCardValues.get(4)) {
    pattern=""String_Node_Str"";
    tempRank=56 + sortedCardValues.get(4);
    for (byte x=0; x < 4; x++) {
      if (tallySuits[x] == 5) {
        tempRank+=56;
        pattern+=""String_Node_Str"";
      }
    }
  }
  if (fours > 0) {
    tempRank=98 + fours;
    pattern=""String_Node_Str"";
  }
 else   if (threes > 0) {
    if (pair1 > 0) {
      tempRank=84 + threes;
      pattern=""String_Node_Str"";
    }
 else {
      tempRank=42 + threes;
      pattern=""String_Node_Str"";
    }
  }
 else   if (pair1 > 0) {
    if (pair2 > 0) {
      tempRank=28 + pair1 + (float)pair2 / 100 + (float)sortedCardValues.get(4) / 10000;
      pattern=""String_Node_Str"";
    }
 else {
      tempRank=14 + pair1 + (float)sortedCardValues.get(4) / 100 + (float)sortedCardValues.get(3) / 10000 + (float)sortedCardValues.get(2) / 1000000;
      pattern=""String_Node_Str"";
    }
  }
  if (tempRank == 0) {
    for (byte i=0; i < 4; i++) {
      if (tallySuits[i] == 5) {
        tempRank=70 + sortedCardValues.get(4) + (float)sortedCardValues.get(3) / 100 + (float)sortedCardValues.get(2) / 10000 + (float)sortedCardValues.get(1) / 1000000 + (float)sortedCardValues.get(0) / 100000000;
        pattern=""String_Node_Str"";
      }
    }
  }
  if (tempRank == 0) {
    tempRank=sortedCardValues.get(4) + (float)sortedCardValues.get(3) / 100 + (float)sortedCardValues.get(2) / 10000 + (float)sortedCardValues.get(1) / 1000000 + (float)sortedCardValues.get(0) / 100000000;
    pattern=""String_Node_Str"";
  }
  handValue=tempRank;
}","public void evaluateHand(){
  byte tallyValues[]=new byte[14];
  byte tallySuits[]=new byte[4];
  byte fours=0;
  byte threes=0;
  byte pair1=0;
  byte pair2=0;
  for (int i=0; i < 5; i++) {
    tallyValues[cards[i].getRank()]++;
    tallySuits[cards[i].getSuit()]++;
  }
  for (byte i=13; i > 0; i--) {
    if (tallyValues[i] == 4) {
      fours=i;
    }
 else     if (tallyValues[i] == 3) {
      threes=i;
    }
 else     if (tallyValues[i] == 2) {
      if (pair1 == 0)       pair1=i;
 else       pair2=i;
    }
  }
  List<Byte> sortedCardValues=new ArrayList<Byte>();
  for (byte i=0; i < 5; i++) {
    sortedCardValues.add(cards[i].getRank());
  }
  Collections.sort(sortedCardValues);
  float tempRank=0;
  if (sortedCardValues.get(0) + 4 == sortedCardValues.get(4) || (sortedCardValues.get(4) == 13 && sortedCardValues.get(0) + 3 == sortedCardValues.get(3))) {
    pattern=""String_Node_Str"";
    tempRank=56 + sortedCardValues.get(4) + (float)sortedCardValues.get(3) / 100;
    for (byte x=0; x < 4; x++) {
      if (tallySuits[x] == 5) {
        tempRank+=56;
        pattern+=""String_Node_Str"";
      }
    }
  }
  if (fours > 0) {
    tempRank=98 + fours + calcAddValue(sortedCardValues,100,fours,0);
    pattern=""String_Node_Str"";
  }
 else   if (threes > 0) {
    if (pair1 > 0) {
      tempRank=84 + threes + (float)pair1 / 100;
      pattern=""String_Node_Str"";
    }
 else {
      tempRank=42 + threes + calcAddValue(sortedCardValues,100,threes,0);
      pattern=""String_Node_Str"";
    }
  }
 else   if (pair1 > 0) {
    if (pair2 > 0) {
      tempRank=28 + pair1 + (float)pair2 / 100 + calcAddValue(sortedCardValues,10000,pair1,pair2);
      pattern=""String_Node_Str"";
    }
 else {
      tempRank=14 + pair1 + calcAddValue(sortedCardValues,100,pair1,0);
      pattern=""String_Node_Str"";
    }
  }
  if (tempRank == 0) {
    for (byte i=0; i < 4; i++) {
      if (tallySuits[i] == 5) {
        tempRank=70 + sortedCardValues.get(4) + (float)sortedCardValues.get(3) / 100 + (float)sortedCardValues.get(2) / 10000 + (float)sortedCardValues.get(1) / 1000000 + (float)sortedCardValues.get(0) / 100000000;
        pattern=""String_Node_Str"";
      }
    }
  }
  if (tempRank == 0) {
    tempRank=sortedCardValues.get(4) + (float)sortedCardValues.get(3) / 100 + (float)sortedCardValues.get(2) / 10000 + (float)sortedCardValues.get(1) / 1000000 + (float)sortedCardValues.get(0) / 100000000;
    pattern=""String_Node_Str"";
  }
  handValue=tempRank;
}"
52047,"public static void main(String[] args){
  Card player1[]=new Card[5];
  Card player2[]=new Card[5];
  player1[0]=new Card(3,0);
  player1[1]=new Card(2,0);
  player1[2]=new Card(2,1);
  player1[3]=new Card(6,0);
  player1[4]=new Card(6,1);
  player2[0]=new Card(4,0);
  player2[1]=new Card(2,0);
  player2[2]=new Card(2,1);
  player2[3]=new Card(6,0);
  player2[4]=new Card(6,1);
  System.out.println(""String_Node_Str"");
  for (int i=0; i < 5; i++)   System.out.println(player1[i].toWords());
  System.out.println();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < 5; i++)   System.out.println(player2[i].toWords());
  System.out.println();
  HandEvaluator he=new HandEvaluator(player1);
  System.out.println(""String_Node_Str"" + he.getPokerHandAsString() + ""String_Node_Str""+ he.getPokerHandAsValued());
  double p1Value=he.getPokerHandAsValued();
  he=new HandEvaluator(player2);
  System.out.println(""String_Node_Str"" + he.getPokerHandAsString() + ""String_Node_Str""+ he.getPokerHandAsValued());
  double p2Value=he.getPokerHandAsValued();
  if (p1Value > p2Value) {
    System.out.println(""String_Node_Str"");
  }
 else   if (p2Value > p1Value) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}","public static void main(String[] args){
  Card player1[]=new Card[5];
  Card player2[]=new Card[5];
  player1[0]=new Card(3,0);
  player1[1]=new Card(3,1);
  player1[2]=new Card(3,2);
  player1[3]=new Card(3,3);
  player1[4]=new Card(6,1);
  player2[0]=new Card(3,0);
  player2[1]=new Card(3,1);
  player2[2]=new Card(3,2);
  player2[3]=new Card(3,3);
  player2[4]=new Card(7,1);
  System.out.println(""String_Node_Str"");
  for (int i=0; i < 5; i++)   System.out.println(player1[i].toWords());
  System.out.println();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < 5; i++)   System.out.println(player2[i].toWords());
  System.out.println();
  HandEvaluator he=new HandEvaluator(player1);
  System.out.println(""String_Node_Str"" + he.getPokerHandAsString() + ""String_Node_Str""+ he.getPokerHandAsValued());
  double p1Value=he.getPokerHandAsValued();
  he=new HandEvaluator(player2);
  System.out.println(""String_Node_Str"" + he.getPokerHandAsString() + ""String_Node_Str""+ he.getPokerHandAsValued());
  double p2Value=he.getPokerHandAsValued();
  if (p1Value > p2Value) {
    System.out.println(""String_Node_Str"");
  }
 else   if (p2Value > p1Value) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
  }
}"
52048,"/** 
 * sortedCardValues  1 to 13
 */
public float calcAddValue(List<Byte> sortedCardValues,int rate,int exclude1,int exclude2){
  float tempRank=0;
  for (int i=4; i >= 0; i--) {
    if (sortedCardValues.get(i) == exclude1 || sortedCardValues.get(i) == exclude2)     continue;
    tempRank+=(float)sortedCardValues.get(i) / rate;
    rate*=100;
  }
  return tempRank;
}","/** 
 * sortedCardValues  1 to 13
 */
public double calcAddValue(List<Byte> sortedCardValues,int rate,int exclude1,int exclude2){
  double tempRank=0;
  for (int i=4; i >= 0; i--) {
    if (sortedCardValues.get(i) == exclude1 || sortedCardValues.get(i) == exclude2)     continue;
    tempRank+=(float)sortedCardValues.get(i) / rate;
    rate*=100;
  }
  return tempRank;
}"
52049,"public void evaluateHand(){
  byte tallyValues[]=new byte[14];
  byte tallySuits[]=new byte[4];
  byte fours=0;
  byte threes=0;
  byte pair1=0;
  byte pair2=0;
  for (int i=0; i < 5; i++) {
    tallyValues[cards[i].getRank()]++;
    tallySuits[cards[i].getSuit()]++;
  }
  for (byte i=13; i > 0; i--) {
    if (tallyValues[i] == 4) {
      fours=i;
    }
 else     if (tallyValues[i] == 3) {
      threes=i;
    }
 else     if (tallyValues[i] == 2) {
      if (pair1 == 0)       pair1=i;
 else       pair2=i;
    }
  }
  List<Byte> sortedCardValues=new ArrayList<Byte>();
  for (byte i=0; i < 5; i++) {
    sortedCardValues.add(cards[i].getRank());
  }
  Collections.sort(sortedCardValues);
  float tempRank=0;
  if (sortedCardValues.get(0) + 4 == sortedCardValues.get(4) || (sortedCardValues.get(4) == 13 && sortedCardValues.get(0) + 3 == sortedCardValues.get(3))) {
    pattern=""String_Node_Str"";
    tempRank=56 + sortedCardValues.get(4) + (float)sortedCardValues.get(3) / 100;
    for (byte x=0; x < 4; x++) {
      if (tallySuits[x] == 5) {
        tempRank+=56;
        pattern+=""String_Node_Str"";
      }
    }
  }
  if (fours > 0) {
    tempRank=98 + fours + calcAddValue(sortedCardValues,100,fours,0);
    pattern=""String_Node_Str"";
  }
 else   if (threes > 0) {
    if (pair1 > 0) {
      tempRank=84 + threes + (float)pair1 / 100;
      pattern=""String_Node_Str"";
    }
 else {
      tempRank=42 + threes + calcAddValue(sortedCardValues,100,threes,0);
      pattern=""String_Node_Str"";
    }
  }
 else   if (pair1 > 0) {
    if (pair2 > 0) {
      tempRank=28 + pair1 + (float)pair2 / 100 + calcAddValue(sortedCardValues,10000,pair1,pair2);
      pattern=""String_Node_Str"";
    }
 else {
      tempRank=14 + pair1 + calcAddValue(sortedCardValues,100,pair1,0);
      pattern=""String_Node_Str"";
    }
  }
  if (tempRank == 0) {
    for (byte i=0; i < 4; i++) {
      if (tallySuits[i] == 5) {
        tempRank=70 + sortedCardValues.get(4) + (float)sortedCardValues.get(3) / 100 + (float)sortedCardValues.get(2) / 10000 + (float)sortedCardValues.get(1) / 1000000 + (float)sortedCardValues.get(0) / 100000000;
        pattern=""String_Node_Str"";
      }
    }
  }
  if (tempRank == 0) {
    tempRank=sortedCardValues.get(4) + (float)sortedCardValues.get(3) / 100 + (float)sortedCardValues.get(2) / 10000 + (float)sortedCardValues.get(1) / 1000000 + (float)sortedCardValues.get(0) / 100000000;
    pattern=""String_Node_Str"";
  }
  handValue=tempRank;
}","public void evaluateHand(){
  byte tallyValues[]=new byte[14];
  byte tallySuits[]=new byte[4];
  byte fours=0;
  byte threes=0;
  byte pair1=0;
  byte pair2=0;
  for (int i=0; i < 5; i++) {
    tallyValues[cards[i].getRank()]++;
    tallySuits[cards[i].getSuit()]++;
  }
  for (byte i=13; i > 0; i--) {
    if (tallyValues[i] == 4) {
      fours=i;
    }
 else     if (tallyValues[i] == 3) {
      threes=i;
    }
 else     if (tallyValues[i] == 2) {
      if (pair1 == 0)       pair1=i;
 else       pair2=i;
    }
  }
  List<Byte> sortedCardValues=new ArrayList<Byte>();
  for (byte i=0; i < 5; i++) {
    sortedCardValues.add(cards[i].getRank());
  }
  Collections.sort(sortedCardValues);
  double tempRank=0;
  if (sortedCardValues.get(0) + 4 == sortedCardValues.get(4) || (sortedCardValues.get(4) == 13 && sortedCardValues.get(0) == 1 && sortedCardValues.get(0) + 3 == sortedCardValues.get(3))) {
    pattern=""String_Node_Str"";
    tempRank=56 + sortedCardValues.get(0);
    for (byte x=0; x < 4; x++) {
      if (tallySuits[x] == 5) {
        tempRank+=56;
        pattern+=""String_Node_Str"";
      }
    }
  }
  if (fours > 0) {
    tempRank=98 + fours + calcAddValue(sortedCardValues,100,fours,0);
    pattern=""String_Node_Str"";
  }
 else   if (threes > 0) {
    if (pair1 > 0) {
      tempRank=84 + threes + (float)pair1 / 100;
      pattern=""String_Node_Str"";
    }
 else {
      tempRank=42 + threes + calcAddValue(sortedCardValues,100,threes,0);
      pattern=""String_Node_Str"";
    }
  }
 else   if (pair1 > 0) {
    if (pair2 > 0) {
      tempRank=28 + pair1 + (float)pair2 / 100 + calcAddValue(sortedCardValues,10000,pair1,pair2);
      pattern=""String_Node_Str"";
    }
 else {
      tempRank=14 + pair1 + calcAddValue(sortedCardValues,100,pair1,0);
      pattern=""String_Node_Str"";
    }
  }
  if (tempRank == 0) {
    for (byte i=0; i < 4; i++) {
      if (tallySuits[i] == 5) {
        tempRank=70 + sortedCardValues.get(4) + (double)sortedCardValues.get(3) / 100 + (double)sortedCardValues.get(2) / 10000 + (double)sortedCardValues.get(1) / 1000000 + (double)sortedCardValues.get(0) / 100000000;
        pattern=""String_Node_Str"";
      }
    }
  }
  if (tempRank == 0) {
    tempRank=sortedCardValues.get(4) + (double)sortedCardValues.get(3) / 100 + (double)sortedCardValues.get(2) / 10000 + (double)sortedCardValues.get(1) / 1000000 + (double)sortedCardValues.get(0) / 100000000;
    pattern=""String_Node_Str"";
  }
  handValue=tempRank;
}"
52050,"public static Result findMementos(){
  Form<Query> urlParam=queryForm.bindFromRequest();
  System.err.println(""String_Node_Str"" + urlParam.hasErrors());
  if (urlParam.hasErrors()) {
    return badRequest(views.html.search.render(new MementoBackingBean(),urlParam));
  }
  Query q=urlParam.get();
  return redirect(routes.Application.findMementosFor(q.url));
}","public static Result findMementos(){
  Form<Query> urlParam=queryForm.bindFromRequest();
  if (urlParam.hasErrors()) {
    return badRequest(views.html.search.render(new MementoQuery(),urlParam));
  }
  Query q=urlParam.get();
  return redirect(routes.Application.findMementosFor(q.url));
}"
52051,"public static Result queryMementos(){
  return ok(views.html.search.render(new MementoBackingBean(),queryForm));
}","public static Result queryMementos(){
  return ok(views.html.search.render(new MementoQuery(),queryForm));
}"
52052,"public static Result findMementosFor(String url){
  MementoBackingBean msb=(MementoBackingBean)Cache.get(""String_Node_Str"" + url);
  if (msb == null) {
    msb=new MementoBackingBean();
    msb.setUrl(url);
  }
  Cache.set(""String_Node_Str"" + url,msb);
  Query q=new Query();
  q.url=url;
  return ok(views.html.search.render(msb,queryForm.fill(q)));
}","public static Result findMementosFor(String url){
  MementoQuery msb=(MementoQuery)Cache.get(""String_Node_Str"" + url);
  if (msb == null) {
    msb=new MementoQuery();
    Logger.info(""String_Node_Str"" + url);
    msb.setUrl(url);
  }
  Cache.set(""String_Node_Str"" + url,msb);
  if (msb.getErrorMessage() != null)   flash(""String_Node_Str"",msb.getErrorMessage());
  Query q=new Query();
  q.url=url;
  return ok(views.html.search.render(msb,queryForm.fill(q)));
}"
52053,"void updateWidgets(){
  ComponentName thisWidget=new ComponentName(this,SleepTimerWidgetProvider.class);
  AppWidgetManager manager=AppWidgetManager.getInstance(this);
  RemoteViews remoteView;
  if (UnlockTools.isAppPayed(this)) {
    remoteView=getUnlockedRemoteView();
  }
 else {
    remoteView=getLockedRemoteView();
  }
  manager.updateAppWidget(thisWidget,remoteView);
}","void updateWidgets(){
  ComponentName thisWidget=new ComponentName(this,SleepTimerWidgetProvider.class);
  AppWidgetManager manager=AppWidgetManager.getInstance(this);
  RemoteViews remoteView;
  if (UnlockTools.isAppPayed(this)) {
    remoteView=getUnlockedRemoteView();
  }
 else {
    remoteView=getLockedRemoteView();
  }
  try {
    manager.updateAppWidget(thisWidget,remoteView);
  }
 catch (  NullPointerException e) {
    BugSender.sendBug(this,""String_Node_Str"",""String_Node_Str"");
  }
}"
52054,"@Override public IPath instanceDirectory(String instanceName){
  return getRuntime().getLocation().append(instanceName);
}","@Override public IPath instanceDirectory(String instanceName){
  return defaultInstancesDirectory().append(instanceName);
}"
52055,"public static IPath getTcServerRuntimePath(IPath installPath){
  File[] files=installPath.toFile().listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return Pattern.matches(""String_Node_Str"",name) && new File(dir,name).isDirectory();
    }
  }
);
  return files.length > 0 ? Path.fromOSString(files[0].toString()) : null;
}","public static IPath getTcServerRuntimePath(IPath installPath){
  File[] files=installPath.toFile().listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return (Pattern.matches(""String_Node_Str"",name) || Pattern.matches(""String_Node_Str"",name)) && new File(dir,name).isDirectory();
    }
  }
);
  return files.length > 0 ? Path.fromOSString(files[0].toString()) : null;
}"
52056,"@Override public boolean accept(File dir,String name){
  return Pattern.matches(""String_Node_Str"",name) && new File(dir,name).isDirectory();
}","@Override public boolean accept(File dir,String name){
  return (Pattern.matches(""String_Node_Str"",name) || Pattern.matches(""String_Node_Str"",name)) && new File(dir,name).isDirectory();
}"
52057,"public static File getInstanceDirectory(ServerWorkingCopy wc){
  if (wc != null) {
    String instanceDir=wc.getAttribute(TomcatServer.PROPERTY_INSTANCE_DIR,(String)null);
    if (instanceDir != null) {
      File file=new File(instanceDir);
      if (file.exists()) {
        return file;
      }
    }
    String serverName=wc.getAttribute(TcServer.KEY_SERVER_NAME,(String)null);
    if (serverName != null) {
      IPath path=wc.getRuntime().getLocation();
      File directory=path.toFile();
      if (directory.exists()) {
        File file=new File(directory,serverName);
        if (file.exists()) {
          return file;
        }
      }
    }
  }
  return null;
}","public static File getInstanceDirectory(ServerWorkingCopy wc){
  if (wc != null) {
    String instanceDir=wc.getAttribute(TomcatServer.PROPERTY_INSTANCE_DIR,(String)null);
    if (instanceDir != null) {
      File file=new File(instanceDir);
      if (file.exists()) {
        return file;
      }
    }
    String serverName=wc.getAttribute(TcServer.KEY_SERVER_NAME,(String)null);
    if (serverName != null) {
      ITcRuntime tcRuntime=getTcRuntime(wc.getRuntime());
      IPath path=tcRuntime == null ? wc.getRuntime().getLocation() : tcRuntime.instanceDirectory(serverName);
      File directory=path.toFile();
      if (directory.exists()) {
        return directory;
      }
    }
  }
  return null;
}"
52058,"private void initialize(){
  isDefaultServerName=wc == null || TcServerUtil.isTcServerDefaultName(wc);
  existingInstanceButton.setEnabled(false);
  if (wc != null && serverNameCombo != null) {
    String previous=serverNameCombo.getText();
    serverNameCombo.removeAll();
    IPath path=wc.getRuntime().getLocation();
    File file=path.toFile();
    if (file.exists()) {
      File[] serverDirectories=file.listFiles();
      if (serverDirectories != null) {
        for (        File directory : serverDirectories) {
          if (directory.isDirectory() && new File(directory,""String_Node_Str"").exists()) {
            serverNameCombo.add(directory.getName());
          }
        }
      }
    }
    existingInstanceButton.setEnabled(true);
    serverNameCombo.setText(previous);
  }
}","private void initialize(){
  isDefaultServerName=wc == null || TcServerUtil.isTcServerDefaultName(wc);
  existingInstanceButton.setEnabled(false);
  if (wc != null && serverNameCombo != null) {
    String previous=serverNameCombo.getText();
    serverNameCombo.removeAll();
    ITcRuntime tcRuntime=TcServerUtil.getTcRuntime(wc.getRuntime());
    if (tcRuntime != null) {
      IPath instancesDirectory=tcRuntime.defaultInstancesDirectory();
      File[] serverDirectories=instancesDirectory.toFile().listFiles();
      if (serverDirectories != null) {
        for (        File directory : serverDirectories) {
          if (directory.isDirectory() && new File(directory,""String_Node_Str"").exists()) {
            serverNameCombo.add(directory.getName());
          }
        }
      }
    }
    existingInstanceButton.setEnabled(true);
    serverNameCombo.setText(previous);
  }
}"
52059,"private static File getInstanceDirectory(String[] arguments,String instanceName){
  for (int i=0; i < arguments.length; i++) {
    if (arguments[i].equals(""String_Node_Str"") && arguments[i + 1] != null) {
      return new File(arguments[i + 1],instanceName);
    }
  }
  return null;
}","public static File getInstanceDirectory(ServerWorkingCopy wc){
  if (wc != null) {
    String instanceDir=wc.getAttribute(TomcatServer.PROPERTY_INSTANCE_DIR,(String)null);
    if (instanceDir != null) {
      File file=new File(instanceDir);
      if (file.exists()) {
        return file;
      }
    }
    String serverName=wc.getAttribute(TcServer.KEY_SERVER_NAME,(String)null);
    if (serverName != null) {
      IPath path=wc.getRuntime().getLocation();
      File directory=path.toFile();
      if (directory.exists()) {
        File file=new File(directory,serverName);
        if (file.exists()) {
          return file;
        }
      }
    }
  }
  return null;
}"
52060,"private void updateDescription(IStatus status){
  if (status.isOK() && existingInstanceButton != null && existingInstanceButton.getSelection()) {
    File directory=getInstanceDirectory();
    if (directory != null) {
      File libDirectory=new File(directory,""String_Node_Str"");
      if (new File(libDirectory,""String_Node_Str"").exists()) {
        descriptionLabel.setText(""String_Node_Str"");
      }
 else {
        descriptionLabel.setText(""String_Node_Str"");
      }
      return;
    }
  }
  descriptionLabel.setText(""String_Node_Str"");
}","private void updateDescription(IStatus status){
  if (status.isOK() && existingInstanceButton != null && existingInstanceButton.getSelection()) {
    File directory=TcServerUtil.getInstanceDirectory((ServerWorkingCopy)wc);
    if (directory != null) {
      File libDirectory=new File(directory,""String_Node_Str"");
      if (new File(libDirectory,""String_Node_Str"").exists()) {
        descriptionLabel.setText(""String_Node_Str"");
      }
 else {
        descriptionLabel.setText(""String_Node_Str"");
      }
      return;
    }
  }
  descriptionLabel.setText(""String_Node_Str"");
}"
52061,"private void initialize(){
  existingInstanceButton.setEnabled(false);
  if (wc != null && serverNameCombo != null) {
    serverNameCombo.removeAll();
    IPath path=wc.getRuntime().getLocation();
    File file=new File(path.toFile(),SERVER_PATH);
    if (file.exists()) {
      File[] serverDirectories=file.listFiles();
      if (serverDirectories != null) {
        for (        File directory : serverDirectories) {
          if (directory.isDirectory() && new File(directory,""String_Node_Str"").exists()) {
            serverNameCombo.add(directory.getName());
          }
        }
      }
    }
    existingInstanceButton.setEnabled(true);
  }
}","private void initialize(){
  existingInstanceButton.setEnabled(false);
  if (wc != null && serverNameCombo != null) {
    serverNameCombo.removeAll();
    IPath path=wc.getRuntime().getLocation();
    File file=path.toFile();
    if (file.exists()) {
      File[] serverDirectories=file.listFiles();
      if (serverDirectories != null) {
        for (        File directory : serverDirectories) {
          if (directory.isDirectory() && new File(directory,""String_Node_Str"").exists()) {
            serverNameCombo.add(directory.getName());
          }
        }
      }
    }
    existingInstanceButton.setEnabled(true);
  }
}"
52062,"private IStatus doValidate(){
  if (newInstanceButton != null && newInstanceButton.getSelection()) {
    return Status.OK_STATUS;
  }
  if (((ServerWorkingCopy)wc).getAttribute(TcServer.KEY_SERVER_NAME,(String)null) == null && ((ServerWorkingCopy)wc).getAttribute(ITomcatServer.PROPERTY_INSTANCE_DIR,(String)null) == null) {
    return new Status(IStatus.INFO,ITcServerConstants.PLUGIN_ID,SELECT_INSTANCE_MESSAGE);
  }
  String tomcatVersion=TcServerUtil.getServerVersion(wc.getRuntime());
  if (tomcatVersion == null) {
    return new Status(IStatus.ERROR,ITcServerConstants.PLUGIN_ID,ILNVALID_SERVER_RUNTIME_SELECTED);
  }
  File file=getInstanceDirectory();
  if (file != null && file.exists()) {
    IStatus status=TcServerUtil.validateInstance(file,true);
    String instanceTomcatVersion=TcServerUtil.getInstanceTomcatVersion(file);
    if (status.isOK() && instanceTomcatVersion == null) {
      status=new Status(IStatus.WARNING,ITcServerConstants.PLUGIN_ID,UNKNOWN_INSTANCE_TOMCAT_VERSION);
    }
    if (status.isOK() && !tomcatVersion.equals(instanceTomcatVersion)) {
      status=new Status(IStatus.WARNING,ITcServerConstants.PLUGIN_ID,MessageFormat.format(TOMCAT_VERSION_MISMATCH,tomcatVersion,instanceTomcatVersion));
    }
    return status;
  }
  return new Status(IStatus.ERROR,ITcServerConstants.PLUGIN_ID,SERVER_DOES_NOT_EXIST_MESSAGE);
}","private IStatus doValidate(){
  if (newInstanceButton != null && newInstanceButton.getSelection()) {
    return Status.OK_STATUS;
  }
  ServerWorkingCopy workingCopy=(ServerWorkingCopy)wc;
  if (workingCopy.getAttribute(TcServer.KEY_SERVER_NAME,(String)null) == null && workingCopy.getAttribute(ITomcatServer.PROPERTY_INSTANCE_DIR,(String)null) == null) {
    return new Status(IStatus.INFO,ITcServerConstants.PLUGIN_ID,SELECT_INSTANCE_MESSAGE);
  }
  String tomcatVersion=TcServerUtil.getServerVersion(wc.getRuntime());
  if (tomcatVersion == null) {
    return new Status(IStatus.ERROR,ITcServerConstants.PLUGIN_ID,ILNVALID_SERVER_RUNTIME_SELECTED);
  }
  File file=TcServerUtil.getInstanceDirectory(workingCopy);
  if (file != null && file.exists()) {
    IStatus status=TcServerUtil.validateInstance(file,true);
    String instanceTomcatVersion=TcServerUtil.getInstanceTomcatVersion(file);
    if (status.isOK() && instanceTomcatVersion == null) {
      status=new Status(IStatus.ERROR,ITcServerConstants.PLUGIN_ID,Messages.UNKNOWN_INSTANCE_TOMCAT_VERSION);
    }
    if (status.isOK() && !tomcatVersion.equals(instanceTomcatVersion)) {
      status=new Status(IStatus.WARNING,ITcServerConstants.PLUGIN_ID,MessageFormat.format(Messages.TOMCAT_VERSION_MISMATCH,tomcatVersion,instanceTomcatVersion));
    }
    return status;
  }
  return new Status(IStatus.ERROR,ITcServerConstants.PLUGIN_ID,SERVER_DOES_NOT_EXIST_MESSAGE);
}"
52063,"protected void validate(){
  if (!newInstanceButton.getSelection() && serverNameCombo.getText().length() == 0) {
    wizard.setMessage(SPECIFY_TC_SERVER_INSTANCE_MESSAGE,IMessageProvider.NONE);
    setComplete(false);
    return;
  }
  if (wc == null) {
    wizard.setMessage(""String_Node_Str"",IMessageProvider.ERROR);
    setComplete(false);
    return;
  }
  IStatus status=doValidate();
  if (status == null || status.isOK()) {
    wizard.setMessage(null,IMessageProvider.NONE);
    setComplete(true);
  }
 else   if (status.getSeverity() == IStatus.INFO) {
    wizard.setMessage(status.getMessage(),IMessageProvider.NONE);
    setComplete(false);
  }
 else   if (status.getSeverity() == IStatus.WARNING) {
    wizard.setMessage(status.getMessage(),IMessageProvider.WARNING);
    setComplete(false);
  }
 else {
    wizard.setMessage(status.getMessage(),IMessageProvider.ERROR);
    setComplete(false);
  }
  updateDescription(status);
  wizard.update();
}","protected void validate(){
  if (!newInstanceButton.getSelection() && serverNameCombo.getText().length() == 0) {
    wizard.setMessage(SPECIFY_TC_SERVER_INSTANCE_MESSAGE,IMessageProvider.NONE);
    setComplete(false);
    return;
  }
  if (wc == null) {
    wizard.setMessage(""String_Node_Str"",IMessageProvider.ERROR);
    setComplete(false);
    return;
  }
  IStatus status=doValidate();
  if (status == null || status.isOK()) {
    wizard.setMessage(null,IMessageProvider.NONE);
    setComplete(true);
  }
 else   if (status.getSeverity() == IStatus.INFO) {
    wizard.setMessage(status.getMessage(),IMessageProvider.NONE);
    setComplete(false);
  }
 else   if (status.getSeverity() == IStatus.WARNING) {
    wizard.setMessage(status.getMessage(),IMessageProvider.WARNING);
    setComplete(true);
  }
 else {
    wizard.setMessage(status.getMessage(),IMessageProvider.ERROR);
    setComplete(false);
  }
  updateDescription(status);
  wizard.update();
}"
52064,"/** 
 * Initialize the fields in this editor.
 */
protected void initialize(){
  if (serverNameLabel == null) {
    return;
  }
  if (serverInstance.isAsfLayout()) {
    infoLabel.setText(""String_Node_Str"");
    serverNameLabel.setText(""String_Node_Str"");
  }
 else {
    String serverName=serverInstance.getServerName();
    infoLabel.setText(""String_Node_Str"");
    serverNameLabel.setText(serverName + ""String_Node_Str"" + serverInstance.getLayout().toString()+ ""String_Node_Str"");
  }
}","/** 
 * Initialize the fields in this editor.
 */
protected void initialize(){
  if (serverNameLabel == null) {
    return;
  }
  if (serverInstance.isAsfLayout()) {
    infoLabel.setText(""String_Node_Str"");
    serverNameLabel.setText(""String_Node_Str"");
  }
 else {
    String serverName=serverInstance.getServerName();
    infoLabel.setText(""String_Node_Str"");
    serverNameLabel.setText(serverName + ""String_Node_Str"" + serverInstance.getLayout().toString()+ ""String_Node_Str"");
  }
  addChangeListeners();
}"
52065,"@Test public void testOrderDetailsValidation(){
  List<OrderSubmitProduct> products=new ArrayList<OrderSubmitProduct>();
  OrderSubmit orderSubmit=new OrderSubmit();
  int totalPrice=600;
  int productPrice=300;
  int quantity=0;
  int productId=0;
  try {
    PhrescoLogger.info(TAG + ""String_Node_Str"");
    orderSubmit.setComments(""String_Node_Str"");
    orderSubmit.setCustomerInfo(getCustomerInfo());
    orderSubmit.setPaymentMethod(""String_Node_Str"");
    orderSubmit.setTotalPrice(totalPrice);
    OrderSubmitProduct orderSubmitProduct=new OrderSubmitProduct();
    productId=1;
    orderSubmitProduct.setProductId(productId);
    orderSubmitProduct.setName(""String_Node_Str"");
    orderSubmitProduct.setPrice(productPrice);
    orderSubmitProduct.setImageURL(""String_Node_Str"");
    orderSubmitProduct.setDetailImageURL(""String_Node_Str"");
    quantity=1;
    orderSubmitProduct.setQuantity(quantity);
    orderSubmitProduct.setTotalPrice(totalPrice);
    products.add(orderSubmitProduct);
    orderSubmit.setProducts(products);
    if (totalPrice == (quantity * productPrice)) {
      assertEquals(""String_Node_Str"",600,600);
    }
 else {
      assertNotSame(""String_Node_Str"",600,250);
    }
    Gson jsonObj=new Gson();
    String orderDetail=jsonObj.toJson(orderSubmit);
    PhrescoLogger.info(TAG + ""String_Node_Str"" + orderDetail);
    Order orderObj=new Order();
    JSONObject jObject=null;
    PhrescoLogger.info(TAG + Constants.getWebContextURL() + Constants.getRestAPI()+ Constants.ORDER_POST_URL);
    jObject=orderObj.postOrderJSONObject(Constants.getWebContextURL() + Constants.getRestAPI() + Constants.ORDER_POST_URL,orderDetail);
    assertNotNull(jObject);
    PhrescoLogger.info(TAG + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
}","@Test public void testOrderDetailsValidation() throws Exception {
  List<OrderSubmitProduct> products=new ArrayList<OrderSubmitProduct>();
  OrderSubmit orderSubmit=new OrderSubmit();
  int totalPrice=600;
  int productPrice=300;
  int quantity=0;
  int productId=0;
  try {
    PhrescoLogger.info(TAG + ""String_Node_Str"");
    orderSubmit.setComments(""String_Node_Str"");
    orderSubmit.setCustomerInfo(getCustomerInfo());
    orderSubmit.setPaymentMethod(""String_Node_Str"");
    orderSubmit.setTotalPrice(totalPrice);
    OrderSubmitProduct orderSubmitProduct=new OrderSubmitProduct();
    productId=1;
    orderSubmitProduct.setProductId(productId);
    orderSubmitProduct.setName(""String_Node_Str"");
    orderSubmitProduct.setPrice(productPrice);
    orderSubmitProduct.setImageURL(""String_Node_Str"");
    orderSubmitProduct.setDetailImageURL(""String_Node_Str"");
    quantity=1;
    orderSubmitProduct.setQuantity(quantity);
    orderSubmitProduct.setTotalPrice(totalPrice);
    products.add(orderSubmitProduct);
    orderSubmit.setProducts(products);
    if (totalPrice == (quantity * productPrice)) {
      assertEquals(""String_Node_Str"",600,600);
    }
 else {
      assertNotSame(""String_Node_Str"",600,250);
    }
    Gson jsonObj=new Gson();
    String orderDetail=jsonObj.toJson(orderSubmit);
    PhrescoLogger.info(TAG + ""String_Node_Str"" + orderDetail);
    Order orderObj=new Order();
    JSONObject jObject=null;
    PhrescoLogger.info(TAG + Constants.getWebContextURL() + Constants.getRestAPI()+ Constants.ORDER_POST_URL);
    jObject=orderObj.postOrderJSONObject(Constants.getWebContextURL() + Constants.getRestAPI() + Constants.ORDER_POST_URL,orderDetail);
    assertNotNull(jObject);
    PhrescoLogger.info(TAG + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
}"
52066,"@Test public void testOrderDetails(){
  List<OrderSubmitProduct> products=new ArrayList<OrderSubmitProduct>();
  OrderSubmit orderSubmit=new OrderSubmit();
  int totalPrice=629;
  int quantity=0;
  int productId=0;
  try {
    PhrescoLogger.info(TAG + ""String_Node_Str"");
    orderSubmit.setComments(""String_Node_Str"");
    orderSubmit.setCustomerInfo(getCustomerInfo());
    orderSubmit.setPaymentMethod(""String_Node_Str"");
    orderSubmit.setTotalPrice(totalPrice);
    OrderSubmitProduct orderSubmitProduct=new OrderSubmitProduct();
    productId=1;
    orderSubmitProduct.setProductId(productId);
    orderSubmitProduct.setName(""String_Node_Str"");
    orderSubmitProduct.setPrice(totalPrice);
    orderSubmitProduct.setImageURL(""String_Node_Str"");
    orderSubmitProduct.setDetailImageURL(""String_Node_Str"");
    quantity=1;
    orderSubmitProduct.setQuantity(quantity);
    orderSubmitProduct.setTotalPrice(totalPrice);
    products.add(orderSubmitProduct);
    orderSubmit.setProducts(products);
    Gson jsonObj=new Gson();
    String orderDetail=jsonObj.toJson(orderSubmit);
    PhrescoLogger.info(TAG + ""String_Node_Str"" + orderDetail);
    Order orderObj=new Order();
    JSONObject jObject=null;
    PhrescoLogger.info(TAG + Constants.getWebContextURL() + Constants.getRestAPI()+ Constants.ORDER_POST_URL);
    jObject=orderObj.postOrderJSONObject(Constants.getWebContextURL() + Constants.getRestAPI() + Constants.ORDER_POST_URL,orderDetail);
    assertNotNull(jObject);
    PhrescoLogger.info(TAG + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
}","@Test public void testOrderDetails() throws Exception {
  List<OrderSubmitProduct> products=new ArrayList<OrderSubmitProduct>();
  OrderSubmit orderSubmit=new OrderSubmit();
  int totalPrice=629;
  int quantity=0;
  int productId=0;
  try {
    PhrescoLogger.info(TAG + ""String_Node_Str"");
    orderSubmit.setComments(""String_Node_Str"");
    orderSubmit.setCustomerInfo(getCustomerInfo());
    orderSubmit.setPaymentMethod(""String_Node_Str"");
    orderSubmit.setTotalPrice(totalPrice);
    OrderSubmitProduct orderSubmitProduct=new OrderSubmitProduct();
    productId=1;
    orderSubmitProduct.setProductId(productId);
    orderSubmitProduct.setName(""String_Node_Str"");
    orderSubmitProduct.setPrice(totalPrice);
    orderSubmitProduct.setImageURL(""String_Node_Str"");
    orderSubmitProduct.setDetailImageURL(""String_Node_Str"");
    quantity=1;
    orderSubmitProduct.setQuantity(quantity);
    orderSubmitProduct.setTotalPrice(totalPrice);
    products.add(orderSubmitProduct);
    orderSubmit.setProducts(products);
    Gson jsonObj=new Gson();
    String orderDetail=jsonObj.toJson(orderSubmit);
    PhrescoLogger.info(TAG + ""String_Node_Str"" + orderDetail);
    Order orderObj=new Order();
    JSONObject jObject=null;
    PhrescoLogger.info(TAG + Constants.getWebContextURL() + Constants.getRestAPI()+ Constants.ORDER_POST_URL);
    jObject=orderObj.postOrderJSONObject(Constants.getWebContextURL() + Constants.getRestAPI() + Constants.ORDER_POST_URL,orderDetail);
    assertNotNull(jObject);
    PhrescoLogger.info(TAG + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
}"
52067,"/** 
 * send valid login email id and password to web server
 */
@Test public final void testLoginCredantial(){
  JSONObject jObjMain=new JSONObject();
  JSONObject jObj=new JSONObject();
  try {
    PhrescoLogger.info(TAG + ""String_Node_Str"");
    jObj.put(""String_Node_Str"",""String_Node_Str"");
    jObj.put(""String_Node_Str"",""String_Node_Str"");
    jObjMain.put(""String_Node_Str"",jObj);
    JSONObject responseJSON=null;
    responseJSON=JSONHelper.postJSONObjectToURL(Constants.getWebContextURL() + Constants.getRestAPI() + Constants.LOGIN_POST_URL,jObjMain.toString());
    assertNotNull(""String_Node_Str"",responseJSON.length() > 0);
    PhrescoLogger.info(TAG + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
catch (  JSONException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
}","/** 
 * send valid login email id and password to web server
 */
@Test public final void testLoginCredantial() throws Exception {
  JSONObject jObjMain=new JSONObject();
  JSONObject jObj=new JSONObject();
  try {
    PhrescoLogger.info(TAG + ""String_Node_Str"");
    jObj.put(""String_Node_Str"",""String_Node_Str"");
    jObj.put(""String_Node_Str"",""String_Node_Str"");
    jObjMain.put(""String_Node_Str"",jObj);
    JSONObject responseJSON=null;
    responseJSON=JSONHelper.postJSONObjectToURL(Constants.getWebContextURL() + Constants.getRestAPI() + Constants.LOGIN_POST_URL,jObjMain.toString());
    assertNotNull(""String_Node_Str"",responseJSON.length() > 0);
    PhrescoLogger.info(TAG + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
catch (  JSONException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
}"
52068,"/** 
 * send valid login email id and password to web server
 */
@Test public final void testLogin(){
  JSONObject jObjMain=new JSONObject();
  JSONObject jObj=new JSONObject();
  try {
    PhrescoLogger.info(TAG + ""String_Node_Str"");
    jObj.put(""String_Node_Str"",""String_Node_Str"");
    jObj.put(""String_Node_Str"",""String_Node_Str"");
    jObjMain.put(""String_Node_Str"",jObj);
    JSONObject responseJSON=null;
    responseJSON=JSONHelper.postJSONObjectToURL(Constants.getWebContextURL() + Constants.getRestAPI() + Constants.LOGIN_POST_URL,jObjMain.toString());
    assertNotNull(""String_Node_Str"",responseJSON.length() > 0);
    PhrescoLogger.info(TAG + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
catch (  JSONException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
}","/** 
 * send valid login email id and password to web server
 */
@Test public final void testLogin() throws Exception {
  JSONObject jObjMain=new JSONObject();
  JSONObject jObj=new JSONObject();
  try {
    PhrescoLogger.info(TAG + ""String_Node_Str"");
    jObj.put(""String_Node_Str"",""String_Node_Str"");
    jObj.put(""String_Node_Str"",""String_Node_Str"");
    jObjMain.put(""String_Node_Str"",jObj);
    JSONObject responseJSON=null;
    responseJSON=JSONHelper.postJSONObjectToURL(Constants.getWebContextURL() + Constants.getRestAPI() + Constants.LOGIN_POST_URL,jObjMain.toString());
    assertNotNull(""String_Node_Str"",responseJSON.length() > 0);
    PhrescoLogger.info(TAG + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
catch (  JSONException ex) {
    PhrescoLogger.info(TAG + ""String_Node_Str"" + ex.toString());
    PhrescoLogger.warning(ex);
  }
}"
52069,"/** 
 * Shows the next SuperActivityToast in the list. Called by add() and when the dismiss animation of a previously showing SuperActivityToast ends. 
 */
private void showNextSuperToast(){
  final SuperActivityToast superActivityToast=mList.peek();
  if (mList.isEmpty() || superActivityToast.getActivity() == null) {
    return;
  }
  if (superActivityToast.getType() == SuperToast.Type.PROGRESS_HORIZONTAL) {
    if (superActivityToast.getProgress() == superActivityToast.getMaxProgress()) {
      mList.remove(superActivityToast);
      this.showNextSuperToast();
      return;
    }
  }
  if (!superActivityToast.isShowing()) {
    final Message message=obtainMessage(Messages.DISPLAY);
    message.obj=superActivityToast;
    sendMessage(message);
  }
}","/** 
 * Shows the next SuperActivityToast in the list. Called by add() and when the dismiss animation of a previously showing SuperActivityToast ends. 
 */
private void showNextSuperToast(){
  final SuperActivityToast superActivityToast=mList.peek();
  if (mList.isEmpty() || superActivityToast.getActivity() == null) {
    return;
  }
  if (!superActivityToast.isShowing()) {
    final Message message=obtainMessage(Messages.DISPLAY);
    message.obj=superActivityToast;
    sendMessage(message);
  }
}"
52070,"/** 
 * Hide and remove the SuperActivityToast 
 */
void removeSuperToast(final SuperActivityToast superActivityToast){
  if (!superActivityToast.isShowing()) {
    return;
  }
  removeMessages(Messages.REMOVE,superActivityToast);
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    Animation animation=getDismissAnimation(superActivityToast);
    animation.setAnimationListener(new Animation.AnimationListener(){
      @Override public void onAnimationStart(      Animation animation){
      }
      @Override public void onAnimationEnd(      Animation animation){
        if (superActivityToast.getOnDismissWrapper() != null) {
          superActivityToast.getOnDismissWrapper().onDismiss(superActivityToast.getView());
        }
        ManagerSuperActivityToast.this.showNextSuperToast();
      }
      @Override public void onAnimationRepeat(      Animation animation){
      }
    }
);
    toastView.startAnimation(animation);
    viewGroup.removeView(toastView);
    mList.poll();
  }
}","/** 
 * Hide and remove the SuperActivityToast 
 */
void removeSuperToast(final SuperActivityToast superActivityToast){
  if (!superActivityToast.isShowing()) {
    mList.remove(superActivityToast);
    return;
  }
  removeMessages(Messages.REMOVE,superActivityToast);
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    Animation animation=getDismissAnimation(superActivityToast);
    animation.setAnimationListener(new Animation.AnimationListener(){
      @Override public void onAnimationStart(      Animation animation){
      }
      @Override public void onAnimationEnd(      Animation animation){
        if (superActivityToast.getOnDismissWrapper() != null) {
          superActivityToast.getOnDismissWrapper().onDismiss(superActivityToast.getView());
        }
        ManagerSuperActivityToast.this.showNextSuperToast();
      }
      @Override public void onAnimationRepeat(      Animation animation){
      }
    }
);
    toastView.startAnimation(animation);
    viewGroup.removeView(toastView);
    mList.poll();
  }
}"
52071,"/** 
 * Shows the next SuperActivityToast in the list. Called by add() and when the dismiss animation of a previously showing SuperActivityToast ends. 
 */
private void showNextSuperToast(){
  final SuperActivityToast superActivityToast=mList.peek();
  if (mList.isEmpty() || superActivityToast.getActivity() == null) {
    return;
  }
  if (!superActivityToast.isShowing()) {
    final Message message=obtainMessage(Messages.DISPLAY);
    message.obj=superActivityToast;
    sendMessage(message);
  }
}","/** 
 * Shows the next SuperActivityToast in the list. Called by add() and when the dismiss animation of a previously showing SuperActivityToast ends. 
 */
private void showNextSuperToast(){
  final SuperActivityToast superActivityToast=mList.peek();
  if (mList.isEmpty() || superActivityToast.getActivity() == null) {
    return;
  }
  if (superActivityToast.getType() == SuperToast.Type.PROGRESS_HORIZONTAL) {
    if (superActivityToast.getProgress() == superActivityToast.getMaxProgress()) {
      mList.remove(superActivityToast);
      this.showNextSuperToast();
      return;
    }
  }
  if (!superActivityToast.isShowing()) {
    final Message message=obtainMessage(Messages.DISPLAY);
    message.obj=superActivityToast;
    sendMessage(message);
  }
}"
52072,"/** 
 * Hide and remove the SuperActivityToast 
 */
void removeSuperToast(final SuperActivityToast superActivityToast){
  removeMessages(Messages.REMOVE);
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    Animation animation=getDismissAnimation(superActivityToast);
    animation.setAnimationListener(new Animation.AnimationListener(){
      @Override public void onAnimationStart(      Animation animation){
      }
      @Override public void onAnimationEnd(      Animation animation){
        if (superActivityToast.getOnDismissWrapper() != null) {
          superActivityToast.getOnDismissWrapper().onDismiss(superActivityToast.getView());
        }
        ManagerSuperActivityToast.this.showNextSuperToast();
      }
      @Override public void onAnimationRepeat(      Animation animation){
      }
    }
);
    toastView.startAnimation(animation);
    viewGroup.removeView(toastView);
    mList.poll();
  }
}","/** 
 * Hide and remove the SuperActivityToast 
 */
void removeSuperToast(final SuperActivityToast superActivityToast){
  if (!superActivityToast.isShowing()) {
    return;
  }
  removeMessages(Messages.REMOVE,superActivityToast);
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    Animation animation=getDismissAnimation(superActivityToast);
    animation.setAnimationListener(new Animation.AnimationListener(){
      @Override public void onAnimationStart(      Animation animation){
      }
      @Override public void onAnimationEnd(      Animation animation){
        if (superActivityToast.getOnDismissWrapper() != null) {
          superActivityToast.getOnDismissWrapper().onDismiss(superActivityToast.getView());
        }
        ManagerSuperActivityToast.this.showNextSuperToast();
      }
      @Override public void onAnimationRepeat(      Animation animation){
      }
    }
);
    toastView.startAnimation(animation);
    viewGroup.removeView(toastView);
    mList.poll();
  }
}"
52073,"void add(SuperActivityToast superActivityToast){
  mList.add(superActivityToast);
  this.showNextSuperToast();
}","/** 
 * Add a SuperActivityToast to the list. Will show immediately if no other SuperActivityToasts are in the list. 
 */
void add(SuperActivityToast superActivityToast){
  mList.add(superActivityToast);
  this.showNextSuperToast();
}"
52074,"private Animation getShowAnimation(SuperActivityToast superActivityToast){
  if (superActivityToast.getAnimations() == SuperToast.Animations.FLYIN) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.75f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.SCALE) {
    ScaleAnimation scaleAnimation=new ScaleAnimation(0.9f,1.0f,0.9f,1.0f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(scaleAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.POPUP) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.1f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else {
    Animation animation=new AlphaAnimation(0f,1f);
    animation.setDuration(500);
    animation.setInterpolator(new DecelerateInterpolator());
    return animation;
  }
}","/** 
 * Returns an animation based on the   {@link com.github.johnpersano.supertoasts.SuperToast.Animations} enums 
 */
private Animation getShowAnimation(SuperActivityToast superActivityToast){
  if (superActivityToast.getAnimations() == SuperToast.Animations.FLYIN) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.75f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.SCALE) {
    ScaleAnimation scaleAnimation=new ScaleAnimation(0.9f,1.0f,0.9f,1.0f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(scaleAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.POPUP) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.1f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else {
    Animation animation=new AlphaAnimation(0f,1f);
    animation.setDuration(500);
    animation.setInterpolator(new DecelerateInterpolator());
    return animation;
  }
}"
52075,"private Animation getDismissAnimation(SuperActivityToast superActivityToast){
  if (superActivityToast.getAnimations() == SuperToast.Animations.FLYIN) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,.75f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new AccelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.SCALE) {
    ScaleAnimation scaleAnimation=new ScaleAnimation(1.0f,0.9f,1.0f,0.9f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(scaleAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.POPUP) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.1f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else {
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    alphaAnimation.setDuration(500);
    alphaAnimation.setInterpolator(new AccelerateInterpolator());
    return alphaAnimation;
  }
}","/** 
 * Returns an animation based on the   {@link com.github.johnpersano.supertoasts.SuperToast.Animations} enums 
 */
private Animation getDismissAnimation(SuperActivityToast superActivityToast){
  if (superActivityToast.getAnimations() == SuperToast.Animations.FLYIN) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,.75f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new AccelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.SCALE) {
    ScaleAnimation scaleAnimation=new ScaleAnimation(1.0f,0.9f,1.0f,0.9f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(scaleAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.POPUP) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.1f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else {
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    alphaAnimation.setDuration(500);
    alphaAnimation.setInterpolator(new AccelerateInterpolator());
    return alphaAnimation;
  }
}"
52076,"private void showNextSuperToast(){
  final SuperActivityToast superActivityToast=mList.peek();
  if (mList.isEmpty() || superActivityToast.getActivity() == null) {
    return;
  }
  if (!superActivityToast.isShowing()) {
    final Message message=obtainMessage(Messages.DISPLAY);
    message.obj=superActivityToast;
    sendMessage(message);
  }
}","/** 
 * Shows the next SuperActivityToast in the list. Called by add() and when the dismiss animation of a previously showing SuperActivityToast ends. 
 */
private void showNextSuperToast(){
  final SuperActivityToast superActivityToast=mList.peek();
  if (mList.isEmpty() || superActivityToast.getActivity() == null) {
    return;
  }
  if (!superActivityToast.isShowing()) {
    final Message message=obtainMessage(Messages.DISPLAY);
    message.obj=superActivityToast;
    sendMessage(message);
  }
}"
52077,"private void displaySuperToast(SuperActivityToast superActivityToast){
  if (superActivityToast.isShowing()) {
    return;
  }
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    try {
      viewGroup.addView(toastView);
      if (!superActivityToast.getShowImmediate()) {
        toastView.startAnimation(getShowAnimation(superActivityToast));
      }
    }
 catch (    IllegalStateException e) {
      Log.e(TAG,e.toString());
      clearSuperActivityToastsForActivity(superActivityToast.getActivity());
    }
  }
  if (!superActivityToast.isIndeterminate()) {
    Message message=obtainMessage(Messages.REMOVE);
    message.obj=superActivityToast;
    sendMessageDelayed(message,superActivityToast.getDuration() + getShowAnimation(superActivityToast).getDuration());
  }
}","/** 
 * Displays a SuperActivityToast 
 */
private void displaySuperToast(SuperActivityToast superActivityToast){
  if (superActivityToast.isShowing()) {
    return;
  }
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    try {
      viewGroup.addView(toastView);
      if (!superActivityToast.getShowImmediate()) {
        toastView.startAnimation(getShowAnimation(superActivityToast));
      }
    }
 catch (    IllegalStateException e) {
      this.cancelAllSuperActivityToastsForActivity(superActivityToast.getActivity());
    }
  }
  if (!superActivityToast.isIndeterminate()) {
    Message message=obtainMessage(Messages.REMOVE);
    message.obj=superActivityToast;
    sendMessageDelayed(message,superActivityToast.getDuration() + getShowAnimation(superActivityToast).getDuration());
  }
}"
52078,"@Override public void onAnimationEnd(Animation animation){
  if (superActivityToast.getOnDismissListenerWrapper() != null) {
    superActivityToast.getOnDismissListenerWrapper().onDismiss(superActivityToast.getView());
  }
  ManagerSuperActivityToast.this.showNextSuperToast();
}","@Override public void onAnimationEnd(Animation animation){
  if (superActivityToast.getOnDismissWrapper() != null) {
    superActivityToast.getOnDismissWrapper().onDismiss(superActivityToast.getView());
  }
  ManagerSuperActivityToast.this.showNextSuperToast();
}"
52079,"LinkedList<SuperActivityToast> getList(){
  return mList;
}","/** 
 * Used in SuperActivityToast saveState() 
 */
LinkedList<SuperActivityToast> getList(){
  return mList;
}"
52080,"private ManagerSuperActivityToast(){
  mList=new LinkedList<SuperActivityToast>();
}","/** 
 * Private method to create a new list if the manager is being initialized 
 */
private ManagerSuperActivityToast(){
  mList=new LinkedList<SuperActivityToast>();
}"
52081,"static synchronized ManagerSuperActivityToast getInstance(){
  if (mManagerSuperActivityToast != null) {
    return mManagerSuperActivityToast;
  }
 else {
    mManagerSuperActivityToast=new ManagerSuperActivityToast();
    return mManagerSuperActivityToast;
  }
}","/** 
 * Singleton method to ensure all SuperActivityToasts are passed through the same manager 
 */
static synchronized ManagerSuperActivityToast getInstance(){
  if (mManagerSuperActivityToast != null) {
    return mManagerSuperActivityToast;
  }
 else {
    mManagerSuperActivityToast=new ManagerSuperActivityToast();
    return mManagerSuperActivityToast;
  }
}"
52082,"void removeSuperToast(final SuperActivityToast superActivityToast){
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    Animation animation=getDismissAnimation(superActivityToast);
    animation.setAnimationListener(new Animation.AnimationListener(){
      @Override public void onAnimationStart(      Animation animation){
      }
      @Override public void onAnimationEnd(      Animation animation){
        if (superActivityToast.getOnDismissListenerWrapper() != null) {
          superActivityToast.getOnDismissListenerWrapper().onDismiss(superActivityToast.getView());
        }
        ManagerSuperActivityToast.this.showNextSuperToast();
      }
      @Override public void onAnimationRepeat(      Animation animation){
      }
    }
);
    toastView.startAnimation(animation);
    viewGroup.removeView(toastView);
    mList.poll();
  }
}","/** 
 * Hide and remove the SuperActivityToast 
 */
void removeSuperToast(final SuperActivityToast superActivityToast){
  removeMessages(Messages.REMOVE);
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    Animation animation=getDismissAnimation(superActivityToast);
    animation.setAnimationListener(new Animation.AnimationListener(){
      @Override public void onAnimationStart(      Animation animation){
      }
      @Override public void onAnimationEnd(      Animation animation){
        if (superActivityToast.getOnDismissWrapper() != null) {
          superActivityToast.getOnDismissWrapper().onDismiss(superActivityToast.getView());
        }
        ManagerSuperActivityToast.this.showNextSuperToast();
      }
      @Override public void onAnimationRepeat(      Animation animation){
      }
    }
);
    toastView.startAnimation(animation);
    viewGroup.removeView(toastView);
    mList.poll();
  }
}"
52083,"/** 
 * Sets the duration that the   {@value #TAG} will show.
 * @param duration {@link com.github.johnpersano.supertoasts.SuperToast.Duration}
 */
public void setDuration(int duration){
  if (duration > 7000) {
    Log.w(TAG,TAG + WARNING_DURATIONTOOLONG);
    this.mDuration=Duration.EXTRA_LONG;
  }
 else {
    this.mDuration=duration;
  }
}","/** 
 * Sets the duration that the   {@value #TAG} will show.
 * @param duration {@link com.github.johnpersano.supertoasts.SuperToast.Duration}
 */
public void setDuration(int duration){
  if (duration > Duration.EXTRA_LONG) {
    Log.e(TAG,TAG + ERROR_DURATIONTOOLONG);
    this.mDuration=Duration.EXTRA_LONG;
  }
 else {
    this.mDuration=duration;
  }
}"
52084,"/** 
 * Returns a dark themed   {@value #TAG} with specified animations.
 * @param context          {@link android.content.Context}
 * @param textCharSequence {@link java.lang.CharSequence}
 * @param durationInteger  {@link com.github.johnpersano.supertoasts.SuperToast.Duration}
 * @param animations       {@link com.github.johnpersano.supertoasts.SuperToast.Animations}
 * @return {@link com.github.johnpersano.supertoasts.SuperToast}
 */
public static SuperToast createSuperToast(Context context,CharSequence textCharSequence,int durationInteger,Animations animations){
  SuperToast superToast=new SuperToast(context);
  superToast.setText(textCharSequence);
  superToast.setDuration(durationInteger);
  superToast.setAnimations(animations);
  return superToast;
}","/** 
 * Returns a   {@value #TAG} with a specified style.
 * @param context          {@link android.content.Context}
 * @param textCharSequence {@link java.lang.CharSequence}
 * @param durationInteger  {@link com.github.johnpersano.supertoasts.SuperToast.Duration}
 * @param style            {@link com.github.johnpersano.supertoasts.util.Style}
 * @return SuperCardToast
 */
public static SuperToast createSuperToast(Context context,CharSequence textCharSequence,int durationInteger,Style style){
  final SuperToast superToast=new SuperToast(context);
  superToast.setText(textCharSequence);
  superToast.setDuration(durationInteger);
  superToast.setStyle(style);
  return superToast;
}"
52085,"/** 
 * Instantiates a new   {@value #TAG} with a specified default style.
 * @param context      {@link android.content.Context}
 * @param defaultStyle {@link com.github.johnpersano.supertoasts.util.DefaultStyle}
 */
public SuperToast(Context context,DefaultStyle defaultStyle){
  if (context == null) {
    throw new IllegalArgumentException(TAG + ERROR_CONTEXTNULL);
  }
  this.mContext=context;
  mYOffset=context.getResources().getDimensionPixelSize(R.dimen.toast_yoffset);
  final LayoutInflater layoutInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mToastView=layoutInflater.inflate(R.layout.supertoast,null);
  mWindowManager=(WindowManager)mToastView.getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
  mRootLayout=(LinearLayout)mToastView.findViewById(R.id.root_layout);
  mMessageTextView=(TextView)mToastView.findViewById(R.id.message_textView);
  this.setDefaultStyle(defaultStyle);
}","/** 
 * Instantiates a new   {@value #TAG} with a specified style.
 * @param context {@link android.content.Context}
 * @param style   {@link com.github.johnpersano.supertoasts.util.Style}
 */
public SuperToast(Context context,Style style){
  if (context == null) {
    throw new IllegalArgumentException(TAG + ERROR_CONTEXTNULL);
  }
  this.mContext=context;
  mYOffset=context.getResources().getDimensionPixelSize(R.dimen.toast_yoffset);
  final LayoutInflater layoutInflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  mToastView=layoutInflater.inflate(R.layout.supertoast,null);
  mWindowManager=(WindowManager)mToastView.getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
  mRootLayout=(LinearLayout)mToastView.findViewById(R.id.root_layout);
  mMessageTextView=(TextView)mToastView.findViewById(R.id.message_textView);
  this.setStyle(style);
}"
52086,"/** 
 * Sets the gravity of the   {@value #TAG}.
 * @param gravity U{@link android.view.Gravity} int
 */
public void setGravity(int gravity){
  this.mGravity=gravity;
}","/** 
 * Sets the gravity of the   {@value #TAG} along with x and y offsets.
 * @param gravity {@link android.view.Gravity} int
 * @param xOffset int
 * @param yOffset int
 */
public void setGravity(int gravity,int xOffset,int yOffset){
  this.mGravity=gravity;
  this.mXOffset=xOffset;
  this.mYOffset=yOffset;
}"
52087,"@Override public void onAnimationUpdate(ValueAnimator valueAnimator){
  layoutParams.height=(Integer)valueAnimator.getAnimatedValue();
  mToastView.setLayoutParams(layoutParams);
}","@Override public void onAnimationUpdate(ValueAnimator valueAnimator){
  if (mToastView != null) {
    layoutParams.height=(Integer)valueAnimator.getAnimatedValue();
    mToastView.setLayoutParams(layoutParams);
  }
}"
52088,"/** 
 * Hide the SuperCardToast and animate the Layout. Post Honeycomb only. 
 */
@SuppressLint(""String_Node_Str"") private void dismissWithLayoutAnimation(){
  if (mToastView != null) {
    mToastView.setVisibility(View.INVISIBLE);
    final ViewGroup.LayoutParams layoutParams=mToastView.getLayoutParams();
    final int originalHeight=mToastView.getHeight();
    ValueAnimator animator=ValueAnimator.ofInt(originalHeight,1).setDuration(mContext.getResources().getInteger(android.R.integer.config_shortAnimTime));
    animator.addListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        Handler mHandler=new Handler();
        mHandler.post(mHideImmediateRunnable);
      }
    }
);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
      @Override public void onAnimationUpdate(      ValueAnimator valueAnimator){
        layoutParams.height=(Integer)valueAnimator.getAnimatedValue();
        mToastView.setLayoutParams(layoutParams);
      }
    }
);
    animator.start();
  }
 else {
    dismissImmediately();
  }
}","/** 
 * Hide the SuperCardToast and animate the Layout. Post Honeycomb only. 
 */
@SuppressLint(""String_Node_Str"") private void dismissWithLayoutAnimation(){
  if (mToastView != null) {
    mToastView.setVisibility(View.INVISIBLE);
    final ViewGroup.LayoutParams layoutParams=mToastView.getLayoutParams();
    final int originalHeight=mToastView.getHeight();
    ValueAnimator animator=ValueAnimator.ofInt(originalHeight,1).setDuration(mContext.getResources().getInteger(android.R.integer.config_shortAnimTime));
    animator.addListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        Handler mHandler=new Handler();
        mHandler.post(mHideImmediateRunnable);
      }
    }
);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
      @Override public void onAnimationUpdate(      ValueAnimator valueAnimator){
        if (mToastView != null) {
          layoutParams.height=(Integer)valueAnimator.getAnimatedValue();
          mToastView.setLayoutParams(layoutParams);
        }
      }
    }
);
    animator.start();
  }
 else {
    dismissImmediately();
  }
}"
52089,"private Animation getShowAnimation(SuperActivityToast superActivityToast){
  if (superActivityToast.getAnimation() == SuperToast.Animations.FLYIN) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.75f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimation() == SuperToast.Animations.SCALE) {
    ScaleAnimation scaleAnimation=new ScaleAnimation(0.9f,1.0f,0.9f,1.0f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(scaleAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimation() == SuperToast.Animations.POPUP) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.1f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else {
    Animation animation=new AlphaAnimation(0f,1f);
    animation.setDuration(500);
    animation.setInterpolator(new DecelerateInterpolator());
    return animation;
  }
}","private Animation getShowAnimation(SuperActivityToast superActivityToast){
  if (superActivityToast.getAnimations() == SuperToast.Animations.FLYIN) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.75f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.SCALE) {
    ScaleAnimation scaleAnimation=new ScaleAnimation(0.9f,1.0f,0.9f,1.0f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(scaleAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.POPUP) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.1f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(0f,1f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else {
    Animation animation=new AlphaAnimation(0f,1f);
    animation.setDuration(500);
    animation.setInterpolator(new DecelerateInterpolator());
    return animation;
  }
}"
52090,"private Animation getDismissAnimation(SuperActivityToast superActivityToast){
  if (superActivityToast.getAnimation() == SuperToast.Animations.FLYIN) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,.75f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new AccelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimation() == SuperToast.Animations.SCALE) {
    ScaleAnimation scaleAnimation=new ScaleAnimation(1.0f,0.9f,1.0f,0.9f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(scaleAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimation() == SuperToast.Animations.POPUP) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.1f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else {
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    alphaAnimation.setDuration(500);
    alphaAnimation.setInterpolator(new AccelerateInterpolator());
    return alphaAnimation;
  }
}","private Animation getDismissAnimation(SuperActivityToast superActivityToast){
  if (superActivityToast.getAnimations() == SuperToast.Animations.FLYIN) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,.75f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new AccelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.SCALE) {
    ScaleAnimation scaleAnimation=new ScaleAnimation(1.0f,0.9f,1.0f,0.9f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(scaleAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else   if (superActivityToast.getAnimations() == SuperToast.Animations.POPUP) {
    TranslateAnimation translateAnimation=new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.1f);
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    AnimationSet animationSet=new AnimationSet(true);
    animationSet.addAnimation(translateAnimation);
    animationSet.addAnimation(alphaAnimation);
    animationSet.setInterpolator(new DecelerateInterpolator());
    animationSet.setDuration(250);
    return animationSet;
  }
 else {
    AlphaAnimation alphaAnimation=new AlphaAnimation(1f,0f);
    alphaAnimation.setDuration(500);
    alphaAnimation.setInterpolator(new AccelerateInterpolator());
    return alphaAnimation;
  }
}"
52091,"@Override public void onAnimationEnd(Animation animation){
  if (superActivityToast.getOnDismissListener() != null) {
    superActivityToast.getOnDismissListener().onDismiss(superActivityToast.getView());
  }
  ManagerSuperActivityToast.this.showNextSuperToast();
}","@Override public void onAnimationEnd(Animation animation){
  if (superActivityToast.getOnDismissListenerWrapper() != null) {
    superActivityToast.getOnDismissListenerWrapper().onDismiss(superActivityToast.getView());
  }
  ManagerSuperActivityToast.this.showNextSuperToast();
}"
52092,"void removeSuperToast(final SuperActivityToast superActivityToast){
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    Animation animation=getDismissAnimation(superActivityToast);
    animation.setAnimationListener(new Animation.AnimationListener(){
      @Override public void onAnimationStart(      Animation animation){
      }
      @Override public void onAnimationEnd(      Animation animation){
        if (superActivityToast.getOnDismissListener() != null) {
          superActivityToast.getOnDismissListener().onDismiss(superActivityToast.getView());
        }
        ManagerSuperActivityToast.this.showNextSuperToast();
      }
      @Override public void onAnimationRepeat(      Animation animation){
      }
    }
);
    toastView.startAnimation(animation);
    viewGroup.removeView(toastView);
    mList.poll();
  }
}","void removeSuperToast(final SuperActivityToast superActivityToast){
  final ViewGroup viewGroup=superActivityToast.getViewGroup();
  final View toastView=superActivityToast.getView();
  if (viewGroup != null) {
    Animation animation=getDismissAnimation(superActivityToast);
    animation.setAnimationListener(new Animation.AnimationListener(){
      @Override public void onAnimationStart(      Animation animation){
      }
      @Override public void onAnimationEnd(      Animation animation){
        if (superActivityToast.getOnDismissListenerWrapper() != null) {
          superActivityToast.getOnDismissListenerWrapper().onDismiss(superActivityToast.getView());
        }
        ManagerSuperActivityToast.this.showNextSuperToast();
      }
      @Override public void onAnimationRepeat(      Animation animation){
      }
    }
);
    toastView.startAnimation(animation);
    viewGroup.removeView(toastView);
    mList.poll();
  }
}"
52093,"protected void clearQueue(){
  removeMessages(Messages.ADD);
  removeMessages(Messages.DISPLAY);
  removeMessages(Messages.REMOVE);
  if (mList != null) {
    for (    SuperActivityToast superActivityToast : mList) {
      if (superActivityToast.isShowing()) {
        superActivityToast.getViewGroup().removeView(superActivityToast.getView());
      }
    }
    mList.clear();
  }
}","protected void clearQueue(){
  removeMessages(Messages.ADD);
  removeMessages(Messages.DISPLAY);
  removeMessages(Messages.REMOVE);
  if (mList != null) {
    for (    SuperActivityToast superActivityToast : mList) {
      if (superActivityToast.isShowing()) {
        superActivityToast.getViewGroup().removeView(superActivityToast.getView());
        superActivityToast.getViewGroup().invalidate();
      }
    }
    mList.clear();
  }
}"
52094,"/** 
 * Sets the text size of the SuperCardToast. <br>
 * @param textSize
 */
public void setTextSizeFloat(float textSize){
  mMessageTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP,textSize);
}","/** 
 * Sets the text size of the SuperCardToast. <br>
 * @param textSize
 */
public void setTextSizeFloat(float textSize){
  mMessageTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX,textSize);
}"
52095,"/** 
 * Sets the text size of the Button in a BUTTON Type SuperCardToast <br>
 * @param buttonTextSize
 */
public void setButtonTextSizeFloat(float buttonTextSize){
  mMessageTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP,buttonTextSize);
}","/** 
 * Sets the text size of the Button in a BUTTON Type SuperCardToast <br>
 * @param buttonTextSize
 */
public void setButtonTextSizeFloat(float buttonTextSize){
  mMessageTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX,buttonTextSize);
}"
52096,"/** 
 * Recreates SuperCardToasts that were showing during an orientation change. <br>
 * @param bundle
 * @param activity
 */
public static void onRestoreState(Bundle bundle,Activity activity){
  if (bundle == null) {
    return;
  }
  for (  SuperCardToast oldSuperCardToast : (SuperCardToast[])bundle.getSerializable(BUNDLE)) {
    SuperCardToast newSuperCardToast;
    if (oldSuperCardToast.getType() == Type.BUTTON) {
      newSuperCardToast=new SuperCardToast(activity,Type.BUTTON);
      newSuperCardToast.setButtonOnClickListener(oldSuperCardToast.getButtonOnClickListener());
      newSuperCardToast.setButtonText(oldSuperCardToast.getButtonText());
      newSuperCardToast.setButtonTextSizeFloat(oldSuperCardToast.getButtonTextSize());
      newSuperCardToast.setButtonTextColor(oldSuperCardToast.getButtonTextColor());
      newSuperCardToast.setButtonTextTypeface(oldSuperCardToast.getButtonTextTypeface());
      if (oldSuperCardToast.getButtonDrawable() != null) {
        newSuperCardToast.setButtonDrawable(oldSuperCardToast.getButtonDrawable());
      }
 else       if (oldSuperCardToast.getButtonResource() != 0) {
        newSuperCardToast.setButtonResource(oldSuperCardToast.getButtonResource());
      }
      if (oldSuperCardToast.getButtonDividerDrawable() != null) {
        newSuperCardToast.setButtonDividerDrawable(oldSuperCardToast.getButtonDividerDrawable());
      }
 else       if (oldSuperCardToast.getButtonDividerResource() != 0) {
        newSuperCardToast.setButtonDividerResource(oldSuperCardToast.getButtonDividerResource());
      }
    }
 else     if (oldSuperCardToast.getType() == Type.PROGRESS) {
      newSuperCardToast=new SuperCardToast(activity,Type.PROGRESS);
      newSuperCardToast.setProgressIndeterminate(oldSuperCardToast.getProgressIndeterminate());
      newSuperCardToast.setProgress(oldSuperCardToast.getProgress());
    }
 else     if (oldSuperCardToast.getType() == Type.PROGRESS_HORIZONTAL) {
      newSuperCardToast=new SuperCardToast(activity,Type.PROGRESS_HORIZONTAL);
      newSuperCardToast.setProgressIndeterminate(oldSuperCardToast.getProgressIndeterminate());
      newSuperCardToast.setProgress(oldSuperCardToast.getProgress());
    }
 else {
      newSuperCardToast=new SuperCardToast(activity);
    }
    newSuperCardToast.setText(oldSuperCardToast.getText());
    newSuperCardToast.setTextColor(oldSuperCardToast.getTextColor());
    newSuperCardToast.setTextSizeFloat(oldSuperCardToast.getTextSize());
    newSuperCardToast.setDuration(oldSuperCardToast.getDuration());
    newSuperCardToast.setIndeterminate(oldSuperCardToast.isIndeterminate());
    if (oldSuperCardToast.getIconDrawable() != null && oldSuperCardToast.getIconPosition() != null) {
      newSuperCardToast.setIconDrawable(oldSuperCardToast.getIconDrawable(),oldSuperCardToast.getIconPosition());
    }
 else     if (oldSuperCardToast.getIconResource() != 0 && oldSuperCardToast.getIconPosition() != null) {
      newSuperCardToast.setIconResource(oldSuperCardToast.getIconResource(),oldSuperCardToast.getIconPosition());
    }
    newSuperCardToast.setOnClickListener(oldSuperCardToast.getOnClickListener());
    if (oldSuperCardToast.getBackgroundDrawable() != null) {
      newSuperCardToast.setBackgroundDrawable(oldSuperCardToast.getBackgroundDrawable());
    }
 else {
      newSuperCardToast.setBackgroundResource(oldSuperCardToast.getBackgroundResource());
    }
    newSuperCardToast.setTypeface(oldSuperCardToast.getTypeface());
    newSuperCardToast.setTouchToDismiss(oldSuperCardToast.isTouchDismissable());
    newSuperCardToast.setOnDismissListener(oldSuperCardToast.getOnDismissListener());
    newSuperCardToast.setSwipeToDismiss(oldSuperCardToast.isSwipeDismissable());
    newSuperCardToast.show();
  }
}","/** 
 * Recreates SuperCardToasts that were showing during an orientation change. <br>
 * @param bundle
 * @param activity
 */
public static void onRestoreState(Bundle bundle,Activity activity){
  if (bundle == null) {
    return;
  }
  for (  SuperCardToast oldSuperCardToast : (SuperCardToast[])bundle.getSerializable(BUNDLE)) {
    SuperCardToast newSuperCardToast;
    if (oldSuperCardToast.getType() == Type.BUTTON) {
      newSuperCardToast=new SuperCardToast(activity,Type.BUTTON);
      newSuperCardToast.setButtonOnClickListener(oldSuperCardToast.getButtonOnClickListener());
      newSuperCardToast.setButtonText(oldSuperCardToast.getButtonText());
      newSuperCardToast.setButtonTextSizeFloat(oldSuperCardToast.getButtonTextSize());
      newSuperCardToast.setButtonTextColor(oldSuperCardToast.getButtonTextColor());
      newSuperCardToast.setButtonTextTypeface(oldSuperCardToast.getButtonTextTypeface());
      if (oldSuperCardToast.getButtonDrawable() != null) {
        newSuperCardToast.setButtonDrawable(oldSuperCardToast.getButtonDrawable());
      }
 else       if (oldSuperCardToast.getButtonResource() != 0) {
        newSuperCardToast.setButtonResource(oldSuperCardToast.getButtonResource());
      }
      if (oldSuperCardToast.getButtonDividerDrawable() != null) {
        newSuperCardToast.setButtonDividerDrawable(oldSuperCardToast.getButtonDividerDrawable());
      }
 else       if (oldSuperCardToast.getButtonDividerResource() != 0) {
        newSuperCardToast.setButtonDividerResource(oldSuperCardToast.getButtonDividerResource());
      }
    }
 else     if (oldSuperCardToast.getType() == Type.PROGRESS) {
      newSuperCardToast=new SuperCardToast(activity,Type.PROGRESS);
      newSuperCardToast.setProgressIndeterminate(oldSuperCardToast.getProgressIndeterminate());
      newSuperCardToast.setProgress(oldSuperCardToast.getProgress());
    }
 else     if (oldSuperCardToast.getType() == Type.PROGRESS_HORIZONTAL) {
      newSuperCardToast=new SuperCardToast(activity,Type.PROGRESS_HORIZONTAL);
      newSuperCardToast.setProgressIndeterminate(oldSuperCardToast.getProgressIndeterminate());
      newSuperCardToast.setProgress(oldSuperCardToast.getProgress());
    }
 else {
      newSuperCardToast=new SuperCardToast(activity);
    }
    newSuperCardToast.setText(oldSuperCardToast.getText());
    newSuperCardToast.setTextColor(oldSuperCardToast.getTextColor());
    newSuperCardToast.setTextSizeFloat(oldSuperCardToast.getTextSize());
    newSuperCardToast.setDuration(oldSuperCardToast.getDuration());
    newSuperCardToast.setIndeterminate(oldSuperCardToast.isIndeterminate());
    if (oldSuperCardToast.getIconDrawable() != null && oldSuperCardToast.getIconPosition() != null) {
      newSuperCardToast.setIconDrawable(oldSuperCardToast.getIconDrawable(),oldSuperCardToast.getIconPosition());
    }
 else     if (oldSuperCardToast.getIconResource() != 0 && oldSuperCardToast.getIconPosition() != null) {
      newSuperCardToast.setIconResource(oldSuperCardToast.getIconResource(),oldSuperCardToast.getIconPosition());
    }
    newSuperCardToast.setOnClickListener(oldSuperCardToast.getOnClickListener());
    if (oldSuperCardToast.getBackgroundDrawable() != null) {
      newSuperCardToast.setBackgroundDrawable(oldSuperCardToast.getBackgroundDrawable());
    }
 else {
      newSuperCardToast.setBackgroundResource(oldSuperCardToast.getBackgroundResource());
    }
    newSuperCardToast.setTypeface(oldSuperCardToast.getTypeface());
    if (oldSuperCardToast.isTouchDismissable()) {
      newSuperCardToast.setTouchToDismiss(oldSuperCardToast.isTouchDismissable());
    }
 else     if (oldSuperCardToast.isSwipeDismissable()) {
      newSuperCardToast.setSwipeToDismiss(oldSuperCardToast.isSwipeDismissable());
    }
    newSuperCardToast.setOnDismissListener(oldSuperCardToast.getOnDismissListener());
    newSuperCardToast.show();
  }
}"
52097,"private void updateDisplay(){
  if (this.mDayOfWeekView != null)   this.mDayOfWeekView.setText(dateformartsymbols.getWeekdays()[Calendar.DAY_OF_WEEK].toUpperCase(Locale.getDefault()));
  this.mSelectedMonthTextView.setText(dateformartsymbols.getMonths()[this.mCalendar.getTime().getMonth()].toUpperCase(Locale.getDefault()));
  this.mSelectedDayTextView.setText(DAY_FORMAT.format(this.mCalendar.getTime()));
  this.mYearView.setText(YEAR_FORMAT.format(this.mCalendar.getTime()));
  long timeInMillis=this.mCalendar.getTimeInMillis();
  String desc=DateUtils.formatDateTime(getActivity(),timeInMillis,24);
  this.mMonthAndDayView.setContentDescription(desc);
}","private void updateDisplay(){
  if (this.mDayOfWeekView != null) {
    this.mCalendar.setFirstDayOfWeek(mWeekStart);
    this.mDayOfWeekView.setText(dateformartsymbols.getWeekdays()[this.mCalendar.get(Calendar.DAY_OF_WEEK)].toUpperCase(Locale.getDefault()));
  }
  this.mSelectedMonthTextView.setText(dateformartsymbols.getMonths()[this.mCalendar.get(Calendar.MONTH)].toUpperCase(Locale.getDefault()));
  this.mSelectedDayTextView.setText(DAY_FORMAT.format(this.mCalendar.getTime()));
  this.mYearView.setText(YEAR_FORMAT.format(this.mCalendar.getTime()));
  long timeInMillis=this.mCalendar.getTimeInMillis();
  String desc=DateUtils.formatDateTime(getActivity(),timeInMillis,24);
  this.mMonthAndDayView.setContentDescription(desc);
}"
52098,"private void drawMonthDayLabels(Canvas canvas){
  int y=MONTH_HEADER_SIZE - MONTH_DAY_LABEL_TEXT_SIZE / 2;
  int space=(this.mWidth - 2 * this.mPadding) / (2 * this.mNumDays);
  for (int day=0; day < this.mNumDays; day++) {
    int dayOfWeek=(day + this.mWeekStart) % this.mNumDays;
    int x=space * (1 + day * 2) + this.mPadding;
    this.mDayLabelCalendar.set(Calendar.DAY_OF_WEEK,dayOfWeek);
    canvas.drawText(dateformartsymbols.getShortWeekdays()[dayOfWeek + 1].toUpperCase(Locale.getDefault()),x,y,this.mMonthDayLabelPaint);
  }
}","private void drawMonthDayLabels(Canvas canvas){
  int y=MONTH_HEADER_SIZE - MONTH_DAY_LABEL_TEXT_SIZE / 2;
  int space=(this.mWidth - 2 * this.mPadding) / (2 * this.mNumDays);
  for (int day=0; day < this.mNumDays; day++) {
    int dayOfWeek=(day + this.mWeekStart) % this.mNumDays;
    int x=space * (1 + day * 2) + this.mPadding;
    this.mDayLabelCalendar.set(Calendar.DAY_OF_WEEK,dayOfWeek);
    canvas.drawText(dateformartsymbols.getShortWeekdays()[this.mDayLabelCalendar.get(Calendar.DAY_OF_WEEK)].toUpperCase(Locale.getDefault()),x,y,this.mMonthDayLabelPaint);
  }
}"
52099,"private void setFirstAndLastCycle(){
  long now=time.currentTimeMillis();
  if (now == firstAndLastCycleTime) {
    return;
  }
  firstCycle=directoryListing.getMinCreatedCycle();
  lastCycle=directoryListing.getMaxCreatedCycle();
  firstAndLastCycleTime=now;
  firstAndLastRetry=0;
}","private void setFirstAndLastCycle(){
  long now=time.currentTimeMillis();
  if (now == firstAndLastCycleTime) {
    if (++firstAndLastRetry > FIRST_AND_LAST_RETRY_MAX)     return;
  }
  firstCycle=directoryListing.getMinCreatedCycle();
  lastCycle=directoryListing.getMaxCreatedCycle();
  firstAndLastCycleTime=now;
  firstAndLastRetry=0;
}"
52100,"@Override public long toIndex(long headerNumber,long sequence){
  int cycle=toCycle(headerNumber);
  return toLongValue(cycle,sequence);
}","@Override public long toIndex(long headerNumber,long sequence){
  long cycle=toLowerBitsWritePosition(headerNumber);
  return toLongValue(cycle,sequence);
}"
52101,"private long toLowerBitsWritePosition(long index){
  return index >> cycleShift;
}","private long toLowerBitsWritePosition(long index){
  return index >>> cycleShift;
}"
52102,"/** 
 * gets the sequence for a writePosition <p> This method will only return a valid sequence number of the write position if the write position is the last write position in the queue. YOU CAN NOT USE THIS METHOD TO LOOK UP RANDOM SEQUENCES FOR ANY WRITE POSITION. NOT_FOUND_RETRY will be return if a sequence number can not be found  ( so can retry ) or NOT_FOUND when you should not retry
 * @param forWritePosition the last write position, expected to be the end of queue
 * @return NOT_FOUND_RETRY if the sequence for this write position can not be found, or NOT_FOUND if sequenceValue==null or the sequence for this {@code writePosition}
 */
public long getSequence(long forWritePosition){
  if (writePositionAndSequence == null)   return Sequence.NOT_FOUND;
  final long sequenceValue=this.writePositionAndSequence.getVolatileValue2();
  if (sequenceValue == 0)   return Sequence.NOT_FOUND;
  int writePositionCycle=(int)cycleMask(forWritePosition);
  final long lowerBitsOfWp=toLowerBitsWritePosition(toLongValue(writePositionCycle,0));
  final long toLowerBitsWritePosition=toLowerBitsWritePosition(cycleMask(sequenceValue));
  if (lowerBitsOfWp == toLowerBitsWritePosition)   return toSequenceNumber(sequenceValue);
  return Sequence.NOT_FOUND_RETRY;
}","/** 
 * gets the sequence for a writePosition <p> This method will only return a valid sequence number of the write position if the write position is the last write position in the queue. YOU CAN NOT USE THIS METHOD TO LOOK UP RANDOM SEQUENCES FOR ANY WRITE POSITION. NOT_FOUND_RETRY will be return if a sequence number can not be found  ( so can retry ) or NOT_FOUND when you should not retry
 * @param forWritePosition the last write position, expected to be the end of queue
 * @return NOT_FOUND_RETRY if the sequence for this write position can not be found, or NOT_FOUND if sequenceValue==null or the sequence for this {@code writePosition}
 */
public long getSequence(long forWritePosition){
  if (writePositionAndSequence == null)   return Sequence.NOT_FOUND;
  final long sequenceValue=this.writePositionAndSequence.getVolatileValue2();
  if (sequenceValue == 0)   return Sequence.NOT_FOUND;
  long writePositionAsCycle=toLongValue(forWritePosition,0);
  long lowerBitsOfWp=toLowerBitsWritePosition(writePositionAsCycle);
  final long toLowerBitsWritePosition=toLowerBitsWritePosition(sequenceValue);
  if (lowerBitsOfWp == toLowerBitsWritePosition)   return toSequenceNumber(sequenceValue);
  return Sequence.NOT_FOUND_RETRY;
}"
52103,"@NotNull default <T>MethodWriterBuilder<T> methodWriterBuilder(@NotNull Class<T> tClass){
  ChronicleQueue queue=queue();
  return new MethodWriterBuilder<>(tClass,new BinaryMethodWriterInvocationHandler(queue::acquireAppender));
}","@NotNull default <T>MethodWriterBuilder<T> methodWriterBuilder(@NotNull Class<T> tClass){
  return queue().methodWriterBuilder(tClass);
}"
52104,"default <T>T methodWriter(@NotNull Class<T> tClass,Class... additional){
  Class[] interfaces=ObjectUtils.addAll(tClass,additional);
  ChronicleQueue queue=queue();
  return (T)Proxy.newProxyInstance(tClass.getClassLoader(),interfaces,new BinaryMethodWriterInvocationHandler(queue::acquireAppender));
}","@NotNull default <T>T methodWriter(@NotNull Class<T> tClass,Class... additional){
  return queue().methodWriter(tClass,additional);
}"
52105,"@Test public void concurrentLockItUp() throws InterruptedException {
  final AtomicInteger written=new AtomicInteger();
  final AtomicReference<String> writerQueueFile=new AtomicReference<>();
  final File path=DirectoryUtils.tempDir(this.getClass().getSimpleName());
  final SingleChronicleQueueBuilder builder=ChronicleQueueBuilder.single(path).sourceId(1).rollCycle(ROLL_CYCLE).timeoutMS(TIMEOUT_MS);
  final String initialFile;
  final DocumentContext initialContext=builder.build().acquireAppender().writingDocument();
  initialContext.wire().write(""String_Node_Str"");
  initialFile=getFilename(initialContext);
  final long afterInitialWrite=System.currentTimeMillis();
  final CountDownLatch writerStarted=new CountDownLatch(1);
  Thread writerThread=new Thread(() -> {
    ExcerptAppender appender=builder.build().acquireAppender();
    writerStarted.countDown();
    try (@NotNull DocumentContext context=appender.writingDocument()){
      written.incrementAndGet();
      writerQueueFile.set(getFilename(context));
      Wire wire=context.wire();
      wire.write(""String_Node_Str"");
      wire.padToCacheAlign();
    }
   }
);
  writerThread.start();
  assertTrue(""String_Node_Str"",writerStarted.await(1,TimeUnit.SECONDS));
  while (System.currentTimeMillis() < afterInitialWrite + (TIMEOUT_MS - 50)) {
    Thread.sleep(10);
  }
  final long elapsedMillis=System.currentTimeMillis() - afterInitialWrite;
  assertTrue(""String_Node_Str"",elapsedMillis < TIMEOUT_MS);
  assumeTrue(""String_Node_Str"",writerQueueFile.get() == null || initialFile.equals(writerQueueFile.get()));
  assertEquals(""String_Node_Str"",0,written.get());
  long start=System.currentTimeMillis();
  while (System.currentTimeMillis() < start + TIMEOUT_MS) {
    if (written.get() > 0)     break;
  }
  assertTrue(""String_Node_Str"",written.get() > 0);
}","@Test public void concurrentLockItUp() throws InterruptedException {
  final AtomicInteger written=new AtomicInteger();
  final AtomicReference<String> writerQueueFile=new AtomicReference<>();
  final File path=DirectoryUtils.tempDir(this.getClass().getSimpleName());
  final SingleChronicleQueueBuilder builder=ChronicleQueueBuilder.single(path).sourceId(1).rollCycle(ROLL_CYCLE).timeoutMS(TIMEOUT_MS);
  final String initialFile;
  final DocumentContext initialContext=builder.build().acquireAppender().writingDocument();
  initialContext.wire().write(""String_Node_Str"");
  initialFile=getFilename(initialContext);
  final long afterInitialWrite=System.currentTimeMillis();
  final CountDownLatch writerStarted=new CountDownLatch(1);
  Thread writerThread=new Thread(() -> {
    ExcerptAppender appender=builder.build().acquireAppender();
    writerStarted.countDown();
    try (@NotNull DocumentContext context=appender.writingDocument()){
      written.incrementAndGet();
      writerQueueFile.set(getFilename(context));
      Wire wire=context.wire();
      wire.write(""String_Node_Str"");
      wire.padToCacheAlign();
    }
   }
);
  writerThread.start();
  assertTrue(""String_Node_Str"",writerStarted.await(1,TimeUnit.SECONDS));
  while (System.currentTimeMillis() < afterInitialWrite + (TIMEOUT_MS - 50)) {
    Thread.sleep(10);
  }
  final long elapsedMillis=System.currentTimeMillis() - afterInitialWrite;
  assertTrue(""String_Node_Str"",elapsedMillis < TIMEOUT_MS);
  assumeTrue(""String_Node_Str"",writerQueueFile.get() == null || initialFile.equals(writerQueueFile.get()));
  int actual=System.currentTimeMillis() < start0 + (timeoutMS - 50) ? 0 : written.get();
  assertEquals(""String_Node_Str"",0,actual);
  long start=System.currentTimeMillis();
  while (System.currentTimeMillis() < start + TIMEOUT_MS) {
    if (written.get() > 0)     break;
  }
  assertTrue(""String_Node_Str"",written.get() > 0);
}"
52106,"@Override public void writeMarshallable(@NotNull WireOut wire){
  if (lastAcknowledgedIndexReplicated == null)   lastAcknowledgedIndexReplicated=wire.newLongReference();
  wire.write(MetaDataField.wireType).asEnum(wireType).writeAlignTo(8,0).write(MetaDataField.writePosition).int64forBinding(0L,writePosition).write(MetaDataField.roll).typedMarshallable(this.roll).write(MetaDataField.indexing).typedMarshallable(this.indexing).write(MetaDataField.lastAcknowledgedIndexReplicated).int64forBinding(-1L,lastAcknowledgedIndexReplicated);
  wire.write(MetaDataField.recovery).typedMarshallable(recovery);
  wire.write(MetaDataField.deltaCheckpointInterval).int32(this.deltaCheckpointInterval);
  wire.padToCacheAlign();
}","@Override public void writeMarshallable(@NotNull WireOut wire){
  if (lastAcknowledgedIndexReplicated == null)   lastAcknowledgedIndexReplicated=wire.newLongReference();
  wire.write(MetaDataField.wireType).object(wireType).writeAlignTo(8,0).write(MetaDataField.writePosition).int64forBinding(0L,writePosition).write(MetaDataField.roll).typedMarshallable(this.roll).write(MetaDataField.indexing).typedMarshallable(this.indexing).write(MetaDataField.lastAcknowledgedIndexReplicated).int64forBinding(-1L,lastAcknowledgedIndexReplicated);
  wire.write(MetaDataField.recovery).typedMarshallable(recovery);
  wire.write(MetaDataField.deltaCheckpointInterval).int32(this.deltaCheckpointInterval);
  wire.padToCacheAlign();
}"
52107,"@NotNull @Override public DocumentContext readingDocument(boolean includeMetaData){
  try {
    boolean next=false, tryAgain=true;
    if (state == FOUND_CYCLE) {
      try {
        next=inACycle(includeMetaData,true);
        tryAgain=false;
      }
 catch (      EOFException eof) {
        state=TailerState.END_OF_CYCLE;
      }
    }
    if (tryAgain)     next=next0(includeMetaData);
    if (context.present(next)) {
      context.setStart(context.wire().bytes().readPosition() - 4);
      return context;
    }
    RollCycle rollCycle=queue.rollCycle();
    if (state == CYCLE_NOT_FOUND && direction == FORWARD) {
      int firstCycle=queue.firstCycle();
      if (rollCycle.toCycle(index) < firstCycle)       toStart();
    }
  }
 catch (  StreamCorruptedException e) {
    throw new IllegalStateException(e);
  }
catch (  UnrecoverableTimeoutException notComplete) {
  }
catch (  DecoratedBufferUnderflowException e) {
    if (queue.isReadOnly()) {
      Jvm.warn().on(StoreTailer.class,""String_Node_Str"" + ""String_Node_Str"",e);
    }
 else {
      throw e;
    }
  }
  return NoDocumentContext.INSTANCE;
}","@NotNull @Override public DocumentContext readingDocument(boolean includeMetaData){
  try {
    boolean next=false, tryAgain=true;
    if (state == FOUND_CYCLE) {
      try {
        next=inACycle(includeMetaData,true);
        tryAgain=false;
      }
 catch (      EOFException eof) {
        state=TailerState.END_OF_CYCLE;
      }
    }
    if (tryAgain)     next=next0(includeMetaData);
    if (context.present(next)) {
      context.setStart(context.wire().bytes().readPosition() - 4);
      readingDocumentFound=true;
      return context;
    }
    RollCycle rollCycle=queue.rollCycle();
    if (state == CYCLE_NOT_FOUND && direction == FORWARD) {
      int firstCycle=queue.firstCycle();
      if (rollCycle.toCycle(index) < firstCycle)       toStart();
    }
  }
 catch (  StreamCorruptedException e) {
    throw new IllegalStateException(e);
  }
catch (  UnrecoverableTimeoutException notComplete) {
  }
catch (  DecoratedBufferUnderflowException e) {
    if (queue.isReadOnly()) {
      Jvm.warn().on(StoreTailer.class,""String_Node_Str"" + ""String_Node_Str"",e);
    }
 else {
      throw e;
    }
  }
  return NoDocumentContext.INSTANCE;
}"
52108,"private static void expected(@NotNull ExcerptTailer tailer,String expected){
  try (DocumentContext dc=tailer.readingDocument()){
    assertTrue(dc.isPresent());
    Bytes bytes2=Bytes.elasticHeapByteBuffer(128);
    dc.wire().copyTo(new TextWire(bytes2));
    assertEquals(expected,bytes2.toString());
  }
 }","private static void expected(@NotNull ExcerptTailer tailer,String expected){
  try (DocumentContext dc=tailer.readingDocument()){
    assertTrue(""String_Node_Str"",dc.isPresent());
    Bytes bytes2=Bytes.elasticHeapByteBuffer(128);
    dc.wire().copyTo(new TextWire(bytes2));
    assertEquals(expected,bytes2.toString());
  }
 }"
52109,"@Nullable public synchronized WireStore acquire(final int cycle,final long epoch,boolean createIfAbsent){
  RollDetails rollDetails=new RollDetails(cycle,epoch);
  WireStore store=stores.get(rollDetails);
  if (store != null) {
    if (store.tryReserve())     return store;
 else     stores.remove(rollDetails);
  }
  store=this.supplier.acquire(cycle,createIfAbsent);
  if (store != null) {
    store.reserve();
    stores.put(rollDetails,store);
    storeFileListener.onAcquired(cycle,store.file());
  }
  return store;
}","@Nullable public synchronized WireStore acquire(final int cycle,final long epoch,boolean createIfAbsent){
  RollDetails rollDetails=new RollDetails(cycle,epoch);
  WireStore store=stores.get(rollDetails);
  if (store != null) {
    if (store.tryReserve())     return store;
 else     stores.remove(rollDetails);
  }
  store=this.supplier.acquire(cycle,createIfAbsent);
  if (store != null) {
    stores.put(rollDetails,store);
    storeFileListener.onAcquired(cycle,store.file());
  }
  return store;
}"
52110,"@Test public void tailerToEndIncreasesRefCount() throws Exception {
  String path=OS.TARGET + ""String_Node_Str"" + System.nanoTime();
  IOTools.shallowDeleteDirWithFiles(path);
  SetTimeProvider time=new SetTimeProvider();
  long now=System.currentTimeMillis();
  time.currentTimeMillis(now);
  RollingChronicleQueue queue=SingleChronicleQueueBuilder.binary(path).testBlockSize().rollCycle(RollCycles.TEST_SECONDLY).timeProvider(time).build();
  final SingleChronicleQueueExcerpts.StoreAppender appender=(SingleChronicleQueueExcerpts.StoreAppender)queue.acquireAppender();
  Field storeF1=SingleChronicleQueueExcerpts.StoreAppender.class.getDeclaredField(""String_Node_Str"");
  storeF1.setAccessible(true);
  SingleChronicleQueueStore store1=(SingleChronicleQueueStore)storeF1.get(appender);
  System.out.println(store1);
  appender.writeDocument(wire -> wire.write(() -> ""String_Node_Str"").int32(1));
  final SingleChronicleQueueExcerpts.StoreTailer tailer=(SingleChronicleQueueExcerpts.StoreTailer)queue.createTailer();
  System.out.println(tailer);
  tailer.toEnd();
  System.out.println(tailer);
  Field storeF2=SingleChronicleQueueExcerpts.StoreTailer.class.getDeclaredField(""String_Node_Str"");
  storeF2.setAccessible(true);
  SingleChronicleQueueStore store2=(SingleChronicleQueueStore)storeF2.get(tailer);
  assertEquals(3,store2.refCount());
}","@Test public void tailerToEndIncreasesRefCount() throws Exception {
  String path=OS.TARGET + ""String_Node_Str"" + System.nanoTime();
  IOTools.shallowDeleteDirWithFiles(path);
  SetTimeProvider time=new SetTimeProvider();
  long now=System.currentTimeMillis();
  time.currentTimeMillis(now);
  RollingChronicleQueue queue=SingleChronicleQueueBuilder.binary(path).testBlockSize().rollCycle(RollCycles.TEST_SECONDLY).timeProvider(time).build();
  final SingleChronicleQueueExcerpts.StoreAppender appender=(SingleChronicleQueueExcerpts.StoreAppender)queue.acquireAppender();
  Field storeF1=SingleChronicleQueueExcerpts.StoreAppender.class.getDeclaredField(""String_Node_Str"");
  storeF1.setAccessible(true);
  SingleChronicleQueueStore store1=(SingleChronicleQueueStore)storeF1.get(appender);
  System.out.println(store1);
  appender.writeDocument(wire -> wire.write(() -> ""String_Node_Str"").int32(1));
  final SingleChronicleQueueExcerpts.StoreTailer tailer=(SingleChronicleQueueExcerpts.StoreTailer)queue.createTailer();
  System.out.println(tailer);
  tailer.toEnd();
  System.out.println(tailer);
  Field storeF2=SingleChronicleQueueExcerpts.StoreTailer.class.getDeclaredField(""String_Node_Str"");
  storeF2.setAccessible(true);
  SingleChronicleQueueStore store2=(SingleChronicleQueueStore)storeF2.get(tailer);
  assertEquals(2,store2.refCount());
}"
52111,"/** 
 * @param store the {@code store} to release
 */
void release(@NotNull WireStore store);","/** 
 * @param store the {@code store} to release
 */
void release(WireStore store);"
52112,"/** 
 * Reverse look up an index for a position.
 * @param ec       the wire of the bytes, to work with
 * @param position of the start of the message
 * @return index in this store.
 */
long sequenceForPosition(ExcerptContext ec,long position,boolean inclusive) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException ;","/** 
 * Reverse look up an index for a position.
 * @param ec       the wire of the bytes, to work with
 * @param position of the start of the message
 * @return index in this store.
 */
long sequenceForPosition(ExcerptContext ec,long position,boolean inclusive) throws UnrecoverableTimeoutException, StreamCorruptedException ;"
52113,"@Nullable public synchronized WireStore acquire(final int cycle,final long epoch,boolean createIfAbsent){
  RollDetails rollDetails=new RollDetails(cycle,epoch);
  WireStore store=stores.get(rollDetails);
  if (store != null) {
    if (store.tryReserve())     return store;
 else     stores.remove(rollDetails);
  }
  store=this.supplier.acquire(cycle,createIfAbsent);
  if (store != null) {
    stores.put(rollDetails,store);
    storeFileListener.onAcquired(cycle,store.file());
  }
  return store;
}","@Nullable public synchronized WireStore acquire(final int cycle,final long epoch,boolean createIfAbsent){
  RollDetails rollDetails=new RollDetails(cycle,epoch);
  WireStore store=stores.get(rollDetails);
  if (store != null) {
    if (store.tryReserve())     return store;
 else     stores.remove(rollDetails);
  }
  store=this.supplier.acquire(cycle,createIfAbsent);
  if (store != null) {
    store.reserve();
    stores.put(rollDetails,store);
    storeFileListener.onAcquired(cycle,store.file());
  }
  return store;
}"
52114,"LongArrayValues getIndex2index(StoreRecovery recovery,ExcerptContext ec,long timeoutMS) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException {
  LongArrayValuesHolder holder=getIndex2IndexArray();
  LongArrayValues values=holder.values;
  if (((Byteable)values).bytesStore() != null || timeoutMS == 0)   return values;
  final long indexToIndex0=indexToIndex(recovery,ec,timeoutMS);
  Wire wire=ec.wireForIndex();
  for (; ; ) {
    try (DocumentContext context=wire.readingDocument(indexToIndex0)){
      if (!context.isPresent() || !context.isMetaData()) {
        wire.pauser().pause();
        continue;
      }
      return array(wire,values,true);
    }
   }
}","private LongArrayValues getIndex2index(StoreRecovery recovery,ExcerptContext ec,long timeoutMS) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException {
  LongArrayValuesHolder holder=getIndex2IndexArray();
  LongArrayValues values=holder.values;
  if (((Byteable)values).bytesStore() != null || timeoutMS == 0)   return values;
  final long indexToIndex0=indexToIndex(recovery,ec,timeoutMS);
  Wire wire=ec.wireForIndex();
  for (; ; ) {
    try (DocumentContext context=wire.readingDocument(indexToIndex0)){
      if (!context.isPresent() || !context.isMetaData()) {
        wire.pauser().pause();
        continue;
      }
      return array(wire,values,true);
    }
   }
}"
52115,"long getSecondaryAddress(StoreRecovery recovery,ExcerptContext ec,long timeoutMS,LongArrayValues index2indexArr,int index2) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException {
  try {
    return getSecondaryAddress1(recovery,ec,timeoutMS,index2indexArr,index2);
  }
 catch (  TimeoutException fallback) {
    ec.wire().pauser().reset();
    ec.wireForIndex().pauser().reset();
    return recovery.recoverSecondaryAddress(index2indexArr,index2,() -> getSecondaryAddress1(recovery,ec,timeoutMS,index2indexArr,index2),timeoutMS);
  }
}","private long getSecondaryAddress(StoreRecovery recovery,ExcerptContext ec,long timeoutMS,LongArrayValues index2indexArr,int index2) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException {
  try {
    return getSecondaryAddress1(recovery,ec,timeoutMS,index2indexArr,index2);
  }
 catch (  TimeoutException fallback) {
    ec.wire().pauser().reset();
    ec.wireForIndex().pauser().reset();
    return recovery.recoverSecondaryAddress(index2indexArr,index2,() -> getSecondaryAddress1(recovery,ec,timeoutMS,index2indexArr,index2),timeoutMS);
  }
}"
52116,"long sequenceForPosition(@NotNull StoreRecovery recovery,@NotNull ExcerptContext ec,final long position,boolean inclusive) throws EOFException, StreamCorruptedException {
}","long sequenceForPosition(@NotNull StoreRecovery recovery,@NotNull ExcerptContext ec,final long position,boolean inclusive) throws StreamCorruptedException {
}"
52117,"@NotNull private LongArrayValues arrayForAddress(@NotNull Wire wire,long secondaryAddress){
  LongArrayValuesHolder holder=getIndexArray();
  if (holder.address == secondaryAddress)   return holder.values;
  holder.address=secondaryAddress;
  wire.bytes().readPositionRemaining(secondaryAddress,256 << 20);
  wire.readMetaDataHeader();
  return array(wire,holder.values,false);
}","@NotNull private LongArrayValues arrayForAddress(@NotNull Wire wire,long secondaryAddress){
  LongArrayValuesHolder holder=getIndexArray();
  if (holder.address == secondaryAddress)   return holder.values;
  holder.address=secondaryAddress;
  wire.bytes().readPositionRemaining(secondaryAddress,4);
  wire.readMetaDataHeader();
  return array(wire,holder.values,false);
}"
52118,"@Override public boolean moveToIndex(final long index){
  if (index() == index)   return true;
  final ScanResult scanResult=moveToIndexResult(index);
  return scanResult == FOUND;
}","@Override public boolean moveToIndex(final long index){
  final ScanResult scanResult=moveToIndexResult(index);
  if (scanResult == NOT_FOUND) {
    try {
      long last=approximateLastIndex();
      if (index == last) {
        state=FOUND_CYCLE;
        return true;
      }
    }
 catch (    EOFException e) {
      return false;
    }
  }
  return scanResult == FOUND;
}"
52119,"@Ignore @Test public void testTailer() throws Exception {
  final Path dir=Files.createTempDirectory(""String_Node_Str"");
  final SingleChronicleQueueBuilder builder=ChronicleQueueBuilder.single(dir.toString()).rollCycle(RollCycles.TEST_SECONDLY);
  final RollingChronicleQueue queue=builder.build();
  queue.acquireAppender().writeText(""String_Node_Str"");
  ExcerptTailer excerptTailer=queue.createTailer().toEnd();
  long index=excerptTailer.index();
  System.out.println(""String_Node_Str"" + Long.toHexString(index));
  Assert.assertTrue(excerptTailer.moveToIndex(index));
}","@Test public void testTailer() throws Exception {
  final Path dir=Files.createTempDirectory(""String_Node_Str"");
  final SingleChronicleQueueBuilder builder=ChronicleQueueBuilder.single(dir.toString()).rollCycle(RollCycles.TEST_SECONDLY);
  final RollingChronicleQueue queue=builder.build();
  queue.acquireAppender().writeText(""String_Node_Str"");
  ExcerptTailer tailer=queue.createTailer();
  ExcerptTailer excerptTailer=tailer.toEnd();
  long index=excerptTailer.index();
  System.out.println(""String_Node_Str"" + Long.toHexString(index));
  Assert.assertTrue(excerptTailer.moveToIndex(index));
}"
52120,"@Test public void testAppendedSkipToEndMultiThreaded() throws TimeoutException, ExecutionException, InterruptedException {
}","@Ignore(""String_Node_Str"") @Test public void testAppendedSkipToEndMultiThreaded() throws TimeoutException, ExecutionException, InterruptedException {
}"
52121,"private boolean next(boolean includeMetaData) throws UnrecoverableTimeoutException, StreamCorruptedException {
  for (int i=0; i < 1000; i++) {
switch (state) {
case UNINTIALISED:
      final long firstIndex=queue.firstIndex();
    if (firstIndex == Long.MAX_VALUE)     return false;
  if (!moveToIndex(firstIndex))   return false;
break;
case FOUND_CYCLE:
try {
return inAnCycle(includeMetaData);
}
 catch (EOFException eof) {
state=TailerState.END_OF_CYCLE;
}
break;
case END_OF_CYCLE:
Boolean x=atTheEndOfACycle();
if (x != null) return x;
break;
case BEHOND_START:
if (direction == FORWARD) {
state=UNINTIALISED;
continue;
}
return false;
case CYCLE_NOT_FOUND:
return moveToIndex(index);
default :
throw new AssertionError(""String_Node_Str"" + state);
}
}
throw new IllegalStateException(""String_Node_Str"");
}","private boolean next(boolean includeMetaData) throws UnrecoverableTimeoutException, StreamCorruptedException {
  for (int i=0; i < 1000; i++) {
switch (state) {
case UNINTIALISED:
      final long firstIndex=queue.firstIndex();
    if (firstIndex == Long.MAX_VALUE)     return false;
  if (!moveToIndex(firstIndex))   return false;
break;
case FOUND_CYCLE:
try {
boolean result=inAnCycle(includeMetaData);
if (!result) {
  state=TailerState.END_OF_CYCLE;
  break;
}
return result;
}
 catch (EOFException eof) {
state=TailerState.END_OF_CYCLE;
}
break;
case END_OF_CYCLE:
Boolean x=atTheEndOfACycle();
if (x != null) return x;
break;
case BEHOND_START_OF_CYCLE:
if (direction == FORWARD) {
state=UNINTIALISED;
continue;
}
if (direction == BACKWARD) {
state=END_OF_CYCLE;
continue;
}
throw new AssertionError(""String_Node_Str"" + direction);
case CYCLE_NOT_FOUND:
return moveToIndex(index);
default :
throw new AssertionError(""String_Node_Str"" + state);
}
}
throw new IllegalStateException(""String_Node_Str"");
}"
52122,"private boolean cycle(final int cycle,boolean createIfAbsent){
  if (this.cycle == cycle && state == FOUND_CYCLE) {
    return true;
  }
  if (this.store != null) {
    this.queue.release(this.store);
  }
  this.store=this.queue.storeForCycle(cycle,queue.epoch(),createIfAbsent);
  if (store == null) {
    context.wire(null);
    if (direction == BACKWARD)     state=BEHOND_START;
 else     state=CYCLE_NOT_FOUND;
    return false;
  }
  this.state=FOUND_CYCLE;
  this.cycle=cycle;
  resetWires();
  final Wire wire=wire();
  wire.parent(this);
  wire.pauser(queue.pauserSupplier.get());
  return true;
}","private boolean cycle(final int cycle,boolean createIfAbsent){
  if (this.cycle == cycle && state == FOUND_CYCLE) {
    return true;
  }
  if (this.store != null) {
    this.queue.release(this.store);
  }
  this.store=this.queue.storeForCycle(cycle,queue.epoch(),createIfAbsent);
  if (store == null) {
    context.wire(null);
    if (direction == BACKWARD)     state=BEHOND_START_OF_CYCLE;
 else     state=CYCLE_NOT_FOUND;
    return false;
  }
  this.state=FOUND_CYCLE;
  this.cycle=cycle;
  resetWires();
  final Wire wire=wire();
  wire.parent(this);
  wire.pauser(queue.pauserSupplier.get());
  return true;
}"
52123,"@Test public void testReadingWritingWhenCycleIsSkipped() throws Exception {
  final Path dir=Files.createTempDirectory(""String_Node_Str"");
  final RollCycles rollCycle=RollCycles.TEST_SECONDLY;
  try (ChronicleQueue queue=ChronicleQueueBuilder.single(dir.toString()).rollCycle(rollCycle).build()){
    queue.acquireAppender().writeText(""String_Node_Str"");
  }
   Thread.sleep(1100);
  try (ChronicleQueue queue=ChronicleQueueBuilder.single(dir.toString()).rollCycle(rollCycle).build()){
    queue.acquireAppender().writeText(""String_Node_Str"");
  }
   try (ChronicleQueue queue=ChronicleQueueBuilder.single(dir.toString()).rollCycle(rollCycle).build()){
    ExcerptTailer tailer=queue.createTailer();
    Assert.assertEquals(""String_Node_Str"",tailer.readText());
    Assert.assertEquals(""String_Node_Str"",tailer.readText());
  }
 }","@Test public void testReadingWritingWhenCycleIsSkipped() throws Exception {
  final Path dir=Files.createTempDirectory(""String_Node_Str"");
  final RollCycles rollCycle=RollCycles.TEST_SECONDLY;
  try (ChronicleQueue queue=ChronicleQueueBuilder.single(dir.toString()).rollCycle(rollCycle).build()){
    queue.acquireAppender().writeText(""String_Node_Str"");
  }
   Thread.sleep(2100);
  try (ChronicleQueue queue=ChronicleQueueBuilder.single(dir.toString()).rollCycle(rollCycle).build()){
    queue.acquireAppender().writeText(""String_Node_Str"");
  }
   try (ChronicleQueue queue=ChronicleQueueBuilder.single(dir.toString()).rollCycle(rollCycle).build()){
    ExcerptTailer tailer=queue.createTailer();
    Assert.assertEquals(""String_Node_Str"",tailer.readText());
    Assert.assertEquals(""String_Node_Str"",tailer.readText());
  }
 }"
52124,"public Long toLong(File file){
  return Instant.from(formatter.parse(fileToName.apply(file))).toEpochMilli() / length;
}","public Long toLong(File file){
}"
52125,"@Override public int nextCycle(int currentCycle,TailerDirection direction) throws ParseException {
  if (direction == NONE)   throw new AssertionError(""String_Node_Str"");
  final NavigableMap<Long,File> tree=cycleTree();
  final File currentCycleFile=dateCache.resourceFor(currentCycle).path;
  if (!currentCycleFile.exists())   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + currentCycleFile);
  Long key=dateCache.toLong(currentCycleFile);
  File file=tree.get(key);
  if (file == null)   throw new AssertionError(""String_Node_Str"" + currentCycleFile);
switch (direction) {
case FORWARD:
    return toCycle(tree.higherEntry(key));
case BACKWARD:
  return toCycle(tree.lowerEntry(key));
default :
throw new UnsupportedOperationException(""String_Node_Str"");
}
}","@Override public int nextCycle(int currentCycle,TailerDirection direction) throws ParseException {
}"
52126,"private boolean next(boolean includeMetaData) throws UnrecoverableTimeoutException, StreamCorruptedException {
  for (int i=0; i < 1000; i++) {
switch (state) {
case UNINTIALISED:
      final long firstIndex=queue.firstIndex();
    if (firstIndex == Long.MAX_VALUE)     return false;
  if (!moveToIndex(firstIndex))   return false;
break;
case FOUND_CYCLE:
try {
return inAnCycle(includeMetaData);
}
 catch (EOFException eof) {
state=TailerState.END_OF_CYCLE;
}
break;
case END_OF_CYCLE:
Boolean x=atTheEndOfACycle();
if (x != null) return x;
break;
default :
throw new AssertionError(""String_Node_Str"" + state);
}
}
throw new IllegalStateException(""String_Node_Str"");
}","private boolean next(boolean includeMetaData) throws UnrecoverableTimeoutException, StreamCorruptedException {
  for (int i=0; i < 1000; i++) {
switch (state) {
case UNINTIALISED:
      final long firstIndex=queue.firstIndex();
    if (firstIndex == Long.MAX_VALUE)     return false;
  if (!moveToIndex(firstIndex))   return false;
break;
case FOUND_CYCLE:
try {
return inAnCycle(includeMetaData);
}
 catch (EOFException eof) {
state=TailerState.END_OF_CYCLE;
}
break;
case END_OF_CYCLE:
Boolean x=atTheEndOfACycle();
if (x != null) return x;
break;
case BEHOND_START:
if (direction == FORWARD) {
state=UNINTIALISED;
continue;
}
return false;
default :
throw new AssertionError(""String_Node_Str"" + state);
}
}
throw new IllegalStateException(""String_Node_Str"");
}"
52127,"private boolean cycle(final int cycle,boolean createIfAbsent){
  if (this.cycle != cycle) {
    if (this.store != null) {
      this.queue.release(this.store);
    }
    this.store=this.queue.storeForCycle(cycle,queue.epoch(),createIfAbsent);
    if (store == null) {
      context.wire(null);
      return false;
    }
    this.cycle=cycle;
    resetWires();
    final Wire wire=wire();
    wire.parent(this);
    wire.pauser(queue.pauserSupplier.get());
  }
  return true;
}","private boolean cycle(final int cycle,boolean createIfAbsent){
  if (this.cycle != cycle) {
    if (this.store != null) {
      this.queue.release(this.store);
    }
    this.store=this.queue.storeForCycle(cycle,queue.epoch(),createIfAbsent);
    if (store == null) {
      context.wire(null);
      if (direction == BACKWARD)       state=TailerState.BEHOND_START;
      return false;
    }
    this.state=TailerState.FOUND_CYCLE;
    this.cycle=cycle;
    resetWires();
    final Wire wire=wire();
    wire.parent(this);
    wire.pauser(queue.pauserSupplier.get());
  }
  return true;
}"
52128,"@NotNull @Override public ExcerptTailer toEnd(){
  long index=approximateLastIndex();
  if (direction != TailerDirection.FORWARD)   index--;
  if (index != Long.MIN_VALUE)   moveToIndex(index);
  return this;
}","@NotNull @Override public ExcerptTailer toEnd(){
  long index=approximateLastIndex();
  if (direction != TailerDirection.FORWARD)   index--;
  if (index != Long.MIN_VALUE)   moveToIndex(index);
  if (state() == TailerState.CYCLE_NOT_FOUND)   state=UNINTIALISED;
  return this;
}"
52129,"@Test public void toEndTest(){
  String baseDir=OS.TARGET + ""String_Node_Str"" + System.nanoTime();
  System.out.println(baseDir);
  IOTools.shallowDeleteDirWithFiles(baseDir);
  List<Integer> results=new ArrayList<>();
  RollingChronicleQueue queue=SingleChronicleQueueBuilder.binary(baseDir).indexCount(8).indexSpacing(1).build();
  checkOneFile(baseDir);
  ExcerptAppender appender=queue.acquireAppender();
  checkOneFile(baseDir);
  for (int i=0; i < 10; i++) {
    final int j=i;
    appender.writeDocument(wire -> wire.write(() -> ""String_Node_Str"").int32(j));
  }
  checkOneFile(baseDir);
  ExcerptTailer tailer=queue.createTailer();
  checkOneFile(baseDir);
  tailer.toEnd();
  assertEquals(10,queue.rollCycle().toSequenceNumber(tailer.index()));
  checkOneFile(baseDir);
  fillResults(tailer,results);
  checkOneFile(baseDir);
  assertEquals(0,results.size());
  tailer.toStart();
  checkOneFile(baseDir);
  fillResults(tailer,results);
  assertEquals(10,results.size());
  checkOneFile(baseDir);
  try {
    IOTools.shallowDeleteDirWithFiles(baseDir);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Test public void toEndTest(){
  String baseDir=OS.TARGET + ""String_Node_Str"" + System.nanoTime();
  System.out.println(baseDir);
  IOTools.shallowDeleteDirWithFiles(baseDir);
  List<Integer> results=new ArrayList<>();
  RollingChronicleQueue queue=SingleChronicleQueueBuilder.binary(baseDir).indexCount(8).indexSpacing(1).build();
  checkOneFile(baseDir);
  ExcerptAppender appender=queue.acquireAppender();
  checkOneFile(baseDir);
  for (int i=0; i < 10; i++) {
    final int j=i;
    appender.writeDocument(wire -> wire.write(() -> ""String_Node_Str"").int32(j));
  }
  checkOneFile(baseDir);
  ExcerptTailer tailer=queue.createTailer();
  checkOneFile(baseDir);
  ExcerptTailer atEnd=tailer.toEnd();
  assertEquals(10,queue.rollCycle().toSequenceNumber(atEnd.index()));
  checkOneFile(baseDir);
  fillResults(atEnd,results);
  checkOneFile(baseDir);
  assertEquals(0,results.size());
  tailer.toStart();
  checkOneFile(baseDir);
  fillResults(tailer,results);
  assertEquals(10,results.size());
  checkOneFile(baseDir);
  try {
    IOTools.shallowDeleteDirWithFiles(baseDir);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
52130,"@NotNull private List<Integer> fillResults(ExcerptTailer tailer,List<Integer> results){
  for (int i=0; i < 10; i++) {
    if (!tailer.readDocument(wire -> results.add(wire.read(() -> ""String_Node_Str"").int32())))     break;
  }
  return results;
}","@NotNull private List<Integer> fillResults(ExcerptTailer tailer,List<Integer> results){
  for (int i=0; i < 10; i++) {
    try (DocumentContext documentContext=tailer.readingDocument()){
      if (!documentContext.isPresent())       break;
      results.add(documentContext.wire().read(() -> ""String_Node_Str"").int32());
    }
   }
  return results;
}"
52131,"private static void dumpFile(File file){
  if (file.getName().endsWith(SingleChronicleQueue.SUFFIX)) {
    try (MappedBytes bytes=MappedBytes.mappedBytes(file,4 << 20)){
      bytes.readLimit(bytes.realCapacity());
      System.out.println(Wires.fromSizePrefixedBlobs(bytes));
    }
 catch (    IOException ioe) {
      System.err.println(""String_Node_Str"" + file + ""String_Node_Str""+ ioe);
    }
  }
}","private static void dumpFile(File file){
  if (file.getName().endsWith(SingleChronicleQueue.SUFFIX)) {
    try (MappedBytes bytes=MappedBytes.mappedBytes(file,4 << 20)){
      bytes.readLimit(bytes.realCapacity());
      out.println(Wires.fromSizePrefixedBlobs(bytes));
    }
 catch (    IOException ioe) {
      err.println(""String_Node_Str"" + file + ""String_Node_Str""+ ioe);
    }
  }
}"
52132,"public static void dump(String path){
  File path2=new File(path);
  if (path2.isDirectory()) {
    File[] files=path2.listFiles();
    if (files == null)     System.err.println(""String_Node_Str"" + path);
    for (    File file : files)     dumpFile(file);
  }
 else {
    dumpFile(path2);
  }
}","public static void dump(String path){
  File path2=new File(path);
  if (path2.isDirectory()) {
    File[] files=path2.listFiles();
    if (files == null)     err.println(""String_Node_Str"" + path);
    for (    File file : files)     dumpFile(file);
  }
 else {
    dumpFile(path2);
  }
}"
52133,"private void resetPosition() throws UnrecoverableTimeoutException {
  try {
    if (store == null || wire == null)     return;
    final long position=store.writePosition();
    wire.bytes().writePosition(position);
    if (lazyIndexing)     return;
    final long headerNumber=store.sequenceForPosition(this,position);
    wire.headerNumber(queue.rollCycle().toIndex(cycle,headerNumber + 1) - 1);
    checkIndex(wire.headerNumber(),wire.bytes().writePosition());
  }
 catch (  BufferOverflowException|EOFException|StreamCorruptedException e) {
    throw new AssertionError(e);
  }
}","private void resetPosition() throws UnrecoverableTimeoutException {
}"
52134,"void writeIndexForPosition(long index,long position) throws UnrecoverableTimeoutException, StreamCorruptedException {
}","void writeIndexForPosition(long index,long position) throws UnrecoverableTimeoutException, StreamCorruptedException {
  if (!lazyIndexing) {
    long sequenceNumber=queue.rollCycle().toSequenceNumber(index);
    store.setPositionForSequenceNumber(this,sequenceNumber,position);
  }
}"
52135,"/** 
 * Moves the position to the index
 * @param ec      the data structure we are navigating
 * @param index     the index we wish to move to
 * @return whether the index was found for reading.
 */
@Override public ScanResult moveToIndexForRead(@NotNull ExcerptContext ec,long index){
  try {
    return indexing.moveToIndex(recovery,ec,index);
  }
 catch (  UnrecoverableTimeoutException|StreamCorruptedException e) {
    return ScanResult.NOT_REACHED;
  }
}","/** 
 * Moves the position to the index
 * @param ec    the data structure we are navigating
 * @param index the index we wish to move to
 * @return whether the index was found for reading.
 */
@Override public ScanResult moveToIndexForRead(@NotNull ExcerptContext ec,long index){
  try {
    return indexing.moveToIndex(recovery,ec,index);
  }
 catch (  UnrecoverableTimeoutException|StreamCorruptedException e) {
    return ScanResult.NOT_REACHED;
  }
}"
52136,"@Override public WireStore writePosition(long position){
  writePosition.setMaxValue(position);
  return this;
}","@Override public WireStore writePosition(long position){
  int header=mappedBytes.readVolatileInt(position);
  if (Wires.isReadyData(header))   writePosition.setMaxValue(position);
 else   throw new AssertionError();
  return this;
}"
52137,"@Test public void testWriteBytesWithIndex() throws Exception {
  String tmp=OS.TARGET + ""String_Node_Str"" + System.nanoTime();
  try (SingleChronicleQueue queue=ChronicleQueueBuilder.single(tmp).build()){
    ExcerptAppender appender=queue.acquireAppender();
    appender.writeBytes(0x421d00000000L,Bytes.from(""String_Node_Str""));
    appender.writeBytes(0x421d00000001L,Bytes.from(""String_Node_Str""));
  }
   try (SingleChronicleQueue queue=ChronicleQueueBuilder.single(tmp).build()){
    ExcerptAppender appender=queue.acquireAppender();
    try {
      appender.writeBytes(0x421d00000000L,Bytes.from(""String_Node_Str""));
      fail();
    }
 catch (    IllegalStateException e) {
      assertEquals(""String_Node_Str"",e.getMessage());
    }
  }
   try (SingleChronicleQueue queue=ChronicleQueueBuilder.single(tmp).build()){
    ExcerptAppender appender=queue.acquireAppender();
    try {
      appender.writeBytes(0x421d00000003L,Bytes.from(""String_Node_Str""));
      fail();
    }
 catch (    IllegalStateException e) {
      assertEquals(""String_Node_Str"",e.getMessage());
    }
  }
   try (SingleChronicleQueue queue=ChronicleQueueBuilder.single(tmp).build()){
    ExcerptAppender appender=queue.acquireAppender();
    appender.writeBytes(0x421d00000002L,Bytes.from(""String_Node_Str""));
    appender.writeBytes(0x421d00000003L,Bytes.from(""String_Node_Str""));
  }
   try {
    IOTools.deleteDirWithFiles(tmp,2);
  }
 catch (  IORuntimeException ignored) {
  }
}","@Test public void testWriteBytesWithIndex() throws Exception {
  String tmp=OS.TARGET + ""String_Node_Str"" + System.nanoTime();
  try (SingleChronicleQueue queue=ChronicleQueueBuilder.single(tmp).rollCycle(TEST_DAILY).build()){
    ExcerptAppender appender=queue.acquireAppender();
    appender.writeBytes(0x421d00000000L,Bytes.from(""String_Node_Str""));
    appender.writeBytes(0x421d00000001L,Bytes.from(""String_Node_Str""));
  }
   try (SingleChronicleQueue queue=ChronicleQueueBuilder.single(tmp).build()){
    ExcerptAppender appender=queue.acquireAppender();
    try {
      appender.writeBytes(0x421d00000000L,Bytes.from(""String_Node_Str""));
      fail();
    }
 catch (    IllegalStateException e) {
      assertEquals(""String_Node_Str"",e.getMessage());
    }
  }
   try (SingleChronicleQueue queue=ChronicleQueueBuilder.single(tmp).build()){
    ExcerptAppender appender=queue.acquireAppender();
    try {
      appender.writeBytes(0x421d00000003L,Bytes.from(""String_Node_Str""));
      fail();
    }
 catch (    IllegalStateException e) {
      assertEquals(""String_Node_Str"",e.getMessage());
    }
  }
   try (SingleChronicleQueue queue=ChronicleQueueBuilder.single(tmp).build()){
    ExcerptAppender appender=queue.acquireAppender();
    appender.writeBytes(0x421d00000002L,Bytes.from(""String_Node_Str""));
    appender.writeBytes(0x421d00000003L,Bytes.from(""String_Node_Str""));
  }
   try {
    IOTools.deleteDirWithFiles(tmp,2);
  }
 catch (  IORuntimeException ignored) {
  }
}"
52138,"@Ignore @Test public void testAppendedSkipToEndMultiThreaded() throws TimeoutException, ExecutionException, InterruptedException {
  for (; ; ) {
    try (ChronicleQueue q=SingleChronicleQueueBuilder.binary(getTmpDir()).wireType(this.wireType).build()){
      final ThreadLocal<ExcerptAppender> tl=ThreadLocal.withInitial(() -> q.acquireAppender());
      int size=100;
      IntStream.range(0,size).parallel().forEach(i -> writeTestDocument(tl));
      ExcerptTailer tailer=q.createTailer();
      for (int i=0; i < size; i++) {
        try (DocumentContext dc=tailer.readingDocument(false)){
          long index=dc.index();
          long actual=dc.wire().read(() -> ""String_Node_Str"").int64(index);
          Assert.assertEquals(index,actual);
        }
       }
      System.out.println(""String_Node_Str"");
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","@Test public void testAppendedSkipToEndMultiThreaded() throws TimeoutException, ExecutionException, InterruptedException {
  for (int j=0; j < 50; j++) {
    try (ChronicleQueue q=SingleChronicleQueueBuilder.binary(getTmpDir()).wireType(this.wireType).build()){
      final ThreadLocal<ExcerptAppender> tl=ThreadLocal.withInitial(() -> q.acquireAppender());
      int size=100;
      IntStream.range(0,size).parallel().forEach(i -> writeTestDocument(tl));
      ExcerptTailer tailer=q.createTailer();
      for (int i=0; i < size; i++) {
        try (DocumentContext dc=tailer.readingDocument(false)){
          Assert.assertEquals(dc.index(),dc.wire().read(() -> ""String_Node_Str"").int64());
        }
       }
      System.out.println(""String_Node_Str"");
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}"
52139,"private void writeTestDocument(ThreadLocal<ExcerptAppender> tl){
  try (DocumentContext dc=tl.get().writingDocument()){
    long index=dc.index();
    dc.wire().write(""String_Node_Str"").int64(index);
    lastPosition.set(dc.wire().bytes().writePosition());
    lastIndex.set(dc.index());
  }
 }","private void writeTestDocument(ThreadLocal<ExcerptAppender> tl){
  try (DocumentContext dc=tl.get().writingDocument()){
    long index=dc.index();
    dc.wire().write(""String_Node_Str"").int64(index);
  }
 }"
52140,"@NotNull @Override public ExcerptTailer toEnd(){
  long index=approximateLastIndex();
  if (index == Long.MIN_VALUE)   return this;
  if (direction != TailerDirection.FORWARD && queue.rollCycle().toSequenceNumber(index) != 0) {
    index--;
  }
  if (moveToIndexResult(index) == ScanResult.NOT_REACHED) {
    if (moveToIndexResult(index - 1) == ScanResult.NOT_REACHED)     Jvm.debug().on(getClass(),""String_Node_Str"" + Long.toHexString(index - 1) + ""String_Node_Str"");
  }
  return this;
}","@NotNull @Override public ExcerptTailer toEnd(){
  this.index=approximateLastIndex();
  return this;
}"
52141,"/** 
 * Moves the position to the   {@code index} <p> The indexes are stored in many excerpts, sothe index2index tells chronicle where ( in other words the address of where ) the root first level targetIndex is stored. The indexing works like a tree, but only 2 levels deep, the root of the tree is at index2index ( this first level targetIndex is 1MB in size and there is only one of them, it only holds the addresses of the second level indexes, there will be many second level indexes ( created on demand ), each is about 1MB in size  (this second level targetIndex only stores the position of every 64th excerpt), so from every 64th excerpt a linear scan occurs.
 * @param recovery
 * @param wire     the data structure we are navigating
 * @param index    the index we wish to move to
 * @return the position of the {@code targetIndex} or -1 if the index can not be found
 */
ScanResult moveToIndex(StoreRecovery recovery,@NotNull final Wire wire,final long index,long timeoutMS) throws UnrecoverableTimeoutException, StreamCorruptedException {
  try {
    ScanResult scanResult=moveToIndex0(recovery,wire,index,timeoutMS);
    if (scanResult != null)     return scanResult;
  }
 catch (  EOFException fallback) {
  }
  return moveToIndexFromTheStart(wire,index);
}","/** 
 * Moves the position to the   {@code index} <p> The indexes are stored in many excerpts, so theindex2index tells chronicle where ( in other words the address of where ) the root first level targetIndex is stored. The indexing works like a tree, but only 2 levels deep, the root of the tree is at index2index ( this first level targetIndex is 1MB in size and there is only one of them, it only holds the addresses of the second level indexes, there will be many second level indexes ( created on demand ), each is about 1MB in size  (this second level targetIndex only stores the position of every 64th excerpt), so from every 64th excerpt a linear scan occurs.
 * @param recovery
 * @param wire     the data structure we are navigating
 * @param index    the index we wish to move to
 * @return the position of the {@code targetIndex} or -1 if the index can not be found
 */
ScanResult moveToIndex(StoreRecovery recovery,@NotNull final Wire wire,final long index,long timeoutMS) throws UnrecoverableTimeoutException, StreamCorruptedException {
  try {
    ScanResult scanResult=moveToIndex0(recovery,wire,index,timeoutMS);
    if (scanResult != null)     return scanResult;
  }
 catch (  EOFException fallback) {
  }
  return moveToIndexFromTheStart(wire,index);
}"
52142,"long linearScanByPosition(@NotNull final Wire wire,final long toPosition,final long fromKnownIndex,final long knownAddress) throws EOFException {
  @NotNull final Bytes<?> bytes=wire.bytes();
  bytes.readLimit(writePosition.getValue()).readPosition(knownAddress);
  long i=fromKnownIndex;
  while (bytes.readPosition() < toPosition) {
    WireIn.HeaderType headerType=wire.readDataHeader(true);
    int header=bytes.readVolatileInt();
    bytes.readSkip(Wires.lengthOf(header));
switch (headerType) {
case NONE:
      if (toPosition == Long.MAX_VALUE)       return i < 0 ? i : i - 1;
    long pos=bytes.readPosition();
  if (toPosition == pos)   return i;
throw new EOFException();
case META_DATA:
break;
case DATA:
++i;
break;
}
}
if (bytes.readPosition() == toPosition) return i;
throw new IllegalArgumentException(""String_Node_Str"");
}","long linearScanByPosition(@NotNull final Wire wire,final long toPosition,final long fromKnownIndex,final long knownAddress) throws EOFException {
  @NotNull final Bytes<?> bytes=wire.bytes();
  bytes.readLimit(writePosition.getValue()).readPosition(knownAddress);
  long i=fromKnownIndex;
  while (bytes.readPosition() < toPosition) {
    WireIn.HeaderType headerType=wire.readDataHeader(true);
    int header=bytes.readVolatileInt();
    bytes.readSkip(Wires.lengthOf(header));
switch (headerType) {
case NONE:
      if (toPosition == Long.MAX_VALUE)       return i < 0 ? i : i - 1;
    long pos=bytes.readPosition();
  if (toPosition == pos)   return i;
throw new EOFException(""String_Node_Str"" + toPosition + ""String_Node_Str""+ pos);
case META_DATA:
break;
case DATA:
++i;
break;
}
}
if (bytes.readPosition() == toPosition) return i;
throw new IllegalArgumentException(""String_Node_Str"");
}"
52143,"/** 
 * moves the context to the index of   {@code toIndex} by doing a linear scans form a {@code fromKnownIndex} at  {@code knownAddress} <p/> note meta data is skipped and does notcount to the indexes
 * @param wire           if successful, moves the context to an address relating to theindex  {@code toIndex }
 * @param toIndex        the index that we wish to move the context to
 * @param fromKnownIndex a know index ( used as a starting point )
 * @param knownAddress   a know address ( used as a starting point )
 * @see SCQIndexing#moveToIndex
 */
private ScanResult linearScan(@NotNull final Wire wire,final long toIndex,final long fromKnownIndex,final long knownAddress){
  @NotNull final Bytes<?> bytes=wire.bytes();
  long end=writePosition.getValue();
  bytes.readLimit(bytes.capacity()).readPosition(knownAddress);
  for (long i=fromKnownIndex; ; i++) {
    try {
      if (wire.readDataHeader()) {
        if (i == toIndex)         return ScanResult.FOUND;
        if (bytes.readPosition() > end)         return ScanResult.NOT_REACHED;
        bytes.readSkip(Wires.lengthOf(bytes.readInt()));
        continue;
      }
    }
 catch (    EOFException fallback) {
    }
    return i == toIndex ? ScanResult.NOT_FOUND : ScanResult.NOT_REACHED;
  }
}","/** 
 * moves the context to the index of   {@code toIndex} by doing a linear scans form a {@code fromKnownIndex} at  {@code knownAddress} <p/> note meta data is skipped and does not count tothe indexes
 * @param wire           if successful, moves the context to an address relating to the index{@code toIndex }
 * @param toIndex        the index that we wish to move the context to
 * @param fromKnownIndex a know index ( used as a starting point )
 * @param knownAddress   a know address ( used as a starting point )
 * @see SCQIndexing#moveToIndex
 */
private ScanResult linearScan(@NotNull final Wire wire,final long toIndex,final long fromKnownIndex,final long knownAddress){
  @NotNull final Bytes<?> bytes=wire.bytes();
  long end=writePosition.getValue();
  bytes.readLimit(bytes.capacity()).readPosition(knownAddress);
  for (long i=fromKnownIndex; ; i++) {
    try {
      if (wire.readDataHeader()) {
        if (i == toIndex)         return ScanResult.FOUND;
        if (bytes.readPosition() > end)         return ScanResult.NOT_REACHED;
        bytes.readSkip(Wires.lengthOf(bytes.readInt()));
        continue;
      }
    }
 catch (    EOFException fallback) {
    }
    return i == toIndex ? ScanResult.NOT_FOUND : ScanResult.NOT_REACHED;
  }
}"
52144,"public long sequenceForPosition(StoreRecovery recovery,Wire wire,long position,long timeoutMS) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException {
  final LongArrayValues index2indexArr=getIndex2index(recovery,wire,timeoutMS);
  long lastKnownAddress=0;
  long lastKnownIndex=0;
  if (((Byteable)index2indexArr).bytesStore() == null)   return linearScanByPosition(wire,position,lastKnownIndex,lastKnownAddress);
  final LongArrayValues indexArr=indexArray.get();
  Bytes<?> bytes=wire.bytes();
  for (int index2=0; index2 < indexCount; index2++) {
    long secondaryAddress=getSecondaryAddress(recovery,wire,timeoutMS,index2indexArr,index2);
    bytes.readLimit(bytes.capacity());
    try (DocumentContext context=wire.readingDocument(secondaryAddress)){
      if (!context.isPresent() || !context.isMetaData())       throw new IllegalStateException(""String_Node_Str"" + context.isPresent() + ""String_Node_Str""+ context.isMetaData());
      @NotNull final LongArrayValues array1=array(wire,indexArr,false);
      long posN=array1.getValueAt(indexCount - 1);
      if (posN > 0 && posN < position) {
        lastKnownAddress=posN;
        lastKnownIndex=((index2 + 1L << indexCountBits) - 1) << indexSpacingBits;
        continue;
      }
      for (int index1=0; index1 < indexCount; index1++) {
        long pos=array1.getValueAt(index1);
        if (pos != 0 && pos <= position) {
          lastKnownAddress=pos;
          lastKnownIndex=((long)index2 << (indexCountBits + indexSpacingBits)) + (index1 << indexSpacingBits);
          continue;
        }
        ScanResult scanResult;
        long nextIndex;
        if (lastKnownIndex < 0) {
          scanResult=firstScan(wire);
          nextIndex=0;
        }
 else {
          nextIndex=lastKnownIndex + indexSpacing;
          scanResult=linearScan(wire,nextIndex,lastKnownIndex,lastKnownAddress);
        }
        if (scanResult == ScanResult.FOUND) {
          long nextPosition=bytes.readPosition();
          array1.setOrderedValueAt(index1,nextPosition);
          array1.setMaxUsed(index1 + 1);
          if (nextPosition == position) {
            nextEntryToIndex.setMaxValue(nextIndex + 1);
            return nextIndex;
          }
        }
        long ret=linearScanByPosition(wire,position,lastKnownIndex,lastKnownAddress);
        nextEntryToIndex.setMaxValue(ret + 1);
        return ret;
      }
    }
   }
  throw new AssertionError();
}","public long sequenceForPosition(StoreRecovery recovery,Wire wire,final long position,long timeoutMS) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException {
  final LongArrayValues index2indexArr=getIndex2index(recovery,wire,timeoutMS);
  long lastKnownAddress=0;
  long lastKnownIndex=0;
  if (((Byteable)index2indexArr).bytesStore() == null)   return linearScanByPosition(wire,position,lastKnownIndex,lastKnownAddress);
  final LongArrayValues indexArr=indexArray.get();
  Bytes<?> bytes=wire.bytes();
  for (int index2=0; index2 < indexCount; index2++) {
    long secondaryAddress=getSecondaryAddress(recovery,wire,timeoutMS,index2indexArr,index2);
    bytes.readLimit(bytes.capacity());
    try (DocumentContext context=wire.readingDocument(secondaryAddress)){
      if (!context.isPresent() || !context.isMetaData())       throw new IllegalStateException(""String_Node_Str"" + context.isPresent() + ""String_Node_Str""+ context.isMetaData());
      @NotNull final LongArrayValues array1=array(wire,indexArr,false);
      long posN=array1.getValueAt(indexCount - 1);
      if (posN > 0 && posN < position) {
        lastKnownAddress=posN;
        lastKnownIndex=((index2 + 1L << indexCountBits) - 1) << indexSpacingBits;
        continue;
      }
      for (int index1=0; index1 < indexCount; index1++) {
        long pos=array1.getValueAt(index1);
        if (pos != 0 && pos <= position) {
          lastKnownAddress=pos;
          lastKnownIndex=((long)index2 << (indexCountBits + indexSpacingBits)) + (index1 << indexSpacingBits);
          continue;
        }
        ScanResult scanResult;
        long nextIndex;
        if (lastKnownIndex < 0) {
          scanResult=firstScan(wire);
          nextIndex=0;
        }
 else {
          nextIndex=lastKnownIndex + indexSpacing;
          scanResult=linearScan(wire,nextIndex,lastKnownIndex,lastKnownAddress);
        }
        if (scanResult == ScanResult.FOUND) {
          long nextPosition=bytes.readPosition();
          array1.setOrderedValueAt(index1,nextPosition);
          array1.setMaxUsed(index1 + 1);
          if (nextPosition == position) {
            nextEntryToIndex.setMaxValue(nextIndex + 1);
            return nextIndex;
          }
        }
        long ret=linearScanByPosition(wire,position,lastKnownIndex,lastKnownAddress);
        nextEntryToIndex.setMaxValue(ret + 1);
        return ret;
      }
    }
   }
  throw new AssertionError();
}"
52145,"@Override public long indexFromPosition(int cycle,WireStore store,long position){
  final Wire wire=wireType().apply(store.bytes());
  long sequenceNumber=0;
  try {
    sequenceNumber=store.sequenceForPosition(wire,position,0);
  }
 catch (  EOFException|StreamCorruptedException e) {
    throw new AssertionError(e);
  }
  return rollCycle.toIndex(cycle,sequenceNumber);
}","@Override public long indexFromPosition(int cycle,WireStore store,final long position){
  final Wire wire=wireType().apply(store.bytes());
  long sequenceNumber=0;
  try {
    sequenceNumber=store.sequenceForPosition(wire,position,0);
  }
 catch (  EOFException|StreamCorruptedException e) {
    throw new AssertionError(e);
  }
  return rollCycle.toIndex(cycle,sequenceNumber);
}"
52146,"private <T>void append2(int length,WireWriter<T> wireWriter,T writer) throws UnrecoverableTimeoutException, EOFException, StreamCorruptedException {
  setCycle(Math.max(queue.cycle(),cycle + 1),true);
  position=store.writeHeader(wire,length,queue.timeoutMS);
  wireWriter.write(writer,wire);
  wire.updateHeader(length,position,false);
}","private <T>void append2(int length,WireWriter<T> wireWriter,T writer) throws UnrecoverableTimeoutException, EOFException, StreamCorruptedException {
  setCycle(Math.max(queue.cycle(),cycle + 1),true);
  position(store.writeHeader(wire,length,queue.timeoutMS));
  wireWriter.write(writer,wire);
  wire.updateHeader(length,position,false);
}"
52147,"@Override public long sequenceForPosition(Wire wire,long position,long timeoutMS) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException {
  final Bytes<?> bytes=wire.bytes();
  long position0=bytes.readPosition();
  long remaining0=bytes.readRemaining();
  try {
    return indexing.sequenceForPosition(recovery,wire,position,timeoutMS);
  }
  finally {
    bytes.readPositionRemaining(position0,remaining0);
  }
}","@Override public long sequenceForPosition(Wire wire,final long position,long timeoutMS) throws EOFException, UnrecoverableTimeoutException, StreamCorruptedException {
  final Bytes<?> bytes=wire.bytes();
  long position0=bytes.readPosition();
  long remaining0=bytes.readRemaining();
  try {
    return indexing.sequenceForPosition(recovery,wire,position,timeoutMS);
  }
  finally {
    bytes.readPositionRemaining(position0,remaining0);
  }
}"
52148,"@Test @Ignore public void testAppendedSkipToEndMultiThreaded() throws TimeoutException, ExecutionException, InterruptedException {
  try (ChronicleQueue q=SingleChronicleQueueBuilder.binary(getTmpDir()).wireType(this.wireType).build()){
    final ThreadLocal<ExcerptAppender> tl=ThreadLocal.withInitial(() -> q.acquireAppender());
    int size=1000;
    IntStream.range(0,size).parallel().forEach(i -> writeTestDocument(tl));
    ExcerptTailer tailer=q.createTailer();
    for (int i=0; i < size; i++) {
      try (DocumentContext dc=tailer.readingDocument(false)){
        Assert.assertEquals(dc.index(),dc.wire().read(() -> ""String_Node_Str"").int64());
      }
     }
  }
 }","@Test public void testAppendedSkipToEndMultiThreaded() throws TimeoutException, ExecutionException, InterruptedException {
}"
52149,"private void writeTestDocument(ThreadLocal<ExcerptAppender> tl){
  try (DocumentContext dc=tl.get().writingDocument()){
    long index=dc.index();
    System.out.println(""String_Node_Str"" + index);
    dc.wire().write(""String_Node_Str"").int64(index);
  }
 }","private void writeTestDocument(ThreadLocal<ExcerptAppender> tl){
  try (DocumentContext dc=tl.get().writingDocument()){
    long index=dc.index();
    dc.wire().write(""String_Node_Str"").int64(index);
    lastPosition.set(dc.wire().bytes().writePosition());
    lastIndex.set(dc.index());
  }
 }"
52150,"/** 
 * @return creates a new instance of mapped bytes, because, for example thetailer and appender can be at different locations.
 */
@NotNull @Override public MappedBytes bytes(){
  return MappedBytes.mappedBytes(mappedFile);
}","/** 
 * @return creates a new instance of mapped bytes, because, for example the tailer and appendercan be at different locations.
 */
@NotNull @Override public MappedBytes bytes(){
  return MappedBytes.mappedBytes(mappedFile);
}"
52151,"@Override public void executeQuery(String query,Class<? extends Marshallable> resultType,Object... args){
  try (PreparedStatement ps=connection.prepareStatement(query)){
    for (int i=0; i < args.length; i++)     ps.setObject(i + 1,args[i]);
    ResultSet resultSet=ps.executeQuery();
    ResultSetMetaData metaData=resultSet.getMetaData();
    int columnCount=metaData.getColumnCount();
    result.queryResult(new Iterator<Marshallable>(){
      @Override public boolean hasNext(){
        try {
          return resultSet.next();
        }
 catch (        SQLException e) {
          throw Jvm.rethrow(e);
        }
      }
      @Override public Marshallable next(){
        return new Marshallable(){
          @Override public void writeMarshallable(          @NotNull WireOut wire){
            try {
              for (int i=1; i <= columnCount; i++) {
                wire.writeEventName(metaData.getCatalogName(i)).object(resultSet.getObject(i));
              }
            }
 catch (            SQLException e) {
              throw Jvm.rethrow(e);
            }
          }
        }
;
      }
    }
,query,args);
  }
 catch (  Throwable t) {
    result.queryThrown(t,query,args);
  }
}","@Override public void executeQuery(String query,Object... args){
  try (PreparedStatement ps=connection.prepareStatement(query)){
    for (int i=0; i < args.length; i++)     ps.setObject(i + 1,args[i]);
    ResultSet resultSet=ps.executeQuery();
    ResultSetMetaData metaData=resultSet.getMetaData();
    int columnCount=metaData.getColumnCount();
    List<String> headings=new ArrayList<>(columnCount);
    for (int i=1; i <= columnCount; i++)     headings.add(metaData.getColumnName(i));
    List<List<Object>> rows=new ArrayList<>();
    while (resultSet.next()) {
      List<Object> row=new ArrayList<>(columnCount);
      for (int i=1; i <= columnCount; i++) {
        row.add(resultSet.getObject(i));
      }
      rows.add(row);
    }
    result.queryResult(headings,rows,query,args);
  }
 catch (  Throwable t) {
    result.queryThrown(t,query,args);
  }
}"
52152,"void queryResult(Iterator<Marshallable> marshallableList,String query,Object... args);","void queryResult(List<String> columns,List<List<Object>> rows,String query,Object... args);"
52153,"void executeQuery(String query,Class<? extends Marshallable> resultType,Object... args);","void executeQuery(String query,Object... args);"
52154,"@Override public long recoverAndWriteHeader(Wire wire,int length,long timeoutMS) throws UnrecoverableTimeoutException {
  while (true) {
    Jvm.warn().on(getClass(),""String_Node_Str"" + Long.toHexString(wire.headerNumber()) + ""String_Node_Str""+ wire.bytes().writePosition());
    try {
      return wire.writeHeader(length,timeoutMS,TimeUnit.MILLISECONDS);
    }
 catch (    TimeoutException e) {
      Jvm.warn().on(getClass(),e);
    }
catch (    EOFException e) {
      throw new AssertionError(e);
    }
  }
}","@Override public long recoverAndWriteHeader(Wire wire,int length,long timeoutMS) throws UnrecoverableTimeoutException {
  while (true) {
    long offset=wire.bytes().writePosition();
    int num=wire.bytes().readInt(offset);
    if (Wires.isNotComplete(num) && wire.bytes().compareAndSwapInt(offset,num,0)) {
      Jvm.warn().on(getClass(),""String_Node_Str"" + Long.toHexString(wire.headerNumber()) + ""String_Node_Str""+ offset+ ""String_Node_Str"");
    }
 else {
      Jvm.warn().on(getClass(),""String_Node_Str"" + Long.toHexString(wire.headerNumber()) + ""String_Node_Str""+ offset+ ""String_Node_Str"");
    }
    try {
      return wire.writeHeader(length,timeoutMS,TimeUnit.MILLISECONDS);
    }
 catch (    TimeoutException e) {
      Jvm.warn().on(getClass(),e);
    }
catch (    EOFException e) {
      throw new AssertionError(e);
    }
  }
}"
52155,"@Test(expected=UnsupportedOperationException.class) public void testZeroLengthMessage(){
  File tmpDir=getTmpDir();
  try (ChronicleQueue chronicle=SingleChronicleQueueBuilder.binary(tmpDir).wireType(this.wireType).build()){
    ExcerptAppender appender=chronicle.createAppender();
    appender.writeDocument(w -> {
    }
);
    System.out.println(chronicle.dump());
  }
 }","@Test public void testZeroLengthMessage(){
  File tmpDir=getTmpDir();
  try (ChronicleQueue chronicle=SingleChronicleQueueBuilder.binary(tmpDir).rollCycle(RollCycles.TEST_DAILY).wireType(this.wireType).build()){
    ExcerptAppender appender=chronicle.createAppender();
    appender.writeDocument(w -> {
    }
);
    System.out.println(chronicle.dump());
    ExcerptTailer tailer=chronicle.createTailer();
    try (DocumentContext dc=tailer.readingDocument()){
      assertFalse(dc.wire().hasMore());
    }
   }
 }"
52156,"@Ignore(""String_Node_Str"") @Test public void testAppendAndRead() throws TimeoutException, ExecutionException, InterruptedException {
}","@Test public void testAppendAndRead() throws TimeoutException, ExecutionException, InterruptedException {
}"
52157,"@Override public void dump(Writer writer,long fromIndex,long toIndex){
  try {
    long firstIndex=firstIndex();
    writer.append(""String_Node_Str"").append(Long.toHexString(firstIndex)).append(""String_Node_Str"");
    writer.append(""String_Node_Str"").append(Long.toHexString(lastIndex())).append(""String_Node_Str"");
    ExcerptTailer tailer=createTailer();
    if (!tailer.moveToIndex(fromIndex)) {
      if (firstIndex > fromIndex) {
        tailer.toStart();
      }
 else {
        return;
      }
    }
    Bytes bytes=Wires.acquireBytes();
    TextWire text=new TextWire(bytes);
    while (true) {
      try (DocumentContext dc=tailer.readingDocument()){
        if (!dc.isPresent()) {
          writer.append(""String_Node_Str"").append(Long.toHexString(dc.index())).append(""String_Node_Str"");
          return;
        }
        if (dc.index() > toIndex)         return;
        writer.append(""String_Node_Str"").append(Long.toHexString(dc.index())).append(""String_Node_Str"");
        Wire wire=dc.wire();
        long start=wire.bytes().readPosition();
        try {
          text.clear();
          wire.copyTo(text);
          writer.append(bytes.toString());
        }
 catch (        Exception e) {
          wire.bytes().readPosition(start);
          writer.append(wire.bytes()).append(""String_Node_Str"");
        }
      }
     }
  }
 catch (  Exception e) {
    e.printStackTrace(new PrintWriter(writer));
  }
}","@Override public void dump(Writer writer,long fromIndex,long toIndex){
  try {
    long firstIndex=firstIndex();
    writer.append(""String_Node_Str"").append(Long.toHexString(firstIndex)).append(""String_Node_Str"");
    writer.append(""String_Node_Str"").append(Long.toHexString(lastIndex())).append(""String_Node_Str"");
    ExcerptTailer tailer=createTailer();
    if (!tailer.moveToIndex(fromIndex)) {
      if (firstIndex > fromIndex) {
        tailer.toStart();
      }
 else {
        return;
      }
    }
    Bytes bytes=Wires.acquireBytes();
    TextWire text=new TextWire(bytes);
    while (true) {
      try (DocumentContext dc=tailer.readingDocument()){
        if (!dc.isPresent()) {
          writer.append(""String_Node_Str"").append(Long.toHexString(dc.index())).append(""String_Node_Str"");
          return;
        }
        if (dc.index() > toIndex)         return;
        writer.append(""String_Node_Str"").append(Long.toHexString(dc.index())).append(""String_Node_Str"");
        Wire wire=dc.wire();
        long start=wire.bytes().readPosition();
        try {
          text.clear();
          wire.copyTo(text);
          writer.append(bytes.toString());
        }
 catch (        Exception e) {
          wire.bytes().readPosition(start);
          writer.append(wire.bytes()).append(""String_Node_Str"");
        }
      }
     }
  }
 catch (  Exception e) {
    e.printStackTrace(new PrintWriter(writer));
  }
 finally {
    try {
      writer.flush();
    }
 catch (    IOException ignore) {
    }
  }
}"
52158,"long acquireIndex2Index(Wire wire,long timeoutMS) throws EOFException, TimeoutException {
  long start=System.currentTimeMillis();
  try {
    do {
      long index2Index=this.index2Index.getVolatileValue();
      if (index2Index == LONG_NOT_COMPLETE) {
        wire.pauser().pause(timeoutMS,TimeUnit.MILLISECONDS);
        continue;
      }
      if (index2Index != NOT_INITIALIZED)       return index2Index;
      if (!this.index2Index.compareAndSwapValue(NOT_INITIALIZED,LONG_NOT_COMPLETE))       continue;
      long index=NOT_INITIALIZED;
      try {
        index=newIndex(wire,true,timeoutMS);
      }
  finally {
        this.index2Index.setOrderedValue(index);
      }
      return index;
    }
 while (System.currentTimeMillis() < start + timeoutMS);
  }
  finally {
    wire.pauser().reset();
  }
  throw new IllegalStateException(""String_Node_Str"");
}","long acquireIndex2Index(Wire wire,long timeoutMS) throws EOFException, TimeoutException {
  try {
    return acquireIndex2Index0(wire,timeoutMS);
  }
 catch (  TimeoutException te) {
    LOG.warn(""String_Node_Str"" + te);
    this.index2Index.setValue(0);
    return acquireIndex2Index0(wire,timeoutMS);
  }
}"
52159,"long newIndex(Wire wire,LongArrayValues index2Index,long index2,long timeoutMS) throws EOFException, TimeoutException {
  try {
    if (index2Index.compareAndSet(index2,NOT_INITIALIZED,LONG_NOT_COMPLETE)) {
      long pos=newIndex(wire,false,timeoutMS);
      if (pos < 0)       throw new IllegalStateException(""String_Node_Str"" + pos);
      if (index2Index.compareAndSet(index2,LONG_NOT_COMPLETE,pos)) {
        index2Index.setMaxUsed(index2 + 1);
        return pos;
      }
      throw new IllegalStateException(""String_Node_Str"" + index2 + ""String_Node_Str"");
    }
    for (; ; ) {
      long pos=index2Index.getVolatileValueAt(index2);
      if (pos == LONG_NOT_COMPLETE) {
        wire.pauser().pause(timeoutMS,TimeUnit.MILLISECONDS);
      }
 else {
        wire.pauser().reset();
        return pos;
      }
    }
  }
 catch (  Exception e) {
    index2Index.compareAndSet(index2,LONG_NOT_COMPLETE,NOT_INITIALIZED);
    throw e;
  }
}","long newIndex(Wire wire,LongArrayValues index2Index,long index2,long timeoutMS) throws EOFException, TimeoutException {
  try {
    if (index2Index.compareAndSet(index2,NOT_INITIALIZED,BinaryLongReference.LONG_NOT_COMPLETE)) {
      long pos=newIndex(wire,false,timeoutMS);
      if (pos < 0)       throw new IllegalStateException(""String_Node_Str"" + pos);
      if (index2Index.compareAndSet(index2,BinaryLongReference.LONG_NOT_COMPLETE,pos)) {
        index2Index.setMaxUsed(index2 + 1);
        return pos;
      }
      throw new IllegalStateException(""String_Node_Str"" + index2 + ""String_Node_Str"");
    }
    for (; ; ) {
      long pos=index2Index.getVolatileValueAt(index2);
      if (pos == BinaryLongReference.LONG_NOT_COMPLETE) {
        wire.pauser().pause(timeoutMS,TimeUnit.MILLISECONDS);
      }
 else {
        wire.pauser().reset();
        return pos;
      }
    }
  }
 catch (  Exception e) {
    index2Index.compareAndSet(index2,BinaryLongReference.LONG_NOT_COMPLETE,NOT_INITIALIZED);
    throw e;
  }
}"
52160,"private long getSecondaryAddress0(Wire wire,long timeoutMS,LongArrayValues index2indexArr,int index2) throws TimeoutException {
  long secondaryAddress;
  while (true) {
    secondaryAddress=index2indexArr.getVolatileValueAt(index2);
    if (secondaryAddress == LONG_NOT_COMPLETE) {
      wire.pauser().pause(timeoutMS,TimeUnit.MILLISECONDS);
    }
 else {
      if (secondaryAddress > wire.bytes().capacity())       throw new IllegalStateException(""String_Node_Str"" + secondaryAddress);
      wire.pauser().reset();
      break;
    }
  }
  return secondaryAddress;
}","private long getSecondaryAddress0(Wire wire,long timeoutMS,LongArrayValues index2indexArr,int index2) throws TimeoutException {
  long secondaryAddress;
  while (true) {
    secondaryAddress=index2indexArr.getVolatileValueAt(index2);
    if (secondaryAddress == BinaryLongReference.LONG_NOT_COMPLETE) {
      wire.pauser().pause(timeoutMS,TimeUnit.MILLISECONDS);
    }
 else {
      if (secondaryAddress > wire.bytes().capacity())       throw new IllegalStateException(""String_Node_Str"" + secondaryAddress);
      wire.pauser().reset();
      break;
    }
  }
  return secondaryAddress;
}"
52161,"long getSecondaryAddress(Wire wire,long timeoutMS,LongArrayValues index2indexArr,int index2) throws EOFException, TimeoutException {
  long secondaryAddress=index2indexArr.getValueAt(index2);
  if (secondaryAddress == 0) {
    secondaryAddress=newIndex(wire,index2indexArr,index2,timeoutMS);
    if (secondaryAddress > wire.bytes().capacity())     throw new IllegalStateException(""String_Node_Str"" + secondaryAddress);
    long sa=index2indexArr.getValueAt(index2);
    if (sa != secondaryAddress)     throw new AssertionError();
  }
 else   if (secondaryAddress == LONG_NOT_COMPLETE) {
    secondaryAddress=getSecondaryAddress0(wire,timeoutMS,index2indexArr,index2);
  }
 else   if (secondaryAddress > wire.bytes().capacity()) {
    throw new IllegalStateException(""String_Node_Str"" + secondaryAddress);
  }
  return secondaryAddress;
}","long getSecondaryAddress(Wire wire,long timeoutMS,LongArrayValues index2indexArr,int index2) throws EOFException, TimeoutException {
  long secondaryAddress=index2indexArr.getValueAt(index2);
  if (secondaryAddress == 0) {
    secondaryAddress=newIndex(wire,index2indexArr,index2,timeoutMS);
    if (secondaryAddress > wire.bytes().capacity())     throw new IllegalStateException(""String_Node_Str"" + secondaryAddress);
    long sa=index2indexArr.getValueAt(index2);
    if (sa != secondaryAddress)     throw new AssertionError();
  }
 else   if (secondaryAddress == BinaryLongReference.LONG_NOT_COMPLETE) {
    secondaryAddress=getSecondaryAddress0(wire,timeoutMS,index2indexArr,index2);
  }
 else   if (secondaryAddress > wire.bytes().capacity()) {
    throw new IllegalStateException(""String_Node_Str"" + secondaryAddress);
  }
  return secondaryAddress;
}"
52162,"/** 
 * tests that when flags are set to not complete we are able to recover
 */
@Test public void testUsingANotCompleteQueue() throws TimeoutException, ExecutionException, InterruptedException {
  File tmpDir=getTmpDir();
  try (final RollingChronicleQueue queue=new SingleChronicleQueueBuilder(tmpDir).wireType(WireType.BINARY).build()){
    ExcerptAppender appender=queue.createAppender();
    try (DocumentContext documentContext=appender.writingDocument()){
      documentContext.wire().write(""String_Node_Str"").text(""String_Node_Str"");
    }
     Thread.sleep(100);
    System.out.println(queue.dump());
  }
   BinaryLongReference.forceAllToNotCompleteState();
  try (final RollingChronicleQueue queue=new SingleChronicleQueueBuilder(tmpDir).wireType(WireType.BINARY).build()){
    ExcerptTailer tailer=queue.createTailer();
    try (DocumentContext documentContext=tailer.readingDocument()){
      Assert.assertEquals(""String_Node_Str"",documentContext.wire().read(() -> ""String_Node_Str"").text());
    }
   }
 }","/** 
 * tests that when flags are set to not complete we are able to recover
 */
@Test public void testUsingANotCompleteQueue() throws TimeoutException, ExecutionException, InterruptedException {
  BinaryLongReference.startCollecting();
  File tmpDir=getTmpDir();
  try (final RollingChronicleQueue queue=new SingleChronicleQueueBuilder(tmpDir).wireType(WireType.BINARY).build()){
    ExcerptAppender appender=queue.createAppender();
    try (DocumentContext documentContext=appender.writingDocument()){
      documentContext.wire().write(""String_Node_Str"").text(""String_Node_Str"");
    }
     Thread.sleep(100);
    System.out.println(queue.dump());
  }
   BinaryLongReference.forceAllToNotCompleteState();
  try (final RollingChronicleQueue queue=new SingleChronicleQueueBuilder(tmpDir).wireType(WireType.BINARY).timeoutMS(500).build()){
    System.out.println(queue.dump());
    ExcerptTailer tailer=queue.createTailer();
    try (DocumentContext documentContext=tailer.readingDocument()){
      Assert.assertEquals(""String_Node_Str"",documentContext.wire().read(() -> ""String_Node_Str"").text());
    }
   }
 }"
52163,"long getSecondaryAddress(Wire wire,long timeoutMS,LongArrayValues index2indexArr,int index2) throws EOFException, TimeoutException {
  long secondaryAddress=index2indexArr.getValueAt(index2);
  if (secondaryAddress == 0) {
    secondaryAddress=newIndex(wire,index2indexArr,index2,timeoutMS);
    if (secondaryAddress > wire.bytes().capacity())     throw new IllegalStateException(""String_Node_Str"" + secondaryAddress);
    long sa=index2indexArr.getValueAt(index2);
    if (sa != secondaryAddress)     throw new AssertionError();
  }
 else   if (secondaryAddress == BinaryLongReference.LONG_NOT_COMPLETE) {
    secondaryAddress=getSecondaryAddress0(wire,timeoutMS,index2indexArr,index2);
  }
 else   if (secondaryAddress > wire.bytes().capacity()) {
    throw new IllegalStateException(""String_Node_Str"" + secondaryAddress);
  }
  return secondaryAddress;
}","long getSecondaryAddress(Wire wire,long timeoutMS,LongArrayValues index2indexArr,int index2) throws EOFException, TimeoutException {
  try {
    return getSecondaryAddress1(wire,timeoutMS,index2indexArr,index2);
  }
 catch (  TimeoutException e) {
    LOG.warn(""String_Node_Str"" + index2 + ""String_Node_Str""+ e);
    index2indexArr.setValueAt(index2,0L);
    return getSecondaryAddress1(wire,timeoutMS,index2indexArr,index2);
  }
}"
52164,"@Test(expected=UnsupportedOperationException.class) public void testZeroLengthMessage(){
}","@Test(expected=UnsupportedOperationException.class) public void testZeroLengthMessage(){
  File tmpDir=getTmpDir();
  try (ChronicleQueue chronicle=new SingleChronicleQueueBuilder(tmpDir).wireType(this.wireType).build()){
    ExcerptAppender appender=chronicle.createAppender();
    appender.writeDocument(w -> {
    }
);
    System.out.println(chronicle.dump());
  }
 }"
52165,"/** 
 * tests that when flags are set to not complete we are able to recover
 */
@Test public void testUsingANotCompleteQueue() throws TimeoutException, ExecutionException, InterruptedException {
  BinaryLongReference.startCollecting();
  File tmpDir=getTmpDir();
  try (final RollingChronicleQueue queue=new SingleChronicleQueueBuilder(tmpDir).wireType(WireType.BINARY).build()){
    ExcerptAppender appender=queue.createAppender();
    try (DocumentContext documentContext=appender.writingDocument()){
      documentContext.wire().write(""String_Node_Str"").text(""String_Node_Str"");
    }
     Thread.sleep(100);
    System.out.println(queue.dump());
  }
   BinaryLongReference.forceAllToNotCompleteState();
  try (final RollingChronicleQueue queue=new SingleChronicleQueueBuilder(tmpDir).wireType(WireType.BINARY).timeoutMS(500).build()){
    System.out.println(queue.dump());
    ExcerptTailer tailer=queue.createTailer();
    try (DocumentContext documentContext=tailer.readingDocument()){
      Assert.assertEquals(""String_Node_Str"",documentContext.wire().read(() -> ""String_Node_Str"").text());
    }
   }
 }","/** 
 * tests that when flags are set to not complete we are able to recover
 */
@Test public void testUsingANotCompleteQueue() throws TimeoutException, ExecutionException, InterruptedException {
  BinaryLongReference.startCollecting();
  File tmpDir=getTmpDir();
  try (final RollingChronicleQueue queue=new SingleChronicleQueueBuilder(tmpDir).wireType(WireType.BINARY).rollCycle(RollCycles.TEST_DAILY).build()){
    ExcerptAppender appender=queue.createAppender();
    try (DocumentContext documentContext=appender.writingDocument()){
      documentContext.wire().write(""String_Node_Str"").text(""String_Node_Str"");
    }
     Thread.sleep(100);
    System.out.println(queue.dump());
  }
   BinaryLongReference.forceAllToNotCompleteState();
  try (final RollingChronicleQueue queue=new SingleChronicleQueueBuilder(tmpDir).wireType(WireType.BINARY).timeoutMS(500).build()){
    System.out.println(queue.dump());
    ExcerptTailer tailer=queue.createTailer();
    try (DocumentContext documentContext=tailer.readingDocument()){
      Assert.assertEquals(""String_Node_Str"",documentContext.wire().read(() -> ""String_Node_Str"").text());
    }
   }
 }"
52166,"private boolean next() throws TimeoutException {
  if (this.store == null) {
    final long firstIndex=queue.firstIndex();
    if (firstIndex == Long.MAX_VALUE)     return false;
    if (!this.moveToIndex(firstIndex))     return false;
  }
  Bytes<?> bytes=wire.bytes();
  bytes.readLimit(bytes.capacity());
  for (int i=0; i < 1000; i++) {
    try {
      if (direction != TailerDirection.FORWARD)       try {
        moveToIndex(index);
      }
 catch (      TimeoutException notReady) {
        return false;
      }
      if (wire.readDataHeader()) {
        closeReadLimit(bytes.capacity());
        wire.readAndSetLength(bytes.readPosition());
        long end=bytes.readLimit();
        closeReadPosition(end);
        return true;
      }
      return false;
    }
 catch (    EOFException eof) {
      if (cycle <= queue.lastCycle() && direction != TailerDirection.NONE)       try {
        if (moveToIndex(cycle + direction.add(),0)) {
          bytes=wire.bytes();
          continue;
        }
      }
 catch (      TimeoutException failed) {
      }
      return false;
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","private boolean next(boolean includeMetaData) throws TimeoutException {
  if (this.store == null) {
    final long firstIndex=queue.firstIndex();
    if (firstIndex == Long.MAX_VALUE)     return false;
    if (!this.moveToIndex(firstIndex))     return false;
  }
  Bytes<?> bytes=wire.bytes();
  bytes.readLimit(bytes.capacity());
  for (int i=0; i < 1000; i++) {
    try {
      if (direction != TailerDirection.FORWARD)       try {
        moveToIndex(index);
      }
 catch (      TimeoutException notReady) {
        return false;
      }
switch (wire.readDataHeader(includeMetaData)) {
case NONE:
        return false;
case META_DATA:
      metaData(true);
    break;
case DATA:
  metaData(false);
break;
}
closeReadLimit(bytes.capacity());
wire.readAndSetLength(bytes.readPosition());
long end=bytes.readLimit();
closeReadPosition(end);
return true;
}
 catch (EOFException eof) {
if (cycle <= queue.lastCycle() && direction != TailerDirection.NONE) try {
if (moveToIndex(cycle + direction.add(),0)) {
bytes=wire.bytes();
continue;
}
}
 catch (TimeoutException failed) {
}
return false;
}
}
throw new IllegalStateException(""String_Node_Str"");
}"
52167,"@Override public DocumentContext readingDocument(boolean includeMetaData){
  while (true) {
    try {
      present=next();
    }
 catch (    TimeoutException ignored) {
      present=false;
    }
    if (present) {
      if (!includeMetaData && isMetaData()) {
        close();
        continue;
      }
      return this;
    }
    return NoDocumentContext.INSTANCE;
  }
}","@Override public DocumentContext readingDocument(boolean includeMetaData){
  try {
    if (present=next(includeMetaData))     return this;
  }
 catch (  TimeoutException ignored) {
  }
  return NoDocumentContext.INSTANCE;
}"
52168,"/** 
 * Write a Map as a marshallable
 */
default void writeMap(Map<String,Object> map){
  QueueInternal.writeMap(this,map);
}","/** 
 * Write a Map as a marshallable
 */
default void writeMap(Map<String,?> map){
  QueueInternal.writeMap(this,map);
}"
52169,"@Override public DocumentContext writingDocument(){
  try {
    position=wire.writeHeader(queue.timeoutMS,TimeUnit.MILLISECONDS);
    metaData=false;
  }
 catch (  TimeoutException e) {
    throw new IllegalStateException(e);
  }
catch (  EOFException e) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return this;
}","@Override public DocumentContext writingDocument(){
}"
52170,"@Override public boolean readDocument(@NotNull final ReadMarshallable marshaller){
  try {
    return read(marshaller,ReadMarshallable::readMarshallable,queue.timeoutMS);
  }
 catch (  TimeoutException e) {
    return false;
  }
}","@Override public boolean readDocument(@NotNull final ReadMarshallable marshaller){
  return read(marshaller,ReadMarshallable::readMarshallable);
}"
52171,"private boolean checkAppendingThread(){
  Thread appendingThread=this.appendingThread;
  if (appendingThread != null)   throw new IllegalStateException(""String_Node_Str"" + Thread.currentThread() + ""String_Node_Str""+ appendingThread);
  this.appendingThread=Thread.currentThread();
  return true;
}","private boolean checkAppendingThread(){
  Thread appendingThread=this.appendingThread;
  Thread currentThread=Thread.currentThread();
  if (appendingThread != null) {
    if (appendingThread == currentThread)     throw new IllegalStateException(""String_Node_Str"");
    throw new IllegalStateException(""String_Node_Str"" + currentThread + ""String_Node_Str""+ appendingThread);
  }
  this.appendingThread=currentThread;
  return true;
}"
52172,"private <T>boolean read(@NotNull final T t,@NotNull final BiConsumer<T,Wire> c,long timeoutMS) throws TimeoutException {
  if (this.store == null) {
    toStart();
    if (this.store == null)     return false;
  }
  if (read0(t,c)) {
    incrementIndex();
    return true;
  }
  return false;
}","private <T>boolean read(@NotNull final T t,@NotNull final BiConsumer<T,Wire> c){
  if (this.store == null) {
    toStart();
    if (this.store == null)     return false;
  }
  if (read0(t,c)) {
    incrementIndex();
    return true;
  }
  return false;
}"
52173,"@Nullable public boolean readText(StringBuilder sb){
  try {
    if (read(sb,(t,w) -> w.bytes().parseUtf8(sb,(int)w.bytes().readRemaining()),queue.timeoutMS))     return true;
  }
 catch (  TimeoutException e) {
  }
  sb.setLength(0);
  sb.append(""String_Node_Str"");
  return false;
}","@Nullable public boolean readText(StringBuilder sb){
  if (read(sb,(t,w) -> w.bytes().parseUtf8(sb,(int)w.bytes().readRemaining())))   return true;
  sb.setLength(0);
  sb.append(""String_Node_Str"");
  return false;
}"
52174,"@Override public boolean readBytes(@NotNull final ReadBytesMarshallable using){
  try {
    return read(using,(t,w) -> t.readMarshallable(w.bytes()),queue.timeoutMS);
  }
 catch (  TimeoutException e) {
    return false;
  }
}","@Override public boolean readBytes(@NotNull final ReadBytesMarshallable using){
  return read(using,(t,w) -> t.readMarshallable(w.bytes()));
}"
52175,"@Override public long lastIndexAppended(){
  if (lastIndex != Long.MIN_VALUE)   return lastIndex;
  if (this.position == -1)   throw new IllegalStateException(""String_Node_Str"");
  try {
    long sequenceNumber=store.indexForPosition(wire,position,queue.timeoutMS);
    final long index=queue.rollCycle().toIndex(cycle,sequenceNumber);
    return index;
  }
 catch (  EOFException|TimeoutException e) {
    throw new AssertionError(e);
  }
 finally {
    wire.bytes().writePosition(store.writePosition());
  }
}","@Override public long lastIndexAppended(){
  if (lastIndex != Long.MIN_VALUE)   return lastIndex;
  if (this.position == -1)   throw new IllegalStateException(""String_Node_Str"");
  try {
    long sequenceNumber=store.indexForPosition(wire,position,queue.timeoutMS);
    lastIndex=queue.rollCycle().toIndex(cycle,sequenceNumber);
    return lastIndex;
  }
 catch (  EOFException|TimeoutException e) {
    throw new AssertionError(e);
  }
 finally {
    wire.bytes().writePosition(store.writePosition());
  }
}"
52176,"private void rollCycleTo(int cycle) throws TimeoutException {
  wire.writeEndOfWire(queue.timeoutMS,TimeUnit.MILLISECONDS);
  setCycle2(cycle);
}","private void rollCycleTo(int cycle) throws TimeoutException {
  if (wire != null)   wire.writeEndOfWire(queue.timeoutMS,TimeUnit.MILLISECONDS);
  setCycle2(cycle);
}"
52177,"public StoreAppender(@NotNull SingleChronicleQueue queue){
  this.queue=queue;
  int cycle=this.queue.lastCycle();
  if (cycle < 0)   cycle=queue.cycle();
  setCycle2(cycle);
}","public StoreAppender(@NotNull SingleChronicleQueue queue){
  this.queue=queue;
}"
52178,"/** 
 * moves the context to the index of   {@code toIndex} by doing a linear scans form a {@code fromKnownIndex} at  {@code knownAddress} <p/> note meta data is skipped and does notcount to the indexes
 * @param wire           if successful, moves the context to an address relating to theindex  {@code toIndex }
 * @param toIndex        the index that we wish to move the context to
 * @param fromKnownIndex a know index ( used as a starting point )
 * @param knownAddress   a know address ( used as a starting point )
 * @see net.openhft.chronicle.queue.impl.single.SingleChronicleQueueStore.Indexing#moveToIndex
 */
private ScanResult linearScan(@NotNull final Wire wire,final long toIndex,final long fromKnownIndex,final long knownAddress){
  @NotNull final Bytes<?> bytes=wire.bytes();
  bytes.readLimit(writePosition.getValue()).readPosition(knownAddress);
  for (long i=fromKnownIndex; ; i++) {
    try {
      if (bytes.readRemaining() < 4)       return ScanResult.NOT_REACHED;
      if (wire.readDataHeader()) {
        if (i == toIndex)         return ScanResult.FOUND;
        bytes.readSkip(Wires.lengthOf(bytes.readInt()));
        continue;
      }
    }
 catch (    EOFException e) {
    }
    return i == toIndex ? ScanResult.NOT_FOUND : ScanResult.NOT_REACHED;
  }
}","/** 
 * moves the context to the index of   {@code toIndex} by doing a linear scans form a {@code fromKnownIndex} at  {@code knownAddress} <p/> note meta data is skipped and does notcount to the indexes
 * @param wire           if successful, moves the context to an address relating to theindex  {@code toIndex }
 * @param toIndex        the index that we wish to move the context to
 * @param fromKnownIndex a know index ( used as a starting point )
 * @param knownAddress   a know address ( used as a starting point )
 * @see net.openhft.chronicle.queue.impl.single.SingleChronicleQueueStore.Indexing#moveToIndex
 */
private ScanResult linearScan(@NotNull final Wire wire,final long toIndex,final long fromKnownIndex,final long knownAddress){
  @NotNull final Bytes<?> bytes=wire.bytes();
  long end=writePosition.getValue();
  bytes.readLimit(bytes.capacity()).readPosition(knownAddress);
  for (long i=fromKnownIndex; ; i++) {
    try {
      if (wire.readDataHeader()) {
        if (i == toIndex)         return ScanResult.FOUND;
        if (bytes.readPosition() > end)         return ScanResult.NOT_REACHED;
        bytes.readSkip(Wires.lengthOf(bytes.readInt()));
        continue;
      }
    }
 catch (    EOFException e) {
    }
    return i == toIndex ? ScanResult.NOT_FOUND : ScanResult.NOT_REACHED;
  }
}"
52179,"public long lastIndex(int cycle){
  cycle(cycle);
  long sequenceNumber=store.lastEntryIndexed(wire,queue.timeoutMS);
  return queue.rollCycle().toIndex(this.cycle,sequenceNumber);
}","public long lastIndex(int cycle){
  cycle(cycle);
  long sequenceNumber=store.lastEntryIndexed(wire,queue.timeoutMS);
  return queue.rollCycle().toIndex(this.cycle,sequenceNumber + 1) - 1;
}"
52180,"@NotNull @Override public ExcerptTailer toEnd(){
  long index=queue.lastIndex();
  if (index == Long.MIN_VALUE)   return this;
  try {
    if (direction == TailerDirection.FORWARD)     index++;
    moveToIndex(index);
  }
 catch (  TimeoutException e) {
    throw new AssertionError(e);
  }
  return this;
}","@NotNull @Override public ExcerptTailer toEnd(){
  long index=queue.lastIndex();
  if (index == Long.MIN_VALUE)   return this;
  try {
    if (direction == TailerDirection.FORWARD || queue.rollCycle().toSequenceNumber(index + 1) == 0)     index++;
    moveToIndex(index);
  }
 catch (  TimeoutException e) {
    throw new AssertionError(e);
  }
  return this;
}"
52181,"@Test public void toEndBeforeWriteTest(){
  String baseDir=OS.TARGET + ""String_Node_Str"";
  IOTools.shallowDeleteDirWithFiles(baseDir);
  ChronicleQueue queue=new SingleChronicleQueueBuilder(baseDir).build();
  checkOneFile(baseDir);
  ExcerptAppender appender=queue.createAppender();
  checkOneFile(baseDir);
  ExcerptTailer tailer=queue.createTailer();
  checkOneFile(baseDir);
  ExcerptTailer tailer2=queue.createTailer();
  checkOneFile(baseDir);
  tailer.toEnd();
  tailer2.toEnd();
  checkOneFile(baseDir);
  IOTools.shallowDeleteDirWithFiles(baseDir);
}","@Test public void toEndBeforeWriteTest(){
  String baseDir=OS.TARGET + ""String_Node_Str"";
  IOTools.shallowDeleteDirWithFiles(baseDir);
  ChronicleQueue queue=new SingleChronicleQueueBuilder(baseDir).build();
  checkOneFile(baseDir);
  ExcerptAppender appender=queue.createAppender();
  checkOneFile(baseDir);
  ExcerptTailer tailer=queue.createTailer();
  checkOneFile(baseDir);
  ExcerptTailer tailer2=queue.createTailer();
  checkOneFile(baseDir);
  tailer.toEnd();
  checkOneFile(baseDir);
  tailer2.toEnd();
  checkOneFile(baseDir);
  IOTools.shallowDeleteDirWithFiles(baseDir);
}"
52182,"/** 
 * A Tailer can be used to read sequentially from the lower of a given position.
 * @return ExcerptTailer
 * @throws IOException if an IO problem occurs
 */
@NotNull ExcerptTailer createTailer() throws IOException ;","/** 
 * A Tailer can be used to read sequentially from the lower of a given position.
 * @return ExcerptTailer
 */
@NotNull ExcerptTailer createTailer();"
52183,DocumentContext writingDocument(boolean metaData);,DocumentContext writingDocument();
52184,"@NotNull @Override public ExcerptTailer createTailer() throws IOException {
  return excerptFactory.createTailer(this);
}","@NotNull @Override public ExcerptTailer createTailer(){
  return excerptFactory.createTailer(this);
}"
52185,"public boolean consumeBytes(BytesConsumer consumer) throws InterruptedException {
  @NotNull final Bytes<?> bytes=wire.bytes();
  final long start=bytes.writePosition();
  bytes.writeInt(Wires.NOT_READY);
  if (!consumer.accept(bytes)) {
    bytes.writeSkip(-4);
    bytes.writeInt(bytes.writePosition(),0);
    return false;
  }
  final long len=bytes.writePosition() - start - 4;
  if (len == 0) {
    bytes.writeSkip(-4);
    bytes.writeInt(bytes.writePosition(),0);
    return false;
  }
  bytes.writeInt(start,toIntU30(len,""String_Node_Str"" + ""String_Node_Str""));
  store().writePosition(bytes.writePosition()).storeIndexLocation(wire,start,++index);
  return true;
}","public boolean consumeBytes(BytesConsumer consumer) throws InterruptedException {
  @NotNull final Bytes<?> bytes=wire.bytes();
  final long start=bytes.writePosition();
  bytes.writeInt(Wires.NOT_READY);
  if (!consumer.accept(bytes)) {
    bytes.writeSkip(-4);
    bytes.writeInt(bytes.writePosition(),0);
    return false;
  }
  final long len=bytes.writePosition() - start - 4;
  if (len == 0) {
    bytes.writeSkip(-4);
    bytes.writeInt(bytes.writePosition(),0);
    return false;
  }
  bytes.writeInt(start,toIntU30(len,""String_Node_Str"" + ""String_Node_Str""));
  store().writePosition(bytes.writePosition()).storeIndexLocation(wire,start,++sequenceNumber);
  return true;
}"
52186,"@Override public DocumentContext writingDocument(boolean metaData){
  dc.start(metaData);
  return dc;
}","@Override public DocumentContext writingDocument(){
  dc.start(false);
  return dc;
}"
52187,"@Override public void close(){
  storeTailer.index=RollingChronicleQueue.index(storeTailer.cycle,toSequenceNumber(storeTailer.index) + 1);
  dc.close();
}","@Override public void close(){
  dc.close();
}"
52188,"public void start(){
  dc.start();
  storeTailer.index=RollingChronicleQueue.index(storeTailer.cycle,toSequenceNumber(storeTailer.index) + 1);
}","public void start(){
  dc.start();
  if (isPresent())   storeTailer.index=RollingChronicleQueue.index(storeTailer.cycle,toSequenceNumber(storeTailer.index) + 1);
}"
52189,"@ForceInline private WireStore store(){
  if (cycle != queue.cycle()) {
    long nextCycle=queue.cycle();
    if (store != null) {
      while (!store.appendRollMeta(wire,nextCycle)) {
        Thread.yield();
      }
      queue.release(store);
    }
    this.cycle=nextCycle;
    this.store=queue.storeForCycle(cycle,queue.epoch());
    this.wire=queue.wireType().apply(store.mappedBytes());
    this.index=store.firstSequenceNumber();
  }
  return store;
}","@ForceInline private WireStore store(){
  if (cycle != queue.cycle()) {
    long nextCycle=queue.cycle();
    if (store != null) {
      while (!store.appendRollMeta(wire,nextCycle)) {
        Thread.yield();
      }
      queue.release(store);
    }
    this.cycle=nextCycle;
    this.store=queue.storeForCycle(cycle,queue.epoch());
    this.wire=queue.wireType().apply(store.mappedBytes());
    this.sequenceNumber=store.firstSequenceNumber();
  }
  return store;
}"
52190,"public StoreAppender(@NotNull SingleChronicleQueue queue){
  this.nextPrefetch=OS.pageSize();
  this.queue=queue;
  final long lastIndex=this.queue.lastIndex();
  this.cycle=(lastIndex == -1) ? queue.cycle() : toCycle(lastIndex);
  if (this.cycle < 0)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + cycle);
  this.store=queue.storeForCycle(this.cycle,queue.epoch());
  this.index=this.store.sequenceNumber();
  @NotNull final MappedBytes mappedBytes=store.mappedBytes();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + mappedBytes.mappedFile().file().getAbsolutePath());
  wire=this.queue.wireType().apply(mappedBytes);
  dc=new AppenderDocumentContext((InternalWire)wire,this);
}","public StoreAppender(@NotNull SingleChronicleQueue queue){
  this.nextPrefetch=OS.pageSize();
  this.queue=queue;
  final long lastIndex=this.queue.lastIndex();
  this.cycle=(lastIndex == -1) ? queue.cycle() : toCycle(lastIndex);
  if (this.cycle < 0)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + cycle);
  this.store=queue.storeForCycle(this.cycle,queue.epoch());
  this.sequenceNumber=this.store.sequenceNumber();
  @NotNull final MappedBytes mappedBytes=store.mappedBytes();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + mappedBytes.mappedFile().file().getAbsolutePath());
  wire=this.queue.wireType().apply(mappedBytes);
  dc=new AppenderDocumentContext((InternalWire)wire,this);
}"
52191,"private <T>long append(@NotNull WireWriter<T> wireWriter,@NotNull T writer){
  if (ASSERTIONS) {
    Thread appendingThread=this.appendingThread;
    if (appendingThread != null)     throw new IllegalStateException(""String_Node_Str"" + Thread.currentThread() + ""String_Node_Str""+ appendingThread);
    this.appendingThread=Thread.currentThread();
  }
  WireStore store=store();
  Bytes<?> bytes=wire.bytes();
  long position=-1;
  do {
    final long readPosition=bytes.readPosition();
    final int spbHeader=bytes.readInt(readPosition);
    if ((spbHeader & Wires.META_DATA) != 0) {
      if (Wires.isReady(spbHeader)) {
        if (bytes.readInt(readPosition + SPB_HEADER_SIZE) == ROLL_KEY) {
          store=store();
          bytes=wire.bytes();
          bytes.writePosition(store.writePosition());
          bytes.readPosition(store.writePosition());
        }
      }
 else {
        continue;
      }
    }
    position=wireWriter.writeOrAdvanceIfNotEmpty(wire,false,writer);
  }
 while (position <= 0);
  index++;
  store.writePosition(bytes.writePosition());
  store.storeIndexLocation(wire,position,index);
  long index=RollingChronicleQueue.index(store.cycle(),this.index);
  if (ASSERTIONS)   appendingThread=null;
  return index;
}","private <T>long append(@NotNull WireWriter<T> wireWriter,@NotNull T writer){
  if (ASSERTIONS) {
    Thread appendingThread=this.appendingThread;
    if (appendingThread != null)     throw new IllegalStateException(""String_Node_Str"" + Thread.currentThread() + ""String_Node_Str""+ appendingThread);
    this.appendingThread=Thread.currentThread();
  }
  WireStore store=store();
  Bytes<?> bytes=wire.bytes();
  long position=-1;
  do {
    final long readPosition=bytes.readPosition();
    final int spbHeader=bytes.readInt(readPosition);
    if ((spbHeader & Wires.META_DATA) != 0) {
      if (Wires.isReady(spbHeader)) {
        if (bytes.readInt(readPosition + SPB_HEADER_SIZE) == ROLL_KEY) {
          store=store();
          bytes=wire.bytes();
          bytes.writePosition(store.writePosition());
          bytes.readPosition(store.writePosition());
        }
      }
 else {
        continue;
      }
    }
    position=wireWriter.writeOrAdvanceIfNotEmpty(wire,false,writer);
  }
 while (position <= 0);
  sequenceNumber++;
  store.writePosition(bytes.writePosition());
  store.storeIndexLocation(wire,position,sequenceNumber);
  long index=RollingChronicleQueue.index(store.cycle(),this.sequenceNumber);
  if (ASSERTIONS)   appendingThread=null;
  return index;
}"
52192,"private long lastCycle(){
  @NotNull final String basePath=path.getAbsolutePath();
  @Nullable final File[] files=path.listFiles();
  if (files != null && files.length > 0) {
    long lastDate=Long.MIN_VALUE;
    long date;
    String name;
    for (int i=files.length - 1; i >= 0; i--) {
      try {
        name=files[i].getAbsolutePath();
        if (name.endsWith(SUFFIX)) {
          name=name.substring(basePath.length() + 1);
          name=name.substring(0,name.indexOf('.'));
          date=dateCache.parseCount(name);
          if (lastDate < date) {
            lastDate=date;
          }
        }
      }
 catch (      ParseException ignored) {
      }
    }
    return lastDate;
  }
  return -1;
}","private long lastCycle(){
  @NotNull final String basePath=path.getAbsolutePath();
  @Nullable final File[] files=path.listFiles();
  if (files != null && files.length > 0) {
    long lastDate=Long.MIN_VALUE;
    long date;
    String name;
    for (int i=files.length - 1; i >= 0; i--) {
      try {
        name=files[i].getAbsolutePath();
        if (name.endsWith(SUFFIX)) {
          name=name.substring(basePath.length() + 1);
          name=name.substring(0,name.indexOf('.'));
          date=dateCache.parseCount(name);
          if (lastDate < date) {
            lastDate=date;
          }
        }
      }
 catch (      ParseException ignored) {
      }
    }
    if (Long.MIN_VALUE == lastDate)     return -1;
    return lastDate;
  }
  return -1;
}"
52193,"/** 
 * @return if we uses a ring buffer to buffer the appends, the Excerpts arewritten to the Chronicle Queue using a background thread
 */
public boolean buffered(){
  return this.isBuffered;
}","/** 
 * @return if we uses a ring buffer to buffer the appends, the Excerpts are written to theChronicle Queue using a background thread
 */
public boolean buffered(){
  return this.isBuffered;
}"
52194,"public long writeDocument(@NotNull WriteMarshallable writer){
  final WireStore store=store();
  long position;
  do {
    position=WireInternal.writeDataOrAdvanceIfNotEmpty(wire,false,writer);
    if (position == 0)     continue;
    this.index++;
  }
 while (position <= 0);
  store.writePosition(wire.bytes().writePosition());
  store.storeIndexLocation(wire,position,index);
  return ChronicleQueue.index(store.cycle(),index);
}","public long writeDocument(@NotNull WriteMarshallable writer){
  final WireStore store=store();
  long position;
  do {
    final long readPosition=wire.bytes().readPosition();
    boolean isMetaData=(wire.bytes().readInt(readPosition) & Wires.META_DATA) != 0;
    position=WireInternal.writeDataOrAdvanceIfNotEmpty(wire,false,writer);
    if (position == 0)     continue;
    if (!isMetaData)     this.index++;
  }
 while (position < 0);
  this.index++;
  store.writePosition(wire.bytes().writePosition());
  store.storeIndexLocation(wire,position,index);
  return ChronicleQueue.index(store.cycle(),index);
}"
52195,"/** 
 * @return creates a new instance of mapped bytes, because, for example the tailer and appendercan be at different locations.
 */
@NotNull @Override public MappedBytes mappedBytes(){
  return new MappedBytes(mappedFile);
}","/** 
 * @return creates a new instance of mapped bytes, because, for example the tailer and appendercan be at different locations.
 */
@NotNull @Override public MappedBytes mappedBytes(){
  final MappedBytes mappedBytes=new MappedBytes(mappedFile);
  mappedBytes.writePosition(writePosition());
  return mappedBytes;
}"
52196,"@Test(timeout=5000) public void testUnbuffered() throws IOException, InterruptedException {
}","@Test(timeout=2000) public void testUnbuffered() throws IOException, InterruptedException {
}"
52197,"@Test public void testAppendAndReadWithRolling() throws IOException {
  final ChronicleQueue queue=new SingleChronicleQueueBuilder(getTmpDir()).wireType(this.wireType).rollCycle(RollCycles.SECONDS).epoch(1452773025277L).build();
  final ExcerptAppender appender=queue.createAppender();
  for (int i=0; i < 5; i++) {
    final int n=i;
    Jvm.pause(500);
    appender.writeDocument(w -> w.write(TestKey.test).int32(n));
  }
  System.out.println(""String_Node_Str"");
  final ExcerptTailer tailer=queue.createTailer().toStart();
  for (int i=0; i < 5; i++) {
    final int n=i;
    final boolean condition=tailer.readDocument(r -> assertEquals(n,r.read(TestKey.test).int32()));
    assertTrue(condition);
  }
}","@Test public void testAppendAndReadWithRolling() throws IOException, InterruptedException {
  final ChronicleQueue queue=new SingleChronicleQueueBuilder(getTmpDir()).wireType(this.wireType).rollCycle(RollCycles.SECONDS).epoch(1452773025277L).build();
  final ExcerptAppender appender=queue.createAppender();
  for (int i=0; i < 5; i++) {
    final int n=i;
    Jvm.pause(500);
    appender.writeDocument(w -> w.write(TestKey.test).int32(n));
  }
  final ExcerptTailer tailer=queue.createTailer().toStart();
  for (int i=0; i < 5; i++) {
    final int n=i;
    final boolean condition=tailer.readDocument(r -> assertEquals(n,r.read(TestKey.test).int32()));
    assertTrue(condition);
  }
}"
52198,"@Test public void testReadAtIndex4MB() throws Exception {
  final File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  file.deleteOnExit();
  try {
    final ChronicleQueue chronicle=new SingleChronicleQueueBuilder(getTmpDir()).wireType(this.wireType).build();
    final ExcerptAppender appender=chronicle.createAppender();
    long lastIndex=-1;
    System.out.print(""String_Node_Str"");
    for (long i=0; i < TIMES; i++) {
      final long j=i;
      lastIndex=appender.writeDocument(wire -> wire.write(() -> ""String_Node_Str"").text(""String_Node_Str"" + j));
      if (i % (TIMES / 20) == 0) {
        System.out.println(""String_Node_Str"" + (i * 100 / TIMES) + ""String_Node_Str"");
      }
    }
    final long cycle=toCycle(lastIndex);
    final ExcerptTailer tailer=chronicle.createTailer();
    StringBuilder sb=new StringBuilder();
    for (long i=0; i < (4L << 20L); i++) {
      tailer.moveToIndex(index(cycle,i));
      tailer.readDocument(wire -> wire.read(() -> ""String_Node_Str"").text(sb));
      Assert.assertEquals(""String_Node_Str"" + i,sb.toString());
      if (i % (TIMES / 20) == 0) {
        System.out.println(""String_Node_Str"" + (i * 100 / TIMES) + ""String_Node_Str"");
      }
    }
  }
  finally {
    file.delete();
  }
}","@Ignore(""String_Node_Str"") @Test public void testReadAtIndex4MB() throws Exception {
  final File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  file.deleteOnExit();
  try {
    final ChronicleQueue chronicle=new SingleChronicleQueueBuilder(getTmpDir()).wireType(this.wireType).build();
    final ExcerptAppender appender=chronicle.createAppender();
    long lastIndex=-1;
    System.out.print(""String_Node_Str"");
    for (long i=0; i < TIMES; i++) {
      final long j=i;
      lastIndex=appender.writeDocument(wire -> wire.write(() -> ""String_Node_Str"").text(""String_Node_Str"" + j));
      if (i % (TIMES / 20) == 0) {
        System.out.println(""String_Node_Str"" + (i * 100 / TIMES) + ""String_Node_Str"");
      }
    }
    final long cycle=toCycle(lastIndex);
    final ExcerptTailer tailer=chronicle.createTailer();
    StringBuilder sb=new StringBuilder();
    for (long i=0; i < (4L << 20L); i++) {
      tailer.moveToIndex(index(cycle,i));
      tailer.readDocument(wire -> wire.read(() -> ""String_Node_Str"").text(sb));
      Assert.assertEquals(""String_Node_Str"" + i,sb.toString());
      if (i % (TIMES / 20) == 0) {
        System.out.println(""String_Node_Str"" + (i * 100 / TIMES) + ""String_Node_Str"");
      }
    }
  }
  finally {
    file.delete();
  }
}"
52199,"static long cycle(long index){
  int result=(int)(index >> 40L);
  if (result > (1 << 24))   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  return result;
}","static long cycle(long index){
  int result=(int)(index >> 40L);
  if (result > (1 << 24))   throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  if (result < 0)   throw new IllegalStateException(""String_Node_Str"" + result + ""String_Node_Str""+ ""String_Node_Str"");
  return result;
}"
52200,"/** 
 * @return
 */
protected abstract long cycle();","/** 
 * @return the current cycle
 */
protected abstract long cycle();"
52201,"/** 
 * @param cycle
 * @param epoch   an epoch offset as the number of number of milliseconds since January1, 1970,  00:00:00 GMT
 * @return
 * @throws IOException
 */
protected abstract WireStore storeForCycle(long cycle,final long epoch) throws IOException ;","/** 
 * @param cycle
 * @param epoch an epoch offset as the number of number of milliseconds since January 1, 1970,00:00:00 GMT
 * @return
 * @throws IOException
 */
protected abstract WireStore storeForCycle(long cycle,final long epoch) throws IOException ;"
52202,"@NotNull @Override public ExcerptTailer toStart() throws IOException {
  long firstCycle=queue.firstCycle();
  if (firstCycle > 0) {
    cycle(firstCycle);
    this.toStart=true;
  }
 else {
    this.toStart=false;
  }
  this.index=-1;
  final Bytes<?> readContext=wire.bytes();
  readContext.readPosition(0);
  readContext.readLimit(readContext.capacity());
  return this;
}","@NotNull @Override public ExcerptTailer toStart() throws IOException {
  final long index=queue.firstIndex();
  if (index == -1)   return this;
  LOG.info(""String_Node_Str"" + ChronicleQueue.subIndex(index) + ""String_Node_Str""+ ChronicleQueue.cycle(index));
  if (!moveToIndex(index))   throw new IllegalStateException(""String_Node_Str"");
  return this;
}"
52203,"@Override public boolean index(long fullIndex) throws IOException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(SingleChronicleQueueStore.IndexOffset.toBinaryString(fullIndex));
    LOG.debug(SingleChronicleQueueStore.IndexOffset.toScale());
  }
  final long nextCycle=ChronicleQueue.cycle(fullIndex);
  if (nextCycle != queue.lastCycle())   cycle(nextCycle);
  final long position=this.store.moveToIndex(wire,subIndex(fullIndex));
  final Bytes<?> readContext=wire.bytes();
  readContext.readPosition(position);
  readContext.readLimit(readContext.capacity());
  if (position != -1) {
    this.index=fullIndex - 1;
    return true;
  }
  return false;
}","@Override public long index(){
  if (this.index == -1) {
    throw new IllegalStateException();
  }
  return ChronicleQueue.index(cycle(),index);
}"
52204,"private StoreTailer cycle(long cycle) throws IOException {
  if (this.cycle != cycle) {
    if (null != this.store) {
      this.queue.release(this.store);
    }
    this.cycle=cycle;
    this.index=-1;
    this.store=this.queue.storeForCycle(cycle,this.epoch);
    wire=queue.wireType().apply(store.mappedBytes());
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + ((MappedBytes)wire.bytes()).mappedFile().file().getAbsolutePath());
  }
  return this;
}","private StoreTailer cycle(long cycle) throws IOException {
  if (this.cycle != cycle) {
    if (null != this.store) {
      this.queue.release(this.store);
    }
    this.cycle=cycle;
    this.index=-1;
    this.store=this.queue.storeForCycle(cycle,queue.epoch());
    wire=queue.wireType().apply(store.mappedBytes());
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + ((MappedBytes)wire.bytes()).mappedFile().file().getAbsolutePath());
  }
  return this;
}"
52205,"@Override public boolean readDocument(@NotNull ReadMarshallable reader) throws IOException {
  if (this.store == null) {
    long lastCycle=this.toStart ? queue.firstCycle() : queue.lastCycle();
    if (lastCycle == -1) {
      return false;
    }
    cycle(lastCycle);
  }
  long position=store.read(wire,reader);
  if (position > 0) {
    this.index++;
    return true;
  }
 else   if (position < 0) {
    cycle(Math.abs(position));
    return readDocument(reader);
  }
  return false;
}","@Override public boolean readDocument(@NotNull ReadMarshallable reader) throws IOException {
  if (this.store == null) {
    final long index=queue.firstIndex();
    if (index == -1) {
      return false;
    }
    moveToIndex(index);
  }
  long position=store.read(wire,reader);
  if (position > 0) {
    this.index++;
    return true;
  }
 else   if (position < 0) {
    cycle(Math.abs(position));
    return readDocument(reader);
  }
  return false;
}"
52206,"@NotNull @Override public ExcerptTailer toEnd() throws IOException {
  long cycle=queue.lastCycle();
  if (cycle > 0) {
    cycle(cycle);
  }
  this.toStart=false;
  return this;
}","@NotNull @Override public ExcerptTailer toEnd() throws IOException {
  if (!moveToIndex(queue.lastIndex()))   throw new IllegalStateException(""String_Node_Str"");
  return this;
}"
52207,"public StoreAppender(@NotNull AbstractChronicleQueue queue) throws IOException {
  super(queue);
  this.cycle=super.queue.lastCycle();
  if (this.cycle == -1)   this.cycle=queue.cycle();
  if (this.cycle < 0)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + cycle);
  this.store=queue.storeForCycle(this.cycle,this.epoch);
  this.index=this.store.lastIndex();
  final MappedBytes mappedBytes=store.mappedBytes();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + mappedBytes.mappedFile().file().getAbsolutePath());
  wire=this.queue().wireType().apply(mappedBytes);
}","public StoreAppender(@NotNull AbstractChronicleQueue queue) throws IOException {
  super(queue);
  final long lastIndex=super.queue.lastIndex();
  this.cycle=(lastIndex == -1) ? queue.cycle() : ChronicleQueue.cycle(lastIndex);
  if (this.cycle < 0)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + cycle);
  this.store=queue.storeForCycle(this.cycle,this.epoch);
  this.index=this.store.lastSubIndex();
  final MappedBytes mappedBytes=store.mappedBytes();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + mappedBytes.mappedFile().file().getAbsolutePath());
  wire=this.queue().wireType().apply(mappedBytes);
}"
52208,"@Override public boolean readBytes(@NotNull ReadBytesMarshallable marshallable) throws IOException {
  if (this.store == null) {
    long lastCycle=this.toStart ? queue.firstCycle() : queue.lastCycle();
    if (lastCycle == -1) {
      return false;
    }
    cycle(lastCycle);
  }
  long position=store.read(wire,marshallable);
  if (position > 0) {
    this.index++;
    return true;
  }
 else   if (position < 0) {
    cycle(Math.abs(position));
    return readBytes(marshallable);
  }
  return false;
}","@Override public boolean readBytes(@NotNull ReadBytesMarshallable marshallable) throws IOException {
  if (this.store == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  long position=store.read(wire,marshallable);
  if (position > 0) {
    this.index++;
    return true;
  }
 else   if (position < 0) {
    cycle(Math.abs(position));
    return readBytes(marshallable);
  }
  return false;
}"
52209,"public synchronized void release(WireStore store){
  store.release();
  if (store.refCount() <= 0) {
    stores.remove(new RollDetails(store.cycle(),store.epoc()));
  }
}","public synchronized void release(WireStore store){
  store.release();
  if (store.refCount() <= 0) {
    stores.remove(new RollDetails(store.cycle(),store.epoch()));
  }
}"
52210,"@Override public boolean moveToIndex(long index) throws IOException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(SingleChronicleQueueStore.IndexOffset.toBinaryString(index));
    LOG.debug(SingleChronicleQueueStore.IndexOffset.toScale());
  }
  final long expectedCycle=ChronicleQueue.cycle(index);
  if (expectedCycle != cycle)   cycle(expectedCycle);
  cycle=expectedCycle;
  final long position=this.store.moveToIndex(wire,subIndex(index));
  if (position == -1)   return false;
  final Bytes<?> readContext=wire.bytes();
  readContext.readPosition(position);
  readContext.readLimit(readContext.capacity());
  this.index=index - 1;
  return true;
}","@Override public boolean moveToIndex(long index) throws IOException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(SingleChronicleQueueStore.IndexOffset.toBinaryString(index));
    LOG.debug(SingleChronicleQueueStore.IndexOffset.toScale());
  }
  final long expectedCycle=ChronicleQueue.cycle(index);
  if (expectedCycle != cycle)   cycle(expectedCycle);
  cycle=expectedCycle;
  final long subIndex=subIndex(index);
  final long position=this.store.moveToIndex(wire,index);
  if (position == -1)   return false;
  final Bytes<?> readContext=wire.bytes();
  readContext.readPosition(position);
  readContext.readLimit(readContext.capacity());
  this.index=ChronicleQueue.index(cycle,subIndex - 1);
  return true;
}"
52211,"@NotNull @Override public ExcerptTailer toStart() throws IOException {
  final long index=queue.firstIndex();
  if (index == -1)   return this;
  LOG.info(""String_Node_Str"" + ChronicleQueue.subIndex(index) + ""String_Node_Str""+ ChronicleQueue.cycle(index));
  if (!moveToIndex(index))   throw new IllegalStateException(""String_Node_Str"");
  return this;
}","@NotNull @Override public ExcerptTailer toStart() throws IOException {
  final long index=queue.firstIndex();
  if (index == -1)   return this;
  LOG.info(""String_Node_Str"" + ChronicleQueue.subIndex(index) + ""String_Node_Str""+ ChronicleQueue.cycle(index));
  if (!moveToIndex(index))   throw new IllegalStateException(""String_Node_Str"" + cycle);
  return this;
}"
52212,"@ForceInline private WireStore store() throws IOException {
  if (this.cycle != queue.cycle()) {
    long nextCycle=queue.cycle();
    if (this.store != null) {
      this.store.appendRollMeta(wire,nextCycle);
      this.queue.release(this.store);
    }
    this.cycle=nextCycle;
    this.store=queue.storeForCycle(this.cycle,epoch);
  }
  return this.store;
}","@ForceInline private WireStore store() throws IOException {
  if (this.cycle != queue.cycle()) {
    long nextCycle=queue.cycle();
    if (this.store != null) {
      this.store.appendRollMeta(wire,nextCycle);
      this.queue.release(this.store);
    }
    this.cycle=nextCycle;
    this.store=queue.storeForCycle(this.cycle,epoch);
    this.wire=this.queue().wireType().apply(store.mappedBytes());
  }
  return this.store;
}"
52213,"private StoreTailer cycle(long cycle) throws IOException {
  if (this.cycle != cycle) {
    if (null != this.store) {
      this.queue.release(this.store);
    }
    this.cycle=cycle;
    this.index=-1;
    this.store=this.queue.storeForCycle(cycle,queue.epoch());
    wire=queue.wireType().apply(store.mappedBytes());
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + ((MappedBytes)wire.bytes()).mappedFile().file().getAbsolutePath());
  }
  return this;
}","private StoreTailer cycle(long cycle) throws IOException {
  if (this.cycle != cycle) {
    if (null != this.store) {
      this.queue.release(this.store);
    }
    this.cycle=cycle;
    this.index=-1;
    this.store=this.queue.storeForCycle(cycle,queue.epoch());
    wire=queue.wireType().apply(store.mappedBytes());
    moveToIndex(ChronicleQueue.index(cycle,0));
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + ((MappedBytes)wire.bytes()).mappedFile().file().getAbsolutePath());
  }
  return this;
}"
52214,"@Override public boolean readDocument(@NotNull ReadMarshallable reader) throws IOException {
  if (this.store == null) {
    final long index=queue.firstIndex();
    if (index == -1) {
      return false;
    }
    moveToIndex(index);
  }
  long position=store.read(wire,reader);
  if (position > 0) {
    this.index++;
    return true;
  }
 else   if (position < 0) {
    cycle(Math.abs(position));
    return readDocument(reader);
  }
  return false;
}","@Override public boolean readDocument(@NotNull ReadMarshallable reader) throws IOException {
  if (this.store == null) {
    final long index=queue.firstIndex();
    if (index == -1) {
      return false;
    }
    moveToIndex(index);
  }
  long position=store.read(wire,reader);
  if (position > 0) {
    this.index++;
    return true;
  }
 else   if (position < 0) {
    cycle(Math.abs(position));
    wire.bytes().readPosition(0);
    wire.bytes().readLimit(store.writePosition());
    return readDocument(reader);
  }
  return false;
}"
52215,"/** 
 * Moves the position to the   {@code index}The indexes are stored in many excerpts, so the index2index tells chronicle where ( in other words the address of where ) the root first level targetIndex is stored. The indexing works like a tree, but only 2 levels deep, the root of the tree is at index2index ( this first level targetIndex is 1MB in size and there is only one of them, it only holds the addresses of the second level indexes, there will be many second level indexes ( created on demand ), each is about 1MB in size  (this second level targetIndex only stores the position of every 64th excerpt), so from every 64th excerpt a linear scan occurs. The indexes are only built when the indexer is run, this could be on a background thread. Each targetIndex is created into chronicle as an excerpt.
 * @param wire  the data structure we are navigating
 * @param index the index we wish to move to
 * @return the position of the {@code targetIndex}  or -1 if the index can not be found
 */
public long moveToIndex(@NotNull final Wire wire,final long index){
  final LongArrayValues array=this.longArray.get();
  final long indexToIndex0=indexToIndex(wire.bytes());
  final Bytes<?> bytes=wire.bytes();
  bytes.readLimit(indexContext.capacity()).readPosition(indexToIndex0);
  long startIndex=((index / 64L)) * 64L;
  try (@NotNull final DocumentContext documentContext0=wire.readingDocument()){
    if (!documentContext0.isPresent())     throw new IllegalStateException(""String_Node_Str"");
    if (documentContext0.isData())     throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + indexToIndex0 + ""String_Node_Str"");
    final LongArrayValues primaryIndex=array(wire,array);
    long primaryOffset=toAddress0(index);
    do {
      long secondaryAddress=primaryIndex.getValueAt(primaryOffset);
      if (secondaryAddress == 0) {
        startIndex-=(1 << 23L);
        primaryOffset--;
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
      final Wire wire1=wireType.apply(indexContext.readPosition(secondaryAddress));
      final long limit=wire1.bytes().readLimit();
      try (@NotNull final DocumentContext documentContext1=wire1.readingDocument()){
        if (!documentContext1.isPresent())         throw new IllegalStateException(""String_Node_Str"");
        if (documentContext1.isData())         continue;
        final LongArrayValues array1=array(wire1,array);
        long secondaryOffset=toAddress1(index);
        do {
          long fromAddress=array1.getValueAt(secondaryOffset);
          if (fromAddress == 0) {
            secondaryOffset--;
            startIndex-=64;
            System.out.println(""String_Node_Str"");
            continue;
          }
          if (index == startIndex) {
            return fromAddress;
          }
 else {
            wire1.bytes().readLimit(limit);
            return linearScan(wire1,index,startIndex,fromAddress);
          }
        }
 while (secondaryOffset >= 0);
      }
       break;
    }
 while (primaryOffset >= 0);
  }
   return -1;
}","/** 
 * Moves the position to the   {@code index}The indexes are stored in many excerpts, so the index2index tells chronicle where ( in other words the address of where ) the root first level targetIndex is stored. The indexing works like a tree, but only 2 levels deep, the root of the tree is at index2index ( this first level targetIndex is 1MB in size and there is only one of them, it only holds the addresses of the second level indexes, there will be many second level indexes ( created on demand ), each is about 1MB in size  (this second level targetIndex only stores the position of every 64th excerpt), so from every 64th excerpt a linear scan occurs. The indexes are only built when the indexer is run, this could be on a background thread. Each targetIndex is created into chronicle as an excerpt.
 * @param wire  the data structure we are navigating
 * @param index the index we wish to move to
 * @return the position of the {@code targetIndex}  or -1 if the index can not be found
 */
public long moveToIndex(@NotNull final Wire wire,final long index){
  final LongArrayValues array=this.longArray.get();
  final long indexToIndex0=indexToIndex(wire.bytes());
  System.out.println(""String_Node_Str"" + indexToIndex0);
  final Bytes<?> bytes=wire.bytes();
  bytes.readLimit(indexContext.capacity()).readPosition(indexToIndex0);
  long startIndex=((index / 64L)) * 64L;
  try (@NotNull final DocumentContext documentContext0=wire.readingDocument()){
    if (!documentContext0.isPresent())     throw new IllegalStateException(""String_Node_Str"");
    if (documentContext0.isData())     throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + indexToIndex0 + ""String_Node_Str"");
    final LongArrayValues primaryIndex=array(wire,array);
    long primaryOffset=toAddress0(index);
    do {
      long secondaryAddress=primaryIndex.getValueAt(primaryOffset);
      if (secondaryAddress == 0) {
        startIndex-=(1 << 23L);
        primaryOffset--;
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
      wire.bytes().readPosition(secondaryAddress);
      try (@NotNull final DocumentContext documentContext1=wire.readingDocument()){
        if (!documentContext1.isPresent())         throw new IllegalStateException(""String_Node_Str"");
        if (documentContext1.isData())         continue;
        final LongArrayValues array1=array(wire,array);
        long secondaryOffset=toAddress1(index);
        do {
          long fromAddress=array1.getValueAt(secondaryOffset);
          if (fromAddress == 0) {
            secondaryOffset--;
            startIndex-=64;
            System.out.println(""String_Node_Str"");
            continue;
          }
          if (index == startIndex) {
            return fromAddress;
          }
 else {
            wire.bytes().readLimit(bounds.getWritePosition());
            return linearScan(wire,index,startIndex,fromAddress);
          }
        }
 while (secondaryOffset >= 0);
      }
       break;
    }
 while (primaryOffset >= 0);
  }
   return -1;
}"
52216,"/** 
 * @return creates a new instance of mapped bytes, because, for example the tailer and appendercan be at diffent locations.
 */
@Override public MappedBytes mappedBytes(){
  return new MappedBytes(mappedFile);
}","/** 
 * @return creates a new instance of mapped bytes, because, for example the tailer and appendercan be at diffent locations.
 */
@Override public MappedBytes mappedBytes(){
  final MappedBytes mappedBytes=new MappedBytes(mappedFile);
  mappedBytes.writePosition(bounds.getWritePosition());
  mappedBytes.readPosition(bounds.getReadPosition());
  return mappedBytes;
}"
52217,"private long writeWireMarshallable(@NotNull Wire wire,long position,int size,@NotNull final WriteMarshallable marshallable) throws IOException {
  final long positionDataWritten=Wires.writeData(wire,marshallable);
  final Bytes<?> context=wire.bytes();
  bounds.setWritePositionIfGreater(context.writePosition());
  final long index=indexing.incrementLastIndex();
  indexing.storeIndexLocation(context,positionDataWritten,index);
  return index;
}","private long writeWireMarshallable(@NotNull Wire wire,long position,int size,@NotNull final WriteMarshallable marshallable) throws IOException {
  final long positionDataWritten=Wires.writeData(wire,marshallable);
  bounds.setWritePositionIfGreater(wire.bytes().writePosition());
  final long index=indexing.incrementLastIndex();
  indexing.storeIndexLocation(wire.bytes(),positionDataWritten,index);
  System.out.println(""String_Node_Str"" + positionDataWritten + ""String_Node_Str""+ cycle()+ ""String_Node_Str""+ index);
  return index;
}"
52218,"private LongArrayValues array(WireIn w,LongArrayValues using){
  w.read(() -> ""String_Node_Str"").int64array(using,this,(o1,o2) -> {
  }
);
  return using;
}","private LongArrayValues array(WireIn w,LongArrayValues using){
  final StringBuilder sb=Wires.acquireStringBuilder();
  final ValueIn valueIn=w.readEventName(sb);
  if (!""String_Node_Str"".contentEquals(sb))   throw new IllegalStateException(""String_Node_Str"");
  valueIn.int64array(using,this,(o1,o2) -> {
  }
);
  return using;
}"
52219,"/** 
 * atomically gets or creates the address of the first index the index is create and another except into the queue, however this except is treated as meta data and does not increment the last index, in otherword it is not possible to access this except by calling index(), it effectively invisible to the end-user
 * @param writeContext used to write and index if it does not exist
 * @return the position of the index
 */
long indexToIndex(@Nullable final Bytes writeContext){
  for (; ; ) {
    long index2Index=this.index2Index.getVolatileValue();
    if (index2Index == NOT_READY)     continue;
    if (index2Index != NOT_INITIALIZED)     return index2Index;
    if (!this.index2Index.compareAndSwapValue(NOT_INITIALIZED,NOT_READY))     continue;
    if (writeContext == null)     return -1;
    final long index=newIndex(writeContext);
    this.index2Index.setOrderedValue(index);
    return index;
  }
}","/** 
 * atomically gets or creates the address of the first index the index is create and another except into the queue, however this except is treated as meta data and does not increment the last index, in otherword it is not possible to access this except by calling index(), it effectively invisible to the end-user
 * @param writeContext used to write and index if it does not exist
 * @return the position of the index
 */
long indexToIndex(@Nullable final Bytes writeContext){
  for (; ; ) {
    long index2Index=this.index2Index.getVolatileValue();
    if (index2Index == NOT_READY)     continue;
    if (index2Index != NOT_INITIALIZED)     return index2Index;
    if (!this.index2Index.compareAndSwapValue(NOT_INITIALIZED,NOT_READY))     continue;
    if (writeContext == null)     return -1;
    final long index=newIndex(writeContext);
    System.out.println(""String_Node_Str"" + index);
    this.index2Index.setOrderedValue(index);
    return index;
  }
}"
52220,"public long nextCycleMetaPosition(){
  return this.nextCycleMetaPosition.getVolatileValue();
}","public Roll nextCycleMetaPosition(long position){
  this.nextCycleMetaPosition.setOrderedValue(position);
  return this;
}"
52221,"Indexing(@NotNull WireType wireType,final MappedBytes mappedBytes){
  this.index2Index=wireType.newLongReference().get();
  this.firstIndex=wireType.newLongReference().get();
  this.lastIndex=wireType.newLongReference().get();
  final Bytes b=Bytes.elasticByteBuffer();
  templateIndex=wireType.apply(b);
  templateIndex.writeDocument(true,w -> w.write(() -> ""String_Node_Str"").int64array(NUMBER_OF_ENTRIES_IN_EACH_INDEX));
  this.wireType=wireType;
  this.longArray=withInitial(wireType.newLongArrayReference());
  this.indexContext=mappedBytes;
}","Indexing(@NotNull WireType wireType,final MappedBytes mappedBytes){
  this.index2Index=wireType.newLongReference().get();
  this.firstIndex=wireType.newLongReference().get();
  this.lastIndex=wireType.newLongReference().get();
  if (wireType == WireType.TEXT)   templateIndex=TEXT_TEMPLATE;
 else   if (wireType == WireType.BINARY)   templateIndex=BINARY_TEMPLATE;
 else {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  this.wireType=wireType;
  this.longArray=withInitial(wireType.newLongArrayReference());
  this.indexContext=mappedBytes;
}"
52222,"@Ignore(""String_Node_Str"") @Test public void testAppendAndReadWithRolling2() throws IOException {
  final File dir=getTmpDir();
  final ChronicleQueue queue=new SingleChronicleQueueBuilder(dir).wireType(this.wireType).rollCycle(RollCycles.SECONDS).epoch(System.currentTimeMillis()).build();
  for (int i=0; i < 10; i++) {
    final int n=i;
    final ExcerptAppender appender=queue.createAppender();
    appender.writeDocument(w -> w.write(TestKey.test).int32(n));
    Jvm.pause(500);
  }
  final ExcerptTailer tailer=queue.createTailer().toStart();
  for (int i=0; i < 10; i++) {
    final int n=i;
    final boolean condition=tailer.readDocument(new ReadMarshallable(){
      @Override public void readMarshallable(      @NotNull WireIn r) throws IORuntimeException {
        assertEquals(n,r.read(TestKey.test).int32());
      }
    }
);
    assertTrue(condition);
  }
}","@Ignore(""String_Node_Str"") @Test public void testAppendAndReadWithRolling2() throws IOException {
  final File dir=getTmpDir();
  final ChronicleQueue queue=new SingleChronicleQueueBuilder(dir).wireType(this.wireType).rollCycle(RollCycles.SECONDS).epoch(1452701442361L).build();
  final ExcerptAppender appender=queue.createAppender();
  for (int i=0; i < 10; i++) {
    final int n=i;
    appender.writeDocument(w -> w.write(TestKey.test).int32(n));
    Jvm.pause(500);
  }
  final ExcerptTailer tailer=queue.createTailer().toStart();
  for (int i=0; i < 10; i++) {
    final int n=i;
    final boolean condition=tailer.readDocument(new ReadMarshallable(){
      @Override public void readMarshallable(      @NotNull WireIn r) throws IORuntimeException {
        assertEquals(n,r.read(TestKey.test).int32());
        System.out.println(""String_Node_Str"" + n);
      }
    }
);
    assertTrue(condition);
  }
}"
52223,"@Test public void testReadAtIndex() throws Exception {
  final File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  file.deleteOnExit();
  try {
    final ChronicleQueue chronicle=new SingleChronicleQueueBuilder(getTmpDir()).wireType(this.wireType).build();
    final ExcerptAppender appender=chronicle.createAppender();
    long lastIndex=-1;
    for (int i=0; i < 100; i++) {
      final int j=i;
      final long index=appender.writeDocument(wire -> wire.write(() -> ""String_Node_Str"").text(""String_Node_Str"" + j));
      lastIndex=index;
    }
    final long cycle=cycle(lastIndex);
    final ExcerptTailer tailer=chronicle.createTailer();
    StringBuilder sb=new StringBuilder();
    for (    int i : new int[]{65}) {
      tailer.moveToIndex(index(cycle,i));
      tailer.readDocument(wire -> wire.read(() -> ""String_Node_Str"").text(sb));
      Assert.assertEquals(""String_Node_Str"" + i,sb.toString());
    }
  }
  finally {
    file.delete();
  }
}","@Test public void testReadAtIndex() throws Exception {
  final File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  file.deleteOnExit();
  try {
    final ChronicleQueue chronicle=new SingleChronicleQueueBuilder(getTmpDir()).wireType(this.wireType).build();
    final ExcerptAppender appender=chronicle.createAppender();
    long lastIndex=-1;
    for (int i=0; i < 100; i++) {
      final int j=i;
      final long index=appender.writeDocument(wire -> wire.write(() -> ""String_Node_Str"").text(""String_Node_Str"" + j));
      lastIndex=index;
    }
    final long cycle=cycle(lastIndex);
    final ExcerptTailer tailer=chronicle.createTailer();
    StringBuilder sb=new StringBuilder();
    for (    int i : new int[]{0,64,65,66}) {
      tailer.moveToIndex(index(cycle,i));
      tailer.readDocument(wire -> wire.read(() -> ""String_Node_Str"").text(sb));
      Assert.assertEquals(""String_Node_Str"" + i,sb.toString());
    }
  }
  finally {
    file.delete();
  }
}"
52224,"@Override public void readMarshallable(@NotNull WireIn r) throws IORuntimeException {
  assertEquals(n,r.read(TestKey.test).int32());
}","@Override public void readMarshallable(@NotNull WireIn r) throws IORuntimeException {
  assertEquals(n,r.read(TestKey.test).int32());
  System.out.println(""String_Node_Str"" + n);
}"
52225,"protected WireStore newStore(final long cycle){
  try {
    final String cycleFormat=this.dateCache.formatFor(cycle);
    final File cycleFile=new File(this.builder.path(),cycleFormat + ""String_Node_Str"");
    if (!cycleFile.getParentFile().exists()) {
      cycleFile.mkdirs();
    }
    return WiredFile.<WireStore>build(cycleFile,file -> MappedFile.mappedFile(file,builder.blockSize(),builder.blockSize()),builder.wireType(),() -> new SingleChronicleQueueStore(builder.rollCycle()),ws -> ws.delegate().install(ws.mappedFile(),ws.headerLength(),ws.headerCreated(),cycle,builder,ws.wireSupplier(),ws.mappedFile())).delegate();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","protected WireStore newStore(final long cycle){
  try {
    final String cycleFormat=this.dateCache.formatFor(cycle);
    final File cycleFile=new File(this.builder.path(),cycleFormat + ""String_Node_Str"");
    File parentFile=cycleFile.getParentFile();
    if (parentFile != null & !parentFile.exists()) {
      parentFile.mkdirs();
    }
    return WiredFile.<WireStore>build(cycleFile,file -> MappedFile.mappedFile(file,builder.blockSize(),builder.blockSize()),builder.wireType(),() -> new SingleChronicleQueueStore(builder.rollCycle()),ws -> ws.delegate().install(ws.mappedFile(),ws.headerLength(),ws.headerCreated(),cycle,builder,ws.wireSupplier(),ws.mappedFile())).delegate();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
52226,"private boolean compareAndSetWriteLocation(long expectedValue,long newValue){
  return bytesStore.compareAndSwapLong(writeLocationOffset,expectedValue,newValue);
}","private boolean compareAndSetWriteLocation(long expectedValue,long newValue){
  boolean success=writeLocationOffsetAtomic.compareAndSet(expectedValue,newValue);
  return success;
}"
52227,"/** 
 * sets the point at which you should not write any additional bits
 */
private void setWriteUpTo(long value){
  bytesStore.writeOrderedLong(writeUpToOffset,value);
}","/** 
 * sets the point at which you should not write any additional bits
 */
private void setWriteUpTo(long value){
  writeUpToOffsetAtomic.set(value);
}"
52228,"private long getWriteLocation(){
  return bytesStore.readVolatileLong(writeLocationOffset);
}","private long getWriteLocation(){
  return writeLocationOffsetAtomic.get();
}"
52229,"private long getReadLocation(){
  return bytesStore.readVolatileLong(readLocationOffset);
}","private long getReadLocation(){
  return readLocationOffsetAtomic.get();
}"
52230,"private long read(@NotNull ReadBytesMarshallable readBytesMarshallable,long offset,long len){
  offset%=capacity();
  long endOffSet=nextOffset(offset,len);
  if (endOffSet >= offset) {
    bytes.write(byteStore,offset,len);
    readBytesMarshallable.readMarshallable(bytes);
    return endOffSet;
  }
  final long firstChunkLen=capacity() - offset;
  bytes.write(byteStore,offset,firstChunkLen);
  bytes.write(byteStore,0,len - firstChunkLen);
  readBytesMarshallable.readMarshallable(bytes);
  return endOffSet;
}","private long read(@NotNull ReadBytesMarshallable readBytesMarshallable,long offset,long len){
  offset%=capacity();
  long endOffSet=nextOffset(offset,len);
  if (endOffSet >= offset) {
    bytes.write(byteStore,offset,len);
    readBytesMarshallable.readMarshallable(bytes);
    return endOffSet;
  }
  final long firstChunkLen=capacity() - offset;
  final long l=bytes.writeLimit();
  bytes.writeLimit(bytes.writePosition() + firstChunkLen);
  bytes.write(byteStore,offset,firstChunkLen);
  bytes.writeLimit(l);
  bytes.write(byteStore,0,len - firstChunkLen);
  readBytesMarshallable.readMarshallable(bytes);
  return endOffSet;
}"
52231,"/** 
 * @return the point at which you should not write any additional bits
 */
private long getWriteUpTo(){
  return bytesStore.readVolatileLong(writeUpToOffset);
}","/** 
 * @return the point at which you should not write any additional bits
 */
private long getWriteUpTo(){
  return writeUpToOffsetAtomic.get();
}"
52232,"private void setReadLocation(long value){
  bytesStore.writeOrderedLong(readLocationOffset,value);
}","private void setReadLocation(long value){
  readLocationOffsetAtomic.set(value);
}"
52233,"public void clear(long size){
  setWriteUpTo(size);
  setReadLocation(0);
  bytesStore.writeOrderedLong(writeLocationOffset,0);
}","public synchronized void clear(long size){
  writeLocationOffsetAtomic.set(0);
  readLocationOffsetAtomic.set(0);
  writeUpToOffsetAtomic.set(size);
}"
52234,"public BytesRingBuffer(@NotNull final BytesStore byteStore){
  capacity=byteStore.writeLimit();
  if (byteStore.writeRemaining() <= 24) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.header=new Header(byteStore,capacity - 24);
  this.bytes=new RingBuffer(byteStore,0,capacity - 24);
  this.header.setWriteUpTo(capacity);
}","public BytesRingBuffer(@NotNull final BytesStore byteStore){
  capacity=byteStore.writeLimit() - 24;
  if (byteStore.writeRemaining() <= 24) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.header=new Header(byteStore,byteStore.writeLimit());
  this.bytes=new RingBuffer(byteStore,0,capacity);
  this.header.setWriteUpTo(capacity);
  byteStore.writeLong(0,0);
}"
52235,"private Consumer(){
  this.input=new byte[]{};
  this.inputBuffer=wrap(ByteBuffer.wrap(input));
}","private Consumer(){
  this.input=new byte[]{};
  this.inputBuffer=wrap(ByteBuffer.wrap(input)).bytesForRead();
}"
52236,"@NotNull @Override public Bytes provide(final long maxSize){
  if (maxSize < inputBuffer.capacity())   return inputBuffer.clear();
  if (maxSize > Integer.MAX_VALUE) {
    throw new IllegalStateException(ERR_MSG);
  }
  this.input=new byte[(int)maxSize];
  this.inputBuffer=wrap(ByteBuffer.wrap(input));
  this.output=new byte[(int)maxSize];
  this.outputBuffer=wrap(ByteBuffer.wrap(output));
  return inputBuffer;
}","@NotNull @Override public Bytes provide(final long maxSize){
  if (maxSize < inputBuffer.capacity())   return inputBuffer.clear();
  if (maxSize > Integer.MAX_VALUE) {
    throw new IllegalStateException(ERR_MSG);
  }
  this.input=new byte[(int)maxSize];
  this.inputBuffer=wrap(ByteBuffer.wrap(input)).bytesForRead();
  this.output=new byte[(int)maxSize];
  this.outputBuffer=wrap(ByteBuffer.wrap(output)).bytesForWrite();
  return inputBuffer;
}"
52237,"@Test public void testFormat(){
  VanillaDateCache dc=new VanillaDateCache(""String_Node_Str"",86400000);
  String str=dc.formatFor(16067);
  assertEquals(""String_Node_Str"",str);
  String str1=dc.formatFor(1);
  assertEquals(""String_Node_Str"",str1);
}","@Test public void testFormat(){
  VanillaDateCache dc=new VanillaDateCache(""String_Node_Str"",86400000,GMT);
  String str=dc.formatFor(16067);
  assertEquals(""String_Node_Str"",str);
  String str1=dc.formatFor(1);
  assertEquals(""String_Node_Str"",str1);
}"
52238,"@Test public void testFormatMillis(){
  String format=""String_Node_Str"";
  SimpleDateFormat sdf=new SimpleDateFormat(format);
  sdf.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  VanillaDateCache dc=new VanillaDateCache(format,1000);
  int now=(int)(System.currentTimeMillis() / 1000);
  for (int i=0; i < 10000; i++) {
    int now2=now + i;
    String str2=sdf.format(new Date(now2 * 1000L));
    String str=dc.formatFor(now2);
    assertEquals(""String_Node_Str"" + i,str2,str);
  }
}","@Test public void testFormatMillis(){
  String format=""String_Node_Str"";
  SimpleDateFormat sdf=new SimpleDateFormat(format);
  sdf.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  VanillaDateCache dc=new VanillaDateCache(format,1000,GMT);
  int now=(int)(System.currentTimeMillis() / 1000);
  for (int i=0; i < 10000; i++) {
    int now2=now + i;
    String str2=sdf.format(new Date(now2 * 1000L));
    String str=dc.formatFor(now2);
    assertEquals(""String_Node_Str"" + i,str2,str);
  }
}"
52239,"@Test(timeout=31000) public void testDataCacheTimeout() throws IOException {
  final String baseDir=getTestPath();
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).dataCacheCapacity(10000).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000);
  final VanillaDataCache dataCache=new VanillaDataCache(builder,dateCache,10 + 7);
  try {
    int cycle=(int)(System.currentTimeMillis() / 1000);
    for (int j=0; j < 5; j++) {
      int runs=2000;
      for (int i=0; i < runs; i++) {
        VanillaMappedBytes buffer=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),i,true);
        File file=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),i,true);
        buffer.release();
        buffer.release();
        buffer.close();
        assertTrue(file.delete());
      }
    }
  }
  finally {
    dataCache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}","@Test(timeout=31000) public void testDataCacheTimeout() throws IOException {
  final String baseDir=getTestPath();
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).dataCacheCapacity(10000).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000,GMT);
  final VanillaDataCache dataCache=new VanillaDataCache(builder,dateCache,10 + 7);
  try {
    int cycle=(int)(System.currentTimeMillis() / 1000);
    for (int j=0; j < 5; j++) {
      int runs=2000;
      for (int i=0; i < runs; i++) {
        VanillaMappedBytes buffer=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),i,true);
        File file=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),i,true);
        buffer.release();
        buffer.release();
        buffer.close();
        assertTrue(file.delete());
      }
    }
  }
  finally {
    dataCache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}"
52240,"@Test public void testDataFor() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).dataCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000);
  final VanillaDataCache dataCache=new VanillaDataCache(builder,dateCache,10 + 6);
  try {
    int cycle=(int)(System.currentTimeMillis() / 1000);
    VanillaMappedBytes vanillaBuffer0=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),0,true);
    vanillaBuffer0.writeLong(0,0x12345678);
    File file0=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),0,true);
    assertEquals(64 << 10,file0.length());
    assertEquals(0x12345678L,vanillaBuffer0.readLong(0));
    vanillaBuffer0.release();
    VanillaMappedBytes vanillaBuffer1=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),1,true);
    File file1=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),1,true);
    assertEquals(64 << 10,file1.length());
    vanillaBuffer1.release();
    assertNotEquals(file1,file0);
    VanillaMappedBytes vanillaBuffer2=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),2,true);
    File file2=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),2,true);
    assertEquals(64 << 10,file2.length());
    vanillaBuffer2.release();
    assertNotEquals(file2,file0);
    assertNotEquals(file2,file1);
    dataCache.close();
    assertEquals(0,vanillaBuffer0.refCount());
    assertEquals(0,vanillaBuffer1.refCount());
    assertEquals(0,vanillaBuffer2.refCount());
    assertTrue(file0.delete());
    assertTrue(file1.delete());
    assertTrue(file2.delete());
    assertTrue(file0.getParentFile().delete());
    dataCache.checkCounts(1,1);
  }
  finally {
    dataCache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}","@Test public void testDataFor() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).dataCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000,GMT);
  final VanillaDataCache dataCache=new VanillaDataCache(builder,dateCache,10 + 6);
  try {
    int cycle=(int)(System.currentTimeMillis() / 1000);
    VanillaMappedBytes vanillaBuffer0=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),0,true);
    vanillaBuffer0.writeLong(0,0x12345678);
    File file0=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),0,true);
    assertEquals(64 << 10,file0.length());
    assertEquals(0x12345678L,vanillaBuffer0.readLong(0));
    vanillaBuffer0.release();
    VanillaMappedBytes vanillaBuffer1=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),1,true);
    File file1=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),1,true);
    assertEquals(64 << 10,file1.length());
    vanillaBuffer1.release();
    assertNotEquals(file1,file0);
    VanillaMappedBytes vanillaBuffer2=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),2,true);
    File file2=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),2,true);
    assertEquals(64 << 10,file2.length());
    vanillaBuffer2.release();
    assertNotEquals(file2,file0);
    assertNotEquals(file2,file1);
    dataCache.close();
    assertEquals(0,vanillaBuffer0.refCount());
    assertEquals(0,vanillaBuffer1.refCount());
    assertEquals(0,vanillaBuffer2.refCount());
    assertTrue(file0.delete());
    assertTrue(file1.delete());
    assertTrue(file2.delete());
    assertTrue(file0.getParentFile().delete());
    dataCache.checkCounts(1,1);
  }
  finally {
    dataCache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}"
52241,"@Test public void testDataForPerf() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).dataCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000);
  final VanillaDataCache dataCache=new VanillaDataCache(builder,dateCache,10 + 7);
  try {
    int cycle=(int)(System.currentTimeMillis() / 1000);
    File file=null;
    VanillaMappedBytes buffer=null;
    for (int j=0; j < 5; j++) {
      long start=System.nanoTime();
      int runs=10000;
      for (int i=0; i < runs; i++) {
        buffer=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),i,true);
        buffer.writeLong(0,0x12345678);
        file=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),i,true);
        assertEquals(128 << 10,file.length());
        assertEquals(0x12345678L,buffer.readLong(0));
        buffer.release();
        buffer.release();
        buffer.close();
        assertTrue(file.delete());
      }
      long time=System.nanoTime() - start;
      System.out.printf(""String_Node_Str"",time / runs / 1000);
      dataCache.checkCounts(0,0);
    }
  }
  finally {
    dataCache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}","@Test public void testDataForPerf() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).dataCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000,GMT);
  final VanillaDataCache dataCache=new VanillaDataCache(builder,dateCache,10 + 7);
  try {
    int cycle=(int)(System.currentTimeMillis() / 1000);
    File file=null;
    VanillaMappedBytes buffer=null;
    for (int j=0; j < 5; j++) {
      long start=System.nanoTime();
      int runs=10000;
      for (int i=0; i < runs; i++) {
        buffer=dataCache.dataFor(cycle,AffinitySupport.getThreadId(),i,true);
        buffer.writeLong(0,0x12345678);
        file=dataCache.fileFor(cycle,AffinitySupport.getThreadId(),i,true);
        assertEquals(128 << 10,file.length());
        assertEquals(0x12345678L,buffer.readLong(0));
        buffer.release();
        buffer.release();
        buffer.close();
        assertTrue(file.delete());
      }
      long time=System.nanoTime() - start;
      System.out.printf(""String_Node_Str"",time / runs / 1000);
      dataCache.checkCounts(0,0);
    }
  }
  finally {
    dataCache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}"
52242,"@Test public void testFindNextDataCount() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  try {
    final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).dataCacheCapacity(32).cleanupOnClose(false);
    final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000);
    final VanillaDataCache dataCache=new VanillaDataCache(builder,dateCache,10 + 6);
    int cycle=(int)(System.currentTimeMillis() / 1000);
    final int threadId=AffinitySupport.getThreadId();
    assertEquals(0,dataCache.findNextDataCount(cycle,threadId));
    VanillaMappedBytes vanillaBuffer1=dataCache.dataFor(cycle,threadId,1,true);
    vanillaBuffer1.release();
    VanillaMappedBytes vanillaBuffer2=dataCache.dataFor(cycle,threadId,2,true);
    vanillaBuffer2.release();
    VanillaMappedBytes vanillaBuffer4=dataCache.dataFor(cycle,threadId,4,true);
    vanillaBuffer4.release();
    dataCache.checkCounts(1,1);
    dataCache.close();
    final VanillaDataCache dataCache2=new VanillaDataCache(builder,dateCache,10 + 6);
    assertEquals(5,dataCache2.findNextDataCount(cycle,threadId));
    dataCache.checkCounts(1,1);
    dataCache2.close();
  }
  finally {
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}","@Test public void testFindNextDataCount() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  try {
    final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).dataCacheCapacity(32).cleanupOnClose(false);
    final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000,GMT);
    final VanillaDataCache dataCache=new VanillaDataCache(builder,dateCache,10 + 6);
    int cycle=(int)(System.currentTimeMillis() / 1000);
    final int threadId=AffinitySupport.getThreadId();
    assertEquals(0,dataCache.findNextDataCount(cycle,threadId));
    VanillaMappedBytes vanillaBuffer1=dataCache.dataFor(cycle,threadId,1,true);
    vanillaBuffer1.release();
    VanillaMappedBytes vanillaBuffer2=dataCache.dataFor(cycle,threadId,2,true);
    vanillaBuffer2.release();
    VanillaMappedBytes vanillaBuffer4=dataCache.dataFor(cycle,threadId,4,true);
    vanillaBuffer4.release();
    dataCache.checkCounts(1,1);
    dataCache.close();
    final VanillaDataCache dataCache2=new VanillaDataCache(builder,dateCache,10 + 6);
    assertEquals(5,dataCache2.findNextDataCount(cycle,threadId));
    dataCache.checkCounts(1,1);
    dataCache2.close();
  }
  finally {
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}"
52243,"@Test public void testIndexFor() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).indexCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000);
  final VanillaIndexCache cache=new VanillaIndexCache(builder,dateCache,10 + 3,FileLifecycleListener.FileLifecycleListeners.CONSOLE);
  try {
    int cycle=(int)(System.currentTimeMillis() / 1000);
    VanillaMappedBytes vanillaBuffer0=cache.indexFor(cycle,0,true);
    vanillaBuffer0.writeLong(0,0x12345678);
    File file0=VanillaChronicleUtils.fileFor(baseDir,cycle,0,dateCache);
    assertEquals(8 << 10,file0.length());
    assertEquals(0x12345678L,vanillaBuffer0.readLong(0));
    vanillaBuffer0.release();
    VanillaMappedBytes vanillaBuffer1=cache.indexFor(cycle,1,true);
    File file1=VanillaChronicleUtils.fileFor(baseDir,cycle,1,dateCache);
    assertEquals(8 << 10,file1.length());
    vanillaBuffer1.release();
    assertNotEquals(file1,file0);
    VanillaMappedBytes vanillaBuffer2=cache.indexFor(cycle,2,true);
    File file2=VanillaChronicleUtils.fileFor(baseDir,cycle,2,dateCache);
    assertEquals(8 << 10,file2.length());
    vanillaBuffer2.release();
    assertNotEquals(file2,file0);
    assertNotEquals(file2,file1);
    cache.close();
    assertEquals(0,vanillaBuffer0.refCount());
    assertEquals(0,vanillaBuffer1.refCount());
    assertEquals(0,vanillaBuffer2.refCount());
    assertTrue(file0.delete());
    assertTrue(file1.delete());
    assertTrue(file2.delete());
    assertTrue(file0.getParentFile().delete());
    cache.checkCounts(1,1);
  }
  finally {
    cache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}","@Test public void testIndexFor() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).indexCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000,GMT);
  final VanillaIndexCache cache=new VanillaIndexCache(builder,dateCache,10 + 3,FileLifecycleListener.FileLifecycleListeners.CONSOLE);
  try {
    int cycle=(int)(System.currentTimeMillis() / 1000);
    VanillaMappedBytes vanillaBuffer0=cache.indexFor(cycle,0,true);
    vanillaBuffer0.writeLong(0,0x12345678);
    File file0=VanillaChronicleUtils.fileFor(baseDir,cycle,0,dateCache);
    assertEquals(8 << 10,file0.length());
    assertEquals(0x12345678L,vanillaBuffer0.readLong(0));
    vanillaBuffer0.release();
    VanillaMappedBytes vanillaBuffer1=cache.indexFor(cycle,1,true);
    File file1=VanillaChronicleUtils.fileFor(baseDir,cycle,1,dateCache);
    assertEquals(8 << 10,file1.length());
    vanillaBuffer1.release();
    assertNotEquals(file1,file0);
    VanillaMappedBytes vanillaBuffer2=cache.indexFor(cycle,2,true);
    File file2=VanillaChronicleUtils.fileFor(baseDir,cycle,2,dateCache);
    assertEquals(8 << 10,file2.length());
    vanillaBuffer2.release();
    assertNotEquals(file2,file0);
    assertNotEquals(file2,file1);
    cache.close();
    assertEquals(0,vanillaBuffer0.refCount());
    assertEquals(0,vanillaBuffer1.refCount());
    assertEquals(0,vanillaBuffer2.refCount());
    assertTrue(file0.delete());
    assertTrue(file1.delete());
    assertTrue(file2.delete());
    assertTrue(file0.getParentFile().delete());
    cache.checkCounts(1,1);
  }
  finally {
    cache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}"
52244,"@Test public void testConcurrentAppend() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).indexCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000);
  final VanillaIndexCache cache=new VanillaIndexCache(builder,dateCache,5,FileLifecycleListener.FileLifecycleListeners.CONSOLE);
  final int cycle=(int)(System.currentTimeMillis() / 1000);
  final int numberOfTasks=2;
  final int countPerTask=1000;
  try {
    final List<Callable<Void>> tasks=new ArrayList<>();
    long nextValue=countPerTask;
    for (int i=0; i < numberOfTasks; i++) {
      final long endValue=nextValue + countPerTask;
      tasks.add(createAppendTask(cache,cycle,nextValue,endValue));
      nextValue=endValue;
    }
    TestTaskExecutionUtil.executeConcurrentTasks(tasks,30000L);
    final Set<Long> indexValues=readAllIndexValues(cache,cycle);
    final Set<Long> rangeSet=createRangeSet(countPerTask,nextValue);
    assertEquals(rangeSet,indexValues);
    cache.checkCounts(1,1);
  }
  finally {
    cache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}","@Test public void testConcurrentAppend() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).indexCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000,GMT);
  final VanillaIndexCache cache=new VanillaIndexCache(builder,dateCache,5,FileLifecycleListener.FileLifecycleListeners.CONSOLE);
  final int cycle=(int)(System.currentTimeMillis() / 1000);
  final int numberOfTasks=2;
  final int countPerTask=1000;
  try {
    final List<Callable<Void>> tasks=new ArrayList<>();
    long nextValue=countPerTask;
    for (int i=0; i < numberOfTasks; i++) {
      final long endValue=nextValue + countPerTask;
      tasks.add(createAppendTask(cache,cycle,nextValue,endValue));
      nextValue=endValue;
    }
    TestTaskExecutionUtil.executeConcurrentTasks(tasks,30000L);
    final Set<Long> indexValues=readAllIndexValues(cache,cycle);
    final Set<Long> rangeSet=createRangeSet(countPerTask,nextValue);
    assertEquals(rangeSet,indexValues);
    cache.checkCounts(1,1);
  }
  finally {
    cache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}"
52245,"@Test public void testLastIndexFile() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).indexCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000);
  final VanillaIndexCache cache=new VanillaIndexCache(builder,dateCache,10 + 3,FileLifecycleListener.FileLifecycleListeners.CONSOLE);
  final int cycle=(int)(System.currentTimeMillis() / 1000);
  try {
    assertEquals(0,cache.lastIndexFile(cycle));
    final VanillaMappedBytes vanillaBuffer0=cache.indexFor(cycle,0,true);
    assertEquals(""String_Node_Str"",VanillaChronicleUtils.fileFor(baseDir,cycle,0,dateCache).getName());
    vanillaBuffer0.release();
    assertEquals(0,cache.lastIndexFile(cycle));
    final VanillaMappedBytes vanillaBuffer1=cache.indexFor(cycle,1,true);
    assertEquals(""String_Node_Str"",VanillaChronicleUtils.fileFor(baseDir,cycle,1,dateCache).getName());
    vanillaBuffer1.release();
    assertEquals(1,cache.lastIndexFile(cycle));
    final VanillaMappedBytes vanillaBuffer3=cache.indexFor(cycle,3,true);
    assertEquals(""String_Node_Str"",VanillaChronicleUtils.fileFor(baseDir,cycle,3,dateCache).getName());
    vanillaBuffer3.release();
    assertEquals(3,cache.lastIndexFile(cycle));
    cache.checkCounts(1,1);
  }
  finally {
    cache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}","@Test public void testLastIndexFile() throws IOException {
  final String baseDir=getTestPath();
  assertNotNull(baseDir);
  final ChronicleQueueBuilder.VanillaChronicleQueueBuilder builder=ChronicleQueueBuilder.vanilla(baseDir).indexCacheCapacity(32).cleanupOnClose(false);
  final VanillaDateCache dateCache=new VanillaDateCache(""String_Node_Str"",1000,GMT);
  final VanillaIndexCache cache=new VanillaIndexCache(builder,dateCache,10 + 3,FileLifecycleListener.FileLifecycleListeners.CONSOLE);
  final int cycle=(int)(System.currentTimeMillis() / 1000);
  try {
    assertEquals(0,cache.lastIndexFile(cycle));
    final VanillaMappedBytes vanillaBuffer0=cache.indexFor(cycle,0,true);
    assertEquals(""String_Node_Str"",VanillaChronicleUtils.fileFor(baseDir,cycle,0,dateCache).getName());
    vanillaBuffer0.release();
    assertEquals(0,cache.lastIndexFile(cycle));
    final VanillaMappedBytes vanillaBuffer1=cache.indexFor(cycle,1,true);
    assertEquals(""String_Node_Str"",VanillaChronicleUtils.fileFor(baseDir,cycle,1,dateCache).getName());
    vanillaBuffer1.release();
    assertEquals(1,cache.lastIndexFile(cycle));
    final VanillaMappedBytes vanillaBuffer3=cache.indexFor(cycle,3,true);
    assertEquals(""String_Node_Str"",VanillaChronicleUtils.fileFor(baseDir,cycle,3,dateCache).getName());
    vanillaBuffer3.release();
    assertEquals(3,cache.lastIndexFile(cycle));
    cache.checkCounts(1,1);
  }
  finally {
    cache.close();
    IOTools.deleteDir(baseDir);
    assertFalse(new File(baseDir).exists());
  }
}"
52246,"protected synchronized ExcerptCommon createAppender0() throws IOException {
  if (this.excerpt != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return this.excerpt=new StatelessExcerpAppender();
}","protected synchronized ExcerptCommon createAppender0() throws IOException {
  if (this.excerpt != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return this.excerpt=new StatelessExcerptAppender();
}"
52247,"@Override public void finish(){
  if (!isFinished()) {
    if (!connection.isOpen()) {
      openConnection();
    }
    try {
      connection.writeAction(commandBuffer,actionType,position());
      connection.writeAllOrEOF(wrapped.buffer());
      if (builder.appendRequireAck()) {
        connection.readUpTo(readBuffer,ChronicleTcp.HEADER_SIZE,-1);
        int recType=readBuffer.getInt();
        long recIndex=readBuffer.getLong();
switch (recType) {
case ChronicleTcp.ACK_LEN:
          this.lastIndex=recIndex;
        break;
case ChronicleTcp.NACK_LEN:
      throw new IllegalStateException(""String_Node_Str"" + (recIndex == ChronicleTcp.IDX_NOT_SUPPORTED ? ""String_Node_Str"" : ""String_Node_Str""));
default :
    logger.warn(""String_Node_Str"",recType,recIndex);
}
}
}
 catch (IOException e) {
LOGGER.trace(""String_Node_Str"",e);
throw new IllegalStateException(e);
}
}
super.finish();
}","@Override public void finish(){
  if (!isFinished()) {
    if (!connection.isOpen()) {
      openConnection();
    }
    try {
      connection.writeAction(commandBuffer,actionType,position());
      ByteBuffer buffer=wrapped.buffer();
      buffer.limit((int)wrapped.position());
      connection.writeAllOrEOF(buffer);
      if (builder.appendRequireAck()) {
        connection.readUpTo(readBuffer,ChronicleTcp.HEADER_SIZE,-1);
        int recType=readBuffer.getInt();
        long recIndex=readBuffer.getLong();
switch (recType) {
case ChronicleTcp.ACK_LEN:
          this.lastIndex=recIndex;
        break;
case ChronicleTcp.NACK_LEN:
      throw new IllegalStateException(""String_Node_Str"" + (recIndex == ChronicleTcp.IDX_NOT_SUPPORTED ? ""String_Node_Str"" : ""String_Node_Str""));
default :
    logger.warn(""String_Node_Str"",recType,recIndex);
}
}
}
 catch (IOException e) {
LOGGER.trace(""String_Node_Str"",e);
throw new IllegalStateException(e);
}
}
super.finish();
}"
52248,"@Override public long appendDocument(@NotNull Bytes buffer){
  long length=buffer.remaining();
  if (length > MAX_LENGTH)   throw new IllegalStateException(""String_Node_Str"" + length);
  LongValue writeByte=header.writeByte;
  long lastByte=writeByte.getVolatileValue();
  for (; ; ) {
    if (bytes.compareAndSwapInt(lastByte,0,NOT_READY | (int)length)) {
      long lastByte2=lastByte + 4 + buffer.remaining();
      bytes.write(lastByte + 4,buffer);
      long lastIndex=header.lastIndex.addAtomicValue(1);
      writeByte.setOrderedValue(lastByte2);
      bytes.writeOrderedInt(lastByte,(int)length);
      return lastIndex;
    }
    int length2=length30(bytes.readVolatileInt());
    bytes.skip(length2);
    Jvm.checkInterrupted();
  }
}","@Override public long appendDocument(@NotNull Bytes buffer){
  long length=buffer.remaining();
  if (length > MAX_LENGTH)   throw new IllegalStateException(""String_Node_Str"" + length);
  LongValue writeByte=header.writeByte();
  long lastByte=writeByte.getVolatileValue();
  for (; ; ) {
    if (bytes.compareAndSwapInt(lastByte,0,NOT_READY | (int)length)) {
      long lastByte2=lastByte + 4 + buffer.remaining();
      bytes.write(lastByte + 4,buffer);
      long lastIndex=header.lastIndex().addAtomicValue(1);
      writeByte.setOrderedValue(lastByte2);
      bytes.writeOrderedInt(lastByte,(int)length);
      return lastIndex;
    }
    int length2=length30(bytes.readVolatileInt());
    bytes.skip(length2);
    try {
      Jvm.checkInterrupted();
    }
 catch (    InterruptedException e) {
      throw new InterruptedRuntimeException(e);
    }
  }
}"
52249,"private void readHeader() throws IOException {
  waitForTheHeaderToBeBuilt(bytes);
  bytes.position(HEADER_OFFSET);
  wire.readDocument($ -> wire.read().marshallable(header),null);
  firstBytes=bytes.position();
}","private void readHeader() throws IOException {
  waitForTheHeaderToBeBuilt(bytes);
  bytes.position(HEADER_OFFSET);
  Consumer<WireIn> nullConsumer=o -> {
  }
;
  Consumer<WireIn> dataConsumer=$ -> {
    wire.read().marshallable(header);
  }
;
  wire.readDocument(dataConsumer,nullConsumer);
  firstBytes=bytes.position();
}"
52250,"/** 
 * Creates a new Excerpt containing and index which will be 1L << 17L bytes long, This method is used for creating both the primary and secondary indexes. Chronicle Queue uses a root primary index ( each entry in the primary index points to a unique a secondary index. The secondary index only records the address of every 64th except, the except are linearly scanned from there on.
 * @return the address of the Excerpt containing the usable index, just after the header
 */
long newIndex(){
  long indexSize=1L << 17L;
  try (DirectStore allocate=DirectStore.allocate(6)){
    final DirectBytes buffer=allocate.bytes();
    new BinaryWire(buffer).write(() -> ""String_Node_Str"");
    buffer.flip();
    final long keyLen=buffer.limit();
    final long length=buffer.remaining();
    if (length > MAX_LENGTH)     throw new IllegalStateException(""String_Node_Str"" + length);
    final LongValue writeByte=header.writeByte;
    final long lastByte=writeByte.getVolatileValue();
    for (; ; ) {
      if (bytes.compareAndSwapInt(lastByte,0,NOT_READY | (int)length)) {
        long lastByte2=lastByte + 4 + buffer.remaining()+ indexSize;
        bytes.write(lastByte + 4,buffer);
        header.lastIndex.addAtomicValue(1);
        writeByte.setOrderedValue(lastByte2);
        bytes.writeOrderedInt(lastByte,(int)(6 + indexSize));
        long start=lastByte + 4;
        bytes.zeroOut(start + keyLen,start + keyLen + length);
        return start + keyLen;
      }
      int length2=length30(bytes.readVolatileInt());
      bytes.skip(length2);
      Jvm.checkInterrupted();
    }
  }
 }","/** 
 * Creates a new Excerpt containing and index which will be 1L << 17L bytes long, This method is used for creating both the primary and secondary indexes. Chronicle Queue uses a root primary index ( each entry in the primary index points to a unique a secondary index. The secondary index only records the address of every 64th except, the except are linearly scanned from there on.
 * @return the address of the Excerpt containing the usable index, just after the header
 */
long newIndex(){
  long indexSize=1L << 17L;
  try (NativeStore<Void> allocate=NativeStore.nativeStore(6)){
    final Bytes<Void> buffer=allocate.bytes();
    new BinaryWire(buffer).write(() -> ""String_Node_Str"");
    buffer.flip();
    final long keyLen=buffer.limit();
    final long length=buffer.remaining();
    if (length > MAX_LENGTH)     throw new IllegalStateException(""String_Node_Str"" + length);
    final LongValue writeByte=header.writeByte();
    final long lastByte=writeByte.getVolatileValue();
    for (; ; ) {
      if (bytes.compareAndSwapInt(lastByte,0,NOT_READY | (int)length)) {
        long lastByte2=lastByte + 4 + buffer.remaining()+ indexSize;
        bytes.write(lastByte + 4,buffer);
        header.lastIndex().addAtomicValue(1);
        writeByte.setOrderedValue(lastByte2);
        bytes.writeOrderedInt(lastByte,(int)(6 + indexSize));
        long start=lastByte + 4;
        bytes.zeroOut(start + keyLen,start + keyLen + length);
        return start + keyLen;
      }
      int length2=length30(bytes.readVolatileInt());
      bytes.skip(length2);
      Jvm.checkInterrupted();
    }
  }
 catch (  Exception e) {
    throw new IORuntimeException(e);
  }
}"
52251,"@Override public long lastIndex(){
  long value=header.lastIndex.getVolatileValue();
  if (value == -1)   throw new IllegalStateException(""String_Node_Str"");
  return value;
}","@Override public long lastIndex(){
  long value=header.lastIndex().getVolatileValue();
  if (value == -1)   throw new IllegalStateException(""String_Node_Str"");
  return value;
}"
52252,"/** 
 * @return gets the index2index, or creates it, if it does not exist.
 */
long indexToIndex(){
  for (; ; ) {
    long index2Index=header.index2Index.getVolatileValue();
    if (index2Index == NOT_READY)     continue;
    if (index2Index != UNINITIALISED)     return index2Index;
    if (!header.index2Index.compareAndSwapValue(UNINITIALISED,NOT_READY))     continue;
    long indexToIndex=newIndex();
    header.index2Index.setOrderedValue(indexToIndex);
    return indexToIndex;
  }
}","/** 
 * @return gets the index2index, or creates it, if it does not exist.
 */
long indexToIndex(){
  for (; ; ) {
    long index2Index=header.index2Index().getVolatileValue();
    if (index2Index == NOT_READY)     continue;
    if (index2Index != UNINITIALISED)     return index2Index;
    if (!header.index2Index().compareAndSwapValue(UNINITIALISED,NOT_READY))     continue;
    long indexToIndex=newIndex();
    header.index2Index().setOrderedValue(indexToIndex);
    return indexToIndex;
  }
}"
52253,"@Override public boolean index(final long index){
  long address0=chronicle.indexToIndex() + toAddress0(index);
  long address1=chronicle.bytes().readVolatileLong(address0);
  long address2=0;
  long start=0;
  if (address1 != 0) {
    long offset=address1 + toAddress1(index);
    address2=chronicle.bytes().readVolatileLong(offset);
    if (address2 != 0) {
      wire.bytes().position(address2);
      start=((index / 64L)) * 64L;
    }
  }
  if (address2 == 0) {
    long lastKnownIndex=0;
    long newAddress0=0;
    int count=0;
    for (newAddress0=chronicle.indexToIndex(); count < ((int)(1L << 17L)); newAddress0+=8, count++) {
      long l=chronicle.bytes().readVolatileLong(newAddress0);
      if (l != 0) {
        address1=l;
        if (count > 0)         lastKnownIndex+=(1L << (17L + 6L));
      }
 else       break;
    }
    if (address1 != 0) {
      long newAddress1;
      for (newAddress1=address1, count=0; count < ((int)(1L << 17L)); newAddress1+=8, count++) {
        long l=chronicle.bytes().readVolatileLong(newAddress1);
        if (l != 0) {
          address2=l;
          if (count > 0)           lastKnownIndex+=(1L << (6L));
        }
 else         break;
      }
    }
    if (address2 != 0) {
      wire.bytes().position(address2);
      start=lastKnownIndex;
    }
  }
  final LongValue position=DataValueClasses.newInstance(LongValue.class);
  long last=chronicle.lastIndex();
  for (long i=start; i < last; i++) {
    final long j=i;
    Function<WireIn,Object> reader=wireIn -> {
      if (index == j)       position.setValue(wire.bytes().position() - 4);
      wireIn.bytes().skip(wireIn.bytes().remaining());
      return null;
    }
;
    wire.readDocument(reader);
    if (position.getValue() != 0) {
      wire.bytes().position(position.getValue());
      return true;
    }
  }
  return false;
}","@Override public boolean index(final long index){
  long address0=chronicle.indexToIndex() + toAddress0(index);
  long address1=chronicle.bytes().readVolatileLong(address0);
  long address2=0;
  long start=0;
  if (address1 != 0) {
    long offset=address1 + toAddress1(index);
    address2=chronicle.bytes().readVolatileLong(offset);
    if (address2 != 0) {
      wire.bytes().position(address2);
      start=((index / 64L)) * 64L;
    }
  }
  if (address2 == 0) {
    long lastKnownIndex=0;
    long newAddress0=0;
    int count=0;
    for (newAddress0=chronicle.indexToIndex(); count < ((int)(1L << 17L)); newAddress0+=8, count++) {
      long l=chronicle.bytes().readVolatileLong(newAddress0);
      if (l != 0) {
        address1=l;
        if (count > 0)         lastKnownIndex+=(1L << (17L + 6L));
      }
 else       break;
    }
    if (address1 != 0) {
      long newAddress1;
      for (newAddress1=address1, count=0; count < ((int)(1L << 17L)); newAddress1+=8, count++) {
        long l=chronicle.bytes().readVolatileLong(newAddress1);
        if (l != 0) {
          address2=l;
          if (count > 0)           lastKnownIndex+=(1L << (6L));
        }
 else         break;
      }
    }
    if (address2 != 0) {
      wire.bytes().position(address2);
      start=lastKnownIndex;
    }
  }
  final LongValue position=codeTemplate.newInstance(LongValue.class);
  long last=chronicle.lastIndex();
  for (long i=start; i < last; i++) {
    final long j=i;
    final Consumer<WireIn> metaDataConsumer=wireIn -> {
      if (index == j)       position.setValue(wire.bytes().position() - 4);
      wireIn.bytes().skip(wireIn.bytes().remaining());
    }
;
    final Consumer<WireIn> dataConsumer=wireIn -> wireIn.bytes().skip(wireIn.bytes().remaining());
    wire.readDocument(metaDataConsumer,dataConsumer);
    if (position.getValue() != 0) {
      wire.bytes().position(position.getValue());
      return true;
    }
  }
  return false;
}"
52254,"@Override public boolean readDocument(Consumer<WireIn> reader){
  wire.readDocument(null,reader);
  return true;
}","@Override public boolean readDocument(Consumer<WireIn> reader){
  Consumer<WireIn> metaDataConsumer=new Consumer<WireIn>(){
    @Override public void accept(    WireIn wireIn){
    }
  }
;
  wire.readDocument(metaDataConsumer,reader);
  return true;
}"
52255,"private boolean compareAndSetWriteLocation(long expectedValue,long newValue){
  return buffer.compareAndSwapLong(writeLocationOffset,expectedValue,newValue);
}","private synchronized boolean compareAndSetWriteLocation(long expectedValue,long newValue){
  return writeLocationAtomic.compareAndSet(expectedValue,newValue);
}"
52256,"/** 
 * Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity,
 * @param bytes the {@code bytes} that you wish to add to the ring buffer
 * @return returning {@code true} upon success and {@code false} if this queue is full.
 */
public boolean offer(@NotNull Bytes bytes) throws InterruptedException {
  try {
    for (; ; ) {
      long writeLocation=this.writeLocation();
      if (Thread.currentThread().isInterrupted())       throw new InterruptedException();
      if (remainingForWrite(writeLocation) < bytes.remaining() + SIZE + FLAG)       return false;
      long len=bytes.remaining();
      long messageLen=SIZE + FLAG + len;
      long offset=writeLocation;
      if (!header.compareAndSetWriteLocation(writeLocation,LOCKED))       continue;
      long flagLoc=offset;
      offset=this.bytes.writeByte(offset,States.BUSY.ordinal());
      if (!header.compareAndSetWriteLocation(-1,writeLocation + messageLen))       continue;
      offset=this.bytes.write(offset,len);
      this.bytes.write(offset,bytes);
      this.bytes.writeByte(flagLoc,States.READY.ordinal());
      return true;
    }
  }
 catch (  IllegalStateException e) {
    return false;
  }
}","/** 
 * Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity,
 * @param bytes the {@code bytes} that you wish to add to the ring buffer
 * @return returning {@code true} upon success and {@code false} if this queue is full.
 */
public boolean offer(@NotNull Bytes bytes) throws InterruptedException {
}"
52257,"/** 
 * sets the point at which you should not write any additional bits
 */
private void setWriteUpTo(long value){
  buffer.writeOrderedLong(writeUpToOffset,value);
}","/** 
 * sets the point at which you should not write any additional bits
 */
private void setWriteUpTo(long value){
  writeUpToOffsetAtomic.set(value);
}"
52258,"private long getWriteLocation(){
  return buffer.readVolatileLong(writeLocationOffset);
}","private synchronized long getWriteLocation(){
  return writeLocationAtomic.get();
}"
52259,"private long getReadLocation(){
  return buffer.readVolatileLong(readLocationOffset);
}","private long getReadLocation(){
  return readLocationAtomic.get();
}"
52260,"/** 
 * @return the point at which you should not write any additional bits
 */
private long getWriteUpTo(){
  return buffer.readVolatileLong(writeUpToOffset);
}","/** 
 * @return the point at which you should not write any additional bits
 */
private long getWriteUpTo(){
  return writeUpToOffsetAtomic.get();
}"
52261,"private void setReadLocation(long value){
  buffer.writeOrderedLong(readLocationOffset,value);
}","private void setReadLocation(long value){
  readLocationAtomic.set(value);
}"
52262,"private boolean casMagicOffset(long expected,long value){
  if (Jvm.vmSupportsCS8())   return bytes.compareAndSwapLong(MAGIC_OFFSET,expected,value);
synchronized (bytes) {
    if (bytes.readVolatileLong(MAGIC_OFFSET) == expected) {
      bytes.writeOrderedLong(MAGIC_OFFSET,value);
      return true;
    }
    return false;
  }
}","private boolean casMagicOffset(long expected,long value){
synchronized (bytes) {
    if (bytes.readVolatileLong(MAGIC_OFFSET) == expected) {
      bytes.writeOrderedLong(MAGIC_OFFSET,value);
      return true;
    }
    return false;
  }
}"
52263,"private void buildHeader(){
  bytes.position(HEADER_OFFSET);
  wire.writeMetaData(() -> wire.write(MetaDataKey.header).writeMarshallable(header.init(Compression.NONE)));
  if (!bytes.compareAndSwapLong(MAGIC_OFFSET,BUILDING,QUEUE_CREATED))   throw new AssertionError(""String_Node_Str"");
}","private void buildHeader(){
  bytes.position(HEADER_OFFSET);
  wire.writeMetaData(() -> wire.write(MetaDataKey.header).writeMarshallable(header.init(Compression.NONE)));
  if (!casMagicOffset(BUILDING,QUEUE_CREATED))   throw new AssertionError(""String_Node_Str"");
}"
52264,"private void initialiseHeader() throws IOException {
  if (bytes.compareAndSwapLong(MAGIC_OFFSET,UNINITIALISED,BUILDING)) {
    buildHeader();
  }
  readHeader();
}","private void initialiseHeader() throws IOException {
  if (casMagicOffset(UNINITIALISED,BUILDING)) {
    buildHeader();
  }
  readHeader();
}"
52265,"private boolean compareAndSetWriteLocation(long expectedValue,long newValue){
  if (Jvm.VMSupportsCS8())   return buffer.compareAndSwapLong(writeLocationOffset,expectedValue,newValue);
synchronized (this) {
    if (expectedValue == getWriteLocation()) {
      setWriteLocation(newValue);
      return true;
    }
    return false;
  }
}","private boolean compareAndSetWriteLocation(long expectedValue,long newValue){
  if (Jvm.vmSupportsCS8())   return buffer.compareAndSwapLong(writeLocationOffset,expectedValue,newValue);
synchronized (this) {
    if (expectedValue == getWriteLocation()) {
      setWriteLocation(newValue);
      return true;
    }
    return false;
  }
}"
52266,"private void readSome(Chronicle chronicle) throws IOException {
  ExcerptTailer tailer=chronicle.createTailer();
  StringBuilder sb=new StringBuilder();
  Function<WireIn,WireIn> reader=wire -> wire.read().text(sb);
  for (int i=0; i < RUNS; i++) {
    assertTrue(tailer.readDocument(reader));
  }
}","private void readSome(Chronicle chronicle) throws IOException {
  ExcerptTailer tailer=chronicle.createTailer();
  StringBuilder sb=new StringBuilder();
  Function<WireIn,WireIn> reader=wire -> wire.read(TestKey.test).text(sb);
  for (int i=0; i < RUNS; i++) {
    assertTrue(tailer.readDocument(reader));
  }
}"
52267,"@Test public void testCreateAppender() throws Exception {
  for (int t=0; t < 10; t++) {
    String name=""String_Node_Str"" + System.nanoTime() + ""String_Node_Str"";
    new File(name).deleteOnExit();
    Chronicle chronicle=new ChronicleQueueBuilder(name).build();
    long start=System.nanoTime();
    writeSome(chronicle);
    long mid=System.nanoTime();
    readSome(chronicle);
    long end=System.nanoTime();
    System.out.printf(""String_Node_Str"",(mid - start) / RUNS,(end - mid) / RUNS);
  }
}","@Test public void testCreateAppender() throws Exception {
  for (int r=0; r < 2; r++) {
    for (int t=1; t <= 12; t++) {
      List<Future<?>> futureList=new ArrayList<>();
      long start=System.nanoTime();
      for (int j=0; j < 4; j++) {
        String name=""String_Node_Str"" + start + ""String_Node_Str""+ j+ ""String_Node_Str"";
        new File(name).deleteOnExit();
        Chronicle chronicle=new ChronicleQueueBuilder(name).build();
        futureList.add(ForkJoinPool.commonPool().submit(() -> {
          writeSome(chronicle);
          return null;
        }
));
      }
      for (      Future<?> future : futureList) {
        future.get();
      }
      futureList.clear();
      long mid=System.nanoTime();
      for (int j=0; j < 4; j++) {
        String name=""String_Node_Str"" + start + ""String_Node_Str""+ j+ ""String_Node_Str"";
        new File(name).deleteOnExit();
        Chronicle chronicle=new ChronicleQueueBuilder(name).build();
        futureList.add(ForkJoinPool.commonPool().submit(() -> {
          readSome(chronicle);
          return null;
        }
));
      }
      for (      Future<?> future : futureList) {
        future.get();
      }
      long end=System.nanoTime();
      System.out.printf(""String_Node_Str"",t,t * RUNS * 1e3 / (mid - start),t * RUNS * 1e3 / (end - mid));
    }
  }
}"
52268,"private void writeSome(Chronicle chronicle) throws IOException {
  ExcerptAppender appender=chronicle.createAppender();
  for (int i=0; i < RUNS; i++) {
    appender.writeDocument(wire -> wire.write().text(""String_Node_Str""));
  }
}","private void writeSome(Chronicle chronicle) throws IOException {
  ExcerptAppender appender=chronicle.createAppender();
  for (int i=0; i < RUNS; i++) {
    appender.writeDocument(wire -> wire.write(TestKey.test).text(""String_Node_Str""));
  }
}"
52269,"@Override public String toDebugString(long limit){
  return wrappedCommon.toDebugString(limit);
}","@Override public String toDebugString(){
  return wrappedCommon.toDebugString();
}"
52270,"public boolean nextIndex(){
  checkNotClosed();
  if (index < 0) {
    toStart();
    if (index < 0)     return false;
  }
  long nextIndex=index + 1;
  while (true) {
    boolean found=index(nextIndex);
    if (found) {
      return true;
    }
    int cycle=(int)(nextIndex / builder.entriesPerCycle());
    if (cycle >= cycle()) {
      return false;
    }
    nextIndex=(cycle + 1) * builder.entriesPerCycle();
  }
}","public boolean nextIndex(){
  checkNotClosed();
  if (index < 0) {
    toStart();
    if (index < 0)     return false;
  }
  long nextIndex=index + 1;
  while (true) {
    boolean found=index(nextIndex);
    if (found) {
      index=nextIndex;
      return true;
    }
    int cycle=(int)(nextIndex / builder.entriesPerCycle());
    if (cycle >= cycle()) {
      return false;
    }
    nextIndex=(cycle + 1) * builder.entriesPerCycle();
  }
}"
52271,"@Override public void finish(){
  super.finish();
  int length=~(int)(positionAddr - startAddr);
  NativeBytes.UNSAFE.putOrderedInt(null,startAddr - 4,length);
  int offset=(int)(startAddr - dataBytes.address());
  long dataOffset=dataBytes.index() * config.dataBlockSize() + offset;
  long indexValue=((long)appenderThreadId << INDEX_DATA_OFFSET_BITS) + dataOffset;
  lastWrittenIndex=indexValue;
  try {
    if (!VanillaIndexCache.append(indexBytes,indexValue,nextSynchronous)) {
      if (indexBytes != null) {
        indexBytes.release();
        indexBytes=null;
      }
      indexBytes=indexCache.append(appenderCycle,indexValue,nextSynchronous);
    }
  }
 catch (  IOException e) {
    throw new AssertionError(e);
  }
  dataBytes.positionAddr(positionAddr);
  dataBytes.alignPositionAddr(4);
  if (nextSynchronous) {
    dataBytes.force();
  }
}","@Override public void finish(){
  super.finish();
  int length=~(int)(positionAddr - startAddr);
  NativeBytes.UNSAFE.putOrderedInt(null,startAddr - 4,length);
  int offset=(int)(startAddr - dataBytes.address());
  long dataOffset=dataBytes.index() * config.dataBlockSize() + offset;
  long indexValue=((long)appenderThreadId << INDEX_DATA_OFFSET_BITS) + dataOffset;
  try {
    long position=VanillaIndexCache.append(indexBytes,indexValue,nextSynchronous);
    if (position < 0) {
      if (indexBytes != null) {
        indexBytes.release();
        indexBytes=null;
      }
      indexBytes=indexCache.append(appenderCycle,indexValue,nextSynchronous,positionArr);
      setLastWrittenIndex(indexFrom(appenderCycle,positionArr[0]));
    }
 else {
      setLastWrittenIndex(indexFrom(appenderCycle,position));
    }
  }
 catch (  IOException e) {
    throw new AssertionError(e);
  }
  setIndex(lastWrittenIndex() + 1);
  dataBytes.positionAddr(positionAddr);
  dataBytes.alignPositionAddr(4);
  if (nextSynchronous) {
    dataBytes.force();
  }
}"
52272,"/** 
 * Return the last index written by the appender. This may not be the actual last index in the Chronicle which can be found from lastIndex().
 */
@Override public long lastWrittenIndex(){
  return VanillaChronicle.this.lastWrittenIndex();
}","/** 
 * Return the last index written by the appender. This may not be the actual last index in the Chronicle which can be found from lastIndex().
 */
@Override public long lastWrittenIndex(){
  return lastWrittenIndex;
}"
52273,"public static boolean append(final VanillaMappedBytes bytes,final long indexValue,final boolean synchronous){
  if (bytes != null) {
    boolean endOfFile=false;
    while (!endOfFile) {
      final long position=bytes.position();
      endOfFile=(bytes.limit() - position) < 8;
      if (!endOfFile) {
        if (bytes.compareAndSwapLong(position,0L,indexValue)) {
          if (synchronous) {
            bytes.force();
          }
          return true;
        }
        bytes.position(position + 8);
      }
    }
  }
  return false;
}","public static long append(final VanillaMappedBytes bytes,final long indexValue,final boolean synchronous){
  if (bytes != null) {
    boolean endOfFile=false;
    while (!endOfFile) {
      final long position=bytes.position();
      endOfFile=(bytes.limit() - position) < 8;
      if (!endOfFile) {
        if (bytes.compareAndSwapLong(position,0L,indexValue)) {
          if (synchronous) {
            bytes.force();
          }
          return position;
        }
        bytes.position(position + 8);
      }
    }
  }
  return -1;
}"
52274,"@Override public Void call() throws Exception {
  long counter=startValue;
  while (counter < endValue) {
    final VanillaMappedBytes vmb=cache.append(cycle,counter,false);
    if (vmb != null) {
      vmb.release();
    }
    counter++;
  }
  return null;
}","@Override public Void call() throws Exception {
  long counter=startValue;
  while (counter < endValue) {
    final VanillaMappedBytes vmb=cache.append(cycle,counter,false,new long[1]);
    if (vmb != null) {
      vmb.release();
    }
    counter++;
  }
  return null;
}"
52275,"private Callable<Void> createAppendTask(final VanillaIndexCache cache,final int cycle,final long startValue,final long endValue){
  return new Callable<Void>(){
    @Override public Void call() throws Exception {
      long counter=startValue;
      while (counter < endValue) {
        final VanillaMappedBytes vmb=cache.append(cycle,counter,false);
        if (vmb != null) {
          vmb.release();
        }
        counter++;
      }
      return null;
    }
  }
;
}","private Callable<Void> createAppendTask(final VanillaIndexCache cache,final int cycle,final long startValue,final long endValue){
  return new Callable<Void>(){
    @Override public Void call() throws Exception {
      long counter=startValue;
      while (counter < endValue) {
        final VanillaMappedBytes vmb=cache.append(cycle,counter,false,new long[1]);
        if (vmb != null) {
          vmb.release();
        }
        counter++;
      }
      return null;
    }
  }
;
}"
52276,"@Override public void finish(){
  super.finish();
  if (dataBytes != null) {
    int length=~(int)(positionAddr - startAddr);
    NativeBytes.UNSAFE.putOrderedInt(null,startAddr - 4,length);
    long indexValue=((long)appenderThreadId << INDEX_DATA_OFFSET_BITS) + dataOffset;
    try {
      long position=VanillaIndexCache.append(indexBytes,indexValue,nextSynchronous);
      if (position < 0) {
        if (indexBytes != null) {
          indexBytes.release();
          indexBytes=null;
        }
        indexBytes=indexCache.append(appenderCycle,indexValue,nextSynchronous,positionArr);
        setLastWrittenIndex(indexFrom(appenderCycle,positionArr[0]));
      }
 else {
        setLastWrittenIndex(indexFrom(appenderCycle,position));
      }
    }
 catch (    IOException e) {
      throw new AssertionError(e);
    }
    setIndex(lastWrittenIndex() + 1);
    dataBytes.positionAddr(positionAddr);
    dataBytes.alignPositionAddr(4);
    if (nextSynchronous) {
      dataBytes.force();
    }
  }
}","@Override public void finish(){
  super.finish();
  if (dataBytes == null)   return;
  int length=~(int)(positionAddr - startAddr);
  NativeBytes.UNSAFE.putOrderedInt(null,startAddr - 4,length);
  int offset=(int)(startAddr - dataBytes.address());
  long dataOffset=dataBytes.index() * config.dataBlockSize() + offset;
  long indexValue=((long)appenderThreadId << INDEX_DATA_OFFSET_BITS) + dataOffset;
  try {
    long position=VanillaIndexCache.append(indexBytes,indexValue,nextSynchronous);
    if (position < 0) {
      if (indexBytes != null) {
        indexBytes.release();
        indexBytes=null;
      }
      indexBytes=indexCache.append(appenderCycle,indexValue,nextSynchronous,positionArr);
      setLastWrittenIndex(indexFrom(appenderCycle,positionArr[0]));
    }
 else {
      setLastWrittenIndex(indexFrom(appenderCycle,position));
    }
  }
 catch (  IOException e) {
    throw new AssertionError(e);
  }
  setIndex(lastWrittenIndex() + 1);
  dataBytes.positionAddr(positionAddr);
  dataBytes.alignPositionAddr(4);
  if (nextSynchronous) {
    dataBytes.force();
  }
}"
52277,"public VanillaFile(String basePath,String cycleStr,String name,int indexCount,long size,boolean forAppend) throws IOException {
  logger=Logger.getLogger(VanillaFile.class.getName() + ""String_Node_Str"" + name);
  File dir=new File(basePath,cycleStr);
  this.indexCount=indexCount;
  if (!dir.isDirectory()) {
    boolean created=dir.mkdirs();
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + dir + ""String_Node_Str""+ created);
  }
  file=new File(dir,name);
  if (file.exists()) {
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + file);
  }
 else   if (forAppend) {
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + file);
  }
 else {
    throw new FileNotFoundException(file.getAbsolutePath());
  }
  fc=new RandomAccessFile(file,""String_Node_Str"").getChannel();
  map=fc.map(FileChannel.MapMode.READ_WRITE,0,size);
  map.order(ByteOrder.nativeOrder());
  baseAddr=((DirectBuffer)map).address();
  bytes=new NativeBytes(null,baseAddr,baseAddr + size,usage);
}","public VanillaFile(String basePath,String cycleStr,String name,int indexCount,long size,boolean forAppend) throws IOException {
  logger=Logger.getLogger(VanillaFile.class.getName() + ""String_Node_Str"" + name);
  File dir=new File(basePath,cycleStr);
  this.indexCount=indexCount;
  if (!forAppend) {
    File f=new File(dir,name);
    if (!f.exists()) {
      throw new FileNotFoundException(f.getAbsolutePath());
    }
  }
  if (!dir.isDirectory()) {
    boolean created=dir.mkdirs();
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + dir + ""String_Node_Str""+ created);
  }
  file=new File(dir,name);
  if (file.exists()) {
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + file);
  }
 else   if (forAppend) {
    if (logger.isLoggable(Level.FINE))     logger.fine(""String_Node_Str"" + file);
  }
 else {
    throw new FileNotFoundException(file.getAbsolutePath());
  }
  fc=new RandomAccessFile(file,""String_Node_Str"").getChannel();
  map=fc.map(FileChannel.MapMode.READ_WRITE,0,size);
  map.order(ByteOrder.nativeOrder());
  baseAddr=((DirectBuffer)map).address();
  bytes=new NativeBytes(null,baseAddr,baseAddr + size,usage);
}"
52278,"private boolean readNextExcerpt(@NotNull SocketChannel sc){
  try {
    if (closed)     return false;
    if (readBuffer.remaining() < (scFirst ? TcpUtil.HEADER_SIZE : 4)) {
      if (readBuffer.remaining() == 0)       readBuffer.clear();
 else       readBuffer.compact();
      int minSize=scFirst ? 8 + 4 + 8 : 4 + 8;
      while (readBuffer.position() < minSize) {
        if (sc.read(readBuffer) < 0) {
          sc.close();
          return false;
        }
      }
      readBuffer.flip();
    }
    if (scFirst) {
      long scIndex=readBuffer.getLong();
      if (scIndex != chronicle.size())       scFirst=false;
    }
    int size=readBuffer.getInt();
    if (size > 128 << 20 || size < 0)     throw new StreamCorruptedException(""String_Node_Str"" + size);
    excerpt.startExcerpt(size);
    long remaining=size;
    int limit=readBuffer.limit();
    int size2=(int)Math.min(readBuffer.remaining(),remaining);
    remaining-=size2;
    readBuffer.limit(readBuffer.position() + size2);
    excerpt.write(readBuffer);
    readBuffer.limit(limit);
    while (remaining > 0) {
      readBuffer.clear();
      int size3=(int)Math.min(readBuffer.capacity(),remaining);
      readBuffer.limit(size3);
      if (sc.read(readBuffer) < 0)       throw new EOFException();
      readBuffer.flip();
      remaining-=readBuffer.remaining();
      excerpt.write(readBuffer);
    }
    excerpt.finish();
  }
 catch (  IOException e) {
    if (logger.isLoggable(Level.FINE))     logger.log(Level.FINE,""String_Node_Str"" + address + ""String_Node_Str"",e);
 else     if (logger.isLoggable(Level.INFO))     logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ e);
    try {
      sc.close();
    }
 catch (    IOException ignored) {
    }
  }
  return true;
}","private boolean readNextExcerpt(@NotNull SocketChannel sc){
  try {
    if (closed)     return false;
    if (readBuffer.remaining() < (scFirst ? TcpUtil.HEADER_SIZE : 4)) {
      if (readBuffer.remaining() == 0)       readBuffer.clear();
 else       readBuffer.compact();
      int minSize=scFirst ? 8 + 4 + 8 : 4 + 8;
      while (readBuffer.position() < minSize) {
        if (sc.read(readBuffer) < 0) {
          sc.close();
          return false;
        }
      }
      readBuffer.flip();
    }
    if (scFirst) {
      long scIndex=readBuffer.getLong();
      if (scIndex != chronicle.size())       scFirst=false;
    }
    int size=readBuffer.getInt();
switch (size) {
case VanillaChronicleSource.IN_SYNC_LEN:
      return false;
default :
    break;
}
if (size > 128 << 20 || size < 0) throw new StreamCorruptedException(""String_Node_Str"" + size);
excerpt.startExcerpt(size);
long remaining=size;
int limit=readBuffer.limit();
int size2=(int)Math.min(readBuffer.remaining(),remaining);
remaining-=size2;
readBuffer.limit(readBuffer.position() + size2);
excerpt.write(readBuffer);
readBuffer.limit(limit);
while (remaining > 0) {
  readBuffer.clear();
  int size3=(int)Math.min(readBuffer.capacity(),remaining);
  readBuffer.limit(size3);
  if (sc.read(readBuffer) < 0)   throw new EOFException();
  readBuffer.flip();
  remaining-=readBuffer.remaining();
  excerpt.write(readBuffer);
}
excerpt.finish();
}
 catch (IOException e) {
if (logger.isLoggable(Level.FINE)) logger.log(Level.FINE,""String_Node_Str"" + address + ""String_Node_Str"",e);
 else if (logger.isLoggable(Level.INFO)) logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ e);
try {
  sc.close();
}
 catch (IOException ignored) {
}
}
return true;
}"
52279,"@Override public void run(){
  try {
    long index=readIndex(socket);
    ExcerptTailer excerpt=chronicle.createTailer();
    ByteBuffer bb=TcpUtil.createBuffer(1,ByteOrder.nativeOrder());
    long sendInSync=0;
    boolean first=true;
    OUTER:     while (!closed) {
      while (!excerpt.nextIndex()) {
        long now=System.currentTimeMillis();
        if (excerpt.wasPadding()) {
          if (index >= 0) {
            bb.clear();
            if (first) {
              bb.putLong(excerpt.index());
              first=false;
            }
            bb.putInt(PADDED_LEN);
            bb.flip();
            TcpUtil.writeAll(socket,bb);
            sendInSync=now + HEARTBEAT_INTERVAL_MS;
          }
          index++;
          continue;
        }
        if (sendInSync <= now && !first) {
          bb.clear();
          bb.putInt(IN_SYNC_LEN);
          bb.flip();
          TcpUtil.writeAll(socket,bb);
          sendInSync=now + HEARTBEAT_INTERVAL_MS;
        }
        pause();
        if (closed)         break OUTER;
      }
      pauseReset();
      final long size=excerpt.capacity();
      long remaining;
      bb.clear();
      if (first) {
        bb.putLong(excerpt.index());
        first=false;
        remaining=size + TcpUtil.HEADER_SIZE;
      }
 else {
        remaining=size + 4;
      }
      bb.putInt((int)size);
      if (size > bb.capacity() / 2) {
        while (remaining > 0) {
          int size2=(int)Math.min(remaining,bb.capacity());
          bb.limit(size2);
          excerpt.read(bb);
          bb.flip();
          remaining-=bb.remaining();
          TcpUtil.writeAll(socket,bb);
        }
      }
 else {
        bb.limit((int)remaining);
        excerpt.read(bb);
        int count=1;
        while (count++ < MAX_MESSAGE) {
          if (excerpt.nextIndex()) {
            if (excerpt.wasPadding()) {
              index++;
              continue;
            }
            if (excerpt.remaining() + 4 >= bb.capacity() - bb.position())             break;
            int size2=(int)excerpt.capacity();
            bb.limit(bb.position() + size2 + 4);
            bb.putInt(size2);
            excerpt.read(bb);
            index++;
          }
        }
        bb.flip();
        TcpUtil.writeAll(socket,bb);
      }
      if (bb.remaining() > 0)       throw new EOFException(""String_Node_Str"" + index);
      index++;
      sendInSync=0;
    }
  }
 catch (  Exception e) {
    if (!closed) {
      String msg=e.getMessage();
      if (msg != null && (msg.contains(""String_Node_Str"") || msg.contains(""String_Node_Str"") || msg.contains(""String_Node_Str"")))       logger.log(Level.INFO,""String_Node_Str"" + socket + ""String_Node_Str""+ e);
 else       logger.log(Level.INFO,""String_Node_Str"" + socket + ""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    long index=readIndex(socket);
    ExcerptTailer excerpt=chronicle.createTailer();
    ByteBuffer bb=TcpUtil.createBuffer(1,ByteOrder.nativeOrder());
    long sendInSync=0;
    boolean first=true;
    OUTER:     while (!closed) {
      while (!excerpt.nextIndex()) {
        long now=System.currentTimeMillis();
        if (excerpt.wasPadding()) {
          if (index >= 0) {
            bb.clear();
            if (first) {
              bb.putLong(excerpt.index());
              first=false;
            }
            bb.putInt(PADDED_LEN);
            bb.flip();
            TcpUtil.writeAll(socket,bb);
            sendInSync=now + HEARTBEAT_INTERVAL_MS;
          }
          index++;
          continue;
        }
        pause();
        if (closed)         break OUTER;
      }
      pauseReset();
      final long size=excerpt.capacity();
      long remaining;
      bb.clear();
      if (first) {
        bb.putLong(excerpt.index());
        first=false;
        remaining=size + TcpUtil.HEADER_SIZE;
      }
 else {
        remaining=size + 4;
      }
      bb.putInt((int)size);
      if (size > bb.capacity() / 2) {
        while (remaining > 0) {
          int size2=(int)Math.min(remaining,bb.capacity());
          bb.limit(size2);
          excerpt.read(bb);
          bb.flip();
          remaining-=bb.remaining();
          TcpUtil.writeAll(socket,bb);
        }
      }
 else {
        bb.limit((int)remaining);
        excerpt.read(bb);
        int count=1;
        while (count++ < MAX_MESSAGE) {
          if (excerpt.nextIndex()) {
            if (excerpt.wasPadding()) {
              index++;
              continue;
            }
            if (excerpt.remaining() + 4 >= bb.capacity() - bb.position())             break;
            int size2=(int)excerpt.capacity();
            bb.limit(bb.position() + size2 + 4);
            bb.putInt(size2);
            excerpt.read(bb);
            index++;
          }
        }
        bb.flip();
        TcpUtil.writeAll(socket,bb);
      }
      if (bb.remaining() > 0)       throw new EOFException(""String_Node_Str"" + index);
      index++;
      sendInSync=0;
    }
  }
 catch (  Exception e) {
    if (!closed) {
      String msg=e.getMessage();
      if (msg != null && (msg.contains(""String_Node_Str"") || msg.contains(""String_Node_Str"") || msg.contains(""String_Node_Str"")))       logger.log(Level.INFO,""String_Node_Str"" + socket + ""String_Node_Str""+ e);
 else       logger.log(Level.INFO,""String_Node_Str"" + socket + ""String_Node_Str"",e);
    }
  }
}"
52280,"@Test public void testReplication() throws IOException {
  int RUNS=100;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str""),0);
  int localPort=chronicle.getLocalPort();
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str""),""String_Node_Str"",localPort);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      tailer.nextIndex();
      assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ tailer.remaining(),tailer.remaining() > 0);
      assertEquals(""String_Node_Str"" + i,value,tailer.parseLong());
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.clear();
  }
}","@Test public void testReplication() throws IOException {
  int RUNS=100;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str""),0);
  int localPort=chronicle.getLocalPort();
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str""),""String_Node_Str"",localPort);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      boolean nextIndex=tailer.nextIndex();
      long val=tailer.parseLong();
      System.out.println(val);
      assertEquals(""String_Node_Str"" + i,value,val);
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.close();
    chronicle2.clear();
    chronicle.clear();
  }
}"
52281,"@Test public void testReplicationWithRolling() throws Exception {
  int RUNS=500;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleConfig config=new VanillaChronicleConfig();
  config.cycleLength(1000);
  config.cycleFormat(""String_Node_Str"");
  config.entriesPerCycle(1L << 20);
  config.indexBlockSize(16L << 10);
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str"",config),0);
  int localPort=chronicle.getLocalPort();
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str"",config),""String_Node_Str"",localPort);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      Thread.sleep(10);
      tailer.nextIndex();
      assertEquals(""String_Node_Str"" + i,value,tailer.parseLong());
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.clear();
  }
}","@Test public void testReplicationWithRolling() throws Exception {
  int RUNS=500;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleConfig config=new VanillaChronicleConfig();
  config.cycleLength(1000);
  config.cycleFormat(""String_Node_Str"");
  config.entriesPerCycle(1L << 20);
  config.indexBlockSize(16L << 10);
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str"",config),0);
  int localPort=chronicle.getLocalPort();
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str"",config),""String_Node_Str"",localPort);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      Thread.sleep(10);
      tailer.nextIndex();
      assertEquals(""String_Node_Str"" + i,value,tailer.parseLong());
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.close();
    chronicle2.clear();
    chronicle.clear();
  }
}"
52282,"@Test public void testReplicationWithRolling2() throws Exception {
  int RUNS=100;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleConfig config=new VanillaChronicleConfig();
  config.cycleLength(1000);
  config.cycleFormat(""String_Node_Str"");
  config.entriesPerCycle(1L << 20);
  config.indexBlockSize(16L << 10);
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str"",config),55555);
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str"",config),""String_Node_Str"",55555);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      Thread.sleep(100);
      tailer.nextIndex();
      long val=tailer.parseLong();
      assertEquals(""String_Node_Str"" + i,value,val);
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.clear();
  }
}","@Test public void testReplicationWithRolling2() throws Exception {
  int RUNS=100;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  VanillaChronicleConfig config=new VanillaChronicleConfig();
  config.cycleLength(1000);
  config.cycleFormat(""String_Node_Str"");
  config.entriesPerCycle(1L << 20);
  config.indexBlockSize(16L << 10);
  VanillaChronicleSource chronicle=new VanillaChronicleSource(new VanillaChronicle(basePath + ""String_Node_Str"",config),55555);
  VanillaChronicleSink chronicle2=new VanillaChronicleSink(new VanillaChronicle(basePath + ""String_Node_Str"",config),""String_Node_Str"",55555);
  try {
    ExcerptAppender appender=chronicle.createAppender();
    ExcerptTailer tailer=chronicle2.createTailer();
    for (int i=0; i < RUNS; i++) {
      appender.startExcerpt();
      long value=1000000000 + i;
      appender.append(value).append(' ');
      appender.finish();
      Thread.sleep(100);
      tailer.nextIndex();
      long val=tailer.parseLong();
      assertEquals(""String_Node_Str"" + i,value,val);
      assertEquals(""String_Node_Str"" + i,0,tailer.remaining());
      tailer.finish();
    }
  }
  finally {
    chronicle2.close();
    chronicle.close();
    chronicle2.clear();
    chronicle.clear();
  }
}"
52283,"@Override public void report(@NotNull MetaData metaData,SmallReport smallReport){
  if (metaData.sourceId != gwId)   return;
  int count=reportCount.getAndIncrement();
  if (!throughputTest) {
    times[Math.abs(count)]=(metaData.inReadTimestamp - metaData.inWriteTimestamp);
  }
}","@Override public void report(@NotNull MetaData metaData,SmallReport smallReport){
  if (metaData.sourceId != gwId)   return;
  int count=reportCount.getAndIncrement();
  if (!throughputTest) {
    times[Math.abs(count)]=(metaData.outReadTimestamp - metaData.inWriteTimestamp);
  }
}"
52284,"public static void main(@NotNull String... args) throws IOException, InterruptedException {
  if (args.length < 2) {
    System.err.print(""String_Node_Str"" + GWMain.class.getName() + ""String_Node_Str"");
    System.exit(-1);
  }
  ChronicleTools.warmup();
  final int gwId=Integer.parseInt(args[0]);
  final boolean throughputTest=Boolean.parseBoolean(args[1]);
  String tmp=System.getProperty(""String_Node_Str"");
  String gw2pePath=tmp + ""String_Node_Str"" + gwId;
  String pePath=tmp + ""String_Node_Str"";
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  IndexedChronicle gw2pe=new IndexedChronicle(gw2pePath,config);
  Gw2PeEvents gw2PeWriter=new Gw2PeWriter(gw2pe.createAppender());
  IndexedChronicle pe2gw=new IndexedChronicle(pePath,config);
  final long[] times=new long[ORDERS];
  final AtomicInteger reportCount=new AtomicInteger(-WARMUP);
  Pe2GwEvents listener=new Pe2GwEvents(){
    @Override public void report(    @NotNull MetaData metaData,    SmallReport smallReport){
      if (metaData.sourceId != gwId)       return;
      int count=reportCount.getAndIncrement();
      if (!throughputTest) {
        times[Math.abs(count)]=(metaData.inReadTimestamp - metaData.inWriteTimestamp);
      }
    }
  }
;
  final Pe2GwReader pe2GwReader=new Pe2GwReader(gwId,pe2gw.createTailer(),listener);
  if (gwId > 1) {
    int startTime=(int)((System.currentTimeMillis() / 1000 - 5) % 10) + 5;
    System.out.println(""String_Node_Str"");
    for (int i=startTime; i > 0; i--) {
      System.out.print(i + ""String_Node_Str"");
      System.out.flush();
      Thread.sleep(1000);
    }
  }
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      AffinitySupport.setAffinity(1L << 3);
      while (reportCount.get() < ORDERS) {
        pe2GwReader.readOne();
      }
    }
  }
);
  t.start();
  Thread t2=new Thread(new Runnable(){
    @Override public void run(){
      int n=0;
      while (reportCount.get() < ORDERS) {
        while (reportCount.get() < n)         try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          throw new AssertionError(e);
        }
        int count=reportCount.get();
        System.out.println(""String_Node_Str"" + count);
        n+=1000000;
      }
    }
  }
);
  t2.start();
  AffinitySupport.setAffinity(1L << 1);
  SmallCommand command=new SmallCommand();
  @SuppressWarnings(""String_Node_Str"") StringBuilder clientOrderId=command.clientOrderId;
  System.out.println(""String_Node_Str"");
  long start=System.nanoTime();
  for (int i=0; i < ORDERS + WARMUP; i++) {
    if (i == WARMUP)     start=System.nanoTime();
    clientOrderId.setLength(0);
    clientOrderId.append(""String_Node_Str"");
    clientOrderId.append(gwId);
    clientOrderId.append('-');
    clientOrderId.append(i);
    command.instrument=""String_Node_Str"";
    command.price=1209.41;
    command.quantity=1000;
    command.side=(i & 1) == 0 ? Side.BUY : Side.SELL;
    if (!throughputTest) {
      long expectedTime=start + i * EVENT_SPACING - 30;
      while (System.nanoTime() < expectedTime) {
      }
    }
    gw2PeWriter.small(null,command);
  }
  System.out.println(""String_Node_Str"" + reportCount.get());
  t.join();
  long time=System.nanoTime() - start;
  Arrays.sort(times);
  System.out.printf(""String_Node_Str"",ORDERS,time / 1e9);
  if (!throughputTest) {
    System.out.printf(""String_Node_Str"",times[ORDERS / 2] / 1e3,times[ORDERS * 9 / 10] / 1e3,times[ORDERS - ORDERS / 100] / 1e3,times[ORDERS - ORDERS / 1000] / 1000,times[ORDERS - ORDERS / 10000] / 1000,times[ORDERS - 1] / 1000);
  }
  gw2pe.close();
  pe2gw.close();
}","public static void main(@NotNull String... args) throws IOException, InterruptedException {
  if (args.length < 2) {
    System.err.print(""String_Node_Str"" + GWMain.class.getName() + ""String_Node_Str"");
    System.exit(-1);
  }
  ChronicleTools.warmup();
  final int gwId=Integer.parseInt(args[0]);
  final boolean throughputTest=Boolean.parseBoolean(args[1]);
  String tmp=System.getProperty(""String_Node_Str"");
  String gw2pePath=tmp + ""String_Node_Str"" + gwId;
  String pePath=tmp + ""String_Node_Str"";
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  IndexedChronicle gw2pe=new IndexedChronicle(gw2pePath,config);
  Gw2PeEvents gw2PeWriter=new Gw2PeWriter(gw2pe.createAppender());
  IndexedChronicle pe2gw=new IndexedChronicle(pePath,config);
  final long[] times=new long[ORDERS];
  final AtomicInteger reportCount=new AtomicInteger(-WARMUP);
  Pe2GwEvents listener=new Pe2GwEvents(){
    @Override public void report(    @NotNull MetaData metaData,    SmallReport smallReport){
      if (metaData.sourceId != gwId)       return;
      int count=reportCount.getAndIncrement();
      if (!throughputTest) {
        times[Math.abs(count)]=(metaData.outReadTimestamp - metaData.inWriteTimestamp);
      }
    }
  }
;
  final Pe2GwReader pe2GwReader=new Pe2GwReader(gwId,pe2gw.createTailer(),listener);
  if (gwId > 1) {
    int startTime=(int)((System.currentTimeMillis() / 1000 - 5) % 10) + 5;
    System.out.println(""String_Node_Str"");
    for (int i=startTime; i > 0; i--) {
      System.out.print(i + ""String_Node_Str"");
      System.out.flush();
      Thread.sleep(1000);
    }
  }
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      AffinitySupport.setAffinity(1L << 3);
      while (reportCount.get() < ORDERS) {
        pe2GwReader.readOne();
      }
    }
  }
);
  t.start();
  Thread t2=new Thread(new Runnable(){
    @Override public void run(){
      int n=0;
      while (reportCount.get() < ORDERS) {
        while (reportCount.get() < n)         try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          throw new AssertionError(e);
        }
        int count=reportCount.get();
        System.out.println(""String_Node_Str"" + count);
        n+=1000000;
      }
    }
  }
);
  t2.start();
  AffinitySupport.setAffinity(1L << 1);
  SmallCommand command=new SmallCommand();
  @SuppressWarnings(""String_Node_Str"") StringBuilder clientOrderId=command.clientOrderId;
  System.out.println(""String_Node_Str"");
  long start=System.nanoTime();
  for (int i=0; i < ORDERS + WARMUP; i++) {
    if (i == WARMUP)     start=System.nanoTime();
    clientOrderId.setLength(0);
    clientOrderId.append(""String_Node_Str"");
    clientOrderId.append(gwId);
    clientOrderId.append('-');
    clientOrderId.append(i);
    command.instrument=""String_Node_Str"";
    command.price=1209.41;
    command.quantity=1000;
    command.side=(i & 1) == 0 ? Side.BUY : Side.SELL;
    if (!throughputTest) {
      long expectedTime=start + i * EVENT_SPACING - 30;
      while (System.nanoTime() < expectedTime) {
      }
    }
    gw2PeWriter.small(null,command);
  }
  System.out.println(""String_Node_Str"" + reportCount.get());
  t.join();
  long time=System.nanoTime() - start;
  Arrays.sort(times);
  System.out.printf(""String_Node_Str"",ORDERS,time / 1e9);
  if (!throughputTest) {
    System.out.printf(""String_Node_Str"",times[ORDERS / 2] / 1e3,times[ORDERS * 9 / 10] / 1e3,times[ORDERS - ORDERS / 100] / 1e3,times[ORDERS - ORDERS / 1000] / 1000,times[ORDERS - ORDERS / 10000] / 1000,times[ORDERS - 1] / 1000);
  }
  gw2pe.close();
  pe2gw.close();
}"
52285,"private long findTheLastIndex0(){
  long size=indexFileCache.size();
  if (size <= 0) {
    return -1;
  }
  int indexBlockSize=config.indexBlockSize();
  for (long block=size / indexBlockSize; block >= 0; block--) {
    MappedByteBuffer mbb=indexFileCache.acquireBuffer(block,false);
    if (block > 0 && mbb.getLong(0) == 0) {
      continue;
    }
    int cacheLineSize=config.cacheLineSize();
    for (int pos=0; pos < indexBlockSize; pos+=cacheLineSize) {
      if (mbb.getLong(pos + cacheLineSize) == 0) {
        int pos2=8;
        for (pos2=8; pos2 < cacheLineSize - 4; pos+=4) {
          if (mbb.getInt(pos + pos2) == 0)           break;
        }
        return (block * indexBlockSize + pos) / cacheLineSize * (cacheLineSize / 4 - 2) + pos / 4 - 1;
      }
    }
    return (block + 1) * indexBlockSize / cacheLineSize * (cacheLineSize / 4 - 2);
  }
  return -1;
}","private long findTheLastIndex0(){
  long size=indexFileCache.size();
  if (size <= 0) {
    return -1;
  }
  int indexBlockSize=config.indexBlockSize();
  for (long block=size / indexBlockSize; block >= 0; block--) {
    MappedByteBuffer mbb=indexFileCache.acquireBuffer(block,false);
    mbb.order(ByteOrder.nativeOrder());
    if (block > 0 && mbb.getLong(0) == 0) {
      continue;
    }
    int cacheLineSize=config.cacheLineSize();
    for (int pos=0; pos < indexBlockSize; pos+=cacheLineSize) {
      if (pos + cacheLineSize >= indexBlockSize || mbb.getLong(pos + cacheLineSize) == 0) {
        int pos2=8;
        for (pos2=8; pos2 < cacheLineSize; pos2+=4) {
          if (mbb.getInt(pos + pos2) == 0)           break;
        }
        return (block * indexBlockSize + pos) / cacheLineSize * (cacheLineSize / 4 - 2) + pos2 / 4 - 3;
      }
    }
    return (block + 1) * indexBlockSize / cacheLineSize * (cacheLineSize / 4 - 2);
  }
  return -1;
}"
52286,"public static void main(String... args) throws IOException {
  int zeros=0;
  FileChannel fc;
  try {
    fc=new FileInputStream(args[0]).getChannel();
  }
 catch (  FileNotFoundException e) {
    System.err.println(e);
    return;
  }
  ByteBuffer buffer=ByteBuffer.allocateDirect(4096).order(ByteOrder.nativeOrder());
  while (fc.read(buffer) > 0) {
    for (int i=0; i < buffer.capacity(); i+=4 * 16) {
      long indexStart=buffer.getLong(i);
      if (indexStart == 0 && zeros++ > 2) {
        continue;
      }
      System.out.print(HEX ? Long.toHexString(indexStart) : ""String_Node_Str"" + indexStart);
      for (int j=i + 8; j < i + 64; j+=4) {
        System.out.print(' ');
        int offset=buffer.getInt(j);
        System.out.print(HEX ? Integer.toHexString(offset) : ""String_Node_Str"" + offset);
      }
      System.out.println();
    }
    buffer.clear();
  }
  fc.close();
}","public static void main(String... args) throws IOException {
  int zeros=0;
  FileChannel fc;
  try {
    fc=new FileInputStream(args[0]).getChannel();
  }
 catch (  FileNotFoundException e) {
    System.err.println(e);
    return;
  }
  ByteBuffer buffer=ByteBuffer.allocateDirect(4096).order(ByteOrder.nativeOrder());
  while (fc.read(buffer) > 0) {
    for (int i=0; i < buffer.capacity(); i+=4 * 16) {
      long indexStart=buffer.getLong(i);
      if (indexStart == 0 && zeros++ > 2) {
        continue;
      }
      System.out.print(HEX ? Long.toHexString(indexStart) : String.valueOf(indexStart));
      for (int j=i + 8; j < i + 64; j+=4) {
        System.out.print(' ');
        int offset=buffer.getInt(j);
        System.out.print(HEX ? Integer.toHexString(offset) : String.valueOf(offset));
      }
      System.out.println();
    }
    buffer.clear();
  }
  fc.close();
}"
52287,"@Test @Ignore public void testAppending() throws IOException {
  int counter=0;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  ChronicleTools.deleteDirOnExit(basePath);
  for (int k=0; k < 15; k++) {
    RollingChronicle rc=new RollingChronicle(basePath,ChronicleConfig.TEST);
    ExcerptAppender appender=rc.createAppender();
    assertEquals(""String_Node_Str"" + k,(long)counter,appender.size());
    for (int i=0; i < 1; i++) {
      appender.startExcerpt(4);
      appender.writeInt(counter++);
      appender.finish();
      assertEquals(""String_Node_Str"" + k + ""String_Node_Str""+ i,(long)counter,appender.size());
    }
    appender.close();
    rc.close();
  }
  RollingChronicle rc=new RollingChronicle(basePath,ChronicleConfig.TEST);
  ExcerptTailer tailer=rc.createTailer();
  for (int i=0; i < counter; i++) {
    assertTrue(""String_Node_Str"" + i,tailer.nextIndex());
    assertEquals(i,tailer.readInt());
    tailer.finish();
  }
  rc.close();
}","@Test @Ignore public void testAppending() throws IOException {
  int counter=0;
  String basePath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  ChronicleTools.deleteDirOnExit(basePath);
  for (int k=0; k < 15; k++) {
    RollingChronicle rc=new RollingChronicle(basePath,ChronicleConfig.TEST);
    ExcerptAppender appender=rc.createAppender();
    assertEquals(""String_Node_Str"" + k,(long)counter,appender.size());
    for (int i=0; i < ChronicleConfig.TEST.indexFileExcerpts() * 2 / 7; i++) {
      appender.startExcerpt(4);
      appender.writeInt(counter++);
      appender.finish();
      assertEquals(""String_Node_Str"" + k + ""String_Node_Str""+ i,(long)counter,appender.size());
    }
    appender.close();
    rc.close();
  }
  RollingChronicle rc=new RollingChronicle(basePath,ChronicleConfig.TEST);
  ExcerptTailer tailer=rc.createTailer();
  for (int i=0; i < counter; i++) {
    assertTrue(""String_Node_Str"" + i,tailer.nextIndex());
    assertEquals(i,tailer.readInt());
    tailer.finish();
  }
  rc.close();
}"
52288,"protected boolean indexForRead(long l){
  if (l < 0) {
    padding=true;
    return false;
  }
  long indexLookup=l / indexEntriesPerBlock;
  indexBuffer=chronicle.indexFileCache.acquireBuffer(indexLookup,true);
  indexStartAddr=((DirectBuffer)indexBuffer).address();
  long indexLookupMod=l % indexEntriesPerBlock;
  int indexLineEntry=(int)(indexLookupMod % indexEntriesPerLine);
  int indexLineStart=(int)(indexLookupMod / indexEntriesPerLine * cacheLineSize);
  int inLine=(indexLineEntry << 2) + 8;
  int dataOffsetEnd=UNSAFE.getInt(indexStartAddr + indexLineStart + inLine);
  indexBaseForLine=UNSAFE.getLong(indexStartAddr + indexLineStart);
  indexPositionAddr=indexStartAddr + indexLineStart + inLine;
  long dataOffsetStart=inLine == 0 ? indexBaseForLine : (indexBaseForLine + Math.abs(UNSAFE.getInt(indexPositionAddr - 4)));
  long dataLookup=dataOffsetStart / dataBlockSize;
  long dataLookupMod=dataOffsetStart % dataBlockSize;
  MappedByteBuffer dataMBB=chronicle.dataFileCache.acquireBuffer(dataLookup,true);
  long dataAddr=((DirectBuffer)dataMBB).address();
  startAddr=positionAddr=dataAddr + dataLookupMod;
  index=l;
  if (dataOffsetEnd > 0) {
    limitAddr=dataAddr + (indexBaseForLine + dataOffsetEnd - dataLookup * dataBlockSize);
    indexPositionAddr+=4;
    padding=false;
    return true;
  }
 else   if (dataOffsetEnd == 0) {
    limitAddr=startAddr;
    padding=false;
    return false;
  }
 else {
    padding=true;
    return false;
  }
}","protected boolean indexForRead(long l){
  if (l < 0) {
    indexBuffer=chronicle.indexFileCache.acquireBuffer(0,true);
    indexStartAddr=((DirectBuffer)indexBuffer).address();
    indexPositionAddr=indexStartAddr;
    index=-1;
    padding=true;
    return false;
  }
  long indexLookup=l / indexEntriesPerBlock;
  indexBuffer=chronicle.indexFileCache.acquireBuffer(indexLookup,true);
  indexStartAddr=((DirectBuffer)indexBuffer).address();
  long indexLookupMod=l % indexEntriesPerBlock;
  int indexLineEntry=(int)(indexLookupMod % indexEntriesPerLine);
  int indexLineStart=(int)(indexLookupMod / indexEntriesPerLine * cacheLineSize);
  int inLine=(indexLineEntry << 2) + 8;
  int dataOffsetEnd=UNSAFE.getInt(indexStartAddr + indexLineStart + inLine);
  indexBaseForLine=UNSAFE.getLong(indexStartAddr + indexLineStart);
  indexPositionAddr=indexStartAddr + indexLineStart + inLine;
  long dataOffsetStart=inLine == 0 ? indexBaseForLine : (indexBaseForLine + Math.abs(UNSAFE.getInt(indexPositionAddr - 4)));
  long dataLookup=dataOffsetStart / dataBlockSize;
  long dataLookupMod=dataOffsetStart % dataBlockSize;
  MappedByteBuffer dataMBB=chronicle.dataFileCache.acquireBuffer(dataLookup,true);
  long dataAddr=((DirectBuffer)dataMBB).address();
  startAddr=positionAddr=dataAddr + dataLookupMod;
  index=l;
  if (dataOffsetEnd > 0) {
    limitAddr=dataAddr + (indexBaseForLine + dataOffsetEnd - dataLookup * dataBlockSize);
    indexPositionAddr+=4;
    padding=false;
    return true;
  }
 else   if (dataOffsetEnd == 0) {
    limitAddr=startAddr;
    padding=false;
    return false;
  }
 else {
    padding=true;
    return false;
  }
}"
52289,"@Test public void testWasPadding() throws IOException {
  final String basePath=TMP + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(basePath);
  ChronicleConfig config=ChronicleConfig.TEST.clone();
  config.dataBlockSize(128);
  config.indexBlockSize(128);
  IndexedChronicle chronicle1=new IndexedChronicle(basePath,config);
  ExcerptAppender appender=chronicle1.createAppender();
  IndexedChronicle chronicle2=new IndexedChronicle(basePath,config);
  ExcerptTailer tailer=chronicle2.createTailer();
  assertEquals(-1,tailer.index());
  assertTrue(tailer.wasPadding());
  assertFalse(tailer.index(-1));
  assertTrue(tailer.wasPadding());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertTrue(tailer.index(0));
  assertFalse(tailer.wasPadding());
  assertFalse(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertFalse(tailer.index(1));
  assertFalse(tailer.wasPadding());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(1));
  assertFalse(tailer.wasPadding());
  assertEquals(1,tailer.index());
  assertFalse(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(1,tailer.index());
  assertFalse(tailer.index(2));
  assertFalse(tailer.wasPadding());
  assertEquals(2,tailer.index());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertFalse(tailer.index(2));
  assertTrue(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(1));
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(3,tailer.index());
  assertFalse(tailer.index(2));
  assertTrue(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(3));
  assertFalse(tailer.wasPadding());
  assertEquals(3,tailer.index());
  assertFalse(tailer.index(4));
  assertFalse(tailer.wasPadding());
  assertEquals(4,tailer.index());
  chronicle1.close();
  chronicle2.close();
}","@Test public void testWasPadding() throws IOException {
  final String basePath=TMP + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(basePath);
  ChronicleConfig config=ChronicleConfig.TEST.clone();
  config.dataBlockSize(128);
  config.indexBlockSize(128);
  IndexedChronicle chronicle1=new IndexedChronicle(basePath,config);
  ExcerptAppender appender=chronicle1.createAppender();
  IndexedChronicle chronicle2=new IndexedChronicle(basePath,config);
  ExcerptTailer tailer=chronicle2.createTailer();
  assertEquals(-1,tailer.index());
  assertTrue(tailer.wasPadding());
  assertFalse(tailer.index(-1));
  assertTrue(tailer.wasPadding());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertTrue(tailer.index(0));
  assertFalse(tailer.wasPadding());
  assertFalse(tailer.index(-1));
  assertEquals(-1,tailer.index());
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertFalse(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(0,tailer.index());
  assertFalse(tailer.index(1));
  assertFalse(tailer.wasPadding());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(1));
  assertFalse(tailer.wasPadding());
  assertEquals(1,tailer.index());
  assertFalse(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(1,tailer.index());
  assertFalse(tailer.index(2));
  assertFalse(tailer.wasPadding());
  assertEquals(2,tailer.index());
  appender.startExcerpt(48);
  appender.position(48);
  appender.finish();
  assertFalse(tailer.index(2));
  assertTrue(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(1));
  assertTrue(tailer.nextIndex());
  assertFalse(tailer.wasPadding());
  assertEquals(3,tailer.index());
  assertFalse(tailer.index(2));
  assertTrue(tailer.wasPadding());
  assertEquals(2,tailer.index());
  assertTrue(tailer.index(3));
  assertFalse(tailer.wasPadding());
  assertEquals(3,tailer.index());
  assertFalse(tailer.index(4));
  assertFalse(tailer.wasPadding());
  assertEquals(4,tailer.index());
  chronicle1.close();
  chronicle2.close();
}"
52290,"public static void main(String... ignored) throws IOException {
  ChronicleTools.warmup();
  if (GWMain.WITH_BINDING)   PosixJNAAffinity.INSTANCE.setAffinity(1L << 5);
  String tmp=System.getProperty(""String_Node_Str"");
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  String pePath=tmp + ""String_Node_Str"";
  IndexedChronicle pe2gw=new IndexedChronicle(pePath,config);
  ExcerptAppender excerpt=pe2gw.createAppender();
  final Pe2GwWriter pe2GwWriter=new Pe2GwWriter(excerpt);
  Gw2PeEvents listener=new PEEvents(pe2GwWriter);
  Gw2PeReader[] readers=new Gw2PeReader[1];
  IndexedChronicle[] gw2pe=new IndexedChronicle[readers.length];
  for (int i=0; i < readers.length; i++) {
    int sourceId=i + 1;
    String gw2pePath=tmp + ""String_Node_Str"" + sourceId;
    gw2pe[i]=new IndexedChronicle(gw2pePath,config);
    readers[i]=new Gw2PeReader(sourceId,gw2pe[i].createTailer(),listener);
  }
  long prevProcessed=0, count=0;
  do {
    boolean readOne=false;
    for (    Gw2PeReader reader : readers) {
      readOne|=reader.readOne();
    }
    if (readOne) {
      count=0;
    }
 else     if (count++ > 1000000) {
      long processed=excerpt.index() + 1;
      if (prevProcessed != processed) {
        System.out.printf(""String_Node_Str"",processed);
        prevProcessed=processed;
      }
    }
  }
 while (true);
}","public static void main(String... ignored) throws IOException {
  ChronicleTools.warmup();
  if (GWMain.WITH_BINDING)   PosixJNAAffinity.INSTANCE.setAffinity(1L << 5);
  String tmp=System.getProperty(""String_Node_Str"");
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  String pePath=tmp + ""String_Node_Str"";
  ChronicleTools.deleteDirOnExit(pePath);
  IndexedChronicle pe2gw=new IndexedChronicle(pePath,config);
  ExcerptAppender excerpt=pe2gw.createAppender();
  final Pe2GwWriter pe2GwWriter=new Pe2GwWriter(excerpt);
  Gw2PeEvents listener=new PEEvents(pe2GwWriter);
  Gw2PeReader[] readers=new Gw2PeReader[1];
  IndexedChronicle[] gw2pe=new IndexedChronicle[readers.length];
  for (int i=0; i < readers.length; i++) {
    int sourceId=i + 1;
    String gw2pePath=tmp + ""String_Node_Str"" + sourceId;
    ChronicleTools.deleteDirOnExit(gw2pePath);
    gw2pe[i]=new IndexedChronicle(gw2pePath,config);
    readers[i]=new Gw2PeReader(sourceId,gw2pe[i].createTailer(),listener);
  }
  long prevProcessed=0, count=0;
  do {
    boolean readOne=false;
    for (    Gw2PeReader reader : readers) {
      readOne|=reader.readOne();
    }
    if (readOne) {
      count=0;
    }
 else     if (count++ > 1000000) {
      long processed=excerpt.index() + 1;
      if (prevProcessed != processed) {
        System.out.printf(""String_Node_Str"",processed);
        prevProcessed=processed;
      }
    }
  }
 while (true);
}"
52291,"@Override public void addPaddedEntry(){
  if (index != lastWrittenIndex()) {
    toEnd();
  }
  checkNewIndexLine();
  writePaddedEntry();
  loadNextDataBuffer();
  checkNewIndexLine();
  finished=true;
}","@Override public void addPaddedEntry(){
  if (index != lastWrittenIndex()) {
    toEnd();
  }
  if (index == 322)   Thread.yield();
  checkNewIndexLine();
  writePaddedEntry();
  loadNextDataBuffer();
  checkNewIndexLine();
  finished=true;
}"
52292,"void checkNewIndexLine2(){
  if ((indexPositionAddr & cacheLineMask) == 8) {
    indexBaseForLine=UNSAFE.getLongVolatile(null,indexPositionAddr - 8);
    setLmitAddr(0);
  }
}","void checkNewIndexLine2(){
}"
52293,"public boolean nextIndex(){
  return nextIndex0() || nextIndex0();
}","public boolean nextIndex(){
  checkNextLine();
  long offset=UNSAFE.getInt(null,indexPositionAddr);
  if (offset == 0)   offset=UNSAFE.getIntVolatile(null,indexPositionAddr);
  if (offset == 0) {
    return false;
  }
  index++;
  return nextIndex0(offset) || nextIndex1();
}"
52294,"private boolean readNextExcerpt(@NotNull SocketChannel sc){
  try {
    if (closed)     return false;
    if (readBuffer.remaining() < (scFirst ? TcpUtil.HEADER_SIZE : 4)) {
      if (readBuffer.remaining() == 0)       readBuffer.clear();
 else       readBuffer.compact();
      int minSize=scFirst ? 8 + 4 + 8 : 4 + 8;
      while (readBuffer.position() < minSize) {
        if (sc.read(readBuffer) < 0) {
          sc.close();
          return false;
        }
      }
      readBuffer.flip();
    }
    if (scFirst) {
      long scIndex=readBuffer.getLong();
      if (scIndex != chronicle.size())       throw new StreamCorruptedException(""String_Node_Str"" + chronicle.size() + ""String_Node_Str""+ scIndex);
      scFirst=false;
    }
    int size=readBuffer.getInt();
switch (size) {
case InProcessChronicleSource.IN_SYNC_LEN:
      return false;
case InProcessChronicleSource.PADDED_LEN:
    excerpt.addPaddedEntry();
  return true;
default :
break;
}
if (size > 128 << 20 || size < 0) throw new StreamCorruptedException(""String_Node_Str"" + size);
excerpt.startExcerpt(size);
long remaining=size;
int limit=readBuffer.limit();
int size2=(int)Math.min(readBuffer.remaining(),remaining);
remaining-=size2;
readBuffer.limit(readBuffer.position() + size2);
excerpt.write(readBuffer);
readBuffer.limit(limit);
while (remaining > 0) {
readBuffer.clear();
int size3=(int)Math.min(readBuffer.capacity(),remaining);
readBuffer.limit(size3);
if (sc.read(readBuffer) < 0) throw new EOFException();
readBuffer.flip();
remaining-=readBuffer.remaining();
excerpt.write(readBuffer);
}
excerpt.finish();
}
 catch (IOException e) {
if (logger.isLoggable(Level.FINE)) logger.log(Level.FINE,""String_Node_Str"" + address + ""String_Node_Str"",e);
 else if (logger.isLoggable(Level.INFO)) logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ e);
try {
sc.close();
}
 catch (IOException ignored) {
}
}
return true;
}","private boolean readNextExcerpt(@NotNull SocketChannel sc){
  try {
    if (closed)     return false;
    if (readBuffer.remaining() < (scFirst ? TcpUtil.HEADER_SIZE : 4)) {
      if (readBuffer.remaining() == 0)       readBuffer.clear();
 else       readBuffer.compact();
      int minSize=scFirst ? 8 + 4 + 8 : 4 + 8;
      while (readBuffer.position() < minSize) {
        if (sc.read(readBuffer) < 0) {
          sc.close();
          return false;
        }
      }
      readBuffer.flip();
    }
    if (scFirst) {
      long scIndex=readBuffer.getLong();
      if (scIndex != chronicle.size())       throw new StreamCorruptedException(""String_Node_Str"" + chronicle.size() + ""String_Node_Str""+ scIndex);
      scFirst=false;
    }
    int size=readBuffer.getInt();
switch (size) {
case InProcessChronicleSource.IN_SYNC_LEN:
      return false;
case InProcessChronicleSource.PADDED_LEN:
    excerpt.startExcerpt(chronicle.config().dataBlockSize() - 1);
  return true;
default :
break;
}
if (size > 128 << 20 || size < 0) throw new StreamCorruptedException(""String_Node_Str"" + size);
excerpt.startExcerpt(size);
long remaining=size;
int limit=readBuffer.limit();
int size2=(int)Math.min(readBuffer.remaining(),remaining);
remaining-=size2;
readBuffer.limit(readBuffer.position() + size2);
excerpt.write(readBuffer);
readBuffer.limit(limit);
while (remaining > 0) {
readBuffer.clear();
int size3=(int)Math.min(readBuffer.capacity(),remaining);
readBuffer.limit(size3);
if (sc.read(readBuffer) < 0) throw new EOFException();
readBuffer.flip();
remaining-=readBuffer.remaining();
excerpt.write(readBuffer);
}
excerpt.finish();
}
 catch (IOException e) {
if (logger.isLoggable(Level.FINE)) logger.log(Level.FINE,""String_Node_Str"" + address + ""String_Node_Str"",e);
 else if (logger.isLoggable(Level.INFO)) logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ e);
try {
sc.close();
}
 catch (IOException ignored) {
}
}
return true;
}"
52295,"@Test @Ignore public void testOverTCP() throws IOException, InterruptedException {
  String baseDir=System.getProperty(""String_Node_Str"");
  String srcBasePath=baseDir + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(srcBasePath);
  final int messages=2000;
  ChronicleConfig config=ChronicleConfig.TEST.clone();
  final Chronicle source=new InProcessChronicleSource(new IndexedChronicle(srcBasePath,config),PORT + 1);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        ExcerptAppender excerpt=source.createAppender();
        for (int i=1; i <= messages; i++) {
          excerpt.startExcerpt(19);
          excerpt.writeLong(i);
          excerpt.append(' ');
          excerpt.append(i);
          excerpt.append('\n');
          excerpt.finish();
        }
        System.out.println(System.currentTimeMillis() + ""String_Node_Str"");
      }
 catch (      Exception e) {
        throw new AssertionError(e);
      }
    }
  }
);
  String snkBasePath=baseDir + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(snkBasePath);
  Chronicle sink=new InProcessChronicleSink(new IndexedChronicle(snkBasePath),""String_Node_Str"",PORT + 1);
  long start=System.nanoTime();
  t.start();
  ExcerptTailer excerpt=sink.createTailer();
  int count=0;
  for (int i=1; i <= messages; i++) {
    while (!excerpt.nextIndex())     count++;
    long n=excerpt.readLong();
    String text=excerpt.parseUTF(StopCharTesters.CONTROL_STOP);
    if (i != n)     assertEquals('\'' + text + '\'',i,n);
    excerpt.finish();
  }
  sink.close();
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
  t.join();
  source.close();
  long time=System.nanoTime() - start;
  System.out.printf(""String_Node_Str"",(int)(messages * 1e9 / time));
}","@Test public void testOverTCP() throws IOException, InterruptedException {
  String baseDir=System.getProperty(""String_Node_Str"");
  String srcBasePath=baseDir + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(srcBasePath);
  final int messages=2 * 1000 * 1000;
  ChronicleConfig config=ChronicleConfig.DEFAULT.clone();
  final Chronicle source=new InProcessChronicleSource(new IndexedChronicle(srcBasePath,config),PORT + 1);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        ExcerptAppender excerpt=source.createAppender();
        for (int i=1; i <= messages; i++) {
          excerpt.startExcerpt(19);
          excerpt.writeLong(i);
          excerpt.append(' ');
          excerpt.append(i);
          excerpt.append('\n');
          excerpt.finish();
        }
        System.out.println(System.currentTimeMillis() + ""String_Node_Str"");
      }
 catch (      Exception e) {
        throw new AssertionError(e);
      }
    }
  }
);
  String snkBasePath=baseDir + ""String_Node_Str"";
  ChronicleTools.deleteOnExit(snkBasePath);
  Chronicle sink=new InProcessChronicleSink(new IndexedChronicle(snkBasePath,config),""String_Node_Str"",PORT + 1);
  long start=System.nanoTime();
  t.start();
  ExcerptTailer excerpt=sink.createTailer();
  int count=0;
  for (int i=1; i <= messages; i++) {
    while (!excerpt.nextIndex())     count++;
    long n=excerpt.readLong();
    String text=excerpt.parseUTF(StopCharTesters.CONTROL_STOP);
    if (i != n)     assertEquals('\'' + text + '\'',i,n);
    excerpt.finish();
  }
  sink.close();
  System.out.println(""String_Node_Str"" + count + ""String_Node_Str"");
  t.join();
  source.close();
  long time=System.nanoTime() - start;
  System.out.printf(""String_Node_Str"",(int)(messages * 1e9 / time));
}"
52296,"/** 
 * Create a SimpleConnection object from a GuacamoleConfiguration, obtain an identifier, and place it on the tree, returning the identifier value of the new connection.
 * @param config The GuacamoleConfiguration to use to create the SimpleConnection object.
 * @return The identifier of the connection created in the directory.
 * @throws GuacamoleException If an error occurs adding the object to the tree.
 */
public String create(GuacamoleConfiguration config) throws GuacamoleException {
  String connectionId=Integer.toString(getNextConnectionID());
  String name=QCParser.getName(config);
  Connection connection=new SimpleConnection(name,connectionId,config);
  connection.setParentIdentifier(ROOT_IDENTIFIER);
  add(connection);
  this.rootGroup.addConnectionIdentifier(connectionId);
  return connectionId;
}","/** 
 * Create a SimpleConnection object from a GuacamoleConfiguration, obtain an identifier, and place it on the tree, returning the identifier value of the new connection.
 * @param config The GuacamoleConfiguration to use to create the SimpleConnection object.
 * @return The identifier of the connection created in the directory.
 * @throws GuacamoleException If an error occurs adding the object to the tree.
 */
public String create(GuacamoleConfiguration config) throws GuacamoleException {
  String connectionId=Integer.toString(getNextConnectionID());
  String name=QCParser.getName(config);
  Connection connection=new SimpleConnection(name,connectionId,config);
  connection.setParentIdentifier(QuickConnectUserContext.ROOT_IDENTIFIER);
  add(connection);
  this.rootGroup.addConnectionIdentifier(connectionId);
  return connectionId;
}"
52297,"/** 
 * Construct a QuickConnectUserContext using the authProvider and the username.
 * @param authProvider The authentication provider module instantiating this this class.
 * @param username The name of the user logging in and using this class.
 */
public QuickConnectUserContext(AuthenticationProvider authProvider,String username){
  this.rootGroup=new QuickConnectionGroup(DEFAULT_ROOT_CONNECTION_GROUP,DEFAULT_ROOT_CONNECTION_GROUP);
  this.self=new SimpleUser(username,Collections.<String>emptyList(),Collections.singleton(DEFAULT_ROOT_CONNECTION_GROUP));
  this.connectionDirectory=new QuickConnectDirectory(this.rootGroup);
  this.authProvider=authProvider;
}","/** 
 * Construct a QuickConnectUserContext using the authProvider and the username.
 * @param authProvider The authentication provider module instantiating this this class.
 * @param username The name of the user logging in and using this class.
 */
public QuickConnectUserContext(AuthenticationProvider authProvider,String username) throws GuacamoleException {
  this.rootGroup=new QuickConnectionGroup(ROOT_IDENTIFIER,ROOT_IDENTIFIER);
  this.connectionDirectory=new QuickConnectDirectory(this.rootGroup);
  this.self=new SimpleUser(username,connectionDirectory.getIdentifiers(),Collections.singleton(ROOT_IDENTIFIER));
  this.authProvider=authProvider;
}"
52298,"@Override public UserContext getUserContext(AuthenticatedUser authenticatedUser) throws GuacamoleException {
  logger.debug(""String_Node_Str"",authenticatedUser.getCredentials().getUsername());
  return userContext;
}","@Override public UserContext getUserContext(AuthenticatedUser authenticatedUser) throws GuacamoleException {
  logger.debug(""String_Node_Str"",authenticatedUser.getCredentials().getUsername());
  return new QuickConnectUserContext(this,authenticatedUser.getIdentifier());
}"
52299,"/** 
 * For QuickConnect, authenticateUser simply returns null because this extension is designed to provide only a connection directory to users that are already authenticated and not any actual authentication.
 * @param credentials Credentials object passed in from Guacamole login.
 * @returns Returns null, which causes the client to move on to the next module.
 */
@Override public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
  logger.debug(""String_Node_Str"");
  GuacamoleConfiguration config=new GuacamoleConfiguration();
  config.setProtocol(""String_Node_Str"");
  config.setParameter(""String_Node_Str"",""String_Node_Str"");
  config.setParameter(""String_Node_Str"",""String_Node_Str"");
  quickConnections.put(""String_Node_Str"",config);
  if (userContext == null)   userContext=new QuickConnectUserContext(this,credentials.getUsername(),quickConnections);
  return null;
}","/** 
 * For QuickConnect, authenticateUser simply returns null because this extension is designed to provide only a connection directory to users that are already authenticated and not any actual authentication.
 * @param credentials Credentials object passed in from Guacamole login.
 * @returns Returns null, which causes the client to move on to the next module.
 */
@Override public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
  logger.debug(""String_Node_Str"",credentials.getUsername());
  String username=credentials.getUsername();
  if (username == null || username.isEmpty())   throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
  userContext=new QuickConnectUserContext(this,credentials.getUsername());
  return null;
}"
52300,"@Override public Map<String,GuacamoleConfiguration> getAuthorizedConfigurations(Credentials credentials) throws GuacamoleException {
  logger.debug(""String_Node_Str"",credentials.getUsername());
  GuacamoleConfiguration config=new GuacamoleConfiguration();
  config.setProtocol(""String_Node_Str"");
  config.setParameter(""String_Node_Str"",""String_Node_Str"");
  config.setParameter(""String_Node_Str"",""String_Node_Str"");
  quickConnections.put(""String_Node_Str"",config);
  if (userContext == null)   userContext=new QuickConnectUserContext(this,credentials.getUsername(),quickConnections);
  return quickConnections;
}","@Override public Map<String,GuacamoleConfiguration> getAuthorizedConfigurations(Credentials credentials) throws GuacamoleException {
  logger.debug(""String_Node_Str"",credentials.getUsername());
  if (userContext == null)   userContext=new QuickConnectUserContext(this,credentials.getUsername());
  return Collections.<String,GuacamoleConfiguration>emptyMap();
}"
52301,"@Override public Directory<User> getUserDirectory() throws GuacamoleException {
  return userDirectory;
}","@Override public Directory<User> getUserDirectory() throws GuacamoleException {
  logger.debug(""String_Node_Str"",userDirectory.getIdentifiers());
  return userDirectory;
}"
52302,"/** 
 * Creates a new instance of RadiusAuthentictor, configured with parameters specified within guacamole.properties.
 * @return A new RadiusAuthenticator instance which has been configured with parameters from guacamole.properties, or null if configuration fails.
 */
private RadiusAuthenticator setupRadiusAuthenticator(RadiusClient radiusClient) throws GuacamoleException {
  if (radiusClient == null) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"");
    return null;
  }
  RadiusAuthenticator radAuth=radiusClient.getAuthProtocol(confService.getRadiusAuthProtocol());
  if (radAuth == null)   throw new GuacamoleException(""String_Node_Str"" + confService.getRadiusAuthProtocol());
  if (radAuth instanceof PEAPAuthenticator || radAuth instanceof EAPTLSAuthenticator || radAuth instanceof EAPTTLSAuthenticator) {
    LocalEnvironment guacEnv=new LocalEnvironment();
    String guacHome=guacEnv.getGuacamoleHome();
    String caFile=confService.getRadiusCAFile();
    String caPassword=confService.getRadiusCAPassword();
    String keyFile=confService.getRadiusKeyFile();
    String keyPassword=confService.getRadiusKeyPassword();
    String innerProtocol=confService.getRadiusEAPTTLSInnerProtocol();
    if (caFile != null) {
      ((EAPTLSAuthenticator)radAuth).setCaFile((new File(guacHome,caFile)).toString());
      ((EAPTLSAuthenticator)radAuth).setCaFileType(confService.getRadiusCAType());
      if (caPassword != null)       ((EAPTLSAuthenticator)radAuth).setCaPassword(caPassword);
    }
    if (keyPassword != null)     ((EAPTLSAuthenticator)radAuth).setKeyPassword(keyPassword);
    ((EAPTLSAuthenticator)radAuth).setKeyFile((new File(guacHome,keyFile)).toString());
    ((EAPTLSAuthenticator)radAuth).setKeyFileType(confService.getRadiusKeyType());
    ((EAPTLSAuthenticator)radAuth).setTrustAll(confService.getRadiusTrustAll());
  }
  if (radAuth instanceof EAPTTLSAuthenticator) {
    if (innerProtocol == null)     throw new GuacamoleException(""String_Node_Str"");
    ((EAPTTLSAuthenticator)radAuth).setInnerProtocol(innerProtocol);
  }
  return radAuth;
}","/** 
 * Creates a new instance of RadiusAuthentictor, configured with parameters specified within guacamole.properties.
 * @return A new RadiusAuthenticator instance which has been configured with parameters from guacamole.properties, or null if configuration fails.
 */
private RadiusAuthenticator setupRadiusAuthenticator(RadiusClient radiusClient) throws GuacamoleException {
  if (radiusClient == null) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"");
    return null;
  }
  RadiusAuthenticator radAuth=radiusClient.getAuthProtocol(confService.getRadiusAuthProtocol());
  if (radAuth == null)   throw new GuacamoleException(""String_Node_Str"" + confService.getRadiusAuthProtocol());
  if (radAuth instanceof PEAPAuthenticator || radAuth instanceof EAPTLSAuthenticator || radAuth instanceof EAPTTLSAuthenticator) {
    LocalEnvironment guacEnv=new LocalEnvironment();
    File guacHome=guacEnv.getGuacamoleHome();
    String caFile=confService.getRadiusCAFile();
    String caPassword=confService.getRadiusCAPassword();
    String keyFile=confService.getRadiusKeyFile();
    String keyPassword=confService.getRadiusKeyPassword();
    if (caFile != null) {
      ((EAPTLSAuthenticator)radAuth).setCaFile((new File(guacHome,caFile)).toString());
      ((EAPTLSAuthenticator)radAuth).setCaFileType(confService.getRadiusCAType());
      if (caPassword != null)       ((EAPTLSAuthenticator)radAuth).setCaPassword(caPassword);
    }
    if (keyPassword != null)     ((EAPTLSAuthenticator)radAuth).setKeyPassword(keyPassword);
    ((EAPTLSAuthenticator)radAuth).setKeyFile((new File(guacHome,keyFile)).toString());
    ((EAPTLSAuthenticator)radAuth).setKeyFileType(confService.getRadiusKeyType());
    ((EAPTLSAuthenticator)radAuth).setTrustAll(confService.getRadiusTrustAll());
  }
  if (radAuth instanceof EAPTTLSAuthenticator) {
    String innerProtocol=confService.getRadiusEAPTTLSInnerProtocol();
    if (innerProtocol == null)     throw new GuacamoleException(""String_Node_Str"");
    ((EAPTTLSAuthenticator)radAuth).setInnerProtocol(innerProtocol);
  }
  return radAuth;
}"
52303,"/** 
 * Returns an AuthenticatedUser representing the user authenticated by the given credentials.
 * @param credentials The credentials to use for authentication.
 * @return An AuthenticatedUser representing the user authenticated by the given credentials.
 * @throws GuacamoleException If an error occurs while authenticating the user, or if access is denied.
 */
public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
  HttpServletRequest request=credentials.getRequest();
  RadiusPacket radPack;
  if (credentials.getUsername() == null || credentials.getUsername().isEmpty())   return null;
  if (credentials.getPassword() == null || credentials.getPassword().isEmpty())   return null;
  String challengeResponse=request.getParameter(RadiusChallengeResponseField.PARAMETER_NAME);
  if (challengeResponse == null) {
    try {
      radPack=radiusService.authenticate(credentials.getUsername(),credentials.getPassword());
    }
 catch (    GuacamoleException e) {
      logger.error(""String_Node_Str"",e.getMessage());
      logger.debug(""String_Node_Str"",e);
      radPack=null;
    }
    if (radPack == null) {
      logger.debug(""String_Node_Str"");
      throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
    }
 else     if (radPack instanceof AccessReject) {
      logger.debug(""String_Node_Str"");
      throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
    }
 else     if (radPack instanceof AccessChallenge) {
      RadiusAttribute stateAttr=radPack.findAttribute(Attr_State.TYPE);
      if (stateAttr == null) {
        logger.error(""String_Node_Str"");
        logger.debug(""String_Node_Str"");
        throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
      }
      RadiusAttribute replyAttr=radPack.findAttribute(Attr_ReplyMessage.TYPE);
      if (replyAttr == null) {
        logger.error(""String_Node_Str"");
        logger.debug(""String_Node_Str"");
        throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
      }
      String replyMsg=replyAttr.toString();
      String radiusState=new String(stateAttr.getValue().getBytes());
      Field radiusResponseField=new RadiusChallengeResponseField(replyMsg);
      Field radiusStateField=new RadiusStateField(radiusState);
      CredentialsInfo expectedCredentials=new CredentialsInfo(Arrays.asList(radiusResponseField,radiusStateField));
      throw new GuacamoleInsufficientCredentialsException(""String_Node_Str"",expectedCredentials);
    }
 else     if (radPack instanceof AccessAccept) {
      try {
        AuthenticatedUser authenticatedUser=authenticatedUserProvider.get();
        authenticatedUser.init(credentials);
        return authenticatedUser;
      }
  finally {
        radiusService.disconnect();
      }
    }
 else     throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
  }
 else {
    try {
      radPack=radiusService.authenticate(credentials.getUsername(),request.getParameter(RadiusStateField.PARAMETER_NAME),challengeResponse);
    }
 catch (    GuacamoleException e) {
      logger.error(""String_Node_Str"",e.getMessage());
      logger.debug(""String_Node_Str"",e);
      radPack=null;
    }
 finally {
      radiusService.disconnect();
    }
    if (radPack instanceof AccessAccept) {
      AuthenticatedUser authenticatedUser=authenticatedUserProvider.get();
      authenticatedUser.init(credentials);
      return authenticatedUser;
    }
 else {
      logger.warn(""String_Node_Str"");
      logger.debug(""String_Node_Str"");
      throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
    }
  }
}","/** 
 * Returns an AuthenticatedUser representing the user authenticated by the given credentials.
 * @param credentials The credentials to use for authentication.
 * @return An AuthenticatedUser representing the user authenticated by the given credentials.
 * @throws GuacamoleException If an error occurs while authenticating the user, or if access is denied.
 */
public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
  HttpServletRequest request=credentials.getRequest();
  RadiusPacket radPack;
  if (credentials.getUsername() == null || credentials.getUsername().isEmpty())   return null;
  if (credentials.getPassword() == null || credentials.getPassword().isEmpty())   return null;
  String challengeResponse=request.getParameter(RadiusChallengeResponseField.PARAMETER_NAME);
  if (challengeResponse == null) {
    try {
      radPack=radiusService.authenticate(credentials.getUsername(),credentials.getPassword());
    }
 catch (    GuacamoleException e) {
      logger.error(""String_Node_Str"",e.getMessage());
      logger.debug(""String_Node_Str"",e);
      throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
    }
    if (radPack == null) {
      logger.debug(""String_Node_Str"");
      throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
    }
 else     if (radPack instanceof AccessReject) {
      logger.debug(""String_Node_Str"");
      throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
    }
 else     if (radPack instanceof AccessChallenge) {
      RadiusAttribute stateAttr=radPack.findAttribute(Attr_State.TYPE);
      if (stateAttr == null) {
        logger.error(""String_Node_Str"");
        logger.debug(""String_Node_Str"");
        throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
      }
      RadiusAttribute replyAttr=radPack.findAttribute(Attr_ReplyMessage.TYPE);
      if (replyAttr == null) {
        logger.error(""String_Node_Str"");
        logger.debug(""String_Node_Str"");
        throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
      }
      String replyMsg=replyAttr.toString();
      String radiusState=new String(stateAttr.getValue().getBytes());
      Field radiusResponseField=new RadiusChallengeResponseField(replyMsg);
      Field radiusStateField=new RadiusStateField(radiusState);
      CredentialsInfo expectedCredentials=new CredentialsInfo(Arrays.asList(radiusResponseField,radiusStateField));
      throw new GuacamoleInsufficientCredentialsException(""String_Node_Str"",expectedCredentials);
    }
 else     if (radPack instanceof AccessAccept) {
      try {
        AuthenticatedUser authenticatedUser=authenticatedUserProvider.get();
        authenticatedUser.init(credentials);
        return authenticatedUser;
      }
  finally {
        radiusService.disconnect();
      }
    }
 else     throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
  }
 else {
    try {
      radPack=radiusService.authenticate(credentials.getUsername(),request.getParameter(RadiusStateField.PARAMETER_NAME),challengeResponse);
    }
 catch (    GuacamoleException e) {
      logger.error(""String_Node_Str"",e.getMessage());
      logger.debug(""String_Node_Str"",e);
      radPack=null;
    }
 finally {
      radiusService.disconnect();
    }
    if (radPack instanceof AccessAccept) {
      AuthenticatedUser authenticatedUser=authenticatedUserProvider.get();
      authenticatedUser.init(credentials);
      return authenticatedUser;
    }
 else {
      logger.warn(""String_Node_Str"");
      logger.debug(""String_Node_Str"");
      throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
    }
  }
}"
52304,"/** 
 * Returns an AuthenticatedUser representing the user authenticated by the given credentials.
 * @param credentials The credentials to use for authentication.
 * @return An AuthenticatedUser representing the user authenticated by the given credentials.
 * @throws GuacamoleException If an error occurs while authenticating the user, or if access is denied.
 */
public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
  RadiusPacket radPack;
  try {
    radPack=radiusService.authenticate(credentials.getUsername(),credentials.getPassword());
  }
 catch (  GuacamoleException e) {
    logger.error(""String_Node_Str"",e.getMessage());
    logger.debug(""String_Node_Str"",e);
    radPack=null;
  }
  if (radPack == null) {
    logger.debug(""String_Node_Str"");
    throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
  }
 else   if (radPack instanceof AccessReject) {
    logger.debug(""String_Node_Str"");
    throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
  }
 else   if (radPack instanceof AccessChallenge) {
    try {
      String replyMsg=radPack.getAttributeValue(""String_Node_Str"").toString();
      String radState=radPack.getAttributeValue(""String_Node_Str"").toString();
      logger.debug(""String_Node_Str"",replyMsg);
      logger.debug(""String_Node_Str"",radState);
      Field radiusResponseField=new RadiusChallengeResponseField(credentials.getUsername(),replyMsg,radState);
      CredentialsInfo expectedCredentials=new CredentialsInfo(Collections.singletonList(radiusResponseField));
      throw new GuacamoleInsufficientCredentialsException(""String_Node_Str"",expectedCredentials);
    }
 catch (    UnknownAttributeException e) {
      logger.error(""String_Node_Str"");
      logger.debug(""String_Node_Str"");
      throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
    }
  }
 else   if (radPack instanceof AccessAccept) {
    try {
      AuthenticatedUser authenticatedUser=authenticatedUserProvider.get();
      authenticatedUser.init(credentials);
      return authenticatedUser;
    }
  finally {
      radiusService.disconnect();
    }
  }
 else   throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
}","/** 
 * Returns an AuthenticatedUser representing the user authenticated by the given credentials.
 * @param credentials The credentials to use for authentication.
 * @return An AuthenticatedUser representing the user authenticated by the given credentials.
 * @throws GuacamoleException If an error occurs while authenticating the user, or if access is denied.
 */
public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
  RadiusPacket radPack;
  try {
    radPack=radiusService.authenticate(credentials.getUsername(),credentials.getPassword());
  }
 catch (  GuacamoleException e) {
    logger.error(""String_Node_Str"",e.getMessage());
    logger.debug(""String_Node_Str"",e);
    radPack=null;
  }
  if (radPack == null) {
    logger.debug(""String_Node_Str"");
    throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
  }
 else   if (radPack instanceof AccessReject) {
    logger.debug(""String_Node_Str"");
    throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
  }
 else   if (radPack instanceof AccessChallenge) {
    try {
      String replyMsg=radPack.getAttributeValue(""String_Node_Str"").toString();
      String radState=radPack.getAttributeValue(""String_Node_Str"").toString();
      logger.debug(""String_Node_Str"",replyMsg);
      logger.debug(""String_Node_Str"",radState);
      Field radiusResponseField=new RadiusChallengeResponseField(credentials.getUsername(),replyMsg,radState);
      CredentialsInfo expectedCredentials=new CredentialsInfo(Collections.singletonList(radiusResponseField));
      throw new GuacamoleInsufficientCredentialsException(""String_Node_Str"",expectedCredentials);
    }
 catch (    UnknownAttributeException e) {
      logger.error(""String_Node_Str"");
      logger.debug(""String_Node_Str"");
      return null;
    }
  }
 else   if (radPack instanceof AccessAccept) {
    try {
      AuthenticatedUser authenticatedUser=authenticatedUserProvider.get();
      authenticatedUser.init(credentials);
      return authenticatedUser;
    }
  finally {
      radiusService.disconnect();
    }
  }
 else   throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
}"
52305,"/** 
 * Returns the maximum number of seconds to wait for LDAP operations
 * @return The maximum number of seconds to wait for LDAP operations as configured in guacamole.properties
 * @throws GuacamoleException If guacamole.properties cannot be parsed.
 */
public int getOperationTimeout() throws GuacamoleException {
  return environment.getProperty(LDAPGuacamoleProperties.LDAP_OPERATION_TIMEOUT,30);
}","/** 
 * Returns the maximum number of seconds to wait for LDAP operations.
 * @return The maximum number of seconds to wait for LDAP operations as configured in guacamole.properties.
 * @throws GuacamoleException If guacamole.properties cannot be parsed.
 */
public int getOperationTimeout() throws GuacamoleException {
  return environment.getProperty(LDAPGuacamoleProperties.LDAP_OPERATION_TIMEOUT,30);
}"
52306,"/** 
 * Returns the maximum number of referral hops to follow.
 * @return The maximum number of referral hops to follow as configured in guacamole.properties
 * @throws GuacamoleException If guacamole.properties cannot be parsed.
 */
public int getMaxReferralHops() throws GuacamoleException {
  return environment.getProperty(LDAPGuacamoleProperties.LDAP_MAX_REFERRAL_HOPS,5);
}","/** 
 * Returns the maximum number of referral hops to follow.
 * @return The maximum number of referral hops to follow as configured in guacamole.properties.
 * @throws GuacamoleException If guacamole.properties cannot be parsed.
 */
public int getMaxReferralHops() throws GuacamoleException {
  return environment.getProperty(LDAPGuacamoleProperties.LDAP_MAX_REFERRAL_HOPS,5);
}"
52307,"/** 
 * Returns the boolean value for whether the connection should follow referrals or not.  By default, it will not.
 * @return The boolean value of whether to follow referrals as configured in guacamole.properties
 * @throws GuacamoleException If guacamole.properties cannot be parsed.
 */
public boolean getFollowReferrals() throws GuacamoleException {
  return environment.getProperty(LDAPGuacamoleProperties.LDAP_FOLLOW_REFERRALS,false);
}","/** 
 * Returns the boolean value for whether the connection should follow referrals or not.  By default, it will not.
 * @return The boolean value of whether to follow referrals as configured in guacamole.properties.
 * @throws GuacamoleException If guacamole.properties cannot be parsed.
 */
public boolean getFollowReferrals() throws GuacamoleException {
  return environment.getProperty(LDAPGuacamoleProperties.LDAP_FOLLOW_REFERRALS,false);
}"
52308,"/** 
 * Creates a ReferralAuthHandler object to handle authentication when following referrals in a LDAP connection, using the provided dn and password.
 * @throws GuacamoleException If exceptions are caught while converting the password from a string into a byte array.
 */
public ReferralAuthHandler(String dn,String password) throws GuacamoleException {
  byte[] passwordBytes;
  try {
    if (password != null)     passwordBytes=password.getBytes(""String_Node_Str"");
 else     passwordBytes=null;
  }
 catch (  UnsupportedEncodingException e) {
    logger.error(""String_Node_Str"",e.getMessage());
    logger.debug(""String_Node_Str"",e);
    throw new GuacamoleException(""String_Node_Str"");
  }
  ldapAuth=new LDAPAuthProvider(dn,passwordBytes);
}","/** 
 * Creates a ReferralAuthHandler object to handle authentication when following referrals in a LDAP connection, using the provided dn and password.
 */
public ReferralAuthHandler(String dn,String password){
  byte[] passwordBytes;
  try {
    if (password != null)     passwordBytes=password.getBytes(""String_Node_Str"");
 else     passwordBytes=null;
  }
 catch (  UnsupportedEncodingException e) {
    logger.error(""String_Node_Str"",e.getMessage());
    logger.debug(""String_Node_Str"",e);
    throw new UnsupportedOperationException(""String_Node_Str"",e);
  }
  ldapAuth=new LDAPAuthProvider(dn,passwordBytes);
}"
52309,"/** 
 * Returns a list of all DNs corresponding to the users having the given username. If multiple username attributes are defined, or if uniqueness is not enforced across the username attribute, it is possible that this will return multiple DNs.
 * @param ldapConnection The connection to the LDAP server to use when querying user DNs.
 * @param username The username of the user whose corresponding user account DNs are to be retrieved.
 * @return A list of all DNs corresponding to the users having the given username. If no such DNs exist, this list will be empty.
 * @throws GuacamoleException If an error occurs while querying the user DNs, or if the username attribute property cannot be parsed within guacamole.properties.
 */
public List<String> getUserDNs(LDAPConnection ldapConnection,String username) throws GuacamoleException {
  try {
    List<String> userDNs=new ArrayList<String>();
    LDAPSearchResults results=ldapConnection.search(confService.getUserBaseDN(),LDAPConnection.SCOPE_SUB,generateLDAPQuery(username),null,false,confService.getLDAPSearchConstraints());
    while (results.hasMore()) {
      try {
        LDAPEntry entry=results.next();
        userDNs.add(entry.getDN());
      }
 catch (      LDAPReferralException e) {
        if (confService.getFollowReferrals()) {
          logger.error(""String_Node_Str"",e.getMessage());
          logger.debug(""String_Node_Str"",e);
          throw new GuacamoleServerException(""String_Node_Str"",e);
        }
 else {
          logger.warn(""String_Node_Str"",e.getMessage());
          logger.debug(""String_Node_Str"",e);
        }
      }
    }
    return userDNs;
  }
 catch (  LDAPException e) {
    throw new GuacamoleServerException(""String_Node_Str"",e);
  }
}","/** 
 * Returns a list of all DNs corresponding to the users having the given username. If multiple username attributes are defined, or if uniqueness is not enforced across the username attribute, it is possible that this will return multiple DNs.
 * @param ldapConnection The connection to the LDAP server to use when querying user DNs.
 * @param username The username of the user whose corresponding user account DNs are to be retrieved.
 * @return A list of all DNs corresponding to the users having the given username. If no such DNs exist, this list will be empty.
 * @throws GuacamoleException If an error occurs while querying the user DNs, or if the username attribute property cannot be parsed within guacamole.properties.
 */
public List<String> getUserDNs(LDAPConnection ldapConnection,String username) throws GuacamoleException {
  try {
    List<String> userDNs=new ArrayList<String>();
    LDAPSearchResults results=ldapConnection.search(confService.getUserBaseDN(),LDAPConnection.SCOPE_SUB,generateLDAPQuery(username),null,false,confService.getLDAPSearchConstraints());
    while (results.hasMore()) {
      try {
        LDAPEntry entry=results.next();
        userDNs.add(entry.getDN());
      }
 catch (      LDAPReferralException e) {
        if (confService.getFollowReferrals()) {
          logger.error(""String_Node_Str"",e.getFailedReferral());
          logger.debug(""String_Node_Str"",e);
          throw new GuacamoleServerException(""String_Node_Str"",e);
        }
 else {
          logger.warn(""String_Node_Str"",e.getMessage());
          logger.debug(""String_Node_Str"",e);
        }
      }
    }
    return userDNs;
  }
 catch (  LDAPException e) {
    throw new GuacamoleServerException(""String_Node_Str"",e);
  }
}"
52310,"/** 
 * Takes an encrypted string representing a password provided by the CAS ClearPass service and decrypts it using the private key configured for this extension.  Returns null if it is unable to decrypt the password.
 * @param encryptedPassword A string with the encrypted password provided by the CAS service.
 * @return The decrypted password, or null if it is unable to decrypt the password.
 * @throws GuacamoleException If unable to get Guacamole configuration data
 */
private final String decryptPassword(String encryptedPassword) throws GuacamoleException {
  if (encryptedPassword == null || encryptedPassword.isEmpty())   return null;
  try {
    File keyFile=new File(new LocalEnvironment().getGuacamoleHome(),confService.getClearpassKey().toString());
    InputStream keyInput=new BufferedInputStream(new FileInputStream(keyFile));
    final byte[] keyBytes=new byte[(int)keyFile.length()];
    keyInput.read(keyBytes);
    keyInput.close();
    KeyFactory keyFactory=KeyFactory.getInstance(""String_Node_Str"");
    KeySpec keySpec=new PKCS8EncodedKeySpec(keyBytes);
    final PrivateKey privateKey=keyFactory.generatePrivate(keySpec);
    final Cipher cipher=Cipher.getInstance(privateKey.getAlgorithm());
    final byte[] pass64=DatatypeConverter.parseBase64Binary(encryptedPassword);
    cipher.init(Cipher.DECRYPT_MODE,privateKey);
    final byte[] cipherData=cipher.doFinal(pass64);
    return new String(cipherData);
  }
 catch (  FileNotFoundException e) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e.getMessage());
    return null;
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e.getMessage());
    return null;
  }
catch (  NoSuchAlgorithmException e) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e.getMessage());
    return null;
  }
catch (  InvalidKeyException e) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e.getMessage());
    return null;
  }
catch (  Throwable t) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",t.getMessage());
    return null;
  }
}","/** 
 * Takes an encrypted string representing a password provided by the CAS ClearPass service and decrypts it using the private key configured for this extension.  Returns null if it is unable to decrypt the password.
 * @param encryptedPassword A string with the encrypted password provided by the CAS service.
 * @return The decrypted password, or null if it is unable to decrypt the password.
 * @throws GuacamoleException If unable to get Guacamole configuration data
 */
private final String decryptPassword(String encryptedPassword) throws GuacamoleException {
  if (encryptedPassword == null || encryptedPassword.isEmpty())   return null;
  try {
    File keyFile=new File(environment.getGuacamoleHome(),confService.getClearpassKey().toString());
    InputStream keyInput=new BufferedInputStream(new FileInputStream(keyFile));
    final byte[] keyBytes=new byte[(int)keyFile.length()];
    keyInput.read(keyBytes);
    keyInput.close();
    KeyFactory keyFactory=KeyFactory.getInstance(""String_Node_Str"");
    KeySpec keySpec=new PKCS8EncodedKeySpec(keyBytes);
    final PrivateKey privateKey=keyFactory.generatePrivate(keySpec);
    final Cipher cipher=Cipher.getInstance(privateKey.getAlgorithm());
    final byte[] pass64=DatatypeConverter.parseBase64Binary(encryptedPassword);
    cipher.init(Cipher.DECRYPT_MODE,privateKey);
    final byte[] cipherData=cipher.doFinal(pass64);
    return new String(cipherData);
  }
 catch (  FileNotFoundException e) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e.getMessage());
    return null;
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e.getMessage());
    return null;
  }
catch (  NoSuchAlgorithmException e) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e.getMessage());
    return null;
  }
catch (  InvalidKeyException e) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",e.getMessage());
    return null;
  }
catch (  Throwable t) {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",t.getMessage());
    return null;
  }
}"
52311,"/** 
 * Validates and parses the given ID ticket, returning the username contained therein, as defined by the username claim type given in guacamole.properties. If the username claim type is missing or the ID ticket is invalid, an exception is thrown instead.
 * @param ticket The ID ticket to validate and parse.
 * @return The username contained within the given ID ticket.
 * @throws GuacamoleException If the ID ticket is not valid, the username claim type is missing, or guacamole.properties could not be parsed.
 */
public String processUsername(String ticket) throws GuacamoleException {
}","/** 
 * Validates and parses the given ID ticket, returning the username contained therein, as defined by the username claim type given in guacamole.properties. If the username claim type is missing or the ID ticket is invalid, an exception is thrown instead.
 * @param ticket The ID ticket to validate and parse.
 * @return The username contained within the given ID ticket.
 * @throws GuacamoleException If the ID ticket is not valid, the username claim type is missing, or guacamole.properties could not be parsed.
 */
public String processUsername(String ticket) throws GuacamoleException {
  AttributePrincipal principal=null;
  String casServerUrl=confService.getAuthorizationEndpoint();
  Cas20ProxyTicketValidator sv=new Cas20ProxyTicketValidator(casServerUrl);
  sv.setAcceptAnyProxy(true);
  try {
    String confRedirectURI=confService.getRedirectURI();
    Assertion a=sv.validate(ticket,confRedirectURI);
    principal=a.getPrincipal();
  }
 catch (  TicketValidationException e) {
    throw new GuacamoleException(""String_Node_Str"",e);
  }
  return principal.getName();
}"
52312,"/** 
 * Returns whether or not LDAP aliases will be dereferenced, as configured with guacamole.properties. By default they will never be dereferenced.
 * @return An integer representing the status of of alias dereferencing, as configured in guacamole.properties.
 * @throws GuacamoleException If guacamole.properties cannot be parsed.
 */
public int getDereferenceAliases() throws GuacamoleException {
  String derefAliases=environment.getProperty(LDAPGuacamoleProperties.LDAP_DEREFERENCE_ALIASES,""String_Node_Str"");
  if (derefAliases == ""String_Node_Str"")   return 3;
 else   if (derefAliases == ""String_Node_Str"")   return 2;
 else   if (derefAliases == ""String_Node_Str"")   return 1;
 else   return 0;
}","/** 
 * Returns whether or not LDAP aliases will be dereferenced, as configured with guacamole.properties. By default they will never be dereferenced.
 * @return An integer representing the status of of alias dereferencing, as configured in guacamole.properties.
 * @throws GuacamoleException If guacamole.properties cannot be parsed.
 */
public int getDereferenceAliases() throws GuacamoleException {
  String derefAliases=environment.getProperty(LDAPGuacamoleProperties.LDAP_DEREFERENCE_ALIASES,""String_Node_Str"");
  if (derefAliases.equals(""String_Node_Str""))   return 3;
 else   if (derefAliases.equals(""String_Node_Str""))   return 2;
 else   if (derefAliases.equals(""String_Node_Str""))   return 1;
 else   if (derefAliases.equals(""String_Node_Str""))   return 0;
 else {
    logger.error(""String_Node_Str"");
    logger.debug(""String_Node_Str"",derefAliases);
    throw new GuacamoleException(""String_Node_Str"");
  }
}"
52313,"/** 
 * Returns an AuthenticatedUser representing the user authenticated by the given credentials.
 * @param credentials The credentials to use for authentication.
 * @return An AuthenticatedUser representing the user authenticated by the given credentials.
 * @throws GuacamoleException If an error occurs while authenticating the user, or if access is denied.
 */
public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
  HttpServletRequest request=credentials.getRequest();
  if (request != null) {
    String username=request.getRemoteUser();
    if (username == null) {
      username=request.getHeader(confService.getHttpAuthHeader());
    }
    if (username != null) {
      AuthenticatedUser authenticatedUser=authenticatedUserProvider.get();
      authenticatedUser.init(username,credentials);
      return authenticatedUser;
    }
  }
  throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
}","/** 
 * Returns an AuthenticatedUser representing the user authenticated by the given credentials.
 * @param credentials The credentials to use for authentication.
 * @return An AuthenticatedUser representing the user authenticated by the given credentials.
 * @throws GuacamoleException If an error occurs while authenticating the user, or if access is denied.
 */
public AuthenticatedUser authenticateUser(Credentials credentials) throws GuacamoleException {
  HttpServletRequest request=credentials.getRequest();
  if (request != null) {
    String username=request.getRemoteUser();
    if (username == null)     username=request.getHeader(confService.getHttpAuthHeader());
    if (username != null) {
      logger.debug(""String_Node_Str"",username);
      AuthenticatedUser authenticatedUser=authenticatedUserProvider.get();
      authenticatedUser.init(username,credentials);
      return authenticatedUser;
    }
  }
  throw new GuacamoleInvalidCredentialsException(""String_Node_Str"",CredentialsInfo.USERNAME_PASSWORD);
}"
52314,"/** 
 * Wraps the given HttpServletRequest, using the given MultivaluedMap to provide all request parameters. All HttpServletRequest functions which do not deal with parameter names and values are delegated to the wrapped request.
 * @param request The HttpServletRequest to wrap.
 * @param parameters All request parameters.
 */
public APIRequest(HttpServletRequest request,MultivaluedMap<String,String> parameters){
  super(request);
  if (request.getHeader(""String_Node_Str"") != null && !request.getHeader(""String_Node_Str"").isEmpty()) {
    this.remoteHost=request.getHeader(""String_Node_Str"");
  }
 else   if (request.getHeader(""String_Node_Str"") != null && !request.getHeader(""String_Node_Str"").isEmpty()) {
    this.remoteHost=request.getHeader(""String_Node_Str"");
  }
 else   if (request.getRemoteHost() != null && !request.getRemoteHost().isEmpty()) {
    this.remoteHost=request.getRemoteHost();
  }
 else {
    this.remoteHost=null;
  }
  if (request.getHeader(""String_Node_Str"") != null && !request.getHeader(""String_Node_Str"").isEmpty()) {
    this.remoteAddr=request.getHeader(""String_Node_Str"");
  }
 else   if (request.getHeader(""String_Node_Str"") != null && !request.getHeader(""String_Node_Str"").isEmpty()) {
    this.remoteAddr=request.getHeader(""String_Node_Str"");
  }
 else   if (request.getRemoteHost() != null && !request.getRemoteAddr().isEmpty()) {
    this.remoteAddr=request.getRemoteAddr();
  }
 else {
    this.remoteAddr=null;
  }
  this.parameters=new HashMap<String,String[]>(parameters.size());
  for (  Map.Entry<String,List<String>> entry : parameters.entrySet()) {
    String name=entry.getKey();
    List<String> values=entry.getValue();
    this.parameters.put(name,values.toArray(new String[values.size()]));
  }
}","/** 
 * Wraps the given HttpServletRequest, using the given MultivaluedMap to provide all request parameters. All HttpServletRequest functions which do not deal with parameter names and values are delegated to the wrapped request.
 * @param request The HttpServletRequest to wrap.
 * @param parameters All request parameters.
 */
public APIRequest(HttpServletRequest request,MultivaluedMap<String,String> parameters){
  super(request);
  if (request.getHeader(""String_Node_Str"") != null && !request.getHeader(""String_Node_Str"").isEmpty())   this.remoteHost=request.getHeader(""String_Node_Str"");
 else   if (request.getHeader(""String_Node_Str"") != null && !request.getHeader(""String_Node_Str"").isEmpty())   this.remoteHost=request.getHeader(""String_Node_Str"");
 else   if (request.getRemoteHost() != null && !request.getRemoteHost().isEmpty())   this.remoteHost=request.getRemoteHost();
 else   this.remoteHost=null;
  if (request.getHeader(""String_Node_Str"") != null && !request.getHeader(""String_Node_Str"").isEmpty())   this.remoteAddr=request.getHeader(""String_Node_Str"");
 else   if (request.getHeader(""String_Node_Str"") != null && !request.getHeader(""String_Node_Str"").isEmpty())   this.remoteAddr=request.getHeader(""String_Node_Str"");
 else   if (request.getRemoteHost() != null && !request.getRemoteAddr().isEmpty())   this.remoteAddr=request.getRemoteAddr();
 else   this.remoteAddr=null;
  this.parameters=new HashMap<String,String[]>(parameters.size());
  for (  Map.Entry<String,List<String>> entry : parameters.entrySet()) {
    String name=entry.getKey();
    List<String> values=entry.getValue();
    this.parameters.put(name,values.toArray(new String[values.size()]));
  }
}"
52315,"/** 
 * Attempts to add a single instance of the given value to the given multiset without exceeding the specified maximum number of values. If the value cannot be added without exceeding the maximum, false is returned.
 * @param < T > The type of values contained within the multiset.
 * @param multiset The multiset to attempt to add a value to.
 * @param value The value to attempt to add.
 * @param max The maximum number of each distinct value that the given multiset should hold, or zero if no limit applies.
 * @return true if the value was successfully added without exceeding the specified maximum, false if the value could not be added.
 */
private <T>boolean tryAdd(ConcurrentHashMultiset<T> multiset,T value,int max){
  while (true) {
    int count=multiset.count(value);
    if (count >= max || max == 0)     return false;
    if (multiset.setCount(value,count,count + 1))     return true;
  }
}","/** 
 * Attempts to add a single instance of the given value to the given multiset without exceeding the specified maximum number of values. If the value cannot be added without exceeding the maximum, false is returned.
 * @param < T > The type of values contained within the multiset.
 * @param multiset The multiset to attempt to add a value to.
 * @param value The value to attempt to add.
 * @param max The maximum number of each distinct value that the given multiset should hold, or zero if no limit applies.
 * @return true if the value was successfully added without exceeding the specified maximum, false if the value could not be added.
 */
private <T>boolean tryAdd(ConcurrentHashMultiset<T> multiset,T value,int max){
  while (true) {
    int count=multiset.count(value);
    if (count >= max && max != 0)     return false;
    if (multiset.setCount(value,count,count + 1))     return true;
  }
}"
52316,"@Override protected void beforeUpdate(AuthenticatedUser user,ConnectionModel model) throws GuacamoleException {
  super.beforeUpdate(user,model);
  if (model.getName().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  ConnectionModel existing=connectionMapper.selectOneByName(model.getParentIdentifier(),model.getName());
  if (existing != null) {
    if (!existing.getObjectID().equals(model.getObjectID()))     throw new GuacamoleClientException(""String_Node_Str"" + model.getName() + ""String_Node_Str"");
  }
}","@Override protected void beforeUpdate(AuthenticatedUser user,ConnectionModel model) throws GuacamoleException {
  super.beforeUpdate(user,model);
  if (model.getName() == null || model.getName().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  ConnectionModel existing=connectionMapper.selectOneByName(model.getParentIdentifier(),model.getName());
  if (existing != null) {
    if (!existing.getObjectID().equals(model.getObjectID()))     throw new GuacamoleClientException(""String_Node_Str"" + model.getName() + ""String_Node_Str"");
  }
}"
52317,"/** 
 * Given an arbitrary Guacamole connection, produces a collection of parameter model objects containing the name/value pairs of that connection's parameters.
 * @param connection The connection whose configuration should be used to produce the collection of parameter models.
 * @return A collection of parameter models containing the name/value pairs of the given connection's parameters.
 */
private Collection<ParameterModel> getParameterModels(ModeledConnection connection){
  Map<String,String> parameters=connection.getConfiguration().getParameters();
  Collection<ParameterModel> parameterModels=new ArrayList(parameters.size());
  for (  Map.Entry<String,String> parameterEntry : parameters.entrySet()) {
    String name=parameterEntry.getKey();
    String value=parameterEntry.getValue();
    if (value.isEmpty())     continue;
    ParameterModel model=new ParameterModel();
    model.setConnectionIdentifier(connection.getIdentifier());
    model.setName(name);
    model.setValue(value);
    parameterModels.add(model);
  }
  return parameterModels;
}","/** 
 * Given an arbitrary Guacamole connection, produces a collection of parameter model objects containing the name/value pairs of that connection's parameters.
 * @param connection The connection whose configuration should be used to produce the collection of parameter models.
 * @return A collection of parameter models containing the name/value pairs of the given connection's parameters.
 */
private Collection<ParameterModel> getParameterModels(ModeledConnection connection){
  Map<String,String> parameters=connection.getConfiguration().getParameters();
  Collection<ParameterModel> parameterModels=new ArrayList(parameters.size());
  for (  Map.Entry<String,String> parameterEntry : parameters.entrySet()) {
    String name=parameterEntry.getKey();
    String value=parameterEntry.getValue();
    if (value == null || value.isEmpty())     continue;
    ParameterModel model=new ParameterModel();
    model.setConnectionIdentifier(connection.getIdentifier());
    model.setName(name);
    model.setValue(value);
    parameterModels.add(model);
  }
  return parameterModels;
}"
52318,"@Override protected void beforeCreate(AuthenticatedUser user,ConnectionModel model) throws GuacamoleException {
  super.beforeCreate(user,model);
  if (model.getName().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  ConnectionModel existing=connectionMapper.selectOneByName(model.getParentIdentifier(),model.getName());
  if (existing != null)   throw new GuacamoleClientException(""String_Node_Str"" + model.getName() + ""String_Node_Str"");
}","@Override protected void beforeCreate(AuthenticatedUser user,ConnectionModel model) throws GuacamoleException {
  super.beforeCreate(user,model);
  if (model.getName() == null || model.getName().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  ConnectionModel existing=connectionMapper.selectOneByName(model.getParentIdentifier(),model.getName());
  if (existing != null)   throw new GuacamoleClientException(""String_Node_Str"" + model.getName() + ""String_Node_Str"");
}"
52319,"@Override protected void beforeUpdate(AuthenticatedUser user,ConnectionGroupModel model) throws GuacamoleException {
  super.beforeUpdate(user,model);
  if (model.getName().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  ConnectionGroupModel existing=connectionGroupMapper.selectOneByName(model.getParentIdentifier(),model.getName());
  if (existing != null) {
    if (!existing.getObjectID().equals(model.getObjectID()))     throw new GuacamoleClientException(""String_Node_Str"" + model.getName() + ""String_Node_Str"");
  }
  String relativeParentIdentifier=model.getParentIdentifier();
  while (relativeParentIdentifier != null) {
    if (relativeParentIdentifier.equals(model.getIdentifier()))     throw new GuacamoleUnsupportedException(""String_Node_Str"");
    ModeledConnectionGroup relativeParentGroup=retrieveObject(user,relativeParentIdentifier);
    relativeParentIdentifier=relativeParentGroup.getModel().getParentIdentifier();
  }
}","@Override protected void beforeUpdate(AuthenticatedUser user,ConnectionGroupModel model) throws GuacamoleException {
  super.beforeUpdate(user,model);
  if (model.getName() == null || model.getName().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  ConnectionGroupModel existing=connectionGroupMapper.selectOneByName(model.getParentIdentifier(),model.getName());
  if (existing != null) {
    if (!existing.getObjectID().equals(model.getObjectID()))     throw new GuacamoleClientException(""String_Node_Str"" + model.getName() + ""String_Node_Str"");
  }
  String relativeParentIdentifier=model.getParentIdentifier();
  while (relativeParentIdentifier != null) {
    if (relativeParentIdentifier.equals(model.getIdentifier()))     throw new GuacamoleUnsupportedException(""String_Node_Str"");
    ModeledConnectionGroup relativeParentGroup=retrieveObject(user,relativeParentIdentifier);
    relativeParentIdentifier=relativeParentGroup.getModel().getParentIdentifier();
  }
}"
52320,"@Override protected void beforeCreate(AuthenticatedUser user,ConnectionGroupModel model) throws GuacamoleException {
  super.beforeCreate(user,model);
  if (model.getName().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  ConnectionGroupModel existing=connectionGroupMapper.selectOneByName(model.getParentIdentifier(),model.getName());
  if (existing != null)   throw new GuacamoleClientException(""String_Node_Str"" + model.getName() + ""String_Node_Str"");
}","@Override protected void beforeCreate(AuthenticatedUser user,ConnectionGroupModel model) throws GuacamoleException {
  super.beforeCreate(user,model);
  if (model.getName() == null || model.getName().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  ConnectionGroupModel existing=connectionGroupMapper.selectOneByName(model.getParentIdentifier(),model.getName());
  if (existing != null)   throw new GuacamoleClientException(""String_Node_Str"" + model.getName() + ""String_Node_Str"");
}"
52321,"@Override protected void beforeUpdate(AuthenticatedUser user,UserModel model) throws GuacamoleException {
  super.beforeUpdate(user,model);
  if (model.getIdentifier().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  UserModel existing=userMapper.selectOne(model.getIdentifier());
  if (existing != null) {
    if (!existing.getObjectID().equals(model.getObjectID()))     throw new GuacamoleClientException(""String_Node_Str"" + model.getIdentifier() + ""String_Node_Str"");
  }
}","@Override protected void beforeUpdate(AuthenticatedUser user,UserModel model) throws GuacamoleException {
  super.beforeUpdate(user,model);
  if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  UserModel existing=userMapper.selectOne(model.getIdentifier());
  if (existing != null) {
    if (!existing.getObjectID().equals(model.getObjectID()))     throw new GuacamoleClientException(""String_Node_Str"" + model.getIdentifier() + ""String_Node_Str"");
  }
}"
52322,"@Override protected void beforeCreate(AuthenticatedUser user,UserModel model) throws GuacamoleException {
  super.beforeCreate(user,model);
  if (model.getIdentifier().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  Collection<UserModel> existing=userMapper.select(Collections.singleton(model.getIdentifier()));
  if (!existing.isEmpty())   throw new GuacamoleClientException(""String_Node_Str"" + model.getIdentifier() + ""String_Node_Str"");
}","@Override protected void beforeCreate(AuthenticatedUser user,UserModel model) throws GuacamoleException {
  super.beforeCreate(user,model);
  if (model.getIdentifier() == null || model.getIdentifier().trim().isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  Collection<UserModel> existing=userMapper.select(Collections.singleton(model.getIdentifier()));
  if (!existing.isEmpty())   throw new GuacamoleClientException(""String_Node_Str"" + model.getIdentifier() + ""String_Node_Str"");
}"
52323,"/** 
 * Returns a map of all available language keys to their corresponding human-readable names.
 * @param authToken The authentication token that is used to authenticate the user performing the operation.
 * @param servletContext The ServletContext associated with the request.
 * @return A list of languages defined in the system, consisting of  language display name and key.
 * @throws GuacamoleException If an error occurs while retrieving the available languages.
 */
@GET @AuthProviderRESTExposure public Map<String,String> getLanguages(@QueryParam(""String_Node_Str"") String authToken,@Context ServletContext servletContext) throws GuacamoleException {
  Set<String> resourcePaths=servletContext.getResourcePaths(TRANSLATION_PATHS);
  if (resourcePaths == null)   return Collections.EMPTY_MAP;
  Map<String,String> languageMap=new HashMap<String,String>();
  for (  String resourcePath : resourcePaths) {
    InputStream languageFileStream=servletContext.getResourceAsStream(resourcePath);
    if (languageFileStream == null) {
      logger.warn(""String_Node_Str"",resourcePath);
      continue;
    }
    try {
      String languageKey;
      Matcher languageKeyMatcher=LANGUAGE_KEY_PATTERN.matcher(resourcePath);
      if (!languageKeyMatcher.matches() || (languageKey=languageKeyMatcher.group(1)) == null) {
        logger.warn(""String_Node_Str"",resourcePath);
        continue;
      }
      JsonNode tree=mapper.readTree(languageFileStream);
      JsonNode nameNode=tree.get(LANGUAGE_DISPLAY_NAME_KEY);
      String languageName;
      if (nameNode == null || (languageName=nameNode.getTextValue()) == null) {
        logger.warn(""String_Node_Str"" + LANGUAGE_DISPLAY_NAME_KEY + ""String_Node_Str"",resourcePath);
        languageName=languageKey;
      }
      languageMap.put(languageKey,languageName);
    }
 catch (    IOException e) {
      logger.warn(""String_Node_Str"",resourcePath,e.getMessage());
      logger.debug(""String_Node_Str"",e);
    }
  }
  return languageMap;
}","/** 
 * Returns a map of all available language keys to their corresponding human-readable names.
 * @param authToken The authentication token that is used to authenticate the user performing the operation.
 * @param servletContext The ServletContext associated with the request.
 * @return A map of languages defined in the system, of language key to  display name.
 * @throws GuacamoleException If an error occurs while retrieving the available languages.
 */
@GET @AuthProviderRESTExposure public Map<String,String> getLanguages(@QueryParam(""String_Node_Str"") String authToken,@Context ServletContext servletContext) throws GuacamoleException {
  Set<String> resourcePaths=servletContext.getResourcePaths(TRANSLATION_PATH);
  if (resourcePaths == null)   return Collections.EMPTY_MAP;
  Map<String,String> languageMap=new HashMap<String,String>();
  for (  String resourcePath : resourcePaths) {
    InputStream languageFileStream=servletContext.getResourceAsStream(resourcePath);
    if (languageFileStream == null) {
      logger.warn(""String_Node_Str"",resourcePath);
      continue;
    }
    try {
      String languageKey;
      Matcher languageKeyMatcher=LANGUAGE_KEY_PATTERN.matcher(resourcePath);
      if (!languageKeyMatcher.matches() || (languageKey=languageKeyMatcher.group(1)) == null) {
        logger.warn(""String_Node_Str"",resourcePath);
        continue;
      }
      JsonNode tree=mapper.readTree(languageFileStream);
      JsonNode nameNode=tree.get(LANGUAGE_DISPLAY_NAME_KEY);
      String languageName;
      if (nameNode == null || (languageName=nameNode.getTextValue()) == null) {
        logger.warn(""String_Node_Str"" + LANGUAGE_DISPLAY_NAME_KEY + ""String_Node_Str"",resourcePath);
        languageName=languageKey;
      }
      languageMap.put(languageKey,languageName);
    }
 catch (    IOException e) {
      logger.warn(""String_Node_Str"",resourcePath,e.getMessage());
      logger.debug(""String_Node_Str"",e);
    }
  }
  return languageMap;
}"
52324,"@Transactional @Override public org.glyptodon.guacamole.net.auth.User get(String identifier) throws GuacamoleException {
  MySQLUser user=userService.retrieveUser(identifier);
  permissionCheckService.verifyUserAccess(this.user_id,user.getUserID(),MySQLConstants.USER_READ);
  return userService.retrieveUser(identifier);
}","@Transactional @Override public org.glyptodon.guacamole.net.auth.User get(String identifier) throws GuacamoleException {
  MySQLUser user=userService.retrieveUser(identifier);
  if (user == null)   return null;
  permissionCheckService.verifyUserAccess(this.user_id,user.getUserID(),MySQLConstants.USER_READ);
  return user;
}"
52325,"/** 
 * Checks whether a user has the specified type of access to the affected connection group.
 * @param userID The ID of the user to check.
 * @param affectedConnectionGroupID The connection group that would be affected by theoperation if permission is granted.
 * @param permissionType The type of permission to check for.
 * @return true if the specified permission is granted, false otherwise.
 */
public boolean checkConnectionGroupAccess(int userID,Integer affectedConnectionGroupID,String permissionType){
  if (affectedConnectionGroupID == null)   return true;
  if (checkSystemAdministratorAccess(userID))   return true;
  ConnectionGroupPermissionExample example=new ConnectionGroupPermissionExample();
  example.createCriteria().andUser_idEqualTo(userID).andConnection_group_idEqualTo(affectedConnectionGroupID).andPermissionEqualTo(permissionType);
  return connectionGroupPermissionDAO.countByExample(example) > 0;
}","/** 
 * Checks whether a user has the specified type of access to the affected connection group.
 * @param userID The ID of the user to check.
 * @param affectedConnectionGroupID The connection group that would be affected by theoperation if permission is granted.
 * @param permissionType The type of permission to check for.
 * @return true if the specified permission is granted, false otherwise.
 */
public boolean checkConnectionGroupAccess(int userID,Integer affectedConnectionGroupID,String permissionType){
  if (affectedConnectionGroupID == null && MySQLConstants.CONNECTION_GROUP_READ.equals(permissionType) || MySQLConstants.CONNECTION_GROUP_UPDATE.equals(permissionType))   return true;
  if (checkSystemAdministratorAccess(userID))   return true;
  ConnectionGroupPermissionExample example=new ConnectionGroupPermissionExample();
  example.createCriteria().andUser_idEqualTo(userID).andConnection_group_idEqualTo(affectedConnectionGroupID).andPermissionEqualTo(permissionType);
  return connectionGroupPermissionDAO.countByExample(example) > 0;
}"
52326,"@Transactional @Override public void add(ConnectionGroup object) throws GuacamoleException {
  String name=object.getName().trim();
  if (name.isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  permissionCheckService.verifySystemAccess(this.user_id,MySQLConstants.SYSTEM_CONNECTION_GROUP_CREATE);
  permissionCheckService.verifyConnectionGroupAccess(this.user_id,this.parentID,MySQLConstants.CONNECTION_GROUP_UPDATE);
  permissionCheckService.verifyConnectionGroupUsageAccess(parentID,user_id,MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
  MySQLConnectionGroup previousConnectionGroup=connectionGroupService.retrieveConnectionGroup(name,parentID,user_id);
  if (previousConnectionGroup != null)   throw new GuacamoleClientException(""String_Node_Str"");
  MySQLConnectionGroup connectionGroup=connectionGroupService.createConnectionGroup(name,user_id,parentID);
  ConnectionGroupPermissionKey newConnectionGroupPermission=new ConnectionGroupPermissionKey();
  newConnectionGroupPermission.setUser_id(this.user_id);
  newConnectionGroupPermission.setConnection_group_id(connectionGroup.getConnectionGroupID());
  newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_READ);
  connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
  newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_UPDATE);
  connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
  newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_DELETE);
  connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
  newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_ADMINISTER);
  connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
}","@Transactional @Override public void add(ConnectionGroup object) throws GuacamoleException {
  String name=object.getName().trim();
  if (name.isEmpty())   throw new GuacamoleClientException(""String_Node_Str"");
  Type type=object.getType();
  String mySQLType=MySQLConstants.getConnectionGroupTypeConstant(type);
  permissionCheckService.verifySystemAccess(this.user_id,MySQLConstants.SYSTEM_CONNECTION_GROUP_CREATE);
  permissionCheckService.verifyConnectionGroupAccess(this.user_id,this.parentID,MySQLConstants.CONNECTION_GROUP_UPDATE);
  permissionCheckService.verifyConnectionGroupUsageAccess(parentID,user_id,MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL);
  MySQLConnectionGroup previousConnectionGroup=connectionGroupService.retrieveConnectionGroup(name,parentID,user_id);
  if (previousConnectionGroup != null)   throw new GuacamoleClientException(""String_Node_Str"");
  MySQLConnectionGroup connectionGroup=connectionGroupService.createConnectionGroup(name,user_id,parentID,mySQLType);
  ConnectionGroupPermissionKey newConnectionGroupPermission=new ConnectionGroupPermissionKey();
  newConnectionGroupPermission.setUser_id(this.user_id);
  newConnectionGroupPermission.setConnection_group_id(connectionGroup.getConnectionGroupID());
  newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_READ);
  connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
  newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_UPDATE);
  connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
  newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_DELETE);
  connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
  newConnectionGroupPermission.setPermission(MySQLConstants.CONNECTION_GROUP_ADMINISTER);
  connectionGroupPermissionDAO.insert(newConnectionGroupPermission);
}"
52327,"/** 
 * Retrieves the connection group having the given ID from the database.
 * @param id The ID of the connection group to retrieve.
 * @param userID The ID of the user who queried this connection.
 * @return The connection group having the given ID, or null if no suchconnection was found.
 */
public MySQLConnectionGroup retrieveConnectionGroup(int id,int userID){
  ConnectionGroup connectionGroup=connectionGroupDAO.selectByPrimaryKey(id);
  if (connectionGroup == null)   return null;
  return toMySQLConnectionGroup(connectionGroup,userID);
}","/** 
 * Retrieves the connection group having the given ID from the database.
 * @param id The ID of the connection group to retrieve.
 * @param userID The ID of the user who queried this connection.
 * @return The connection group having the given ID, or null if no suchconnection was found.
 */
public MySQLConnectionGroup retrieveConnectionGroup(Integer id,int userID){
  if (id == null) {
    MySQLConnectionGroup connectionGroup=mysqlConnectionGroupProvider.get();
    connectionGroup.init(null,null,MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.BALANCING,userID);
    return connectionGroup;
  }
  ConnectionGroup connectionGroup=connectionGroupDAO.selectByPrimaryKey(id);
  if (connectionGroup == null)   return null;
  return toMySQLConnectionGroup(connectionGroup,userID);
}"
52328,"/** 
 * Creates a new connection group having the given name and protocol.
 * @param name The name to assign to the new connection group.
 * @param userID The ID of the user who created this connection group.
 * @return A new MySQLConnectionGroup containing the data of the newly createdconnection group.
 */
public MySQLConnectionGroup createConnectionGroup(String name,int userID,Integer parentID){
  ConnectionGroup connectionGroup=new ConnectionGroup();
  connectionGroup.setConnection_group_name(name);
  connectionGroup.setParent_id(parentID);
  connectionGroupDAO.insert(connectionGroup);
  return toMySQLConnectionGroup(connectionGroup,userID);
}","/** 
 * Creates a new connection group having the given name and protocol.
 * @param name The name to assign to the new connection group.
 * @param userID The ID of the user who created this connection group.
 * @param Type The type of the new connection group.
 * @return A new MySQLConnectionGroup containing the data of the newly createdconnection group.
 */
public MySQLConnectionGroup createConnectionGroup(String name,int userID,Integer parentID,String type){
  ConnectionGroup connectionGroup=new ConnectionGroup();
  connectionGroup.setConnection_group_name(name);
  connectionGroup.setParent_id(parentID);
  connectionGroup.setType(type);
  connectionGroupDAO.insert(connectionGroup);
  return toMySQLConnectionGroup(connectionGroup,userID);
}"
52329,"@Override protected void authenticatedService(UserContext context,HttpServletRequest request,HttpServletResponse response) throws GuacamoleException {
  String name=request.getParameter(""String_Node_Str"");
  String parentID=request.getParameter(""String_Node_Str"");
  Directory<String,ConnectionGroup> directory=ConnectionGroupUtility.findConnectionGroupDirectory(context,parentID);
  if (directory == null)   throw new GuacamoleException(""String_Node_Str"");
  ConnectionGroup connectionGroup=new DummyConnectionGroup();
  connectionGroup.setName(name);
  directory.add(connectionGroup);
}","@Override protected void authenticatedService(UserContext context,HttpServletRequest request,HttpServletResponse response) throws GuacamoleException {
  String name=request.getParameter(""String_Node_Str"");
  String type=request.getParameter(""String_Node_Str"");
  String parentID=request.getParameter(""String_Node_Str"");
  Directory<String,ConnectionGroup> directory=ConnectionGroupUtility.findConnectionGroupDirectory(context,parentID);
  if (directory == null)   throw new GuacamoleException(""String_Node_Str"");
  ConnectionGroup connectionGroup=new DummyConnectionGroup();
  connectionGroup.setName(name);
  if (""String_Node_Str"".equals(type))   connectionGroup.setType(ConnectionGroup.Type.BALANCING);
 else   if (""String_Node_Str"".equals(type))   connectionGroup.setType(ConnectionGroup.Type.ORGANIZATIONAL);
  directory.add(connectionGroup);
}"
52330,"@Override protected void authenticatedService(UserContext context,HttpServletRequest request,HttpServletResponse response) throws GuacamoleException {
  String identifier=request.getParameter(""String_Node_Str"");
  String name=request.getParameter(""String_Node_Str"");
  Directory<String,ConnectionGroup> directory=context.getRootConnectionGroup().getConnectionGroupDirectory();
  ConnectionGroup connectionGroup=directory.get(identifier);
  connectionGroup.setName(name);
  directory.update(connectionGroup);
}","@Override protected void authenticatedService(UserContext context,HttpServletRequest request,HttpServletResponse response) throws GuacamoleException {
  String identifier=request.getParameter(""String_Node_Str"");
  String name=request.getParameter(""String_Node_Str"");
  String type=request.getParameter(""String_Node_Str"");
  Directory<String,ConnectionGroup> directory=context.getRootConnectionGroup().getConnectionGroupDirectory();
  ConnectionGroup connectionGroup=directory.get(identifier);
  connectionGroup.setName(name);
  if (""String_Node_Str"".equals(type))   connectionGroup.setType(ConnectionGroup.Type.BALANCING);
 else   if (""String_Node_Str"".equals(type))   connectionGroup.setType(ConnectionGroup.Type.ORGANIZATIONAL);
  directory.update(connectionGroup);
}"
52331,"/** 
 * Create any new permissions having to do with connection groups  for a given user.
 * @param user_id The ID of the user to assign or remove permissions from.
 * @param permissions The new permissions the user should have after thisoperation completes.
 * @throws GuacamoleException If permission to alter the access permissionsof affected objects is deniedD
 */
private void createConnectionGroupPermissions(int user_id,Collection<ConnectionGroupPermission> permissions) throws GuacamoleException {
  if (permissions.isEmpty())   return;
  Set<Integer> administerableConnectionGroupIDs=Sets.<Integer>newHashSet(permissionCheckService.retrieveConnectionGroupIDs(this.user_id,MySQLConstants.CONNECTION_GROUP_ADMINISTER));
  for (  ConnectionGroupPermission permission : permissions) {
    Integer connection_group_id=Integer.valueOf(permission.getObjectIdentifier());
    if (!administerableConnectionGroupIDs.contains(connection_group_id))     throw new GuacamoleSecurityException(""String_Node_Str"" + this.user_id + ""String_Node_Str""+ permission.getObjectIdentifier());
    ConnectionGroupPermissionKey newPermission=new ConnectionGroupPermissionKey();
    newPermission.setUser_id(user_id);
    newPermission.setPermission(MySQLConstants.getConnectionConstant(permission.getType()));
    newPermission.setConnection_group_id(connection_group_id);
    connectionGroupPermissionDAO.insert(newPermission);
  }
}","/** 
 * Create any new permissions having to do with connection groups  for a given user.
 * @param user_id The ID of the user to assign or remove permissions from.
 * @param permissions The new permissions the user should have after thisoperation completes.
 * @throws GuacamoleException If permission to alter the access permissionsof affected objects is deniedD
 */
private void createConnectionGroupPermissions(int user_id,Collection<ConnectionGroupPermission> permissions) throws GuacamoleException {
  if (permissions.isEmpty())   return;
  Set<Integer> administerableConnectionGroupIDs=Sets.<Integer>newHashSet(permissionCheckService.retrieveConnectionGroupIDs(this.user_id,MySQLConstants.CONNECTION_GROUP_ADMINISTER));
  for (  ConnectionGroupPermission permission : permissions) {
    Integer connection_group_id=Integer.valueOf(permission.getObjectIdentifier());
    if (!administerableConnectionGroupIDs.contains(connection_group_id))     throw new GuacamoleSecurityException(""String_Node_Str"" + this.user_id + ""String_Node_Str""+ permission.getObjectIdentifier());
    ConnectionGroupPermissionKey newPermission=new ConnectionGroupPermissionKey();
    newPermission.setUser_id(user_id);
    newPermission.setPermission(MySQLConstants.getConnectionGroupConstant(permission.getType()));
    newPermission.setConnection_group_id(connection_group_id);
    connectionGroupPermissionDAO.insert(newPermission);
  }
}"
52332,"/** 
 * Creates a new MySQLAuthenticationProvider that reads and writes authentication data to a MySQL database defined by properties in guacamole.properties.
 * @throws GuacamoleException If a required property is missing, oran error occurs while parsing a property.
 */
public MySQLAuthenticationProvider() throws GuacamoleException {
  final Properties myBatisProperties=new Properties();
  final Properties driverProperties=new Properties();
  myBatisProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  myBatisProperties.setProperty(""String_Node_Str"",GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_HOSTNAME));
  myBatisProperties.setProperty(""String_Node_Str"",String.valueOf(GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_PORT)));
  myBatisProperties.setProperty(""String_Node_Str"",GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_DATABASE));
  myBatisProperties.setProperty(""String_Node_Str"",GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_USERNAME));
  myBatisProperties.setProperty(""String_Node_Str"",GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_PASSWORD));
  myBatisProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  driverProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  injector=Guice.createInjector(JdbcHelper.MySQL,new Module(){
    @Override public void configure(    Binder binder){
      Names.bindProperties(binder,myBatisProperties);
      binder.bind(Properties.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(driverProperties);
    }
  }
,new MyBatisModule(){
    @Override protected void initialize(){
      bindDataSourceProviderType(PooledDataSourceProvider.class);
      bindTransactionFactoryType(JdbcTransactionFactory.class);
      addMapperClass(ConnectionHistoryMapper.class);
      addMapperClass(ConnectionMapper.class);
      addMapperClass(ConnectionGroupMapper.class);
      addMapperClass(ConnectionParameterMapper.class);
      addMapperClass(ConnectionPermissionMapper.class);
      addMapperClass(SystemPermissionMapper.class);
      addMapperClass(UserMapper.class);
      addMapperClass(UserPermissionMapper.class);
      bind(MySQLUserContext.class);
      bind(UserDirectory.class);
      bind(MySQLUser.class);
      bind(SaltService.class).to(SecureRandomSaltService.class);
      bind(PasswordEncryptionService.class).to(SHA256PasswordEncryptionService.class);
      bind(PermissionCheckService.class);
      bind(ConnectionService.class);
      bind(ConnectionGroupService.class);
      bind(UserService.class);
      bind(ActiveConnectionMap.class).toInstance(activeConnectionMap);
    }
  }
);
}","/** 
 * Creates a new MySQLAuthenticationProvider that reads and writes authentication data to a MySQL database defined by properties in guacamole.properties.
 * @throws GuacamoleException If a required property is missing, oran error occurs while parsing a property.
 */
public MySQLAuthenticationProvider() throws GuacamoleException {
  final Properties myBatisProperties=new Properties();
  final Properties driverProperties=new Properties();
  myBatisProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  myBatisProperties.setProperty(""String_Node_Str"",GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_HOSTNAME));
  myBatisProperties.setProperty(""String_Node_Str"",String.valueOf(GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_PORT)));
  myBatisProperties.setProperty(""String_Node_Str"",GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_DATABASE));
  myBatisProperties.setProperty(""String_Node_Str"",GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_USERNAME));
  myBatisProperties.setProperty(""String_Node_Str"",GuacamoleProperties.getRequiredProperty(MySQLGuacamoleProperties.MYSQL_PASSWORD));
  myBatisProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  driverProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  injector=Guice.createInjector(JdbcHelper.MySQL,new Module(){
    @Override public void configure(    Binder binder){
      Names.bindProperties(binder,myBatisProperties);
      binder.bind(Properties.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(driverProperties);
    }
  }
,new MyBatisModule(){
    @Override protected void initialize(){
      bindDataSourceProviderType(PooledDataSourceProvider.class);
      bindTransactionFactoryType(JdbcTransactionFactory.class);
      addMapperClass(ConnectionHistoryMapper.class);
      addMapperClass(ConnectionMapper.class);
      addMapperClass(ConnectionGroupMapper.class);
      addMapperClass(ConnectionGroupPermissionMapper.class);
      addMapperClass(ConnectionParameterMapper.class);
      addMapperClass(ConnectionPermissionMapper.class);
      addMapperClass(SystemPermissionMapper.class);
      addMapperClass(UserMapper.class);
      addMapperClass(UserPermissionMapper.class);
      bind(MySQLUserContext.class);
      bind(UserDirectory.class);
      bind(MySQLUser.class);
      bind(SaltService.class).to(SecureRandomSaltService.class);
      bind(PasswordEncryptionService.class).to(SHA256PasswordEncryptionService.class);
      bind(PermissionCheckService.class);
      bind(ConnectionService.class);
      bind(ConnectionGroupService.class);
      bind(UserService.class);
      bind(ActiveConnectionMap.class).toInstance(activeConnectionMap);
    }
  }
);
}"
52333,"@Override protected void initialize(){
  bindDataSourceProviderType(PooledDataSourceProvider.class);
  bindTransactionFactoryType(JdbcTransactionFactory.class);
  addMapperClass(ConnectionHistoryMapper.class);
  addMapperClass(ConnectionMapper.class);
  addMapperClass(ConnectionGroupMapper.class);
  addMapperClass(ConnectionParameterMapper.class);
  addMapperClass(ConnectionPermissionMapper.class);
  addMapperClass(SystemPermissionMapper.class);
  addMapperClass(UserMapper.class);
  addMapperClass(UserPermissionMapper.class);
  bind(MySQLUserContext.class);
  bind(UserDirectory.class);
  bind(MySQLUser.class);
  bind(SaltService.class).to(SecureRandomSaltService.class);
  bind(PasswordEncryptionService.class).to(SHA256PasswordEncryptionService.class);
  bind(PermissionCheckService.class);
  bind(ConnectionService.class);
  bind(ConnectionGroupService.class);
  bind(UserService.class);
  bind(ActiveConnectionMap.class).toInstance(activeConnectionMap);
}","@Override protected void initialize(){
  bindDataSourceProviderType(PooledDataSourceProvider.class);
  bindTransactionFactoryType(JdbcTransactionFactory.class);
  addMapperClass(ConnectionHistoryMapper.class);
  addMapperClass(ConnectionMapper.class);
  addMapperClass(ConnectionGroupMapper.class);
  addMapperClass(ConnectionGroupPermissionMapper.class);
  addMapperClass(ConnectionParameterMapper.class);
  addMapperClass(ConnectionPermissionMapper.class);
  addMapperClass(SystemPermissionMapper.class);
  addMapperClass(UserMapper.class);
  addMapperClass(UserPermissionMapper.class);
  bind(MySQLUserContext.class);
  bind(UserDirectory.class);
  bind(MySQLUser.class);
  bind(SaltService.class).to(SecureRandomSaltService.class);
  bind(PasswordEncryptionService.class).to(SHA256PasswordEncryptionService.class);
  bind(PermissionCheckService.class);
  bind(ConnectionService.class);
  bind(ConnectionGroupService.class);
  bind(UserService.class);
  bind(ActiveConnectionMap.class).toInstance(activeConnectionMap);
}"
52334,"/** 
 * Initialize from explicit values.
 * @param connectionGroupID The ID of the associated database record, if any.
 * @param parentID The ID of the parent connection group for this connection group, if any.
 * @param identifier The unique identifier associated with this connection group.
 * @param type The type of this connection group.
 * @param userID The IID of the user who queried this connection.
 */
public void init(Integer connectionGroupID,Integer parentID,String name,String identifier,String type,int userID){
  this.connectionGroupID=connectionGroupID;
  this.parentID=parentID;
  setName(name);
  setIdentifier(identifier);
  this.userID=userID;
  connectionDirectory=connectionDirectoryProvider.get();
  connectionDirectory.init(userID,parentID);
  connectionGroupDirectory=connectionGroupDirectoryProvider.get();
  connectionGroupDirectory.init(userID,parentID);
}","/** 
 * Initialize from explicit values.
 * @param connectionGroupID The ID of the associated database record, if any.
 * @param parentID The ID of the parent connection group for this connection group, if any.
 * @param identifier The unique identifier associated with this connection group.
 * @param type The type of this connection group.
 * @param userID The IID of the user who queried this connection.
 */
public void init(Integer connectionGroupID,Integer parentID,String name,String identifier,ConnectionGroup.Type type,int userID){
  this.connectionGroupID=connectionGroupID;
  this.parentID=parentID;
  setName(name);
  setIdentifier(identifier);
  setType(type);
  this.userID=userID;
  connectionDirectory=connectionDirectoryProvider.get();
  connectionDirectory.init(userID,parentID);
  connectionGroupDirectory=connectionGroupDirectoryProvider.get();
  connectionGroupDirectory.init(userID,parentID);
}"
52335,"/** 
 * Initializes the user and directories associated with this context.
 * @param user_id The ID of the user owning this context.
 */
public void init(int user_id){
  this.user_id=user_id;
  userDirectory.init(user_id);
  mySQLConnectionGroup.init(null,null,MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL,user_id);
}","/** 
 * Initializes the user and directories associated with this context.
 * @param user_id The ID of the user owning this context.
 */
public void init(int user_id){
  this.user_id=user_id;
  userDirectory.init(user_id);
  rootConnectionGroup.init(null,null,MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,MySQLConstants.CONNECTION_GROUP_ROOT_IDENTIFIER,ConnectionGroup.Type.ORGANIZATIONAL,user_id);
}"
52336,"@Override public ConnectionGroup getConnectionGroup() throws GuacamoleException {
  return mySQLConnectionGroup;
}","@Override public ConnectionGroup getConnectionGroup() throws GuacamoleException {
  return rootConnectionGroup;
}"
52337,"/** 
 * Convert the given database-retrieved Connection into a MySQLConnection. The parameters of the given connection will be read and added to the MySQLConnection in the process.
 * @param connection The connection to convert.
 * @param userID The user who queried this connection.
 * @return A new MySQLConnection containing all data associated with thespecified connection.
 */
private MySQLConnectionGroup toMySQLConnectionGroup(ConnectionGroup connectionGroup,int userID){
  MySQLConnectionGroup mySQLConnectionGroup=mysqlConnectionGroupProvider.get();
  mySQLConnectionGroup.init(connectionGroup.getConnection_group_id(),connectionGroup.getParent_id(),connectionGroup.getConnection_group_name(),Integer.toString(connectionGroup.getConnection_group_id()),connectionGroup.getType(),userID);
  return mySQLConnectionGroup;
}","/** 
 * Convert the given database-retrieved Connection into a MySQLConnection. The parameters of the given connection will be read and added to the MySQLConnection in the process.
 * @param connection The connection to convert.
 * @param userID The user who queried this connection.
 * @return A new MySQLConnection containing all data associated with thespecified connection.
 */
private MySQLConnectionGroup toMySQLConnectionGroup(ConnectionGroup connectionGroup,int userID){
  MySQLConnectionGroup mySQLConnectionGroup=mysqlConnectionGroupProvider.get();
  String mySqlType=connectionGroup.getType();
  net.sourceforge.guacamole.net.auth.ConnectionGroup.Type authType;
  if (mySqlType.equals(MySQLConstants.CONNECTION_GROUP_ORGANIZATIONAL))   authType=net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.ORGANIZATIONAL;
 else   authType=net.sourceforge.guacamole.net.auth.ConnectionGroup.Type.BALANCING;
  mySQLConnectionGroup.init(connectionGroup.getConnection_group_id(),connectionGroup.getParent_id(),connectionGroup.getConnection_group_name(),Integer.toString(connectionGroup.getConnection_group_id()),authType,userID);
  return mySQLConnectionGroup;
}"
52338,"/** 
 * Creates a new InetGuacamoleSocket which reads and writes instructions to the Guacamole instruction stream of the Guacamole proxy server running at the given hostname and port.
 * @param hostname The hostname of the Guacamole proxy server to connect to.
 * @param port The port of the Guacamole proxy server to connect to.
 * @throws GuacamoleException If an error occurs while connecting to theGuacamole proxy server.
 */
public SSLGuacamoleSocket(String hostname,int port) throws GuacamoleException {
  SocketFactory socket_factory=SSLSocketFactory.getDefault();
  try {
    logger.debug(""String_Node_Str"",hostname,port);
    SocketAddress address=new InetSocketAddress(InetAddress.getByName(hostname),port);
    sock=socket_factory.createSocket();
    sock.connect(address,SOCKET_TIMEOUT);
    sock.setSoTimeout(SOCKET_TIMEOUT);
    reader=new ReaderGuacamoleReader(new InputStreamReader(sock.getInputStream(),""String_Node_Str""));
    writer=new WriterGuacamoleWriter(new OutputStreamWriter(sock.getOutputStream(),""String_Node_Str""));
  }
 catch (  IOException e) {
    throw new GuacamoleServerException(e);
  }
}","/** 
 * Creates a new SSLGuacamoleSocket which reads and writes instructions to the Guacamole instruction stream of the Guacamole proxy server running at the given hostname and port using SSL.
 * @param hostname The hostname of the Guacamole proxy server to connect to.
 * @param port The port of the Guacamole proxy server to connect to.
 * @throws GuacamoleException If an error occurs while connecting to theGuacamole proxy server.
 */
public SSLGuacamoleSocket(String hostname,int port) throws GuacamoleException {
  SocketFactory socket_factory=SSLSocketFactory.getDefault();
  try {
    logger.debug(""String_Node_Str"",hostname,port);
    SocketAddress address=new InetSocketAddress(InetAddress.getByName(hostname),port);
    sock=socket_factory.createSocket();
    sock.connect(address,SOCKET_TIMEOUT);
    sock.setSoTimeout(SOCKET_TIMEOUT);
    reader=new ReaderGuacamoleReader(new InputStreamReader(sock.getInputStream(),""String_Node_Str""));
    writer=new WriterGuacamoleWriter(new OutputStreamWriter(sock.getOutputStream(),""String_Node_Str""));
  }
 catch (  IOException e) {
    throw new GuacamoleServerException(e);
  }
}"
52339,"/** 
 * Returns the value that will be sent to the client plugin if this option  is chosen.
 * @return The value that will be sent if this option is chosen.
 */
public String getValue(){
  return value;
}","/** 
 * Returns the value that will be sent to the client plugin if this option is chosen.
 * @return The value that will be sent if this option is chosen.
 */
public String getValue(){
  return value;
}"
52340,"/** 
 * Create any new system permissions for a given user. All permissions in the given list will be inserted.
 * @param user_id The ID of the user whose permissions should be updated.
 * @param permissions The new system permissions that the given user shouldhave when this operation completes.
 */
private void createSystemPermissions(int user_id,Collection<SystemPermission> permissions) throws GuacamoleException {
  if (permissions.isEmpty())   return;
  permissionCheckService.verifySystemAccess(this.user_id,SystemPermission.Type.ADMINISTER.name());
  for (  SystemPermission permission : permissions) {
    SystemPermissionKey newSystemPermission=new SystemPermissionKey();
    newSystemPermission.setUser_id(user_id);
    newSystemPermission.setPermission(MySQLConstants.getSystemConstant(permission.getType()));
    systemPermissionDAO.insert(newSystemPermission);
  }
}","/** 
 * Create any new system permissions for a given user. All permissions in the given list will be inserted.
 * @param user_id The ID of the user whose permissions should be updated.
 * @param permissions The new system permissions that the given user shouldhave when this operation completes.
 * @throws GuacamoleException If permission to administer system permissionsis denied.
 */
private void createSystemPermissions(int user_id,Collection<SystemPermission> permissions) throws GuacamoleException {
  if (permissions.isEmpty())   return;
  permissionCheckService.verifySystemAccess(this.user_id,SystemPermission.Type.ADMINISTER.name());
  for (  SystemPermission permission : permissions) {
    SystemPermissionKey newSystemPermission=new SystemPermissionKey();
    newSystemPermission.setUser_id(user_id);
    newSystemPermission.setPermission(MySQLConstants.getSystemConstant(permission.getType()));
    systemPermissionDAO.insert(newSystemPermission);
  }
}"
52341,"@Transactional @Override public Set<String> getIdentifiers() throws GuacamoleException {
  List<Integer> connectionIDs=permissionCheckService.retrieveConnectionIDs(this.user_id,MySQLConstants.CONNECTION_READ);
  return connectionService.translateNames(connectionIDs).keySet();
}","@Transactional @Override public Set<String> getIdentifiers() throws GuacamoleException {
  return permissionCheckService.retrieveConnectionNames(user_id,MySQLConstants.CONNECTION_READ);
}"
52342,"/** 
 * Delete permissions having to do with connections for a given user.
 * @param user_id The ID of the user to change the permissions of.
 * @param permissions The permissions the given user should no longer havewhen this operation completes.
 * @throws GuacamoleException If permission to alter the access permissionsof affected objects is denied.
 */
private void deleteConnectionPermissions(int user_id,Collection<ConnectionPermission> permissions) throws GuacamoleException {
  if (permissions.isEmpty())   return;
  List<Integer> administerableConnectionIDs=permissionCheckService.retrieveUserIDs(this.user_id,MySQLConstants.CONNECTION_ADMINISTER);
  Map<String,Integer> administerableConnections=userService.translateUsernames(administerableConnectionIDs);
  for (  ConnectionPermission permission : permissions) {
    Integer connection_id=administerableConnections.get(permission.getObjectIdentifier());
    if (connection_id == null)     throw new GuacamoleSecurityException(""String_Node_Str"" + this.user_id + ""String_Node_Str""+ permission.getObjectIdentifier());
    ConnectionPermissionExample connectionPermissionExample=new ConnectionPermissionExample();
    connectionPermissionExample.createCriteria().andUser_idEqualTo(user_id).andPermissionEqualTo(MySQLConstants.getConnectionConstant(permission.getType())).andConnection_idEqualTo(connection_id);
    connectionPermissionDAO.deleteByExample(connectionPermissionExample);
  }
}","/** 
 * Delete permissions having to do with connections for a given user.
 * @param user_id The ID of the user to change the permissions of.
 * @param permissions The permissions the given user should no longer havewhen this operation completes.
 * @throws GuacamoleException If permission to alter the access permissionsof affected objects is denied.
 */
private void deleteConnectionPermissions(int user_id,Collection<ConnectionPermission> permissions) throws GuacamoleException {
  if (permissions.isEmpty())   return;
  List<Integer> administerableConnectionIDs=permissionCheckService.retrieveConnectionIDs(this.user_id,MySQLConstants.CONNECTION_ADMINISTER);
  Map<String,Integer> administerableConnections=connectionService.translateNames(administerableConnectionIDs);
  for (  ConnectionPermission permission : permissions) {
    Integer connection_id=administerableConnections.get(permission.getObjectIdentifier());
    if (connection_id == null)     throw new GuacamoleSecurityException(""String_Node_Str"" + this.user_id + ""String_Node_Str""+ permission.getObjectIdentifier());
    ConnectionPermissionExample connectionPermissionExample=new ConnectionPermissionExample();
    connectionPermissionExample.createCriteria().andUser_idEqualTo(user_id).andPermissionEqualTo(MySQLConstants.getConnectionConstant(permission.getType())).andConnection_idEqualTo(connection_id);
    connectionPermissionDAO.deleteByExample(connectionPermissionExample);
  }
}"
52343,"@Transactional @Override public Set<String> getIdentifiers() throws GuacamoleException {
  List<Integer> userIDs=permissionCheckService.retrieveConnectionIDs(this.user_id,MySQLConstants.USER_READ);
  return userService.translateUsernames(userIDs).keySet();
}","@Transactional @Override public Set<String> getIdentifiers() throws GuacamoleException {
  return permissionCheckService.retrieveUsernames(user_id,MySQLConstants.USER_READ);
}"
52344,"/** 
 * Get the IDs of all the connection defined in the system.
 * @param userID The ID of the user who is querying the connections.
 * @return A list of IDs of all the connections defined in the system.
 */
public List<Integer> getAllConnectionIDs(int userID){
  List<Integer> connectionIDs=new ArrayList<Integer>();
  for (  MySQLConnection connection : getAllConnections(userID)) {
    connectionIDs.add(connection.getConnectionID());
  }
  return connectionIDs;
}","/** 
 * Get the connection IDs of all the connections defined in the system.
 * @return A list of connection IDs of all the connections defined in the system.
 */
public List<Integer> getAllConnectionIDs(){
  List<Integer> connectionIDs=new ArrayList<Integer>();
  List<Connection> connections=connectionDAO.selectByExample(new ConnectionExample());
  for (  Connection connection : connections)   connectionIDs.add(connection.getConnection_id());
  return connectionIDs;
}"
52345,"/** 
 * Find the list of the IDs of all connections a user has permission to. The access type is defined by permissionType.
 * @param userID The ID of the user to check.
 * @param permissionType The type of permission to check for.
 * @return A list of all connection IDs this user has the specified accessto.
 */
public List<Integer> retrieveConnectionIDs(int userID,String permissionType){
  if (checkSystemAdministratorAccess(userID)) {
    return connectionService.getAllConnectionIDs(userID);
  }
  ConnectionPermissionExample example=new ConnectionPermissionExample();
  example.createCriteria().andUser_idEqualTo(userID).andPermissionEqualTo(permissionType);
  example.setDistinct(true);
  List<ConnectionPermissionKey> connectionPermissions=connectionPermissionDAO.selectByExample(example);
  List<Integer> connectionIDs=new ArrayList<Integer>(connectionPermissions.size());
  for (  ConnectionPermissionKey permission : connectionPermissions)   connectionIDs.add(permission.getConnection_id());
  return connectionIDs;
}","/** 
 * Find the list of the IDs of all connections a user has permission to. The access type is defined by permissionType.
 * @param userID The ID of the user to check.
 * @param permissionType The type of permission to check for.
 * @return A list of all connection IDs this user has the specified accessto.
 */
public List<Integer> retrieveConnectionIDs(int userID,String permissionType){
  if (checkSystemAdministratorAccess(userID))   return connectionService.getAllConnectionIDs();
  ConnectionPermissionExample example=new ConnectionPermissionExample();
  example.createCriteria().andUser_idEqualTo(userID).andPermissionEqualTo(permissionType);
  example.setDistinct(true);
  List<ConnectionPermissionKey> connectionPermissions=connectionPermissionDAO.selectByExample(example);
  List<Integer> connectionIDs=new ArrayList<Integer>(connectionPermissions.size());
  for (  ConnectionPermissionKey permission : connectionPermissions)   connectionIDs.add(permission.getConnection_id());
  return connectionIDs;
}"
52346,"/** 
 * Find the list of the IDs of all users a user has permission to. The access type is defined by permissionType.
 * @param userID The ID of the user to check.
 * @param permissionType The type of permission to check for.
 * @return A list of all user IDs this user has the specified access to.
 */
public List<Integer> retrieveUserIDs(int userID,String permissionType){
  if (checkSystemAdministratorAccess(userID)) {
    return userService.getAllUserIDs();
  }
  UserPermissionExample example=new UserPermissionExample();
  example.createCriteria().andUser_idEqualTo(userID).andPermissionEqualTo(permissionType);
  example.setDistinct(true);
  List<UserPermissionKey> userPermissions=userPermissionDAO.selectByExample(example);
  List<Integer> userIDs=new ArrayList<Integer>(userPermissions.size());
  for (  UserPermissionKey permission : userPermissions)   userIDs.add(permission.getAffected_user_id());
  return userIDs;
}","/** 
 * Find the list of the IDs of all users a user has permission to. The access type is defined by permissionType.
 * @param userID The ID of the user to check.
 * @param permissionType The type of permission to check for.
 * @return A list of all user IDs this user has the specified access to.
 */
public List<Integer> retrieveUserIDs(int userID,String permissionType){
  if (checkSystemAdministratorAccess(userID))   return userService.getAllUserIDs();
  UserPermissionExample example=new UserPermissionExample();
  example.createCriteria().andUser_idEqualTo(userID).andPermissionEqualTo(permissionType);
  example.setDistinct(true);
  List<UserPermissionKey> userPermissions=userPermissionDAO.selectByExample(example);
  List<Integer> userIDs=new ArrayList<Integer>(userPermissions.size());
  for (  UserPermissionKey permission : userPermissions)   userIDs.add(permission.getAffected_user_id());
  return userIDs;
}"
52347,"/** 
 * Retrieves a map of all usernames for the given IDs.
 * @param ids The IDs of the users to retrieve the usernames of.
 * @return A map containing the names of all users and their correspondingIDs.
 */
public Map<Integer,String> retrieveUsernames(Collection<Integer> ids){
  if (ids.isEmpty())   return Collections.EMPTY_MAP;
  Map<Integer,String> names=new HashMap<Integer,String>();
  UserExample example=new UserExample();
  example.createCriteria().andUser_idIn(Lists.newArrayList(ids));
  List<net.sourceforge.guacamole.net.auth.mysql.model.User> users=userDAO.selectByExample(example);
  for (  net.sourceforge.guacamole.net.auth.mysql.model.User user : users)   names.put(user.getUser_id(),user.getUsername());
  return names;
}","/** 
 * Retrieves a map of all usernames for the given IDs.
 * @param ids The IDs of the users to retrieve the usernames of.
 * @return A map containing the names of all users and their correspondingIDs.
 */
public Map<Integer,String> retrieveUsernames(Collection<Integer> ids){
  if (ids.isEmpty())   return Collections.EMPTY_MAP;
  Map<Integer,String> names=new HashMap<Integer,String>();
  UserExample example=new UserExample();
  example.createCriteria().andUser_idIn(Lists.newArrayList(ids));
  List<User> users=userDAO.selectByExample(example);
  for (  User user : users)   names.put(user.getUser_id(),user.getUsername());
  return names;
}"
52348,"/** 
 * Retrieves a translation map of usernames to their corresponding IDs.
 * @param ids The IDs of the users to retrieve the usernames of.
 * @return A map containing the names of all users and their correspondingIDs.
 */
public Map<String,Integer> translateUsernames(List<Integer> ids){
  if (ids.isEmpty())   return Collections.EMPTY_MAP;
  Map<String,Integer> names=new HashMap<String,Integer>();
  UserExample example=new UserExample();
  example.createCriteria().andUser_idIn(ids);
  List<net.sourceforge.guacamole.net.auth.mysql.model.User> users=userDAO.selectByExample(example);
  for (  net.sourceforge.guacamole.net.auth.mysql.model.User user : users)   names.put(user.getUsername(),user.getUser_id());
  return names;
}","/** 
 * Retrieves a translation map of usernames to their corresponding IDs.
 * @param ids The IDs of the users to retrieve the usernames of.
 * @return A map containing the names of all users and their correspondingIDs.
 */
public Map<String,Integer> translateUsernames(List<Integer> ids){
  if (ids.isEmpty())   return Collections.EMPTY_MAP;
  Map<String,Integer> names=new HashMap<String,Integer>();
  UserExample example=new UserExample();
  example.createCriteria().andUser_idIn(ids);
  List<User> users=userDAO.selectByExample(example);
  for (  User user : users)   names.put(user.getUsername(),user.getUser_id());
  return names;
}"
52349,"/** 
 * Get the IDs of all the user defined in the system.
 * @return A list of IDs of all the users defined in the system.
 */
public List<Integer> getAllUserIDs(){
  List<Integer> userIDs=new ArrayList<Integer>();
  for (  MySQLUser user : getAllUsers()) {
    userIDs.add(user.getUserID());
  }
  return userIDs;
}","/** 
 * Get the user IDs of all the users defined in the system.
 * @return A list of user IDs of all the users defined in the system.
 */
public List<Integer> getAllUserIDs(){
  List<Integer> userIDs=new ArrayList<Integer>();
  List<User> users=userDAO.selectByExample(new UserExample());
  for (  User user : users)   userIDs.add(user.getUser_id());
  return userIDs;
}"
52350,"/** 
 * Produces a String containing the bytes provided in hexadecimal notation.
 * @param bytes The bytes to convert into hex.
 * @return A String containing the hex representation of the given bytes.
 */
private static String getHexString(byte[] bytes){
  if (bytes == null)   return null;
  StringBuilder hex=new StringBuilder(2 * bytes.length);
  for (  byte b : bytes) {
    hex.append(HEX_CHARS[(b & 0xF0) >> 4]).append(HEX_CHARS[(b & 0x0F)]);
  }
  return hex.toString();
}","/** 
 * Produces a String containing the bytes provided in hexadecimal notation.
 * @param bytes The bytes to convert into hex.
 * @return A String containing the hex representation of the given bytes.
 */
private static String getHexString(byte[] bytes){
  if (bytes == null)   return null;
  StringBuilder hex=new StringBuilder(2 * bytes.length);
  for (  byte b : bytes) {
    hex.append(HEX_CHARS[(b & 0xF0) >> 4]).append(HEX_CHARS[b & 0x0F]);
  }
  return hex.toString();
}"
52351,"@Override public GuacamoleInstruction readInstruction() throws GuacamoleException {
  char[] instructionBuffer=read();
  if (instructionBuffer == null)   return null;
  int elementStart=0;
  LinkedList<String> elements=new LinkedList<String>();
  while (elementStart < instructionBuffer.length) {
    int lengthEnd=-1;
    for (int i=elementStart; i < instructionBuffer.length; i++) {
      if (instructionBuffer[i] == '.') {
        lengthEnd=i;
        break;
      }
    }
    if (lengthEnd == -1)     throw new GuacamoleServerException(""String_Node_Str"");
    int length=Integer.parseInt(new String(instructionBuffer,elementStart,lengthEnd - elementStart));
    elementStart=lengthEnd + 1;
    String element=new String(instructionBuffer,elementStart,length);
    elements.addLast(element);
    elementStart+=length;
    char terminator=instructionBuffer[elementStart];
    elementStart++;
    if (terminator == ';')     break;
  }
  String opcode=elements.removeFirst();
  GuacamoleInstruction instruction=new GuacamoleInstruction(opcode,elements.toArray(new String[elements.size()]));
  return instruction;
}","@Override public GuacamoleInstruction readInstruction() throws GuacamoleException {
  char[] instructionBuffer=read();
  if (instructionBuffer == null)   return null;
  int elementStart=0;
  Deque<String> elements=new LinkedList<String>();
  while (elementStart < instructionBuffer.length) {
    int lengthEnd=-1;
    for (int i=elementStart; i < instructionBuffer.length; i++) {
      if (instructionBuffer[i] == '.') {
        lengthEnd=i;
        break;
      }
    }
    if (lengthEnd == -1)     throw new GuacamoleServerException(""String_Node_Str"");
    int length=Integer.parseInt(new String(instructionBuffer,elementStart,lengthEnd - elementStart));
    elementStart=lengthEnd + 1;
    String element=new String(instructionBuffer,elementStart,length);
    elements.addLast(element);
    elementStart+=length;
    char terminator=instructionBuffer[elementStart];
    elementStart++;
    if (terminator == ';')     break;
  }
  String opcode=elements.removeFirst();
  GuacamoleInstruction instruction=new GuacamoleInstruction(opcode,elements.toArray(new String[elements.size()]));
  return instruction;
}"
52352,"@Override public boolean equals(Object obj){
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  final UserPermission other=(UserPermission)obj;
  if (this.type != other.type)   return false;
  if (identifier == null)   return other.identifier != null;
  return identifier.equals(other.identifier);
}","@Override public boolean equals(Object obj){
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  final UserPermission other=(UserPermission)obj;
  if (this.type != other.type)   return false;
  if (identifier == null)   return other.identifier == null;
  return identifier.equals(other.identifier);
}"
52353,"@Override public boolean equals(Object obj){
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  final ConnectionPermission other=(ConnectionPermission)obj;
  if (this.type != other.type)   return false;
  if (identifier == null)   return other.identifier != null;
  return identifier.equals(other.identifier);
}","@Override public boolean equals(Object obj){
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  final ConnectionPermission other=(ConnectionPermission)obj;
  if (this.type != other.type)   return false;
  if (identifier == null)   return other.identifier == null;
  return identifier.equals(other.identifier);
}"
52354,"@Override protected Class<?> findClass(String name) throws ClassNotFoundException {
  if (classLoader == null)   return super.findClass(name);
  return classLoader.loadClass(name);
}","@Override protected Class<?> findClass(String name) throws ClassNotFoundException {
  if (classLoader == null)   return Class.forName(name);
  return classLoader.loadClass(name);
}"
52355,"@Override public File parseValue(String value) throws GuacamoleException {
  return new File(value);
}","@Override public File parseValue(String value) throws GuacamoleException {
  if (value != null)   return new File(value);
 else   return null;
}"
52356,"@Override public char[] read() throws GuacamoleException {
  try {
    for (; ; ) {
      if (usedLength > buffer.length / 2) {
        char[] biggerBuffer=new char[buffer.length * 2];
        System.arraycopy(buffer,0,biggerBuffer,0,usedLength);
        buffer=biggerBuffer;
      }
      int numRead=input.read(buffer,usedLength,buffer.length - usedLength);
      if (numRead == -1)       return null;
      int prevLength=usedLength;
      usedLength+=numRead;
      for (int i=usedLength - 1; i >= prevLength; i--) {
        char readChar=buffer[i];
        if (readChar == ';') {
          char[] chunk=new char[i + 1];
          System.arraycopy(buffer,0,chunk,0,i + 1);
          usedLength-=i + 1;
          System.arraycopy(buffer,i + 1,buffer,0,usedLength);
          return chunk;
        }
      }
    }
  }
 catch (  IOException e) {
    throw new GuacamoleException(e);
  }
}","@Override public char[] read() throws GuacamoleException {
  if (instructionBuffer != null) {
    char[] chunk=new char[instructionBuffer.length - instructionStart];
    System.arraycopy(instructionBuffer,instructionStart,chunk,0,chunk.length);
    instructionBuffer=null;
    return chunk;
  }
  try {
    for (; ; ) {
      if (usedLength > buffer.length / 2) {
        char[] biggerBuffer=new char[buffer.length * 2];
        System.arraycopy(buffer,0,biggerBuffer,0,usedLength);
        buffer=biggerBuffer;
      }
      int numRead=input.read(buffer,usedLength,buffer.length - usedLength);
      if (numRead == -1)       return null;
      int prevLength=usedLength;
      usedLength+=numRead;
      for (int i=usedLength - 1; i >= prevLength; i--) {
        char readChar=buffer[i];
        if (readChar == ';') {
          char[] chunk=new char[i + 1];
          System.arraycopy(buffer,0,chunk,0,i + 1);
          usedLength-=i + 1;
          System.arraycopy(buffer,i + 1,buffer,0,usedLength);
          return chunk;
        }
      }
    }
  }
 catch (  IOException e) {
    throw new GuacamoleException(e);
  }
}"
52357,"protected void doWrite(HttpServletRequest request,HttpServletResponse response) throws GuacamoleException {
  HttpSession httpSession=request.getSession(false);
  GuacamoleSession session=new GuacamoleSession(httpSession);
  try {
    Reader input=request.getReader();
    char[] buffer=new char[8192];
    int length;
    while ((length=input.read(buffer,0,buffer.length)) != -1)     session.getClient().write(buffer,0,length);
  }
 catch (  IOException e) {
    throw new GuacamoleException(""String_Node_Str"" + e.getMessage(),e);
  }
}","protected void doWrite(HttpServletRequest request,HttpServletResponse response) throws GuacamoleException {
  HttpSession httpSession=request.getSession(false);
  GuacamoleSession session=new GuacamoleSession(httpSession);
  response.setContentType(""String_Node_Str"");
  response.setContentLength(0);
  try {
    Reader input=request.getReader();
    char[] buffer=new char[8192];
    int length;
    while ((length=input.read(buffer,0,buffer.length)) != -1)     session.getClient().write(buffer,0,length);
  }
 catch (  IOException e) {
    throw new GuacamoleException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
52358,"@Override protected void handleRequest(GuacamoleSession session,HttpServletRequest request,HttpServletResponse response) throws GuacamoleException {
  ReentrantLock instructionStreamLock=session.getInstructionStreamLock();
  instructionStreamLock.lock();
  try {
    response.setContentType(""String_Node_Str"");
    Writer out=response.getWriter();
    try {
      Client client=session.getClient();
      char[] message;
      while ((message=client.read()) != null) {
        out.write(message,0,message.length);
        out.flush();
        response.flushBuffer();
        if (instructionStreamLock.hasQueuedThreads())         break;
      }
    }
 catch (    GuacamoleException e) {
      out.write(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
      out.flush();
      response.flushBuffer();
    }
    out.write(';');
    out.flush();
    response.flushBuffer();
  }
 catch (  UnsupportedEncodingException e) {
    throw new GuacamoleException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new GuacamoleException(""String_Node_Str"",e);
  }
 finally {
    instructionStreamLock.unlock();
  }
}","@Override protected void handleRequest(GuacamoleSession session,HttpServletRequest request,HttpServletResponse response) throws GuacamoleException {
  ReentrantLock instructionStreamLock=session.getInstructionStreamLock();
  instructionStreamLock.lock();
  try {
    response.setContentType(""String_Node_Str"");
    Writer out=response.getWriter();
    try {
      Client client=session.getClient();
      char[] message;
      while ((message=client.read()) != null) {
        out.write(message,0,message.length);
        out.flush();
        response.flushBuffer();
        if (instructionStreamLock.hasQueuedThreads())         break;
      }
      if (message == null) {
        session.disconnect();
        throw new GuacamoleException(""String_Node_Str"");
      }
    }
 catch (    GuacamoleException e) {
      out.write(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
      out.flush();
      response.flushBuffer();
    }
    out.write(';');
    out.flush();
    response.flushBuffer();
  }
 catch (  UnsupportedEncodingException e) {
    throw new GuacamoleException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new GuacamoleException(""String_Node_Str"",e);
  }
 finally {
    instructionStreamLock.unlock();
  }
}"
52359,"public Instruction nextInstruction(boolean blocking) throws GuacamoleException {
  try {
    while (blocking || input.ready()) {
      if (usedLength > buffer.length / 2) {
        char[] newbuffer=new char[buffer.length * 2];
        System.arraycopy(newbuffer,0,buffer,0,usedLength);
        buffer=newbuffer;
      }
      int numRead=input.read(buffer,usedLength,buffer.length - usedLength);
      if (numRead == -1)       return null;
      int prevLength=usedLength;
      usedLength+=numRead;
      for (int i=usedLength - 1; i >= prevLength; i--) {
        char readChar=buffer[i];
        if (readChar == ';') {
          final String instruction=new String(buffer,0,i + 1);
          usedLength-=i + 1;
          System.arraycopy(buffer,i + 1,buffer,0,usedLength);
          return new Instruction(){
            public String toString(){
              return instruction;
            }
          }
;
        }
      }
    }
  }
 catch (  IOException e) {
    throw new GuacamoleException(e);
  }
  return null;
}","public Instruction nextInstruction(boolean blocking) throws GuacamoleException {
  try {
    do {
      if (usedLength > buffer.length / 2) {
        char[] biggerBuffer=new char[buffer.length * 2];
        System.arraycopy(buffer,0,biggerBuffer,0,usedLength);
        buffer=biggerBuffer;
      }
      int numRead=input.read(buffer,usedLength,buffer.length - usedLength);
      if (numRead == -1)       return null;
      int prevLength=usedLength;
      usedLength+=numRead;
      for (int i=usedLength - 1; i >= prevLength; i--) {
        char readChar=buffer[i];
        if (readChar == ';') {
          final String instruction=new String(buffer,0,i + 1);
          usedLength-=i + 1;
          System.arraycopy(buffer,i + 1,buffer,0,usedLength);
          return new Instruction(){
            public String toString(){
              return instruction;
            }
          }
;
        }
      }
    }
 while (input.ready());
  }
 catch (  IOException e) {
    throw new GuacamoleException(e);
  }
  return null;
}"
52360,"/** 
 * Create a PGPPublicKey from the passed in JCA one. <p> Note: the time passed in affects the value of the key's keyID, so you probably only want to do this once for a JCA key, or make sure you keep track of the time you used. </p>
 * @param algorithm asymmetric algorithm type representing the public key.
 * @param pubKey    actual public key to associate.
 * @param time      date of creation.
 * @throws PGPException on key creation problem.
 */
public PGPPublicKey getPGPPublicKey(int algorithm,PGPAlgorithmParameters algorithmParameters,AsymmetricKeyParameter pubKey,Date time) throws PGPException {
  BCPGKey bcpgKey;
  if (pubKey instanceof RSAKeyParameters) {
    RSAKeyParameters rK=(RSAKeyParameters)pubKey;
    bcpgKey=new RSAPublicBCPGKey(rK.getModulus(),rK.getExponent());
  }
 else   if (pubKey instanceof DSAPublicKeyParameters) {
    DSAPublicKeyParameters dK=(DSAPublicKeyParameters)pubKey;
    DSAParameters dP=dK.getParameters();
    bcpgKey=new DSAPublicBCPGKey(dP.getP(),dP.getQ(),dP.getG(),dK.getY());
  }
 else   if (pubKey instanceof ElGamalPublicKeyParameters) {
    ElGamalPublicKeyParameters eK=(ElGamalPublicKeyParameters)pubKey;
    ElGamalParameters eS=eK.getParameters();
    bcpgKey=new ElGamalPublicBCPGKey(eS.getP(),eS.getG(),eK.getY());
  }
 else   if (pubKey instanceof ECPublicKeyParameters) {
    SubjectPublicKeyInfo keyInfo;
    try {
      keyInfo=SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(pubKey);
    }
 catch (    IOException e) {
      throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
    }
    ASN1ObjectIdentifier curveOid=ASN1ObjectIdentifier.getInstance(keyInfo.getAlgorithm().getParameters());
    X9ECParameters params=NISTNamedCurves.getByOID(curveOid);
    ASN1OctetString key=new DEROctetString(keyInfo.getPublicKeyData().getBytes());
    X9ECPoint derQ=new X9ECPoint(params.getCurve(),key);
    if (algorithm == PGPPublicKey.ECDH) {
      PGPKdfParameters kdfParams=(PGPKdfParameters)algorithmParameters;
      if (kdfParams == null) {
        kdfParams=new PGPKdfParameters(HashAlgorithmTags.SHA256,SymmetricKeyAlgorithmTags.AES_128);
      }
      bcpgKey=new ECDHPublicBCPGKey(curveOid,derQ.getPoint(),kdfParams.getHashAlgorithm(),kdfParams.getSymmetricWrapAlgorithm());
    }
 else     if (algorithm == PGPPublicKey.ECDSA) {
      bcpgKey=new ECDSAPublicBCPGKey(curveOid,derQ.getPoint());
    }
 else {
      throw new PGPException(""String_Node_Str"");
    }
  }
 else {
    throw new PGPException(""String_Node_Str"");
  }
  return new PGPPublicKey(new PublicKeyPacket(algorithm,time,bcpgKey),new BcKeyFingerprintCalculator());
}","/** 
 * Create a PGPPublicKey from the passed in JCA one. <p> Note: the time passed in affects the value of the key's keyID, so you probably only want to do this once for a JCA key, or make sure you keep track of the time you used. </p>
 * @param algorithm asymmetric algorithm type representing the public key.
 * @param pubKey    actual public key to associate.
 * @param time      date of creation.
 * @throws PGPException on key creation problem.
 */
public PGPPublicKey getPGPPublicKey(int algorithm,PGPAlgorithmParameters algorithmParameters,AsymmetricKeyParameter pubKey,Date time) throws PGPException {
  BCPGKey bcpgKey;
  if (pubKey instanceof RSAKeyParameters) {
    RSAKeyParameters rK=(RSAKeyParameters)pubKey;
    bcpgKey=new RSAPublicBCPGKey(rK.getModulus(),rK.getExponent());
  }
 else   if (pubKey instanceof DSAPublicKeyParameters) {
    DSAPublicKeyParameters dK=(DSAPublicKeyParameters)pubKey;
    DSAParameters dP=dK.getParameters();
    bcpgKey=new DSAPublicBCPGKey(dP.getP(),dP.getQ(),dP.getG(),dK.getY());
  }
 else   if (pubKey instanceof ElGamalPublicKeyParameters) {
    ElGamalPublicKeyParameters eK=(ElGamalPublicKeyParameters)pubKey;
    ElGamalParameters eS=eK.getParameters();
    bcpgKey=new ElGamalPublicBCPGKey(eS.getP(),eS.getG(),eK.getY());
  }
 else   if (pubKey instanceof ECPublicKeyParameters) {
    SubjectPublicKeyInfo keyInfo;
    try {
      keyInfo=SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(pubKey);
    }
 catch (    IOException e) {
      throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
    }
    ASN1ObjectIdentifier curveOid=ASN1ObjectIdentifier.getInstance(keyInfo.getAlgorithm().getParameters());
    X9ECParameters params=ECNamedCurveTable.getByOID(curveOid);
    ASN1OctetString key=new DEROctetString(keyInfo.getPublicKeyData().getBytes());
    X9ECPoint derQ=new X9ECPoint(params.getCurve(),key);
    if (algorithm == PGPPublicKey.ECDH) {
      PGPKdfParameters kdfParams=(PGPKdfParameters)algorithmParameters;
      if (kdfParams == null) {
        kdfParams=new PGPKdfParameters(HashAlgorithmTags.SHA256,SymmetricKeyAlgorithmTags.AES_128);
      }
      bcpgKey=new ECDHPublicBCPGKey(curveOid,derQ.getPoint(),kdfParams.getHashAlgorithm(),kdfParams.getSymmetricWrapAlgorithm());
    }
 else     if (algorithm == PGPPublicKey.ECDSA) {
      bcpgKey=new ECDSAPublicBCPGKey(curveOid,derQ.getPoint());
    }
 else {
      throw new PGPException(""String_Node_Str"");
    }
  }
 else {
    throw new PGPException(""String_Node_Str"");
  }
  return new PGPPublicKey(new PublicKeyPacket(algorithm,time,bcpgKey),new BcKeyFingerprintCalculator());
}"
52361,"public byte[] recoverSessionData(int keyAlgorithm,byte[][] secKeyData) throws PGPException {
  try {
    if (keyAlgorithm != PGPPublicKey.ECDH) {
      AsymmetricBlockCipher c=BcImplProvider.createPublicKeyCipher(keyAlgorithm);
      AsymmetricKeyParameter key=keyConverter.getPrivateKey(privKey);
      BufferedAsymmetricBlockCipher c1=new BufferedAsymmetricBlockCipher(c);
      c1.init(false,key);
      if (keyAlgorithm == PGPPublicKey.RSA_ENCRYPT || keyAlgorithm == PGPPublicKey.RSA_GENERAL) {
        byte[] bi=secKeyData[0];
        c1.processBytes(bi,2,bi.length - 2);
      }
 else {
        BcPGPKeyConverter converter=new BcPGPKeyConverter();
        ElGamalPrivateKeyParameters parms=(ElGamalPrivateKeyParameters)converter.getPrivateKey(privKey);
        int size=(parms.getParameters().getP().bitLength() + 7) / 8;
        byte[] tmp=new byte[size];
        byte[] bi=secKeyData[0];
        if (bi.length - 2 > size) {
          c1.processBytes(bi,3,bi.length - 3);
        }
 else {
          System.arraycopy(bi,2,tmp,tmp.length - (bi.length - 2),bi.length - 2);
          c1.processBytes(tmp,0,tmp.length);
        }
        bi=secKeyData[1];
        for (int i=0; i != tmp.length; i++) {
          tmp[i]=0;
        }
        if (bi.length - 2 > size) {
          c1.processBytes(bi,3,bi.length - 3);
        }
 else {
          System.arraycopy(bi,2,tmp,tmp.length - (bi.length - 2),bi.length - 2);
          c1.processBytes(tmp,0,tmp.length);
        }
      }
      return c1.doFinal();
    }
 else {
      ECDHPublicBCPGKey ecKey=(ECDHPublicBCPGKey)privKey.getPublicKeyPacket().getKey();
      X9ECParameters x9Params=NISTNamedCurves.getByOID(ecKey.getCurveOID());
      byte[] enc=secKeyData[0];
      int pLen=((((enc[0] & 0xff) << 8) + (enc[1] & 0xff)) + 7) / 8;
      byte[] pEnc=new byte[pLen];
      System.arraycopy(enc,2,pEnc,0,pLen);
      byte[] keyEnc=new byte[enc[pLen + 2]];
      System.arraycopy(enc,2 + pLen + 1,keyEnc,0,keyEnc.length);
      Wrapper c=BcImplProvider.createWrapper(ecKey.getSymmetricKeyAlgorithm());
      ECPoint S=x9Params.getCurve().decodePoint(pEnc).multiply(((ECSecretBCPGKey)privKey.getPrivateKeyDataPacket()).getX()).normalize();
      RFC6637KDFCalculator rfc6637KDFCalculator=new RFC6637KDFCalculator(new BcPGPDigestCalculatorProvider().get(ecKey.getHashAlgorithm()),ecKey.getSymmetricKeyAlgorithm());
      KeyParameter key=new KeyParameter(rfc6637KDFCalculator.createKey(S,RFC6637Utils.createUserKeyingMaterial(privKey.getPublicKeyPacket(),new BcKeyFingerprintCalculator())));
      c.init(false,key);
      return PGPPad.unpadSessionData(c.unwrap(keyEnc,0,keyEnc.length));
    }
  }
 catch (  IOException e) {
    throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  InvalidCipherTextException e) {
    throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
  }
}","public byte[] recoverSessionData(int keyAlgorithm,byte[][] secKeyData) throws PGPException {
  try {
    if (keyAlgorithm != PGPPublicKey.ECDH) {
      AsymmetricBlockCipher c=BcImplProvider.createPublicKeyCipher(keyAlgorithm);
      AsymmetricKeyParameter key=keyConverter.getPrivateKey(privKey);
      BufferedAsymmetricBlockCipher c1=new BufferedAsymmetricBlockCipher(c);
      c1.init(false,key);
      if (keyAlgorithm == PGPPublicKey.RSA_ENCRYPT || keyAlgorithm == PGPPublicKey.RSA_GENERAL) {
        byte[] bi=secKeyData[0];
        c1.processBytes(bi,2,bi.length - 2);
      }
 else {
        BcPGPKeyConverter converter=new BcPGPKeyConverter();
        ElGamalPrivateKeyParameters parms=(ElGamalPrivateKeyParameters)converter.getPrivateKey(privKey);
        int size=(parms.getParameters().getP().bitLength() + 7) / 8;
        byte[] tmp=new byte[size];
        byte[] bi=secKeyData[0];
        if (bi.length - 2 > size) {
          c1.processBytes(bi,3,bi.length - 3);
        }
 else {
          System.arraycopy(bi,2,tmp,tmp.length - (bi.length - 2),bi.length - 2);
          c1.processBytes(tmp,0,tmp.length);
        }
        bi=secKeyData[1];
        for (int i=0; i != tmp.length; i++) {
          tmp[i]=0;
        }
        if (bi.length - 2 > size) {
          c1.processBytes(bi,3,bi.length - 3);
        }
 else {
          System.arraycopy(bi,2,tmp,tmp.length - (bi.length - 2),bi.length - 2);
          c1.processBytes(tmp,0,tmp.length);
        }
      }
      return c1.doFinal();
    }
 else {
      ECDHPublicBCPGKey ecKey=(ECDHPublicBCPGKey)privKey.getPublicKeyPacket().getKey();
      X9ECParameters x9Params=ECNamedCurveTable.getByOID(ecKey.getCurveOID());
      byte[] enc=secKeyData[0];
      int pLen=((((enc[0] & 0xff) << 8) + (enc[1] & 0xff)) + 7) / 8;
      byte[] pEnc=new byte[pLen];
      System.arraycopy(enc,2,pEnc,0,pLen);
      byte[] keyEnc=new byte[enc[pLen + 2]];
      System.arraycopy(enc,2 + pLen + 1,keyEnc,0,keyEnc.length);
      Wrapper c=BcImplProvider.createWrapper(ecKey.getSymmetricKeyAlgorithm());
      ECPoint S=x9Params.getCurve().decodePoint(pEnc).multiply(((ECSecretBCPGKey)privKey.getPrivateKeyDataPacket()).getX()).normalize();
      RFC6637KDFCalculator rfc6637KDFCalculator=new RFC6637KDFCalculator(new BcPGPDigestCalculatorProvider().get(ecKey.getHashAlgorithm()),ecKey.getSymmetricKeyAlgorithm());
      KeyParameter key=new KeyParameter(rfc6637KDFCalculator.createKey(S,RFC6637Utils.createUserKeyingMaterial(privKey.getPublicKeyPacket(),new BcKeyFingerprintCalculator())));
      c.init(false,key);
      return PGPPad.unpadSessionData(c.unwrap(keyEnc,0,keyEnc.length));
    }
  }
 catch (  IOException e) {
    throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  InvalidCipherTextException e) {
    throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
52362,"public PrivateKey getPrivateKey(PGPPrivateKey privKey) throws PGPException {
  if (privKey instanceof JcaPGPPrivateKey) {
    return ((JcaPGPPrivateKey)privKey).getPrivateKey();
  }
  PublicKeyPacket pubPk=privKey.getPublicKeyPacket();
  BCPGKey privPk=privKey.getPrivateKeyDataPacket();
  try {
    KeyFactory fact;
switch (pubPk.getAlgorithm()) {
case PGPPublicKey.RSA_ENCRYPT:
case PGPPublicKey.RSA_GENERAL:
case PGPPublicKey.RSA_SIGN:
      RSAPublicBCPGKey rsaPub=(RSAPublicBCPGKey)pubPk.getKey();
    RSASecretBCPGKey rsaPriv=(RSASecretBCPGKey)privPk;
  RSAPrivateCrtKeySpec rsaPrivSpec=new RSAPrivateCrtKeySpec(rsaPriv.getModulus(),rsaPub.getPublicExponent(),rsaPriv.getPrivateExponent(),rsaPriv.getPrimeP(),rsaPriv.getPrimeQ(),rsaPriv.getPrimeExponentP(),rsaPriv.getPrimeExponentQ(),rsaPriv.getCrtCoefficient());
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(rsaPrivSpec);
case PGPPublicKey.DSA:
DSAPublicBCPGKey dsaPub=(DSAPublicBCPGKey)pubPk.getKey();
DSASecretBCPGKey dsaPriv=(DSASecretBCPGKey)privPk;
DSAPrivateKeySpec dsaPrivSpec=new DSAPrivateKeySpec(dsaPriv.getX(),dsaPub.getP(),dsaPub.getQ(),dsaPub.getG());
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(dsaPrivSpec);
case PublicKeyAlgorithmTags.ECDH:
ECDHPublicBCPGKey ecdhPub=(ECDHPublicBCPGKey)pubPk.getKey();
ECSecretBCPGKey ecdhK=(ECSecretBCPGKey)privPk;
ECPrivateKeySpec ecDhSpec=new ECPrivateKeySpec(ecdhK.getX(),convertX9Parameters(ecdhPub.getCurveOID(),NISTNamedCurves.getByOID(ecdhPub.getCurveOID())));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(ecDhSpec);
case PublicKeyAlgorithmTags.ECDSA:
ECDSAPublicBCPGKey ecdsaPub=(ECDSAPublicBCPGKey)pubPk.getKey();
ECSecretBCPGKey ecdsaK=(ECSecretBCPGKey)privPk;
ECPrivateKeySpec ecDsaSpec=new ECPrivateKeySpec(ecdsaK.getX(),convertX9Parameters(ecdsaPub.getCurveOID(),NISTNamedCurves.getByOID(ecdsaPub.getCurveOID())));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(ecDsaSpec);
case PGPPublicKey.ELGAMAL_ENCRYPT:
case PGPPublicKey.ELGAMAL_GENERAL:
ElGamalPublicBCPGKey elPub=(ElGamalPublicBCPGKey)pubPk.getKey();
ElGamalSecretBCPGKey elPriv=(ElGamalSecretBCPGKey)privPk;
ElGamalPrivateKeySpec elSpec=new ElGamalPrivateKeySpec(elPriv.getX(),new ElGamalParameterSpec(elPub.getP(),elPub.getG()));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(elSpec);
default :
throw new PGPException(""String_Node_Str"");
}
}
 catch (PGPException e) {
throw e;
}
catch (Exception e) {
throw new PGPException(""String_Node_Str"",e);
}
}","public PrivateKey getPrivateKey(PGPPrivateKey privKey) throws PGPException {
  if (privKey instanceof JcaPGPPrivateKey) {
    return ((JcaPGPPrivateKey)privKey).getPrivateKey();
  }
  PublicKeyPacket pubPk=privKey.getPublicKeyPacket();
  BCPGKey privPk=privKey.getPrivateKeyDataPacket();
  try {
    KeyFactory fact;
switch (pubPk.getAlgorithm()) {
case PGPPublicKey.RSA_ENCRYPT:
case PGPPublicKey.RSA_GENERAL:
case PGPPublicKey.RSA_SIGN:
      RSAPublicBCPGKey rsaPub=(RSAPublicBCPGKey)pubPk.getKey();
    RSASecretBCPGKey rsaPriv=(RSASecretBCPGKey)privPk;
  RSAPrivateCrtKeySpec rsaPrivSpec=new RSAPrivateCrtKeySpec(rsaPriv.getModulus(),rsaPub.getPublicExponent(),rsaPriv.getPrivateExponent(),rsaPriv.getPrimeP(),rsaPriv.getPrimeQ(),rsaPriv.getPrimeExponentP(),rsaPriv.getPrimeExponentQ(),rsaPriv.getCrtCoefficient());
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(rsaPrivSpec);
case PGPPublicKey.DSA:
DSAPublicBCPGKey dsaPub=(DSAPublicBCPGKey)pubPk.getKey();
DSASecretBCPGKey dsaPriv=(DSASecretBCPGKey)privPk;
DSAPrivateKeySpec dsaPrivSpec=new DSAPrivateKeySpec(dsaPriv.getX(),dsaPub.getP(),dsaPub.getQ(),dsaPub.getG());
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(dsaPrivSpec);
case PublicKeyAlgorithmTags.ECDH:
ECDHPublicBCPGKey ecdhPub=(ECDHPublicBCPGKey)pubPk.getKey();
ECSecretBCPGKey ecdhK=(ECSecretBCPGKey)privPk;
ECPrivateKeySpec ecDhSpec=new ECPrivateKeySpec(ecdhK.getX(),convertX9Parameters(ecdhPub.getCurveOID(),ECNamedCurveTable.getByOID(ecdhPub.getCurveOID())));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(ecDhSpec);
case PublicKeyAlgorithmTags.ECDSA:
ECDSAPublicBCPGKey ecdsaPub=(ECDSAPublicBCPGKey)pubPk.getKey();
ECSecretBCPGKey ecdsaK=(ECSecretBCPGKey)privPk;
ECPrivateKeySpec ecDsaSpec=new ECPrivateKeySpec(ecdsaK.getX(),convertX9Parameters(ecdsaPub.getCurveOID(),ECNamedCurveTable.getByOID(ecdsaPub.getCurveOID())));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(ecDsaSpec);
case PGPPublicKey.ELGAMAL_ENCRYPT:
case PGPPublicKey.ELGAMAL_GENERAL:
ElGamalPublicBCPGKey elPub=(ElGamalPublicBCPGKey)pubPk.getKey();
ElGamalSecretBCPGKey elPriv=(ElGamalSecretBCPGKey)privPk;
ElGamalPrivateKeySpec elSpec=new ElGamalPrivateKeySpec(elPriv.getX(),new ElGamalParameterSpec(elPub.getP(),elPub.getG()));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(elSpec);
default :
throw new PGPException(""String_Node_Str"");
}
}
 catch (PGPException e) {
throw e;
}
catch (Exception e) {
throw new PGPException(""String_Node_Str"",e);
}
}"
52363,"private void encryptDecryptBCTest() throws Exception {
  byte[] text={(byte)'h',(byte)'e',(byte)'l',(byte)'l',(byte)'o',(byte)' ',(byte)'w',(byte)'o',(byte)'r',(byte)'l',(byte)'d',(byte)'!',(byte)'\n'};
  ECKeyPairGenerator keyGen=new ECKeyPairGenerator();
  X9ECParameters x9ECParameters=NISTNamedCurves.getByName(""String_Node_Str"");
  keyGen.init(new ECKeyGenerationParameters(new ECNamedDomainParameters(NISTNamedCurves.getOID(""String_Node_Str""),x9ECParameters.getCurve(),x9ECParameters.getG(),x9ECParameters.getN()),new SecureRandom()));
  AsymmetricCipherKeyPair kpEnc=keyGen.generateKeyPair();
  PGPKeyPair ecdhKeyPair=new BcPGPKeyPair(PGPPublicKey.ECDH,kpEnc,new Date());
  PGPLiteralDataGenerator lData=new PGPLiteralDataGenerator();
  ByteArrayOutputStream ldOut=new ByteArrayOutputStream();
  OutputStream pOut=lData.open(ldOut,PGPLiteralDataGenerator.UTF8,PGPLiteralData.CONSOLE,text.length,new Date());
  pOut.write(text);
  pOut.close();
  byte[] data=ldOut.toByteArray();
  ByteArrayOutputStream cbOut=new ByteArrayOutputStream();
  PGPEncryptedDataGenerator cPk=new PGPEncryptedDataGenerator(new BcPGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.CAST5).setSecureRandom(new SecureRandom()));
  cPk.addMethod(new BcPublicKeyKeyEncryptionMethodGenerator(ecdhKeyPair.getPublicKey()));
  OutputStream cOut=cPk.open(new UncloseableOutputStream(cbOut),data.length);
  cOut.write(data);
  cOut.close();
  JcaPGPObjectFactory pgpF=new JcaPGPObjectFactory(cbOut.toByteArray());
  PGPEncryptedDataList encList=(PGPEncryptedDataList)pgpF.nextObject();
  PGPPublicKeyEncryptedData encP=(PGPPublicKeyEncryptedData)encList.get(0);
  InputStream clear=encP.getDataStream(new BcPublicKeyDataDecryptorFactory(ecdhKeyPair.getPrivateKey()));
  pgpF=new JcaPGPObjectFactory(clear);
  PGPLiteralData ld=(PGPLiteralData)pgpF.nextObject();
  clear=ld.getInputStream();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  int ch;
  while ((ch=clear.read()) >= 0) {
    bOut.write(ch);
  }
  byte[] out=bOut.toByteArray();
  if (!areEqual(out,text)) {
    fail(""String_Node_Str"");
  }
}","private void encryptDecryptBCTest(final String curve) throws Exception {
  byte[] text={(byte)'h',(byte)'e',(byte)'l',(byte)'l',(byte)'o',(byte)' ',(byte)'w',(byte)'o',(byte)'r',(byte)'l',(byte)'d',(byte)'!',(byte)'\n'};
  ECKeyPairGenerator keyGen=new ECKeyPairGenerator();
  X9ECParameters x9ECParameters=ECNamedCurveTable.getByName(curve);
  keyGen.init(new ECKeyGenerationParameters(new ECNamedDomainParameters(ECNamedCurveTable.getOID(curve),x9ECParameters.getCurve(),x9ECParameters.getG(),x9ECParameters.getN()),new SecureRandom()));
  AsymmetricCipherKeyPair kpEnc=keyGen.generateKeyPair();
  PGPKeyPair ecdhKeyPair=new BcPGPKeyPair(PGPPublicKey.ECDH,kpEnc,new Date());
  PGPLiteralDataGenerator lData=new PGPLiteralDataGenerator();
  ByteArrayOutputStream ldOut=new ByteArrayOutputStream();
  OutputStream pOut=lData.open(ldOut,PGPLiteralDataGenerator.UTF8,PGPLiteralData.CONSOLE,text.length,new Date());
  pOut.write(text);
  pOut.close();
  byte[] data=ldOut.toByteArray();
  ByteArrayOutputStream cbOut=new ByteArrayOutputStream();
  PGPEncryptedDataGenerator cPk=new PGPEncryptedDataGenerator(new BcPGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.CAST5).setSecureRandom(new SecureRandom()));
  cPk.addMethod(new BcPublicKeyKeyEncryptionMethodGenerator(ecdhKeyPair.getPublicKey()));
  OutputStream cOut=cPk.open(new UncloseableOutputStream(cbOut),data.length);
  cOut.write(data);
  cOut.close();
  JcaPGPObjectFactory pgpF=new JcaPGPObjectFactory(cbOut.toByteArray());
  PGPEncryptedDataList encList=(PGPEncryptedDataList)pgpF.nextObject();
  PGPPublicKeyEncryptedData encP=(PGPPublicKeyEncryptedData)encList.get(0);
  InputStream clear=encP.getDataStream(new BcPublicKeyDataDecryptorFactory(ecdhKeyPair.getPrivateKey()));
  pgpF=new JcaPGPObjectFactory(clear);
  PGPLiteralData ld=(PGPLiteralData)pgpF.nextObject();
  clear=ld.getInputStream();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  int ch;
  while ((ch=clear.read()) >= 0) {
    bOut.write(ch);
  }
  byte[] out=bOut.toByteArray();
  if (!areEqual(out,text)) {
    fail(""String_Node_Str"");
  }
}"
52364,"public void performTest() throws Exception {
  PGPPublicKeyRing pubKeyRing=new PGPPublicKeyRing(testPubKey,new JcaKeyFingerprintCalculator());
  doBasicKeyRingCheck(pubKeyRing);
  PGPSecretKeyRing secretKeyRing=new PGPSecretKeyRing(testPrivKey,new JcaKeyFingerprintCalculator());
  testDecrypt(secretKeyRing);
  encryptDecryptTest();
  encryptDecryptBCTest();
  generate();
}","public void performTest() throws Exception {
  PGPPublicKeyRing pubKeyRing=new PGPPublicKeyRing(testPubKey,new JcaKeyFingerprintCalculator());
  doBasicKeyRingCheck(pubKeyRing);
  PGPSecretKeyRing secretKeyRing=new PGPSecretKeyRing(testPrivKey,new JcaKeyFingerprintCalculator());
  testDecrypt(secretKeyRing);
  encryptDecryptTest();
  encryptDecryptBCTest(""String_Node_Str"");
  encryptDecryptBCTest(""String_Node_Str"");
  generate();
}"
52365,"public static String getCurveName(ASN1ObjectIdentifier oid){
  String name=X962NamedCurves.getName(oid);
  if (name == null) {
    name=SECNamedCurves.getName(oid);
    if (name == null) {
      name=NISTNamedCurves.getName(oid);
    }
    if (name == null) {
      name=TeleTrusTNamedCurves.getName(oid);
    }
    if (name == null) {
      name=ECGOST3410NamedCurves.getName(oid);
    }
    if (name == null) {
      name=ANSSINamedCurves.getName(oid);
    }
    if (name == null) {
      name=GMNamedCurves.getName(oid);
    }
  }
  return name;
}","public static String getCurveName(ASN1ObjectIdentifier oid){
  String name=X962NamedCurves.getName(oid);
  if (name == null) {
    name=SECNamedCurves.getName(oid);
    if (name == null) {
      name=NISTNamedCurves.getName(oid);
    }
    if (name == null) {
      name=TeleTrusTNamedCurves.getName(oid);
    }
    if (name == null) {
      name=ECGOST3410NamedCurves.getName(oid);
    }
    if (name == null) {
      name=ANSSINamedCurves.getName(oid);
    }
    if (name == null) {
      name=GMNamedCurves.getName(oid);
    }
    if (name == null) {
      name=ECNamedCurveTable.getName(oid);
    }
  }
  return name;
}"
52366,"public static X9ECParameters getNamedCurveByOid(ASN1ObjectIdentifier oid){
  X9ECParameters params=CustomNamedCurves.getByOID(oid);
  if (params == null) {
    params=X962NamedCurves.getByOID(oid);
    if (params == null) {
      params=SECNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=NISTNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=TeleTrusTNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=ANSSINamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=GMNamedCurves.getByOID(oid);
    }
  }
  return params;
}","public static X9ECParameters getNamedCurveByOid(ASN1ObjectIdentifier oid){
  X9ECParameters params=CustomNamedCurves.getByOID(oid);
  if (params == null) {
    params=X962NamedCurves.getByOID(oid);
    if (params == null) {
      params=SECNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=NISTNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=TeleTrusTNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=ANSSINamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=GMNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=ECNamedCurveTable.getByOID(oid);
    }
  }
  return params;
}"
52367,"public static X9ECParameters getNamedCurveByName(String curveName){
  X9ECParameters params=CustomNamedCurves.getByName(curveName);
  if (params == null) {
    params=X962NamedCurves.getByName(curveName);
    if (params == null) {
      params=SECNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=NISTNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=TeleTrusTNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=ANSSINamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=GMNamedCurves.getByName(curveName);
    }
  }
  return params;
}","public static X9ECParameters getNamedCurveByName(String curveName){
  X9ECParameters params=CustomNamedCurves.getByName(curveName);
  if (params == null) {
    params=X962NamedCurves.getByName(curveName);
    if (params == null) {
      params=SECNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=NISTNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=TeleTrusTNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=ANSSINamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=GMNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=ECNamedCurveTable.getByName(curveName);
    }
  }
  return params;
}"
52368,"private static ASN1ObjectIdentifier lookupOidByName(String name){
  ASN1ObjectIdentifier oid=X962NamedCurves.getOID(name);
  if (oid == null) {
    oid=SECNamedCurves.getOID(name);
    if (oid == null) {
      oid=NISTNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=TeleTrusTNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ECGOST3410NamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ANSSINamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=GMNamedCurves.getOID(name);
    }
  }
  return oid;
}","private static ASN1ObjectIdentifier lookupOidByName(String name){
  ASN1ObjectIdentifier oid=X962NamedCurves.getOID(name);
  if (oid == null) {
    oid=SECNamedCurves.getOID(name);
    if (oid == null) {
      oid=NISTNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=TeleTrusTNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ECGOST3410NamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ANSSINamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=GMNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ECNamedCurveTable.getOID(name);
    }
  }
  return oid;
}"
52369,"/** 
 * Create a PGPPublicKey from the passed in JCA one. <p> Note: the time passed in affects the value of the key's keyID, so you probably only want to do this once for a JCA key, or make sure you keep track of the time you used. </p>
 * @param algorithm asymmetric algorithm type representing the public key.
 * @param pubKey    actual public key to associate.
 * @param time      date of creation.
 * @throws PGPException on key creation problem.
 */
public PGPPublicKey getPGPPublicKey(int algorithm,PGPAlgorithmParameters algorithmParameters,AsymmetricKeyParameter pubKey,Date time) throws PGPException {
  BCPGKey bcpgKey;
  if (pubKey instanceof RSAKeyParameters) {
    RSAKeyParameters rK=(RSAKeyParameters)pubKey;
    bcpgKey=new RSAPublicBCPGKey(rK.getModulus(),rK.getExponent());
  }
 else   if (pubKey instanceof DSAPublicKeyParameters) {
    DSAPublicKeyParameters dK=(DSAPublicKeyParameters)pubKey;
    DSAParameters dP=dK.getParameters();
    bcpgKey=new DSAPublicBCPGKey(dP.getP(),dP.getQ(),dP.getG(),dK.getY());
  }
 else   if (pubKey instanceof ElGamalPublicKeyParameters) {
    ElGamalPublicKeyParameters eK=(ElGamalPublicKeyParameters)pubKey;
    ElGamalParameters eS=eK.getParameters();
    bcpgKey=new ElGamalPublicBCPGKey(eS.getP(),eS.getG(),eK.getY());
  }
 else   if (pubKey instanceof ECPublicKeyParameters) {
    SubjectPublicKeyInfo keyInfo;
    try {
      keyInfo=SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(pubKey);
    }
 catch (    IOException e) {
      throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
    }
    ASN1ObjectIdentifier curveOid=ASN1ObjectIdentifier.getInstance(keyInfo.getAlgorithm().getParameters());
    X9ECParameters params=NISTNamedCurves.getByOID(curveOid);
    ASN1OctetString key=new DEROctetString(keyInfo.getPublicKeyData().getBytes());
    X9ECPoint derQ=new X9ECPoint(params.getCurve(),key);
    if (algorithm == PGPPublicKey.ECDH) {
      PGPKdfParameters kdfParams=(PGPKdfParameters)algorithmParameters;
      if (kdfParams == null) {
        kdfParams=new PGPKdfParameters(HashAlgorithmTags.SHA256,SymmetricKeyAlgorithmTags.AES_128);
      }
      bcpgKey=new ECDHPublicBCPGKey(curveOid,derQ.getPoint(),kdfParams.getHashAlgorithm(),kdfParams.getSymmetricWrapAlgorithm());
    }
 else     if (algorithm == PGPPublicKey.ECDSA) {
      bcpgKey=new ECDSAPublicBCPGKey(curveOid,derQ.getPoint());
    }
 else {
      throw new PGPException(""String_Node_Str"");
    }
  }
 else {
    throw new PGPException(""String_Node_Str"");
  }
  return new PGPPublicKey(new PublicKeyPacket(algorithm,time,bcpgKey),new BcKeyFingerprintCalculator());
}","/** 
 * Create a PGPPublicKey from the passed in JCA one. <p> Note: the time passed in affects the value of the key's keyID, so you probably only want to do this once for a JCA key, or make sure you keep track of the time you used. </p>
 * @param algorithm asymmetric algorithm type representing the public key.
 * @param pubKey    actual public key to associate.
 * @param time      date of creation.
 * @throws PGPException on key creation problem.
 */
public PGPPublicKey getPGPPublicKey(int algorithm,PGPAlgorithmParameters algorithmParameters,AsymmetricKeyParameter pubKey,Date time) throws PGPException {
  BCPGKey bcpgKey;
  if (pubKey instanceof RSAKeyParameters) {
    RSAKeyParameters rK=(RSAKeyParameters)pubKey;
    bcpgKey=new RSAPublicBCPGKey(rK.getModulus(),rK.getExponent());
  }
 else   if (pubKey instanceof DSAPublicKeyParameters) {
    DSAPublicKeyParameters dK=(DSAPublicKeyParameters)pubKey;
    DSAParameters dP=dK.getParameters();
    bcpgKey=new DSAPublicBCPGKey(dP.getP(),dP.getQ(),dP.getG(),dK.getY());
  }
 else   if (pubKey instanceof ElGamalPublicKeyParameters) {
    ElGamalPublicKeyParameters eK=(ElGamalPublicKeyParameters)pubKey;
    ElGamalParameters eS=eK.getParameters();
    bcpgKey=new ElGamalPublicBCPGKey(eS.getP(),eS.getG(),eK.getY());
  }
 else   if (pubKey instanceof ECPublicKeyParameters) {
    SubjectPublicKeyInfo keyInfo;
    try {
      keyInfo=SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(pubKey);
    }
 catch (    IOException e) {
      throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
    }
    ASN1ObjectIdentifier curveOid=ASN1ObjectIdentifier.getInstance(keyInfo.getAlgorithm().getParameters());
    X9ECParameters params=ECNamedCurveTable.getByOID(curveOid);
    ASN1OctetString key=new DEROctetString(keyInfo.getPublicKeyData().getBytes());
    X9ECPoint derQ=new X9ECPoint(params.getCurve(),key);
    if (algorithm == PGPPublicKey.ECDH) {
      PGPKdfParameters kdfParams=(PGPKdfParameters)algorithmParameters;
      if (kdfParams == null) {
        kdfParams=new PGPKdfParameters(HashAlgorithmTags.SHA256,SymmetricKeyAlgorithmTags.AES_128);
      }
      bcpgKey=new ECDHPublicBCPGKey(curveOid,derQ.getPoint(),kdfParams.getHashAlgorithm(),kdfParams.getSymmetricWrapAlgorithm());
    }
 else     if (algorithm == PGPPublicKey.ECDSA) {
      bcpgKey=new ECDSAPublicBCPGKey(curveOid,derQ.getPoint());
    }
 else {
      throw new PGPException(""String_Node_Str"");
    }
  }
 else {
    throw new PGPException(""String_Node_Str"");
  }
  return new PGPPublicKey(new PublicKeyPacket(algorithm,time,bcpgKey),new BcKeyFingerprintCalculator());
}"
52370,"public byte[] recoverSessionData(int keyAlgorithm,byte[][] secKeyData) throws PGPException {
  try {
    if (keyAlgorithm != PGPPublicKey.ECDH) {
      AsymmetricBlockCipher c=BcImplProvider.createPublicKeyCipher(keyAlgorithm);
      AsymmetricKeyParameter key=keyConverter.getPrivateKey(privKey);
      BufferedAsymmetricBlockCipher c1=new BufferedAsymmetricBlockCipher(c);
      c1.init(false,key);
      if (keyAlgorithm == PGPPublicKey.RSA_ENCRYPT || keyAlgorithm == PGPPublicKey.RSA_GENERAL) {
        byte[] bi=secKeyData[0];
        c1.processBytes(bi,2,bi.length - 2);
      }
 else {
        BcPGPKeyConverter converter=new BcPGPKeyConverter();
        ElGamalPrivateKeyParameters parms=(ElGamalPrivateKeyParameters)converter.getPrivateKey(privKey);
        int size=(parms.getParameters().getP().bitLength() + 7) / 8;
        byte[] tmp=new byte[size];
        byte[] bi=secKeyData[0];
        if (bi.length - 2 > size) {
          c1.processBytes(bi,3,bi.length - 3);
        }
 else {
          System.arraycopy(bi,2,tmp,tmp.length - (bi.length - 2),bi.length - 2);
          c1.processBytes(tmp,0,tmp.length);
        }
        bi=secKeyData[1];
        for (int i=0; i != tmp.length; i++) {
          tmp[i]=0;
        }
        if (bi.length - 2 > size) {
          c1.processBytes(bi,3,bi.length - 3);
        }
 else {
          System.arraycopy(bi,2,tmp,tmp.length - (bi.length - 2),bi.length - 2);
          c1.processBytes(tmp,0,tmp.length);
        }
      }
      return c1.doFinal();
    }
 else {
      ECDHPublicBCPGKey ecKey=(ECDHPublicBCPGKey)privKey.getPublicKeyPacket().getKey();
      X9ECParameters x9Params=NISTNamedCurves.getByOID(ecKey.getCurveOID());
      byte[] enc=secKeyData[0];
      int pLen=((((enc[0] & 0xff) << 8) + (enc[1] & 0xff)) + 7) / 8;
      byte[] pEnc=new byte[pLen];
      System.arraycopy(enc,2,pEnc,0,pLen);
      byte[] keyEnc=new byte[enc[pLen + 2]];
      System.arraycopy(enc,2 + pLen + 1,keyEnc,0,keyEnc.length);
      Wrapper c=BcImplProvider.createWrapper(ecKey.getSymmetricKeyAlgorithm());
      ECPoint S=x9Params.getCurve().decodePoint(pEnc).multiply(((ECSecretBCPGKey)privKey.getPrivateKeyDataPacket()).getX()).normalize();
      RFC6637KDFCalculator rfc6637KDFCalculator=new RFC6637KDFCalculator(new BcPGPDigestCalculatorProvider().get(ecKey.getHashAlgorithm()),ecKey.getSymmetricKeyAlgorithm());
      KeyParameter key=new KeyParameter(rfc6637KDFCalculator.createKey(S,RFC6637Utils.createUserKeyingMaterial(privKey.getPublicKeyPacket(),new BcKeyFingerprintCalculator())));
      c.init(false,key);
      return PGPPad.unpadSessionData(c.unwrap(keyEnc,0,keyEnc.length));
    }
  }
 catch (  IOException e) {
    throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  InvalidCipherTextException e) {
    throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
  }
}","public byte[] recoverSessionData(int keyAlgorithm,byte[][] secKeyData) throws PGPException {
  try {
    if (keyAlgorithm != PGPPublicKey.ECDH) {
      AsymmetricBlockCipher c=BcImplProvider.createPublicKeyCipher(keyAlgorithm);
      AsymmetricKeyParameter key=keyConverter.getPrivateKey(privKey);
      BufferedAsymmetricBlockCipher c1=new BufferedAsymmetricBlockCipher(c);
      c1.init(false,key);
      if (keyAlgorithm == PGPPublicKey.RSA_ENCRYPT || keyAlgorithm == PGPPublicKey.RSA_GENERAL) {
        byte[] bi=secKeyData[0];
        c1.processBytes(bi,2,bi.length - 2);
      }
 else {
        BcPGPKeyConverter converter=new BcPGPKeyConverter();
        ElGamalPrivateKeyParameters parms=(ElGamalPrivateKeyParameters)converter.getPrivateKey(privKey);
        int size=(parms.getParameters().getP().bitLength() + 7) / 8;
        byte[] tmp=new byte[size];
        byte[] bi=secKeyData[0];
        if (bi.length - 2 > size) {
          c1.processBytes(bi,3,bi.length - 3);
        }
 else {
          System.arraycopy(bi,2,tmp,tmp.length - (bi.length - 2),bi.length - 2);
          c1.processBytes(tmp,0,tmp.length);
        }
        bi=secKeyData[1];
        for (int i=0; i != tmp.length; i++) {
          tmp[i]=0;
        }
        if (bi.length - 2 > size) {
          c1.processBytes(bi,3,bi.length - 3);
        }
 else {
          System.arraycopy(bi,2,tmp,tmp.length - (bi.length - 2),bi.length - 2);
          c1.processBytes(tmp,0,tmp.length);
        }
      }
      return c1.doFinal();
    }
 else {
      ECDHPublicBCPGKey ecKey=(ECDHPublicBCPGKey)privKey.getPublicKeyPacket().getKey();
      X9ECParameters x9Params=ECNamedCurveTable.getByOID(ecKey.getCurveOID());
      byte[] enc=secKeyData[0];
      int pLen=((((enc[0] & 0xff) << 8) + (enc[1] & 0xff)) + 7) / 8;
      byte[] pEnc=new byte[pLen];
      System.arraycopy(enc,2,pEnc,0,pLen);
      byte[] keyEnc=new byte[enc[pLen + 2]];
      System.arraycopy(enc,2 + pLen + 1,keyEnc,0,keyEnc.length);
      Wrapper c=BcImplProvider.createWrapper(ecKey.getSymmetricKeyAlgorithm());
      ECPoint S=x9Params.getCurve().decodePoint(pEnc).multiply(((ECSecretBCPGKey)privKey.getPrivateKeyDataPacket()).getX()).normalize();
      RFC6637KDFCalculator rfc6637KDFCalculator=new RFC6637KDFCalculator(new BcPGPDigestCalculatorProvider().get(ecKey.getHashAlgorithm()),ecKey.getSymmetricKeyAlgorithm());
      KeyParameter key=new KeyParameter(rfc6637KDFCalculator.createKey(S,RFC6637Utils.createUserKeyingMaterial(privKey.getPublicKeyPacket(),new BcKeyFingerprintCalculator())));
      c.init(false,key);
      return PGPPad.unpadSessionData(c.unwrap(keyEnc,0,keyEnc.length));
    }
  }
 catch (  IOException e) {
    throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  InvalidCipherTextException e) {
    throw new PGPException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
52371,"public PrivateKey getPrivateKey(PGPPrivateKey privKey) throws PGPException {
  if (privKey instanceof JcaPGPPrivateKey) {
    return ((JcaPGPPrivateKey)privKey).getPrivateKey();
  }
  PublicKeyPacket pubPk=privKey.getPublicKeyPacket();
  BCPGKey privPk=privKey.getPrivateKeyDataPacket();
  try {
    KeyFactory fact;
switch (pubPk.getAlgorithm()) {
case PGPPublicKey.RSA_ENCRYPT:
case PGPPublicKey.RSA_GENERAL:
case PGPPublicKey.RSA_SIGN:
      RSAPublicBCPGKey rsaPub=(RSAPublicBCPGKey)pubPk.getKey();
    RSASecretBCPGKey rsaPriv=(RSASecretBCPGKey)privPk;
  RSAPrivateCrtKeySpec rsaPrivSpec=new RSAPrivateCrtKeySpec(rsaPriv.getModulus(),rsaPub.getPublicExponent(),rsaPriv.getPrivateExponent(),rsaPriv.getPrimeP(),rsaPriv.getPrimeQ(),rsaPriv.getPrimeExponentP(),rsaPriv.getPrimeExponentQ(),rsaPriv.getCrtCoefficient());
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(rsaPrivSpec);
case PGPPublicKey.DSA:
DSAPublicBCPGKey dsaPub=(DSAPublicBCPGKey)pubPk.getKey();
DSASecretBCPGKey dsaPriv=(DSASecretBCPGKey)privPk;
DSAPrivateKeySpec dsaPrivSpec=new DSAPrivateKeySpec(dsaPriv.getX(),dsaPub.getP(),dsaPub.getQ(),dsaPub.getG());
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(dsaPrivSpec);
case PublicKeyAlgorithmTags.ECDH:
ECDHPublicBCPGKey ecdhPub=(ECDHPublicBCPGKey)pubPk.getKey();
ECSecretBCPGKey ecdhK=(ECSecretBCPGKey)privPk;
ECPrivateKeySpec ecDhSpec=new ECPrivateKeySpec(ecdhK.getX(),convertX9Parameters(ecdhPub.getCurveOID(),NISTNamedCurves.getByOID(ecdhPub.getCurveOID())));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(ecDhSpec);
case PublicKeyAlgorithmTags.ECDSA:
ECDSAPublicBCPGKey ecdsaPub=(ECDSAPublicBCPGKey)pubPk.getKey();
ECSecretBCPGKey ecdsaK=(ECSecretBCPGKey)privPk;
ECPrivateKeySpec ecDsaSpec=new ECPrivateKeySpec(ecdsaK.getX(),convertX9Parameters(ecdsaPub.getCurveOID(),NISTNamedCurves.getByOID(ecdsaPub.getCurveOID())));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(ecDsaSpec);
case PGPPublicKey.ELGAMAL_ENCRYPT:
case PGPPublicKey.ELGAMAL_GENERAL:
ElGamalPublicBCPGKey elPub=(ElGamalPublicBCPGKey)pubPk.getKey();
ElGamalSecretBCPGKey elPriv=(ElGamalSecretBCPGKey)privPk;
ElGamalPrivateKeySpec elSpec=new ElGamalPrivateKeySpec(elPriv.getX(),new ElGamalParameterSpec(elPub.getP(),elPub.getG()));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(elSpec);
default :
throw new PGPException(""String_Node_Str"");
}
}
 catch (PGPException e) {
throw e;
}
catch (Exception e) {
throw new PGPException(""String_Node_Str"",e);
}
}","public PrivateKey getPrivateKey(PGPPrivateKey privKey) throws PGPException {
  if (privKey instanceof JcaPGPPrivateKey) {
    return ((JcaPGPPrivateKey)privKey).getPrivateKey();
  }
  PublicKeyPacket pubPk=privKey.getPublicKeyPacket();
  BCPGKey privPk=privKey.getPrivateKeyDataPacket();
  try {
    KeyFactory fact;
switch (pubPk.getAlgorithm()) {
case PGPPublicKey.RSA_ENCRYPT:
case PGPPublicKey.RSA_GENERAL:
case PGPPublicKey.RSA_SIGN:
      RSAPublicBCPGKey rsaPub=(RSAPublicBCPGKey)pubPk.getKey();
    RSASecretBCPGKey rsaPriv=(RSASecretBCPGKey)privPk;
  RSAPrivateCrtKeySpec rsaPrivSpec=new RSAPrivateCrtKeySpec(rsaPriv.getModulus(),rsaPub.getPublicExponent(),rsaPriv.getPrivateExponent(),rsaPriv.getPrimeP(),rsaPriv.getPrimeQ(),rsaPriv.getPrimeExponentP(),rsaPriv.getPrimeExponentQ(),rsaPriv.getCrtCoefficient());
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(rsaPrivSpec);
case PGPPublicKey.DSA:
DSAPublicBCPGKey dsaPub=(DSAPublicBCPGKey)pubPk.getKey();
DSASecretBCPGKey dsaPriv=(DSASecretBCPGKey)privPk;
DSAPrivateKeySpec dsaPrivSpec=new DSAPrivateKeySpec(dsaPriv.getX(),dsaPub.getP(),dsaPub.getQ(),dsaPub.getG());
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(dsaPrivSpec);
case PublicKeyAlgorithmTags.ECDH:
ECDHPublicBCPGKey ecdhPub=(ECDHPublicBCPGKey)pubPk.getKey();
ECSecretBCPGKey ecdhK=(ECSecretBCPGKey)privPk;
ECPrivateKeySpec ecDhSpec=new ECPrivateKeySpec(ecdhK.getX(),convertX9Parameters(ecdhPub.getCurveOID(),ECNamedCurveTable.getByOID(ecdhPub.getCurveOID())));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(ecDhSpec);
case PublicKeyAlgorithmTags.ECDSA:
ECDSAPublicBCPGKey ecdsaPub=(ECDSAPublicBCPGKey)pubPk.getKey();
ECSecretBCPGKey ecdsaK=(ECSecretBCPGKey)privPk;
ECPrivateKeySpec ecDsaSpec=new ECPrivateKeySpec(ecdsaK.getX(),convertX9Parameters(ecdsaPub.getCurveOID(),ECNamedCurveTable.getByOID(ecdsaPub.getCurveOID())));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(ecDsaSpec);
case PGPPublicKey.ELGAMAL_ENCRYPT:
case PGPPublicKey.ELGAMAL_GENERAL:
ElGamalPublicBCPGKey elPub=(ElGamalPublicBCPGKey)pubPk.getKey();
ElGamalSecretBCPGKey elPriv=(ElGamalSecretBCPGKey)privPk;
ElGamalPrivateKeySpec elSpec=new ElGamalPrivateKeySpec(elPriv.getX(),new ElGamalParameterSpec(elPub.getP(),elPub.getG()));
fact=helper.createKeyFactory(""String_Node_Str"");
return fact.generatePrivate(elSpec);
default :
throw new PGPException(""String_Node_Str"");
}
}
 catch (PGPException e) {
throw e;
}
catch (Exception e) {
throw new PGPException(""String_Node_Str"",e);
}
}"
52372,"private void encryptDecryptBCTest() throws Exception {
  byte[] text={(byte)'h',(byte)'e',(byte)'l',(byte)'l',(byte)'o',(byte)' ',(byte)'w',(byte)'o',(byte)'r',(byte)'l',(byte)'d',(byte)'!',(byte)'\n'};
  ECKeyPairGenerator keyGen=new ECKeyPairGenerator();
  X9ECParameters x9ECParameters=NISTNamedCurves.getByName(""String_Node_Str"");
  keyGen.init(new ECKeyGenerationParameters(new ECNamedDomainParameters(NISTNamedCurves.getOID(""String_Node_Str""),x9ECParameters.getCurve(),x9ECParameters.getG(),x9ECParameters.getN()),new SecureRandom()));
  AsymmetricCipherKeyPair kpEnc=keyGen.generateKeyPair();
  PGPKeyPair ecdhKeyPair=new BcPGPKeyPair(PGPPublicKey.ECDH,kpEnc,new Date());
  PGPLiteralDataGenerator lData=new PGPLiteralDataGenerator();
  ByteArrayOutputStream ldOut=new ByteArrayOutputStream();
  OutputStream pOut=lData.open(ldOut,PGPLiteralDataGenerator.UTF8,PGPLiteralData.CONSOLE,text.length,new Date());
  pOut.write(text);
  pOut.close();
  byte[] data=ldOut.toByteArray();
  ByteArrayOutputStream cbOut=new ByteArrayOutputStream();
  PGPEncryptedDataGenerator cPk=new PGPEncryptedDataGenerator(new BcPGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.CAST5).setSecureRandom(new SecureRandom()));
  cPk.addMethod(new BcPublicKeyKeyEncryptionMethodGenerator(ecdhKeyPair.getPublicKey()));
  OutputStream cOut=cPk.open(new UncloseableOutputStream(cbOut),data.length);
  cOut.write(data);
  cOut.close();
  JcaPGPObjectFactory pgpF=new JcaPGPObjectFactory(cbOut.toByteArray());
  PGPEncryptedDataList encList=(PGPEncryptedDataList)pgpF.nextObject();
  PGPPublicKeyEncryptedData encP=(PGPPublicKeyEncryptedData)encList.get(0);
  InputStream clear=encP.getDataStream(new BcPublicKeyDataDecryptorFactory(ecdhKeyPair.getPrivateKey()));
  pgpF=new JcaPGPObjectFactory(clear);
  PGPLiteralData ld=(PGPLiteralData)pgpF.nextObject();
  clear=ld.getInputStream();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  int ch;
  while ((ch=clear.read()) >= 0) {
    bOut.write(ch);
  }
  byte[] out=bOut.toByteArray();
  if (!areEqual(out,text)) {
    fail(""String_Node_Str"");
  }
}","private void encryptDecryptBCTest(final String curve) throws Exception {
  byte[] text={(byte)'h',(byte)'e',(byte)'l',(byte)'l',(byte)'o',(byte)' ',(byte)'w',(byte)'o',(byte)'r',(byte)'l',(byte)'d',(byte)'!',(byte)'\n'};
  ECKeyPairGenerator keyGen=new ECKeyPairGenerator();
  X9ECParameters x9ECParameters=ECNamedCurveTable.getByName(curve);
  keyGen.init(new ECKeyGenerationParameters(new ECNamedDomainParameters(ECNamedCurveTable.getOID(curve),x9ECParameters.getCurve(),x9ECParameters.getG(),x9ECParameters.getN()),new SecureRandom()));
  AsymmetricCipherKeyPair kpEnc=keyGen.generateKeyPair();
  PGPKeyPair ecdhKeyPair=new BcPGPKeyPair(PGPPublicKey.ECDH,kpEnc,new Date());
  PGPLiteralDataGenerator lData=new PGPLiteralDataGenerator();
  ByteArrayOutputStream ldOut=new ByteArrayOutputStream();
  OutputStream pOut=lData.open(ldOut,PGPLiteralDataGenerator.UTF8,PGPLiteralData.CONSOLE,text.length,new Date());
  pOut.write(text);
  pOut.close();
  byte[] data=ldOut.toByteArray();
  ByteArrayOutputStream cbOut=new ByteArrayOutputStream();
  PGPEncryptedDataGenerator cPk=new PGPEncryptedDataGenerator(new BcPGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.CAST5).setSecureRandom(new SecureRandom()));
  cPk.addMethod(new BcPublicKeyKeyEncryptionMethodGenerator(ecdhKeyPair.getPublicKey()));
  OutputStream cOut=cPk.open(new UncloseableOutputStream(cbOut),data.length);
  cOut.write(data);
  cOut.close();
  JcaPGPObjectFactory pgpF=new JcaPGPObjectFactory(cbOut.toByteArray());
  PGPEncryptedDataList encList=(PGPEncryptedDataList)pgpF.nextObject();
  PGPPublicKeyEncryptedData encP=(PGPPublicKeyEncryptedData)encList.get(0);
  InputStream clear=encP.getDataStream(new BcPublicKeyDataDecryptorFactory(ecdhKeyPair.getPrivateKey()));
  pgpF=new JcaPGPObjectFactory(clear);
  PGPLiteralData ld=(PGPLiteralData)pgpF.nextObject();
  clear=ld.getInputStream();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  int ch;
  while ((ch=clear.read()) >= 0) {
    bOut.write(ch);
  }
  byte[] out=bOut.toByteArray();
  if (!areEqual(out,text)) {
    fail(""String_Node_Str"");
  }
}"
52373,"public void performTest() throws Exception {
  PGPPublicKeyRing pubKeyRing=new PGPPublicKeyRing(testPubKey,new JcaKeyFingerprintCalculator());
  doBasicKeyRingCheck(pubKeyRing);
  PGPSecretKeyRing secretKeyRing=new PGPSecretKeyRing(testPrivKey,new JcaKeyFingerprintCalculator());
  testDecrypt(secretKeyRing);
  encryptDecryptTest();
  encryptDecryptBCTest();
  generate();
}","public void performTest() throws Exception {
  PGPPublicKeyRing pubKeyRing=new PGPPublicKeyRing(testPubKey,new JcaKeyFingerprintCalculator());
  doBasicKeyRingCheck(pubKeyRing);
  PGPSecretKeyRing secretKeyRing=new PGPSecretKeyRing(testPrivKey,new JcaKeyFingerprintCalculator());
  testDecrypt(secretKeyRing);
  encryptDecryptTest();
  encryptDecryptBCTest(""String_Node_Str"");
  encryptDecryptBCTest(""String_Node_Str"");
  generate();
}"
52374,"public static String getCurveName(ASN1ObjectIdentifier oid){
  String name=X962NamedCurves.getName(oid);
  if (name == null) {
    name=SECNamedCurves.getName(oid);
    if (name == null) {
      name=NISTNamedCurves.getName(oid);
    }
    if (name == null) {
      name=TeleTrusTNamedCurves.getName(oid);
    }
    if (name == null) {
      name=ECGOST3410NamedCurves.getName(oid);
    }
    if (name == null) {
      name=ANSSINamedCurves.getName(oid);
    }
    if (name == null) {
      name=GMNamedCurves.getName(oid);
    }
  }
  return name;
}","public static String getCurveName(ASN1ObjectIdentifier oid){
  String name=X962NamedCurves.getName(oid);
  if (name == null) {
    name=SECNamedCurves.getName(oid);
    if (name == null) {
      name=NISTNamedCurves.getName(oid);
    }
    if (name == null) {
      name=TeleTrusTNamedCurves.getName(oid);
    }
    if (name == null) {
      name=ECGOST3410NamedCurves.getName(oid);
    }
    if (name == null) {
      name=ANSSINamedCurves.getName(oid);
    }
    if (name == null) {
      name=GMNamedCurves.getName(oid);
    }
    if (name == null) {
      name=ECNamedCurveTable.getName(oid);
    }
  }
  return name;
}"
52375,"public static X9ECParameters getNamedCurveByOid(ASN1ObjectIdentifier oid){
  X9ECParameters params=CustomNamedCurves.getByOID(oid);
  if (params == null) {
    params=X962NamedCurves.getByOID(oid);
    if (params == null) {
      params=SECNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=NISTNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=TeleTrusTNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=ANSSINamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=GMNamedCurves.getByOID(oid);
    }
  }
  return params;
}","public static X9ECParameters getNamedCurveByOid(ASN1ObjectIdentifier oid){
  X9ECParameters params=CustomNamedCurves.getByOID(oid);
  if (params == null) {
    params=X962NamedCurves.getByOID(oid);
    if (params == null) {
      params=SECNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=NISTNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=TeleTrusTNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=ANSSINamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=GMNamedCurves.getByOID(oid);
    }
    if (params == null) {
      params=ECNamedCurveTable.getByOID(oid);
    }
  }
  return params;
}"
52376,"public static X9ECParameters getNamedCurveByName(String curveName){
  X9ECParameters params=CustomNamedCurves.getByName(curveName);
  if (params == null) {
    params=X962NamedCurves.getByName(curveName);
    if (params == null) {
      params=SECNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=NISTNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=TeleTrusTNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=ANSSINamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=GMNamedCurves.getByName(curveName);
    }
  }
  return params;
}","public static X9ECParameters getNamedCurveByName(String curveName){
  X9ECParameters params=CustomNamedCurves.getByName(curveName);
  if (params == null) {
    params=X962NamedCurves.getByName(curveName);
    if (params == null) {
      params=SECNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=NISTNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=TeleTrusTNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=ANSSINamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=GMNamedCurves.getByName(curveName);
    }
    if (params == null) {
      params=ECNamedCurveTable.getByName(curveName);
    }
  }
  return params;
}"
52377,"private static ASN1ObjectIdentifier lookupOidByName(String name){
  ASN1ObjectIdentifier oid=X962NamedCurves.getOID(name);
  if (oid == null) {
    oid=SECNamedCurves.getOID(name);
    if (oid == null) {
      oid=NISTNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=TeleTrusTNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ECGOST3410NamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ANSSINamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=GMNamedCurves.getOID(name);
    }
  }
  return oid;
}","private static ASN1ObjectIdentifier lookupOidByName(String name){
  ASN1ObjectIdentifier oid=X962NamedCurves.getOID(name);
  if (oid == null) {
    oid=SECNamedCurves.getOID(name);
    if (oid == null) {
      oid=NISTNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=TeleTrusTNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ECGOST3410NamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ANSSINamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=GMNamedCurves.getOID(name);
    }
    if (oid == null) {
      oid=ECNamedCurveTable.getOID(name);
    }
  }
  return oid;
}"
52378,"public static boolean isValidNameMatch(String name,String dnsName,Set<String> suffixes) throws IOException {
  if (dnsName.contains(""String_Node_Str"")) {
    int wildIndex=dnsName.indexOf('*');
    if (wildIndex == dnsName.lastIndexOf(""String_Node_Str"")) {
      if (dnsName.contains(""String_Node_Str"") || dnsName.charAt(dnsName.length() - 1) == '*') {
        return false;
      }
      int dnsDotIndex=dnsName.indexOf('.',wildIndex);
      if (suffixes != null && suffixes.contains(Strings.toLowerCase(dnsName.substring(dnsDotIndex)))) {
        throw new IOException(""String_Node_Str"" + dnsName + ""String_Node_Str"");
      }
      String end=Strings.toLowerCase(dnsName.substring(wildIndex + 1));
      String loweredName=Strings.toLowerCase(name);
      if (loweredName.equals(end)) {
        return false;
      }
      if (end.length() > loweredName.length()) {
        return false;
      }
      if (wildIndex > 0) {
        if (loweredName.startsWith(dnsName.substring(0,wildIndex - 1)) && loweredName.endsWith(end)) {
          return loweredName.substring(wildIndex,loweredName.length() - end.length()).indexOf('.') < 0;
        }
 else {
          return false;
        }
      }
      String prefix=loweredName.substring(0,loweredName.length() - end.length());
      if (prefix.indexOf('.') > 0) {
        return false;
      }
      return loweredName.endsWith(end);
    }
    return false;
  }
  return name.equalsIgnoreCase(dnsName);
}","public static boolean isValidNameMatch(String name,String dnsName,Set<String> suffixes) throws IOException {
  if (dnsName.contains(""String_Node_Str"")) {
    int wildIndex=dnsName.indexOf('*');
    if (wildIndex == dnsName.lastIndexOf(""String_Node_Str"")) {
      if (dnsName.contains(""String_Node_Str"") || dnsName.charAt(dnsName.length() - 1) == '*') {
        return false;
      }
      int dnsDotIndex=dnsName.indexOf('.',wildIndex);
      if (suffixes != null && suffixes.contains(Strings.toLowerCase(dnsName.substring(dnsDotIndex)))) {
        throw new IOException(""String_Node_Str"" + dnsName + ""String_Node_Str"");
      }
      String end=Strings.toLowerCase(dnsName.substring(wildIndex + 1));
      String loweredName=Strings.toLowerCase(name);
      if (loweredName.equals(end)) {
        return false;
      }
      if (end.length() > loweredName.length()) {
        return false;
      }
      if (wildIndex > 0) {
        if (loweredName.startsWith(dnsName.substring(0,wildIndex)) && loweredName.endsWith(end)) {
          return loweredName.substring(wildIndex,loweredName.length() - end.length()).indexOf('.') < 0;
        }
 else {
          return false;
        }
      }
      String prefix=loweredName.substring(0,loweredName.length() - end.length());
      if (prefix.indexOf('.') > 0) {
        return false;
      }
      return loweredName.endsWith(end);
    }
    return false;
  }
  return name.equalsIgnoreCase(dnsName);
}"
52379,"public void testWildcardMatcher() throws Exception {
  Object[][] v=new Object[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false}};
  for (  Object[] j : v) {
    assertEquals(j[0].toString(),j[3],JsseDefaultHostnameAuthorizer.isValidNameMatch((String)j[1],(String)j[2],null));
  }
}","public void testWildcardMatcher() throws Exception {
  Object[][] v=new Object[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true}};
  for (  Object[] j : v) {
    assertEquals(j[0].toString(),j[3],JsseDefaultHostnameAuthorizer.isValidNameMatch((String)j[1],(String)j[2],null));
  }
}"
52380,"private byte[] decrypt(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  byte[] c1=new byte[curveLength * 2 + 1];
  System.arraycopy(in,inOff,c1,0,c1.length);
  ECPoint c1P=ecParams.getCurve().decodePoint(c1);
  ECPoint s=c1P.multiply(ecParams.getH());
  if (s.isInfinity()) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  c1P=c1P.multiply(((ECPrivateKeyParameters)ecKey).getD()).normalize();
  byte[] c2=new byte[inLen - c1.length - digest.getDigestSize()];
  System.arraycopy(in,inOff + c1.length,c2,0,c2.length);
  kdf(digest,c1P,c2);
  byte[] c3=new byte[digest.getDigestSize()];
  addFieldElement(digest,c1P.getAffineXCoord());
  digest.update(c2,0,c2.length);
  addFieldElement(digest,c1P.getAffineYCoord());
  digest.doFinal(c3,0);
  int check=0;
  for (int i=0; i != c3.length; i++) {
    check|=c3[i] ^ in[c1.length + c2.length + i];
  }
  Arrays.fill(c1,(byte)0);
  Arrays.fill(c3,(byte)0);
  if (check != 0) {
    Arrays.fill(c2,(byte)0);
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  return c2;
}","private byte[] decrypt(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  byte[] c1=new byte[curveLength * 2 + 1];
  System.arraycopy(in,inOff,c1,0,c1.length);
  ECPoint c1P=ecParams.getCurve().decodePoint(c1);
  ECPoint s=c1P.multiply(ecParams.getH());
  if (s.isInfinity()) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  c1P=c1P.multiply(((ECPrivateKeyParameters)ecKey).getD()).normalize();
  byte[] c2=new byte[inLen - c1.length - digest.getDigestSize()];
  System.arraycopy(in,inOff + c1.length,c2,0,c2.length);
  kdf(digest,c1P,c2);
  byte[] c3=new byte[digest.getDigestSize()];
  addFieldElement(digest,c1P.getAffineXCoord());
  digest.update(c2,0,c2.length);
  addFieldElement(digest,c1P.getAffineYCoord());
  digest.doFinal(c3,0);
  int check=0;
  for (int i=0; i != c3.length; i++) {
    check|=c3[i] ^ in[inOff + c1.length + c2.length+ i];
  }
  Arrays.fill(c1,(byte)0);
  Arrays.fill(c3,(byte)0);
  if (check != 0) {
    Arrays.fill(c2,(byte)0);
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  return c2;
}"
52381,"/** 
 * Generate a key using the scrypt key derivation function.
 * @param P     the bytes of the pass phrase.
 * @param S     the salt to use for this invocation.
 * @param N     CPU/Memory cost parameter. Must be larger than 1, a power of 2 and less than<code>2^(128 * r / 8)</code>.
 * @param r     the block size, must be &gt;= 1.
 * @param p     Parallelization parameter. Must be a positive integer less than or equal to<code>Integer.MAX_VALUE / (128 * r * 8)</code>.
 * @param dkLen the length of the key to generate.
 * @return the generated key.
 */
public static byte[] generate(byte[] P,byte[] S,int N,int r,int p,int dkLen){
  if (P == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (S == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (N <= 1 || !isPowerOf2(N)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (r == 1 && N > 65536) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (r < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int maxParallel=Integer.MAX_VALUE / (128 * r * 8);
  if (p < 1 || p > maxParallel) {
    throw new IllegalArgumentException(""String_Node_Str"" + maxParallel + ""String_Node_Str""+ r+ ""String_Node_Str"");
  }
  if (dkLen < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return MFcrypt(P,S,N,r,p,dkLen);
}","/** 
 * Generate a key using the scrypt key derivation function.
 * @param P     the bytes of the pass phrase.
 * @param S     the salt to use for this invocation.
 * @param N     CPU/Memory cost parameter. Must be larger than 1, a power of 2 and less than<code>2^(128 * r / 8)</code>.
 * @param r     the block size, must be &gt;= 1.
 * @param p     Parallelization parameter. Must be a positive integer less than or equal to<code>Integer.MAX_VALUE / (128 * r * 8)</code>.
 * @param dkLen the length of the key to generate.
 * @return the generated key.
 */
public static byte[] generate(byte[] P,byte[] S,int N,int r,int p,int dkLen){
  if (P == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (S == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (N <= 1 || !isPowerOf2(N)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (r == 1 && N >= 65536) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (r < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int maxParallel=Integer.MAX_VALUE / (128 * r * 8);
  if (p < 1 || p > maxParallel) {
    throw new IllegalArgumentException(""String_Node_Str"" + maxParallel + ""String_Node_Str""+ r+ ""String_Node_Str"");
  }
  if (dkLen < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return MFcrypt(P,S,N,r,p,dkLen);
}"
52382,"public void testParameters(){
  checkOK(""String_Node_Str"",new byte[0],new byte[0],2,1,1,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],1,1,1,1);
  checkOK(""String_Node_Str"",new byte[0],new byte[0],65536,1,1,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],65537,1,1,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],2,0,2,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],2,1,0,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],2,32,65536,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],2,1,1,0);
}","public void testParameters(){
  checkOK(""String_Node_Str"",new byte[0],new byte[0],2,1,1,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],1,1,1,1);
  checkOK(""String_Node_Str"",new byte[0],new byte[0],65536,1,1,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],65536,1,1,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],2,0,2,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],2,1,0,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],2,32,65536,1);
  checkIllegal(""String_Node_Str"",new byte[0],new byte[0],2,1,1,0);
}"
52383,"/** 
 * return the time - always in the form of YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm). <p> Normally in a certificate we would expect ""Z"" rather than ""GMT"", however adding the ""GMT"" means we can just use: <pre> dateF = new SimpleDateFormat(""yyyyMMddHHmmssz""); </pre> To read in the time and get a date which is compatible with our local time zone. </p>
 * @return a String representation of the time.
 */
public String getTime(){
  String stime=Strings.fromByteArray(time);
  if (stime.charAt(stime.length() - 1) == 'Z') {
    return stime.substring(0,stime.length() - 1) + ""String_Node_Str"";
  }
 else {
    int signPos=stime.length() - 5;
    char sign=stime.charAt(signPos);
    if (sign == '-' || sign == '+') {
      return stime.substring(0,signPos) + ""String_Node_Str"" + stime.substring(signPos,signPos + 3)+ ""String_Node_Str""+ stime.substring(signPos + 3);
    }
 else {
      signPos=stime.length() - 3;
      sign=stime.charAt(signPos);
      if (sign == '-' || sign == '+') {
        return stime.substring(0,signPos) + ""String_Node_Str"" + stime.substring(signPos)+ ""String_Node_Str"";
      }
    }
  }
  return stime + calculateGMTOffset();
}","/** 
 * return the time - always in the form of YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm). <p> Normally in a certificate we would expect ""Z"" rather than ""GMT"", however adding the ""GMT"" means we can just use: <pre> dateF = new SimpleDateFormat(""yyyyMMddHHmmssz""); </pre> To read in the time and get a date which is compatible with our local time zone.
 * @return a String representation of the time.
 */
public String getTime(){
  String stime=Strings.fromByteArray(time);
  if (stime.charAt(stime.length() - 1) == 'Z') {
    return stime.substring(0,stime.length() - 1) + ""String_Node_Str"";
  }
 else {
    int signPos=stime.length() - 5;
    char sign=stime.charAt(signPos);
    if (sign == '-' || sign == '+') {
      return stime.substring(0,signPos) + ""String_Node_Str"" + stime.substring(signPos,signPos + 3)+ ""String_Node_Str""+ stime.substring(signPos + 3);
    }
 else {
      signPos=stime.length() - 3;
      sign=stime.charAt(signPos);
      if (sign == '-' || sign == '+') {
        return stime.substring(0,signPos) + ""String_Node_Str"" + stime.substring(signPos)+ ""String_Node_Str"";
      }
    }
  }
  return stime + calculateGMTOffset();
}"
52384,"/** 
 * Return an instance of ASN.1 NULL from the passed in object. <p> Accepted inputs: <ul> <li> null &rarr; null <li>   {@link ASN1Null} object<li> a byte[] containing ASN.1 NULL object </ul> </p>
 * @param o object to be converted.
 * @return an instance of ASN1Null, or null.
 * @exception IllegalArgumentException if the object cannot be converted.
 */
public static ASN1Null getInstance(Object o){
  if (o instanceof ASN1Null) {
    return (ASN1Null)o;
  }
  if (o != null) {
    try {
      return ASN1Null.getInstance(ASN1Primitive.fromByteArray((byte[])o));
    }
 catch (    IOException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + e.getMessage());
    }
catch (    ClassCastException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + o.getClass().getName());
    }
  }
  return null;
}","/** 
 * Return an instance of ASN.1 NULL from the passed in object. <p> Accepted inputs: <ul> <li> null &rarr; null <li>   {@link ASN1Null} object<li> a byte[] containing ASN.1 NULL object </ul>
 * @param o object to be converted.
 * @return an instance of ASN1Null, or null.
 * @exception IllegalArgumentException if the object cannot be converted.
 */
public static ASN1Null getInstance(Object o){
  if (o instanceof ASN1Null) {
    return (ASN1Null)o;
  }
  if (o != null) {
    try {
      return ASN1Null.getInstance(ASN1Primitive.fromByteArray((byte[])o));
    }
 catch (    IOException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + e.getMessage());
    }
catch (    ClassCastException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + o.getClass().getName());
    }
  }
  return null;
}"
52385,"/** 
 * return the MAC used as the basis for the function
 */
public Mac getMac();","/** 
 * return the MAC used as the basis for the function
 * @return the Mac.
 */
public Mac getMac();"
52386,"/** 
 * which generates the p and g values from the given parameters, returning the DHParameters object. <p> Note: can take a while...
 */
public DHParameters generateParameters(){
  BigInteger[] safePrimes=DHParametersHelper.generateSafePrimes(size,certainty,random);
  BigInteger p=safePrimes[0];
  BigInteger q=safePrimes[1];
  BigInteger g=DHParametersHelper.selectGenerator(p,q,random);
  return new DHParameters(p,g,q,TWO,null);
}","/** 
 * which generates the p and g values from the given parameters, returning the DHParameters object. <p> Note: can take a while...
 * @return a generated Diffie-Hellman parameters object.
 */
public DHParameters generateParameters(){
  BigInteger[] safePrimes=DHParametersHelper.generateSafePrimes(size,certainty,random);
  BigInteger p=safePrimes[0];
  BigInteger q=safePrimes[1];
  BigInteger g=DHParametersHelper.selectGenerator(p,q,random);
  return new DHParameters(p,g,q,TWO,null);
}"
52387,"/** 
 * which generates the p and g values from the given parameters, returning the DSAParameters object. <p> Note: can take a while...
 */
public DSAParameters generateParameters(){
  return (use186_3) ? generateParameters_FIPS186_3() : generateParameters_FIPS186_2();
}","/** 
 * which generates the p and g values from the given parameters, returning the DSAParameters object. <p> Note: can take a while...
 * @return a generated DSA parameters object.
 */
public DSAParameters generateParameters(){
  return (use186_3) ? generateParameters_FIPS186_3() : generateParameters_FIPS186_2();
}"
52388,"/** 
 * which generates the p and g values from the given parameters, returning the ElGamalParameters object. <p> Note: can take a while...
 */
public ElGamalParameters generateParameters(){
  BigInteger[] safePrimes=DHParametersHelper.generateSafePrimes(size,certainty,random);
  BigInteger p=safePrimes[0];
  BigInteger q=safePrimes[1];
  BigInteger g=DHParametersHelper.selectGenerator(p,q,random);
  return new ElGamalParameters(p,g);
}","/** 
 * which generates the p and g values from the given parameters, returning the ElGamalParameters object. <p> Note: can take a while...
 * @return a generated ElGamal parameters object.
 */
public ElGamalParameters generateParameters(){
  BigInteger[] safePrimes=DHParametersHelper.generateSafePrimes(size,certainty,random);
  BigInteger p=safePrimes[0];
  BigInteger q=safePrimes[1];
  BigInteger g=DHParametersHelper.selectGenerator(p,q,random);
  return new ElGamalParameters(p,g);
}"
52389,"/** 
 * Procedure C procedure generates the a value from the given p,q, returning the a value.
 */
private BigInteger procedure_C(BigInteger p,BigInteger q){
  BigInteger pSub1=p.subtract(ONE);
  BigInteger pSub1DivQ=pSub1.divide(q);
  int length=p.bitLength();
  for (; ; ) {
    BigInteger d=new BigInteger(length,init_random);
    if (d.compareTo(ONE) > 0 && d.compareTo(pSub1) < 0) {
      BigInteger a=d.modPow(pSub1DivQ,p);
      if (a.compareTo(ONE) != 0) {
        return a;
      }
    }
  }
}","private BigInteger procedure_C(BigInteger p,BigInteger q){
  BigInteger pSub1=p.subtract(ONE);
  BigInteger pSub1DivQ=pSub1.divide(q);
  int length=p.bitLength();
  for (; ; ) {
    BigInteger d=new BigInteger(length,init_random);
    if (d.compareTo(ONE) > 0 && d.compareTo(pSub1) < 0) {
      BigInteger a=d.modPow(pSub1DivQ,p);
      if (a.compareTo(ONE) != 0) {
        return a;
      }
    }
  }
}"
52390,"/** 
 * which generates the p , q and a values from the given parameters, returning the GOST3410Parameters object.
 */
public GOST3410Parameters generateParameters(){
  BigInteger[] pq=new BigInteger[2];
  BigInteger q=null, p=null, a=null;
  int x0, c;
  long x0L, cL;
  if (typeproc == 1) {
    x0=init_random.nextInt();
    c=init_random.nextInt();
switch (size) {
case 512:
      procedure_A(x0,c,pq,512);
    break;
case 1024:
  procedure_B(x0,c,pq);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
p=pq[0];
q=pq[1];
a=procedure_C(p,q);
return new GOST3410Parameters(p,q,a,new GOST3410ValidationParameters(x0,c));
}
 else {
x0L=init_random.nextLong();
cL=init_random.nextLong();
switch (size) {
case 512:
procedure_Aa(x0L,cL,pq,512);
break;
case 1024:
procedure_Bb(x0L,cL,pq);
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
p=pq[0];
q=pq[1];
a=procedure_C(p,q);
return new GOST3410Parameters(p,q,a,new GOST3410ValidationParameters(x0L,cL));
}
}","/** 
 * which generates the p , q and a values from the given parameters, returning the GOST3410Parameters object.
 * @return a generated GOST3410 parameters object.
 */
public GOST3410Parameters generateParameters(){
  BigInteger[] pq=new BigInteger[2];
  BigInteger q=null, p=null, a=null;
  int x0, c;
  long x0L, cL;
  if (typeproc == 1) {
    x0=init_random.nextInt();
    c=init_random.nextInt();
switch (size) {
case 512:
      procedure_A(x0,c,pq,512);
    break;
case 1024:
  procedure_B(x0,c,pq);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
p=pq[0];
q=pq[1];
a=procedure_C(p,q);
return new GOST3410Parameters(p,q,a,new GOST3410ValidationParameters(x0,c));
}
 else {
x0L=init_random.nextLong();
cL=init_random.nextLong();
switch (size) {
case 512:
procedure_Aa(x0L,cL,pq,512);
break;
case 1024:
procedure_Bb(x0L,cL,pq);
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
p=pq[0];
q=pq[1];
a=procedure_C(p,q);
return new GOST3410Parameters(p,q,a,new GOST3410ValidationParameters(x0L,cL));
}
}"
52391,"/** 
 * Generate a key using the scrypt key derivation function.
 * @param P the bytes of the pass phrase.
 * @param S the salt to use for this invocation.
 * @param N CPU/Memory cost parameter. Must be larger than 1, a power of 2 and less than<code>2^(128 * r / 8)</code>.
 * @param r the block size, must be >= 1.
 * @param p Parallelization parameter. Must be a positive integer less than or equal to<code>Integer.MAX_VALUE / (128 * r * 8)</code>.
 * @param dkLen the length of the key to generate.
 * @return the generated key.
 */
public static byte[] generate(byte[] P,byte[] S,int N,int r,int p,int dkLen){
  if (P == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (S == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (N <= 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (r == 1 && N > 65536) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (r < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int maxParallel=Integer.MAX_VALUE / (128 * r * 8);
  if (p < 1 || p > maxParallel) {
    throw new IllegalArgumentException(""String_Node_Str"" + maxParallel + ""String_Node_Str""+ r+ ""String_Node_Str"");
  }
  if (dkLen < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return MFcrypt(P,S,N,r,p,dkLen);
}","/** 
 * Generate a key using the scrypt key derivation function.
 * @param P the bytes of the pass phrase.
 * @param S the salt to use for this invocation.
 * @param N CPU/Memory cost parameter. Must be larger than 1, a power of 2 and less than<code>2^(128 * r / 8)</code>.
 * @param r the block size, must be &gt;= 1.
 * @param p Parallelization parameter. Must be a positive integer less than or equal to<code>Integer.MAX_VALUE / (128 * r * 8)</code>.
 * @param dkLen the length of the key to generate.
 * @return the generated key.
 */
public static byte[] generate(byte[] P,byte[] S,int N,int r,int p,int dkLen){
  if (P == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (S == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (N <= 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (r == 1 && N > 65536) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (r < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int maxParallel=Integer.MAX_VALUE / (128 * r * 8);
  if (p < 1 || p > maxParallel) {
    throw new IllegalArgumentException(""String_Node_Str"" + maxParallel + ""String_Node_Str""+ r+ ""String_Node_Str"");
  }
  if (dkLen < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return MFcrypt(P,S,N,r,p,dkLen);
}"
52392,"/** 
 * Return the   {@link ProtocolVersion} to use for the <c>TLSPlaintext.version</c> field prior toreceiving the server version. NOTE: This method is <b>not</b> called for DTLS. <p> See RFC 5246 E.1.: ""TLS clients that wish to negotiate with older servers MAY send any value {03,XX} as the record layer version number. Typical values would be {03,00}, the lowest version number supported by the client, and the value of ClientHello.client_version. No single value will guarantee interoperability with all old servers, but this is a complex topic beyond the scope of this document."" </p>
 * @return The {@link ProtocolVersion} to use.
 */
ProtocolVersion getClientHelloRecordLayerVersion();","/** 
 * Return the   {@link ProtocolVersion} to use for the <code>TLSPlaintext.version</code> field prior toreceiving the server version. NOTE: This method is <b>not</b> called for DTLS. <p> See RFC 5246 E.1.: ""TLS clients that wish to negotiate with older servers MAY send any value {03,XX} as the record layer version number. Typical values would be {03,00}, the lowest version number supported by the client, and the value of ClientHello.client_version. No single value will guarantee interoperability with all old servers, but this is a complex topic beyond the scope of this document."" </p>
 * @return The {@link ProtocolVersion} to use.
 */
ProtocolVersion getClientHelloRecordLayerVersion();"
52393,"/** 
 * Constructor for non-blocking mode.<br> <br> When data is received, use   {@link #offerInput(java.nio.ByteBuffer)} toprovide the received ciphertext, then use {@link #readInput(byte[],int,int)} to read the corresponding cleartext.<br><br> Similarly, when data needs to be sent, use {@link #offerOutput(byte[],int,int)} to provide the cleartext, then use{@link #readOutput(byte[],int,int)} to get the correspondingciphertext.
 * @param secureRandom Random number generator for various cryptographic functions
 */
public TlsClientProtocol(SecureRandom secureRandom){
  super(secureRandom);
}","/** 
 * Constructor for non-blocking mode.<br> <br> When data is received, use offerInput(java.nio.ByteBuffer) to provide the received ciphertext, then use  {@link #readInput(byte[],int,int)} to read the corresponding cleartext.<br><br> Similarly, when data needs to be sent, use {@link #offerOutput(byte[],int,int)} to provide the cleartext, then use{@link #readOutput(byte[],int,int)} to get the correspondingciphertext.
 * @param secureRandom Random number generator for various cryptographic functions
 */
public TlsClientProtocol(SecureRandom secureRandom){
  super(secureRandom);
}"
52394,"/** 
 * Constructor for non-blocking mode.<br> <br> When data is received, use   {@link #offerInput(java.nio.ByteBuffer)} toprovide the received ciphertext, then use {@link #readInput(byte[],int,int)} to read the corresponding cleartext.<br><br> Similarly, when data needs to be sent, use {@link #offerOutput(byte[],int,int)} to provide the cleartext, then use{@link #readOutput(byte[],int,int)} to get the correspondingciphertext.
 * @param secureRandom Random number generator for various cryptographic functions
 */
public TlsServerProtocol(SecureRandom secureRandom){
  super(secureRandom);
}","/** 
 * Constructor for non-blocking mode.<br> <br> When data is received, use offerInput(java.nio.ByteBuffer) to provide the received ciphertext, then use  {@link #readInput(byte[],int,int)} to read the corresponding cleartext.<br><br> Similarly, when data needs to be sent, use {@link #offerOutput(byte[],int,int)} to provide the cleartext, then use{@link #readOutput(byte[],int,int)} to get the correspondingciphertext.
 * @param secureRandom Random number generator for various cryptographic functions
 */
public TlsServerProtocol(SecureRandom secureRandom){
  super(secureRandom);
}"
52395,"public byte[] wrap(byte[] in,int inOff,int inLen){
  if (!forWrapping) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if ((in.length - inOff) % engine.getBlockSize() != 0) {
    throw new DataLengthException(""String_Node_Str"" + engine.getBlockSize() + ""String_Node_Str"");
  }
  if (inOff + inLen > in.length) {
    throw new DataLengthException(""String_Node_Str"");
  }
  int n=2 * (1 + inLen / engine.getBlockSize());
  int V=(n - 1) * 6;
  byte[] wrappedBuffer=new byte[in.length - inOff + engine.getBlockSize()];
  System.arraycopy(in,inOff,wrappedBuffer,0,in.length - inOff);
  System.arraycopy(wrappedBuffer,0,B,0,engine.getBlockSize() / 2);
  Btemp.clear();
  int bHalfBlocksLen=wrappedBuffer.length - engine.getBlockSize() / 2;
  int bufOff=engine.getBlockSize() / 2;
  while (bHalfBlocksLen != 0) {
    byte[] temp=new byte[engine.getBlockSize() / 2];
    System.arraycopy(wrappedBuffer,bufOff,temp,0,engine.getBlockSize() / 2);
    Btemp.add(temp);
    bHalfBlocksLen-=engine.getBlockSize() / 2;
    bufOff+=engine.getBlockSize() / 2;
  }
  for (int j=0; j < V; j++) {
    System.arraycopy(B,0,wrappedBuffer,0,engine.getBlockSize() / 2);
    System.arraycopy(Btemp.get(0),0,wrappedBuffer,engine.getBlockSize() / 2,engine.getBlockSize() / 2);
    engine.processBlock(wrappedBuffer,0,wrappedBuffer,0);
    intToBytes(j + 1,intArray,0);
    for (int byteNum=0; byteNum < BYTES_IN_INTEGER; byteNum++) {
      wrappedBuffer[byteNum + engine.getBlockSize() / 2]^=intArray[byteNum];
    }
    System.arraycopy(wrappedBuffer,engine.getBlockSize() / 2,B,0,engine.getBlockSize() / 2);
    for (int i=2; i < n; i++) {
      System.arraycopy(Btemp.get(i - 1),0,Btemp.get(i - 2),0,engine.getBlockSize() / 2);
    }
    System.arraycopy(wrappedBuffer,0,Btemp.get(n - 2),0,engine.getBlockSize() / 2);
  }
  System.arraycopy(B,0,wrappedBuffer,0,engine.getBlockSize() / 2);
  bufOff=engine.getBlockSize() / 2;
  for (int i=0; i < n - 1; i++) {
    System.arraycopy(Btemp.get(i),0,wrappedBuffer,bufOff,engine.getBlockSize() / 2);
    bufOff+=engine.getBlockSize() / 2;
  }
  return wrappedBuffer;
}","public byte[] wrap(byte[] in,int inOff,int inLen){
  if (!forWrapping) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if ((inLen % engine.getBlockSize()) != 0) {
    throw new DataLengthException(""String_Node_Str"" + engine.getBlockSize() + ""String_Node_Str"");
  }
  if (inOff + inLen > in.length) {
    throw new DataLengthException(""String_Node_Str"");
  }
  int n=2 * (1 + inLen / engine.getBlockSize());
  int V=(n - 1) * 6;
  byte[] wrappedBuffer=new byte[inLen + engine.getBlockSize()];
  System.arraycopy(in,inOff,wrappedBuffer,0,inLen);
  System.arraycopy(wrappedBuffer,0,B,0,engine.getBlockSize() / 2);
  Btemp.clear();
  int bHalfBlocksLen=wrappedBuffer.length - engine.getBlockSize() / 2;
  int bufOff=engine.getBlockSize() / 2;
  while (bHalfBlocksLen != 0) {
    byte[] temp=new byte[engine.getBlockSize() / 2];
    System.arraycopy(wrappedBuffer,bufOff,temp,0,engine.getBlockSize() / 2);
    Btemp.add(temp);
    bHalfBlocksLen-=engine.getBlockSize() / 2;
    bufOff+=engine.getBlockSize() / 2;
  }
  for (int j=0; j < V; j++) {
    System.arraycopy(B,0,wrappedBuffer,0,engine.getBlockSize() / 2);
    System.arraycopy(Btemp.get(0),0,wrappedBuffer,engine.getBlockSize() / 2,engine.getBlockSize() / 2);
    engine.processBlock(wrappedBuffer,0,wrappedBuffer,0);
    intToBytes(j + 1,intArray,0);
    for (int byteNum=0; byteNum < BYTES_IN_INTEGER; byteNum++) {
      wrappedBuffer[byteNum + engine.getBlockSize() / 2]^=intArray[byteNum];
    }
    System.arraycopy(wrappedBuffer,engine.getBlockSize() / 2,B,0,engine.getBlockSize() / 2);
    for (int i=2; i < n; i++) {
      System.arraycopy(Btemp.get(i - 1),0,Btemp.get(i - 2),0,engine.getBlockSize() / 2);
    }
    System.arraycopy(wrappedBuffer,0,Btemp.get(n - 2),0,engine.getBlockSize() / 2);
  }
  System.arraycopy(B,0,wrappedBuffer,0,engine.getBlockSize() / 2);
  bufOff=engine.getBlockSize() / 2;
  for (int i=0; i < n - 1; i++) {
    System.arraycopy(Btemp.get(i),0,wrappedBuffer,bufOff,engine.getBlockSize() / 2);
    bufOff+=engine.getBlockSize() / 2;
  }
  return wrappedBuffer;
}"
52396,"public byte[] unwrap(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  if (forWrapping) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if ((in.length - inOff) % engine.getBlockSize() != 0) {
    throw new DataLengthException(""String_Node_Str"" + engine.getBlockSize() + ""String_Node_Str"");
  }
  int n=2 * inLen / engine.getBlockSize();
  int V=(n - 1) * 6;
  byte[] buffer=new byte[in.length - inOff];
  System.arraycopy(in,inOff,buffer,0,in.length - inOff);
  byte[] B=new byte[engine.getBlockSize() / 2];
  System.arraycopy(buffer,0,B,0,engine.getBlockSize() / 2);
  Btemp.clear();
  int bHalfBlocksLen=buffer.length - engine.getBlockSize() / 2;
  int bufOff=engine.getBlockSize() / 2;
  while (bHalfBlocksLen != 0) {
    byte[] temp=new byte[engine.getBlockSize() / 2];
    System.arraycopy(buffer,bufOff,temp,0,engine.getBlockSize() / 2);
    Btemp.add(temp);
    bHalfBlocksLen-=engine.getBlockSize() / 2;
    bufOff+=engine.getBlockSize() / 2;
  }
  for (int j=0; j < V; j++) {
    System.arraycopy(Btemp.get(n - 2),0,buffer,0,engine.getBlockSize() / 2);
    System.arraycopy(B,0,buffer,engine.getBlockSize() / 2,engine.getBlockSize() / 2);
    intToBytes(V - j,intArray,0);
    for (int byteNum=0; byteNum < BYTES_IN_INTEGER; byteNum++) {
      buffer[byteNum + engine.getBlockSize() / 2]^=intArray[byteNum];
    }
    engine.processBlock(buffer,0,buffer,0);
    System.arraycopy(buffer,0,B,0,engine.getBlockSize() / 2);
    for (int i=2; i < n; i++) {
      System.arraycopy(Btemp.get(n - i - 1),0,Btemp.get(n - i),0,engine.getBlockSize() / 2);
    }
    System.arraycopy(buffer,engine.getBlockSize() / 2,Btemp.get(0),0,engine.getBlockSize() / 2);
  }
  System.arraycopy(B,0,buffer,0,engine.getBlockSize() / 2);
  bufOff=engine.getBlockSize() / 2;
  for (int i=0; i < n - 1; i++) {
    System.arraycopy(Btemp.get(i),0,buffer,bufOff,engine.getBlockSize() / 2);
    bufOff+=engine.getBlockSize() / 2;
  }
  System.arraycopy(buffer,buffer.length - engine.getBlockSize(),checkSumArray,0,engine.getBlockSize());
  byte[] wrappedBuffer=new byte[buffer.length - engine.getBlockSize()];
  if (!Arrays.areEqual(checkSumArray,zeroArray)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
 else {
    System.arraycopy(buffer,0,wrappedBuffer,0,buffer.length - engine.getBlockSize());
  }
  return wrappedBuffer;
}","public byte[] unwrap(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  if (forWrapping) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if ((inLen % engine.getBlockSize()) != 0) {
    throw new DataLengthException(""String_Node_Str"" + engine.getBlockSize() + ""String_Node_Str"");
  }
  int n=2 * inLen / engine.getBlockSize();
  int V=(n - 1) * 6;
  byte[] buffer=new byte[inLen];
  System.arraycopy(in,inOff,buffer,0,inLen);
  byte[] B=new byte[engine.getBlockSize() / 2];
  System.arraycopy(buffer,0,B,0,engine.getBlockSize() / 2);
  Btemp.clear();
  int bHalfBlocksLen=buffer.length - engine.getBlockSize() / 2;
  int bufOff=engine.getBlockSize() / 2;
  while (bHalfBlocksLen != 0) {
    byte[] temp=new byte[engine.getBlockSize() / 2];
    System.arraycopy(buffer,bufOff,temp,0,engine.getBlockSize() / 2);
    Btemp.add(temp);
    bHalfBlocksLen-=engine.getBlockSize() / 2;
    bufOff+=engine.getBlockSize() / 2;
  }
  for (int j=0; j < V; j++) {
    System.arraycopy(Btemp.get(n - 2),0,buffer,0,engine.getBlockSize() / 2);
    System.arraycopy(B,0,buffer,engine.getBlockSize() / 2,engine.getBlockSize() / 2);
    intToBytes(V - j,intArray,0);
    for (int byteNum=0; byteNum < BYTES_IN_INTEGER; byteNum++) {
      buffer[byteNum + engine.getBlockSize() / 2]^=intArray[byteNum];
    }
    engine.processBlock(buffer,0,buffer,0);
    System.arraycopy(buffer,0,B,0,engine.getBlockSize() / 2);
    for (int i=2; i < n; i++) {
      System.arraycopy(Btemp.get(n - i - 1),0,Btemp.get(n - i),0,engine.getBlockSize() / 2);
    }
    System.arraycopy(buffer,engine.getBlockSize() / 2,Btemp.get(0),0,engine.getBlockSize() / 2);
  }
  System.arraycopy(B,0,buffer,0,engine.getBlockSize() / 2);
  bufOff=engine.getBlockSize() / 2;
  for (int i=0; i < n - 1; i++) {
    System.arraycopy(Btemp.get(i),0,buffer,bufOff,engine.getBlockSize() / 2);
    bufOff+=engine.getBlockSize() / 2;
  }
  System.arraycopy(buffer,buffer.length - engine.getBlockSize(),checkSumArray,0,engine.getBlockSize());
  byte[] wrappedBuffer=new byte[buffer.length - engine.getBlockSize()];
  if (!Arrays.areEqual(checkSumArray,zeroArray)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
 else {
    System.arraycopy(buffer,0,wrappedBuffer,0,buffer.length - engine.getBlockSize());
  }
  return wrappedBuffer;
}"
52397,"private CertPathBuilderResult build(X509AttributeCertificate attrCert,X509Certificate tbvCert,PKIXExtendedBuilderParameters pkixParams,List tbvPath){
  if (tbvPath.contains(tbvCert)) {
    return null;
  }
  if (pkixParams.getExcludedCerts().contains(tbvCert)) {
    return null;
  }
  if (pkixParams.getMaxPathLength() != -1) {
    if (tbvPath.size() - 1 > pkixParams.getMaxPathLength()) {
      return null;
    }
  }
  tbvPath.add(tbvCert);
  CertificateFactory cFact;
  CertPathValidator validator;
  CertPathBuilderResult builderResult=null;
  try {
    cFact=CertificateFactory.getInstance(""String_Node_Str"",BouncyCastleProvider.PROVIDER_NAME);
    validator=CertPathValidator.getInstance(""String_Node_Str"",BouncyCastleProvider.PROVIDER_NAME);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    if (CertPathValidatorUtilities.findTrustAnchor(tbvCert,pkixParams.getBaseParameters().getTrustAnchors(),pkixParams.getBaseParameters().getSigProvider()) != null) {
      CertPath certPath;
      PKIXCertPathValidatorResult result;
      try {
        certPath=cFact.generateCertPath(tbvPath);
      }
 catch (      Exception e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      try {
        result=(PKIXCertPathValidatorResult)validator.validate(certPath,pkixParams);
      }
 catch (      Exception e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      return new PKIXCertPathBuilderResult(certPath,result.getTrustAnchor(),result.getPolicyTree(),result.getPublicKey());
    }
 else {
      List stores=new ArrayList();
      stores.addAll(pkixParams.getBaseParameters().getCertificateStores());
      try {
        stores.addAll(CertPathValidatorUtilities.getAdditionalStoresFromAltNames(tbvCert.getExtensionValue(Extension.issuerAlternativeName.getId()),pkixParams.getBaseParameters().getNamedCertificateStoreMap()));
      }
 catch (      CertificateParsingException e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      Collection issuers=new HashSet();
      try {
        issuers.addAll(CertPathValidatorUtilities.findIssuerCerts(tbvCert,pkixParams.getBaseParameters().getCertStores(),stores));
      }
 catch (      AnnotatedException e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      if (issuers.isEmpty()) {
        throw new AnnotatedException(""String_Node_Str"");
      }
      Iterator it=issuers.iterator();
      while (it.hasNext() && builderResult == null) {
        X509Certificate issuer=(X509Certificate)it.next();
        if (issuer.getIssuerX500Principal().equals(issuer.getSubjectX500Principal())) {
          continue;
        }
        builderResult=build(attrCert,issuer,pkixParams,tbvPath);
      }
    }
  }
 catch (  AnnotatedException e) {
    certPathException=new AnnotatedException(""String_Node_Str"",e);
  }
  if (builderResult == null) {
    tbvPath.remove(tbvCert);
  }
  return builderResult;
}","private CertPathBuilderResult build(X509AttributeCertificate attrCert,X509Certificate tbvCert,PKIXExtendedBuilderParameters pkixParams,List tbvPath){
  if (tbvPath.contains(tbvCert)) {
    return null;
  }
  if (pkixParams.getExcludedCerts().contains(tbvCert)) {
    return null;
  }
  if (pkixParams.getMaxPathLength() != -1) {
    if (tbvPath.size() - 1 > pkixParams.getMaxPathLength()) {
      return null;
    }
  }
  tbvPath.add(tbvCert);
  CertificateFactory cFact;
  CertPathValidator validator;
  CertPathBuilderResult builderResult=null;
  try {
    cFact=CertificateFactory.getInstance(""String_Node_Str"",BouncyCastleProvider.PROVIDER_NAME);
    validator=CertPathValidator.getInstance(""String_Node_Str"",BouncyCastleProvider.PROVIDER_NAME);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    if (CertPathValidatorUtilities.isIssuerTrustAnchor(tbvCert,pkixParams.getBaseParameters().getTrustAnchors(),pkixParams.getBaseParameters().getSigProvider())) {
      CertPath certPath;
      PKIXCertPathValidatorResult result;
      try {
        certPath=cFact.generateCertPath(tbvPath);
      }
 catch (      Exception e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      try {
        result=(PKIXCertPathValidatorResult)validator.validate(certPath,pkixParams);
      }
 catch (      Exception e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      return new PKIXCertPathBuilderResult(certPath,result.getTrustAnchor(),result.getPolicyTree(),result.getPublicKey());
    }
 else {
      List stores=new ArrayList();
      stores.addAll(pkixParams.getBaseParameters().getCertificateStores());
      try {
        stores.addAll(CertPathValidatorUtilities.getAdditionalStoresFromAltNames(tbvCert.getExtensionValue(Extension.issuerAlternativeName.getId()),pkixParams.getBaseParameters().getNamedCertificateStoreMap()));
      }
 catch (      CertificateParsingException e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      Collection issuers=new HashSet();
      try {
        issuers.addAll(CertPathValidatorUtilities.findIssuerCerts(tbvCert,pkixParams.getBaseParameters().getCertStores(),stores));
      }
 catch (      AnnotatedException e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      if (issuers.isEmpty()) {
        throw new AnnotatedException(""String_Node_Str"");
      }
      Iterator it=issuers.iterator();
      while (it.hasNext() && builderResult == null) {
        X509Certificate issuer=(X509Certificate)it.next();
        if (issuer.getIssuerX500Principal().equals(issuer.getSubjectX500Principal())) {
          continue;
        }
        builderResult=build(attrCert,issuer,pkixParams,tbvPath);
      }
    }
  }
 catch (  AnnotatedException e) {
    certPathException=new AnnotatedException(""String_Node_Str"",e);
  }
  if (builderResult == null) {
    tbvPath.remove(tbvCert);
  }
  return builderResult;
}"
52398,"protected CertPathBuilderResult build(X509Certificate tbvCert,PKIXExtendedBuilderParameters pkixParams,List tbvPath){
  if (tbvPath.contains(tbvCert)) {
    return null;
  }
  if (pkixParams.getExcludedCerts().contains(tbvCert)) {
    return null;
  }
  if (pkixParams.getMaxPathLength() != -1) {
    if (tbvPath.size() - 1 > pkixParams.getMaxPathLength()) {
      return null;
    }
  }
  tbvPath.add(tbvCert);
  CertificateFactory cFact;
  PKIXCertPathValidatorSpi validator;
  CertPathBuilderResult builderResult=null;
  try {
    cFact=new CertificateFactory();
    validator=new PKIXCertPathValidatorSpi();
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    if (CertPathValidatorUtilities.findTrustAnchor(tbvCert,pkixParams.getBaseParameters().getTrustAnchors(),pkixParams.getBaseParameters().getSigProvider()) != null) {
      CertPath certPath=null;
      PKIXCertPathValidatorResult result=null;
      try {
        certPath=cFact.engineGenerateCertPath(tbvPath);
      }
 catch (      Exception e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      try {
        result=(PKIXCertPathValidatorResult)validator.engineValidate(certPath,pkixParams);
      }
 catch (      Exception e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      return new PKIXCertPathBuilderResult(certPath,result.getTrustAnchor(),result.getPolicyTree(),result.getPublicKey());
    }
 else {
      List stores=new ArrayList();
      stores.addAll(pkixParams.getBaseParameters().getCertificateStores());
      try {
        stores.addAll(CertPathValidatorUtilities.getAdditionalStoresFromAltNames(tbvCert.getExtensionValue(Extension.issuerAlternativeName.getId()),pkixParams.getBaseParameters().getNamedCertificateStoreMap()));
      }
 catch (      CertificateParsingException e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      Collection issuers=new HashSet();
      try {
        issuers.addAll(CertPathValidatorUtilities.findIssuerCerts(tbvCert,pkixParams.getBaseParameters().getCertStores(),stores));
      }
 catch (      AnnotatedException e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      if (issuers.isEmpty()) {
        throw new AnnotatedException(""String_Node_Str"");
      }
      Iterator it=issuers.iterator();
      while (it.hasNext() && builderResult == null) {
        X509Certificate issuer=(X509Certificate)it.next();
        builderResult=build(issuer,pkixParams,tbvPath);
      }
    }
  }
 catch (  AnnotatedException e) {
    certPathException=e;
  }
  if (builderResult == null) {
    tbvPath.remove(tbvCert);
  }
  return builderResult;
}","protected CertPathBuilderResult build(X509Certificate tbvCert,PKIXExtendedBuilderParameters pkixParams,List tbvPath){
  if (tbvPath.contains(tbvCert)) {
    return null;
  }
  if (pkixParams.getExcludedCerts().contains(tbvCert)) {
    return null;
  }
  if (pkixParams.getMaxPathLength() != -1) {
    if (tbvPath.size() - 1 > pkixParams.getMaxPathLength()) {
      return null;
    }
  }
  tbvPath.add(tbvCert);
  CertificateFactory cFact;
  PKIXCertPathValidatorSpi validator;
  CertPathBuilderResult builderResult=null;
  try {
    cFact=new CertificateFactory();
    validator=new PKIXCertPathValidatorSpi();
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    if (CertPathValidatorUtilities.isIssuerTrustAnchor(tbvCert,pkixParams.getBaseParameters().getTrustAnchors(),pkixParams.getBaseParameters().getSigProvider())) {
      CertPath certPath=null;
      PKIXCertPathValidatorResult result=null;
      try {
        certPath=cFact.engineGenerateCertPath(tbvPath);
      }
 catch (      Exception e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      try {
        result=(PKIXCertPathValidatorResult)validator.engineValidate(certPath,pkixParams);
      }
 catch (      Exception e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      return new PKIXCertPathBuilderResult(certPath,result.getTrustAnchor(),result.getPolicyTree(),result.getPublicKey());
    }
 else {
      List stores=new ArrayList();
      stores.addAll(pkixParams.getBaseParameters().getCertificateStores());
      try {
        stores.addAll(CertPathValidatorUtilities.getAdditionalStoresFromAltNames(tbvCert.getExtensionValue(Extension.issuerAlternativeName.getId()),pkixParams.getBaseParameters().getNamedCertificateStoreMap()));
      }
 catch (      CertificateParsingException e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      Collection issuers=new HashSet();
      try {
        issuers.addAll(CertPathValidatorUtilities.findIssuerCerts(tbvCert,pkixParams.getBaseParameters().getCertStores(),stores));
      }
 catch (      AnnotatedException e) {
        throw new AnnotatedException(""String_Node_Str"",e);
      }
      if (issuers.isEmpty()) {
        throw new AnnotatedException(""String_Node_Str"");
      }
      Iterator it=issuers.iterator();
      while (it.hasNext() && builderResult == null) {
        X509Certificate issuer=(X509Certificate)it.next();
        builderResult=build(issuer,pkixParams,tbvPath);
      }
    }
  }
 catch (  AnnotatedException e) {
    certPathException=e;
  }
  if (builderResult == null) {
    tbvPath.remove(tbvCert);
  }
  return builderResult;
}"
52399,"public CertPathValidatorResult engineValidate(CertPath certPath,CertPathParameters params) throws CertPathValidatorException, InvalidAlgorithmParameterException {
  PKIXExtendedParameters paramsPKIX;
  if (params instanceof PKIXParameters) {
    PKIXExtendedParameters.Builder paramsPKIXBldr=new PKIXExtendedParameters.Builder((PKIXParameters)params);
    if (params instanceof ExtendedPKIXParameters) {
      ExtendedPKIXParameters extPKIX=(ExtendedPKIXParameters)params;
      paramsPKIXBldr.setUseDeltasEnabled(extPKIX.isUseDeltasEnabled());
      paramsPKIXBldr.setValidityModel(extPKIX.getValidityModel());
    }
    paramsPKIX=paramsPKIXBldr.build();
  }
 else   if (params instanceof PKIXExtendedBuilderParameters) {
    paramsPKIX=((PKIXExtendedBuilderParameters)params).getBaseParameters();
  }
 else   if (params instanceof PKIXExtendedParameters) {
    paramsPKIX=(PKIXExtendedParameters)params;
  }
 else {
    throw new InvalidAlgorithmParameterException(""String_Node_Str"" + PKIXParameters.class.getName() + ""String_Node_Str"");
  }
  if (paramsPKIX.getTrustAnchors() == null) {
    throw new InvalidAlgorithmParameterException(""String_Node_Str"");
  }
  List certs=certPath.getCertificates();
  int n=certs.size();
  if (certs.isEmpty()) {
    throw new CertPathValidatorException(""String_Node_Str"",null,certPath,-1);
  }
  Set userInitialPolicySet=paramsPKIX.getInitialPolicies();
  TrustAnchor trust;
  try {
    trust=CertPathValidatorUtilities.findTrustAnchor((X509Certificate)certs.get(certs.size() - 1),paramsPKIX.getTrustAnchors(),paramsPKIX.getSigProvider());
    if (trust == null) {
      throw new CertPathValidatorException(""String_Node_Str"",null,certPath,-1);
    }
    checkCertificate(trust.getTrustedCert());
  }
 catch (  AnnotatedException e) {
    throw new CertPathValidatorException(e.getMessage(),e.getUnderlyingException(),certPath,certs.size() - 1);
  }
  paramsPKIX=new PKIXExtendedParameters.Builder(paramsPKIX).setTrustAnchor(trust).build();
  Iterator certIter;
  int index=0;
  int i;
  List[] policyNodes=new ArrayList[n + 1];
  for (int j=0; j < policyNodes.length; j++) {
    policyNodes[j]=new ArrayList();
  }
  Set policySet=new HashSet();
  policySet.add(RFC3280CertPathUtilities.ANY_POLICY);
  PKIXPolicyNode validPolicyTree=new PKIXPolicyNode(new ArrayList(),0,policySet,null,new HashSet(),RFC3280CertPathUtilities.ANY_POLICY,false);
  policyNodes[0].add(validPolicyTree);
  PKIXNameConstraintValidator nameConstraintValidator=new PKIXNameConstraintValidator();
  int explicitPolicy;
  Set acceptablePolicies=new HashSet();
  if (paramsPKIX.isExplicitPolicyRequired()) {
    explicitPolicy=0;
  }
 else {
    explicitPolicy=n + 1;
  }
  int inhibitAnyPolicy;
  if (paramsPKIX.isAnyPolicyInhibited()) {
    inhibitAnyPolicy=0;
  }
 else {
    inhibitAnyPolicy=n + 1;
  }
  int policyMapping;
  if (paramsPKIX.isPolicyMappingInhibited()) {
    policyMapping=0;
  }
 else {
    policyMapping=n + 1;
  }
  PublicKey workingPublicKey;
  X500Name workingIssuerName;
  X509Certificate sign=trust.getTrustedCert();
  try {
    if (sign != null) {
      workingIssuerName=PrincipalUtils.getSubjectPrincipal(sign);
      workingPublicKey=sign.getPublicKey();
    }
 else {
      workingIssuerName=PrincipalUtils.getCA(trust);
      workingPublicKey=trust.getCAPublicKey();
    }
  }
 catch (  IllegalArgumentException ex) {
    throw new ExtCertPathValidatorException(""String_Node_Str"",ex,certPath,-1);
  }
  AlgorithmIdentifier workingAlgId=null;
  try {
    workingAlgId=CertPathValidatorUtilities.getAlgorithmIdentifier(workingPublicKey);
  }
 catch (  CertPathValidatorException e) {
    throw new ExtCertPathValidatorException(""String_Node_Str"",e,certPath,-1);
  }
  ASN1ObjectIdentifier workingPublicKeyAlgorithm=workingAlgId.getAlgorithm();
  ASN1Encodable workingPublicKeyParameters=workingAlgId.getParameters();
  int maxPathLength=n;
  if (paramsPKIX.getTargetConstraints() != null && !paramsPKIX.getTargetConstraints().match((X509Certificate)certs.get(0))) {
    throw new ExtCertPathValidatorException(""String_Node_Str"",null,certPath,0);
  }
  List pathCheckers=paramsPKIX.getCertPathCheckers();
  certIter=pathCheckers.iterator();
  while (certIter.hasNext()) {
    ((PKIXCertPathChecker)certIter.next()).init(false);
  }
  X509Certificate cert=null;
  for (index=certs.size() - 1; index >= 0; index--) {
    i=n - index;
    cert=(X509Certificate)certs.get(index);
    boolean verificationAlreadyPerformed=(index == certs.size() - 1);
    try {
      checkCertificate(cert);
    }
 catch (    AnnotatedException e) {
      throw new CertPathValidatorException(e.getMessage(),e.getUnderlyingException(),certPath,index);
    }
    RFC3280CertPathUtilities.processCertA(certPath,paramsPKIX,index,workingPublicKey,verificationAlreadyPerformed,workingIssuerName,sign,helper);
    RFC3280CertPathUtilities.processCertBC(certPath,index,nameConstraintValidator);
    validPolicyTree=RFC3280CertPathUtilities.processCertD(certPath,index,acceptablePolicies,validPolicyTree,policyNodes,inhibitAnyPolicy);
    validPolicyTree=RFC3280CertPathUtilities.processCertE(certPath,index,validPolicyTree);
    RFC3280CertPathUtilities.processCertF(certPath,index,validPolicyTree,explicitPolicy);
    if (i != n) {
      if (cert != null && cert.getVersion() == 1) {
        throw new CertPathValidatorException(""String_Node_Str"",null,certPath,index);
      }
      RFC3280CertPathUtilities.prepareNextCertA(certPath,index);
      validPolicyTree=RFC3280CertPathUtilities.prepareCertB(certPath,index,policyNodes,validPolicyTree,policyMapping);
      RFC3280CertPathUtilities.prepareNextCertG(certPath,index,nameConstraintValidator);
      explicitPolicy=RFC3280CertPathUtilities.prepareNextCertH1(certPath,index,explicitPolicy);
      policyMapping=RFC3280CertPathUtilities.prepareNextCertH2(certPath,index,policyMapping);
      inhibitAnyPolicy=RFC3280CertPathUtilities.prepareNextCertH3(certPath,index,inhibitAnyPolicy);
      explicitPolicy=RFC3280CertPathUtilities.prepareNextCertI1(certPath,index,explicitPolicy);
      policyMapping=RFC3280CertPathUtilities.prepareNextCertI2(certPath,index,policyMapping);
      inhibitAnyPolicy=RFC3280CertPathUtilities.prepareNextCertJ(certPath,index,inhibitAnyPolicy);
      RFC3280CertPathUtilities.prepareNextCertK(certPath,index);
      maxPathLength=RFC3280CertPathUtilities.prepareNextCertL(certPath,index,maxPathLength);
      maxPathLength=RFC3280CertPathUtilities.prepareNextCertM(certPath,index,maxPathLength);
      RFC3280CertPathUtilities.prepareNextCertN(certPath,index);
      Set criticalExtensions=cert.getCriticalExtensionOIDs();
      if (criticalExtensions != null) {
        criticalExtensions=new HashSet(criticalExtensions);
        criticalExtensions.remove(RFC3280CertPathUtilities.KEY_USAGE);
        criticalExtensions.remove(RFC3280CertPathUtilities.CERTIFICATE_POLICIES);
        criticalExtensions.remove(RFC3280CertPathUtilities.POLICY_MAPPINGS);
        criticalExtensions.remove(RFC3280CertPathUtilities.INHIBIT_ANY_POLICY);
        criticalExtensions.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);
        criticalExtensions.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);
        criticalExtensions.remove(RFC3280CertPathUtilities.POLICY_CONSTRAINTS);
        criticalExtensions.remove(RFC3280CertPathUtilities.BASIC_CONSTRAINTS);
        criticalExtensions.remove(RFC3280CertPathUtilities.SUBJECT_ALTERNATIVE_NAME);
        criticalExtensions.remove(RFC3280CertPathUtilities.NAME_CONSTRAINTS);
      }
 else {
        criticalExtensions=new HashSet();
      }
      RFC3280CertPathUtilities.prepareNextCertO(certPath,index,criticalExtensions,pathCheckers);
      sign=cert;
      workingIssuerName=PrincipalUtils.getSubjectPrincipal(sign);
      try {
        workingPublicKey=CertPathValidatorUtilities.getNextWorkingKey(certPath.getCertificates(),index,helper);
      }
 catch (      CertPathValidatorException e) {
        throw new CertPathValidatorException(""String_Node_Str"",e,certPath,index);
      }
      workingAlgId=CertPathValidatorUtilities.getAlgorithmIdentifier(workingPublicKey);
      workingPublicKeyAlgorithm=workingAlgId.getAlgorithm();
      workingPublicKeyParameters=workingAlgId.getParameters();
    }
  }
  explicitPolicy=RFC3280CertPathUtilities.wrapupCertA(explicitPolicy,cert);
  explicitPolicy=RFC3280CertPathUtilities.wrapupCertB(certPath,index + 1,explicitPolicy);
  Set criticalExtensions=cert.getCriticalExtensionOIDs();
  if (criticalExtensions != null) {
    criticalExtensions=new HashSet(criticalExtensions);
    criticalExtensions.remove(RFC3280CertPathUtilities.KEY_USAGE);
    criticalExtensions.remove(RFC3280CertPathUtilities.CERTIFICATE_POLICIES);
    criticalExtensions.remove(RFC3280CertPathUtilities.POLICY_MAPPINGS);
    criticalExtensions.remove(RFC3280CertPathUtilities.INHIBIT_ANY_POLICY);
    criticalExtensions.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);
    criticalExtensions.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);
    criticalExtensions.remove(RFC3280CertPathUtilities.POLICY_CONSTRAINTS);
    criticalExtensions.remove(RFC3280CertPathUtilities.BASIC_CONSTRAINTS);
    criticalExtensions.remove(RFC3280CertPathUtilities.SUBJECT_ALTERNATIVE_NAME);
    criticalExtensions.remove(RFC3280CertPathUtilities.NAME_CONSTRAINTS);
    criticalExtensions.remove(RFC3280CertPathUtilities.CRL_DISTRIBUTION_POINTS);
    criticalExtensions.remove(Extension.extendedKeyUsage.getId());
  }
 else {
    criticalExtensions=new HashSet();
  }
  RFC3280CertPathUtilities.wrapupCertF(certPath,index + 1,pathCheckers,criticalExtensions);
  PKIXPolicyNode intersection=RFC3280CertPathUtilities.wrapupCertG(certPath,paramsPKIX,userInitialPolicySet,index + 1,policyNodes,validPolicyTree,acceptablePolicies);
  if ((explicitPolicy > 0) || (intersection != null)) {
    return new PKIXCertPathValidatorResult(trust,intersection,cert.getPublicKey());
  }
  throw new CertPathValidatorException(""String_Node_Str"",null,certPath,index);
}","public CertPathValidatorResult engineValidate(CertPath certPath,CertPathParameters params) throws CertPathValidatorException, InvalidAlgorithmParameterException {
  PKIXExtendedParameters paramsPKIX;
  if (params instanceof PKIXParameters) {
    PKIXExtendedParameters.Builder paramsPKIXBldr=new PKIXExtendedParameters.Builder((PKIXParameters)params);
    if (params instanceof ExtendedPKIXParameters) {
      ExtendedPKIXParameters extPKIX=(ExtendedPKIXParameters)params;
      paramsPKIXBldr.setUseDeltasEnabled(extPKIX.isUseDeltasEnabled());
      paramsPKIXBldr.setValidityModel(extPKIX.getValidityModel());
    }
    paramsPKIX=paramsPKIXBldr.build();
  }
 else   if (params instanceof PKIXExtendedBuilderParameters) {
    paramsPKIX=((PKIXExtendedBuilderParameters)params).getBaseParameters();
  }
 else   if (params instanceof PKIXExtendedParameters) {
    paramsPKIX=(PKIXExtendedParameters)params;
  }
 else {
    throw new InvalidAlgorithmParameterException(""String_Node_Str"" + PKIXParameters.class.getName() + ""String_Node_Str"");
  }
  if (paramsPKIX.getTrustAnchors() == null) {
    throw new InvalidAlgorithmParameterException(""String_Node_Str"");
  }
  List certs=certPath.getCertificates();
  int n=certs.size();
  if (certs.isEmpty()) {
    throw new CertPathValidatorException(""String_Node_Str"",null,certPath,-1);
  }
  Set userInitialPolicySet=paramsPKIX.getInitialPolicies();
  TrustAnchor trust;
  try {
    trust=CertPathValidatorUtilities.findTrustAnchor((X509Certificate)certs.get(certs.size() - 1),paramsPKIX.getTrustAnchors(),paramsPKIX.getSigProvider());
    if (trust == null) {
      throw new CertPathValidatorException(""String_Node_Str"",null,certPath,-1);
    }
    checkCertificate(trust.getTrustedCert());
  }
 catch (  AnnotatedException e) {
    throw new CertPathValidatorException(e.getMessage(),e.getUnderlyingException(),certPath,certs.size() - 1);
  }
  paramsPKIX=new PKIXExtendedParameters.Builder(paramsPKIX).setTrustAnchor(trust).build();
  Iterator certIter;
  int index=0;
  int i;
  List[] policyNodes=new ArrayList[n + 1];
  for (int j=0; j < policyNodes.length; j++) {
    policyNodes[j]=new ArrayList();
  }
  Set policySet=new HashSet();
  policySet.add(RFC3280CertPathUtilities.ANY_POLICY);
  PKIXPolicyNode validPolicyTree=new PKIXPolicyNode(new ArrayList(),0,policySet,null,new HashSet(),RFC3280CertPathUtilities.ANY_POLICY,false);
  policyNodes[0].add(validPolicyTree);
  PKIXNameConstraintValidator nameConstraintValidator=new PKIXNameConstraintValidator();
  int explicitPolicy;
  Set acceptablePolicies=new HashSet();
  if (paramsPKIX.isExplicitPolicyRequired()) {
    explicitPolicy=0;
  }
 else {
    explicitPolicy=n + 1;
  }
  int inhibitAnyPolicy;
  if (paramsPKIX.isAnyPolicyInhibited()) {
    inhibitAnyPolicy=0;
  }
 else {
    inhibitAnyPolicy=n + 1;
  }
  int policyMapping;
  if (paramsPKIX.isPolicyMappingInhibited()) {
    policyMapping=0;
  }
 else {
    policyMapping=n + 1;
  }
  PublicKey workingPublicKey;
  X500Name workingIssuerName;
  X509Certificate sign=trust.getTrustedCert();
  try {
    if (sign != null) {
      workingIssuerName=PrincipalUtils.getSubjectPrincipal(sign);
      workingPublicKey=sign.getPublicKey();
    }
 else {
      workingIssuerName=PrincipalUtils.getCA(trust);
      workingPublicKey=trust.getCAPublicKey();
    }
  }
 catch (  IllegalArgumentException ex) {
    throw new ExtCertPathValidatorException(""String_Node_Str"",ex,certPath,-1);
  }
  AlgorithmIdentifier workingAlgId=null;
  try {
    workingAlgId=CertPathValidatorUtilities.getAlgorithmIdentifier(workingPublicKey);
  }
 catch (  CertPathValidatorException e) {
    throw new ExtCertPathValidatorException(""String_Node_Str"",e,certPath,-1);
  }
  ASN1ObjectIdentifier workingPublicKeyAlgorithm=workingAlgId.getAlgorithm();
  ASN1Encodable workingPublicKeyParameters=workingAlgId.getParameters();
  int maxPathLength=n;
  if (paramsPKIX.getTargetConstraints() != null && !paramsPKIX.getTargetConstraints().match((X509Certificate)certs.get(0))) {
    throw new ExtCertPathValidatorException(""String_Node_Str"",null,certPath,0);
  }
  List pathCheckers=paramsPKIX.getCertPathCheckers();
  certIter=pathCheckers.iterator();
  while (certIter.hasNext()) {
    ((PKIXCertPathChecker)certIter.next()).init(false);
  }
  X509Certificate cert=null;
  for (index=certs.size() - 1; index >= 0; index--) {
    i=n - index;
    cert=(X509Certificate)certs.get(index);
    boolean verificationAlreadyPerformed=(index == certs.size() - 1);
    try {
      checkCertificate(cert);
    }
 catch (    AnnotatedException e) {
      throw new CertPathValidatorException(e.getMessage(),e.getUnderlyingException(),certPath,index);
    }
    RFC3280CertPathUtilities.processCertA(certPath,paramsPKIX,index,workingPublicKey,verificationAlreadyPerformed,workingIssuerName,sign,helper);
    RFC3280CertPathUtilities.processCertBC(certPath,index,nameConstraintValidator);
    validPolicyTree=RFC3280CertPathUtilities.processCertD(certPath,index,acceptablePolicies,validPolicyTree,policyNodes,inhibitAnyPolicy);
    validPolicyTree=RFC3280CertPathUtilities.processCertE(certPath,index,validPolicyTree);
    RFC3280CertPathUtilities.processCertF(certPath,index,validPolicyTree,explicitPolicy);
    if (i != n) {
      if (cert != null && cert.getVersion() == 1) {
        if ((i == 1) && cert.equals(trust.getTrustedCert())) {
          continue;
        }
        throw new CertPathValidatorException(""String_Node_Str"",null,certPath,index);
      }
      RFC3280CertPathUtilities.prepareNextCertA(certPath,index);
      validPolicyTree=RFC3280CertPathUtilities.prepareCertB(certPath,index,policyNodes,validPolicyTree,policyMapping);
      RFC3280CertPathUtilities.prepareNextCertG(certPath,index,nameConstraintValidator);
      explicitPolicy=RFC3280CertPathUtilities.prepareNextCertH1(certPath,index,explicitPolicy);
      policyMapping=RFC3280CertPathUtilities.prepareNextCertH2(certPath,index,policyMapping);
      inhibitAnyPolicy=RFC3280CertPathUtilities.prepareNextCertH3(certPath,index,inhibitAnyPolicy);
      explicitPolicy=RFC3280CertPathUtilities.prepareNextCertI1(certPath,index,explicitPolicy);
      policyMapping=RFC3280CertPathUtilities.prepareNextCertI2(certPath,index,policyMapping);
      inhibitAnyPolicy=RFC3280CertPathUtilities.prepareNextCertJ(certPath,index,inhibitAnyPolicy);
      RFC3280CertPathUtilities.prepareNextCertK(certPath,index);
      maxPathLength=RFC3280CertPathUtilities.prepareNextCertL(certPath,index,maxPathLength);
      maxPathLength=RFC3280CertPathUtilities.prepareNextCertM(certPath,index,maxPathLength);
      RFC3280CertPathUtilities.prepareNextCertN(certPath,index);
      Set criticalExtensions=cert.getCriticalExtensionOIDs();
      if (criticalExtensions != null) {
        criticalExtensions=new HashSet(criticalExtensions);
        criticalExtensions.remove(RFC3280CertPathUtilities.KEY_USAGE);
        criticalExtensions.remove(RFC3280CertPathUtilities.CERTIFICATE_POLICIES);
        criticalExtensions.remove(RFC3280CertPathUtilities.POLICY_MAPPINGS);
        criticalExtensions.remove(RFC3280CertPathUtilities.INHIBIT_ANY_POLICY);
        criticalExtensions.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);
        criticalExtensions.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);
        criticalExtensions.remove(RFC3280CertPathUtilities.POLICY_CONSTRAINTS);
        criticalExtensions.remove(RFC3280CertPathUtilities.BASIC_CONSTRAINTS);
        criticalExtensions.remove(RFC3280CertPathUtilities.SUBJECT_ALTERNATIVE_NAME);
        criticalExtensions.remove(RFC3280CertPathUtilities.NAME_CONSTRAINTS);
      }
 else {
        criticalExtensions=new HashSet();
      }
      RFC3280CertPathUtilities.prepareNextCertO(certPath,index,criticalExtensions,pathCheckers);
      sign=cert;
      workingIssuerName=PrincipalUtils.getSubjectPrincipal(sign);
      try {
        workingPublicKey=CertPathValidatorUtilities.getNextWorkingKey(certPath.getCertificates(),index,helper);
      }
 catch (      CertPathValidatorException e) {
        throw new CertPathValidatorException(""String_Node_Str"",e,certPath,index);
      }
      workingAlgId=CertPathValidatorUtilities.getAlgorithmIdentifier(workingPublicKey);
      workingPublicKeyAlgorithm=workingAlgId.getAlgorithm();
      workingPublicKeyParameters=workingAlgId.getParameters();
    }
  }
  explicitPolicy=RFC3280CertPathUtilities.wrapupCertA(explicitPolicy,cert);
  explicitPolicy=RFC3280CertPathUtilities.wrapupCertB(certPath,index + 1,explicitPolicy);
  Set criticalExtensions=cert.getCriticalExtensionOIDs();
  if (criticalExtensions != null) {
    criticalExtensions=new HashSet(criticalExtensions);
    criticalExtensions.remove(RFC3280CertPathUtilities.KEY_USAGE);
    criticalExtensions.remove(RFC3280CertPathUtilities.CERTIFICATE_POLICIES);
    criticalExtensions.remove(RFC3280CertPathUtilities.POLICY_MAPPINGS);
    criticalExtensions.remove(RFC3280CertPathUtilities.INHIBIT_ANY_POLICY);
    criticalExtensions.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);
    criticalExtensions.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);
    criticalExtensions.remove(RFC3280CertPathUtilities.POLICY_CONSTRAINTS);
    criticalExtensions.remove(RFC3280CertPathUtilities.BASIC_CONSTRAINTS);
    criticalExtensions.remove(RFC3280CertPathUtilities.SUBJECT_ALTERNATIVE_NAME);
    criticalExtensions.remove(RFC3280CertPathUtilities.NAME_CONSTRAINTS);
    criticalExtensions.remove(RFC3280CertPathUtilities.CRL_DISTRIBUTION_POINTS);
    criticalExtensions.remove(Extension.extendedKeyUsage.getId());
  }
 else {
    criticalExtensions=new HashSet();
  }
  RFC3280CertPathUtilities.wrapupCertF(certPath,index + 1,pathCheckers,criticalExtensions);
  PKIXPolicyNode intersection=RFC3280CertPathUtilities.wrapupCertG(certPath,paramsPKIX,userInitialPolicySet,index + 1,policyNodes,validPolicyTree,acceptablePolicies);
  if ((explicitPolicy > 0) || (intersection != null)) {
    return new PKIXCertPathValidatorResult(trust,intersection,cert.getPublicKey());
  }
  throw new CertPathValidatorException(""String_Node_Str"",null,certPath,index);
}"
52400,"public void performTest() throws Exception {
  CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
  X509Certificate rootCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(CertPathTest.rootCertBin));
  X509Certificate interCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(CertPathTest.interCertBin));
  X509Certificate finalCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(CertPathTest.finalCertBin));
  X509CRL rootCrl=(X509CRL)cf.generateCRL(new ByteArrayInputStream(CertPathTest.rootCrlBin));
  X509CRL interCrl=(X509CRL)cf.generateCRL(new ByteArrayInputStream(CertPathTest.interCrlBin));
  List list=new ArrayList();
  list.add(rootCert);
  list.add(interCert);
  list.add(finalCert);
  list.add(rootCrl);
  list.add(interCrl);
  CollectionCertStoreParameters ccsp=new CollectionCertStoreParameters(list);
  CertStore store=CertStore.getInstance(""String_Node_Str"",ccsp,""String_Node_Str"");
  Date validDate=new Date(rootCrl.getThisUpdate().getTime() + 60 * 60 * 1000);
  List certchain=new ArrayList();
  certchain.add(finalCert);
  certchain.add(interCert);
  CertPath cp=CertificateFactory.getInstance(""String_Node_Str"",""String_Node_Str"").generateCertPath(certchain);
  Set trust=new HashSet();
  trust.add(new TrustAnchor(rootCert,null));
  CertPathValidator cpv=CertPathValidator.getInstance(""String_Node_Str"",""String_Node_Str"");
  PKIXParameters param=new PKIXParameters(trust);
  param.addCertStore(store);
  param.setDate(validDate);
  MyChecker checker=new MyChecker();
  param.addCertPathChecker(checker);
  PKIXCertPathValidatorResult result=(PKIXCertPathValidatorResult)cpv.validate(cp,param);
  PolicyNode policyTree=result.getPolicyTree();
  PublicKey subjectPublicKey=result.getPublicKey();
  if (checker.getCount() != 2) {
    fail(""String_Node_Str"");
  }
  if (!subjectPublicKey.equals(finalCert.getPublicKey())) {
    fail(""String_Node_Str"");
  }
  try {
    rootCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(AC_RAIZ_ICPBRASIL));
    interCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(AC_PR));
    finalCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(schefer));
    list=new ArrayList();
    list.add(rootCert);
    list.add(interCert);
    list.add(finalCert);
    ccsp=new CollectionCertStoreParameters(list);
    store=CertStore.getInstance(""String_Node_Str"",ccsp);
    validDate=new Date(finalCert.getNotBefore().getTime() + 60 * 60 * 1000);
    certchain=new ArrayList();
    certchain.add(finalCert);
    certchain.add(interCert);
    cp=CertificateFactory.getInstance(""String_Node_Str"",""String_Node_Str"").generateCertPath(certchain);
    trust=new HashSet();
    trust.add(new TrustAnchor(rootCert,null));
    cpv=CertPathValidator.getInstance(""String_Node_Str"",""String_Node_Str"");
    param=new PKIXParameters(trust);
    param.addCertStore(store);
    param.setRevocationEnabled(false);
    param.setDate(validDate);
    result=(PKIXCertPathValidatorResult)cpv.validate(cp,param);
    policyTree=result.getPolicyTree();
    subjectPublicKey=result.getPublicKey();
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    if (!(e instanceof CertPathValidatorException && e.getMessage().startsWith(""String_Node_Str""))) {
      fail(""String_Node_Str"",e);
    }
  }
  checkCircProcessing();
  checkPolicyProcessingAtDomainMatch();
  validateWithExtendedKeyUsage();
  testEmptyPath();
  checkInvalidCertPath();
}","public void performTest() throws Exception {
  CertificateFactory cf=CertificateFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
  X509Certificate rootCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(CertPathTest.rootCertBin));
  X509Certificate interCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(CertPathTest.interCertBin));
  X509Certificate finalCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(CertPathTest.finalCertBin));
  X509CRL rootCrl=(X509CRL)cf.generateCRL(new ByteArrayInputStream(CertPathTest.rootCrlBin));
  X509CRL interCrl=(X509CRL)cf.generateCRL(new ByteArrayInputStream(CertPathTest.interCrlBin));
  List list=new ArrayList();
  list.add(rootCert);
  list.add(interCert);
  list.add(finalCert);
  list.add(rootCrl);
  list.add(interCrl);
  CollectionCertStoreParameters ccsp=new CollectionCertStoreParameters(list);
  CertStore store=CertStore.getInstance(""String_Node_Str"",ccsp,""String_Node_Str"");
  Date validDate=new Date(rootCrl.getThisUpdate().getTime() + 60 * 60 * 1000);
  List certchain=new ArrayList();
  certchain.add(finalCert);
  certchain.add(interCert);
  CertPath cp=CertificateFactory.getInstance(""String_Node_Str"",""String_Node_Str"").generateCertPath(certchain);
  Set trust=new HashSet();
  trust.add(new TrustAnchor(rootCert,null));
  CertPathValidator cpv=CertPathValidator.getInstance(""String_Node_Str"",""String_Node_Str"");
  PKIXParameters param=new PKIXParameters(trust);
  param.addCertStore(store);
  param.setDate(validDate);
  MyChecker checker=new MyChecker();
  param.addCertPathChecker(checker);
  PKIXCertPathValidatorResult result=(PKIXCertPathValidatorResult)cpv.validate(cp,param);
  PolicyNode policyTree=result.getPolicyTree();
  PublicKey subjectPublicKey=result.getPublicKey();
  if (checker.getCount() != 2) {
    fail(""String_Node_Str"");
  }
  if (!subjectPublicKey.equals(finalCert.getPublicKey())) {
    fail(""String_Node_Str"");
  }
  isTrue(result.getTrustAnchor().getTrustedCert().equals(rootCert));
  certchain.clear();
  certchain.add(finalCert);
  certchain.add(interCert);
  certchain.add(rootCert);
  cp=CertificateFactory.getInstance(""String_Node_Str"",""String_Node_Str"").generateCertPath(certchain);
  cpv=CertPathValidator.getInstance(""String_Node_Str"",""String_Node_Str"");
  param=new PKIXParameters(trust);
  param.addCertStore(store);
  param.setDate(validDate);
  result=(PKIXCertPathValidatorResult)cpv.validate(cp,param);
  isTrue(result.getTrustAnchor().getTrustedCert().equals(rootCert));
  try {
    rootCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(AC_RAIZ_ICPBRASIL));
    interCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(AC_PR));
    finalCert=(X509Certificate)cf.generateCertificate(new ByteArrayInputStream(schefer));
    list=new ArrayList();
    list.add(rootCert);
    list.add(interCert);
    list.add(finalCert);
    ccsp=new CollectionCertStoreParameters(list);
    store=CertStore.getInstance(""String_Node_Str"",ccsp);
    validDate=new Date(finalCert.getNotBefore().getTime() + 60 * 60 * 1000);
    certchain=new ArrayList();
    certchain.add(finalCert);
    certchain.add(interCert);
    cp=CertificateFactory.getInstance(""String_Node_Str"",""String_Node_Str"").generateCertPath(certchain);
    trust=new HashSet();
    trust.add(new TrustAnchor(rootCert,null));
    cpv=CertPathValidator.getInstance(""String_Node_Str"",""String_Node_Str"");
    param=new PKIXParameters(trust);
    param.addCertStore(store);
    param.setRevocationEnabled(false);
    param.setDate(validDate);
    result=(PKIXCertPathValidatorResult)cpv.validate(cp,param);
    policyTree=result.getPolicyTree();
    subjectPublicKey=result.getPublicKey();
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    if (!(e instanceof CertPathValidatorException && e.getMessage().startsWith(""String_Node_Str""))) {
      fail(""String_Node_Str"",e);
    }
  }
  checkCircProcessing();
  checkPolicyProcessingAtDomainMatch();
  validateWithExtendedKeyUsage();
  testEmptyPath();
  checkInvalidCertPath();
}"
52401,"public boolean verifySignature(byte[] message,BigInteger r,BigInteger s){
  BigInteger n=ecParams.getN();
  if (r.compareTo(ONE) < 0 || r.compareTo(n) > 0) {
    return false;
  }
  if (s.compareTo(ONE) < 0 || s.compareTo(n) > 0) {
    return false;
  }
  ECPoint q=((ECPublicKeyParameters)ecKey).getQ();
  SM3Digest digest=new SM3Digest();
  byte[] z=getZ(digest);
  digest.update(z,0,z.length);
  digest.update(message,0,message.length);
  byte[] eHash=new byte[digest.getDigestSize()];
  digest.doFinal(eHash,0);
  BigInteger e=calculateE(eHash);
  BigInteger t=r.add(s).mod(n);
  if (t.equals(ZERO)) {
    return false;
  }
 else {
    ECPoint x1y1=ecParams.getG().multiply(s);
    x1y1=x1y1.add(q.multiply(t)).normalize();
    return r.equals(e.add(x1y1.getAffineXCoord().toBigInteger()).mod(n));
  }
}","public boolean verifySignature(byte[] message,BigInteger r,BigInteger s){
  BigInteger n=ecParams.getN();
  if (r.compareTo(ONE) < 0 || r.compareTo(n) >= 0) {
    return false;
  }
  if (s.compareTo(ONE) < 0 || s.compareTo(n) >= 0) {
    return false;
  }
  ECPoint q=((ECPublicKeyParameters)ecKey).getQ();
  SM3Digest digest=new SM3Digest();
  byte[] z=getZ(digest);
  digest.update(z,0,z.length);
  digest.update(message,0,message.length);
  byte[] eHash=new byte[digest.getDigestSize()];
  digest.doFinal(eHash,0);
  BigInteger e=calculateE(eHash);
  BigInteger t=r.add(s).mod(n);
  if (t.equals(ZERO)) {
    return false;
  }
 else {
    ECPoint x1y1=ecParams.getG().multiply(s);
    x1y1=x1y1.add(q.multiply(t)).normalize();
    return r.equals(e.add(x1y1.getAffineXCoord().toBigInteger()).mod(n));
  }
}"
52402,"public void performTest() throws Exception {
  doSignerTestFp();
  doSignerTestF2m();
}","public void performTest() throws Exception {
  doSignerTestFp();
  doSignerTestF2m();
  doVerifyBoundsCheck();
}"
52403,"public int doFinal(byte[] out,int outOff){
  padded=pad(buf,0,bufOff);
  processBlock(padded,0);
  byte[][] temp=new byte[STATE_BYTES_SIZE_1024][];
  for (int bufferIndex=0; bufferIndex < state.length; bufferIndex++) {
    temp[bufferIndex]=new byte[ROWS];
    System.arraycopy(state[bufferIndex],0,temp[bufferIndex],0,ROWS);
  }
  for (int roundIndex=0; roundIndex < rounds; roundIndex++) {
    for (int columnIndex=0; columnIndex < columns; columnIndex++) {
      temp[columnIndex][0]^=(byte)((columnIndex * 0x10) ^ roundIndex);
    }
    for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
      for (int columnIndex=0; columnIndex < columns; columnIndex++) {
        temp[columnIndex][rowIndex]=sBoxes[rowIndex % 4][temp[columnIndex][rowIndex] & 0xFF];
      }
    }
    int shift=-1;
    for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
      if ((rowIndex == ROWS - 1) && (columns == NB_1024)) {
        shift=11;
      }
 else {
        shift++;
      }
      for (int columnIndex=0; columnIndex < columns; columnIndex++) {
        tempBuffer[(columnIndex + shift) % columns]=temp[columnIndex][rowIndex];
      }
      for (int columnIndex=0; columnIndex < columns; columnIndex++) {
        temp[columnIndex][rowIndex]=tempBuffer[columnIndex];
      }
    }
    byte multiplicationResult;
    for (int columnIndex=0; columnIndex < columns; columnIndex++) {
      Arrays.fill(mixColumnsResult,(byte)0);
      for (int rowIndex=ROWS - 1; rowIndex >= 0; rowIndex--) {
        multiplicationResult=0;
        for (int rowInternalIndex=ROWS - 1; rowInternalIndex >= 0; rowInternalIndex--) {
          multiplicationResult^=multiplyGF(temp[columnIndex][rowInternalIndex],mds_matrix[rowIndex][rowInternalIndex]);
        }
        mixColumnsResult[rowIndex]=multiplicationResult;
      }
      for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
        temp[columnIndex][rowIndex]=mixColumnsResult[rowIndex];
      }
    }
  }
  for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
    for (int columnIndex=0; columnIndex < columns; columnIndex++) {
      state[columnIndex][rowIndex]^=temp[columnIndex][rowIndex];
    }
  }
  byte[] stateBuffer=new byte[ROWS * columns];
  int stateLineIndex=0;
  for (int columnIndex=0; columnIndex < columns; columnIndex++) {
    for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
      stateBuffer[stateLineIndex]=state[columnIndex][rowIndex];
      stateLineIndex++;
    }
  }
  System.arraycopy(stateBuffer,stateBuffer.length - hashSize,out,outOff,hashSize);
  return hashSize;
}","public int doFinal(byte[] out,int outOff){
  padded=pad(buf,0,bufOff);
  processBlock(padded,0);
  byte[][] temp=new byte[STATE_BYTES_SIZE_1024][];
  for (int bufferIndex=0; bufferIndex < state.length; bufferIndex++) {
    temp[bufferIndex]=new byte[ROWS];
    System.arraycopy(state[bufferIndex],0,temp[bufferIndex],0,ROWS);
  }
  for (int roundIndex=0; roundIndex < rounds; roundIndex++) {
    for (int columnIndex=0; columnIndex < columns; columnIndex++) {
      temp[columnIndex][0]^=(byte)((columnIndex * 0x10) ^ roundIndex);
    }
    for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
      for (int columnIndex=0; columnIndex < columns; columnIndex++) {
        temp[columnIndex][rowIndex]=sBoxes[rowIndex % 4][temp[columnIndex][rowIndex] & 0xFF];
      }
    }
    int shift=-1;
    for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
      if ((rowIndex == ROWS - 1) && (columns == NB_1024)) {
        shift=11;
      }
 else {
        shift++;
      }
      for (int columnIndex=0; columnIndex < columns; columnIndex++) {
        tempBuffer[(columnIndex + shift) % columns]=temp[columnIndex][rowIndex];
      }
      for (int columnIndex=0; columnIndex < columns; columnIndex++) {
        temp[columnIndex][rowIndex]=tempBuffer[columnIndex];
      }
    }
    byte multiplicationResult;
    for (int columnIndex=0; columnIndex < columns; columnIndex++) {
      Arrays.fill(mixColumnsResult,(byte)0);
      for (int rowIndex=ROWS - 1; rowIndex >= 0; rowIndex--) {
        multiplicationResult=0;
        for (int rowInternalIndex=ROWS - 1; rowInternalIndex >= 0; rowInternalIndex--) {
          multiplicationResult^=multiplyGF(temp[columnIndex][rowInternalIndex],mds_matrix[rowIndex][rowInternalIndex]);
        }
        mixColumnsResult[rowIndex]=multiplicationResult;
      }
      for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
        temp[columnIndex][rowIndex]=mixColumnsResult[rowIndex];
      }
    }
  }
  for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
    for (int columnIndex=0; columnIndex < columns; columnIndex++) {
      state[columnIndex][rowIndex]^=temp[columnIndex][rowIndex];
    }
  }
  byte[] stateBuffer=new byte[ROWS * columns];
  int stateLineIndex=0;
  for (int columnIndex=0; columnIndex < columns; columnIndex++) {
    for (int rowIndex=0; rowIndex < ROWS; rowIndex++) {
      stateBuffer[stateLineIndex]=state[columnIndex][rowIndex];
      stateLineIndex++;
    }
  }
  System.arraycopy(stateBuffer,stateBuffer.length - hashSize,out,outOff,hashSize);
  reset();
  return hashSize;
}"
52404,"private byte[] pad(byte[] in,int inOff,int len){
  byte[] padded;
  if (len % blockSize == 0) {
    padded=new byte[len + blockSize];
  }
 else {
    int blocks=len / blockSize;
    padded=new byte[(blocks * blockSize) + blockSize];
  }
  System.arraycopy(in,inOff,padded,0,len);
  padded[len]=(byte)0x80;
  intToBytes(inputLength * BITS_IN_BYTE,padded,padded.length - 12);
  return padded;
}","private byte[] pad(byte[] in,int inOff,int len){
  byte[] padded;
  if (blockSize - len < 12) {
    padded=new byte[2 * blockSize];
  }
 else {
    padded=new byte[blockSize];
  }
  System.arraycopy(in,inOff,padded,0,len);
  padded[len]=(byte)0x80;
  Pack.longToLittleEndian(inputLength * BITS_IN_BYTE,padded,padded.length - 12);
  return padded;
}"
52405,"public void reset(){
  for (int bufferIndex=0; bufferIndex < state.length; bufferIndex++) {
    state[bufferIndex]=new byte[columns];
  }
  state[0][0]=(byte)state.length;
  Arrays.fill(padded,(byte)0);
}","public void reset(){
  for (int bufferIndex=0; bufferIndex < state.length; bufferIndex++) {
    state[bufferIndex]=new byte[columns];
  }
  state[0][0]=(byte)state.length;
  inputLength=0;
  Arrays.fill(padded,(byte)0);
}"
52406,"private byte[] pad(){
  byte[] padded=new byte[engine.getByteLength() - (inputLength % engine.getByteLength())];
  padded[0]=(byte)0x80;
  intToBytes(inputLength * BITS_IN_BYTE,padded,padded.length - 12);
  engine.update(padded,0,padded.length);
  return padded;
}","private void pad(){
  int extra=engine.getByteLength() - (int)(inputLength % engine.getByteLength());
  if (extra < 12) {
    extra=engine.getByteLength();
  }
  byte[] padded=new byte[extra];
  padded[0]=(byte)0x80;
  Pack.longToLittleEndian(inputLength * BITS_IN_BYTE,padded,padded.length - 12);
  engine.update(padded,0,padded.length);
}"
52407,"public DSTU7564Mac(int macBitSize){
  this.engine=new DSTU7564Digest(macBitSize);
  this.macSize=macBitSize / BITS_IN_BYTE;
  this.paddedKey=null;
  this.invertedKey=null;
  this.paddedIn=null;
}","public DSTU7564Mac(int macBitSize){
  this.engine=new DSTU7564Digest(macBitSize);
  this.macSize=macBitSize / BITS_IN_BYTE;
  this.paddedKey=null;
  this.invertedKey=null;
}"
52408,"private byte[] padKey(byte[] in,int inOff,int len){
  byte[] padded;
  if (len % engine.getByteLength() == 0) {
    padded=new byte[len + engine.getByteLength()];
  }
 else {
    int blocks=len / engine.getByteLength();
    padded=new byte[(blocks * engine.getByteLength()) + engine.getByteLength()];
  }
  System.arraycopy(in,inOff,padded,0,len);
  padded[len]=(byte)0x80;
  intToBytes(len * BITS_IN_BYTE,padded,padded.length - 12);
  return padded;
}","private byte[] padKey(byte[] in,int inOff,int len){
  byte[] padded;
  if (len % engine.getByteLength() == 0) {
    padded=new byte[len + engine.getByteLength()];
  }
 else {
    int blocks=len / engine.getByteLength();
    padded=new byte[(blocks * engine.getByteLength()) + engine.getByteLength()];
  }
  System.arraycopy(in,inOff,padded,0,len);
  padded[len]=(byte)0x80;
  Pack.intToLittleEndian(len * BITS_IN_BYTE,padded,padded.length - 12);
  return padded;
}"
52409,"@Override public void performTest(){
  TestResult result;
  result=hash256Tests();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  result=hash384Tests();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  result=hash512Tests();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  result=macTests();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  System.out.println(result);
}","@Override public void performTest(){
  TestResult result;
  result=hash256Tests();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  result=hash384Tests();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  result=hash512Tests();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  result=macTests();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  result=overflowTest();
  if (!result.isSuccessful()) {
    System.out.println(result);
    return;
  }
  System.out.println(result);
}"
52410,"public void reset(){
  for (int bufferIndex=0; bufferIndex < state.length; bufferIndex++) {
    state[bufferIndex]=new byte[columns];
  }
  state[0][0]=(byte)state.length;
  inputLength=0;
  bufOff=0;
  Arrays.fill(buf,(byte)0);
  Arrays.fill(padded,(byte)0);
}","public void reset(Memoable other){
  DSTU7564Digest d=(DSTU7564Digest)other;
  copyIn(d);
}"
52411,"public void init(CipherParameters params) throws IllegalArgumentException {
  if (params instanceof KeyParameter) {
    byte[] key=((KeyParameter)params).getKey();
    invertedKey=new byte[key.length];
    paddedKey=padKey(key,0,key.length);
    for (int byteIndex=0; byteIndex < invertedKey.length; byteIndex++) {
      invertedKey[byteIndex]=(byte)(key[byteIndex] ^ (byte)0xFF);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  engine.update(paddedKey,0,paddedKey.length);
}","public void init(CipherParameters params) throws IllegalArgumentException {
  if (params instanceof KeyParameter) {
    byte[] key=((KeyParameter)params).getKey();
    invertedKey=new byte[key.length];
    paddedKey=padKey(key);
    for (int byteIndex=0; byteIndex < invertedKey.length; byteIndex++) {
      invertedKey[byteIndex]=(byte)(key[byteIndex] ^ (byte)0xFF);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  engine.update(paddedKey,0,paddedKey.length);
}"
52412,"private void pad(){
  int extra=engine.getByteLength() - (int)(inputLength % engine.getByteLength());
  if (extra < 13) {
    extra=engine.getByteLength();
  }
  byte[] padded=new byte[extra];
  padded[0]=(byte)0x80;
  Pack.longToLittleEndian(inputLength * BITS_IN_BYTE,padded,padded.length - 12);
  engine.update(padded,0,padded.length);
}","private void pad(){
  int extra=engine.getByteLength() - (int)(inputLength % engine.getByteLength());
  if (extra < 13) {
    extra+=engine.getByteLength();
  }
  byte[] padded=new byte[extra];
  padded[0]=(byte)0x80;
  Pack.longToLittleEndian(inputLength * BITS_IN_BYTE,padded,padded.length - 12);
  engine.update(padded,0,padded.length);
}"
52413,"private byte[] padKey(byte[] in,int inOff,int len){
  byte[] padded;
  if (len % engine.getByteLength() == 0) {
    padded=new byte[len + engine.getByteLength()];
  }
 else {
    int blocks=len / engine.getByteLength();
    padded=new byte[(blocks * engine.getByteLength()) + engine.getByteLength()];
  }
  System.arraycopy(in,inOff,padded,0,len);
  padded[len]=(byte)0x80;
  Pack.intToLittleEndian(len * BITS_IN_BYTE,padded,padded.length - 12);
  return padded;
}","private byte[] padKey(byte[] in){
  int paddedLen=((in.length + engine.getByteLength() - 1) / engine.getByteLength()) * engine.getByteLength();
  int extra=engine.getByteLength() - (int)(in.length % engine.getByteLength());
  if (extra < 13) {
    paddedLen+=engine.getByteLength();
  }
  byte[] padded=new byte[paddedLen];
  System.arraycopy(in,0,padded,0,in.length);
  padded[in.length]=(byte)0x80;
  Pack.intToLittleEndian(in.length * BITS_IN_BYTE,padded,padded.length - 12);
  return padded;
}"
52414,"protected Digest cloneDigest(Digest digest){
  return null;
}","protected Digest cloneDigest(Digest digest){
  return new DSTU7564Digest((DSTU7564Digest)digest);
}"
52415,"public DSTU7564Test(){
  super(new DSTU7564Digest(256),new String[0],new String[0]);
}","public DSTU7564Test(){
  super(new DSTU7564Digest(256),messages,digests);
}"
52416,"private void macTests(){
  int macBitSize=256;
  byte[] input=Hex.decode(""String_Node_Str"");
  byte[] key=Hex.decode(""String_Node_Str"");
  byte[] expectedMac=Hex.decode(""String_Node_Str"");
  byte[] mac=new byte[macBitSize / 8];
  DSTU7564Mac dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
  macBitSize=384;
  input=Hex.decode(""String_Node_Str"");
  key=Hex.decode(""String_Node_Str"");
  expectedMac=Hex.decode(""String_Node_Str"");
  mac=new byte[macBitSize / 8];
  dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
  macBitSize=512;
  input=Hex.decode(""String_Node_Str"");
  key=Hex.decode(""String_Node_Str"");
  expectedMac=Hex.decode(""String_Node_Str"");
  mac=new byte[macBitSize / 8];
  dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
}","private void macTests(){
  int macBitSize=256;
  byte[] input=Hex.decode(""String_Node_Str"");
  byte[] key=Hex.decode(""String_Node_Str"");
  byte[] expectedMac=Hex.decode(""String_Node_Str"");
  byte[] mac=new byte[macBitSize / 8];
  DSTU7564Mac dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
  input=Hex.decode(""String_Node_Str"");
  key=Hex.decode(""String_Node_Str"");
  expectedMac=Hex.decode(""String_Node_Str"");
  mac=new byte[macBitSize / 8];
  dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
  macBitSize=384;
  input=Hex.decode(""String_Node_Str"");
  key=Hex.decode(""String_Node_Str"");
  expectedMac=Hex.decode(""String_Node_Str"");
  mac=new byte[macBitSize / 8];
  dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
  macBitSize=512;
  input=Hex.decode(""String_Node_Str"");
  key=Hex.decode(""String_Node_Str"");
  expectedMac=Hex.decode(""String_Node_Str"");
  mac=new byte[macBitSize / 8];
  dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
}"
52417,"@Override public void performTest(){
  hash256Tests();
  hash384Tests();
  hash512Tests();
  macTests();
  overflowTest();
}","@Override public void performTest(){
  super.performTest();
  overflowTest();
}"
52418,"private void overflowTest(){
  int macBitSize=256;
  byte[] input=new byte[1024];
  for (int i=0; i != input.length; i++) {
    input[i]=(byte)(i & 0xff);
  }
  byte[] key=Hex.decode(""String_Node_Str"");
  byte[] expectedMac=Hex.decode(""String_Node_Str"");
  byte[] mac=new byte[macBitSize / 8];
  DSTU7564Mac dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
  macBitSize=256;
  input=new byte[1023];
  for (int i=0; i != input.length; i++) {
    input[i]=(byte)(i & 0xff);
  }
  key=Hex.decode(""String_Node_Str"");
  expectedMac=Hex.decode(""String_Node_Str"");
  mac=new byte[macBitSize / 8];
  dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
  DSTU7564Digest digest=new DSTU7564Digest(macBitSize);
  byte[] expectedDigest=Hex.decode(""String_Node_Str"");
  byte[] digestBuf=new byte[macBitSize / 8];
  digest.update(input,0,input.length);
  digest.doFinal(digestBuf,0);
  if (!Arrays.areEqual(expectedDigest,digestBuf)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedDigest) + ""String_Node_Str""+ Hex.toHexString(digestBuf));
  }
  expectedDigest=Hex.decode(""String_Node_Str"");
  input=new byte[51];
  for (int i=0; i != input.length; i++) {
    input[i]=(byte)(i & 0xff);
  }
  digest.update(input,0,input.length);
  digest.doFinal(digestBuf,0);
  if (!Arrays.areEqual(expectedDigest,digestBuf)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedDigest) + ""String_Node_Str""+ Hex.toHexString(digestBuf));
  }
  input=new byte[52];
  for (int i=0; i != input.length; i++) {
    input[i]=(byte)(i & 0xff);
  }
  expectedDigest=Hex.decode(""String_Node_Str"");
  digest.update(input,0,input.length);
  digest.doFinal(digestBuf,0);
  if (!Arrays.areEqual(expectedDigest,digestBuf)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedDigest) + ""String_Node_Str""+ Hex.toHexString(digestBuf));
  }
}","private void overflowTest(){
  int macBitSize=256;
  byte[] input=new byte[1024];
  for (int i=0; i != input.length; i++) {
    input[i]=(byte)(i & 0xff);
  }
  byte[] key=Hex.decode(""String_Node_Str"");
  byte[] expectedMac=Hex.decode(""String_Node_Str"");
  byte[] mac=new byte[macBitSize / 8];
  DSTU7564Mac dstu7564mac=new DSTU7564Mac(macBitSize);
  macBitSize=256;
  input=new byte[1023];
  for (int i=0; i != input.length; i++) {
    input[i]=(byte)(i & 0xff);
  }
  key=Hex.decode(""String_Node_Str"");
  expectedMac=Hex.decode(""String_Node_Str"");
  mac=new byte[macBitSize / 8];
  dstu7564mac=new DSTU7564Mac(macBitSize);
  dstu7564mac.init(new KeyParameter(key));
  dstu7564mac.update(input,0,input.length);
  dstu7564mac.doFinal(mac,0);
  if (!Arrays.areEqual(expectedMac,mac)) {
    fail(""String_Node_Str"" + Hex.toHexString(expectedMac) + ""String_Node_Str""+ Hex.toHexString(mac));
  }
}"
52419,"public void performTest() throws Exception {
  signTest();
}","public void performTest() throws Exception {
  alltest();
}"
52420,"public void configure(ConfigurableProvider provider){
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  registerOid(provider,CryptoProObjectIdentifiers.gostR3410_2001,""String_Node_Str"",new KeyFactorySpi());
  registerOidAlgorithmParameters(provider,CryptoProObjectIdentifiers.gostR3410_2001,""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_2001);
  provider.addAlgorithm(""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  registerOid(provider,RosstandartObjectIdentifiers.id_tc26_gost_3410_12_256,""String_Node_Str"",new org.bouncycastle.jcajce.provider.asymmetric.ecgost12.KeyFactorySpi());
  registerOidAlgorithmParameters(provider,RosstandartObjectIdentifiers.id_tc26_gost_3410_12_256,""String_Node_Str"");
  registerOid(provider,RosstandartObjectIdentifiers.id_tc26_gost_3410_12_512,""String_Node_Str"",new org.bouncycastle.jcajce.provider.asymmetric.ecgost12.KeyFactorySpi());
  registerOidAlgorithmParameters(provider,RosstandartObjectIdentifiers.id_tc26_gost_3410_12_512,""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"",RosstandartObjectIdentifiers.id_tc26_signwithdigest_gost_3410_12_256);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"",RosstandartObjectIdentifiers.id_tc26_signwithdigest_gost_3410_12_256);
  provider.addAlgorithm(""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"",RosstandartObjectIdentifiers.id_tc26_signwithdigest_gost_3410_12_512);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"",RosstandartObjectIdentifiers.id_tc26_signwithdigest_gost_3410_12_512);
}","public void configure(ConfigurableProvider provider){
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  registerOid(provider,CryptoProObjectIdentifiers.gostR3410_2001,""String_Node_Str"",new KeyFactorySpi());
  registerOidAlgorithmParameters(provider,CryptoProObjectIdentifiers.gostR3410_2001,""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_2001);
  provider.addAlgorithm(""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  registerOid(provider,RosstandartObjectIdentifiers.id_tc26_gost_3410_12_256,""String_Node_Str"",new org.bouncycastle.jcajce.provider.asymmetric.ecgost12.KeyFactorySpi());
  registerOidAlgorithmParameters(provider,RosstandartObjectIdentifiers.id_tc26_gost_3410_12_256,""String_Node_Str"");
  registerOid(provider,RosstandartObjectIdentifiers.id_tc26_gost_3410_12_512,""String_Node_Str"",new org.bouncycastle.jcajce.provider.asymmetric.ecgost12.KeyFactorySpi());
  registerOidAlgorithmParameters(provider,RosstandartObjectIdentifiers.id_tc26_gost_3410_12_512,""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"",RosstandartObjectIdentifiers.id_tc26_signwithdigest_gost_3410_12_256);
  provider.addAlgorithm(""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX_GOST_2012 + ""String_Node_Str"",RosstandartObjectIdentifiers.id_tc26_signwithdigest_gost_3410_12_512);
}"
52421,"public PKIData(ASN1Sequence seq){
  if (seq.size() != 4) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ASN1Sequence s=((ASN1Sequence)seq.getObjectAt(0));
  controlSequence=new TaggedAttribute[s.size()];
  for (int t=0; t < controlSequence.length; t++) {
    controlSequence[t]=TaggedAttribute.getInstance(s.getObjectAt(t));
  }
  s=((ASN1Sequence)seq.getObjectAt(1));
  reqSequence=new TaggedRequest[s.size()];
  for (int t=0; t < controlSequence.length; t++) {
    reqSequence[t]=TaggedRequest.getInstance(s.getObjectAt(t));
  }
  s=((ASN1Sequence)seq.getObjectAt(2));
  cmsSequence=new TaggedContentInfo[s.size()];
  for (int t=0; t < cmsSequence.length; t++) {
    cmsSequence[t]=TaggedContentInfo.getInstance(s.getObjectAt(t));
  }
  s=((ASN1Sequence)seq.getObjectAt(3));
  otherMsgSequence=new OtherMsg[s.size()];
  for (int t=0; t < cmsSequence.length; t++) {
    otherMsgSequence[t]=OtherMsg.getInstance(s.getObjectAt(t));
  }
}","private PKIData(ASN1Sequence seq){
  if (seq.size() != 4) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ASN1Sequence s=((ASN1Sequence)seq.getObjectAt(0));
  controlSequence=new TaggedAttribute[s.size()];
  for (int t=0; t < controlSequence.length; t++) {
    controlSequence[t]=TaggedAttribute.getInstance(s.getObjectAt(t));
  }
  s=((ASN1Sequence)seq.getObjectAt(1));
  reqSequence=new TaggedRequest[s.size()];
  for (int t=0; t < reqSequence.length; t++) {
    reqSequence[t]=TaggedRequest.getInstance(s.getObjectAt(t));
  }
  s=((ASN1Sequence)seq.getObjectAt(2));
  cmsSequence=new TaggedContentInfo[s.size()];
  for (int t=0; t < cmsSequence.length; t++) {
    cmsSequence[t]=TaggedContentInfo.getInstance(s.getObjectAt(t));
  }
  s=((ASN1Sequence)seq.getObjectAt(3));
  otherMsgSequence=new OtherMsg[s.size()];
  for (int t=0; t < otherMsgSequence.length; t++) {
    otherMsgSequence[t]=OtherMsg.getInstance(s.getObjectAt(t));
  }
}"
52422,"@Override public Object clone(){
  Headers n=new Headers();
  for (  Entry<String,String[]> v : entrySet()) {
    n.put(v.getKey(),v.getValue());
  }
  return n;
}","@Override public Object clone(){
  Headers n=new Headers();
  for (  Map.Entry<String,String[]> v : entrySet()) {
    n.put(v.getKey(),v.getValue());
  }
  return n;
}"
52423,"public ECPoint add(ECPoint b){
  if (this.isInfinity()) {
    return b;
  }
  if (b.isInfinity()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  ECFieldElement X1=this.x;
  ECFieldElement X2=b.getRawXCoord();
  if (X1.isZero()) {
    if (X2.isZero()) {
      return curve.getInfinity();
    }
    return b.add(this);
  }
  ECFieldElement L1=this.y, Z1=this.zs[0];
  ECFieldElement L2=b.getRawYCoord(), Z2=b.getZCoord(0);
  boolean Z1IsOne=Z1.isOne();
  ECFieldElement U2=X2, S2=L2;
  if (!Z1IsOne) {
    U2=U2.multiply(Z1);
    S2=S2.multiply(Z1);
  }
  boolean Z2IsOne=Z2.isOne();
  ECFieldElement U1=X1, S1=L1;
  if (!Z2IsOne) {
    U1=U1.multiply(Z2);
    S1=S1.multiply(Z2);
  }
  ECFieldElement A=S1.add(S2);
  ECFieldElement B=U1.add(U2);
  if (B.isZero()) {
    if (A.isZero()) {
      return twice();
    }
    return curve.getInfinity();
  }
  ECFieldElement X3, L3, Z3;
  if (X2.isZero()) {
    ECPoint p=this.normalize();
    X1=p.getXCoord();
    ECFieldElement Y1=p.getYCoord();
    ECFieldElement Y2=L2;
    ECFieldElement L=Y1.add(Y2).divide(X1);
    X3=L.square().add(L).add(X1).addOne();
    if (X3.isZero()) {
      return new SecT571K1Point(curve,X3,curve.getB(),this.withCompression);
    }
    ECFieldElement Y3=L.multiply(X1.add(X3)).add(X3).add(Y1);
    L3=Y3.divide(X3).add(X3);
    Z3=curve.fromBigInteger(ECConstants.ONE);
  }
 else {
    B=B.square();
    ECFieldElement AU1=A.multiply(U1);
    ECFieldElement AU2=A.multiply(U2);
    X3=AU1.multiply(AU2);
    if (X3.isZero()) {
      return new SecT571K1Point(curve,X3,curve.getB(),this.withCompression);
    }
    ECFieldElement ABZ2=A.multiply(B);
    if (!Z2IsOne) {
      ABZ2=ABZ2.multiply(Z2);
    }
    L3=AU2.add(B).squarePlusProduct(ABZ2,L1.add(Z1));
    Z3=ABZ2;
    if (!Z1IsOne) {
      Z3=Z3.multiply(Z1);
    }
  }
  return new SecT571K1Point(curve,X3,L3,new ECFieldElement[]{Z3},this.withCompression);
}","public ECPoint add(ECPoint b){
  if (this.isInfinity()) {
    return b;
  }
  if (b.isInfinity()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  ECFieldElement X1=this.x;
  ECFieldElement X2=b.getRawXCoord();
  if (X1.isZero()) {
    if (X2.isZero()) {
      return curve.getInfinity();
    }
    return b.add(this);
  }
  ECFieldElement L1=this.y, Z1=this.zs[0];
  ECFieldElement L2=b.getRawYCoord(), Z2=b.getZCoord(0);
  boolean Z1IsOne=Z1.isOne();
  ECFieldElement U2=X2, S2=L2;
  if (!Z1IsOne) {
    U2=U2.multiply(Z1);
    S2=S2.multiply(Z1);
  }
  boolean Z2IsOne=Z2.isOne();
  ECFieldElement U1=X1, S1=L1;
  if (!Z2IsOne) {
    U1=U1.multiply(Z2);
    S1=S1.multiply(Z2);
  }
  ECFieldElement A=S1.add(S2);
  ECFieldElement B=U1.add(U2);
  if (B.isZero()) {
    if (A.isZero()) {
      return twice();
    }
    return curve.getInfinity();
  }
  ECFieldElement X3, L3, Z3;
  if (X2.isZero()) {
    ECPoint p=this.normalize();
    X1=p.getXCoord();
    ECFieldElement Y1=p.getYCoord();
    ECFieldElement Y2=L2;
    ECFieldElement L=Y1.add(Y2).divide(X1);
    X3=L.square().add(L).add(X1);
    if (X3.isZero()) {
      return new SecT571K1Point(curve,X3,curve.getB(),this.withCompression);
    }
    ECFieldElement Y3=L.multiply(X1.add(X3)).add(X3).add(Y1);
    L3=Y3.divide(X3).add(X3);
    Z3=curve.fromBigInteger(ECConstants.ONE);
  }
 else {
    B=B.square();
    ECFieldElement AU1=A.multiply(U1);
    ECFieldElement AU2=A.multiply(U2);
    X3=AU1.multiply(AU2);
    if (X3.isZero()) {
      return new SecT571K1Point(curve,X3,curve.getB(),this.withCompression);
    }
    ECFieldElement ABZ2=A.multiply(B);
    if (!Z2IsOne) {
      ABZ2=ABZ2.multiply(Z2);
    }
    L3=AU2.add(B).squarePlusProduct(ABZ2,L1.add(Z1));
    Z3=ABZ2;
    if (!Z1IsOne) {
      Z3=Z3.multiply(Z1);
    }
  }
  return new SecT571K1Point(curve,X3,L3,new ECFieldElement[]{Z3},this.withCompression);
}"
52424,"NonceEntropySource(JcaJceHelper helper,SecureRandom random) throws GeneralSecurityException {
  super(new NonceEntropySourceSpi(random,helper.createDigest(""String_Node_Str"")),null);
}","NonceEntropySource(JcaJceHelper helper,SecureRandom random) throws GeneralSecurityException {
  super(new NonceEntropySourceSpi(random,helper.createDigest(""String_Node_Str"")),random.getProvider());
}"
52425,"public static SignatureAndHashAlgorithm chooseSignatureAndHashAlgorithm(TlsContext context,Vector algs,int signatureAlgorithm) throws IOException {
  if (!TlsUtils.isTLSv12(context)) {
    return null;
  }
  if (algs == null) {
    algs=TlsUtils.getDefaultSignatureAlgorithms(signatureAlgorithm);
  }
  SignatureAndHashAlgorithm result=null;
  for (int i=0; i < algs.size(); ++i) {
    SignatureAndHashAlgorithm alg=(SignatureAndHashAlgorithm)algs.elementAt(i);
    if (alg.getSignature() == signatureAlgorithm) {
      short hash=alg.getHash();
      if (hash < MINIMUM_HASH_STRICT) {
        continue;
      }
      if (result == null) {
        result=alg;
        continue;
      }
      short current=result.getHash();
      if (hash < MINIMUM_HASH_PREFERRED) {
        if (hash > current) {
          result=alg;
        }
      }
 else {
        if (hash < current) {
          result=alg;
        }
      }
    }
  }
  if (result == null) {
    throw new TlsFatalAlert(AlertDescription.internal_error);
  }
  return result;
}","public static SignatureAndHashAlgorithm chooseSignatureAndHashAlgorithm(TlsContext context,Vector algs,int signatureAlgorithm) throws IOException {
  if (!TlsUtils.isTLSv12(context)) {
    return null;
  }
  if (algs == null) {
    algs=TlsUtils.getDefaultSignatureAlgorithms(signatureAlgorithm);
  }
  SignatureAndHashAlgorithm result=null;
  for (int i=0; i < algs.size(); ++i) {
    SignatureAndHashAlgorithm alg=(SignatureAndHashAlgorithm)algs.elementAt(i);
    if (alg.getSignature() == signatureAlgorithm) {
      short hash=alg.getHash();
      if (hash < MINIMUM_HASH_STRICT) {
        continue;
      }
      if (result == null) {
        result=alg;
        continue;
      }
      short current=result.getHash();
      if (current < MINIMUM_HASH_PREFERRED) {
        if (hash > current) {
          result=alg;
        }
      }
 else {
        if (hash < current) {
          result=alg;
        }
      }
    }
  }
  if (result == null) {
    throw new TlsFatalAlert(AlertDescription.internal_error);
  }
  return result;
}"
52426,"/** 
 * Construct a DVCS Request from a ContentInfo
 * @param contentInfo the contentInfo representing the DVCSRequest
 * @throws org.bouncycastle.dvcs.DVCSConstructionException
 */
public DVCSResponse(ContentInfo contentInfo) throws DVCSConstructionException {
  super(contentInfo);
  if (!DVCSObjectIdentifiers.id_ct_DVCSResponseData.equals(contentInfo.getContentType())) {
    throw new DVCSConstructionException(""String_Node_Str"");
  }
  try {
    if (contentInfo.getContent().toASN1Primitive() instanceof ASN1Sequence) {
      this.asn1=org.bouncycastle.asn1.dvcs.DVCSResponse.getInstance(contentInfo.getContent());
    }
 else {
      this.asn1=org.bouncycastle.asn1.dvcs.DVCSResponse.getInstance(ASN1OctetString.getInstance(contentInfo.getContent()).getOctets());
    }
  }
 catch (  Exception e) {
    throw new DVCSConstructionException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Construct a DVCS Response from a ContentInfo
 * @param contentInfo the contentInfo representing the DVCSRequest
 * @throws org.bouncycastle.dvcs.DVCSConstructionException
 */
public DVCSResponse(ContentInfo contentInfo) throws DVCSConstructionException {
  super(contentInfo);
  if (!DVCSObjectIdentifiers.id_ct_DVCSResponseData.equals(contentInfo.getContentType())) {
    throw new DVCSConstructionException(""String_Node_Str"");
  }
  try {
    if (contentInfo.getContent().toASN1Primitive() instanceof ASN1Sequence) {
      this.asn1=org.bouncycastle.asn1.dvcs.DVCSResponse.getInstance(contentInfo.getContent());
    }
 else {
      this.asn1=org.bouncycastle.asn1.dvcs.DVCSResponse.getInstance(ASN1OctetString.getInstance(contentInfo.getContent()).getOctets());
    }
  }
 catch (  Exception e) {
    throw new DVCSConstructionException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
52427,"public static void square(int[] x,int xOff,int[] zz,int zzOff){
  long x_0=x[xOff + 0] & M;
  long zz_1;
  int c=0, w;
{
    int i=3, j=8;
    do {
      long xVal=(x[xOff + i--] & M);
      long p=xVal * xVal;
      zz[zzOff + --j]=(c << 31) | (int)(p >>> 33);
      zz[zzOff + --j]=(int)(p >>> 1);
      c=(int)p;
    }
 while (i > 0);
{
      long p=x_0 * x_0;
      zz_1=((c << 31) & M) | (p >>> 33);
      zz[zzOff + 0]=(int)p;
      c=(int)(p >>> 32) & 1;
    }
  }
  long x_1=x[xOff + 1] & M;
  long zz_2=zz[zzOff + 2] & M;
{
    zz_1+=x_1 * x_0;
    w=(int)zz_1;
    zz[zzOff + 1]=(w << 1) | c;
    c=w >>> 31;
    zz_2+=zz_1 >>> 32;
  }
  long x_2=x[xOff + 2] & M;
  long zz_3=zz[zzOff + 3] & M;
  long zz_4=zz[zzOff + 4] & M;
{
    zz_2+=x_2 * x_0;
    w=(int)zz_2;
    zz[zzOff + 2]=(w << 1) | c;
    c=w >>> 31;
    zz_3+=(zz_2 >>> 32) + x_2 * x_1;
    zz_4+=zz_3 >>> 32;
    zz_3&=M;
  }
  long x_3=x[xOff + 3] & M;
  long zz_5=zz[zzOff + 5] & M;
  long zz_6=zz[zzOff + 6] & M;
{
    zz_3+=x_3 * x_0;
    w=(int)zz_3;
    zz[zzOff + 3]=(w << 1) | c;
    c=w >>> 31;
    zz_4+=(zz_3 >>> 32) + x_3 * x_1;
    zz_5+=(zz_4 >>> 32) + x_3 * x_2;
    zz_6+=zz_5 >>> 32;
  }
  w=(int)zz_4;
  zz[zzOff + 4]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_5;
  zz[zzOff + 5]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_6;
  zz[zzOff + 6]=(w << 1) | c;
  c=w >>> 31;
  w=zz[zzOff + 7] + (int)(zz_6 >> 32);
  zz[zzOff + 7]=(w << 1) | c;
}","public static void square(int[] x,int xOff,int[] zz,int zzOff){
  long x_0=x[xOff + 0] & M;
  long zz_1;
  int c=0, w;
{
    int i=3, j=8;
    do {
      long xVal=(x[xOff + i--] & M);
      long p=xVal * xVal;
      zz[zzOff + --j]=(c << 31) | (int)(p >>> 33);
      zz[zzOff + --j]=(int)(p >>> 1);
      c=(int)p;
    }
 while (i > 0);
{
      long p=x_0 * x_0;
      zz_1=((c << 31) & M) | (p >>> 33);
      zz[zzOff + 0]=(int)p;
      c=(int)(p >>> 32) & 1;
    }
  }
  long x_1=x[xOff + 1] & M;
  long zz_2=zz[zzOff + 2] & M;
{
    zz_1+=x_1 * x_0;
    w=(int)zz_1;
    zz[zzOff + 1]=(w << 1) | c;
    c=w >>> 31;
    zz_2+=zz_1 >>> 32;
  }
  long x_2=x[xOff + 2] & M;
  long zz_3=zz[zzOff + 3] & M;
  long zz_4=zz[zzOff + 4] & M;
{
    zz_2+=x_2 * x_0;
    w=(int)zz_2;
    zz[zzOff + 2]=(w << 1) | c;
    c=w >>> 31;
    zz_3+=(zz_2 >>> 32) + x_2 * x_1;
    zz_4+=zz_3 >>> 32;
    zz_3&=M;
  }
  long x_3=x[xOff + 3] & M;
  long zz_5=(zz[zzOff + 5] & M) + (zz_4 >>> 32);
  zz_4&=M;
  long zz_6=(zz[zzOff + 6] & M) + (zz_5 >>> 32);
  zz_5&=M;
{
    zz_3+=x_3 * x_0;
    w=(int)zz_3;
    zz[zzOff + 3]=(w << 1) | c;
    c=w >>> 31;
    zz_4+=(zz_3 >>> 32) + x_3 * x_1;
    zz_5+=(zz_4 >>> 32) + x_3 * x_2;
    zz_6+=zz_5 >>> 32;
  }
  w=(int)zz_4;
  zz[zzOff + 4]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_5;
  zz[zzOff + 5]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_6;
  zz[zzOff + 6]=(w << 1) | c;
  c=w >>> 31;
  w=zz[zzOff + 7] + (int)(zz_6 >>> 32);
  zz[zzOff + 7]=(w << 1) | c;
}"
52428,"public static void square(int[] x,int xOff,int[] zz,int zzOff){
  long x_0=x[xOff + 0] & M;
  long zz_1;
  int c=0, w;
{
    int i=4, j=10;
    do {
      long xVal=(x[xOff + i--] & M);
      long p=xVal * xVal;
      zz[zzOff + --j]=(c << 31) | (int)(p >>> 33);
      zz[zzOff + --j]=(int)(p >>> 1);
      c=(int)p;
    }
 while (i > 0);
{
      long p=x_0 * x_0;
      zz_1=((c << 31) & M) | (p >>> 33);
      zz[zzOff + 0]=(int)p;
      c=(int)(p >>> 32) & 1;
    }
  }
  long x_1=x[xOff + 1] & M;
  long zz_2=zz[zzOff + 2] & M;
{
    zz_1+=x_1 * x_0;
    w=(int)zz_1;
    zz[zzOff + 1]=(w << 1) | c;
    c=w >>> 31;
    zz_2+=zz_1 >>> 32;
  }
  long x_2=x[xOff + 2] & M;
  long zz_3=zz[zzOff + 3] & M;
  long zz_4=zz[zzOff + 4] & M;
{
    zz_2+=x_2 * x_0;
    w=(int)zz_2;
    zz[zzOff + 2]=(w << 1) | c;
    c=w >>> 31;
    zz_3+=(zz_2 >>> 32) + x_2 * x_1;
    zz_4+=zz_3 >>> 32;
    zz_3&=M;
  }
  long x_3=x[xOff + 3] & M;
  long zz_5=zz[zzOff + 5] & M;
  long zz_6=zz[zzOff + 6] & M;
{
    zz_3+=x_3 * x_0;
    w=(int)zz_3;
    zz[zzOff + 3]=(w << 1) | c;
    c=w >>> 31;
    zz_4+=(zz_3 >>> 32) + x_3 * x_1;
    zz_5+=(zz_4 >>> 32) + x_3 * x_2;
    zz_4&=M;
    zz_6+=zz_5 >>> 32;
    zz_5&=M;
  }
  long x_4=x[xOff + 4] & M;
  long zz_7=zz[zzOff + 7] & M;
  long zz_8=zz[zzOff + 8] & M;
{
    zz_4+=x_4 * x_0;
    w=(int)zz_4;
    zz[zzOff + 4]=(w << 1) | c;
    c=w >>> 31;
    zz_5+=(zz_4 >>> 32) + x_4 * x_1;
    zz_6+=(zz_5 >>> 32) + x_4 * x_2;
    zz_7+=(zz_6 >>> 32) + x_4 * x_3;
    zz_8+=zz_7 >>> 32;
  }
  w=(int)zz_5;
  zz[zzOff + 5]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_6;
  zz[zzOff + 6]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_7;
  zz[zzOff + 7]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_8;
  zz[zzOff + 8]=(w << 1) | c;
  c=w >>> 31;
  w=zz[zzOff + 9] + (int)(zz_8 >> 32);
  zz[zzOff + 9]=(w << 1) | c;
}","public static void square(int[] x,int xOff,int[] zz,int zzOff){
  long x_0=x[xOff + 0] & M;
  long zz_1;
  int c=0, w;
{
    int i=4, j=10;
    do {
      long xVal=(x[xOff + i--] & M);
      long p=xVal * xVal;
      zz[zzOff + --j]=(c << 31) | (int)(p >>> 33);
      zz[zzOff + --j]=(int)(p >>> 1);
      c=(int)p;
    }
 while (i > 0);
{
      long p=x_0 * x_0;
      zz_1=((c << 31) & M) | (p >>> 33);
      zz[zzOff + 0]=(int)p;
      c=(int)(p >>> 32) & 1;
    }
  }
  long x_1=x[xOff + 1] & M;
  long zz_2=zz[zzOff + 2] & M;
{
    zz_1+=x_1 * x_0;
    w=(int)zz_1;
    zz[zzOff + 1]=(w << 1) | c;
    c=w >>> 31;
    zz_2+=zz_1 >>> 32;
  }
  long x_2=x[xOff + 2] & M;
  long zz_3=zz[zzOff + 3] & M;
  long zz_4=zz[zzOff + 4] & M;
{
    zz_2+=x_2 * x_0;
    w=(int)zz_2;
    zz[zzOff + 2]=(w << 1) | c;
    c=w >>> 31;
    zz_3+=(zz_2 >>> 32) + x_2 * x_1;
    zz_4+=zz_3 >>> 32;
    zz_3&=M;
  }
  long x_3=x[xOff + 3] & M;
  long zz_5=(zz[zzOff + 5] & M) + (zz_4 >>> 32);
  zz_4&=M;
  long zz_6=(zz[zzOff + 6] & M) + (zz_5 >>> 32);
  zz_5&=M;
{
    zz_3+=x_3 * x_0;
    w=(int)zz_3;
    zz[zzOff + 3]=(w << 1) | c;
    c=w >>> 31;
    zz_4+=(zz_3 >>> 32) + x_3 * x_1;
    zz_5+=(zz_4 >>> 32) + x_3 * x_2;
    zz_4&=M;
    zz_6+=zz_5 >>> 32;
    zz_5&=M;
  }
  long x_4=x[xOff + 4] & M;
  long zz_7=(zz[zzOff + 7] & M) + (zz_6 >>> 32);
  zz_6&=M;
  long zz_8=(zz[zzOff + 8] & M) + (zz_7 >>> 32);
  zz_7&=M;
{
    zz_4+=x_4 * x_0;
    w=(int)zz_4;
    zz[zzOff + 4]=(w << 1) | c;
    c=w >>> 31;
    zz_5+=(zz_4 >>> 32) + x_4 * x_1;
    zz_6+=(zz_5 >>> 32) + x_4 * x_2;
    zz_7+=(zz_6 >>> 32) + x_4 * x_3;
    zz_8+=zz_7 >>> 32;
  }
  w=(int)zz_5;
  zz[zzOff + 5]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_6;
  zz[zzOff + 6]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_7;
  zz[zzOff + 7]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_8;
  zz[zzOff + 8]=(w << 1) | c;
  c=w >>> 31;
  w=zz[zzOff + 9] + (int)(zz_8 >>> 32);
  zz[zzOff + 9]=(w << 1) | c;
}"
52429,"public static void square(int[] x,int xOff,int[] zz,int zzOff){
  long x_0=x[xOff + 0] & M;
  long zz_1;
  int c=0, w;
{
    int i=5, j=12;
    do {
      long xVal=(x[xOff + i--] & M);
      long p=xVal * xVal;
      zz[zzOff + --j]=(c << 31) | (int)(p >>> 33);
      zz[zzOff + --j]=(int)(p >>> 1);
      c=(int)p;
    }
 while (i > 0);
{
      long p=x_0 * x_0;
      zz_1=((c << 31) & M) | (p >>> 33);
      zz[zzOff + 0]=(int)p;
      c=(int)(p >>> 32) & 1;
    }
  }
  long x_1=x[xOff + 1] & M;
  long zz_2=zz[zzOff + 2] & M;
{
    zz_1+=x_1 * x_0;
    w=(int)zz_1;
    zz[zzOff + 1]=(w << 1) | c;
    c=w >>> 31;
    zz_2+=zz_1 >>> 32;
  }
  long x_2=x[xOff + 2] & M;
  long zz_3=zz[zzOff + 3] & M;
  long zz_4=zz[zzOff + 4] & M;
{
    zz_2+=x_2 * x_0;
    w=(int)zz_2;
    zz[zzOff + 2]=(w << 1) | c;
    c=w >>> 31;
    zz_3+=(zz_2 >>> 32) + x_2 * x_1;
    zz_4+=zz_3 >>> 32;
    zz_3&=M;
  }
  long x_3=x[xOff + 3] & M;
  long zz_5=zz[zzOff + 5] & M;
  long zz_6=zz[zzOff + 6] & M;
{
    zz_3+=x_3 * x_0;
    w=(int)zz_3;
    zz[zzOff + 3]=(w << 1) | c;
    c=w >>> 31;
    zz_4+=(zz_3 >>> 32) + x_3 * x_1;
    zz_5+=(zz_4 >>> 32) + x_3 * x_2;
    zz_4&=M;
    zz_6+=zz_5 >>> 32;
    zz_5&=M;
  }
  long x_4=x[xOff + 4] & M;
  long zz_7=zz[zzOff + 7] & M;
  long zz_8=zz[zzOff + 8] & M;
{
    zz_4+=x_4 * x_0;
    w=(int)zz_4;
    zz[zzOff + 4]=(w << 1) | c;
    c=w >>> 31;
    zz_5+=(zz_4 >>> 32) + x_4 * x_1;
    zz_6+=(zz_5 >>> 32) + x_4 * x_2;
    zz_5&=M;
    zz_7+=(zz_6 >>> 32) + x_4 * x_3;
    zz_6&=M;
    zz_8+=zz_7 >>> 32;
    zz_7&=M;
  }
  long x_5=x[xOff + 5] & M;
  long zz_9=zz[zzOff + 9] & M;
  long zz_10=zz[zzOff + 10] & M;
{
    zz_5+=x_5 * x_0;
    w=(int)zz_5;
    zz[zzOff + 5]=(w << 1) | c;
    c=w >>> 31;
    zz_6+=(zz_5 >>> 32) + x_5 * x_1;
    zz_7+=(zz_6 >>> 32) + x_5 * x_2;
    zz_8+=(zz_7 >>> 32) + x_5 * x_3;
    zz_9+=(zz_8 >>> 32) + x_5 * x_4;
    zz_10+=zz_9 >>> 32;
  }
  w=(int)zz_6;
  zz[zzOff + 6]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_7;
  zz[zzOff + 7]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_8;
  zz[zzOff + 8]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_9;
  zz[zzOff + 9]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_10;
  zz[zzOff + 10]=(w << 1) | c;
  c=w >>> 31;
  w=zz[zzOff + 11] + (int)(zz_10 >> 32);
  zz[zzOff + 11]=(w << 1) | c;
}","public static void square(int[] x,int xOff,int[] zz,int zzOff){
  long x_0=x[xOff + 0] & M;
  long zz_1;
  int c=0, w;
{
    int i=5, j=12;
    do {
      long xVal=(x[xOff + i--] & M);
      long p=xVal * xVal;
      zz[zzOff + --j]=(c << 31) | (int)(p >>> 33);
      zz[zzOff + --j]=(int)(p >>> 1);
      c=(int)p;
    }
 while (i > 0);
{
      long p=x_0 * x_0;
      zz_1=((c << 31) & M) | (p >>> 33);
      zz[zzOff + 0]=(int)p;
      c=(int)(p >>> 32) & 1;
    }
  }
  long x_1=x[xOff + 1] & M;
  long zz_2=zz[zzOff + 2] & M;
{
    zz_1+=x_1 * x_0;
    w=(int)zz_1;
    zz[zzOff + 1]=(w << 1) | c;
    c=w >>> 31;
    zz_2+=zz_1 >>> 32;
  }
  long x_2=x[xOff + 2] & M;
  long zz_3=zz[zzOff + 3] & M;
  long zz_4=zz[zzOff + 4] & M;
{
    zz_2+=x_2 * x_0;
    w=(int)zz_2;
    zz[zzOff + 2]=(w << 1) | c;
    c=w >>> 31;
    zz_3+=(zz_2 >>> 32) + x_2 * x_1;
    zz_4+=zz_3 >>> 32;
    zz_3&=M;
  }
  long x_3=x[xOff + 3] & M;
  long zz_5=(zz[zzOff + 5] & M) + (zz_4 >>> 32);
  zz_4&=M;
  long zz_6=(zz[zzOff + 6] & M) + (zz_5 >>> 32);
  zz_5&=M;
{
    zz_3+=x_3 * x_0;
    w=(int)zz_3;
    zz[zzOff + 3]=(w << 1) | c;
    c=w >>> 31;
    zz_4+=(zz_3 >>> 32) + x_3 * x_1;
    zz_5+=(zz_4 >>> 32) + x_3 * x_2;
    zz_4&=M;
    zz_6+=zz_5 >>> 32;
    zz_5&=M;
  }
  long x_4=x[xOff + 4] & M;
  long zz_7=(zz[zzOff + 7] & M) + (zz_6 >>> 32);
  zz_6&=M;
  long zz_8=(zz[zzOff + 8] & M) + (zz_7 >>> 32);
  zz_7&=M;
{
    zz_4+=x_4 * x_0;
    w=(int)zz_4;
    zz[zzOff + 4]=(w << 1) | c;
    c=w >>> 31;
    zz_5+=(zz_4 >>> 32) + x_4 * x_1;
    zz_6+=(zz_5 >>> 32) + x_4 * x_2;
    zz_5&=M;
    zz_7+=(zz_6 >>> 32) + x_4 * x_3;
    zz_6&=M;
    zz_8+=zz_7 >>> 32;
    zz_7&=M;
  }
  long x_5=x[xOff + 5] & M;
  long zz_9=(zz[zzOff + 9] & M) + (zz_8 >>> 32);
  zz_8&=M;
  long zz_10=(zz[zzOff + 10] & M) + (zz_9 >>> 32);
  zz_9&=M;
{
    zz_5+=x_5 * x_0;
    w=(int)zz_5;
    zz[zzOff + 5]=(w << 1) | c;
    c=w >>> 31;
    zz_6+=(zz_5 >>> 32) + x_5 * x_1;
    zz_7+=(zz_6 >>> 32) + x_5 * x_2;
    zz_8+=(zz_7 >>> 32) + x_5 * x_3;
    zz_9+=(zz_8 >>> 32) + x_5 * x_4;
    zz_10+=zz_9 >>> 32;
  }
  w=(int)zz_6;
  zz[zzOff + 6]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_7;
  zz[zzOff + 7]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_8;
  zz[zzOff + 8]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_9;
  zz[zzOff + 9]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_10;
  zz[zzOff + 10]=(w << 1) | c;
  c=w >>> 31;
  w=zz[zzOff + 11] + (int)(zz_10 >>> 32);
  zz[zzOff + 11]=(w << 1) | c;
}"
52430,"public static void square(int[] x,int xOff,int[] zz,int zzOff){
  long x_0=x[xOff + 0] & M;
  long zz_1;
  int c=0, w;
{
    int i=6, j=14;
    do {
      long xVal=(x[xOff + i--] & M);
      long p=xVal * xVal;
      zz[zzOff + --j]=(c << 31) | (int)(p >>> 33);
      zz[zzOff + --j]=(int)(p >>> 1);
      c=(int)p;
    }
 while (i > 0);
{
      long p=x_0 * x_0;
      zz_1=((c << 31) & M) | (p >>> 33);
      zz[zzOff + 0]=(int)p;
      c=(int)(p >>> 32) & 1;
    }
  }
  long x_1=x[xOff + 1] & M;
  long zz_2=zz[zzOff + 2] & M;
{
    zz_1+=x_1 * x_0;
    w=(int)zz_1;
    zz[zzOff + 1]=(w << 1) | c;
    c=w >>> 31;
    zz_2+=zz_1 >>> 32;
  }
  long x_2=x[xOff + 2] & M;
  long zz_3=zz[zzOff + 3] & M;
  long zz_4=zz[zzOff + 4] & M;
{
    zz_2+=x_2 * x_0;
    w=(int)zz_2;
    zz[zzOff + 2]=(w << 1) | c;
    c=w >>> 31;
    zz_3+=(zz_2 >>> 32) + x_2 * x_1;
    zz_4+=zz_3 >>> 32;
    zz_3&=M;
  }
  long x_3=x[xOff + 3] & M;
  long zz_5=zz[zzOff + 5] & M;
  long zz_6=zz[zzOff + 6] & M;
{
    zz_3+=x_3 * x_0;
    w=(int)zz_3;
    zz[zzOff + 3]=(w << 1) | c;
    c=w >>> 31;
    zz_4+=(zz_3 >>> 32) + x_3 * x_1;
    zz_5+=(zz_4 >>> 32) + x_3 * x_2;
    zz_4&=M;
    zz_6+=zz_5 >>> 32;
    zz_5&=M;
  }
  long x_4=x[xOff + 4] & M;
  long zz_7=zz[zzOff + 7] & M;
  long zz_8=zz[zzOff + 8] & M;
{
    zz_4+=x_4 * x_0;
    w=(int)zz_4;
    zz[zzOff + 4]=(w << 1) | c;
    c=w >>> 31;
    zz_5+=(zz_4 >>> 32) + x_4 * x_1;
    zz_6+=(zz_5 >>> 32) + x_4 * x_2;
    zz_5&=M;
    zz_7+=(zz_6 >>> 32) + x_4 * x_3;
    zz_6&=M;
    zz_8+=zz_7 >>> 32;
    zz_7&=M;
  }
  long x_5=x[xOff + 5] & M;
  long zz_9=zz[zzOff + 9] & M;
  long zz_10=zz[zzOff + 10] & M;
{
    zz_5+=x_5 * x_0;
    w=(int)zz_5;
    zz[zzOff + 5]=(w << 1) | c;
    c=w >>> 31;
    zz_6+=(zz_5 >>> 32) + x_5 * x_1;
    zz_7+=(zz_6 >>> 32) + x_5 * x_2;
    zz_6&=M;
    zz_8+=(zz_7 >>> 32) + x_5 * x_3;
    zz_7&=M;
    zz_9+=(zz_8 >>> 32) + x_5 * x_4;
    zz_8&=M;
    zz_10+=zz_9 >>> 32;
    zz_9&=M;
  }
  long x_6=x[xOff + 6] & M;
  long zz_11=zz[zzOff + 11] & M;
  long zz_12=zz[zzOff + 12] & M;
{
    zz_6+=x_6 * x_0;
    w=(int)zz_6;
    zz[zzOff + 6]=(w << 1) | c;
    c=w >>> 31;
    zz_7+=(zz_6 >>> 32) + x_6 * x_1;
    zz_8+=(zz_7 >>> 32) + x_6 * x_2;
    zz_9+=(zz_8 >>> 32) + x_6 * x_3;
    zz_10+=(zz_9 >>> 32) + x_6 * x_4;
    zz_11+=(zz_10 >>> 32) + x_6 * x_5;
    zz_12+=zz_11 >>> 32;
  }
  w=(int)zz_7;
  zz[zzOff + 7]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_8;
  zz[zzOff + 8]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_9;
  zz[zzOff + 9]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_10;
  zz[zzOff + 10]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_11;
  zz[zzOff + 11]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_12;
  zz[zzOff + 12]=(w << 1) | c;
  c=w >>> 31;
  w=zz[zzOff + 13] + (int)(zz_12 >> 32);
  zz[zzOff + 13]=(w << 1) | c;
}","public static void square(int[] x,int xOff,int[] zz,int zzOff){
  long x_0=x[xOff + 0] & M;
  long zz_1;
  int c=0, w;
{
    int i=6, j=14;
    do {
      long xVal=(x[xOff + i--] & M);
      long p=xVal * xVal;
      zz[zzOff + --j]=(c << 31) | (int)(p >>> 33);
      zz[zzOff + --j]=(int)(p >>> 1);
      c=(int)p;
    }
 while (i > 0);
{
      long p=x_0 * x_0;
      zz_1=((c << 31) & M) | (p >>> 33);
      zz[zzOff + 0]=(int)p;
      c=(int)(p >>> 32) & 1;
    }
  }
  long x_1=x[xOff + 1] & M;
  long zz_2=zz[zzOff + 2] & M;
{
    zz_1+=x_1 * x_0;
    w=(int)zz_1;
    zz[zzOff + 1]=(w << 1) | c;
    c=w >>> 31;
    zz_2+=zz_1 >>> 32;
  }
  long x_2=x[xOff + 2] & M;
  long zz_3=zz[zzOff + 3] & M;
  long zz_4=zz[zzOff + 4] & M;
{
    zz_2+=x_2 * x_0;
    w=(int)zz_2;
    zz[zzOff + 2]=(w << 1) | c;
    c=w >>> 31;
    zz_3+=(zz_2 >>> 32) + x_2 * x_1;
    zz_4+=zz_3 >>> 32;
    zz_3&=M;
  }
  long x_3=x[xOff + 3] & M;
  long zz_5=(zz[zzOff + 5] & M) + (zz_4 >>> 32);
  zz_4&=M;
  long zz_6=(zz[zzOff + 6] & M) + (zz_5 >>> 32);
  zz_5&=M;
{
    zz_3+=x_3 * x_0;
    w=(int)zz_3;
    zz[zzOff + 3]=(w << 1) | c;
    c=w >>> 31;
    zz_4+=(zz_3 >>> 32) + x_3 * x_1;
    zz_5+=(zz_4 >>> 32) + x_3 * x_2;
    zz_4&=M;
    zz_6+=zz_5 >>> 32;
    zz_5&=M;
  }
  long x_4=x[xOff + 4] & M;
  long zz_7=(zz[zzOff + 7] & M) + (zz_6 >>> 32);
  zz_6&=M;
  long zz_8=(zz[zzOff + 8] & M) + (zz_7 >>> 32);
  zz_7&=M;
{
    zz_4+=x_4 * x_0;
    w=(int)zz_4;
    zz[zzOff + 4]=(w << 1) | c;
    c=w >>> 31;
    zz_5+=(zz_4 >>> 32) + x_4 * x_1;
    zz_6+=(zz_5 >>> 32) + x_4 * x_2;
    zz_5&=M;
    zz_7+=(zz_6 >>> 32) + x_4 * x_3;
    zz_6&=M;
    zz_8+=zz_7 >>> 32;
    zz_7&=M;
  }
  long x_5=x[xOff + 5] & M;
  long zz_9=(zz[zzOff + 9] & M) + (zz_8 >>> 32);
  zz_8&=M;
  long zz_10=(zz[zzOff + 10] & M) + (zz_9 >>> 32);
  zz_9&=M;
{
    zz_5+=x_5 * x_0;
    w=(int)zz_5;
    zz[zzOff + 5]=(w << 1) | c;
    c=w >>> 31;
    zz_6+=(zz_5 >>> 32) + x_5 * x_1;
    zz_7+=(zz_6 >>> 32) + x_5 * x_2;
    zz_6&=M;
    zz_8+=(zz_7 >>> 32) + x_5 * x_3;
    zz_7&=M;
    zz_9+=(zz_8 >>> 32) + x_5 * x_4;
    zz_8&=M;
    zz_10+=zz_9 >>> 32;
    zz_9&=M;
  }
  long x_6=x[xOff + 6] & M;
  long zz_11=(zz[zzOff + 11] & M) + (zz_10 >>> 32);
  zz_10&=M;
  long zz_12=(zz[zzOff + 12] & M) + (zz_11 >>> 32);
  zz_11&=M;
{
    zz_6+=x_6 * x_0;
    w=(int)zz_6;
    zz[zzOff + 6]=(w << 1) | c;
    c=w >>> 31;
    zz_7+=(zz_6 >>> 32) + x_6 * x_1;
    zz_8+=(zz_7 >>> 32) + x_6 * x_2;
    zz_9+=(zz_8 >>> 32) + x_6 * x_3;
    zz_10+=(zz_9 >>> 32) + x_6 * x_4;
    zz_11+=(zz_10 >>> 32) + x_6 * x_5;
    zz_12+=zz_11 >>> 32;
  }
  w=(int)zz_7;
  zz[zzOff + 7]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_8;
  zz[zzOff + 8]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_9;
  zz[zzOff + 9]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_10;
  zz[zzOff + 10]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_11;
  zz[zzOff + 11]=(w << 1) | c;
  c=w >>> 31;
  w=(int)zz_12;
  zz[zzOff + 12]=(w << 1) | c;
  c=w >>> 31;
  w=zz[zzOff + 13] + (int)(zz_12 >>> 32);
  zz[zzOff + 13]=(w << 1) | c;
}"
52431,"/** 
 * Remove a certification from the key.
 * @param key the key the certifications are to be removed from.
 * @param certification the certification to be removed.
 * @return the modified key, null if the certification was not found.
 */
public static PGPPublicKey removeCertification(PGPPublicKey key,PGPSignature certification){
  PGPPublicKey returnKey=new PGPPublicKey(key);
  boolean found;
  if (returnKey.subSigs != null) {
    found=returnKey.subSigs.remove(certification);
  }
 else {
    found=returnKey.keySigs.remove(certification);
  }
  if (!found) {
    for (Iterator it=key.getUserIDs(); it.hasNext(); ) {
      String id=(String)it.next();
      for (Iterator sIt=key.getSignaturesForID(id); sIt.hasNext(); ) {
        if (certification == sIt.next()) {
          found=true;
          returnKey=PGPPublicKey.removeCertification(returnKey,id,certification);
        }
      }
    }
    if (!found) {
      for (Iterator it=key.getUserAttributes(); it.hasNext(); ) {
        PGPUserAttributeSubpacketVector id=(PGPUserAttributeSubpacketVector)it.next();
        for (Iterator sIt=key.getSignaturesForUserAttribute(id); sIt.hasNext(); ) {
          if (certification == sIt.next()) {
            found=true;
            returnKey=PGPPublicKey.removeCertification(returnKey,id,certification);
          }
        }
      }
    }
  }
  return returnKey;
}","/** 
 * Remove a certification from the key.
 * @param key the key the certifications are to be removed from.
 * @param certification the certification to be removed.
 * @return the modified key, null if the certification was not found.
 */
public static PGPPublicKey removeCertification(PGPPublicKey key,PGPSignature certification){
  PGPPublicKey returnKey=new PGPPublicKey(key);
  boolean found;
  if (returnKey.subSigs != null) {
    found=returnKey.subSigs.remove(certification);
  }
 else {
    found=returnKey.keySigs.remove(certification);
  }
  if (!found) {
    for (Iterator it=key.getRawUserIDs(); it.hasNext(); ) {
      UserIDPacket id=(UserIDPacket)it.next();
      for (Iterator sIt=key.getSignaturesForID(id); sIt.hasNext(); ) {
        if (certification == sIt.next()) {
          found=true;
          returnKey=PGPPublicKey.removeCertification(returnKey,id,certification);
        }
      }
    }
    if (!found) {
      for (Iterator it=key.getUserAttributes(); it.hasNext(); ) {
        PGPUserAttributeSubpacketVector id=(PGPUserAttributeSubpacketVector)it.next();
        for (Iterator sIt=key.getSignaturesForUserAttribute(id); sIt.hasNext(); ) {
          if (certification == sIt.next()) {
            found=true;
            returnKey=PGPPublicKey.removeCertification(returnKey,id,certification);
          }
        }
      }
    }
  }
  return returnKey;
}"
52432,"/** 
 * Remove a certification from the key.
 * @param key the key the certifications are to be removed from.
 * @param certification the certification to be removed.
 * @return the modified key, null if the certification was not found.
 */
public static PGPPublicKey removeCertification(PGPPublicKey key,PGPSignature certification){
  PGPPublicKey returnKey=new PGPPublicKey(key);
  boolean found;
  if (returnKey.subSigs != null) {
    found=returnKey.subSigs.remove(certification);
  }
 else {
    found=returnKey.keySigs.remove(certification);
  }
  if (!found) {
    for (Iterator it=key.getUserIDs(); it.hasNext(); ) {
      UserIDPacket id=(UserIDPacket)it.next();
      for (Iterator sIt=key.getSignaturesForID(id); sIt.hasNext(); ) {
        if (certification == sIt.next()) {
          found=true;
          returnKey=PGPPublicKey.removeCertification(returnKey,id.getRawID(),certification);
        }
      }
    }
    if (!found) {
      for (Iterator it=key.getUserAttributes(); it.hasNext(); ) {
        PGPUserAttributeSubpacketVector id=(PGPUserAttributeSubpacketVector)it.next();
        for (Iterator sIt=key.getSignaturesForUserAttribute(id); sIt.hasNext(); ) {
          if (certification == sIt.next()) {
            found=true;
            returnKey=PGPPublicKey.removeCertification(returnKey,id,certification);
          }
        }
      }
    }
  }
  return returnKey;
}","/** 
 * Remove a certification from the key.
 * @param key the key the certifications are to be removed from.
 * @param certification the certification to be removed.
 * @return the modified key, null if the certification was not found.
 */
public static PGPPublicKey removeCertification(PGPPublicKey key,PGPSignature certification){
  PGPPublicKey returnKey=new PGPPublicKey(key);
  boolean found;
  if (returnKey.subSigs != null) {
    found=returnKey.subSigs.remove(certification);
  }
 else {
    found=returnKey.keySigs.remove(certification);
  }
  if (!found) {
    for (Iterator it=key.getRawUserIDs(); it.hasNext(); ) {
      UserIDPacket id=(UserIDPacket)it.next();
      for (Iterator sIt=key.getSignaturesForID(id); sIt.hasNext(); ) {
        if (certification == sIt.next()) {
          found=true;
          returnKey=PGPPublicKey.removeCertification(returnKey,id.getRawID(),certification);
        }
      }
    }
    if (!found) {
      for (Iterator it=key.getUserAttributes(); it.hasNext(); ) {
        PGPUserAttributeSubpacketVector id=(PGPUserAttributeSubpacketVector)it.next();
        for (Iterator sIt=key.getSignaturesForUserAttribute(id); sIt.hasNext(); ) {
          if (certification == sIt.next()) {
            found=true;
            returnKey=PGPPublicKey.removeCertification(returnKey,id,certification);
          }
        }
      }
    }
  }
  return returnKey;
}"
52433,"public void testRSAServer() throws Exception {
  KeyStore ks=getRsaKeyStore(false);
  KeyStore trustStore=KeyStore.getInstance(""String_Node_Str"");
  trustStore.load(null,PASSWORD);
  trustStore.setCertificateEntry(""String_Node_Str"",ks.getCertificate(""String_Node_Str""));
  SSLUtils.startServer(ks,PASSWORD,trustStore);
  TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(""String_Node_Str"",BouncyCastleJsseProvider.PROVIDER_NAME);
  trustManagerFactory.init(trustStore);
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,trustManagerFactory.getTrustManagers(),null);
  SSLSocketFactory f=context.getSocketFactory();
  SSLSocket c=(SSLSocket)f.createSocket(""String_Node_Str"",8888);
  c.setUseClientMode(true);
  c.startHandshake();
  c.getOutputStream().write('!');
  c.getInputStream().read();
}","public void testRSAServer() throws Exception {
  KeyStore ks=getRsaKeyStore(false);
  KeyStore trustStore=KeyStore.getInstance(""String_Node_Str"");
  trustStore.load(null,PASSWORD);
  trustStore.setCertificateEntry(""String_Node_Str"",ks.getCertificate(""String_Node_Str""));
  SSLUtils.startServer(ks,PASSWORD,trustStore,false,8886);
  TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(""String_Node_Str"",BouncyCastleJsseProvider.PROVIDER_NAME);
  trustManagerFactory.init(trustStore);
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,trustManagerFactory.getTrustManagers(),null);
  SSLSocketFactory f=context.getSocketFactory();
  SSLSocket c=(SSLSocket)f.createSocket(""String_Node_Str"",8886);
  c.setUseClientMode(true);
  c.startHandshake();
  c.getOutputStream().write('!');
  c.getInputStream().read();
}"
52434,"public void testRSAServerWithClientAuth() throws Exception {
  KeyStore ks=getRsaKeyStore(false);
  KeyStore trustStore=KeyStore.getInstance(""String_Node_Str"");
  trustStore.load(null,PASSWORD);
  trustStore.setCertificateEntry(""String_Node_Str"",ks.getCertificate(""String_Node_Str""));
  SSLUtils.startServer(ks,PASSWORD,trustStore,true);
  KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(""String_Node_Str"",BouncyCastleJsseProvider.PROVIDER_NAME);
  keyManagerFactory.init(ks,PASSWORD);
  TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(""String_Node_Str"",BouncyCastleJsseProvider.PROVIDER_NAME);
  trustManagerFactory.init(trustStore);
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(keyManagerFactory.getKeyManagers(),trustManagerFactory.getTrustManagers(),null);
  SSLSocketFactory f=context.getSocketFactory();
  SSLSocket c=(SSLSocket)f.createSocket(""String_Node_Str"",8888);
  c.setUseClientMode(true);
  SSLUtils.restrictKeyExchange(c,""String_Node_Str"");
  c.startHandshake();
  c.getOutputStream().write('!');
  c.getInputStream().read();
}","public void testRSAServerWithClientAuth() throws Exception {
  KeyStore ks=getRsaKeyStore(false);
  KeyStore trustStore=KeyStore.getInstance(""String_Node_Str"");
  trustStore.load(null,PASSWORD);
  trustStore.setCertificateEntry(""String_Node_Str"",ks.getCertificate(""String_Node_Str""));
  SSLUtils.startServer(ks,PASSWORD,trustStore,true,8887);
  KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(""String_Node_Str"",BouncyCastleJsseProvider.PROVIDER_NAME);
  keyManagerFactory.init(ks,PASSWORD);
  TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(""String_Node_Str"",BouncyCastleJsseProvider.PROVIDER_NAME);
  trustManagerFactory.init(trustStore);
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(keyManagerFactory.getKeyManagers(),trustManagerFactory.getTrustManagers(),null);
  SSLSocketFactory f=context.getSocketFactory();
  SSLSocket c=(SSLSocket)f.createSocket(""String_Node_Str"",8887);
  c.setUseClientMode(true);
  SSLUtils.restrictKeyExchange(c,""String_Node_Str"");
  c.startHandshake();
  c.getOutputStream().write('!');
  c.getInputStream().read();
}"
52435,"static void startServer(final KeyStore keyStore,final char[] password,final KeyStore serverStore,final boolean needClientAuth){
  Runnable serverTask=new Runnable(){
    public void run(){
      try {
        KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(""String_Node_Str"");
        keyManagerFactory.init(keyStore,password);
        TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(""String_Node_Str"");
        trustManagerFactory.init(serverStore);
        SSLContext context=SSLContext.getInstance(""String_Node_Str"");
        context.init(keyManagerFactory.getKeyManagers(),trustManagerFactory.getTrustManagers(),null);
        SSLServerSocketFactory sslSocketFactory=context.getServerSocketFactory();
        SSLServerSocket ss=(SSLServerSocket)sslSocketFactory.createServerSocket(8888);
        ss.setNeedClientAuth(needClientAuth);
        SSLSocket s=(SSLSocket)ss.accept();
        s.setUseClientMode(false);
        s.startHandshake();
        s.getInputStream().read();
        s.getOutputStream().write('!');
        s.close();
        ss.close();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
;
  new Thread(serverTask).start();
}","static void startServer(final KeyStore keyStore,final char[] password,final KeyStore serverStore,final boolean needClientAuth,final int port){
  final CountDownLatch latch=new CountDownLatch(1);
  Runnable serverTask=new Runnable(){
    public void run(){
      try {
        KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(""String_Node_Str"");
        keyManagerFactory.init(keyStore,password);
        TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(""String_Node_Str"");
        trustManagerFactory.init(serverStore);
        SSLContext context=SSLContext.getInstance(""String_Node_Str"");
        context.init(keyManagerFactory.getKeyManagers(),trustManagerFactory.getTrustManagers(),null);
        SSLServerSocketFactory sslSocketFactory=context.getServerSocketFactory();
        SSLServerSocket ss=(SSLServerSocket)sslSocketFactory.createServerSocket(port);
        ss.setNeedClientAuth(needClientAuth);
        latch.countDown();
        SSLSocket s=(SSLSocket)ss.accept();
        s.setUseClientMode(false);
        s.startHandshake();
        s.getInputStream().read();
        s.getOutputStream().write('!');
        s.close();
        ss.close();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
;
  new Thread(serverTask).start();
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
  }
}"
52436,"public void run(){
  try {
    KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(""String_Node_Str"");
    keyManagerFactory.init(keyStore,password);
    TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(""String_Node_Str"");
    trustManagerFactory.init(serverStore);
    SSLContext context=SSLContext.getInstance(""String_Node_Str"");
    context.init(keyManagerFactory.getKeyManagers(),trustManagerFactory.getTrustManagers(),null);
    SSLServerSocketFactory sslSocketFactory=context.getServerSocketFactory();
    SSLServerSocket ss=(SSLServerSocket)sslSocketFactory.createServerSocket(8888);
    ss.setNeedClientAuth(needClientAuth);
    SSLSocket s=(SSLSocket)ss.accept();
    s.setUseClientMode(false);
    s.startHandshake();
    s.getInputStream().read();
    s.getOutputStream().write('!');
    s.close();
    ss.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(){
  try {
    KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(""String_Node_Str"");
    keyManagerFactory.init(keyStore,password);
    TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(""String_Node_Str"");
    trustManagerFactory.init(serverStore);
    SSLContext context=SSLContext.getInstance(""String_Node_Str"");
    context.init(keyManagerFactory.getKeyManagers(),trustManagerFactory.getTrustManagers(),null);
    SSLServerSocketFactory sslSocketFactory=context.getServerSocketFactory();
    SSLServerSocket ss=(SSLServerSocket)sslSocketFactory.createServerSocket(port);
    ss.setNeedClientAuth(needClientAuth);
    latch.countDown();
    SSLSocket s=(SSLSocket)ss.accept();
    s.setUseClientMode(false);
    s.startHandshake();
    s.getInputStream().read();
    s.getOutputStream().write('!');
    s.close();
    ss.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
52437,"/** 
 * Validates the signed   {@link MimeMessage} message. The{@link PKIXParameters} from param are used for the certificate pathvalidation. The actual PKIXParameters used for the certificate path validation is a copy of param with the followin changes: <br> - The validation date is changed to the signature time <br> - A CertStore with certificates and crls from the mail message is added to the CertStores.<br> <br> In <code>param</code> it's also possible to add additional CertStores with intermediate Certificates and/or CRLs which then are also used for the validation.
 * @param message               the signed MimeMessage
 * @param param                 the parameters for the certificate path validation
 * @param certPathReviewerClass a subclass of {@link PKIXCertPathReviewer}. The SignedMailValidator uses objects of this type for the cert path vailidation. The class must have an empty constructor.
 * @throws SignedMailValidatorException if the message is no signed message or if an exception occursreading the message
 * @throws IllegalArgumentException if the certPathReviewerClass is not asubclass of  {@link PKIXCertPathReviewer} or objects ofcertPathReviewerClass can not be instantiated
 */
public SignedMailValidator(MimeMessage message,PKIXParameters param,Class certPathReviewerClass) throws SignedMailValidatorException {
  this.certPathReviewerClass=certPathReviewerClass;
  boolean isSubclass=DEFAULT_CERT_PATH_REVIEWER.isAssignableFrom(certPathReviewerClass);
  if (!isSubclass) {
    throw new IllegalArgumentException(""String_Node_Str"" + DEFAULT_CERT_PATH_REVIEWER.getName());
  }
  SMIMESigned s;
  try {
    if (message.isMimeType(""String_Node_Str"")) {
      MimeMultipart mimemp=(MimeMultipart)message.getContent();
      s=new SMIMESigned(mimemp);
    }
 else     if (message.isMimeType(""String_Node_Str"") || message.isMimeType(""String_Node_Str"")) {
      s=new SMIMESigned(message);
    }
 else {
      ErrorBundle msg=new ErrorBundle(RESOURCE_NAME,""String_Node_Str"");
      throw new SignedMailValidatorException(msg);
    }
    certs=new JcaCertStoreBuilder().addCertificates(s.getCertificates()).addCRLs(s.getCRLs()).setProvider(""String_Node_Str"").build();
    signers=s.getSignerInfos();
    Address[] froms=message.getFrom();
    InternetAddress sender=null;
    try {
      if (message.getHeader(""String_Node_Str"") != null) {
        sender=new InternetAddress(message.getHeader(""String_Node_Str"")[0]);
      }
    }
 catch (    MessagingException ex) {
    }
    int fromsLength=(froms != null) ? froms.length : 0;
    fromAddresses=new String[fromsLength + ((sender != null) ? 1 : 0)];
    for (int i=0; i < froms.length; i++) {
      InternetAddress inetAddr=(InternetAddress)froms[i];
      fromAddresses[i]=inetAddr.getAddress();
    }
    if (sender != null) {
      fromAddresses[froms.length]=sender.getAddress();
    }
    results=new HashMap();
  }
 catch (  Exception e) {
    if (e instanceof SignedMailValidatorException) {
      throw (SignedMailValidatorException)e;
    }
    ErrorBundle msg=new ErrorBundle(RESOURCE_NAME,""String_Node_Str"",new Object[]{e.getMessage(),e,e.getClass().getName()});
    throw new SignedMailValidatorException(msg,e);
  }
  validateSignatures(param);
}","/** 
 * Validates the signed   {@link MimeMessage} message. The{@link PKIXParameters} from param are used for the certificate pathvalidation. The actual PKIXParameters used for the certificate path validation is a copy of param with the followin changes: <br> - The validation date is changed to the signature time <br> - A CertStore with certificates and crls from the mail message is added to the CertStores.<br> <br> In <code>param</code> it's also possible to add additional CertStores with intermediate Certificates and/or CRLs which then are also used for the validation.
 * @param message               the signed MimeMessage
 * @param param                 the parameters for the certificate path validation
 * @param certPathReviewerClass a subclass of {@link PKIXCertPathReviewer}. The SignedMailValidator uses objects of this type for the cert path vailidation. The class must have an empty constructor.
 * @throws SignedMailValidatorException if the message is no signed message or if an exception occursreading the message
 * @throws IllegalArgumentException if the certPathReviewerClass is not asubclass of  {@link PKIXCertPathReviewer} or objects ofcertPathReviewerClass can not be instantiated
 */
public SignedMailValidator(MimeMessage message,PKIXParameters param,Class certPathReviewerClass) throws SignedMailValidatorException {
  this.certPathReviewerClass=certPathReviewerClass;
  boolean isSubclass=DEFAULT_CERT_PATH_REVIEWER.isAssignableFrom(certPathReviewerClass);
  if (!isSubclass) {
    throw new IllegalArgumentException(""String_Node_Str"" + DEFAULT_CERT_PATH_REVIEWER.getName());
  }
  SMIMESigned s;
  try {
    if (message.isMimeType(""String_Node_Str"")) {
      MimeMultipart mimemp=(MimeMultipart)message.getContent();
      s=new SMIMESigned(mimemp);
    }
 else     if (message.isMimeType(""String_Node_Str"") || message.isMimeType(""String_Node_Str"")) {
      s=new SMIMESigned(message);
    }
 else {
      ErrorBundle msg=new ErrorBundle(RESOURCE_NAME,""String_Node_Str"");
      throw new SignedMailValidatorException(msg);
    }
    certs=new JcaCertStoreBuilder().addCertificates(s.getCertificates()).addCRLs(s.getCRLs()).setProvider(""String_Node_Str"").build();
    signers=s.getSignerInfos();
    Address[] froms=message.getFrom();
    InternetAddress sender=null;
    try {
      if (message.getHeader(""String_Node_Str"") != null) {
        sender=new InternetAddress(message.getHeader(""String_Node_Str"")[0]);
      }
    }
 catch (    MessagingException ex) {
    }
    int fromsLength=(froms != null) ? froms.length : 0;
    fromAddresses=new String[fromsLength + ((sender != null) ? 1 : 0)];
    for (int i=0; i < fromsLength; i++) {
      InternetAddress inetAddr=(InternetAddress)froms[i];
      fromAddresses[i]=inetAddr.getAddress();
    }
    if (sender != null) {
      fromAddresses[fromsLength]=sender.getAddress();
    }
    results=new HashMap();
  }
 catch (  Exception e) {
    if (e instanceof SignedMailValidatorException) {
      throw (SignedMailValidatorException)e;
    }
    ErrorBundle msg=new ErrorBundle(RESOURCE_NAME,""String_Node_Str"",new Object[]{e.getMessage(),e,e.getClass().getName()});
    throw new SignedMailValidatorException(msg,e);
  }
  validateSignatures(param);
}"
52438,"public void init(boolean forEncryption,CipherParameters param){
  AsymmetricKeyParameter kParam;
  if (param instanceof ParametersWithRandom) {
    ParametersWithRandom rParam=(ParametersWithRandom)param;
    this.random=rParam.getRandom();
    kParam=(AsymmetricKeyParameter)rParam.getParameters();
  }
 else {
    kParam=(AsymmetricKeyParameter)param;
    if (!kParam.isPrivate() && forEncryption) {
      this.random=new SecureRandom();
    }
  }
  engine.init(forEncryption,param);
  this.forPrivateKey=kParam.isPrivate();
  this.forEncryption=forEncryption;
  this.blockBuffer=new byte[engine.getOutputBlockSize()];
}","public void init(boolean forEncryption,CipherParameters param){
  AsymmetricKeyParameter kParam;
  if (param instanceof ParametersWithRandom) {
    ParametersWithRandom rParam=(ParametersWithRandom)param;
    this.random=rParam.getRandom();
    kParam=(AsymmetricKeyParameter)rParam.getParameters();
  }
 else {
    kParam=(AsymmetricKeyParameter)param;
    if (!kParam.isPrivate() && forEncryption) {
      this.random=new SecureRandom();
    }
  }
  engine.init(forEncryption,param);
  this.forPrivateKey=kParam.isPrivate();
  this.forEncryption=forEncryption;
  this.blockBuffer=new byte[engine.getOutputBlockSize()];
  if (pLen > 0 && fallback == null && random == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}"
52439,"/** 
 * Decode PKCS#1.5 encoding, and return a random value if the padding is not correct.
 * @param in    The encrypted block.
 * @param inOff Offset in the encrypted block.
 * @param inLen Length of the encrypted block.//@param pLen Length of the desired output.
 * @return The plaintext without padding, or a random value if the padding was incorrect.
 * @throws InvalidCipherTextException
 */
private byte[] decodeBlockOrRandom(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  if (!forPrivateKey) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  byte[] block=engine.processBlock(in,inOff,inLen);
  byte[] random;
  if (this.fallback == null) {
    random=new byte[this.pLen];
    this.random.nextBytes(random);
  }
 else {
    random=fallback;
  }
  System.arraycopy(block,0,blockBuffer,blockBuffer.length - block.length,block.length);
  byte[] data=(useStrictLength) ? block : blockBuffer;
  int correct=PKCS1Encoding.checkPkcs1Encoding(data,this.pLen);
  byte[] result=new byte[this.pLen];
  for (int i=0; i < this.pLen; i++) {
    result[i]=(byte)((data[i + (data.length - pLen)] & (~correct)) | (random[i] & correct));
  }
  Arrays.fill(data,(byte)0);
  Arrays.fill(blockBuffer,(byte)0);
  return result;
}","/** 
 * Decode PKCS#1.5 encoding, and return a random value if the padding is not correct.
 * @param in    The encrypted block.
 * @param inOff Offset in the encrypted block.
 * @param inLen Length of the encrypted block.//@param pLen Length of the desired output.
 * @return The plaintext without padding, or a random value if the padding was incorrect.
 * @throws InvalidCipherTextException
 */
private byte[] decodeBlockOrRandom(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  if (!forPrivateKey) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  byte[] block=engine.processBlock(in,inOff,inLen);
  byte[] random;
  if (this.fallback == null) {
    random=new byte[this.pLen];
    this.random.nextBytes(random);
  }
 else {
    random=fallback;
  }
  byte[] data=(useStrictLength & (block.length != engine.getOutputBlockSize())) ? blockBuffer : block;
  int correct=PKCS1Encoding.checkPkcs1Encoding(data,this.pLen);
  byte[] result=new byte[this.pLen];
  for (int i=0; i < this.pLen; i++) {
    result[i]=(byte)((data[i + (data.length - pLen)] & (~correct)) | (random[i] & correct));
  }
  Arrays.fill(data,(byte)0);
  return result;
}"
52440,"private void testStrictPKCS1Length(RSAKeyParameters pubParameters,RSAKeyParameters privParameters){
  AsymmetricBlockCipher eng=new RSAEngine();
  eng.init(true,privParameters);
  byte[] data=null;
  try {
    data=eng.processBlock(oversizedSig,0,oversizedSig.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng=new PKCS1Encoding(eng);
  eng.init(false,pubParameters);
  try {
    data=eng.processBlock(data,0,data.length);
    fail(""String_Node_Str"");
  }
 catch (  InvalidCipherTextException e) {
    if (!e.getMessage().equals(""String_Node_Str"")) {
      fail(""String_Node_Str"" + e.toString(),e);
    }
  }
  System.getProperties().put(PKCS1Encoding.STRICT_LENGTH_ENABLED_PROPERTY,""String_Node_Str"");
  eng=new PKCS1Encoding(new RSAEngine());
  eng.init(false,pubParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  InvalidCipherTextException e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  System.getProperties().remove(PKCS1Encoding.STRICT_LENGTH_ENABLED_PROPERTY);
}","private void testStrictPKCS1Length(RSAKeyParameters pubParameters,RSAKeyParameters privParameters){
  AsymmetricBlockCipher eng=new RSAEngine();
  eng.init(true,privParameters);
  byte[] data=null;
  byte[] overSized=null;
  try {
    overSized=data=eng.processBlock(oversizedSig,0,oversizedSig.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng=new PKCS1Encoding(eng);
  eng.init(false,pubParameters);
  try {
    data=eng.processBlock(overSized,0,overSized.length);
    fail(""String_Node_Str"");
  }
 catch (  InvalidCipherTextException e) {
    if (!e.getMessage().equals(""String_Node_Str"")) {
      fail(""String_Node_Str"" + e.toString(),e);
    }
  }
  eng=new PKCS1Encoding(new RSAEngine(),Hex.decode(""String_Node_Str""));
  eng.init(false,new ParametersWithRandom(privParameters,new SecureRandom()));
  try {
    data=eng.processBlock(overSized,0,overSized.length);
    isTrue(""String_Node_Str"",Arrays.areEqual(Hex.decode(""String_Node_Str""),data));
  }
 catch (  InvalidCipherTextException e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  System.getProperties().put(PKCS1Encoding.NOT_STRICT_LENGTH_ENABLED_PROPERTY,""String_Node_Str"");
  eng=new PKCS1Encoding(new RSAEngine());
  eng.init(false,pubParameters);
  try {
    data=eng.processBlock(overSized,0,overSized.length);
  }
 catch (  InvalidCipherTextException e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  System.getProperties().remove(PKCS1Encoding.NOT_STRICT_LENGTH_ENABLED_PROPERTY);
}"
52441,"public void performTest(){
  RSAKeyParameters pubParameters=new RSAKeyParameters(false,mod,pubExp);
  RSAKeyParameters privParameters=new RSAPrivateCrtKeyParameters(mod,pubExp,privExp,p,q,pExp,qExp,crtCoef);
  byte[] data=Hex.decode(edgeInput);
  AsymmetricBlockCipher eng=new RSAEngine();
  eng.init(true,pubParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,privParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!edgeInput.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  data=Hex.decode(input);
  eng.init(true,pubParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,privParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  eng=new PKCS1Encoding(eng);
  eng.init(true,pubParameters);
  if (eng.getOutputBlockSize() != ((PKCS1Encoding)eng).getUnderlyingCipher().getOutputBlockSize()) {
    fail(""String_Node_Str"");
  }
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,privParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  eng=new PKCS1Encoding(((PKCS1Encoding)eng).getUnderlyingCipher());
  eng.init(true,privParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,pubParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  zeroBlockTest(pubParameters,privParameters);
  zeroBlockTest(privParameters,pubParameters);
  RSAKeyPairGenerator pGen=new RSAKeyPairGenerator();
  RSAKeyGenerationParameters genParam=new RSAKeyGenerationParameters(BigInteger.valueOf(0x11),new SecureRandom(),768,25);
  pGen.init(genParam);
  AsymmetricCipherKeyPair pair=pGen.generateKeyPair();
  eng=new RSAEngine();
  if (((RSAKeyParameters)pair.getPublic()).getModulus().bitLength() < 768) {
    fail(""String_Node_Str"");
  }
  eng.init(true,pair.getPublic());
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,pair.getPrivate());
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  genParam=new RSAKeyGenerationParameters(BigInteger.valueOf(0x11),new SecureRandom(),1024,25);
  pGen.init(genParam);
  pair=pGen.generateKeyPair();
  eng.init(true,pair.getPublic());
  if (((RSAKeyParameters)pair.getPublic()).getModulus().bitLength() < 1024) {
    fail(""String_Node_Str"");
  }
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,pair.getPrivate());
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  genParam=new RSAKeyGenerationParameters(BigInteger.valueOf(0x11),new SecureRandom(),128,25);
  pGen.init(genParam);
  for (int i=0; i < 100; ++i) {
    pair=pGen.generateKeyPair();
    RSAPrivateCrtKeyParameters privKey=(RSAPrivateCrtKeyParameters)pair.getPrivate();
    BigInteger pqDiff=privKey.getP().subtract(privKey.getQ()).abs();
    if (pqDiff.bitLength() < 42) {
      fail(""String_Node_Str"");
    }
  }
  testOAEP(pubParameters,privParameters);
  testStrictPKCS1Length(pubParameters,privParameters);
  testDudPKCS1Block(pubParameters,privParameters);
  testMissingDataPKCS1Block(pubParameters,privParameters);
  testTruncatedPKCS1Block(pubParameters,privParameters);
  testWrongPaddingPKCS1Block(pubParameters,privParameters);
  try {
    new RSAEngine().processBlock(new byte[]{1},0,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalStateException e) {
  }
}","public void performTest(){
  RSAKeyParameters pubParameters=new RSAKeyParameters(false,mod,pubExp);
  RSAKeyParameters privParameters=new RSAPrivateCrtKeyParameters(mod,pubExp,privExp,p,q,pExp,qExp,crtCoef);
  byte[] data=Hex.decode(edgeInput);
  AsymmetricBlockCipher eng=new RSAEngine();
  eng.init(true,pubParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,privParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!edgeInput.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  data=Hex.decode(input);
  eng.init(true,pubParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,privParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  eng=new PKCS1Encoding(eng);
  eng.init(true,pubParameters);
  if (eng.getOutputBlockSize() != ((PKCS1Encoding)eng).getUnderlyingCipher().getOutputBlockSize()) {
    fail(""String_Node_Str"");
  }
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,privParameters);
  byte[] plainData=null;
  try {
    plainData=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(Hex.toHexString(plainData))) {
    fail(""String_Node_Str"");
  }
  PKCS1Encoding fEng=new PKCS1Encoding(new RSAEngine(),input.length() / 2);
  fEng.init(false,new ParametersWithRandom(privParameters,new SecureRandom()));
  try {
    plainData=fEng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(Hex.toHexString(plainData))) {
    fail(""String_Node_Str"");
  }
  fEng=new PKCS1Encoding(new RSAEngine(),input.length());
  fEng.init(false,new ParametersWithRandom(privParameters,new SecureRandom()));
  try {
    data=fEng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (input.equals(Hex.toHexString(data))) {
    fail(""String_Node_Str"");
  }
  data=plainData;
  eng=new PKCS1Encoding(((PKCS1Encoding)eng).getUnderlyingCipher());
  eng.init(true,privParameters);
  try {
    data=eng.processBlock(plainData,0,plainData.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,pubParameters);
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(Hex.toHexString(data))) {
    fail(""String_Node_Str"");
  }
  zeroBlockTest(pubParameters,privParameters);
  zeroBlockTest(privParameters,pubParameters);
  RSAKeyPairGenerator pGen=new RSAKeyPairGenerator();
  RSAKeyGenerationParameters genParam=new RSAKeyGenerationParameters(BigInteger.valueOf(0x11),new SecureRandom(),768,25);
  pGen.init(genParam);
  AsymmetricCipherKeyPair pair=pGen.generateKeyPair();
  eng=new RSAEngine();
  if (((RSAKeyParameters)pair.getPublic()).getModulus().bitLength() < 768) {
    fail(""String_Node_Str"");
  }
  eng.init(true,pair.getPublic());
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,pair.getPrivate());
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  genParam=new RSAKeyGenerationParameters(BigInteger.valueOf(0x11),new SecureRandom(),1024,25);
  pGen.init(genParam);
  pair=pGen.generateKeyPair();
  eng.init(true,pair.getPublic());
  if (((RSAKeyParameters)pair.getPublic()).getModulus().bitLength() < 1024) {
    fail(""String_Node_Str"");
  }
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  eng.init(false,pair.getPrivate());
  try {
    data=eng.processBlock(data,0,data.length);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString(),e);
  }
  if (!input.equals(new String(Hex.encode(data)))) {
    fail(""String_Node_Str"");
  }
  genParam=new RSAKeyGenerationParameters(BigInteger.valueOf(0x11),new SecureRandom(),128,25);
  pGen.init(genParam);
  for (int i=0; i < 100; ++i) {
    pair=pGen.generateKeyPair();
    RSAPrivateCrtKeyParameters privKey=(RSAPrivateCrtKeyParameters)pair.getPrivate();
    BigInteger pqDiff=privKey.getP().subtract(privKey.getQ()).abs();
    if (pqDiff.bitLength() < 42) {
      fail(""String_Node_Str"");
    }
  }
  testOAEP(pubParameters,privParameters);
  testStrictPKCS1Length(pubParameters,privParameters);
  testDudPKCS1Block(pubParameters,privParameters);
  testMissingDataPKCS1Block(pubParameters,privParameters);
  testTruncatedPKCS1Block(pubParameters,privParameters);
  testWrongPaddingPKCS1Block(pubParameters,privParameters);
  try {
    new RSAEngine().processBlock(new byte[]{1},0,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalStateException e) {
  }
}"
52442,"public void testAES256CCM() throws Exception {
  Security.addProvider(new BouncyCastleProvider());
  byte[] data=""String_Node_Str"".getBytes();
  ASN1ObjectIdentifier macAlg=CMSAlgorithm.AES256_CCM;
  AlgorithmParameters algParams=AlgorithmParameters.getInstance(""String_Node_Str"",BC);
  algParams.init(new CCMParameters(Hex.decode(""String_Node_Str""),16).getEncoded());
  CMSAuthenticatedDataGenerator adGen=new CMSAuthenticatedDataGenerator();
  X509CertificateHolder origCert=new X509CertificateHolder(_origCert.getEncoded());
  adGen.setOriginatorInfo(new OriginatorInfoGenerator(origCert).generate());
  adGen.addRecipientInfoGenerator(new JceKeyTransRecipientInfoGenerator(_reciCert).setProvider(BC));
  CMSAuthenticatedData ad=adGen.generate(new CMSProcessableByteArray(data),new JceCMSMacCalculatorBuilder(macAlg).setAlgorithmParameters(algParams).setProvider(BC).build());
  assertTrue(ad.getOriginatorInfo().getCertificates().getMatches(null).contains(origCert));
  RecipientInformationStore recipients=ad.getRecipientInfos();
  assertEquals(ad.getMacAlgOID(),macAlg.getId());
  Collection c=recipients.getRecipients();
  assertEquals(1,c.size());
  Iterator it=c.iterator();
  while (it.hasNext()) {
    RecipientInformation recipient=(RecipientInformation)it.next();
    assertEquals(recipient.getKeyEncryptionAlgOID(),PKCSObjectIdentifiers.rsaEncryption.getId());
    byte[] recData=recipient.getContent(new JceKeyTransAuthenticatedRecipient(_reciKP.getPrivate()).setProvider(BC));
    assertTrue(Arrays.equals(data,recData));
    assertEquals(16,ad.getMac().length);
    assertTrue(Arrays.equals(ad.getMac(),recipient.getMac()));
  }
}","public void testAES256CCM() throws Exception {
  byte[] data=""String_Node_Str"".getBytes();
  ASN1ObjectIdentifier macAlg=CMSAlgorithm.AES256_CCM;
  AlgorithmParameters algParams=AlgorithmParameters.getInstance(""String_Node_Str"",BC);
  algParams.init(new CCMParameters(Hex.decode(""String_Node_Str""),16).getEncoded());
  CMSAuthenticatedDataGenerator adGen=new CMSAuthenticatedDataGenerator();
  X509CertificateHolder origCert=new X509CertificateHolder(_origCert.getEncoded());
  adGen.setOriginatorInfo(new OriginatorInfoGenerator(origCert).generate());
  adGen.addRecipientInfoGenerator(new JceKeyTransRecipientInfoGenerator(_reciCert).setProvider(BC));
  CMSAuthenticatedData ad=adGen.generate(new CMSProcessableByteArray(data),new JceCMSMacCalculatorBuilder(macAlg).setAlgorithmParameters(algParams).setProvider(BC).build());
  assertTrue(ad.getOriginatorInfo().getCertificates().getMatches(null).contains(origCert));
  RecipientInformationStore recipients=ad.getRecipientInfos();
  assertEquals(ad.getMacAlgOID(),macAlg.getId());
  Collection c=recipients.getRecipients();
  assertEquals(1,c.size());
  Iterator it=c.iterator();
  while (it.hasNext()) {
    RecipientInformation recipient=(RecipientInformation)it.next();
    assertEquals(recipient.getKeyEncryptionAlgOID(),PKCSObjectIdentifiers.rsaEncryption.getId());
    byte[] recData=recipient.getContent(new JceKeyTransAuthenticatedRecipient(_reciKP.getPrivate()).setProvider(BC));
    assertTrue(Arrays.equals(data,recData));
    assertEquals(16,ad.getMac().length);
    assertTrue(Arrays.equals(ad.getMac(),recipient.getMac()));
  }
}"
52443,"protected void engineInit(Key key,AlgorithmParameterSpec params) throws InvalidKeyException, InvalidAlgorithmParameterException {
  CipherParameters param;
  if (key == null) {
    throw new InvalidKeyException(""String_Node_Str"");
  }
  if (key instanceof PKCS12Key) {
    SecretKey k;
    PBEParameterSpec pbeSpec;
    try {
      k=(SecretKey)key;
    }
 catch (    Exception e) {
      throw new InvalidKeyException(""String_Node_Str"");
    }
    try {
      pbeSpec=(PBEParameterSpec)params;
    }
 catch (    Exception e) {
      throw new InvalidAlgorithmParameterException(""String_Node_Str"");
    }
    if (k instanceof PBEKey && pbeSpec == null) {
      pbeSpec=new PBEParameterSpec(((PBEKey)k).getSalt(),((PBEKey)k).getIterationCount());
    }
    int digest=SHA1;
    int keySize=160;
    if (macEngine.getAlgorithmName().startsWith(""String_Node_Str"")) {
      digest=GOST3411;
      keySize=256;
    }
 else     if (macEngine.getAlgorithmName().startsWith(""String_Node_Str"")) {
      digest=SHA256;
      keySize=256;
    }
    param=PBE.Util.makePBEMacParameters(k,PKCS12,digest,keySize,pbeSpec);
  }
 else   if (key instanceof BCPBEKey) {
    BCPBEKey k=(BCPBEKey)key;
    if (k.getParam() != null) {
      param=k.getParam();
    }
 else     if (params instanceof PBEParameterSpec) {
      param=PBE.Util.makePBEMacParameters(k,params);
    }
 else {
      throw new InvalidAlgorithmParameterException(""String_Node_Str"");
    }
  }
 else   if (params instanceof IvParameterSpec) {
    param=new ParametersWithIV(new KeyParameter(key.getEncoded()),((IvParameterSpec)params).getIV());
  }
 else   if (params instanceof RC2ParameterSpec) {
    param=new ParametersWithIV(new RC2Parameters(key.getEncoded(),((RC2ParameterSpec)params).getEffectiveKeyBits()),((RC2ParameterSpec)params).getIV());
  }
 else   if (params instanceof SkeinParameterSpec) {
    param=new SkeinParameters.Builder(copyMap(((SkeinParameterSpec)params).getParameters())).setKey(key.getEncoded()).build();
  }
 else   if (gcmSpecClass != null && gcmSpecClass.isAssignableFrom(params.getClass())) {
    try {
      Method tLen=gcmSpecClass.getDeclaredMethod(""String_Node_Str"",new Class[0]);
      Method iv=gcmSpecClass.getDeclaredMethod(""String_Node_Str"",new Class[0]);
      KeyParameter keyParam=new KeyParameter(key.getEncoded());
      param=new AEADParameters(keyParam,((Integer)tLen.invoke(params,new Object[0])).intValue(),(byte[])iv.invoke(params,new Object[0]));
    }
 catch (    Exception e) {
      throw new InvalidAlgorithmParameterException(""String_Node_Str"");
    }
  }
 else   if (params == null) {
    param=new KeyParameter(key.getEncoded());
  }
 else {
    throw new InvalidAlgorithmParameterException(""String_Node_Str"" + params.getClass().getName());
  }
  macEngine.init(param);
}","protected void engineInit(Key key,AlgorithmParameterSpec params) throws InvalidKeyException, InvalidAlgorithmParameterException {
  CipherParameters param;
  if (key == null) {
    throw new InvalidKeyException(""String_Node_Str"");
  }
  if (key instanceof PKCS12Key) {
    SecretKey k;
    PBEParameterSpec pbeSpec;
    try {
      k=(SecretKey)key;
    }
 catch (    Exception e) {
      throw new InvalidKeyException(""String_Node_Str"");
    }
    try {
      pbeSpec=(PBEParameterSpec)params;
    }
 catch (    Exception e) {
      throw new InvalidAlgorithmParameterException(""String_Node_Str"");
    }
    if (k instanceof PBEKey && pbeSpec == null) {
      pbeSpec=new PBEParameterSpec(((PBEKey)k).getSalt(),((PBEKey)k).getIterationCount());
    }
    int digest=SHA1;
    int keySize=160;
    if (macEngine.getAlgorithmName().startsWith(""String_Node_Str"")) {
      digest=GOST3411;
      keySize=256;
    }
 else     if (macEngine.getAlgorithmName().startsWith(""String_Node_Str"")) {
      digest=SHA256;
      keySize=256;
    }
    param=PBE.Util.makePBEMacParameters(k,PKCS12,digest,keySize,pbeSpec);
  }
 else   if (key instanceof BCPBEKey) {
    BCPBEKey k=(BCPBEKey)key;
    if (k.getParam() != null) {
      param=k.getParam();
    }
 else     if (params instanceof PBEParameterSpec) {
      param=PBE.Util.makePBEMacParameters(k,params);
    }
 else {
      throw new InvalidAlgorithmParameterException(""String_Node_Str"");
    }
  }
 else   if (params instanceof IvParameterSpec) {
    param=new ParametersWithIV(new KeyParameter(key.getEncoded()),((IvParameterSpec)params).getIV());
  }
 else   if (params instanceof RC2ParameterSpec) {
    param=new ParametersWithIV(new RC2Parameters(key.getEncoded(),((RC2ParameterSpec)params).getEffectiveKeyBits()),((RC2ParameterSpec)params).getIV());
  }
 else   if (params instanceof SkeinParameterSpec) {
    param=new SkeinParameters.Builder(copyMap(((SkeinParameterSpec)params).getParameters())).setKey(key.getEncoded()).build();
  }
 else   if (params == null) {
    param=new KeyParameter(key.getEncoded());
  }
 else   if (gcmSpecClass != null && gcmSpecClass.isAssignableFrom(params.getClass())) {
    try {
      Method tLen=gcmSpecClass.getDeclaredMethod(""String_Node_Str"",new Class[0]);
      Method iv=gcmSpecClass.getDeclaredMethod(""String_Node_Str"",new Class[0]);
      KeyParameter keyParam=new KeyParameter(key.getEncoded());
      param=new AEADParameters(keyParam,((Integer)tLen.invoke(params,new Object[0])).intValue(),(byte[])iv.invoke(params,new Object[0]));
    }
 catch (    Exception e) {
      throw new InvalidAlgorithmParameterException(""String_Node_Str"");
    }
  }
 else {
    throw new InvalidAlgorithmParameterException(""String_Node_Str"" + params.getClass().getName());
  }
  macEngine.init(param);
}"
52444,"/** 
 * Reads a parameter set from an input stream.
 * @param is an input stream
 * @throws java.io.IOException
 */
public NTRUEncryptionKeyGenerationParameters(InputStream is) throws IOException {
  super(new SecureRandom(),-1);
  DataInputStream dis=new DataInputStream(is);
  N=dis.readInt();
  q=dis.readInt();
  df=dis.readInt();
  df1=dis.readInt();
  df2=dis.readInt();
  df3=dis.readInt();
  db=dis.readInt();
  dm0=dis.readInt();
  c=dis.readInt();
  minCallsR=dis.readInt();
  minCallsMask=dis.readInt();
  hashSeed=dis.readBoolean();
  oid=new byte[3];
  dis.read(oid);
  sparse=dis.readBoolean();
  fastFp=dis.readBoolean();
  polyType=dis.read();
  String alg=dis.readUTF();
  if (""String_Node_Str"".equals(alg)) {
    hashAlg=new SHA512Digest();
  }
 else   if (""String_Node_Str"".equals(alg)) {
    hashAlg=new SHA256Digest();
  }
  init();
}","/** 
 * Reads a parameter set from an input stream.
 * @param is an input stream
 * @throws java.io.IOException
 */
public NTRUEncryptionKeyGenerationParameters(InputStream is) throws IOException {
  super(new SecureRandom(),-1);
  DataInputStream dis=new DataInputStream(is);
  N=dis.readInt();
  q=dis.readInt();
  df=dis.readInt();
  df1=dis.readInt();
  df2=dis.readInt();
  df3=dis.readInt();
  db=dis.readInt();
  dm0=dis.readInt();
  c=dis.readInt();
  minCallsR=dis.readInt();
  minCallsMask=dis.readInt();
  hashSeed=dis.readBoolean();
  oid=new byte[3];
  dis.readFully(oid);
  sparse=dis.readBoolean();
  fastFp=dis.readBoolean();
  polyType=dis.read();
  String alg=dis.readUTF();
  if (""String_Node_Str"".equals(alg)) {
    hashAlg=new SHA512Digest();
  }
 else   if (""String_Node_Str"".equals(alg)) {
    hashAlg=new SHA256Digest();
  }
  init();
}"
52445,"private static final long mul32x32_64(int i1,int i2){
  return ((long)i1) * i2;
}","private static final long mul32x32_64(int i1,int i2){
  return (i1 & 0xFFFFFFFFL) * i2;
}"
52446,"private void processBlock(){
  if (currentBlockOffset < BLOCK_SIZE) {
    currentBlock[currentBlockOffset]=1;
    for (int i=currentBlockOffset + 1; i < BLOCK_SIZE; i++) {
      currentBlock[i]=0;
    }
  }
  final long t0=0xffffffffL & Pack.littleEndianToInt(currentBlock,0);
  final long t1=0xffffffffL & Pack.littleEndianToInt(currentBlock,4);
  final long t2=0xffffffffL & Pack.littleEndianToInt(currentBlock,8);
  final long t3=0xffffffffL & Pack.littleEndianToInt(currentBlock,12);
  h0+=t0 & 0x3ffffff;
  h1+=(((t1 << 32) | t0) >>> 26) & 0x3ffffff;
  h2+=(((t2 << 32) | t1) >>> 20) & 0x3ffffff;
  h3+=(((t3 << 32) | t2) >>> 14) & 0x3ffffff;
  h4+=(t3 >>> 8);
  if (currentBlockOffset == BLOCK_SIZE) {
    h4+=(1 << 24);
  }
  long tp0=mul32x32_64(h0,r0) + mul32x32_64(h1,s4) + mul32x32_64(h2,s3)+ mul32x32_64(h3,s2)+ mul32x32_64(h4,s1);
  long tp1=mul32x32_64(h0,r1) + mul32x32_64(h1,r0) + mul32x32_64(h2,s4)+ mul32x32_64(h3,s3)+ mul32x32_64(h4,s2);
  long tp2=mul32x32_64(h0,r2) + mul32x32_64(h1,r1) + mul32x32_64(h2,r0)+ mul32x32_64(h3,s4)+ mul32x32_64(h4,s3);
  long tp3=mul32x32_64(h0,r3) + mul32x32_64(h1,r2) + mul32x32_64(h2,r1)+ mul32x32_64(h3,r0)+ mul32x32_64(h4,s4);
  long tp4=mul32x32_64(h0,r4) + mul32x32_64(h1,r3) + mul32x32_64(h2,r2)+ mul32x32_64(h3,r1)+ mul32x32_64(h4,r0);
  long b;
  h0=(int)tp0 & 0x3ffffff;
  b=(tp0 >>> 26);
  tp1+=b;
  h1=(int)tp1 & 0x3ffffff;
  b=((tp1 >>> 26) & 0xffffffff);
  tp2+=b;
  h2=(int)tp2 & 0x3ffffff;
  b=((tp2 >>> 26) & 0xffffffff);
  tp3+=b;
  h3=(int)tp3 & 0x3ffffff;
  b=(tp3 >>> 26);
  tp4+=b;
  h4=(int)tp4 & 0x3ffffff;
  b=(tp4 >>> 26);
  h0+=b * 5;
}","private void processBlock(){
  if (currentBlockOffset < BLOCK_SIZE) {
    currentBlock[currentBlockOffset]=1;
    for (int i=currentBlockOffset + 1; i < BLOCK_SIZE; i++) {
      currentBlock[i]=0;
    }
  }
  final long t0=0xffffffffL & Pack.littleEndianToInt(currentBlock,0);
  final long t1=0xffffffffL & Pack.littleEndianToInt(currentBlock,4);
  final long t2=0xffffffffL & Pack.littleEndianToInt(currentBlock,8);
  final long t3=0xffffffffL & Pack.littleEndianToInt(currentBlock,12);
  h0+=t0 & 0x3ffffff;
  h1+=(((t1 << 32) | t0) >>> 26) & 0x3ffffff;
  h2+=(((t2 << 32) | t1) >>> 20) & 0x3ffffff;
  h3+=(((t3 << 32) | t2) >>> 14) & 0x3ffffff;
  h4+=(t3 >>> 8);
  if (currentBlockOffset == BLOCK_SIZE) {
    h4+=(1 << 24);
  }
  long tp0=mul32x32_64(h0,r0) + mul32x32_64(h1,s4) + mul32x32_64(h2,s3)+ mul32x32_64(h3,s2)+ mul32x32_64(h4,s1);
  long tp1=mul32x32_64(h0,r1) + mul32x32_64(h1,r0) + mul32x32_64(h2,s4)+ mul32x32_64(h3,s3)+ mul32x32_64(h4,s2);
  long tp2=mul32x32_64(h0,r2) + mul32x32_64(h1,r1) + mul32x32_64(h2,r0)+ mul32x32_64(h3,s4)+ mul32x32_64(h4,s3);
  long tp3=mul32x32_64(h0,r3) + mul32x32_64(h1,r2) + mul32x32_64(h2,r1)+ mul32x32_64(h3,r0)+ mul32x32_64(h4,s4);
  long tp4=mul32x32_64(h0,r4) + mul32x32_64(h1,r3) + mul32x32_64(h2,r2)+ mul32x32_64(h3,r1)+ mul32x32_64(h4,r0);
  h0=(int)tp0 & 0x3ffffff;
  tp1+=(tp0 >>> 26);
  h1=(int)tp1 & 0x3ffffff;
  tp2+=(tp1 >>> 26);
  h2=(int)tp2 & 0x3ffffff;
  tp3+=(tp2 >>> 26);
  h3=(int)tp3 & 0x3ffffff;
  tp4+=(tp3 >>> 26);
  h4=(int)tp4 & 0x3ffffff;
  h0+=(int)(tp4 >>> 26) * 5;
  h1+=(h0 >>> 26);
  h0&=0x3ffffff;
}"
52447,"public int doFinal(final byte[] out,final int outOff) throws DataLengthException, IllegalStateException {
  if (outOff + BLOCK_SIZE > out.length) {
    throw new DataLengthException(""String_Node_Str"");
  }
  if (currentBlockOffset > 0) {
    processBlock();
  }
  long f0, f1, f2, f3;
  int b=h0 >>> 26;
  h0=h0 & 0x3ffffff;
  h1+=b;
  b=h1 >>> 26;
  h1=h1 & 0x3ffffff;
  h2+=b;
  b=h2 >>> 26;
  h2=h2 & 0x3ffffff;
  h3+=b;
  b=h3 >>> 26;
  h3=h3 & 0x3ffffff;
  h4+=b;
  b=h4 >>> 26;
  h4=h4 & 0x3ffffff;
  h0+=b * 5;
  int g0, g1, g2, g3, g4;
  g0=h0 + 5;
  b=g0 >>> 26;
  g0&=0x3ffffff;
  g1=h1 + b;
  b=g1 >>> 26;
  g1&=0x3ffffff;
  g2=h2 + b;
  b=g2 >>> 26;
  g2&=0x3ffffff;
  g3=h3 + b;
  b=g3 >>> 26;
  g3&=0x3ffffff;
  g4=h4 + b - (1 << 26);
  b=(g4 >>> 31) - 1;
  int nb=~b;
  h0=(h0 & nb) | (g0 & b);
  h1=(h1 & nb) | (g1 & b);
  h2=(h2 & nb) | (g2 & b);
  h3=(h3 & nb) | (g3 & b);
  h4=(h4 & nb) | (g4 & b);
  f0=(((h0) | (h1 << 26)) & 0xffffffffl) + (0xffffffffL & k0);
  f1=(((h1 >>> 6) | (h2 << 20)) & 0xffffffffl) + (0xffffffffL & k1);
  f2=(((h2 >>> 12) | (h3 << 14)) & 0xffffffffl) + (0xffffffffL & k2);
  f3=(((h3 >>> 18) | (h4 << 8)) & 0xffffffffl) + (0xffffffffL & k3);
  Pack.intToLittleEndian((int)f0,out,outOff);
  f1+=(f0 >>> 32);
  Pack.intToLittleEndian((int)f1,out,outOff + 4);
  f2+=(f1 >>> 32);
  Pack.intToLittleEndian((int)f2,out,outOff + 8);
  f3+=(f2 >>> 32);
  Pack.intToLittleEndian((int)f3,out,outOff + 12);
  reset();
  return BLOCK_SIZE;
}","public int doFinal(final byte[] out,final int outOff) throws DataLengthException, IllegalStateException {
  if (outOff + BLOCK_SIZE > out.length) {
    throw new DataLengthException(""String_Node_Str"");
  }
  if (currentBlockOffset > 0) {
    processBlock();
  }
  h1+=(h0 >>> 26);
  h0&=0x3ffffff;
  h2+=(h1 >>> 26);
  h1&=0x3ffffff;
  h3+=(h2 >>> 26);
  h2&=0x3ffffff;
  h4+=(h3 >>> 26);
  h3&=0x3ffffff;
  h0+=(h4 >>> 26) * 5;
  h4&=0x3ffffff;
  h1+=(h0 >>> 26);
  h0&=0x3ffffff;
  int g0, g1, g2, g3, g4, b;
  g0=h0 + 5;
  b=g0 >>> 26;
  g0&=0x3ffffff;
  g1=h1 + b;
  b=g1 >>> 26;
  g1&=0x3ffffff;
  g2=h2 + b;
  b=g2 >>> 26;
  g2&=0x3ffffff;
  g3=h3 + b;
  b=g3 >>> 26;
  g3&=0x3ffffff;
  g4=h4 + b - (1 << 26);
  b=(g4 >>> 31) - 1;
  int nb=~b;
  h0=(h0 & nb) | (g0 & b);
  h1=(h1 & nb) | (g1 & b);
  h2=(h2 & nb) | (g2 & b);
  h3=(h3 & nb) | (g3 & b);
  h4=(h4 & nb) | (g4 & b);
  long f0, f1, f2, f3;
  f0=(((h0) | (h1 << 26)) & 0xffffffffl) + (0xffffffffL & k0);
  f1=(((h1 >>> 6) | (h2 << 20)) & 0xffffffffl) + (0xffffffffL & k1);
  f2=(((h2 >>> 12) | (h3 << 14)) & 0xffffffffl) + (0xffffffffL & k2);
  f3=(((h3 >>> 18) | (h4 << 8)) & 0xffffffffl) + (0xffffffffL & k3);
  Pack.intToLittleEndian((int)f0,out,outOff);
  f1+=(f0 >>> 32);
  Pack.intToLittleEndian((int)f1,out,outOff + 4);
  f2+=(f1 >>> 32);
  Pack.intToLittleEndian((int)f2,out,outOff + 8);
  f3+=(f2 >>> 32);
  Pack.intToLittleEndian((int)f3,out,outOff + 12);
  reset();
  return BLOCK_SIZE;
}"
52448,"public SMIMECompressedTest(String name) throws Exception {
  super(name);
  msg=SMIMETestUtil.makeMimeBodyPart(""String_Node_Str"");
  signDN=""String_Node_Str"";
  signKP=CMSTestUtil.makeKeyPair();
  signCert=CMSTestUtil.makeCertificate(signKP,signDN,signKP,signDN);
  origDN=""String_Node_Str"";
  origKP=CMSTestUtil.makeKeyPair();
  origCert=CMSTestUtil.makeCertificate(origKP,origDN,signKP,signDN);
}","public SMIMECompressedTest(String name) throws Exception {
  super(name);
}"
52449,"private void sealedObjectTest() throws Exception {
  KeyPairGenerator kpg=KeyPairGenerator.getInstance(""String_Node_Str"");
  kpg.initialize(new ECGenParameterSpec(""String_Node_Str""));
  KeyPair keyPair=kpg.generateKeyPair();
  Cipher cipher=Cipher.getInstance(""String_Node_Str"");
  cipher.init(Cipher.ENCRYPT_MODE,keyPair.getPublic());
  String toEncrypt=""String_Node_Str"";
  cipher.doFinal(toEncrypt.getBytes());
  SealedObject sealedObject=new SealedObject(toEncrypt,cipher);
  cipher.init(Cipher.DECRYPT_MODE,keyPair.getPrivate());
  String result=(String)sealedObject.getObject(cipher);
  isTrue(""String_Node_Str"",result.equals(toEncrypt));
}","private void sealedObjectTest() throws Exception {
  KeyPairGenerator kpg=KeyPairGenerator.getInstance(""String_Node_Str"");
  kpg.initialize(new ECGenParameterSpec(""String_Node_Str""));
  KeyPair keyPair=kpg.generateKeyPair();
  Cipher cipher=Cipher.getInstance(""String_Node_Str"");
  cipher.init(Cipher.ENCRYPT_MODE,keyPair.getPublic());
  String toEncrypt=""String_Node_Str"";
  cipher.doFinal(toEncrypt.getBytes());
  SealedObject sealedObject=new SealedObject(toEncrypt,cipher);
  cipher.init(Cipher.DECRYPT_MODE,keyPair.getPrivate());
  String result=(String)sealedObject.getObject(cipher);
  isTrue(""String_Node_Str"",result.equals(toEncrypt));
  result=(String)sealedObject.getObject(keyPair.getPrivate());
  isTrue(""String_Node_Str"",result.equals(toEncrypt));
}"
52450,"/** 
 * @exception InvalidCipherTextException if the decrypted block turns out tobe badly formatted.
 */
public byte[] decodeBlock(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  byte[] data=engine.processBlock(in,inOff,inLen);
  byte[] block;
  if (data.length < engine.getOutputBlockSize()) {
    block=new byte[engine.getOutputBlockSize()];
    System.arraycopy(data,0,block,block.length - data.length,data.length);
  }
 else {
    block=data;
  }
  if (block.length < (2 * defHash.length) + 1) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  byte[] mask=maskGeneratorFunction1(block,defHash.length,block.length - defHash.length,defHash.length);
  for (int i=0; i != defHash.length; i++) {
    block[i]^=mask[i];
  }
  mask=maskGeneratorFunction1(block,0,defHash.length,block.length - defHash.length);
  for (int i=defHash.length; i != block.length; i++) {
    block[i]^=mask[i - defHash.length];
  }
  boolean defHashWrong=false;
  for (int i=0; i != defHash.length; i++) {
    if (defHash[i] != block[defHash.length + i]) {
      defHashWrong=true;
    }
  }
  if (defHashWrong) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  int start;
  for (start=2 * defHash.length; start != block.length; start++) {
    if (block[start] != 0) {
      break;
    }
  }
  if (start >= (block.length - 1) || block[start] != 1) {
    throw new InvalidCipherTextException(""String_Node_Str"" + start);
  }
  start++;
  byte[] output=new byte[block.length - start];
  System.arraycopy(block,start,output,0,output.length);
  return output;
}","/** 
 * @exception InvalidCipherTextException if the decrypted block turns out tobe badly formatted.
 */
public byte[] decodeBlock(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  byte[] data=engine.processBlock(in,inOff,inLen);
  byte[] block;
  if (data.length < engine.getOutputBlockSize()) {
    block=new byte[engine.getOutputBlockSize()];
    System.arraycopy(data,0,block,block.length - data.length,data.length);
  }
 else {
    block=data;
  }
  if (block.length < (2 * defHash.length) + 1) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  byte[] mask=maskGeneratorFunction1(block,defHash.length,block.length - defHash.length,defHash.length);
  for (int i=0; i != defHash.length; i++) {
    block[i]^=mask[i];
  }
  mask=maskGeneratorFunction1(block,0,defHash.length,block.length - defHash.length);
  for (int i=defHash.length; i != block.length; i++) {
    block[i]^=mask[i - defHash.length];
  }
  boolean defHashWrong=false;
  for (int i=0; i != defHash.length; i++) {
    if (defHash[i] != block[defHash.length + i]) {
      defHashWrong=true;
    }
  }
  if (defHashWrong) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  int start;
  for (start=2 * defHash.length; start != block.length; start++) {
    if (block[start] != 0) {
      break;
    }
  }
  if (start > (block.length - 1) || block[start] != 1) {
    throw new InvalidCipherTextException(""String_Node_Str"" + start);
  }
  start++;
  byte[] output=new byte[block.length - start];
  System.arraycopy(block,start,output,0,output.length);
  return output;
}"
52451,"public void performTest() throws Exception {
  KeyFactory fact;
  byte[] input=new byte[]{(byte)0x54,(byte)0x85,(byte)0x9b,(byte)0x34,(byte)0x2c,(byte)0x49,(byte)0xea,(byte)0x2a};
  byte[][] output=new byte[][]{Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str"")};
  SecureRandom rand=new FixedSecureRandom();
  fact=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
  PrivateKey privKey=fact.generatePrivate(privKeySpec);
  PublicKey pubKey=fact.generatePublic(pubKeySpec);
  PrivateKey priv2048Key=fact.generatePrivate(priv2048KeySpec);
  PublicKey pub2048Key=fact.generatePublic(pub2048KeySpec);
  PrivateKeyInfo keyInfo=PrivateKeyInfo.getInstance(privKey.getEncoded());
  BigInteger zero=BigInteger.valueOf(0);
  PKCS8EncodedKeySpec noCrtSpec=new PKCS8EncodedKeySpec(new PrivateKeyInfo(keyInfo.getPrivateKeyAlgorithm(),new org.bouncycastle.asn1.pkcs.RSAPrivateKey(privKeySpec.getModulus(),privKeySpec.getPublicExponent(),privKeySpec.getPrivateExponent(),zero,zero,zero,zero,zero)).getEncoded());
  PrivateKey noCrtKey=fact.generatePrivate(noCrtSpec);
  if (noCrtKey instanceof RSAPrivateCrtKey) {
    fail(""String_Node_Str"");
  }
  Cipher c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  byte[] out=c.doFinal(input);
  if (!areEqual(out,output[0])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[0])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  c.update(input);
  out=c.doFinal();
  if (!areEqual(out,output[0])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[0])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  c.update(input);
  out=c.doFinal();
  if (!areEqual(out,output[0])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[0])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  byte[] modBytes=((RSAPublicKey)pubKey).getModulus().toByteArray();
  byte[] maxInput=new byte[modBytes.length - 1];
  maxInput[0]|=0x7f;
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(maxInput);
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,maxInput)) {
    fail(""String_Node_Str"" + new String(Hex.encode(maxInput)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[1])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[1])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[1])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[1])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[2])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  AlgorithmParameters oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pub2048Key,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[3])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,priv2048Key);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha224,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha224,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pub2048Key,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[4])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,priv2048Key);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pub2048Key,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[5])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,priv2048Key);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha384,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha384,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[6])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(PKCSObjectIdentifiers.md5,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(PKCSObjectIdentifiers.md5,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,OAEPParameterSpec.DEFAULT,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[2])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new byte[]{0x30,0x00})) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,new OAEPParameterSpec(""String_Node_Str"",""String_Node_Str"",new MGF1ParameterSpec(""String_Node_Str""),new PSource.PSpecified(new byte[]{1,2,3,4,5})),rand);
  out=c.doFinal(input);
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[]{1,2,3,4,5}))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  if (!areEqual(out,output[7])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.DECRYPT_MODE,privKey,oaepP);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  byte[] isoInput=Hex.decode(""String_Node_Str"");
  PrivateKey isoPrivKey=fact.generatePrivate(isoPrivKeySpec);
  PublicKey isoPubKey=fact.generatePublic(isoPubKeySpec);
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,isoPrivKey);
  out=c.doFinal(isoInput);
  if (!areEqual(out,output[8])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[3])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,isoPubKey);
  out=c.doFinal(out);
  if (!areEqual(out,isoInput)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  KeyPairGenerator keyPairGen=KeyPairGenerator.getInstance(""String_Node_Str"",""String_Node_Str"");
  keyPairGen.initialize(new RSAKeyGenParameterSpec(768,BigInteger.valueOf(65537)),new SecureRandom());
  KeyPair kp=keyPairGen.generateKeyPair();
  pubKey=kp.getPublic();
  privKey=kp.getPrivate();
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  KeyFactory keyFact=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
  RSAPrivateCrtKey crtKey=(RSAPrivateCrtKey)keyFact.translateKey(privKey);
  if (!privKey.equals(crtKey)) {
    fail(""String_Node_Str"");
  }
  crtKey=(RSAPrivateCrtKey)keyFact.generatePrivate(new PKCS8EncodedKeySpec(privKey.getEncoded()));
  if (!privKey.equals(crtKey)) {
    fail(""String_Node_Str"");
  }
  crtKey=(RSAPrivateCrtKey)serializeDeserialize(privKey);
  if (!privKey.equals(crtKey)) {
    fail(""String_Node_Str"");
  }
  if (privKey.hashCode() != crtKey.hashCode()) {
    fail(""String_Node_Str"");
  }
  RSAPublicKey copyKey=(RSAPublicKey)keyFact.translateKey(pubKey);
  if (!pubKey.equals(copyKey)) {
    fail(""String_Node_Str"");
  }
  copyKey=(RSAPublicKey)keyFact.generatePublic(new X509EncodedKeySpec(pubKey.getEncoded()));
  if (!pubKey.equals(copyKey)) {
    fail(""String_Node_Str"");
  }
  copyKey=(RSAPublicKey)serializeDeserialize(pubKey);
  if (!pubKey.equals(copyKey)) {
    fail(""String_Node_Str"");
  }
  if (pubKey.hashCode() != copyKey.hashCode()) {
    fail(""String_Node_Str"");
  }
  SubjectPublicKeyInfo oaepKey=new SubjectPublicKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.id_RSAES_OAEP,new RSAESOAEPparams()),SubjectPublicKeyInfo.getInstance(pubKey.getEncoded()).parsePublicKey());
  copyKey=(RSAPublicKey)serializeDeserialize(keyFact.generatePublic(new X509EncodedKeySpec(oaepKey.getEncoded())));
  if (!pubKey.equals(copyKey)) {
    fail(""String_Node_Str"");
  }
  if (pubKey.hashCode() != copyKey.hashCode()) {
    fail(""String_Node_Str"");
  }
  if (!Arrays.areEqual(copyKey.getEncoded(),oaepKey.getEncoded())) {
    fail(""String_Node_Str"");
  }
  oaepCompatibilityTest(""String_Node_Str"",priv2048Key,pub2048Key);
  oaepCompatibilityTest(""String_Node_Str"",priv2048Key,pub2048Key);
  oaepCompatibilityTest(""String_Node_Str"",priv2048Key,pub2048Key);
  oaepCompatibilityTest(""String_Node_Str"",priv2048Key,pub2048Key);
  SecureRandom random=new SecureRandom();
  rawModeTest(""String_Node_Str"",X509ObjectIdentifiers.id_SHA1,priv2048Key,pub2048Key,random);
  rawModeTest(""String_Node_Str"",PKCSObjectIdentifiers.md5,priv2048Key,pub2048Key,random);
  rawModeTest(""String_Node_Str"",TeleTrusTObjectIdentifiers.ripemd128,priv2048Key,pub2048Key,random);
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.update(new byte[40]);
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.update(new byte[40]);
}","public void performTest() throws Exception {
  KeyFactory fact;
  byte[] input=new byte[]{(byte)0x54,(byte)0x85,(byte)0x9b,(byte)0x34,(byte)0x2c,(byte)0x49,(byte)0xea,(byte)0x2a};
  byte[][] output=new byte[][]{Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str""),Hex.decode(""String_Node_Str"")};
  SecureRandom rand=new FixedSecureRandom();
  fact=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
  PrivateKey privKey=fact.generatePrivate(privKeySpec);
  PublicKey pubKey=fact.generatePublic(pubKeySpec);
  PrivateKey priv2048Key=fact.generatePrivate(priv2048KeySpec);
  PublicKey pub2048Key=fact.generatePublic(pub2048KeySpec);
  PrivateKeyInfo keyInfo=PrivateKeyInfo.getInstance(privKey.getEncoded());
  BigInteger zero=BigInteger.valueOf(0);
  PKCS8EncodedKeySpec noCrtSpec=new PKCS8EncodedKeySpec(new PrivateKeyInfo(keyInfo.getPrivateKeyAlgorithm(),new org.bouncycastle.asn1.pkcs.RSAPrivateKey(privKeySpec.getModulus(),privKeySpec.getPublicExponent(),privKeySpec.getPrivateExponent(),zero,zero,zero,zero,zero)).getEncoded());
  PrivateKey noCrtKey=fact.generatePrivate(noCrtSpec);
  if (noCrtKey instanceof RSAPrivateCrtKey) {
    fail(""String_Node_Str"");
  }
  Cipher c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  byte[] out=c.doFinal(input);
  if (!areEqual(out,output[0])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[0])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  c.update(input);
  out=c.doFinal();
  if (!areEqual(out,output[0])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[0])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  c.update(input);
  out=c.doFinal();
  if (!areEqual(out,output[0])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[0])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  byte[] modBytes=((RSAPublicKey)pubKey).getModulus().toByteArray();
  byte[] maxInput=new byte[modBytes.length - 1];
  maxInput[0]|=0x7f;
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(maxInput);
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,maxInput)) {
    fail(""String_Node_Str"" + new String(Hex.encode(maxInput)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[1])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[1])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[1])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[1])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[2])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  AlgorithmParameters oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pub2048Key,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[3])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,priv2048Key);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha224,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha224,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pub2048Key,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[4])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,priv2048Key);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pub2048Key,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[5])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,priv2048Key);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha384,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha384,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[6])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(PKCSObjectIdentifiers.md5,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(PKCSObjectIdentifiers.md5,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[0]))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,OAEPParameterSpec.DEFAULT,rand);
  out=c.doFinal(input);
  if (!areEqual(out,output[2])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new byte[]{0x30,0x00})) {
    fail(""String_Node_Str"");
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,pubKey,new OAEPParameterSpec(""String_Node_Str"",""String_Node_Str"",new MGF1ParameterSpec(""String_Node_Str""),new PSource.PSpecified(new byte[]{1,2,3,4,5})),rand);
  out=c.doFinal(input);
  oaepP=c.getParameters();
  if (!areEqual(oaepP.getEncoded(),new RSAESOAEPparams(new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1,DERNull.INSTANCE),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_mgf1,new AlgorithmIdentifier(OIWObjectIdentifiers.idSHA1,DERNull.INSTANCE)),new AlgorithmIdentifier(PKCSObjectIdentifiers.id_pSpecified,new DEROctetString(new byte[]{1,2,3,4,5}))).getEncoded())) {
    fail(""String_Node_Str"");
  }
  if (!areEqual(out,output[7])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[2])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.DECRYPT_MODE,privKey,oaepP);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  byte[] isoInput=Hex.decode(""String_Node_Str"");
  PrivateKey isoPrivKey=fact.generatePrivate(isoPrivKeySpec);
  PublicKey isoPubKey=fact.generatePublic(isoPubKeySpec);
  c=Cipher.getInstance(""String_Node_Str"",""String_Node_Str"");
  c.init(Cipher.ENCRYPT_MODE,isoPrivKey);
  out=c.doFinal(isoInput);
  if (!areEqual(out,output[8])) {
    fail(""String_Node_Str"" + new String(Hex.encode(output[3])) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  c.init(Cipher.DECRYPT_MODE,isoPubKey);
  out=c.doFinal(out);
  if (!areEqual(out,isoInput)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  KeyPairGenerator keyPairGen=KeyPairGenerator.getInstance(""String_Node_Str"",""String_Node_Str"");
  keyPairGen.initialize(new RSAKeyGenParameterSpec(768,BigInteger.valueOf(65537)),new SecureRandom());
  KeyPair kp=keyPairGen.generateKeyPair();
  pubKey=kp.getPublic();
  privKey=kp.getPrivate();
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.doFinal(input);
  c.init(Cipher.DECRYPT_MODE,privKey);
  out=c.doFinal(out);
  if (!areEqual(out,input)) {
    fail(""String_Node_Str"" + new String(Hex.encode(input)) + ""String_Node_Str""+ new String(Hex.encode(out)));
  }
  KeyFactory keyFact=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
  RSAPrivateCrtKey crtKey=(RSAPrivateCrtKey)keyFact.translateKey(privKey);
  if (!privKey.equals(crtKey)) {
    fail(""String_Node_Str"");
  }
  crtKey=(RSAPrivateCrtKey)keyFact.generatePrivate(new PKCS8EncodedKeySpec(privKey.getEncoded()));
  if (!privKey.equals(crtKey)) {
    fail(""String_Node_Str"");
  }
  crtKey=(RSAPrivateCrtKey)serializeDeserialize(privKey);
  if (!privKey.equals(crtKey)) {
    fail(""String_Node_Str"");
  }
  if (privKey.hashCode() != crtKey.hashCode()) {
    fail(""String_Node_Str"");
  }
  RSAPublicKey copyKey=(RSAPublicKey)keyFact.translateKey(pubKey);
  if (!pubKey.equals(copyKey)) {
    fail(""String_Node_Str"");
  }
  copyKey=(RSAPublicKey)keyFact.generatePublic(new X509EncodedKeySpec(pubKey.getEncoded()));
  if (!pubKey.equals(copyKey)) {
    fail(""String_Node_Str"");
  }
  copyKey=(RSAPublicKey)serializeDeserialize(pubKey);
  if (!pubKey.equals(copyKey)) {
    fail(""String_Node_Str"");
  }
  if (pubKey.hashCode() != copyKey.hashCode()) {
    fail(""String_Node_Str"");
  }
  SubjectPublicKeyInfo oaepKey=new SubjectPublicKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.id_RSAES_OAEP,new RSAESOAEPparams()),SubjectPublicKeyInfo.getInstance(pubKey.getEncoded()).parsePublicKey());
  copyKey=(RSAPublicKey)serializeDeserialize(keyFact.generatePublic(new X509EncodedKeySpec(oaepKey.getEncoded())));
  if (!pubKey.equals(copyKey)) {
    fail(""String_Node_Str"");
  }
  if (pubKey.hashCode() != copyKey.hashCode()) {
    fail(""String_Node_Str"");
  }
  if (!Arrays.areEqual(copyKey.getEncoded(),oaepKey.getEncoded())) {
    fail(""String_Node_Str"");
  }
  oaepCompatibilityTest(""String_Node_Str"",priv2048Key,pub2048Key);
  oaepCompatibilityTest(""String_Node_Str"",priv2048Key,pub2048Key);
  oaepCompatibilityTest(""String_Node_Str"",priv2048Key,pub2048Key);
  oaepCompatibilityTest(""String_Node_Str"",priv2048Key,pub2048Key);
  SecureRandom random=new SecureRandom();
  rawModeTest(""String_Node_Str"",X509ObjectIdentifiers.id_SHA1,priv2048Key,pub2048Key,random);
  rawModeTest(""String_Node_Str"",PKCSObjectIdentifiers.md5,priv2048Key,pub2048Key,random);
  rawModeTest(""String_Node_Str"",TeleTrusTObjectIdentifiers.ripemd128,priv2048Key,pub2048Key,random);
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.update(new byte[40]);
  c.init(Cipher.ENCRYPT_MODE,pubKey,rand);
  out=c.update(new byte[40]);
  zeroMessageTest();
}"
52452,"int hash_2n_n_mask(byte[] out,int outOff,byte[] in,int inOff,byte[] mask,int maskOff){
  byte[] buf=new byte[2 * Sphincs256Config.HASH_BYTES];
  int i;
  for (i=0; i < 2 * Sphincs256Config.HASH_BYTES; i++) {
    buf[i]=(byte)(in[inOff + i] ^ mask[maskOff + i]);
  }
  int rv=hash_2n_n(out,outOff,buf,0);
  return rv;
}","int hash_2n_n_mask(byte[] out,int outOff,byte[] in,int inOff,byte[] mask,int maskOff){
  byte[] buf=new byte[2 * SPHINCS256Config.HASH_BYTES];
  int i;
  for (i=0; i < 2 * SPHINCS256Config.HASH_BYTES; i++) {
    buf[i]=(byte)(in[inOff + i] ^ mask[maskOff + i]);
  }
  int rv=hash_2n_n(out,outOff,buf,0);
  return rv;
}"
52453,"int hash_n_n_mask(byte[] out,int outOff,byte[] in,int inOff,byte[] mask,int maskOff){
  byte[] buf=new byte[Sphincs256Config.HASH_BYTES];
  int i;
  for (i=0; i < Sphincs256Config.HASH_BYTES; i++) {
    buf[i]=(byte)(in[inOff + i] ^ mask[maskOff + i]);
  }
  return hash_n_n(out,outOff,buf,0);
}","int hash_n_n_mask(byte[] out,int outOff,byte[] in,int inOff,byte[] mask,int maskOff){
  byte[] buf=new byte[SPHINCS256Config.HASH_BYTES];
  int i;
  for (i=0; i < SPHINCS256Config.HASH_BYTES; i++) {
    buf[i]=(byte)(in[inOff + i] ^ mask[maskOff + i]);
  }
  return hash_n_n(out,outOff,buf,0);
}"
52454,"static int horst_verify(HashFunctions hs,byte[] pk,byte[] sig,int sigOff,byte[] masks,byte[] m_hash){
  byte[] buffer=new byte[32 * Sphincs256Config.HASH_BYTES];
  int idx;
  int i, j, k;
  int sigOffset=sigOff + 64 * Sphincs256Config.HASH_BYTES;
  for (i=0; i < HORST_K; i++) {
    idx=(m_hash[2 * i] & 0xff) + ((m_hash[2 * i + 1] & 0xff) << 8);
    if ((idx & 1) == 0) {
      hs.hash_n_n(buffer,0,sig,sigOffset);
      for (k=0; k < Sphincs256Config.HASH_BYTES; k++)       buffer[Sphincs256Config.HASH_BYTES + k]=sig[sigOffset + HORST_SKBYTES + k];
    }
 else {
      hs.hash_n_n(buffer,Sphincs256Config.HASH_BYTES,sig,sigOffset);
      for (k=0; k < Sphincs256Config.HASH_BYTES; k++)       buffer[k]=sig[sigOffset + HORST_SKBYTES + k];
    }
    sigOffset+=HORST_SKBYTES + Sphincs256Config.HASH_BYTES;
    for (j=1; j < HORST_LOGT - 6; j++) {
      idx=idx >>> 1;
      if ((idx & 1) == 0) {
        hs.hash_2n_n_mask(buffer,0,buffer,0,masks,2 * (j - 1) * Sphincs256Config.HASH_BYTES);
        for (k=0; k < Sphincs256Config.HASH_BYTES; k++)         buffer[Sphincs256Config.HASH_BYTES + k]=sig[sigOffset + k];
      }
 else {
        hs.hash_2n_n_mask(buffer,Sphincs256Config.HASH_BYTES,buffer,0,masks,2 * (j - 1) * Sphincs256Config.HASH_BYTES);
        for (k=0; k < Sphincs256Config.HASH_BYTES; k++)         buffer[k]=sig[sigOffset + k];
      }
      sigOffset+=Sphincs256Config.HASH_BYTES;
    }
    idx=idx >>> 1;
    hs.hash_2n_n_mask(buffer,0,buffer,0,masks,2 * (HORST_LOGT - 7) * Sphincs256Config.HASH_BYTES);
    for (k=0; k < Sphincs256Config.HASH_BYTES; k++)     if (sig[sigOff + idx * Sphincs256Config.HASH_BYTES + k] != buffer[k]) {
      for (k=0; k < Sphincs256Config.HASH_BYTES; k++)       pk[k]=0;
      return -1;
    }
  }
  for (j=0; j < 32; j++)   hs.hash_2n_n_mask(buffer,j * Sphincs256Config.HASH_BYTES,sig,sigOff + 2 * j * Sphincs256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 6) * Sphincs256Config.HASH_BYTES);
  for (j=0; j < 16; j++)   hs.hash_2n_n_mask(buffer,j * Sphincs256Config.HASH_BYTES,buffer,2 * j * Sphincs256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 5) * Sphincs256Config.HASH_BYTES);
  for (j=0; j < 8; j++)   hs.hash_2n_n_mask(buffer,j * Sphincs256Config.HASH_BYTES,buffer,2 * j * Sphincs256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 4) * Sphincs256Config.HASH_BYTES);
  for (j=0; j < 4; j++)   hs.hash_2n_n_mask(buffer,j * Sphincs256Config.HASH_BYTES,buffer,2 * j * Sphincs256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 3) * Sphincs256Config.HASH_BYTES);
  for (j=0; j < 2; j++)   hs.hash_2n_n_mask(buffer,j * Sphincs256Config.HASH_BYTES,buffer,2 * j * Sphincs256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 2) * Sphincs256Config.HASH_BYTES);
  hs.hash_2n_n_mask(pk,0,buffer,0,masks,2 * (HORST_LOGT - 1) * Sphincs256Config.HASH_BYTES);
  return 0;
}","static int horst_verify(HashFunctions hs,byte[] pk,byte[] sig,int sigOff,byte[] masks,byte[] m_hash){
  byte[] buffer=new byte[32 * SPHINCS256Config.HASH_BYTES];
  int idx;
  int i, j, k;
  int sigOffset=sigOff + 64 * SPHINCS256Config.HASH_BYTES;
  for (i=0; i < HORST_K; i++) {
    idx=(m_hash[2 * i] & 0xff) + ((m_hash[2 * i + 1] & 0xff) << 8);
    if ((idx & 1) == 0) {
      hs.hash_n_n(buffer,0,sig,sigOffset);
      for (k=0; k < SPHINCS256Config.HASH_BYTES; k++)       buffer[SPHINCS256Config.HASH_BYTES + k]=sig[sigOffset + HORST_SKBYTES + k];
    }
 else {
      hs.hash_n_n(buffer,SPHINCS256Config.HASH_BYTES,sig,sigOffset);
      for (k=0; k < SPHINCS256Config.HASH_BYTES; k++)       buffer[k]=sig[sigOffset + HORST_SKBYTES + k];
    }
    sigOffset+=HORST_SKBYTES + SPHINCS256Config.HASH_BYTES;
    for (j=1; j < HORST_LOGT - 6; j++) {
      idx=idx >>> 1;
      if ((idx & 1) == 0) {
        hs.hash_2n_n_mask(buffer,0,buffer,0,masks,2 * (j - 1) * SPHINCS256Config.HASH_BYTES);
        for (k=0; k < SPHINCS256Config.HASH_BYTES; k++)         buffer[SPHINCS256Config.HASH_BYTES + k]=sig[sigOffset + k];
      }
 else {
        hs.hash_2n_n_mask(buffer,SPHINCS256Config.HASH_BYTES,buffer,0,masks,2 * (j - 1) * SPHINCS256Config.HASH_BYTES);
        for (k=0; k < SPHINCS256Config.HASH_BYTES; k++)         buffer[k]=sig[sigOffset + k];
      }
      sigOffset+=SPHINCS256Config.HASH_BYTES;
    }
    idx=idx >>> 1;
    hs.hash_2n_n_mask(buffer,0,buffer,0,masks,2 * (HORST_LOGT - 7) * SPHINCS256Config.HASH_BYTES);
    for (k=0; k < SPHINCS256Config.HASH_BYTES; k++)     if (sig[sigOff + idx * SPHINCS256Config.HASH_BYTES + k] != buffer[k]) {
      for (k=0; k < SPHINCS256Config.HASH_BYTES; k++)       pk[k]=0;
      return -1;
    }
  }
  for (j=0; j < 32; j++)   hs.hash_2n_n_mask(buffer,j * SPHINCS256Config.HASH_BYTES,sig,sigOff + 2 * j * SPHINCS256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 6) * SPHINCS256Config.HASH_BYTES);
  for (j=0; j < 16; j++)   hs.hash_2n_n_mask(buffer,j * SPHINCS256Config.HASH_BYTES,buffer,2 * j * SPHINCS256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 5) * SPHINCS256Config.HASH_BYTES);
  for (j=0; j < 8; j++)   hs.hash_2n_n_mask(buffer,j * SPHINCS256Config.HASH_BYTES,buffer,2 * j * SPHINCS256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 4) * SPHINCS256Config.HASH_BYTES);
  for (j=0; j < 4; j++)   hs.hash_2n_n_mask(buffer,j * SPHINCS256Config.HASH_BYTES,buffer,2 * j * SPHINCS256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 3) * SPHINCS256Config.HASH_BYTES);
  for (j=0; j < 2; j++)   hs.hash_2n_n_mask(buffer,j * SPHINCS256Config.HASH_BYTES,buffer,2 * j * SPHINCS256Config.HASH_BYTES,masks,2 * (HORST_LOGT - 2) * SPHINCS256Config.HASH_BYTES);
  hs.hash_2n_n_mask(pk,0,buffer,0,masks,2 * (HORST_LOGT - 1) * SPHINCS256Config.HASH_BYTES);
  return 0;
}"
52455,"static int horst_sign(HashFunctions hs,byte[] sig,int sigOff,byte[] pk,long[] sigbytes,byte[] seed,byte[] masks,byte[] m_hash){
  byte[] sk=new byte[HORST_T * HORST_SKBYTES];
  int idx;
  int i, j, k;
  int sigpos=sigOff;
  byte[] tree=new byte[(2 * HORST_T - 1) * Sphincs256Config.HASH_BYTES];
  expand_seed(sk,seed);
  for (i=0; i < HORST_T; i++)   hs.hash_n_n(tree,(HORST_T - 1 + i) * Sphincs256Config.HASH_BYTES,sk,i * HORST_SKBYTES);
  long offset_in, offset_out;
  for (i=0; i < HORST_LOGT; i++) {
    offset_in=(1 << (HORST_LOGT - i)) - 1;
    offset_out=(1 << (HORST_LOGT - i - 1)) - 1;
    for (j=0; j < (1 << (HORST_LOGT - i - 1)); j++)     hs.hash_2n_n_mask(tree,(int)((offset_out + j) * Sphincs256Config.HASH_BYTES),tree,(int)((offset_in + 2 * j) * Sphincs256Config.HASH_BYTES),masks,2 * i * Sphincs256Config.HASH_BYTES);
  }
  for (j=63 * Sphincs256Config.HASH_BYTES; j < 127 * Sphincs256Config.HASH_BYTES; j++)   sig[sigpos++]=tree[j];
  for (i=0; i < HORST_K; i++) {
    idx=(m_hash[2 * i] & 0xff) + ((m_hash[2 * i + 1] & 0xff) << 8);
    for (k=0; k < HORST_SKBYTES; k++)     sig[sigpos++]=sk[idx * HORST_SKBYTES + k];
    idx+=(HORST_T - 1);
    for (j=0; j < HORST_LOGT - 6; j++) {
      idx=((idx & 1) != 0) ? idx + 1 : idx - 1;
      for (k=0; k < Sphincs256Config.HASH_BYTES; k++)       sig[sigpos++]=tree[idx * Sphincs256Config.HASH_BYTES + k];
      idx=(idx - 1) / 2;
    }
  }
  for (i=0; i < Sphincs256Config.HASH_BYTES; i++)   pk[i]=tree[i];
  sigbytes[0]=HORST_SIGBYTES;
  return 0;
}","static int horst_sign(HashFunctions hs,byte[] sig,int sigOff,byte[] pk,long[] sigbytes,byte[] seed,byte[] masks,byte[] m_hash){
  byte[] sk=new byte[HORST_T * HORST_SKBYTES];
  int idx;
  int i, j, k;
  int sigpos=sigOff;
  byte[] tree=new byte[(2 * HORST_T - 1) * SPHINCS256Config.HASH_BYTES];
  expand_seed(sk,seed);
  for (i=0; i < HORST_T; i++)   hs.hash_n_n(tree,(HORST_T - 1 + i) * SPHINCS256Config.HASH_BYTES,sk,i * HORST_SKBYTES);
  long offset_in, offset_out;
  for (i=0; i < HORST_LOGT; i++) {
    offset_in=(1 << (HORST_LOGT - i)) - 1;
    offset_out=(1 << (HORST_LOGT - i - 1)) - 1;
    for (j=0; j < (1 << (HORST_LOGT - i - 1)); j++)     hs.hash_2n_n_mask(tree,(int)((offset_out + j) * SPHINCS256Config.HASH_BYTES),tree,(int)((offset_in + 2 * j) * SPHINCS256Config.HASH_BYTES),masks,2 * i * SPHINCS256Config.HASH_BYTES);
  }
  for (j=63 * SPHINCS256Config.HASH_BYTES; j < 127 * SPHINCS256Config.HASH_BYTES; j++)   sig[sigpos++]=tree[j];
  for (i=0; i < HORST_K; i++) {
    idx=(m_hash[2 * i] & 0xff) + ((m_hash[2 * i + 1] & 0xff) << 8);
    for (k=0; k < HORST_SKBYTES; k++)     sig[sigpos++]=sk[idx * HORST_SKBYTES + k];
    idx+=(HORST_T - 1);
    for (j=0; j < HORST_LOGT - 6; j++) {
      idx=((idx & 1) != 0) ? idx + 1 : idx - 1;
      for (k=0; k < SPHINCS256Config.HASH_BYTES; k++)       sig[sigpos++]=tree[idx * SPHINCS256Config.HASH_BYTES + k];
      idx=(idx - 1) / 2;
    }
  }
  for (i=0; i < SPHINCS256Config.HASH_BYTES; i++)   pk[i]=tree[i];
  sigbytes[0]=HORST_SIGBYTES;
  return 0;
}"
52456,"/** 
 * Validate the timestamp request, checking the digest to see if it is of an accepted type and whether it is of the correct length for the algorithm specified.
 * @param algorithms a set of OIDs giving accepted algorithms.
 * @param policies if non-null a set of policies OIDs we are willing to sign under.
 * @param extensions if non-null a set of extensions OIDs we are willing to accept.
 * @throws TSPException if the request is invalid, or processing fails.
 */
public void validate(Set algorithms,Set policies,Set extensions) throws TSPException {
  algorithms=convert(algorithms);
  policies=convert(policies);
  extensions=convert(extensions);
  if (!algorithms.contains(this.getMessageImprintAlgOID())) {
    throw new TSPValidationException(""String_Node_Str"",PKIFailureInfo.badAlg);
  }
  if (policies != null && this.getReqPolicy() != null && !policies.contains(this.getReqPolicy())) {
    throw new TSPValidationException(""String_Node_Str"",PKIFailureInfo.unacceptedPolicy);
  }
  if (this.getExtensions() != null && extensions != null) {
    Enumeration en=this.getExtensions().oids();
    while (en.hasMoreElements()) {
      String oid=((ASN1ObjectIdentifier)en.nextElement()).getId();
      if (!extensions.contains(oid)) {
        throw new TSPValidationException(""String_Node_Str"",PKIFailureInfo.unacceptedExtension);
      }
    }
  }
  int digestLength=TSPUtil.getDigestLength(this.getMessageImprintAlgOID().getId());
  if (digestLength != this.getMessageImprintDigest().length) {
    throw new TSPValidationException(""String_Node_Str"",PKIFailureInfo.badDataFormat);
  }
}","/** 
 * Validate the timestamp request, checking the digest to see if it is of an accepted type and whether it is of the correct length for the algorithm specified.
 * @param algorithms a set of OIDs giving accepted algorithms.
 * @param policies if non-null a set of policies OIDs we are willing to sign under.
 * @param extensions if non-null a set of extensions OIDs we are willing to accept.
 * @throws TSPException if the request is invalid, or processing fails.
 */
public void validate(Set algorithms,Set policies,Set extensions) throws TSPException {
  algorithms=convert(algorithms);
  policies=convert(policies);
  extensions=convert(extensions);
  if (!algorithms.contains(this.getMessageImprintAlgOID())) {
    throw new TSPValidationException(""String_Node_Str"",PKIFailureInfo.badAlg);
  }
  if (policies != null && this.getReqPolicy() != null && !policies.contains(this.getReqPolicy())) {
    throw new TSPValidationException(""String_Node_Str"",PKIFailureInfo.unacceptedPolicy);
  }
  if (this.getExtensions() != null && extensions != null) {
    Enumeration en=this.getExtensions().oids();
    while (en.hasMoreElements()) {
      ASN1ObjectIdentifier oid=(ASN1ObjectIdentifier)en.nextElement();
      if (!extensions.contains(oid)) {
        throw new TSPValidationException(""String_Node_Str"",PKIFailureInfo.unacceptedExtension);
      }
    }
  }
  int digestLength=TSPUtil.getDigestLength(this.getMessageImprintAlgOID().getId());
  if (digestLength != this.getMessageImprintDigest().length) {
    throw new TSPValidationException(""String_Node_Str"",PKIFailureInfo.badDataFormat);
  }
}"
52457,"/** 
 * Base constructor.
 * @param data the octets making up the bit string.
 * @param padBits the number of extra bits at the end of the string.
 */
public ASN1BitString(byte[] data,int padBits){
  this.data=Arrays.clone(data);
  this.padBits=padBits;
}","/** 
 * Base constructor.
 * @param data the octets making up the bit string.
 * @param padBits the number of extra bits at the end of the string.
 */
public ASN1BitString(byte[] data,int padBits){
  if (data.length == 0 && padBits != 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (padBits > 7) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.data=Arrays.clone(data);
  this.padBits=padBits;
}"
52458,"public void performTest() throws Exception {
  KeyUsage k=new KeyUsage(KeyUsage.digitalSignature);
  if ((k.getBytes()[0] != (byte)KeyUsage.digitalSignature) || (k.getPadBits() != 7)) {
    fail(""String_Node_Str"");
  }
  k=new KeyUsage(KeyUsage.nonRepudiation);
  if ((k.getBytes()[0] != (byte)KeyUsage.nonRepudiation) || (k.getPadBits() != 6)) {
    fail(""String_Node_Str"");
  }
  k=new KeyUsage(KeyUsage.keyEncipherment);
  if ((k.getBytes()[0] != (byte)KeyUsage.keyEncipherment) || (k.getPadBits() != 5)) {
    fail(""String_Node_Str"");
  }
  k=new KeyUsage(KeyUsage.cRLSign);
  if ((k.getBytes()[0] != (byte)KeyUsage.cRLSign) || (k.getPadBits() != 1)) {
    fail(""String_Node_Str"");
  }
  k=new KeyUsage(KeyUsage.decipherOnly);
  if ((k.getBytes()[1] != (byte)(KeyUsage.decipherOnly >> 8)) || (k.getPadBits() != 7)) {
    fail(""String_Node_Str"");
  }
  try {
    ASN1Primitive.fromByteArray(new DERBitString(new byte[0],0).getEncoded());
  }
 catch (  IOException e) {
    fail(e.toString());
  }
  testRandomPadBits();
}","public void performTest() throws Exception {
  KeyUsage k=new KeyUsage(KeyUsage.digitalSignature);
  if ((k.getBytes()[0] != (byte)KeyUsage.digitalSignature) || (k.getPadBits() != 7)) {
    fail(""String_Node_Str"");
  }
  k=new KeyUsage(KeyUsage.nonRepudiation);
  if ((k.getBytes()[0] != (byte)KeyUsage.nonRepudiation) || (k.getPadBits() != 6)) {
    fail(""String_Node_Str"");
  }
  k=new KeyUsage(KeyUsage.keyEncipherment);
  if ((k.getBytes()[0] != (byte)KeyUsage.keyEncipherment) || (k.getPadBits() != 5)) {
    fail(""String_Node_Str"");
  }
  k=new KeyUsage(KeyUsage.cRLSign);
  if ((k.getBytes()[0] != (byte)KeyUsage.cRLSign) || (k.getPadBits() != 1)) {
    fail(""String_Node_Str"");
  }
  k=new KeyUsage(KeyUsage.decipherOnly);
  if ((k.getBytes()[1] != (byte)(KeyUsage.decipherOnly >> 8)) || (k.getPadBits() != 7)) {
    fail(""String_Node_Str"");
  }
  try {
    ASN1Primitive.fromByteArray(new DERBitString(new byte[0],0).getEncoded());
  }
 catch (  IOException e) {
    fail(e.toString());
  }
  testRandomPadBits();
  testZeroLengthStrings();
}"
52459,"@Override public int read(byte[] b,int off,int len){
  int bytesToRead=Math.min(buffer.available(),len);
  buffer.removeData(b,off,bytesToRead,0);
  return bytesToRead;
}","public int read(byte[] b,int off,int len){
  int bytesToRead=Math.min(buffer.available(),len);
  buffer.removeData(b,off,bytesToRead,0);
  return bytesToRead;
}"
52460,"@Override public int available(){
  return buffer.available();
}","public int available(){
  return buffer.available();
}"
52461,"@Override public long skip(long n){
  int bytesToRemove=Math.min((int)n,buffer.available());
  buffer.removeData(bytesToRemove);
  return bytesToRemove;
}","public long skip(long n){
  int bytesToRemove=Math.min((int)n,buffer.available());
  buffer.removeData(bytesToRemove);
  return bytesToRemove;
}"
52462,"@Override public void close(){
}","public void close(){
}"
52463,"@Override public void write(byte[] b,int off,int len) throws IOException {
  buffer.addData(b,off,len);
}","public void write(byte[] b,int off,int len) throws IOException {
  buffer.addData(b,off,len);
}"
52464,"@Test public void testSkip(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  assertEquals(0,in.skip(10));
  in.addBytes(new byte[2]);
  assertEquals(2,in.skip(2));
  assertEquals(0,in.available());
  in.addBytes(new byte[10]);
  assertEquals(5,in.skip(5));
  assertEquals(5,in.available());
  assertEquals(5,in.skip(20));
  assertEquals(0,in.available());
  in.close();
}","public void testSkip(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  assertEquals(0,in.skip(10));
  in.addBytes(new byte[2]);
  assertEquals(2,in.skip(2));
  assertEquals(0,in.available());
  in.addBytes(new byte[10]);
  assertEquals(5,in.skip(5));
  assertEquals(5,in.available());
  assertEquals(5,in.skip(20));
  assertEquals(0,in.available());
  in.close();
}"
52465,"@Test public void testReadArray(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  in.addBytes(new byte[]{0x01,0x02,0x03,0x04,0x05,0x06});
  byte[] buffer=new byte[5];
  assertEquals(1,in.read(buffer,2,1));
  assertArrayEquals(new byte[]{0x00,0x00,0x01,0x00,0x00},buffer);
  assertEquals(5,in.read(buffer));
  assertArrayEquals(new byte[]{0x02,0x03,0x04,0x05,0x06},buffer);
  in.addBytes(new byte[]{0x01,0x02,0x03});
  assertEquals(3,in.read(buffer));
  assertArrayEquals(new byte[]{0x01,0x02,0x03,0x05,0x06},buffer);
  in.close();
}","public void testReadArray(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  in.addBytes(new byte[]{0x01,0x02,0x03,0x04,0x05,0x06});
  byte[] buffer=new byte[5];
  assertEquals(1,in.read(buffer,2,1));
  assertArrayEquals(new byte[]{0x00,0x00,0x01,0x00,0x00},buffer);
  assertEquals(5,in.read(buffer));
  assertArrayEquals(new byte[]{0x02,0x03,0x04,0x05,0x06},buffer);
  in.addBytes(new byte[]{0x01,0x02,0x03});
  assertEquals(3,in.read(buffer));
  assertArrayEquals(new byte[]{0x01,0x02,0x03,0x05,0x06},buffer);
  in.close();
}"
52466,"@Test public void testAvailable(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  assertEquals(0,in.available());
  in.addBytes(new byte[10]);
  assertEquals(10,in.available());
  in.addBytes(new byte[5]);
  assertEquals(15,in.available());
  in.read();
  assertEquals(14,in.available());
  in.read(new byte[4]);
  assertEquals(10,in.available());
  in.close();
}","public void testAvailable(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  assertEquals(0,in.available());
  in.addBytes(new byte[10]);
  assertEquals(10,in.available());
  in.addBytes(new byte[5]);
  assertEquals(15,in.available());
  in.read();
  assertEquals(14,in.available());
  in.read(new byte[4]);
  assertEquals(10,in.available());
  in.close();
}"
52467,"@Test public void testRead(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  in.addBytes(new byte[]{0x01,0x02});
  in.addBytes(new byte[]{0x03});
  assertEquals(0x01,in.read());
  assertEquals(0x02,in.read());
  assertEquals(0x03,in.read());
  assertEquals(-1,in.read());
  in.close();
}","public void testRead(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  in.addBytes(new byte[]{0x01,0x02});
  in.addBytes(new byte[]{0x03});
  assertEquals(0x01,in.read());
  assertEquals(0x02,in.read());
  assertEquals(0x03,in.read());
  assertEquals(-1,in.read());
  in.close();
}"
52468,"@Test public void testPeek(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  byte[] buffer=new byte[5];
  assertEquals(0,in.peek(buffer));
  assertArrayEquals(new byte[]{0x00,0x00,0x00,0x00,0x00},buffer);
  in.addBytes(new byte[]{0x01,0x02,0x03,0x04,0x05,0x06});
  assertEquals(5,in.peek(buffer));
  assertArrayEquals(new byte[]{0x01,0x02,0x03,0x04,0x05},buffer);
  assertEquals(6,in.available());
  in.read();
  assertEquals(5,in.peek(buffer));
  assertArrayEquals(new byte[]{0x02,0x03,0x04,0x05,0x06},buffer);
  assertEquals(5,in.available());
  in.close();
}","public void testPeek(){
  ByteQueueInputStream in=new ByteQueueInputStream();
  byte[] buffer=new byte[5];
  assertEquals(0,in.peek(buffer));
  assertArrayEquals(new byte[]{0x00,0x00,0x00,0x00,0x00},buffer);
  in.addBytes(new byte[]{0x01,0x02,0x03,0x04,0x05,0x06});
  assertEquals(5,in.peek(buffer));
  assertArrayEquals(new byte[]{0x01,0x02,0x03,0x04,0x05},buffer);
  assertEquals(6,in.available());
  in.read();
  assertEquals(5,in.peek(buffer));
  assertArrayEquals(new byte[]{0x02,0x03,0x04,0x05,0x06},buffer);
  assertEquals(5,in.available());
  in.close();
}"
52469,"/** 
 * close the digest, producing the final digest value. The doFinal call leaves the digest reset. Key, salt and personal string remain. 
 * @param out the array the digest is to be copied into.
 * @param outOffset the offset into the out array the digest is to start at.
 */
public int doFinal(byte[] out,int outOffset){
  f0=0xFFFFFFFFFFFFFFFFL;
  t0+=bufferPos;
  if ((t0 < 0) && (bufferPos > -t0)) {
    t1++;
  }
  compress(buffer,0);
  Arrays.fill(buffer,(byte)0);
  Arrays.fill(internalState,0L);
  for (int i=outOffset; i < chainValue.length; i++) {
    System.arraycopy(long2bytes(chainValue[i]),0,out,i * 8,8);
  }
  Arrays.fill(chainValue,0L);
  reset();
  return digestLength;
}","/** 
 * close the digest, producing the final digest value. The doFinal call leaves the digest reset. Key, salt and personal string remain. 
 * @param out the array the digest is to be copied into.
 * @param outOffset the offset into the out array the digest is to start at.
 */
public int doFinal(byte[] out,int outOffset){
  f0=0xFFFFFFFFFFFFFFFFL;
  t0+=bufferPos;
  if ((t0 < 0) && (bufferPos > -t0)) {
    t1++;
  }
  compress(buffer,0);
  Arrays.fill(buffer,(byte)0);
  Arrays.fill(internalState,0L);
  for (int i=0; i < chainValue.length; i++) {
    System.arraycopy(long2bytes(chainValue[i]),0,out,outOffset + i * 8,8);
  }
  Arrays.fill(chainValue,0L);
  reset();
  return digestLength;
}"
52470,"public void performTest() throws Exception {
  Blake2bDigest blake2bkeyed=new Blake2bDigest(Hex.decode(keyedTestVectors[0][1]));
  for (int tv=0; tv < keyedTestVectors.length; tv++) {
    byte[] input=Hex.decode(keyedTestVectors[tv][0]);
    blake2bkeyed.reset();
    blake2bkeyed.update(input,0,input.length);
    byte[] keyedHash=new byte[64];
    blake2bkeyed.doFinal(keyedHash,0);
    if (!Arrays.areEqual(Hex.decode(keyedTestVectors[tv][2]),keyedHash)) {
      fail(""String_Node_Str"",keyedTestVectors[tv][2],new String(Hex.encode(keyedHash)));
    }
  }
  Blake2bDigest blake2bunkeyed=new Blake2bDigest();
  for (int i=0; i < unkeyedTestVectors.length; i++) {
    try {
      byte[] unkeyedInput=unkeyedTestVectors[i][1].getBytes(""String_Node_Str"");
      for (int j=0; j < unkeyedInput.length; j++) {
        blake2bunkeyed.update(unkeyedInput[j]);
      }
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
    byte[] unkeyedHash=new byte[64];
    blake2bunkeyed.doFinal(unkeyedHash,0);
    blake2bunkeyed.reset();
    if (!Arrays.areEqual(Hex.decode(unkeyedTestVectors[i][0]),unkeyedHash)) {
      fail(""String_Node_Str"",unkeyedTestVectors[i][0],new String(Hex.encode(unkeyedHash)));
    }
  }
}","public void performTest() throws Exception {
  Blake2bDigest blake2bkeyed=new Blake2bDigest(Hex.decode(keyedTestVectors[0][1]));
  for (int tv=0; tv < keyedTestVectors.length; tv++) {
    byte[] input=Hex.decode(keyedTestVectors[tv][0]);
    blake2bkeyed.reset();
    blake2bkeyed.update(input,0,input.length);
    byte[] keyedHash=new byte[64];
    blake2bkeyed.doFinal(keyedHash,0);
    if (!Arrays.areEqual(Hex.decode(keyedTestVectors[tv][2]),keyedHash)) {
      fail(""String_Node_Str"",keyedTestVectors[tv][2],new String(Hex.encode(keyedHash)));
    }
    offsetTest(blake2bkeyed,input,keyedHash);
  }
  Blake2bDigest blake2bunkeyed=new Blake2bDigest();
  for (int i=0; i < unkeyedTestVectors.length; i++) {
    try {
      byte[] unkeyedInput=unkeyedTestVectors[i][1].getBytes(""String_Node_Str"");
      for (int j=0; j < unkeyedInput.length; j++) {
        blake2bunkeyed.update(unkeyedInput[j]);
      }
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
    byte[] unkeyedHash=new byte[64];
    blake2bunkeyed.doFinal(unkeyedHash,0);
    blake2bunkeyed.reset();
    if (!Arrays.areEqual(Hex.decode(unkeyedTestVectors[i][0]),unkeyedHash)) {
      fail(""String_Node_Str"",unkeyedTestVectors[i][0],new String(Hex.encode(unkeyedHash)));
    }
  }
}"
52471,"public void performTest(){
  byte[] resBuf=new byte[digest.getDigestSize()];
  for (int i=0; i < input.length - 1; i++) {
    byte[] m=toByteArray(input[i]);
    vectorTest(digest,i,resBuf,m,Hex.decode(results[i]));
  }
  byte[] lastV=toByteArray(input[input.length - 1]);
  byte[] lastDigest=Hex.decode(results[input.length - 1]);
  vectorTest(digest,input.length - 1,resBuf,lastV,Hex.decode(results[input.length - 1]));
  testClone(resBuf,lastV,lastDigest);
  testMemo(resBuf,lastV,lastDigest);
  if (digest instanceof EncodableDigest) {
    testEncodedState(resBuf,lastV,lastDigest);
  }
}","public void performTest(){
  byte[] resBuf=new byte[digest.getDigestSize()];
  for (int i=0; i < input.length - 1; i++) {
    byte[] m=toByteArray(input[i]);
    vectorTest(digest,i,resBuf,m,Hex.decode(results[i]));
  }
  offsetTest(digest,0,toByteArray(input[0]),Hex.decode(results[0]));
  byte[] lastV=toByteArray(input[input.length - 1]);
  byte[] lastDigest=Hex.decode(results[input.length - 1]);
  vectorTest(digest,input.length - 1,resBuf,lastV,Hex.decode(results[input.length - 1]));
  testClone(resBuf,lastV,lastDigest);
  testMemo(resBuf,lastV,lastDigest);
  if (digest instanceof EncodableDigest) {
    testEncodedState(resBuf,lastV,lastDigest);
  }
}"
52472,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _reciDN2=""String_Node_Str"";
    _reciKP2=CMSTestUtil.makeKeyPair();
    _reciCert2=CMSTestUtil.makeCertificate(_reciKP2,_reciDN2,_signKP,_signDN);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    if (Security.getProvider(""String_Node_Str"") == null) {
      Security.addProvider(new BouncyCastleProvider());
    }
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _reciDN2=""String_Node_Str"";
    _reciKP2=CMSTestUtil.makeKeyPair();
    _reciCert2=CMSTestUtil.makeCertificate(_reciKP2,_reciDN2,_signKP,_signDN);
  }
}"
52473,"public void testSignAttachmentOnly() throws Exception {
  MimeMessage m=loadMessage(""String_Node_Str"");
  List certList=new ArrayList();
  certList.add(_signCert);
  certList.add(_origCert);
  Store certs=new JcaCertStore(certList);
  ASN1EncodableVector signedAttrs=generateSignedAttributes();
  SMIMESignedGenerator gen=new SMIMESignedGenerator(""String_Node_Str"");
  gen.addSignerInfoGenerator(new JcaSimpleSignerInfoGeneratorBuilder().setProvider(BC).setSignedAttributeGenerator(new AttributeTable(signedAttrs)).build(""String_Node_Str"",_signKP.getPrivate(),_signCert));
  gen.addCertificates(certs);
  MimeMultipart mm=gen.generate(m);
  SMIMESigned s=new SMIMESigned(mm);
  verifySigners(s.getCertificates(),s.getSignerInfos());
  SMIMESignedParser sp=new SMIMESignedParser(new JcaDigestCalculatorProviderBuilder().setProvider(BC).build(),mm);
  verifySigners(sp.getCertificates(),sp.getSignerInfos());
}","public void testSignAttachmentOnly() throws Exception {
  MimeMessage m=loadMessage(""String_Node_Str"");
  List certList=new ArrayList();
  certList.add(_signCert);
  certList.add(_origCert);
  Store certs=new JcaCertStore(certList);
  ASN1EncodableVector signedAttrs=generateSignedAttributes();
  SMIMESignedGenerator gen=new SMIMESignedGenerator(""String_Node_Str"");
  gen.addSignerInfoGenerator(new JcaSimpleSignerInfoGeneratorBuilder().setProvider(BC).setSignedAttributeGenerator(new AttributeTable(signedAttrs)).build(""String_Node_Str"",_signKP.getPrivate(),_signCert));
  gen.addCertificates(certs);
  m.writeTo(System.err);
  MimeMultipart mm=gen.generate(m);
  mm.writeTo(System.err);
  SMIMESigned s=new SMIMESigned(mm);
  verifySigners(s.getCertificates(),s.getSignerInfos());
  SMIMESignedParser sp=new SMIMESignedParser(new JcaDigestCalculatorProviderBuilder().setProvider(BC).build(),mm);
  verifySigners(sp.getCertificates(),sp.getSignerInfos());
}"
52474,"/** 
 * Write out the contents of the provided file as a literal data packet in partial packet format.
 * @param out the stream to write the literal data to.
 * @param fileType the {@link PGPLiteralData} type to use for the file data.
 * @param file the file to write the contents of.
 * @param buffer buffer to be used to chunk the file into partial packets.
 * @see {@link PGPLiteralDataGenerator#open(OutputStream,char,String,Date,byte[])}.
 * @throws IOException if an error occurs reading the file or writing to the output stream.
 */
public static void writeFileToLiteralData(OutputStream out,char fileType,File file,byte[] buffer) throws IOException {
  PGPLiteralDataGenerator lData=new PGPLiteralDataGenerator();
  OutputStream pOut=lData.open(out,fileType,file.getName(),new Date(file.lastModified()),buffer);
  pipeFileContents(file,pOut,buffer.length);
}","/** 
 * Write out the contents of the provided file as a literal data packet in partial packet format.
 * @param out the stream to write the literal data to.
 * @param fileType the {@link PGPLiteralData} type to use for the file data.
 * @param file the file to write the contents of.
 * @param buffer buffer to be used to chunk the file into partial packets.
 * @see PGPLiteralDataGenerator#open(OutputStream, char, String, Date, byte[]).
 * @throws IOException if an error occurs reading the file or writing to the output stream.
 */
public static void writeFileToLiteralData(OutputStream out,char fileType,File file,byte[] buffer) throws IOException {
  PGPLiteralDataGenerator lData=new PGPLiteralDataGenerator();
  OutputStream pOut=lData.open(out,fileType,file.getName(),new Date(file.lastModified()),buffer);
  pipeFileContents(file,pOut,buffer.length);
}"
52475,"/** 
 * Builds CCPD request.
 * @param messageImprint - the message imprint to include.
 * @return
 * @throws DVCSException
 */
public DVCSRequest build(MessageImprint messageImprint) throws DVCSException {
  Data data=new Data(messageImprint.toASN1Structure());
  return createDVCRequest(data);
}","/** 
 * Builds CCPD request.
 * @param messageImprint - the message imprint to include.
 * @return a new DVCSRequest based on the state of this builder.
 * @throws DVCSException if an issue occurs during construction.
 */
public DVCSRequest build(MessageImprint messageImprint) throws DVCSException {
  Data data=new Data(messageImprint.toASN1Structure());
  return createDVCRequest(data);
}"
52476,"/** 
 * Get MessageImprint value
 * @return
 */
public MessageImprint getMessageImprint(){
  return new MessageImprint(data.getMessageImprint());
}","/** 
 * Get MessageImprint value
 * @return the message imprint data as a MessageImprint object.
 */
public MessageImprint getMessageImprint(){
  return new MessageImprint(data.getMessageImprint());
}"
52477,"/** 
 * Get contained message (data to be certified).
 * @return
 */
public byte[] getMessage(){
  return data.getMessage().getOctets();
}","/** 
 * Get contained message (data to be certified).
 * @return the contained message.
 */
public byte[] getMessage(){
  return data.getMessage().getOctets();
}"
52478,"/** 
 * Add a given extension field.
 * @param oid the OID defining the extension type.
 * @param isCritical true if the extension is critical, false otherwise.
 * @param value the ASN.1 structure that forms the extension's value.
 * @return this builder object.
 * @throws DVCSException if there is an issue encoding the extension for adding.
 */
public void addExtension(ASN1ObjectIdentifier oid,boolean isCritical,ASN1Encodable value) throws DVCSException {
  try {
    extGenerator.addExtension(oid,isCritical,value);
  }
 catch (  IOException e) {
    throw new DVCSException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Add a given extension field.
 * @param oid the OID defining the extension type.
 * @param isCritical true if the extension is critical, false otherwise.
 * @param value the ASN.1 structure that forms the extension's value.
 * @throws DVCSException if there is an issue encoding the extension for adding.
 */
public void addExtension(ASN1ObjectIdentifier oid,boolean isCritical,ASN1Encodable value) throws DVCSException {
  try {
    extGenerator.addExtension(oid,isCritical,value);
  }
 catch (  IOException e) {
    throw new DVCSException(""String_Node_Str"" + e.getMessage(),e);
  }
}"
52479,"/** 
 * Get DVCS version of request.
 * @return
 */
public int getVersion(){
  return data.getVersion();
}","/** 
 * Get DVCS version of request.
 * @return the version number of the request.
 */
public int getVersion(){
  return data.getVersion();
}"
52480,"/** 
 * Converts to corresponding ASN.1 structure (DVCSRequestInformation).
 * @return
 */
public DVCSRequestInformation toASN1Structure(){
  return data;
}","/** 
 * Converts to corresponding ASN.1 structure (DVCSRequestInformation).
 * @return a DVCSRequestInformation object.
 */
public DVCSRequestInformation toASN1Structure(){
  return data;
}"
52481,"/** 
 * Constructs DVCRequestInfo from DVCSRequestInformation ASN.1 structure.
 * @param data
 */
public DVCSRequestInfo(DVCSRequestInformation data){
  this.data=data;
}","/** 
 * Constructs DVCRequestInfo from DVCSRequestInformation ASN.1 structure.
 * @param data a DVCSRequestInformation to populate this object with.
 */
public DVCSRequestInfo(DVCSRequestInformation data){
  this.data=data;
}"
52482,"/** 
 * Get data locations, where the copy of request Data can be obtained. Note: the exact meaning of field is up to applications. Note: this field can be set by DVCS.
 * @return
 */
public GeneralNames getDataLocations(){
  return data.getDataLocations();
}","/** 
 * Get data locations, where the copy of request Data can be obtained. Note: the exact meaning of field is up to applications. Note: this field can be set by DVCS.
 * @return the DVCS dataLocations object, or null if not set.
 */
public GeneralNames getDataLocations(){
  return data.getDataLocations();
}"
52483,"/** 
 * Get names of DVCS servers. Note: this field can be set by DVCS.
 * @return
 */
public GeneralNames getDVCSNames(){
  return data.getDVCS();
}","/** 
 * Get names of DVCS servers. Note: this field can be set by DVCS.
 * @return the DVCS names object, or null if not set.
 */
public GeneralNames getDVCSNames(){
  return data.getDVCS();
}"
52484,"/** 
 * Get names of requesting entity, if set.
 * @return
 */
public GeneralNames getRequester(){
  return data.getRequester();
}","/** 
 * Get names of requesting entity, if set.
 * @return the requesting entity, or null.
 */
public GeneralNames getRequester(){
  return data.getRequester();
}"
52485,"/** 
 * Build DVCS request to VPKC service.
 * @throws DVCSException
 */
public DVCSRequest build() throws DVCSException {
  Data data=new Data((TargetEtcChain[])chains.toArray(new TargetEtcChain[chains.size()]));
  return createDVCRequest(data);
}","/** 
 * Build DVCS request to VPKC service.
 * @return a new DVCSRequest based on the state of this builder.
 * @throws DVCSException if an issue occurs during construction.
 */
public DVCSRequest build() throws DVCSException {
  Data data=new Data((TargetEtcChain[])chains.toArray(new TargetEtcChain[chains.size()]));
  return createDVCRequest(data);
}"
52486,"/** 
 * Build VSD request from CMS SignedData object.
 * @param document
 * @return
 * @throws DVCSException
 */
public DVCSRequest build(CMSSignedData document) throws DVCSException {
  try {
    Data data=new Data(document.getEncoded());
    return createDVCRequest(data);
  }
 catch (  IOException e) {
    throw new DVCSException(""String_Node_Str"",e);
  }
}","/** 
 * Build VSD request from CMS SignedData object.
 * @param document the CMS SignedData to include in the request.
 * @return a new DVCSRequest based on the state of this builder.
 * @throws DVCSException if an issue occurs during construction.
 */
public DVCSRequest build(CMSSignedData document) throws DVCSException {
  try {
    Data data=new Data(document.getEncoded());
    return createDVCRequest(data);
  }
 catch (  IOException e) {
    throw new DVCSException(""String_Node_Str"",e);
  }
}"
52487,"/** 
 * Get the CMS SignedData object represented by the encoded message.
 * @return
 */
public CMSSignedData getParsedMessage(){
  return doc;
}","/** 
 * Get the CMS SignedData object represented by the encoded message.
 * @return the parsed contents of the contained message as a CMS SignedData object.
 */
public CMSSignedData getParsedMessage(){
  return doc;
}"
52488,"/** 
 * Get contained message (data to be certified).
 * @return
 */
public byte[] getMessage(){
  return data.getMessage().getOctets();
}","/** 
 * Get contained message (data to be certified).
 * @return the contained message.
 */
public byte[] getMessage(){
  return data.getMessage().getOctets();
}"
52489,"/** 
 * Return true if the passed in objectIdentifier has a ""human friendly"" name associated with it.
 * @param objectIdentifier the OID of interest.
 * @boolean true if a name lookup exists for the OID, false otherwise.
 */
boolean hasAlgorithmName(ASN1ObjectIdentifier objectIdentifier);","/** 
 * Return true if the passed in objectIdentifier has a ""human friendly"" name associated with it.
 * @param objectIdentifier the OID of interest.
 * @return true if a name lookup exists for the OID, false otherwise.
 */
boolean hasAlgorithmName(ASN1ObjectIdentifier objectIdentifier);"
52490,"/** 
 * @deprecated use toASN1Structure
 * @return
 */
public TSTInfo toTSTInfo(){
  return tstInfo;
}","/** 
 * @deprecated use toASN1Structure
 */
public TSTInfo toTSTInfo(){
  return tstInfo;
}"
52491,"/** 
 * Constructor used by the   {@link McElieceKeyFactory}.
 * @param n            the length of the code
 * @param k            the dimension of the code
 * @param encFieldPoly the encoded field polynomial defining the finite field<tt>GF(2<sup>m</sup>)</tt>
 * @param encGoppaPoly the encoded irreducible Goppa polynomial
 * @param encP         the encoded permutation
 * @param encH         the encoded canonical check matrix
 * @param encQInv      the encoded matrix used to compute square roots in<tt>(GF(2^m))^t</tt>
 */
public McElieceCCA2PrivateKeySpec(String oid,int n,int k,byte[] encFieldPoly,byte[] encGoppaPoly,byte[] encP,byte[] encH,byte[][] encQInv){
  this.oid=oid;
  this.n=n;
  this.k=k;
  field=new GF2mField(encFieldPoly);
  goppaPoly=new PolynomialGF2mSmallM(field,encGoppaPoly);
  p=new Permutation(encP);
  h=new GF2Matrix(encH);
  qInv=new PolynomialGF2mSmallM[encQInv.length];
  for (int i=0; i < encQInv.length; i++) {
    qInv[i]=new PolynomialGF2mSmallM(field,encQInv[i]);
  }
}","/** 
 * Constructor.
 * @param n            the length of the code
 * @param k            the dimension of the code
 * @param encFieldPoly the encoded field polynomial defining the finite field<tt>GF(2<sup>m</sup>)</tt>
 * @param encGoppaPoly the encoded irreducible Goppa polynomial
 * @param encP         the encoded permutation
 * @param encH         the encoded canonical check matrix
 * @param encQInv      the encoded matrix used to compute square roots in<tt>(GF(2^m))^t</tt>
 */
public McElieceCCA2PrivateKeySpec(String oid,int n,int k,byte[] encFieldPoly,byte[] encGoppaPoly,byte[] encP,byte[] encH,byte[][] encQInv){
  this.oid=oid;
  this.n=n;
  this.k=k;
  field=new GF2mField(encFieldPoly);
  goppaPoly=new PolynomialGF2mSmallM(field,encGoppaPoly);
  p=new Permutation(encP);
  h=new GF2Matrix(encH);
  qInv=new PolynomialGF2mSmallM[encQInv.length];
  for (int i=0; i < encQInv.length; i++) {
    qInv[i]=new PolynomialGF2mSmallM(field,encQInv[i]);
  }
}"
52492,"/** 
 * return true if the signature represents a ISO9796-2 signature for the passed in message.
 */
public boolean verifySignature(byte[] signature){
  try {
    block=cipher.processBlock(signature,0,signature.length);
  }
 catch (  Exception e) {
    return false;
  }
  BigInteger t=new BigInteger(block);
  BigInteger f;
  if ((t.intValue() & 15) == 12) {
    f=t;
  }
 else {
    t=kParam.getModulus().subtract(t);
    if ((t.intValue() & 15) == 12) {
      f=t;
    }
 else {
      return false;
    }
  }
  createSignatureBlock();
  byte[] fBlock=BigIntegers.asUnsignedByteArray(block.length,f);
  boolean rv=Arrays.constantTimeAreEqual(block,fBlock);
  clearBlock(block);
  clearBlock(fBlock);
  return rv;
}","/** 
 * return true if the signature represents a ISO9796-2 signature for the passed in message.
 */
public boolean verifySignature(byte[] signature){
  try {
    block=cipher.processBlock(signature,0,signature.length);
  }
 catch (  Exception e) {
    return false;
  }
  BigInteger t=new BigInteger(1,block);
  BigInteger f;
  if ((t.intValue() & 15) == 12) {
    f=t;
  }
 else {
    t=kParam.getModulus().subtract(t);
    if ((t.intValue() & 15) == 12) {
      f=t;
    }
 else {
      return false;
    }
  }
  createSignatureBlock();
  byte[] fBlock=BigIntegers.asUnsignedByteArray(block.length,f);
  boolean rv=Arrays.constantTimeAreEqual(block,fBlock);
  clearBlock(block);
  clearBlock(fBlock);
  return rv;
}"
52493,"/** 
 * fill len bytes of the output buffer with bytes generated from the derivation function.
 * @throws DataLengthException if the out buffer is too small.
 */
public int generateBytes(byte[] out,int outOff,int len) throws DataLengthException, IllegalArgumentException {
  if ((out.length - len) < outOff) {
    throw new DataLengthException(""String_Node_Str"");
  }
  byte[] hashBuf=new byte[hLen];
  byte[] C=new byte[4];
  int counter=1;
  digest.reset();
  if (len > hLen) {
    do {
      ItoOSP(counter++,C);
      digest.update(C,0,C.length);
      digest.update(shared,0,shared.length);
      digest.update(otherInfo,0,otherInfo.length);
      digest.doFinal(hashBuf,0);
      System.arraycopy(hashBuf,0,out,outOff + (counter - 1) * hLen,hLen);
    }
 while (counter < (len / hLen));
  }
  if (((counter - 1) * hLen) < len) {
    ItoOSP(counter,C);
    digest.update(C,0,C.length);
    digest.update(shared,0,shared.length);
    digest.update(otherInfo,0,otherInfo.length);
    digest.doFinal(hashBuf,0);
    System.arraycopy(hashBuf,0,out,outOff + (counter - 1) * hLen,len - ((counter - 1) * hLen));
  }
  return len;
}","/** 
 * fill len bytes of the output buffer with bytes generated from the derivation function.
 * @throws DataLengthException if the out buffer is too small.
 */
public int generateBytes(byte[] out,int outOff,int len) throws DataLengthException, IllegalArgumentException {
  if ((out.length - len) < outOff) {
    throw new DataLengthException(""String_Node_Str"");
  }
  byte[] hashBuf=new byte[hLen];
  byte[] C=new byte[4];
  int counter=1;
  int outputLen=0;
  digest.reset();
  if (len > hLen) {
    do {
      ItoOSP(counter,C);
      digest.update(C,0,C.length);
      digest.update(shared,0,shared.length);
      digest.update(otherInfo,0,otherInfo.length);
      digest.doFinal(hashBuf,0);
      System.arraycopy(hashBuf,0,out,outOff + outputLen,hLen);
      outputLen+=hLen;
    }
 while ((counter++) < (len / hLen));
  }
  if (outputLen < len) {
    ItoOSP(counter,C);
    digest.update(C,0,C.length);
    digest.update(shared,0,shared.length);
    digest.update(otherInfo,0,otherInfo.length);
    digest.doFinal(hashBuf,0);
    System.arraycopy(hashBuf,0,out,outOff + outputLen,len - outputLen);
  }
  return len;
}"
52494,"public void configure(ConfigurableProvider provider){
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  registerOid(provider,X9ObjectIdentifiers.id_ecPublicKey,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOidAlgorithmParameters(provider,X9ObjectIdentifiers.id_ecPublicKey,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme,""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + TeleTrusTObjectIdentifiers.ecSignWithSha1,""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",X9ObjectIdentifiers.ecdsa_with_SHA224);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",X9ObjectIdentifiers.ecdsa_with_SHA256);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",X9ObjectIdentifiers.ecdsa_with_SHA384);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",X9ObjectIdentifiers.ecdsa_with_SHA512);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",TeleTrusTObjectIdentifiers.ecSignWithRipemd160);
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_1);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_224);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_256);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_384);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_512);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA1);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA224);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA256);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA384);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA512);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_RIPEMD160);
}","public void configure(ConfigurableProvider provider){
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme,PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  registerOid(provider,X9ObjectIdentifiers.id_ecPublicKey,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme,""String_Node_Str"",new KeyFactorySpi.EC());
  registerOid(provider,SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme,""String_Node_Str"",new KeyFactorySpi.ECMQV());
  registerOidAlgorithmParameters(provider,X9ObjectIdentifiers.id_ecPublicKey,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme,""String_Node_Str"");
  registerOidAlgorithmParameters(provider,SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme,""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"" + TeleTrusTObjectIdentifiers.ecSignWithSha1,""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",X9ObjectIdentifiers.ecdsa_with_SHA224);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",X9ObjectIdentifiers.ecdsa_with_SHA256);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",X9ObjectIdentifiers.ecdsa_with_SHA384);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",X9ObjectIdentifiers.ecdsa_with_SHA512);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",TeleTrusTObjectIdentifiers.ecSignWithRipemd160);
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  provider.addAlgorithm(""String_Node_Str"",PREFIX + ""String_Node_Str"");
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_1);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_224);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_256);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_384);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",EACObjectIdentifiers.id_TA_ECDSA_SHA_512);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA1);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA224);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA256);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA384);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_SHA512);
  addSignatureAlgorithm(provider,""String_Node_Str"",""String_Node_Str"",PREFIX + ""String_Node_Str"",BSIObjectIdentifiers.ecdsa_plain_RIPEMD160);
}"
52495,"private void populateFromPrivKeyInfo(PrivateKeyInfo info) throws IOException {
  ASN1Primitive p=info.getPrivateKeyAlgorithm().getParameters().toASN1Primitive();
  if (p instanceof ASN1Sequence && (ASN1Sequence.getInstance(p).size() == 2 || ASN1Sequence.getInstance(p).size() == 3)) {
    gostParams=GOST3410PublicKeyAlgParameters.getInstance(info.getPrivateKeyAlgorithm().getParameters());
    ECNamedCurveParameterSpec spec=ECGOST3410NamedCurveTable.getParameterSpec(ECGOST3410NamedCurves.getName(gostParams.getPublicKeyParamSet()));
    ECCurve curve=spec.getCurve();
    EllipticCurve ellipticCurve=EC5Util.convertCurve(curve,spec.getSeed());
    ecSpec=new ECNamedCurveSpec(ECGOST3410NamedCurves.getName(gostParams.getPublicKeyParamSet()),ellipticCurve,new ECPoint(spec.getG().getAffineXCoord().toBigInteger(),spec.getG().getAffineYCoord().toBigInteger()),spec.getN(),spec.getH());
    ASN1Encodable privKey=info.parsePrivateKey();
    byte[] encVal=ASN1OctetString.getInstance(privKey).getOctets();
    byte[] dVal=new byte[encVal.length];
    for (int i=0; i != encVal.length; i++) {
      dVal[i]=encVal[encVal.length - 1 - i];
    }
    this.d=new BigInteger(1,dVal);
  }
 else {
    X962Parameters params=X962Parameters.getInstance(info.getPrivateKeyAlgorithm().getParameters());
    if (params.isNamedCurve()) {
      ASN1ObjectIdentifier oid=ASN1ObjectIdentifier.getInstance(params.getParameters());
      X9ECParameters ecP=ECUtil.getNamedCurveByOid(oid);
      if (ecP == null) {
        ECDomainParameters gParam=ECGOST3410NamedCurves.getByOID(oid);
        EllipticCurve ellipticCurve=EC5Util.convertCurve(gParam.getCurve(),gParam.getSeed());
        ecSpec=new ECNamedCurveSpec(ECGOST3410NamedCurves.getName(oid),ellipticCurve,new ECPoint(gParam.getG().getAffineXCoord().toBigInteger(),gParam.getG().getAffineYCoord().toBigInteger()),gParam.getN(),gParam.getH());
      }
 else {
        EllipticCurve ellipticCurve=EC5Util.convertCurve(ecP.getCurve(),ecP.getSeed());
        ecSpec=new ECNamedCurveSpec(ECUtil.getCurveName(oid),ellipticCurve,new ECPoint(ecP.getG().getAffineXCoord().toBigInteger(),ecP.getG().getAffineYCoord().toBigInteger()),ecP.getN(),ecP.getH());
      }
    }
 else     if (params.isImplicitlyCA()) {
      ecSpec=null;
    }
 else {
      X9ECParameters ecP=X9ECParameters.getInstance(params.getParameters());
      EllipticCurve ellipticCurve=EC5Util.convertCurve(ecP.getCurve(),ecP.getSeed());
      this.ecSpec=new ECParameterSpec(ellipticCurve,new ECPoint(ecP.getG().getAffineXCoord().toBigInteger(),ecP.getG().getAffineYCoord().toBigInteger()),ecP.getN(),ecP.getH().intValue());
    }
    ASN1Encodable privKey=info.parsePrivateKey();
    if (privKey instanceof ASN1Integer) {
      ASN1Integer derD=ASN1Integer.getInstance(privKey);
      this.d=derD.getValue();
    }
 else {
      org.bouncycastle.asn1.sec.ECPrivateKey ec=org.bouncycastle.asn1.sec.ECPrivateKey.getInstance(privKey);
      this.d=ec.getKey();
      this.publicKey=ec.getPublicKey();
    }
  }
}","private void populateFromPrivKeyInfo(PrivateKeyInfo info) throws IOException {
  ASN1Primitive p=info.getPrivateKeyAlgorithm().getParameters().toASN1Primitive();
  if (p instanceof ASN1Sequence && (ASN1Sequence.getInstance(p).size() == 2 || ASN1Sequence.getInstance(p).size() == 3)) {
    gostParams=GOST3410PublicKeyAlgParameters.getInstance(info.getPrivateKeyAlgorithm().getParameters());
    ECNamedCurveParameterSpec spec=ECGOST3410NamedCurveTable.getParameterSpec(ECGOST3410NamedCurves.getName(gostParams.getPublicKeyParamSet()));
    ECCurve curve=spec.getCurve();
    EllipticCurve ellipticCurve=EC5Util.convertCurve(curve,spec.getSeed());
    ecSpec=new ECNamedCurveSpec(ECGOST3410NamedCurves.getName(gostParams.getPublicKeyParamSet()),ellipticCurve,new ECPoint(spec.getG().getAffineXCoord().toBigInteger(),spec.getG().getAffineYCoord().toBigInteger()),spec.getN(),spec.getH());
    ASN1Encodable privKey=info.parsePrivateKey();
    if (privKey instanceof ASN1Integer) {
      this.d=ASN1Integer.getInstance(privKey).getPositiveValue();
    }
 else {
      byte[] encVal=ASN1OctetString.getInstance(privKey).getOctets();
      byte[] dVal=new byte[encVal.length];
      for (int i=0; i != encVal.length; i++) {
        dVal[i]=encVal[encVal.length - 1 - i];
      }
      this.d=new BigInteger(1,dVal);
    }
  }
 else {
    X962Parameters params=X962Parameters.getInstance(info.getPrivateKeyAlgorithm().getParameters());
    if (params.isNamedCurve()) {
      ASN1ObjectIdentifier oid=ASN1ObjectIdentifier.getInstance(params.getParameters());
      X9ECParameters ecP=ECUtil.getNamedCurveByOid(oid);
      if (ecP == null) {
        ECDomainParameters gParam=ECGOST3410NamedCurves.getByOID(oid);
        EllipticCurve ellipticCurve=EC5Util.convertCurve(gParam.getCurve(),gParam.getSeed());
        ecSpec=new ECNamedCurveSpec(ECGOST3410NamedCurves.getName(oid),ellipticCurve,new ECPoint(gParam.getG().getAffineXCoord().toBigInteger(),gParam.getG().getAffineYCoord().toBigInteger()),gParam.getN(),gParam.getH());
      }
 else {
        EllipticCurve ellipticCurve=EC5Util.convertCurve(ecP.getCurve(),ecP.getSeed());
        ecSpec=new ECNamedCurveSpec(ECUtil.getCurveName(oid),ellipticCurve,new ECPoint(ecP.getG().getAffineXCoord().toBigInteger(),ecP.getG().getAffineYCoord().toBigInteger()),ecP.getN(),ecP.getH());
      }
    }
 else     if (params.isImplicitlyCA()) {
      ecSpec=null;
    }
 else {
      X9ECParameters ecP=X9ECParameters.getInstance(params.getParameters());
      EllipticCurve ellipticCurve=EC5Util.convertCurve(ecP.getCurve(),ecP.getSeed());
      this.ecSpec=new ECParameterSpec(ellipticCurve,new ECPoint(ecP.getG().getAffineXCoord().toBigInteger(),ecP.getG().getAffineYCoord().toBigInteger()),ecP.getN(),ecP.getH().intValue());
    }
    ASN1Encodable privKey=info.parsePrivateKey();
    if (privKey instanceof ASN1Integer) {
      ASN1Integer derD=ASN1Integer.getInstance(privKey);
      this.d=derD.getValue();
    }
 else {
      org.bouncycastle.asn1.sec.ECPrivateKey ec=org.bouncycastle.asn1.sec.ECPrivateKey.getInstance(privKey);
      this.d=ec.getKey();
      this.publicKey=ec.getPublicKey();
    }
  }
}"
52496,"public void performTest() throws Exception {
  testKeyConversion();
  testAdaptiveKeyConversion();
  decodeTest();
  testECDSA239bitPrime();
  testECDSA239bitBinary();
  testGeneration();
  testKeyPairGenerationWithOIDs();
  testNamedCurveParameterPreservation();
  testNamedCurveSigning();
  testBSI();
}","public void performTest() throws Exception {
  testKeyConversion();
  testAdaptiveKeyConversion();
  decodeTest();
  testECDSA239bitPrime();
  testECDSA239bitBinary();
  testGeneration();
  testKeyPairGenerationWithOIDs();
  testNamedCurveParameterPreservation();
  testNamedCurveSigning();
  testBSI();
  testMQVwithHMACOnePass();
}"
52497,"private void testGOSTStore() throws Exception {
  byte[] data=Hex.decode(""String_Node_Str"");
  KeyStore pkcs12=KeyStore.getInstance(""String_Node_Str"",""String_Node_Str"");
  pkcs12.load(new ByteArrayInputStream(gostPfx),""String_Node_Str"".toCharArray());
  PrivateKey pk=(PrivateKey)pkcs12.getKey(""String_Node_Str"",null);
  Certificate[] pubCerts=pkcs12.getCertificateChain(""String_Node_Str"");
  Signature sig=Signature.getInstance(""String_Node_Str"",""String_Node_Str"");
  sig.initSign(pk);
  sig.update(data);
  byte[] signature=sig.sign();
  sig=Signature.getInstance(""String_Node_Str"",""String_Node_Str"");
  sig.initVerify(pubCerts[0].getPublicKey());
  sig.update(data);
  if (!sig.verify(signature)) {
    fail(""String_Node_Str"");
  }
}","private void testGOSTStore() throws Exception {
  byte[] data=Hex.decode(""String_Node_Str"");
  KeyStore pkcs12=KeyStore.getInstance(""String_Node_Str"",""String_Node_Str"");
  pkcs12.load(new ByteArrayInputStream(gostPfx),""String_Node_Str"".toCharArray());
  PrivateKey pk=(PrivateKey)pkcs12.getKey(""String_Node_Str"",null);
  Certificate[] pubCerts=pkcs12.getCertificateChain(""String_Node_Str"");
  Signature sig=Signature.getInstance(""String_Node_Str"",""String_Node_Str"");
  sig.initSign(pk);
  sig.update(data);
  byte[] signature=sig.sign();
  sig=Signature.getInstance(""String_Node_Str"",""String_Node_Str"");
  sig.initVerify(pubCerts[0].getPublicKey());
  sig.update(data);
  if (!sig.verify(signature)) {
    fail(""String_Node_Str"");
  }
  KeyStore ks=KeyStore.getInstance(""String_Node_Str"",""String_Node_Str"");
  ks.load(new ByteArrayInputStream(gostOpenSSLIntegerDPfx),""String_Node_Str"".toCharArray());
  PrivateKey key=(PrivateKey)ks.getKey(""String_Node_Str"",""String_Node_Str"".toCharArray());
  X509Certificate cert=(X509Certificate)ks.getCertificate(""String_Node_Str"");
  sig.initSign(key);
  sig.update(data);
  signature=sig.sign();
  sig.initVerify(cert.getPublicKey());
  sig.update(data);
  if (!sig.verify(signature)) {
    fail(""String_Node_Str"");
  }
}"
52498,"public void verify(PublicKey key,Provider sigProvider) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException {
  Signature sig;
  if (sigProvider != null) {
    sig=Signature.getInstance(getSigAlgName(),sigProvider);
  }
 else {
    sig=Signature.getInstance(getSigAlgName());
  }
  doVerify(key,sig);
}","public void verify(PublicKey key,Provider sigProvider) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
  Signature sig;
  if (sigProvider != null) {
    sig=Signature.getInstance(getSigAlgName(),sigProvider);
  }
 else {
    sig=Signature.getInstance(getSigAlgName());
  }
  doVerify(key,sig);
}"
52499,"private void doVerify(PublicKey key,Signature sig) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException {
  if (!c.getSignatureAlgorithm().equals(c.getTBSCertList().getSignature())) {
    throw new CRLException(""String_Node_Str"");
  }
  sig.initVerify(key);
  sig.update(this.getTBSCertList());
  if (!sig.verify(this.getSignature())) {
    throw new SignatureException(""String_Node_Str"");
  }
}","private void doVerify(PublicKey key,Signature sig) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
  if (!c.getSignatureAlgorithm().equals(c.getTBSCertList().getSignature())) {
    throw new CRLException(""String_Node_Str"");
  }
  sig.initVerify(key);
  sig.update(this.getTBSCertList());
  if (!sig.verify(this.getSignature())) {
    throw new SignatureException(""String_Node_Str"");
  }
}"
52500,"public final void verify(PublicKey key,Provider sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException {
  String sigName=X509SignatureUtil.getSignatureName(c.getSignatureAlgorithm());
  Signature signature;
  if (sigProvider != null) {
    signature=Signature.getInstance(sigName,sigProvider);
  }
 else {
    signature=Signature.getInstance(sigName);
  }
  checkSignature(key,signature);
}","public final void verify(PublicKey key,Provider sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
  String sigName=X509SignatureUtil.getSignatureName(c.getSignatureAlgorithm());
  Signature signature;
  if (sigProvider != null) {
    signature=Signature.getInstance(sigName,sigProvider);
  }
 else {
    signature=Signature.getInstance(sigName);
  }
  checkSignature(key,signature);
}"
52501,"public void verify(PublicKey key,Provider sigProvider) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException {
  Signature sig;
  if (sigProvider != null) {
    sig=Signature.getInstance(getSigAlgName(),sigProvider);
  }
 else {
    sig=Signature.getInstance(getSigAlgName());
  }
  doVerify(key,sig);
}","public void verify(PublicKey key,Provider sigProvider) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
  Signature sig;
  if (sigProvider != null) {
    sig=Signature.getInstance(getSigAlgName(),sigProvider);
  }
 else {
    sig=Signature.getInstance(getSigAlgName());
  }
  doVerify(key,sig);
}"
52502,"private void doVerify(PublicKey key,Signature sig) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException {
  if (!c.getSignatureAlgorithm().equals(c.getTBSCertList().getSignature())) {
    throw new CRLException(""String_Node_Str"");
  }
  sig.initVerify(key);
  sig.update(this.getTBSCertList());
  if (!sig.verify(this.getSignature())) {
    throw new SignatureException(""String_Node_Str"");
  }
}","private void doVerify(PublicKey key,Signature sig) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
  if (!c.getSignatureAlgorithm().equals(c.getTBSCertList().getSignature())) {
    throw new CRLException(""String_Node_Str"");
  }
  sig.initVerify(key);
  sig.update(this.getTBSCertList());
  if (!sig.verify(this.getSignature())) {
    throw new SignatureException(""String_Node_Str"");
  }
}"
52503,"public final void verify(PublicKey key,Provider sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException {
  String sigName=X509SignatureUtil.getSignatureName(c.getSignatureAlgorithm());
  Signature signature;
  if (sigProvider != null) {
    signature=Signature.getInstance(sigName,sigProvider);
  }
 else {
    signature=Signature.getInstance(sigName);
  }
  checkSignature(key,signature);
}","public final void verify(PublicKey key,Provider sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
  String sigName=X509SignatureUtil.getSignatureName(c.getSignatureAlgorithm());
  Signature signature;
  if (sigProvider != null) {
    signature=Signature.getInstance(sigName,sigProvider);
  }
 else {
    signature=Signature.getInstance(sigName);
  }
  checkSignature(key,signature);
}"
52504,"public void write(OutputStream out) throws IOException, CMSException {
  try {
    SMIMEUtil.outputBodyPart(out,bodyPart,defaultContentTransferEncoding);
  }
 catch (  MessagingException e) {
    throw new CMSException(""String_Node_Str"" + e,e);
  }
}","public void write(OutputStream out) throws IOException, CMSException {
  try {
    SMIMEUtil.outputBodyPart(out,true,bodyPart,defaultContentTransferEncoding);
  }
 catch (  MessagingException e) {
    throw new CMSException(""String_Node_Str"" + e,e);
  }
}"
52505,"private static CMSTypedStream getSignedInputStream(BodyPart bodyPart,String defaultContentTransferEncoding,File backingFile) throws MessagingException {
  try {
    OutputStream out=new BufferedOutputStream(new FileOutputStream(backingFile));
    SMIMEUtil.outputBodyPart(out,bodyPart,defaultContentTransferEncoding);
    out.close();
    InputStream in=new TemporaryFileInputStream(backingFile);
    return new CMSTypedStream(in);
  }
 catch (  IOException e) {
    throw new MessagingException(""String_Node_Str"" + e);
  }
}","private static CMSTypedStream getSignedInputStream(BodyPart bodyPart,String defaultContentTransferEncoding,File backingFile) throws MessagingException {
  try {
    OutputStream out=new BufferedOutputStream(new FileOutputStream(backingFile));
    SMIMEUtil.outputBodyPart(out,true,bodyPart,defaultContentTransferEncoding);
    out.close();
    InputStream in=new TemporaryFileInputStream(backingFile);
    return new CMSTypedStream(in);
  }
 catch (  IOException e) {
    throw new MessagingException(""String_Node_Str"" + e);
  }
}"
52506,"/** 
 * Return a CMS IssuerAndSerialNumber structure for the passed in X.509 certificate.
 * @param cert the X.509 certificate to get the issuer and serial number for.
 * @return an IssuerAndSerialNumber structure representing the certificate.
 */
public static IssuerAndSerialNumber createIssuerAndSerialNumberFor(X509Certificate cert) throws CertificateParsingException {
  try {
    return new IssuerAndSerialNumber(PrincipalUtil.getIssuerX509Principal(cert),cert.getSerialNumber());
  }
 catch (  Exception e) {
    throw new CertificateParsingException(""String_Node_Str"" + e);
  }
}","/** 
 * Return a CMS IssuerAndSerialNumber structure for the passed in X.509 certificate.
 * @param cert the X.509 certificate to get the issuer and serial number for.
 * @return an IssuerAndSerialNumber structure representing the certificate.
 */
public static IssuerAndSerialNumber createIssuerAndSerialNumberFor(X509Certificate cert) throws CertificateParsingException {
  try {
    return new IssuerAndSerialNumber(new JcaX509CertificateHolder(cert).getIssuer(),cert.getSerialNumber());
  }
 catch (  Exception e) {
    throw new CertificateParsingException(""String_Node_Str"" + e);
  }
}"
52507,"static void outputBodyPart(OutputStream out,BodyPart bodyPart,String defaultContentTransferEncoding) throws MessagingException, IOException {
  if (bodyPart instanceof MimeBodyPart) {
    MimeBodyPart mimePart=(MimeBodyPart)bodyPart;
    String[] cte=mimePart.getHeader(""String_Node_Str"");
    String contentTransferEncoding;
    if (mimePart.getContent() instanceof MimeMultipart) {
      MimeMultipart mp=(MimeMultipart)bodyPart.getContent();
      ContentType contentType=new ContentType(mp.getContentType());
      String boundary=""String_Node_Str"" + contentType.getParameter(""String_Node_Str"");
      SMIMEUtil.LineOutputStream lOut=new SMIMEUtil.LineOutputStream(out);
      Enumeration headers=mimePart.getAllHeaderLines();
      while (headers.hasMoreElements()) {
        String header=(String)headers.nextElement();
        lOut.writeln(header);
      }
      lOut.writeln();
      outputPreamble(lOut,mimePart,boundary);
      for (int i=0; i < mp.getCount(); i++) {
        lOut.writeln(boundary);
        BodyPart part=mp.getBodyPart(i);
        outputBodyPart(out,part,defaultContentTransferEncoding);
        if (!(part.getContent() instanceof MimeMultipart)) {
          lOut.writeln();
        }
 else {
          outputPostamble(lOut,mimePart,boundary,part);
        }
      }
      lOut.writeln(boundary + ""String_Node_Str"");
      outputPostamble(lOut,mimePart,mp.getCount(),boundary);
      return;
    }
    if (cte == null) {
      contentTransferEncoding=defaultContentTransferEncoding;
    }
 else {
      contentTransferEncoding=cte[0];
    }
    if (!contentTransferEncoding.equalsIgnoreCase(""String_Node_Str"") && !contentTransferEncoding.equalsIgnoreCase(""String_Node_Str"")) {
      if (!contentTransferEncoding.equalsIgnoreCase(""String_Node_Str"")) {
        out=new CRLFOutputStream(out);
      }
      bodyPart.writeTo(out);
      out.flush();
      return;
    }
    boolean base64=contentTransferEncoding.equalsIgnoreCase(""String_Node_Str"");
    InputStream inRaw;
    try {
      inRaw=mimePart.getRawInputStream();
    }
 catch (    MessagingException e) {
      out=new CRLFOutputStream(out);
      bodyPart.writeTo(out);
      out.flush();
      return;
    }
    LineOutputStream outLine=new LineOutputStream(out);
    for (Enumeration e=mimePart.getAllHeaderLines(); e.hasMoreElements(); ) {
      String header=(String)e.nextElement();
      outLine.writeln(header);
    }
    outLine.writeln();
    outLine.flush();
    OutputStream outCRLF;
    if (base64) {
      outCRLF=new Base64CRLFOutputStream(out);
    }
 else {
      outCRLF=new CRLFOutputStream(out);
    }
    byte[] buf=new byte[BUF_SIZE];
    int len;
    while ((len=inRaw.read(buf,0,buf.length)) > 0) {
      outCRLF.write(buf,0,len);
    }
    outCRLF.flush();
  }
 else {
    if (!defaultContentTransferEncoding.equalsIgnoreCase(""String_Node_Str"")) {
      out=new CRLFOutputStream(out);
    }
    bodyPart.writeTo(out);
    out.flush();
  }
}","static void outputBodyPart(OutputStream out,boolean topLevel,BodyPart bodyPart,String defaultContentTransferEncoding) throws MessagingException, IOException {
  if (bodyPart instanceof MimeBodyPart) {
    MimeBodyPart mimePart=(MimeBodyPart)bodyPart;
    String[] cte=mimePart.getHeader(""String_Node_Str"");
    String contentTransferEncoding;
    if (mimePart.getContent() instanceof MimeMultipart) {
      MimeMultipart mp=(MimeMultipart)bodyPart.getContent();
      ContentType contentType=new ContentType(mp.getContentType());
      String boundary=""String_Node_Str"" + contentType.getParameter(""String_Node_Str"");
      SMIMEUtil.LineOutputStream lOut=new SMIMEUtil.LineOutputStream(out);
      Enumeration headers=mimePart.getAllHeaderLines();
      while (headers.hasMoreElements()) {
        String header=(String)headers.nextElement();
        lOut.writeln(header);
      }
      lOut.writeln();
      outputPreamble(lOut,mimePart,boundary);
      for (int i=0; i < mp.getCount(); i++) {
        lOut.writeln(boundary);
        BodyPart part=mp.getBodyPart(i);
        outputBodyPart(out,false,part,defaultContentTransferEncoding);
        if (!(part.getContent() instanceof MimeMultipart)) {
          lOut.writeln();
        }
 else {
          outputPostamble(lOut,mimePart,boundary,part);
        }
      }
      lOut.writeln(boundary + ""String_Node_Str"");
      if (topLevel) {
        outputPostamble(lOut,mimePart,mp.getCount(),boundary);
      }
      return;
    }
    if (cte == null) {
      contentTransferEncoding=defaultContentTransferEncoding;
    }
 else {
      contentTransferEncoding=cte[0];
    }
    if (!contentTransferEncoding.equalsIgnoreCase(""String_Node_Str"") && !contentTransferEncoding.equalsIgnoreCase(""String_Node_Str"")) {
      if (!contentTransferEncoding.equalsIgnoreCase(""String_Node_Str"")) {
        out=new CRLFOutputStream(out);
      }
      bodyPart.writeTo(out);
      out.flush();
      return;
    }
    boolean base64=contentTransferEncoding.equalsIgnoreCase(""String_Node_Str"");
    InputStream inRaw;
    try {
      inRaw=mimePart.getRawInputStream();
    }
 catch (    MessagingException e) {
      out=new CRLFOutputStream(out);
      bodyPart.writeTo(out);
      out.flush();
      return;
    }
    LineOutputStream outLine=new LineOutputStream(out);
    for (Enumeration e=mimePart.getAllHeaderLines(); e.hasMoreElements(); ) {
      String header=(String)e.nextElement();
      outLine.writeln(header);
    }
    outLine.writeln();
    outLine.flush();
    OutputStream outCRLF;
    if (base64) {
      outCRLF=new Base64CRLFOutputStream(out);
    }
 else {
      outCRLF=new CRLFOutputStream(out);
    }
    byte[] buf=new byte[BUF_SIZE];
    int len;
    while ((len=inRaw.read(buf,0,buf.length)) > 0) {
      outCRLF.write(buf,0,len);
    }
    outCRLF.flush();
  }
 else {
    if (!defaultContentTransferEncoding.equalsIgnoreCase(""String_Node_Str"")) {
      out=new CRLFOutputStream(out);
    }
    bodyPart.writeTo(out);
    out.flush();
  }
}"
52508,"public static ECField convertField(FiniteField field){
  if (ECAlgorithms.isFpField(field)) {
    return new ECFieldFp(field.getCharacteristic());
  }
 else {
    Polynomial poly=((PolynomialExtensionField)field).getMinimalPolynomial();
    int[] exponents=poly.getExponentsPresent();
    int[] ks=Arrays.reverse(Arrays.copyOfRange(exponents,1,exponents.length - 2));
    return new ECFieldF2m(poly.getDegree(),ks);
  }
}","public static ECField convertField(FiniteField field){
  if (ECAlgorithms.isFpField(field)) {
    return new ECFieldFp(field.getCharacteristic());
  }
 else {
    Polynomial poly=((PolynomialExtensionField)field).getMinimalPolynomial();
    int[] exponents=poly.getExponentsPresent();
    int[] ks=Arrays.reverse(Arrays.copyOfRange(exponents,1,exponents.length - 1));
    return new ECFieldF2m(poly.getDegree(),ks);
  }
}"
52509,"private static ECField convertField(FiniteField field){
  if (ECAlgorithms.isFpField(field)) {
    return new ECFieldFp(field.getCharacteristic());
  }
 else {
    Polynomial poly=((PolynomialExtensionField)field).getMinimalPolynomial();
    int[] exponents=poly.getExponentsPresent();
    int[] ks=Arrays.reverse(Arrays.copyOfRange(exponents,1,exponents.length - 2));
    return new ECFieldF2m(poly.getDegree(),ks);
  }
}","private static ECField convertField(FiniteField field){
  if (ECAlgorithms.isFpField(field)) {
    return new ECFieldFp(field.getCharacteristic());
  }
 else {
    Polynomial poly=((PolynomialExtensionField)field).getMinimalPolynomial();
    int[] exponents=poly.getExponentsPresent();
    int[] ks=Arrays.reverse(Arrays.copyOfRange(exponents,1,exponents.length - 1));
    return new ECFieldF2m(poly.getDegree(),ks);
  }
}"
52510,"protected int engineDoFinal(byte[] input,int inputOffset,int inputLen,byte[] output,int outputOffset) throws IllegalBlockSizeException, BadPaddingException, ShortBufferException {
  try {
    int len=0;
    if (inputLen != 0) {
      len=cipher.processBytes(input,inputOffset,inputLen,output,outputOffset);
    }
    return (len + cipher.doFinal(output,outputOffset + len));
  }
 catch (  OutputLengthException e) {
    throw new ShortBufferException(e.getMessage());
  }
catch (  DataLengthException e) {
    throw new IllegalBlockSizeException(e.getMessage());
  }
}","protected int engineDoFinal(byte[] input,int inputOffset,int inputLen,byte[] output,int outputOffset) throws IllegalBlockSizeException, BadPaddingException, ShortBufferException {
  int len=0;
  if (outputOffset + engineGetOutputSize(inputLen) > output.length) {
    throw new ShortBufferException(""String_Node_Str"");
  }
  try {
    if (inputLen != 0) {
      len=cipher.processBytes(input,inputOffset,inputLen,output,outputOffset);
    }
    return (len + cipher.doFinal(output,outputOffset + len));
  }
 catch (  OutputLengthException e) {
    throw new ShortBufferException(e.getMessage());
  }
catch (  DataLengthException e) {
    throw new IllegalBlockSizeException(e.getMessage());
  }
}"
52511,"protected int engineDoFinal(byte[] input,int inputOffset,int inputLen,byte[] output,int outputOffset){
  if (inputLen != 0) {
    cipher.processBytes(input,inputOffset,inputLen,output,outputOffset);
  }
  cipher.reset();
  return inputLen;
}","protected int engineDoFinal(byte[] input,int inputOffset,int inputLen,byte[] output,int outputOffset) throws ShortBufferException {
  if (outputOffset + inputLen > output.length) {
    throw new ShortBufferException(""String_Node_Str"");
  }
  if (inputLen != 0) {
    cipher.processBytes(input,inputOffset,inputLen,output,outputOffset);
  }
  cipher.reset();
  return inputLen;
}"
52512,"private void createSignatureBlock(){
  int digSize=digest.getDigestSize();
  int delta;
  if (trailer == TRAILER_IMPLICIT) {
    delta=block.length - digSize - 1;
    digest.doFinal(block,delta);
    block[block.length - 1]=(byte)TRAILER_IMPLICIT;
  }
 else {
    delta=block.length - digSize - 2;
    digest.doFinal(block,delta);
    block[block.length - 2]=(byte)(trailer >>> 8);
    block[block.length - 1]=(byte)trailer;
  }
  block[0]=0x06;
  for (int i=delta - 2; i != 0; i--) {
    block[i]=(byte)0xbb;
  }
  block[delta - 1]=(byte)0xba;
}","private void createSignatureBlock(){
  int digSize=digest.getDigestSize();
  int delta;
  if (trailer == TRAILER_IMPLICIT) {
    delta=block.length - digSize - 1;
    digest.doFinal(block,delta);
    block[block.length - 1]=(byte)TRAILER_IMPLICIT;
  }
 else {
    delta=block.length - digSize - 2;
    digest.doFinal(block,delta);
    block[block.length - 2]=(byte)(trailer >>> 8);
    block[block.length - 1]=(byte)trailer;
  }
  block[0]=0x6b;
  for (int i=delta - 2; i != 0; i--) {
    block[i]=(byte)0xbb;
  }
  block[delta - 1]=(byte)0xba;
}"
52513,"public void performTest() throws Exception {
  BigInteger rsaPubMod=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPubExp=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivMod=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivDP=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivDQ=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivExp=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivP=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivQ=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivQinv=new BigInteger(Base64.decode(""String_Node_Str""));
  RSAKeyParameters rsaPublic=new RSAKeyParameters(false,rsaPubMod,rsaPubExp);
  RSAPrivateCrtKeyParameters rsaPrivate=new RSAPrivateCrtKeyParameters(rsaPrivMod,rsaPubExp,rsaPrivExp,rsaPrivP,rsaPrivQ,rsaPrivDP,rsaPrivDQ,rsaPrivQinv);
  byte[] msg=new byte[]{1,6,3,32,7,43,2,5,7,78,4,23};
  X931Signer signer=new X931Signer(new RSAEngine(),new SHA1Digest());
  signer.init(true,rsaPrivate);
  signer.update(msg,0,msg.length);
  byte[] sig=signer.generateSignature();
  signer=new X931Signer(new RSAEngine(),new SHA1Digest());
  signer.init(false,rsaPublic);
  signer.update(msg,0,msg.length);
  if (!signer.verifySignature(sig)) {
    fail(""String_Node_Str"");
  }
}","public void performTest() throws Exception {
  BigInteger rsaPubMod=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPubExp=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivMod=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivDP=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivDQ=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivExp=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivP=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivQ=new BigInteger(Base64.decode(""String_Node_Str""));
  BigInteger rsaPrivQinv=new BigInteger(Base64.decode(""String_Node_Str""));
  RSAKeyParameters rsaPublic=new RSAKeyParameters(false,rsaPubMod,rsaPubExp);
  RSAPrivateCrtKeyParameters rsaPrivate=new RSAPrivateCrtKeyParameters(rsaPrivMod,rsaPubExp,rsaPrivExp,rsaPrivP,rsaPrivQ,rsaPrivDP,rsaPrivDQ,rsaPrivQinv);
  byte[] msg=new byte[]{1,6,3,32,7,43,2,5,7,78,4,23};
  X931Signer signer=new X931Signer(new RSAEngine(),new SHA1Digest());
  signer.init(true,rsaPrivate);
  signer.update(msg,0,msg.length);
  byte[] sig=signer.generateSignature();
  signer=new X931Signer(new RSAEngine(),new SHA1Digest());
  signer.init(false,rsaPublic);
  signer.update(msg,0,msg.length);
  if (!signer.verifySignature(sig)) {
    fail(""String_Node_Str"");
  }
  shouldPassSignatureTest1();
  shouldPassSignatureTest2();
}"
52514,"public static String canonicalize(String s){
  String value=Strings.toLowerCase(s.trim());
  if (value.length() > 0 && value.charAt(0) == '#') {
    ASN1Primitive obj=decodeObject(value);
    if (obj instanceof ASN1String) {
      value=Strings.toLowerCase(((ASN1String)obj).getString().trim());
    }
  }
  value=stripInternalSpaces(value);
  return value;
}","public static String canonicalize(String s){
  String value=Strings.toLowerCase(s);
  if (value.length() > 0 && value.charAt(0) == '#') {
    ASN1Primitive obj=decodeObject(value);
    if (obj instanceof ASN1String) {
      value=Strings.toLowerCase(((ASN1String)obj).getString());
    }
  }
  if (value.length() > 1) {
    int start=0;
    while (start + 1 < value.length() && value.charAt(start) == '\\' && value.charAt(start + 1) == ' ') {
      start+=2;
    }
    int end=value.length() - 1;
    while (end - 1 > 0 && value.charAt(end - 1) == '\\' && value.charAt(end) == ' ') {
      end-=2;
    }
    if (start > 0 || end < value.length() - 1) {
      value=value.substring(start,end + 1);
    }
  }
  value=stripInternalSpaces(value);
  return value;
}"
52515,"public void performTest() throws Exception {
  ietfUtilsTest();
  testEncodingPrintableString(BCStyle.C,""String_Node_Str"");
  testEncodingPrintableString(BCStyle.SERIALNUMBER,""String_Node_Str"");
  testEncodingPrintableString(BCStyle.DN_QUALIFIER,""String_Node_Str"");
  testEncodingIA5String(BCStyle.EmailAddress,""String_Node_Str"");
  testEncodingIA5String(BCStyle.DC,""String_Node_Str"");
  testEncodingGeneralizedTime(BCStyle.DATE_OF_BIRTH,""String_Node_Str"");
  testEncodingGeneralizedTime(BCStyle.DATE_OF_BIRTH,""String_Node_Str"");
  testEncodingUTF8String(BCStyle.CN,""String_Node_Str"");
  X500NameBuilder builder=new X500NameBuilder(BCStyle.INSTANCE);
  builder.addRDN(BCStyle.C,""String_Node_Str"");
  builder.addRDN(BCStyle.O,""String_Node_Str"");
  builder.addRDN(BCStyle.L,""String_Node_Str"");
  builder.addRDN(BCStyle.ST,""String_Node_Str"");
  builder.addRDN(BCStyle.E,""String_Node_Str"");
  X500Name name1=builder.build();
  if (!name1.equals(name1)) {
    fail(""String_Node_Str"");
  }
  builder=new X500NameBuilder(BCStyle.INSTANCE);
  builder.addRDN(BCStyle.C,""String_Node_Str"");
  builder.addRDN(BCStyle.O,""String_Node_Str"");
  builder.addRDN(BCStyle.L,""String_Node_Str"");
  builder.addRDN(BCStyle.ST,""String_Node_Str"");
  builder.addRDN(BCStyle.E,""String_Node_Str"");
  X500Name name2=builder.build();
  if (!name1.equals(name2)) {
    fail(""String_Node_Str"");
  }
  if (name1.hashCode() != name2.hashCode()) {
    fail(""String_Node_Str"");
  }
  X500NameBuilder builder1=new X500NameBuilder(BCStyle.INSTANCE);
  builder.addRDN(BCStyle.C,""String_Node_Str"");
  builder.addRDN(BCStyle.O,""String_Node_Str"");
  builder.addRDN(BCStyle.L,""String_Node_Str"");
  builder.addRDN(BCStyle.ST,""String_Node_Str"");
  builder.addRDN(BCStyle.E,""String_Node_Str"");
  X500NameBuilder builder2=new X500NameBuilder(BCStyle.INSTANCE);
  builder.addRDN(BCStyle.E,""String_Node_Str"");
  builder.addRDN(BCStyle.C,""String_Node_Str"");
  builder.addRDN(BCStyle.O,""String_Node_Str"");
  builder.addRDN(BCStyle.L,""String_Node_Str"");
  builder.addRDN(BCStyle.ST,""String_Node_Str"");
  name1=builder1.build();
  name2=builder2.build();
  if (!name1.equals(name2)) {
    fail(""String_Node_Str"");
  }
  if (name1.hashCode() != name2.hashCode()) {
    fail(""String_Node_Str"");
  }
  ByteArrayOutputStream bOut;
  ASN1OutputStream aOut;
  ASN1InputStream aIn;
  for (int i=0; i != subjects.length; i++) {
    X500Name name=new X500Name(subjects[i]);
    bOut=new ByteArrayOutputStream();
    aOut=new ASN1OutputStream(bOut);
    aOut.writeObject(name);
    aIn=new ASN1InputStream(new ByteArrayInputStream(bOut.toByteArray()));
    name=X500Name.getInstance(aIn.readObject());
    if (!name.toString().equals(subjects[i])) {
      fail(""String_Node_Str"" + i + ""String_Node_Str""+ name.toString()+ ""String_Node_Str""+ subjects[i]);
    }
  }
  for (int i=0; i < hexSubjects.length; i+=2) {
    X500Name name=new X500Name(hexSubjects[i]);
    bOut=new ByteArrayOutputStream();
    aOut=new ASN1OutputStream(bOut);
    aOut.writeObject(name);
    aIn=new ASN1InputStream(new ByteArrayInputStream(bOut.toByteArray()));
    name=X500Name.getInstance(aIn.readObject());
    if (!name.toString().equals(hexSubjects[i + 1])) {
      fail(""String_Node_Str"" + i + ""String_Node_Str""+ name.toString()+ ""String_Node_Str""+ subjects[i]);
    }
  }
  X500Name unsorted=new X500Name(""String_Node_Str"");
  if (!fromBytes(unsorted.getEncoded()).toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  unsorted=new X500Name(""String_Node_Str"");
  if (!fromBytes(unsorted.getEncoded()).toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  unsorted=new X500Name(""String_Node_Str"");
  if (!fromBytes(unsorted.getEncoded()).toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  unsorted=new X500Name(""String_Node_Str"");
  if (!fromBytes(unsorted.getEncoded()).toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  X500Name n1=new X500Name(""String_Node_Str"");
  X500Name n2=new X500Name(""String_Node_Str"");
  X500Name n3=new X500Name(""String_Node_Str"");
  equalityTest(n1,n2);
  equalityTest(n2,n3);
  equalityTest(n3,n1);
  n1=new X500Name(""String_Node_Str"");
  n2=new X500Name(""String_Node_Str"");
  n3=X500Name.getInstance(ASN1Primitive.fromByteArray(Hex.decode(""String_Node_Str"" + ""String_Node_Str"")));
  equalityTest(n1,n2);
  equalityTest(n2,n3);
  equalityTest(n3,n1);
  n1=new X500Name(""String_Node_Str"");
  n2=new X500Name(""String_Node_Str"");
  n1=new X500Name(""String_Node_Str"");
  n2=new X500Name(""String_Node_Str"");
  equalityTest(n1,n2);
  equalityTest(X500Name.getInstance(BCStrictStyle.INSTANCE,n1),X500Name.getInstance(BCStrictStyle.INSTANCE,n2));
  n2=new X500Name(""String_Node_Str"");
  equalityTest(n1,n2);
  if (X500Name.getInstance(BCStrictStyle.INSTANCE,n1).equals(X500Name.getInstance(BCStrictStyle.INSTANCE,n2))) {
    fail(""String_Node_Str"");
  }
  name1=new X500Name(""String_Node_Str"");
  if (name1.equals(new DERSequence())) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(new DERSequence(new DERSet()))) {
    fail(""String_Node_Str"");
  }
  ASN1EncodableVector v=new ASN1EncodableVector();
  v.add(new ASN1ObjectIdentifier(""String_Node_Str""));
  v.add(new ASN1ObjectIdentifier(""String_Node_Str""));
  if (name1.equals(new DERSequence(new DERSet(new DERSet(v))))) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(new DERSequence(new DERSet(new DERSet(v))))) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(new DERSequence(new DERSet(new DERSequence())))) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(new DERSequence(new DERSet(new DERSequence())))) {
    fail(""String_Node_Str"");
  }
  v=new ASN1EncodableVector();
  v.add(new ASN1ObjectIdentifier(""String_Node_Str""));
  v.add(new DERSequence());
  if (name1.equals(new DERSequence(new DERSet(new DERSequence(v))))) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(null)) {
    fail(""String_Node_Str"");
  }
  unsorted=new X500Name(""String_Node_Str"");
  ASN1ObjectIdentifier[] types=unsorted.getAttributeTypes();
  if (types.length != 3 || !types[0].equals(BCStyle.CN) || !types[1].equals(BCStyle.CN) || !types[2].equals(BCStyle.CN)) {
    fail(""String_Node_Str"");
  }
  X500Name nested=new X500Name(""String_Node_Str"");
  types=nested.getAttributeTypes();
  if (types.length != 3 || !types[0].equals(BCStyle.CN) || !types[1].equals(BCStyle.CN) || !types[2].equals(BCStyle.C)) {
    fail(""String_Node_Str"");
  }
  ASN1TaggedObject tag=new DERTaggedObject(false,1,new X500Name(""String_Node_Str""));
  if (!tag.isExplicit()) {
    fail(""String_Node_Str"");
  }
  X500Name name=X500Name.getInstance(tag,false);
  if (!name.equals(new X500Name(""String_Node_Str""))) {
    fail(""String_Node_Str"");
  }
  DERUTF8String testString=new DERUTF8String(""String_Node_Str"");
  byte[] encodedBytes=testString.getEncoded();
  byte[] hexEncodedBytes=Hex.encode(encodedBytes);
  String hexEncodedString=""String_Node_Str"" + new String(hexEncodedBytes);
  DERUTF8String converted=(DERUTF8String)new X509DefaultEntryConverter().getConvertedValue(BCStyle.L,hexEncodedString);
  if (!converted.equals(testString)) {
    fail(""String_Node_Str"");
  }
  converted=(DERUTF8String)new X509DefaultEntryConverter().getConvertedValue(BCStyle.L,""String_Node_Str"" + hexEncodedString);
  if (!converted.equals(new DERUTF8String(hexEncodedString))) {
    fail(""String_Node_Str"" + converted + ""String_Node_Str""+ hexEncodedString);
  }
  X500Name n=new X500Name(""String_Node_Str"");
  if (!n.toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  RDN[] vls=n.getRDNs(BCStyle.CN);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  types=n.getAttributeTypes();
  if (types.length != 1 || !types[0].equals(BCStyle.CN)) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.CN);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.CN);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  if (!n.toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.CN);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  if (!n.toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.TELEPHONE_NUMBER);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.TELEPHONE_NUMBER);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  if (!""String_Node_Str"".equals(BCStyle.INSTANCE.oidToDisplayName(BCStyle.EmailAddress))) {
    fail(""String_Node_Str"");
  }
  String[] aliases=BCStyle.INSTANCE.oidToAttrNames(BCStyle.EmailAddress);
  if (aliases.length != 2) {
    fail(""String_Node_Str"");
  }
  if (!(""String_Node_Str"".equals(aliases[0]) || ""String_Node_Str"".equals(aliases[1]))) {
    fail(""String_Node_Str"");
  }
  if (!(""String_Node_Str"".equals(aliases[0]) || ""String_Node_Str"".equals(aliases[1]))) {
    fail(""String_Node_Str"");
  }
  if (BCStyle.INSTANCE.oidToDisplayName(new ASN1ObjectIdentifier(""String_Node_Str"")) != null) {
    fail(""String_Node_Str"");
  }
  if (BCStyle.INSTANCE.oidToAttrNames(new ASN1ObjectIdentifier(""String_Node_Str"")).length != 0) {
    fail(""String_Node_Str"");
  }
}","public void performTest() throws Exception {
  ietfUtilsTest();
  testEncodingPrintableString(BCStyle.C,""String_Node_Str"");
  testEncodingPrintableString(BCStyle.SERIALNUMBER,""String_Node_Str"");
  testEncodingPrintableString(BCStyle.DN_QUALIFIER,""String_Node_Str"");
  testEncodingIA5String(BCStyle.EmailAddress,""String_Node_Str"");
  testEncodingIA5String(BCStyle.DC,""String_Node_Str"");
  testEncodingGeneralizedTime(BCStyle.DATE_OF_BIRTH,""String_Node_Str"");
  testEncodingGeneralizedTime(BCStyle.DATE_OF_BIRTH,""String_Node_Str"");
  testEncodingUTF8String(BCStyle.CN,""String_Node_Str"");
  X500NameBuilder builder=new X500NameBuilder(BCStyle.INSTANCE);
  builder.addRDN(BCStyle.C,""String_Node_Str"");
  builder.addRDN(BCStyle.O,""String_Node_Str"");
  builder.addRDN(BCStyle.L,""String_Node_Str"");
  builder.addRDN(BCStyle.ST,""String_Node_Str"");
  builder.addRDN(BCStyle.E,""String_Node_Str"");
  X500Name name1=builder.build();
  if (!name1.equals(name1)) {
    fail(""String_Node_Str"");
  }
  builder=new X500NameBuilder(BCStyle.INSTANCE);
  builder.addRDN(BCStyle.C,""String_Node_Str"");
  builder.addRDN(BCStyle.O,""String_Node_Str"");
  builder.addRDN(BCStyle.L,""String_Node_Str"");
  builder.addRDN(BCStyle.ST,""String_Node_Str"");
  builder.addRDN(BCStyle.E,""String_Node_Str"");
  X500Name name2=builder.build();
  if (!name1.equals(name2)) {
    fail(""String_Node_Str"");
  }
  if (name1.hashCode() != name2.hashCode()) {
    fail(""String_Node_Str"");
  }
  X500NameBuilder builder1=new X500NameBuilder(BCStyle.INSTANCE);
  builder.addRDN(BCStyle.C,""String_Node_Str"");
  builder.addRDN(BCStyle.O,""String_Node_Str"");
  builder.addRDN(BCStyle.L,""String_Node_Str"");
  builder.addRDN(BCStyle.ST,""String_Node_Str"");
  builder.addRDN(BCStyle.E,""String_Node_Str"");
  X500NameBuilder builder2=new X500NameBuilder(BCStyle.INSTANCE);
  builder.addRDN(BCStyle.E,""String_Node_Str"");
  builder.addRDN(BCStyle.C,""String_Node_Str"");
  builder.addRDN(BCStyle.O,""String_Node_Str"");
  builder.addRDN(BCStyle.L,""String_Node_Str"");
  builder.addRDN(BCStyle.ST,""String_Node_Str"");
  name1=builder1.build();
  name2=builder2.build();
  if (!name1.equals(name2)) {
    fail(""String_Node_Str"");
  }
  if (name1.hashCode() != name2.hashCode()) {
    fail(""String_Node_Str"");
  }
  ByteArrayOutputStream bOut;
  ASN1OutputStream aOut;
  ASN1InputStream aIn;
  for (int i=0; i != subjects.length; i++) {
    X500Name name=new X500Name(subjects[i]);
    bOut=new ByteArrayOutputStream();
    aOut=new ASN1OutputStream(bOut);
    aOut.writeObject(name);
    aIn=new ASN1InputStream(new ByteArrayInputStream(bOut.toByteArray()));
    name=X500Name.getInstance(aIn.readObject());
    if (!name.toString().equals(subjects[i])) {
      fail(""String_Node_Str"" + i + ""String_Node_Str""+ name.toString()+ ""String_Node_Str""+ subjects[i]);
    }
  }
  for (int i=0; i < hexSubjects.length; i+=2) {
    X500Name name=new X500Name(hexSubjects[i]);
    bOut=new ByteArrayOutputStream();
    aOut=new ASN1OutputStream(bOut);
    aOut.writeObject(name);
    aIn=new ASN1InputStream(new ByteArrayInputStream(bOut.toByteArray()));
    name=X500Name.getInstance(aIn.readObject());
    if (!name.toString().equals(hexSubjects[i + 1])) {
      fail(""String_Node_Str"" + i + ""String_Node_Str""+ name.toString()+ ""String_Node_Str""+ subjects[i]);
    }
  }
  X500Name unsorted=new X500Name(""String_Node_Str"");
  if (!fromBytes(unsorted.getEncoded()).toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  unsorted=new X500Name(""String_Node_Str"");
  if (!fromBytes(unsorted.getEncoded()).toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  unsorted=new X500Name(""String_Node_Str"");
  if (!fromBytes(unsorted.getEncoded()).toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  unsorted=new X500Name(""String_Node_Str"");
  if (!fromBytes(unsorted.getEncoded()).toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  equalityTest(new X500Name(""String_Node_Str""),new X500Name(""String_Node_Str""));
  X500Name n1=new X500Name(""String_Node_Str"");
  X500Name n2=new X500Name(""String_Node_Str"");
  X500Name n3=new X500Name(""String_Node_Str"");
  equalityTest(n1,n2);
  equalityTest(n2,n3);
  equalityTest(n3,n1);
  n1=new X500Name(""String_Node_Str"");
  n2=new X500Name(""String_Node_Str"");
  n3=X500Name.getInstance(ASN1Primitive.fromByteArray(Hex.decode(""String_Node_Str"" + ""String_Node_Str"")));
  equalityTest(n1,n2);
  equalityTest(n2,n3);
  equalityTest(n3,n1);
  n1=new X500Name(""String_Node_Str"");
  n2=new X500Name(""String_Node_Str"");
  n1=new X500Name(""String_Node_Str"");
  n2=new X500Name(""String_Node_Str"");
  equalityTest(n1,n2);
  equalityTest(X500Name.getInstance(BCStrictStyle.INSTANCE,n1),X500Name.getInstance(BCStrictStyle.INSTANCE,n2));
  n2=new X500Name(""String_Node_Str"");
  equalityTest(n1,n2);
  if (X500Name.getInstance(BCStrictStyle.INSTANCE,n1).equals(X500Name.getInstance(BCStrictStyle.INSTANCE,n2))) {
    fail(""String_Node_Str"");
  }
  name1=new X500Name(""String_Node_Str"");
  if (name1.equals(new DERSequence())) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(new DERSequence(new DERSet()))) {
    fail(""String_Node_Str"");
  }
  ASN1EncodableVector v=new ASN1EncodableVector();
  v.add(new ASN1ObjectIdentifier(""String_Node_Str""));
  v.add(new ASN1ObjectIdentifier(""String_Node_Str""));
  if (name1.equals(new DERSequence(new DERSet(new DERSet(v))))) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(new DERSequence(new DERSet(new DERSet(v))))) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(new DERSequence(new DERSet(new DERSequence())))) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(new DERSequence(new DERSet(new DERSequence())))) {
    fail(""String_Node_Str"");
  }
  v=new ASN1EncodableVector();
  v.add(new ASN1ObjectIdentifier(""String_Node_Str""));
  v.add(new DERSequence());
  if (name1.equals(new DERSequence(new DERSet(new DERSequence(v))))) {
    fail(""String_Node_Str"");
  }
  if (name1.equals(null)) {
    fail(""String_Node_Str"");
  }
  unsorted=new X500Name(""String_Node_Str"");
  ASN1ObjectIdentifier[] types=unsorted.getAttributeTypes();
  if (types.length != 3 || !types[0].equals(BCStyle.CN) || !types[1].equals(BCStyle.CN) || !types[2].equals(BCStyle.CN)) {
    fail(""String_Node_Str"");
  }
  X500Name nested=new X500Name(""String_Node_Str"");
  types=nested.getAttributeTypes();
  if (types.length != 3 || !types[0].equals(BCStyle.CN) || !types[1].equals(BCStyle.CN) || !types[2].equals(BCStyle.C)) {
    fail(""String_Node_Str"");
  }
  ASN1TaggedObject tag=new DERTaggedObject(false,1,new X500Name(""String_Node_Str""));
  if (!tag.isExplicit()) {
    fail(""String_Node_Str"");
  }
  X500Name name=X500Name.getInstance(tag,false);
  if (!name.equals(new X500Name(""String_Node_Str""))) {
    fail(""String_Node_Str"");
  }
  DERUTF8String testString=new DERUTF8String(""String_Node_Str"");
  byte[] encodedBytes=testString.getEncoded();
  byte[] hexEncodedBytes=Hex.encode(encodedBytes);
  String hexEncodedString=""String_Node_Str"" + new String(hexEncodedBytes);
  DERUTF8String converted=(DERUTF8String)new X509DefaultEntryConverter().getConvertedValue(BCStyle.L,hexEncodedString);
  if (!converted.equals(testString)) {
    fail(""String_Node_Str"");
  }
  converted=(DERUTF8String)new X509DefaultEntryConverter().getConvertedValue(BCStyle.L,""String_Node_Str"" + hexEncodedString);
  if (!converted.equals(new DERUTF8String(hexEncodedString))) {
    fail(""String_Node_Str"" + converted + ""String_Node_Str""+ hexEncodedString);
  }
  X500Name n=new X500Name(""String_Node_Str"");
  if (!n.toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  RDN[] vls=n.getRDNs(BCStyle.CN);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  types=n.getAttributeTypes();
  if (types.length != 1 || !types[0].equals(BCStyle.CN)) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.CN);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.CN);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  if (!n.toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.CN);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  if (!n.toString().equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.TELEPHONE_NUMBER);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  n=new X500Name(""String_Node_Str"");
  vls=n.getRDNs(BCStyle.TELEPHONE_NUMBER);
  if (vls.length != 1 || !getValue(vls[0]).equals(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  if (!""String_Node_Str"".equals(BCStyle.INSTANCE.oidToDisplayName(BCStyle.EmailAddress))) {
    fail(""String_Node_Str"");
  }
  String[] aliases=BCStyle.INSTANCE.oidToAttrNames(BCStyle.EmailAddress);
  if (aliases.length != 2) {
    fail(""String_Node_Str"");
  }
  if (!(""String_Node_Str"".equals(aliases[0]) || ""String_Node_Str"".equals(aliases[1]))) {
    fail(""String_Node_Str"");
  }
  if (!(""String_Node_Str"".equals(aliases[0]) || ""String_Node_Str"".equals(aliases[1]))) {
    fail(""String_Node_Str"");
  }
  if (BCStyle.INSTANCE.oidToDisplayName(new ASN1ObjectIdentifier(""String_Node_Str"")) != null) {
    fail(""String_Node_Str"");
  }
  if (BCStyle.INSTANCE.oidToAttrNames(new ASN1ObjectIdentifier(""String_Node_Str"")).length != 0) {
    fail(""String_Node_Str"");
  }
  if (!new X500Name(""String_Node_Str"").equals(new X500Name(""String_Node_Str""))) {
    fail(""String_Node_Str"");
  }
}"
52516,"public void testSimpleTests(){
  org.bouncycastle.util.test.Test[] tests=new org.bouncycastle.util.test.Test[]{new CertTest(),new DANETest(),new PKCS10Test(),new AttrCertSelectorTest(),new AttrCertTest(),new X509ExtensionUtilsTest()};
  for (int i=0; i != tests.length; i++) {
    SimpleTestResult result=(SimpleTestResult)tests[i].perform();
    if (!result.isSuccessful()) {
      if (result.getException() != null) {
        result.getException().printStackTrace();
      }
      fail(result.toString());
    }
  }
}","public void testSimpleTests(){
  org.bouncycastle.util.test.Test[] tests=new org.bouncycastle.util.test.Test[]{new CertTest(),new DANETest(),new PKCS10Test(),new AttrCertSelectorTest(),new AttrCertTest(),new X509ExtensionUtilsTest(),new CertPathLoopTest()};
  for (int i=0; i != tests.length; i++) {
    SimpleTestResult result=(SimpleTestResult)tests[i].perform();
    if (!result.isSuccessful()) {
      if (result.getException() != null) {
        result.getException().printStackTrace();
      }
      fail(result.toString());
    }
  }
}"
52517,"private DRBGTestVector[] createTestVectorData(){
  return new DRBGTestVector[]{new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),false,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),false,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),false,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),false,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),true,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),true,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),true,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),true,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),192,new Bit320EntropyProvider().get(320),false,""String_Node_Str"",192,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),192,new Bit320EntropyProvider().get(320),true,""String_Node_Str"",192,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),false,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),true,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),true,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),true,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str"")};
}","private DRBGTestVector[] createTestVectorData(){
  return new DRBGTestVector[]{new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),false,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),false,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),false,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),false,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),true,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),true,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),true,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new DESedeEngine(),168,new Bit232EntropyProvider().get(232),true,""String_Node_Str"",112,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),128,new Bit256EntropyProvider().get(256),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),192,new Bit320EntropyProvider().get(320),false,""String_Node_Str"",192,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),192,new Bit320EntropyProvider().get(320),true,""String_Node_Str"",192,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),false,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),true,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),true,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),true,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new AESFastEngine(),256,new Bit384EntropyProvider().get(384),true,""String_Node_Str"",256,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str"")};
}"
52518,"/** 
 * Populate a passed in array with random data.
 * @param output output array for generated bits.
 * @param additionalInput additional input to be added to the DRBG in this step.
 * @param predictionResistant true if a reseed should be forced, false otherwise.
 * @return number of bits generated, -1 if a reseed required.
 */
public int generate(byte[] output,byte[] additionalInput,boolean predictionResistant){
  if (_isTDEA) {
    if (_reseedCounter > TDEA_RESEED_MAX) {
      return -1;
    }
    if (Utils.isTooLarge(output,TDEA_MAX_BITS_REQUEST / 8)) {
      throw new IllegalArgumentException(""String_Node_Str"" + TDEA_MAX_BITS_REQUEST);
    }
  }
 else {
    if (_reseedCounter > AES_RESEED_MAX) {
      return -1;
    }
    if (Utils.isTooLarge(output,AES_MAX_BITS_REQUEST / 8)) {
      throw new IllegalArgumentException(""String_Node_Str"" + AES_MAX_BITS_REQUEST);
    }
  }
  if (predictionResistant) {
    CTR_DRBG_Reseed_algorithm(_entropySource,additionalInput);
    additionalInput=null;
  }
  if (additionalInput != null) {
    additionalInput=Block_Cipher_df(additionalInput,_seedLength);
    CTR_DRBG_Update(additionalInput,_Key,_V);
  }
 else {
    additionalInput=new byte[_seedLength];
  }
  byte[] out=new byte[_V.length];
  _engine.init(true,new KeyParameter(expandKey(_Key)));
  for (int i=0; i <= output.length / out.length; i++) {
    addOneTo(_V);
    _engine.processBlock(_V,0,out,0);
    int bytesToCopy=((output.length - i * out.length) > out.length) ? out.length : (output.length - i * _V.length);
    System.arraycopy(out,0,output,i * out.length,bytesToCopy);
  }
  CTR_DRBG_Update(additionalInput,_Key,_V);
  _reseedCounter++;
  return output.length * 8;
}","/** 
 * Populate a passed in array with random data.
 * @param output output array for generated bits.
 * @param additionalInput additional input to be added to the DRBG in this step.
 * @param predictionResistant true if a reseed should be forced, false otherwise.
 * @return number of bits generated, -1 if a reseed required.
 */
public int generate(byte[] output,byte[] additionalInput,boolean predictionResistant){
  if (_isTDEA) {
    if (_reseedCounter > TDEA_RESEED_MAX) {
      return -1;
    }
    if (Utils.isTooLarge(output,TDEA_MAX_BITS_REQUEST / 8)) {
      throw new IllegalArgumentException(""String_Node_Str"" + TDEA_MAX_BITS_REQUEST);
    }
  }
 else {
    if (_reseedCounter > AES_RESEED_MAX) {
      return -1;
    }
    if (Utils.isTooLarge(output,AES_MAX_BITS_REQUEST / 8)) {
      throw new IllegalArgumentException(""String_Node_Str"" + AES_MAX_BITS_REQUEST);
    }
  }
  if (predictionResistant) {
    CTR_DRBG_Reseed_algorithm(_entropySource,additionalInput);
    additionalInput=null;
  }
  if (additionalInput != null) {
    additionalInput=Block_Cipher_df(additionalInput,_seedLength);
    CTR_DRBG_Update(additionalInput,_Key,_V);
  }
 else {
    additionalInput=new byte[_seedLength];
  }
  byte[] out=new byte[_V.length];
  _engine.init(true,new KeyParameter(expandKey(_Key)));
  for (int i=0; i <= output.length / out.length; i++) {
    int bytesToCopy=((output.length - i * out.length) > out.length) ? out.length : (output.length - i * _V.length);
    if (bytesToCopy != 0) {
      addOneTo(_V);
      _engine.processBlock(_V,0,out,0);
      System.arraycopy(out,0,output,i * out.length,bytesToCopy);
    }
  }
  CTR_DRBG_Update(additionalInput,_Key,_V);
  _reseedCounter++;
  return output.length * 8;
}"
52519,"/** 
 * Populate a passed in array with random data.
 * @param output output array for generated bits.
 * @param additionalInput additional input to be added to the DRBG in this step.
 * @param predictionResistant true if a reseed should be forced, false otherwise.
 * @return number of bits generated, -1 if a reseed required.
 */
public int generate(byte[] output,byte[] additionalInput,boolean predictionResistant){
  if (_isTDEA) {
    if (_reseedCounter > TDEA_RESEED_MAX) {
      return -1;
    }
    if (Utils.isTooLarge(output,TDEA_MAX_BITS_REQUEST / 8)) {
      throw new IllegalArgumentException(""String_Node_Str"" + TDEA_MAX_BITS_REQUEST);
    }
  }
 else {
    if (_reseedCounter > AES_RESEED_MAX) {
      return -1;
    }
    if (Utils.isTooLarge(output,AES_MAX_BITS_REQUEST / 8)) {
      throw new IllegalArgumentException(""String_Node_Str"" + AES_MAX_BITS_REQUEST);
    }
  }
  if (predictionResistant) {
    CTR_DRBG_Reseed_algorithm(_entropySource,additionalInput);
    additionalInput=null;
  }
  if (additionalInput != null) {
    additionalInput=Block_Cipher_df(additionalInput,_seedLength);
    CTR_DRBG_Update(additionalInput,_Key,_V);
  }
 else {
    additionalInput=new byte[_seedLength];
  }
  byte[] out=new byte[_V.length];
  _engine.init(true,new KeyParameter(expandKey(_Key)));
  for (int i=0; i < output.length / out.length; i++) {
    addOneTo(_V);
    _engine.processBlock(_V,0,out,0);
    int bytesToCopy=((output.length - i * out.length) > out.length) ? out.length : (output.length - i * _V.length);
    System.arraycopy(out,0,output,i * out.length,bytesToCopy);
  }
  CTR_DRBG_Update(additionalInput,_Key,_V);
  _reseedCounter++;
  return output.length * 8;
}","/** 
 * Populate a passed in array with random data.
 * @param output output array for generated bits.
 * @param additionalInput additional input to be added to the DRBG in this step.
 * @param predictionResistant true if a reseed should be forced, false otherwise.
 * @return number of bits generated, -1 if a reseed required.
 */
public int generate(byte[] output,byte[] additionalInput,boolean predictionResistant){
  if (_isTDEA) {
    if (_reseedCounter > TDEA_RESEED_MAX) {
      return -1;
    }
    if (Utils.isTooLarge(output,TDEA_MAX_BITS_REQUEST / 8)) {
      throw new IllegalArgumentException(""String_Node_Str"" + TDEA_MAX_BITS_REQUEST);
    }
  }
 else {
    if (_reseedCounter > AES_RESEED_MAX) {
      return -1;
    }
    if (Utils.isTooLarge(output,AES_MAX_BITS_REQUEST / 8)) {
      throw new IllegalArgumentException(""String_Node_Str"" + AES_MAX_BITS_REQUEST);
    }
  }
  if (predictionResistant) {
    CTR_DRBG_Reseed_algorithm(_entropySource,additionalInput);
    additionalInput=null;
  }
  if (additionalInput != null) {
    additionalInput=Block_Cipher_df(additionalInput,_seedLength);
    CTR_DRBG_Update(additionalInput,_Key,_V);
  }
 else {
    additionalInput=new byte[_seedLength];
  }
  byte[] out=new byte[_V.length];
  _engine.init(true,new KeyParameter(expandKey(_Key)));
  for (int i=0; i <= output.length / out.length; i++) {
    addOneTo(_V);
    _engine.processBlock(_V,0,out,0);
    int bytesToCopy=((output.length - i * out.length) > out.length) ? out.length : (output.length - i * _V.length);
    System.arraycopy(out,0,output,i * out.length,bytesToCopy);
  }
  CTR_DRBG_Update(additionalInput,_Key,_V);
  _reseedCounter++;
  return output.length * 8;
}"
52520,"public byte[] unwrap(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  if (forWrapping) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int n=inLen / 8;
  if ((n * 8) != inLen) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  if (n == 1) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  byte[] relevantCiphertext=new byte[inLen];
  System.arraycopy(in,inOff,relevantCiphertext,0,inLen);
  byte[] decrypted=new byte[inLen];
  byte[] paddedPlaintext;
  if (n == 2) {
    engine.init(false,param);
    for (int i=0; i < relevantCiphertext.length; i+=engine.getBlockSize()) {
      engine.processBlock(relevantCiphertext,i,decrypted,i);
    }
    extractedAIV=new byte[8];
    System.arraycopy(decrypted,0,extractedAIV,0,extractedAIV.length);
    paddedPlaintext=new byte[decrypted.length - extractedAIV.length];
    System.arraycopy(decrypted,extractedAIV.length,paddedPlaintext,0,paddedPlaintext.length);
  }
 else {
    decrypted=rfc3394UnwrapNoIvCheck(in,inOff,inLen);
    paddedPlaintext=decrypted;
  }
  byte[] extractedHighOrderAIV=new byte[4];
  byte[] mliBytes=new byte[4];
  System.arraycopy(extractedAIV,0,extractedHighOrderAIV,0,extractedHighOrderAIV.length);
  System.arraycopy(extractedAIV,extractedHighOrderAIV.length,mliBytes,0,mliBytes.length);
  int mli=Pack.bigEndianToInt(mliBytes,0);
  boolean isValid=true;
  if (!Arrays.constantTimeAreEqual(extractedHighOrderAIV,preIV)) {
    isValid=false;
  }
  int upperBound=paddedPlaintext.length;
  int lowerBound=upperBound - 8;
  if (mli <= lowerBound) {
    isValid=false;
  }
  if (mli > upperBound) {
    isValid=false;
  }
  int expectedZeros=upperBound - mli;
  byte[] zeros=new byte[expectedZeros];
  byte[] pad=new byte[expectedZeros];
  System.arraycopy(paddedPlaintext,paddedPlaintext.length - expectedZeros,pad,0,expectedZeros);
  if (!Arrays.constantTimeAreEqual(pad,zeros)) {
    isValid=false;
  }
  byte[] plaintext=new byte[mli];
  System.arraycopy(paddedPlaintext,0,plaintext,0,plaintext.length);
  if (!isValid) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  return plaintext;
}","public byte[] unwrap(byte[] in,int inOff,int inLen) throws InvalidCipherTextException {
  if (forWrapping) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int n=inLen / 8;
  if ((n * 8) != inLen) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  if (n == 1) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  byte[] relevantCiphertext=new byte[inLen];
  System.arraycopy(in,inOff,relevantCiphertext,0,inLen);
  byte[] decrypted=new byte[inLen];
  byte[] paddedPlaintext;
  if (n == 2) {
    engine.init(false,param);
    for (int i=0; i < relevantCiphertext.length; i+=engine.getBlockSize()) {
      engine.processBlock(relevantCiphertext,i,decrypted,i);
    }
    extractedAIV=new byte[8];
    System.arraycopy(decrypted,0,extractedAIV,0,extractedAIV.length);
    paddedPlaintext=new byte[decrypted.length - extractedAIV.length];
    System.arraycopy(decrypted,extractedAIV.length,paddedPlaintext,0,paddedPlaintext.length);
  }
 else {
    decrypted=rfc3394UnwrapNoIvCheck(in,inOff,inLen);
    paddedPlaintext=decrypted;
  }
  byte[] extractedHighOrderAIV=new byte[4];
  byte[] mliBytes=new byte[4];
  System.arraycopy(extractedAIV,0,extractedHighOrderAIV,0,extractedHighOrderAIV.length);
  System.arraycopy(extractedAIV,extractedHighOrderAIV.length,mliBytes,0,mliBytes.length);
  int mli=Pack.bigEndianToInt(mliBytes,0);
  boolean isValid=true;
  if (!Arrays.constantTimeAreEqual(extractedHighOrderAIV,preIV)) {
    isValid=false;
  }
  int upperBound=paddedPlaintext.length;
  int lowerBound=upperBound - 8;
  if (mli <= lowerBound) {
    isValid=false;
  }
  if (mli > upperBound) {
    isValid=false;
  }
  int expectedZeros=upperBound - mli;
  if (expectedZeros >= paddedPlaintext.length) {
    isValid=false;
    expectedZeros=paddedPlaintext.length;
  }
  byte[] zeros=new byte[expectedZeros];
  byte[] pad=new byte[expectedZeros];
  System.arraycopy(paddedPlaintext,paddedPlaintext.length - expectedZeros,pad,0,expectedZeros);
  if (!Arrays.constantTimeAreEqual(pad,zeros)) {
    isValid=false;
  }
  if (!isValid) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  byte[] plaintext=new byte[mli];
  System.arraycopy(paddedPlaintext,0,plaintext,0,plaintext.length);
  return plaintext;
}"
52521,"private TestResult wrapTest(int id,byte[] kek,byte[] in,byte[] out){
  Wrapper wrapper=new AESWrapEngine();
  wrapper.init(true,new KeyParameter(kek));
  try {
    byte[] cText=wrapper.wrap(in,0,in.length);
    if (!Arrays.areEqual(cText,out)) {
      return new SimpleTestResult(false,getName() + ""String_Node_Str"" + id+ ""String_Node_Str""+ new String(Hex.encode(out))+ ""String_Node_Str""+ new String(Hex.encode(cText)));
    }
  }
 catch (  Exception e) {
    return new SimpleTestResult(false,getName() + ""String_Node_Str"" + e.toString());
  }
  wrapper.init(false,new KeyParameter(kek));
  try {
    byte[] pText=wrapper.unwrap(out,0,out.length);
    if (!Arrays.areEqual(pText,in)) {
      return new SimpleTestResult(false,getName() + ""String_Node_Str"" + id+ ""String_Node_Str""+ new String(Hex.encode(in))+ ""String_Node_Str""+ new String(Hex.encode(pText)));
    }
  }
 catch (  Exception e) {
    return new SimpleTestResult(false,getName() + ""String_Node_Str"",e);
  }
  byte[] pText=new byte[5 + in.length];
  byte[] cText;
  System.arraycopy(in,0,pText,5,in.length);
  wrapper.init(true,new KeyParameter(kek));
  try {
    cText=wrapper.wrap(pText,5,in.length);
    if (!Arrays.areEqual(cText,out)) {
      return new SimpleTestResult(false,getName() + ""String_Node_Str"" + id+ ""String_Node_Str""+ new String(Hex.encode(out))+ ""String_Node_Str""+ new String(Hex.encode(cText)));
    }
  }
 catch (  Exception e) {
    return new SimpleTestResult(false,getName() + ""String_Node_Str"" + e.toString());
  }
  wrapper.init(false,new KeyParameter(kek));
  cText=new byte[6 + out.length];
  System.arraycopy(out,0,cText,6,out.length);
  try {
    pText=wrapper.unwrap(cText,6,out.length);
    if (!Arrays.areEqual(pText,in)) {
      return new SimpleTestResult(false,getName() + ""String_Node_Str"" + id+ ""String_Node_Str""+ new String(Hex.encode(in))+ ""String_Node_Str""+ new String(Hex.encode(pText)));
    }
  }
 catch (  Exception e) {
    return new SimpleTestResult(false,getName() + ""String_Node_Str"",e);
  }
  return new SimpleTestResult(true,getName() + ""String_Node_Str"");
}","private void wrapTest(int id,byte[] kek,byte[] in,byte[] out){
  Wrapper wrapper=new AESWrapEngine();
  wrapper.init(true,new KeyParameter(kek));
  try {
    byte[] cText=wrapper.wrap(in,0,in.length);
    if (!Arrays.areEqual(cText,out)) {
      fail(""String_Node_Str"" + id + ""String_Node_Str""+ new String(Hex.encode(out))+ ""String_Node_Str""+ new String(Hex.encode(cText)));
    }
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString());
  }
  wrapper.init(false,new KeyParameter(kek));
  try {
    byte[] pText=wrapper.unwrap(out,0,out.length);
    if (!Arrays.areEqual(pText,in)) {
      fail(""String_Node_Str"" + id + ""String_Node_Str""+ new String(Hex.encode(in))+ ""String_Node_Str""+ new String(Hex.encode(pText)));
    }
  }
 catch (  Exception e) {
    fail(""String_Node_Str"",e);
  }
  byte[] pText=new byte[5 + in.length];
  byte[] cText;
  System.arraycopy(in,0,pText,5,in.length);
  wrapper.init(true,new KeyParameter(kek));
  try {
    cText=wrapper.wrap(pText,5,in.length);
    if (!Arrays.areEqual(cText,out)) {
      fail(""String_Node_Str"" + id + ""String_Node_Str""+ new String(Hex.encode(out))+ ""String_Node_Str""+ new String(Hex.encode(cText)));
    }
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e.toString());
  }
  wrapper.init(false,new KeyParameter(kek));
  cText=new byte[6 + out.length];
  System.arraycopy(out,0,cText,6,out.length);
  try {
    pText=wrapper.unwrap(cText,6,out.length);
    if (!Arrays.areEqual(pText,in)) {
      fail(""String_Node_Str"" + id + ""String_Node_Str""+ new String(Hex.encode(in))+ ""String_Node_Str""+ new String(Hex.encode(pText)));
    }
  }
 catch (  Exception e) {
    fail(""String_Node_Str"",e);
  }
}"
52522,"public void encode(OutputStream out) throws IOException {
  int bodyLen=data.length + 1;
  if (bodyLen < 192) {
    out.write((byte)bodyLen);
  }
 else   if (bodyLen <= 8383) {
    bodyLen-=192;
    out.write((byte)(((bodyLen >> 8) & 0xff) + 192));
    out.write((byte)bodyLen);
  }
 else {
    out.write(0xff);
    out.write((byte)(bodyLen >> 24));
    out.write((byte)(bodyLen >> 16));
    out.write((byte)(bodyLen >> 8));
    out.write((byte)bodyLen);
  }
  out.write(type);
  out.write(data);
}","public void encode(OutputStream out) throws IOException {
  int bodyLen=data.length + 1;
  if (bodyLen < 192 && !longLength) {
    out.write((byte)bodyLen);
  }
 else   if (bodyLen <= 8383 && !longLength) {
    bodyLen-=192;
    out.write((byte)(((bodyLen >> 8) & 0xff) + 192));
    out.write((byte)bodyLen);
  }
 else {
    out.write(0xff);
    out.write((byte)(bodyLen >> 24));
    out.write((byte)(bodyLen >> 16));
    out.write((byte)(bodyLen >> 8));
    out.write((byte)bodyLen);
  }
  out.write(type);
  out.write(data);
}"
52523,"protected UserAttributeSubpacket(int type,byte[] data){
  this.type=type;
  this.data=data;
}","protected UserAttributeSubpacket(int type,boolean forceLongLength,byte[] data){
  this.type=type;
  this.longLength=forceLongLength;
  this.data=data;
}"
52524,"public UserAttributeSubpacket readPacket() throws IOException {
  int l=this.read();
  int bodyLen=0;
  if (l < 0) {
    return null;
  }
  if (l < 192) {
    bodyLen=l;
  }
 else   if (l <= 223) {
    bodyLen=((l - 192) << 8) + (in.read()) + 192;
  }
 else   if (l == 255) {
    bodyLen=(in.read() << 24) | (in.read() << 16) | (in.read() << 8)| in.read();
  }
 else {
  }
  int tag=in.read();
  if (tag < 0) {
    throw new EOFException(""String_Node_Str"");
  }
  byte[] data=new byte[bodyLen - 1];
  this.readFully(data,0,data.length);
  int type=tag;
switch (type) {
case IMAGE_ATTRIBUTE:
    return new ImageAttribute(data);
}
return new UserAttributeSubpacket(type,data);
}","public UserAttributeSubpacket readPacket() throws IOException {
  int l=this.read();
  int bodyLen=0;
  boolean longLength=false;
  if (l < 0) {
    return null;
  }
  if (l < 192) {
    bodyLen=l;
  }
 else   if (l <= 223) {
    bodyLen=((l - 192) << 8) + (in.read()) + 192;
  }
 else   if (l == 255) {
    bodyLen=(in.read() << 24) | (in.read() << 16) | (in.read() << 8)| in.read();
    longLength=true;
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  int tag=in.read();
  if (tag < 0) {
    throw new EOFException(""String_Node_Str"");
  }
  byte[] data=new byte[bodyLen - 1];
  this.readFully(data,0,data.length);
  int type=tag;
switch (type) {
case IMAGE_ATTRIBUTE:
    return new ImageAttribute(longLength,data);
}
return new UserAttributeSubpacket(type,longLength,data);
}"
52525,"public static void reduce(int[] xx,int[] z){
  int xx07=xx[7];
  Nat.shiftUpBit(8,xx,8,xx07,z,0);
  int c=Nat256.mulByWordAddTo(PInv,xx,z) << 1;
  int z7=z[7];
  c+=(z7 >> 31) - (xx07 >> 31);
  z7&=P7;
  z7+=Nat.addWordTo(7,c * PInv,z);
  z[7]=z7;
  if (Nat256.gte(z,P)) {
    subPFrom(z);
  }
}","public static void reduce(int[] xx,int[] z){
  int xx07=xx[7];
  Nat.shiftUpBit(8,xx,8,xx07,z,0);
  int c=Nat256.mulByWordAddTo(PInv,xx,z) << 1;
  int z7=z[7];
  c+=(z7 >>> 31) - (xx07 >>> 31);
  z7&=P7;
  z7+=Nat.addWordTo(7,c * PInv,z);
  z[7]=z7;
  if (Nat256.gte(z,P)) {
    subPFrom(z);
  }
}"
52526,"public void performTest() throws IOException {
  SubjectPublicKeyInfo pubInfo=SubjectPublicKeyInfo.getInstance(ASN1Primitive.fromByteArray(pubKeyInfo));
  SubjectKeyIdentifier ski=SubjectKeyIdentifier.createSHA1KeyIdentifier(pubInfo);
  if (!Arrays.areEqual(shaID,ski.getKeyIdentifier())) {
    fail(""String_Node_Str"");
  }
  ski=SubjectKeyIdentifier.createTruncatedSHA1KeyIdentifier(pubInfo);
  if (!Arrays.areEqual(shaTruncID,ski.getKeyIdentifier())) {
    fail(""String_Node_Str"");
  }
}","public void performTest() throws IOException {
}"
52527,"private SubjectKeyIdentifier createSubjectKeyId(PublicKey pubKey){
  try {
    SubjectPublicKeyInfo info=new SubjectPublicKeyInfo((ASN1Sequence)ASN1Primitive.fromByteArray(pubKey.getEncoded()));
    return new SubjectKeyIdentifier(info);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","private SubjectKeyIdentifier createSubjectKeyId(PublicKey pubKey){
  try {
    SubjectPublicKeyInfo info=new SubjectPublicKeyInfo((ASN1Sequence)ASN1Primitive.fromByteArray(pubKey.getEncoded()));
    return new SubjectKeyIdentifier(getDigest(info));
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
52528,"private void tbsV3CertGen() throws IOException {
  V3TBSCertificateGenerator gen=new V3TBSCertificateGenerator();
  Date startDate=new Date(1000);
  Date endDate=new Date(2000);
  gen.setSerialNumber(new ASN1Integer(2));
  gen.setStartDate(new Time(startDate));
  gen.setEndDate(new Time(endDate));
  gen.setIssuer(new X500Name(""String_Node_Str""));
  gen.setSubject(new X500Name(""String_Node_Str""));
  gen.setSignature(new AlgorithmIdentifier(PKCSObjectIdentifiers.md5WithRSAEncryption,DERNull.INSTANCE));
  SubjectPublicKeyInfo info=new SubjectPublicKeyInfo(new AlgorithmIdentifier(OIWObjectIdentifiers.elGamalAlgorithm,new ElGamalParameter(BigInteger.valueOf(1),BigInteger.valueOf(2))),new ASN1Integer(3));
  gen.setSubjectPublicKeyInfo(info);
  Vector order=new Vector();
  Hashtable extensions=new Hashtable();
  order.addElement(X509Extension.authorityKeyIdentifier);
  order.addElement(X509Extension.subjectKeyIdentifier);
  order.addElement(X509Extension.keyUsage);
  extensions.put(X509Extension.authorityKeyIdentifier,new X509Extension(true,new DEROctetString(createAuthorityKeyId(info,new X500Name(""String_Node_Str""),2))));
  extensions.put(X509Extension.subjectKeyIdentifier,new X509Extension(true,new DEROctetString(new SubjectKeyIdentifier(info))));
  extensions.put(X509Extension.keyUsage,new X509Extension(false,new DEROctetString(new KeyUsage(KeyUsage.dataEncipherment))));
  X509Extensions ex=new X509Extensions(order,extensions);
  gen.setExtensions(ex);
  TBSCertificate tbs=gen.generateTBSCertificate();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  ASN1OutputStream aOut=new ASN1OutputStream(bOut);
  aOut.writeObject(tbs);
  if (!Arrays.areEqual(bOut.toByteArray(),v3Cert)) {
    fail(""String_Node_Str"");
  }
  ASN1InputStream aIn=new ASN1InputStream(new ByteArrayInputStream(v3Cert));
  ASN1Primitive o=aIn.readObject();
  bOut=new ByteArrayOutputStream();
  aOut=new ASN1OutputStream(bOut);
  aOut.writeObject(o);
  if (!Arrays.areEqual(bOut.toByteArray(),v3Cert)) {
    fail(""String_Node_Str"");
  }
}","private void tbsV3CertGen() throws IOException {
  V3TBSCertificateGenerator gen=new V3TBSCertificateGenerator();
  Date startDate=new Date(1000);
  Date endDate=new Date(2000);
  gen.setSerialNumber(new ASN1Integer(2));
  gen.setStartDate(new Time(startDate));
  gen.setEndDate(new Time(endDate));
  gen.setIssuer(new X500Name(""String_Node_Str""));
  gen.setSubject(new X500Name(""String_Node_Str""));
  gen.setSignature(new AlgorithmIdentifier(PKCSObjectIdentifiers.md5WithRSAEncryption,DERNull.INSTANCE));
  SubjectPublicKeyInfo info=new SubjectPublicKeyInfo(new AlgorithmIdentifier(OIWObjectIdentifiers.elGamalAlgorithm,new ElGamalParameter(BigInteger.valueOf(1),BigInteger.valueOf(2))),new ASN1Integer(3));
  gen.setSubjectPublicKeyInfo(info);
  Vector order=new Vector();
  Hashtable extensions=new Hashtable();
  order.addElement(X509Extension.authorityKeyIdentifier);
  order.addElement(X509Extension.subjectKeyIdentifier);
  order.addElement(X509Extension.keyUsage);
  extensions.put(X509Extension.authorityKeyIdentifier,new X509Extension(true,new DEROctetString(createAuthorityKeyId(info,new X500Name(""String_Node_Str""),2))));
  extensions.put(X509Extension.subjectKeyIdentifier,new X509Extension(true,new DEROctetString(new SubjectKeyIdentifier(new byte[20]))));
  extensions.put(X509Extension.keyUsage,new X509Extension(false,new DEROctetString(new KeyUsage(KeyUsage.dataEncipherment))));
  X509Extensions ex=new X509Extensions(order,extensions);
  gen.setExtensions(ex);
  TBSCertificate tbs=gen.generateTBSCertificate();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  ASN1OutputStream aOut=new ASN1OutputStream(bOut);
  aOut.writeObject(tbs);
  if (!Arrays.areEqual(bOut.toByteArray(),v3Cert)) {
    fail(""String_Node_Str"");
  }
  ASN1InputStream aIn=new ASN1InputStream(new ByteArrayInputStream(v3Cert));
  ASN1Primitive o=aIn.readObject();
  bOut=new ByteArrayOutputStream();
  aOut=new ASN1OutputStream(bOut);
  aOut.writeObject(o);
  if (!Arrays.areEqual(bOut.toByteArray(),v3Cert)) {
    fail(""String_Node_Str"");
  }
}"
52529,"/** 
 * we generate a certificate signed by our CA's intermediate certficate
 */
public static Certificate createCert(PublicKey pubKey,PrivateKey caPrivKey,PublicKey caPubKey) throws Exception {
  Hashtable sAttrs=new Hashtable();
  Vector sOrder=new Vector();
  sAttrs.put(X509Principal.C,""String_Node_Str"");
  sAttrs.put(X509Principal.O,""String_Node_Str"");
  sAttrs.put(X509Principal.OU,""String_Node_Str"");
  sAttrs.put(X509Principal.EmailAddress,""String_Node_Str"");
  sOrder.addElement(X509Principal.C);
  sOrder.addElement(X509Principal.O);
  sOrder.addElement(X509Principal.OU);
  sOrder.addElement(X509Principal.EmailAddress);
  Hashtable attrs=new Hashtable();
  Vector order=new Vector();
  attrs.put(X509Principal.C,""String_Node_Str"");
  attrs.put(X509Principal.O,""String_Node_Str"");
  attrs.put(X509Principal.L,""String_Node_Str"");
  attrs.put(X509Principal.CN,""String_Node_Str"");
  attrs.put(X509Principal.EmailAddress,""String_Node_Str"");
  order.addElement(X509Principal.C);
  order.addElement(X509Principal.O);
  order.addElement(X509Principal.L);
  order.addElement(X509Principal.CN);
  order.addElement(X509Principal.EmailAddress);
  v3CertGen.reset();
  v3CertGen.setSerialNumber(BigInteger.valueOf(3));
  v3CertGen.setIssuerDN(new X509Principal(sOrder,sAttrs));
  v3CertGen.setNotBefore(new Date(System.currentTimeMillis() - 1000L * 60 * 60* 24* 30));
  v3CertGen.setNotAfter(new Date(System.currentTimeMillis() + (1000L * 60 * 60* 24* 30)));
  v3CertGen.setSubjectDN(new X509Principal(order,attrs));
  v3CertGen.setPublicKey(pubKey);
  v3CertGen.setSignatureAlgorithm(""String_Node_Str"");
  v3CertGen.addExtension(X509Extensions.SubjectKeyIdentifier,false,new SubjectKeyIdentifierStructure(pubKey));
  v3CertGen.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(caPubKey));
  X509Certificate cert=v3CertGen.generate(caPrivKey);
  cert.checkValidity(new Date());
  cert.verify(caPubKey);
  PKCS12BagAttributeCarrier bagAttr=(PKCS12BagAttributeCarrier)cert;
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_friendlyName,new DERBMPString(""String_Node_Str""));
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_localKeyId,new SubjectKeyIdentifierStructure(pubKey));
  return cert;
}","/** 
 * we generate a certificate signed by our CA's intermediate certficate
 */
public static Certificate createCert(PublicKey pubKey,PrivateKey caPrivKey,PublicKey caPubKey) throws Exception {
  Hashtable sAttrs=new Hashtable();
  Vector sOrder=new Vector();
  sAttrs.put(X509Principal.C,""String_Node_Str"");
  sAttrs.put(X509Principal.O,""String_Node_Str"");
  sAttrs.put(X509Principal.OU,""String_Node_Str"");
  sAttrs.put(X509Principal.EmailAddress,""String_Node_Str"");
  sOrder.addElement(X509Principal.C);
  sOrder.addElement(X509Principal.O);
  sOrder.addElement(X509Principal.OU);
  sOrder.addElement(X509Principal.EmailAddress);
  Hashtable attrs=new Hashtable();
  Vector order=new Vector();
  attrs.put(X509Principal.C,""String_Node_Str"");
  attrs.put(X509Principal.O,""String_Node_Str"");
  attrs.put(X509Principal.L,""String_Node_Str"");
  attrs.put(X509Principal.CN,""String_Node_Str"");
  attrs.put(X509Principal.EmailAddress,""String_Node_Str"");
  order.addElement(X509Principal.C);
  order.addElement(X509Principal.O);
  order.addElement(X509Principal.L);
  order.addElement(X509Principal.CN);
  order.addElement(X509Principal.EmailAddress);
  v3CertGen.reset();
  v3CertGen.setSerialNumber(BigInteger.valueOf(3));
  v3CertGen.setIssuerDN(new X509Principal(sOrder,sAttrs));
  v3CertGen.setNotBefore(new Date(System.currentTimeMillis() - 1000L * 60 * 60* 24* 30));
  v3CertGen.setNotAfter(new Date(System.currentTimeMillis() + (1000L * 60 * 60* 24* 30)));
  v3CertGen.setSubjectDN(new X509Principal(order,attrs));
  v3CertGen.setPublicKey(pubKey);
  v3CertGen.setSignatureAlgorithm(""String_Node_Str"");
  v3CertGen.addExtension(X509Extensions.SubjectKeyIdentifier,false,new SubjectKeyIdentifierStructure(getDigest(SubjectPublicKeyInfo.getInstance(pubKey.getEncoded()))));
  v3CertGen.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(caPubKey));
  X509Certificate cert=v3CertGen.generate(caPrivKey);
  cert.checkValidity(new Date());
  cert.verify(caPubKey);
  PKCS12BagAttributeCarrier bagAttr=(PKCS12BagAttributeCarrier)cert;
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_friendlyName,new DERBMPString(""String_Node_Str""));
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_localKeyId,new SubjectKeyIdentifierStructure(getDigest(SubjectPublicKeyInfo.getInstance(pubKey.getEncoded()))));
  return cert;
}"
52530,"public static void main(String[] args) throws Exception {
  Security.addProvider(new BouncyCastleProvider());
  RSAPublicKeySpec pubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPrivateCrtKeySpec privKeySpec=new RSAPrivateCrtKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPublicKeySpec intPubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPrivateCrtKeySpec intPrivKeySpec=new RSAPrivateCrtKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPublicKeySpec caPubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPrivateCrtKeySpec caPrivKeySpec=new RSAPrivateCrtKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  KeyFactory fact=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
  PrivateKey caPrivKey=fact.generatePrivate(caPrivKeySpec);
  PublicKey caPubKey=fact.generatePublic(caPubKeySpec);
  PrivateKey intPrivKey=fact.generatePrivate(intPrivKeySpec);
  PublicKey intPubKey=fact.generatePublic(intPubKeySpec);
  PrivateKey privKey=fact.generatePrivate(privKeySpec);
  PublicKey pubKey=fact.generatePublic(pubKeySpec);
  Certificate[] chain=new Certificate[3];
  chain[2]=createMasterCert(caPubKey,caPrivKey);
  chain[1]=createIntermediateCert(intPubKey,caPrivKey,(X509Certificate)chain[2]);
  chain[0]=createCert(pubKey,intPrivKey,intPubKey);
  PKCS12BagAttributeCarrier bagAttr=(PKCS12BagAttributeCarrier)privKey;
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_friendlyName,new DERBMPString(""String_Node_Str""));
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_localKeyId,new SubjectKeyIdentifierStructure(pubKey));
  KeyStore store=KeyStore.getInstance(""String_Node_Str"",""String_Node_Str"");
  store.load(null,null);
  store.setKeyEntry(""String_Node_Str"",privKey,null,chain);
  FileOutputStream fOut=new FileOutputStream(""String_Node_Str"");
  store.store(fOut,passwd);
  fOut.close();
}","public static void main(String[] args) throws Exception {
  Security.addProvider(new BouncyCastleProvider());
  RSAPublicKeySpec pubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPrivateCrtKeySpec privKeySpec=new RSAPrivateCrtKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPublicKeySpec intPubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPrivateCrtKeySpec intPrivKeySpec=new RSAPrivateCrtKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPublicKeySpec caPubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPrivateCrtKeySpec caPrivKeySpec=new RSAPrivateCrtKeySpec(new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  KeyFactory fact=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
  PrivateKey caPrivKey=fact.generatePrivate(caPrivKeySpec);
  PublicKey caPubKey=fact.generatePublic(caPubKeySpec);
  PrivateKey intPrivKey=fact.generatePrivate(intPrivKeySpec);
  PublicKey intPubKey=fact.generatePublic(intPubKeySpec);
  PrivateKey privKey=fact.generatePrivate(privKeySpec);
  PublicKey pubKey=fact.generatePublic(pubKeySpec);
  Certificate[] chain=new Certificate[3];
  chain[2]=createMasterCert(caPubKey,caPrivKey);
  chain[1]=createIntermediateCert(intPubKey,caPrivKey,(X509Certificate)chain[2]);
  chain[0]=createCert(pubKey,intPrivKey,intPubKey);
  PKCS12BagAttributeCarrier bagAttr=(PKCS12BagAttributeCarrier)privKey;
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_friendlyName,new DERBMPString(""String_Node_Str""));
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_localKeyId,new SubjectKeyIdentifierStructure(getDigest(SubjectPublicKeyInfo.getInstance(pubKey.getEncoded()))));
  KeyStore store=KeyStore.getInstance(""String_Node_Str"",""String_Node_Str"");
  store.load(null,null);
  store.setKeyEntry(""String_Node_Str"",privKey,null,chain);
  FileOutputStream fOut=new FileOutputStream(""String_Node_Str"");
  store.store(fOut,passwd);
  fOut.close();
}"
52531,"/** 
 * we generate an intermediate certificate signed by our CA
 */
public static Certificate createIntermediateCert(PublicKey pubKey,PrivateKey caPrivKey,X509Certificate caCert) throws Exception {
  Hashtable attrs=new Hashtable();
  Vector order=new Vector();
  attrs.put(X509Principal.C,""String_Node_Str"");
  attrs.put(X509Principal.O,""String_Node_Str"");
  attrs.put(X509Principal.OU,""String_Node_Str"");
  attrs.put(X509Principal.EmailAddress,""String_Node_Str"");
  order.addElement(X509Principal.C);
  order.addElement(X509Principal.O);
  order.addElement(X509Principal.OU);
  order.addElement(X509Principal.EmailAddress);
  v3CertGen.reset();
  v3CertGen.setSerialNumber(BigInteger.valueOf(2));
  v3CertGen.setIssuerDN(PrincipalUtil.getSubjectX509Principal(caCert));
  v3CertGen.setNotBefore(new Date(System.currentTimeMillis() - 1000L * 60 * 60* 24* 30));
  v3CertGen.setNotAfter(new Date(System.currentTimeMillis() + (1000L * 60 * 60* 24* 30)));
  v3CertGen.setSubjectDN(new X509Principal(order,attrs));
  v3CertGen.setPublicKey(pubKey);
  v3CertGen.setSignatureAlgorithm(""String_Node_Str"");
  v3CertGen.addExtension(X509Extensions.SubjectKeyIdentifier,false,new SubjectKeyIdentifierStructure(pubKey));
  v3CertGen.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(caCert));
  v3CertGen.addExtension(X509Extensions.BasicConstraints,true,new BasicConstraints(0));
  X509Certificate cert=v3CertGen.generate(caPrivKey);
  cert.checkValidity(new Date());
  cert.verify(caCert.getPublicKey());
  PKCS12BagAttributeCarrier bagAttr=(PKCS12BagAttributeCarrier)cert;
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_friendlyName,new DERBMPString(""String_Node_Str""));
  return cert;
}","/** 
 * we generate an intermediate certificate signed by our CA
 */
public static Certificate createIntermediateCert(PublicKey pubKey,PrivateKey caPrivKey,X509Certificate caCert) throws Exception {
  Hashtable attrs=new Hashtable();
  Vector order=new Vector();
  attrs.put(X509Principal.C,""String_Node_Str"");
  attrs.put(X509Principal.O,""String_Node_Str"");
  attrs.put(X509Principal.OU,""String_Node_Str"");
  attrs.put(X509Principal.EmailAddress,""String_Node_Str"");
  order.addElement(X509Principal.C);
  order.addElement(X509Principal.O);
  order.addElement(X509Principal.OU);
  order.addElement(X509Principal.EmailAddress);
  v3CertGen.reset();
  v3CertGen.setSerialNumber(BigInteger.valueOf(2));
  v3CertGen.setIssuerDN(PrincipalUtil.getSubjectX509Principal(caCert));
  v3CertGen.setNotBefore(new Date(System.currentTimeMillis() - 1000L * 60 * 60* 24* 30));
  v3CertGen.setNotAfter(new Date(System.currentTimeMillis() + (1000L * 60 * 60* 24* 30)));
  v3CertGen.setSubjectDN(new X509Principal(order,attrs));
  v3CertGen.setPublicKey(pubKey);
  v3CertGen.setSignatureAlgorithm(""String_Node_Str"");
  v3CertGen.addExtension(X509Extensions.SubjectKeyIdentifier,false,new SubjectKeyIdentifierStructure(getDigest(SubjectPublicKeyInfo.getInstance(pubKey.getEncoded()))));
  v3CertGen.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(caCert));
  v3CertGen.addExtension(X509Extensions.BasicConstraints,true,new BasicConstraints(0));
  X509Certificate cert=v3CertGen.generate(caPrivKey);
  cert.checkValidity(new Date());
  cert.verify(caCert.getPublicKey());
  PKCS12BagAttributeCarrier bagAttr=(PKCS12BagAttributeCarrier)cert;
  bagAttr.setBagAttribute(PKCSObjectIdentifiers.pkcs_9_at_friendlyName,new DERBMPString(""String_Node_Str""));
  return cert;
}"
52532,"static SubjectKeyIdentifier createSubjectKeyId(PublicKey pub) throws IOException {
  ByteArrayInputStream bIn=new ByteArrayInputStream(pub.getEncoded());
  SubjectPublicKeyInfo info=new SubjectPublicKeyInfo((ASN1Sequence)new ASN1InputStream(bIn).readObject());
  return new SubjectKeyIdentifier(info);
}","static SubjectKeyIdentifier createSubjectKeyId(PublicKey pub) throws IOException {
  ByteArrayInputStream bIn=new ByteArrayInputStream(pub.getEncoded());
  SubjectPublicKeyInfo info=new SubjectPublicKeyInfo((ASN1Sequence)new ASN1InputStream(bIn).readObject());
  return new BcX509ExtensionUtils().createSubjectKeyIdentifier(info);
}"
52533,"private void tbsV3CertGen() throws IOException {
  V3TBSCertificateGenerator gen=new V3TBSCertificateGenerator();
  Date startDate=new Date(1000);
  Date endDate=new Date(2000);
  gen.setSerialNumber(new ASN1Integer(2));
  gen.setStartDate(new Time(startDate));
  gen.setEndDate(new Time(endDate));
  gen.setIssuer(new X500Name(""String_Node_Str""));
  gen.setSubject(new X500Name(""String_Node_Str""));
  gen.setSignature(new AlgorithmIdentifier(PKCSObjectIdentifiers.md5WithRSAEncryption,DERNull.INSTANCE));
  SubjectPublicKeyInfo info=new SubjectPublicKeyInfo(new AlgorithmIdentifier(OIWObjectIdentifiers.elGamalAlgorithm,new ElGamalParameter(BigInteger.valueOf(1),BigInteger.valueOf(2))),new ASN1Integer(3));
  gen.setSubjectPublicKeyInfo(info);
  Vector order=new Vector();
  Hashtable extensions=new Hashtable();
  order.addElement(X509Extension.authorityKeyIdentifier);
  order.addElement(X509Extension.subjectKeyIdentifier);
  order.addElement(X509Extension.keyUsage);
  extensions.put(X509Extension.authorityKeyIdentifier,new X509Extension(true,new DEROctetString(createAuthorityKeyId(info,new X500Name(""String_Node_Str""),2))));
  extensions.put(X509Extension.subjectKeyIdentifier,new X509Extension(true,new DEROctetString(new SubjectKeyIdentifier(new byte[20]))));
  extensions.put(X509Extension.keyUsage,new X509Extension(false,new DEROctetString(new KeyUsage(KeyUsage.dataEncipherment))));
  X509Extensions ex=new X509Extensions(order,extensions);
  gen.setExtensions(ex);
  TBSCertificate tbs=gen.generateTBSCertificate();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  ASN1OutputStream aOut=new ASN1OutputStream(bOut);
  aOut.writeObject(tbs);
  if (!Arrays.areEqual(bOut.toByteArray(),v3Cert)) {
    fail(""String_Node_Str"");
  }
  ASN1InputStream aIn=new ASN1InputStream(new ByteArrayInputStream(v3Cert));
  ASN1Primitive o=aIn.readObject();
  bOut=new ByteArrayOutputStream();
  aOut=new ASN1OutputStream(bOut);
  aOut.writeObject(o);
  if (!Arrays.areEqual(bOut.toByteArray(),v3Cert)) {
    fail(""String_Node_Str"");
  }
}","private void tbsV3CertGen() throws IOException {
  V3TBSCertificateGenerator gen=new V3TBSCertificateGenerator();
  Date startDate=new Date(1000);
  Date endDate=new Date(2000);
  gen.setSerialNumber(new ASN1Integer(2));
  gen.setStartDate(new Time(startDate));
  gen.setEndDate(new Time(endDate));
  gen.setIssuer(new X500Name(""String_Node_Str""));
  gen.setSubject(new X500Name(""String_Node_Str""));
  gen.setSignature(new AlgorithmIdentifier(PKCSObjectIdentifiers.md5WithRSAEncryption,DERNull.INSTANCE));
  SubjectPublicKeyInfo info=new SubjectPublicKeyInfo(new AlgorithmIdentifier(OIWObjectIdentifiers.elGamalAlgorithm,new ElGamalParameter(BigInteger.valueOf(1),BigInteger.valueOf(2))),new ASN1Integer(3));
  gen.setSubjectPublicKeyInfo(info);
  Vector order=new Vector();
  Hashtable extensions=new Hashtable();
  order.addElement(X509Extension.authorityKeyIdentifier);
  order.addElement(X509Extension.subjectKeyIdentifier);
  order.addElement(X509Extension.keyUsage);
  extensions.put(X509Extension.authorityKeyIdentifier,new X509Extension(true,new DEROctetString(createAuthorityKeyId(info,new X500Name(""String_Node_Str""),2))));
  extensions.put(X509Extension.subjectKeyIdentifier,new X509Extension(true,new DEROctetString(new SubjectKeyIdentifier(getDigest(info)))));
  extensions.put(X509Extension.keyUsage,new X509Extension(false,new DEROctetString(new KeyUsage(KeyUsage.dataEncipherment))));
  X509Extensions ex=new X509Extensions(order,extensions);
  gen.setExtensions(ex);
  TBSCertificate tbs=gen.generateTBSCertificate();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  ASN1OutputStream aOut=new ASN1OutputStream(bOut);
  aOut.writeObject(tbs);
  if (!Arrays.areEqual(bOut.toByteArray(),v3Cert)) {
    fail(""String_Node_Str"");
  }
  ASN1InputStream aIn=new ASN1InputStream(new ByteArrayInputStream(v3Cert));
  ASN1Primitive o=aIn.readObject();
  bOut=new ByteArrayOutputStream();
  aOut=new ASN1OutputStream(bOut);
  aOut.writeObject(o);
  if (!Arrays.areEqual(bOut.toByteArray(),v3Cert)) {
    fail(""String_Node_Str"");
  }
}"
52534,"private static SubjectKeyIdentifier createSubjectKeyId(PublicKey _pubKey) throws IOException {
  ByteArrayInputStream _bais=new ByteArrayInputStream(_pubKey.getEncoded());
  SubjectPublicKeyInfo _info=new SubjectPublicKeyInfo((ASN1Sequence)new ASN1InputStream(_bais).readObject());
  return new SubjectKeyIdentifier(_info);
}","private static SubjectKeyIdentifier createSubjectKeyId(PublicKey _pubKey) throws IOException {
  return new BcX509ExtensionUtils().createSubjectKeyIdentifier(SubjectPublicKeyInfo.getInstance(_pubKey.getEncoded()));
}"
52535,"private void nullPointerTest() throws Exception {
  KeyPairGenerator keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",""String_Node_Str"");
  keyGen.initialize(1024,new SecureRandom());
  KeyPair pair=keyGen.generateKeyPair();
  Vector oids=new Vector();
  Vector values=new Vector();
  oids.add(X509Extensions.BasicConstraints);
  values.add(new X509Extension(true,new DEROctetString(new BasicConstraints(true))));
  oids.add(X509Extensions.KeyUsage);
  values.add(new X509Extension(true,new DEROctetString(new KeyUsage(KeyUsage.keyCertSign | KeyUsage.cRLSign))));
  SubjectKeyIdentifier subjectKeyIdentifier=new SubjectKeyIdentifierStructure(pair.getPublic());
  X509Extension ski=new X509Extension(false,new DEROctetString(subjectKeyIdentifier));
  oids.add(X509Extensions.SubjectKeyIdentifier);
  values.add(ski);
  Attribute attribute=new Attribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest,new DERSet(new X509Extensions(oids,values)));
  PKCS10CertificationRequest p1=new PKCS10CertificationRequest(""String_Node_Str"",new X509Principal(""String_Node_Str""),pair.getPublic(),new DERSet(attribute),pair.getPrivate(),""String_Node_Str"");
  PKCS10CertificationRequest p2=new PKCS10CertificationRequest(""String_Node_Str"",new X509Principal(""String_Node_Str""),pair.getPublic(),new DERSet(attribute),pair.getPrivate(),""String_Node_Str"");
  if (!p1.equals(p2)) {
    fail(""String_Node_Str"");
  }
}","private void nullPointerTest() throws Exception {
  KeyPairGenerator keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",""String_Node_Str"");
  keyGen.initialize(1024,new SecureRandom());
  KeyPair pair=keyGen.generateKeyPair();
  Vector oids=new Vector();
  Vector values=new Vector();
  oids.add(X509Extensions.BasicConstraints);
  values.add(new X509Extension(true,new DEROctetString(new BasicConstraints(true))));
  oids.add(X509Extensions.KeyUsage);
  values.add(new X509Extension(true,new DEROctetString(new KeyUsage(KeyUsage.keyCertSign | KeyUsage.cRLSign))));
  SubjectKeyIdentifier subjectKeyIdentifier=new SubjectKeyIdentifierStructure(getDigest(SubjectPublicKeyInfo.getInstance(pair.getPublic().getEncoded())));
  X509Extension ski=new X509Extension(false,new DEROctetString(subjectKeyIdentifier));
  oids.add(X509Extensions.SubjectKeyIdentifier);
  values.add(ski);
  Attribute attribute=new Attribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest,new DERSet(new X509Extensions(oids,values)));
  PKCS10CertificationRequest p1=new PKCS10CertificationRequest(""String_Node_Str"",new X509Principal(""String_Node_Str""),pair.getPublic(),new DERSet(attribute),pair.getPrivate(),""String_Node_Str"");
  PKCS10CertificationRequest p2=new PKCS10CertificationRequest(""String_Node_Str"",new X509Principal(""String_Node_Str""),pair.getPublic(),new DERSet(attribute),pair.getPrivate(),""String_Node_Str"");
  if (!p1.equals(p2)) {
    fail(""String_Node_Str"");
  }
}"
52536,"public static X509Certificate generateIntermediateCert(PublicKey intKey,PrivateKey caKey,X509Certificate caCert) throws Exception {
  X509V3CertificateGenerator certGen=new X509V3CertificateGenerator();
  certGen.setSerialNumber(BigInteger.valueOf(1));
  certGen.setIssuerDN(PrincipalUtil.getSubjectX509Principal(caCert));
  certGen.setNotBefore(new Date(System.currentTimeMillis() - 50000));
  certGen.setNotAfter(new Date(System.currentTimeMillis() + 50000));
  certGen.setSubjectDN(new X509Principal(""String_Node_Str""));
  certGen.setPublicKey(intKey);
  certGen.setSignatureAlgorithm(""String_Node_Str"");
  certGen.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(caCert));
  certGen.addExtension(X509Extensions.SubjectKeyIdentifier,false,new SubjectKeyIdentifierStructure(intKey));
  certGen.addExtension(X509Extensions.BasicConstraints,true,new BasicConstraints(0));
  certGen.addExtension(X509Extensions.KeyUsage,true,new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));
  return certGen.generate(caKey,""String_Node_Str"");
}","public static X509Certificate generateIntermediateCert(PublicKey intKey,PrivateKey caKey,X509Certificate caCert) throws Exception {
  X509V3CertificateGenerator certGen=new X509V3CertificateGenerator();
  certGen.setSerialNumber(BigInteger.valueOf(1));
  certGen.setIssuerDN(PrincipalUtil.getSubjectX509Principal(caCert));
  certGen.setNotBefore(new Date(System.currentTimeMillis() - 50000));
  certGen.setNotAfter(new Date(System.currentTimeMillis() + 50000));
  certGen.setSubjectDN(new X509Principal(""String_Node_Str""));
  certGen.setPublicKey(intKey);
  certGen.setSignatureAlgorithm(""String_Node_Str"");
  certGen.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(caCert));
  certGen.addExtension(X509Extensions.SubjectKeyIdentifier,false,new SubjectKeyIdentifierStructure(getDigest(SubjectPublicKeyInfo.getInstance(intKey.getEncoded()))));
  certGen.addExtension(X509Extensions.BasicConstraints,true,new BasicConstraints(0));
  certGen.addExtension(X509Extensions.KeyUsage,true,new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));
  return certGen.generate(caKey,""String_Node_Str"");
}"
52537,"public static X509Certificate generateEndEntityCert(PublicKey entityKey,PrivateKey caKey,X509Certificate caCert) throws Exception {
  X509V3CertificateGenerator certGen=new X509V3CertificateGenerator();
  certGen.setSerialNumber(BigInteger.valueOf(1));
  certGen.setIssuerDN(PrincipalUtil.getSubjectX509Principal(caCert));
  certGen.setNotBefore(new Date(System.currentTimeMillis() - 50000));
  certGen.setNotAfter(new Date(System.currentTimeMillis() + 50000));
  certGen.setSubjectDN(new X509Principal(""String_Node_Str""));
  certGen.setPublicKey(entityKey);
  certGen.setSignatureAlgorithm(""String_Node_Str"");
  certGen.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(caCert));
  certGen.addExtension(X509Extensions.SubjectKeyIdentifier,false,new SubjectKeyIdentifierStructure(entityKey));
  certGen.addExtension(X509Extensions.BasicConstraints,true,new BasicConstraints(false));
  certGen.addExtension(X509Extensions.KeyUsage,true,new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));
  return certGen.generate(caKey,""String_Node_Str"");
}","public static X509Certificate generateEndEntityCert(PublicKey entityKey,PrivateKey caKey,X509Certificate caCert) throws Exception {
  X509V3CertificateGenerator certGen=new X509V3CertificateGenerator();
  certGen.setSerialNumber(BigInteger.valueOf(1));
  certGen.setIssuerDN(PrincipalUtil.getSubjectX509Principal(caCert));
  certGen.setNotBefore(new Date(System.currentTimeMillis() - 50000));
  certGen.setNotAfter(new Date(System.currentTimeMillis() + 50000));
  certGen.setSubjectDN(new X509Principal(""String_Node_Str""));
  certGen.setPublicKey(entityKey);
  certGen.setSignatureAlgorithm(""String_Node_Str"");
  certGen.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(caCert));
  certGen.addExtension(X509Extensions.SubjectKeyIdentifier,false,new SubjectKeyIdentifierStructure(getDigest(SubjectPublicKeyInfo.getInstance(entityKey.getEncoded()))));
  certGen.addExtension(X509Extensions.BasicConstraints,true,new BasicConstraints(false));
  certGen.addExtension(X509Extensions.KeyUsage,true,new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));
  return certGen.generate(caKey,""String_Node_Str"");
}"
52538,"private void finaliseCipher() throws IOException {
  try {
    finalized=true;
    if (bufferedBlockCipher != null) {
      maxBuf=bufferedBlockCipher.doFinal(buf,0);
    }
 else     if (aeadBlockCipher != null) {
      maxBuf=aeadBlockCipher.doFinal(buf,0);
    }
 else {
      maxBuf=0;
    }
  }
 catch (  final InvalidCipherTextException e) {
    throw new InvalidCipherTextIOException(""String_Node_Str"",e);
  }
catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + e);
  }
}","private void finaliseCipher() throws IOException {
  try {
    finalized=true;
    ensureCapacity(0,true);
    if (bufferedBlockCipher != null) {
      maxBuf=bufferedBlockCipher.doFinal(buf,0);
    }
 else     if (aeadBlockCipher != null) {
      maxBuf=aeadBlockCipher.doFinal(buf,0);
    }
 else {
      maxBuf=0;
    }
  }
 catch (  final InvalidCipherTextException e) {
    throw new InvalidCipherTextIOException(""String_Node_Str"",e);
  }
catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + e);
  }
}"
52539,"/** 
 * Constructs a CipherInputStream from an InputStream and an AEADBlockCipher.
 */
public CipherInputStream(InputStream is,AEADBlockCipher cipher){
  super(is);
  this.aeadBlockCipher=cipher;
  buf=new byte[cipher.getOutputSize(INPUT_BUF_SIZE)];
  inBuf=new byte[INPUT_BUF_SIZE];
}","/** 
 * Constructs a CipherInputStream from an InputStream and an AEADBlockCipher.
 */
public CipherInputStream(InputStream is,AEADBlockCipher cipher){
  super(is);
  this.aeadBlockCipher=cipher;
}"
52540,"/** 
 * Read data from underlying stream and process with cipher until end of stream or some data is available after cipher processing.
 * @return -1 to indicate end of stream, or the number of bytes (> 0) available.
 */
private int nextChunk() throws IOException {
  if (finalized) {
    return -1;
  }
  bufOff=0;
  maxBuf=0;
  while (maxBuf == 0) {
    int read=in.read(inBuf);
    if (read == -1) {
      finaliseCipher();
      if (maxBuf == 0) {
        return -1;
      }
      return maxBuf;
    }
    try {
      if (bufferedBlockCipher != null) {
        maxBuf=bufferedBlockCipher.processBytes(inBuf,0,read,buf,0);
      }
 else       if (aeadBlockCipher != null) {
        maxBuf=aeadBlockCipher.processBytes(inBuf,0,read,buf,0);
      }
 else {
        streamCipher.processBytes(inBuf,0,read,buf,0);
        maxBuf=read;
      }
    }
 catch (    Exception e) {
      throw new IOException(""String_Node_Str"" + e);
    }
  }
  return maxBuf;
}","/** 
 * Read data from underlying stream and process with cipher until end of stream or some data is available after cipher processing.
 * @return -1 to indicate end of stream, or the number of bytes (> 0) available.
 */
private int nextChunk() throws IOException {
  if (finalized) {
    return -1;
  }
  bufOff=0;
  maxBuf=0;
  while (maxBuf == 0) {
    int read=in.read(inBuf);
    if (read == -1) {
      finaliseCipher();
      if (maxBuf == 0) {
        return -1;
      }
      return maxBuf;
    }
    try {
      ensureCapacity(read,false);
      if (bufferedBlockCipher != null) {
        maxBuf=bufferedBlockCipher.processBytes(inBuf,0,read,buf,0);
      }
 else       if (aeadBlockCipher != null) {
        maxBuf=aeadBlockCipher.processBytes(inBuf,0,read,buf,0);
      }
 else {
        streamCipher.processBytes(inBuf,0,read,buf,0);
        maxBuf=read;
      }
    }
 catch (    Exception e) {
      throw new CipherIOException(""String_Node_Str"",e);
    }
  }
  return maxBuf;
}"
52541,"private void nullPointerTest() throws Exception {
  KeyPairGenerator keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",""String_Node_Str"");
  keyGen.initialize(1024,new SecureRandom());
  KeyPair pair=keyGen.generateKeyPair();
  Vector oids=new Vector();
  Vector values=new Vector();
  oids.add(X509Extensions.BasicConstraints);
  values.add(new X509Extension(true,new DEROctetString(new BasicConstraints(true))));
  oids.add(X509Extensions.KeyUsage);
  values.add(new X509Extension(true,new DEROctetString(new KeyUsage(KeyUsage.keyCertSign | KeyUsage.cRLSign))));
  SubjectKeyIdentifier subjectKeyIdentifier=new SubjectKeyIdentifierStructure(getDigest(SubjectPublicKeyInfo.getInstance(pair.getPublic().getEncoded())));
  X509Extension ski=new X509Extension(false,new DEROctetString(subjectKeyIdentifier));
  oids.add(X509Extensions.SubjectKeyIdentifier);
  values.add(ski);
  Attribute attribute=new Attribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest,new DERSet(new X509Extensions(oids,values)));
  PKCS10CertificationRequest p1=new PKCS10CertificationRequest(""String_Node_Str"",new X509Principal(""String_Node_Str""),pair.getPublic(),new DERSet(attribute),pair.getPrivate(),""String_Node_Str"");
  PKCS10CertificationRequest p2=new PKCS10CertificationRequest(""String_Node_Str"",new X509Principal(""String_Node_Str""),pair.getPublic(),new DERSet(attribute),pair.getPrivate(),""String_Node_Str"");
  if (!p1.equals(p2)) {
    fail(""String_Node_Str"");
  }
}","private void nullPointerTest() throws Exception {
  KeyPairGenerator keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",""String_Node_Str"");
  keyGen.initialize(1024,new SecureRandom());
  KeyPair pair=keyGen.generateKeyPair();
  Vector oids=new Vector();
  Vector values=new Vector();
  oids.add(X509Extensions.BasicConstraints);
  values.add(new X509Extension(true,new DEROctetString(new BasicConstraints(true))));
  oids.add(X509Extensions.KeyUsage);
  values.add(new X509Extension(true,new DEROctetString(new KeyUsage(KeyUsage.keyCertSign | KeyUsage.cRLSign))));
  SubjectKeyIdentifier subjectKeyIdentifier=new SubjectKeyIdentifier(getDigest(SubjectPublicKeyInfo.getInstance(pair.getPublic().getEncoded())));
  X509Extension ski=new X509Extension(false,new DEROctetString(subjectKeyIdentifier));
  oids.add(X509Extensions.SubjectKeyIdentifier);
  values.add(ski);
  Attribute attribute=new Attribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest,new DERSet(new X509Extensions(oids,values)));
  PKCS10CertificationRequest p1=new PKCS10CertificationRequest(""String_Node_Str"",new X509Principal(""String_Node_Str""),pair.getPublic(),new DERSet(attribute),pair.getPrivate(),""String_Node_Str"");
  PKCS10CertificationRequest p2=new PKCS10CertificationRequest(""String_Node_Str"",new X509Principal(""String_Node_Str""),pair.getPublic(),new DERSet(attribute),pair.getPrivate(),""String_Node_Str"");
  if (!p1.equals(p2)) {
    fail(""String_Node_Str"");
  }
}"
52542,"protected static long rotateLeft(long x,int n){
  return (x << n) | (x >>> (64 - n));
}","protected static long rotateLeft(long x,int n){
  return (x << n) | (x >>> -n);
}"
52543,"public void update(byte[] input,int offset,int length) throws DataLengthException, IllegalStateException {
  int i=0, fullWords=length & ~7;
  if (wordPos == 0) {
    for (; i < fullWords; i+=8) {
      m=Pack.littleEndianToLong(input,offset + i);
      processMessageWord();
    }
    for (; i < length; ++i) {
      m>>>=8;
      m|=(input[offset + i] & 0xffL) << 56;
    }
    wordPos=length - fullWords;
  }
 else {
    int bits=wordPos << 3;
    for (; i < fullWords; i+=8) {
      long n=Pack.littleEndianToLong(input,offset + i);
      m>>>=64 - bits;
      m|=n << bits;
      processMessageWord();
      m=n;
    }
    for (; i < length; ++i) {
      m>>>=8;
      m|=(input[offset + i] & 0xffL) << 56;
      if (++wordPos == 8) {
        processMessageWord();
        wordPos=0;
      }
    }
  }
}","public void update(byte[] input,int offset,int length) throws DataLengthException, IllegalStateException {
  int i=0, fullWords=length & ~7;
  if (wordPos == 0) {
    for (; i < fullWords; i+=8) {
      m=Pack.littleEndianToLong(input,offset + i);
      processMessageWord();
    }
    for (; i < length; ++i) {
      m>>>=8;
      m|=(input[offset + i] & 0xffL) << 56;
    }
    wordPos=length - fullWords;
  }
 else {
    int bits=wordPos << 3;
    for (; i < fullWords; i+=8) {
      long n=Pack.littleEndianToLong(input,offset + i);
      m=(n << bits) | (m >>> -bits);
      processMessageWord();
      m=n;
    }
    for (; i < length; ++i) {
      m>>>=8;
      m|=(input[offset + i] & 0xffL) << 56;
      if (++wordPos == 8) {
        processMessageWord();
        wordPos=0;
      }
    }
  }
}"
52544,"protected void applySipRounds(int n){
  for (int r=0; r < n; ++r) {
    v0+=v1;
    v2+=v3;
    v1=rotateLeft(v1,13);
    v3=rotateLeft(v3,16);
    v1^=v0;
    v3^=v2;
    v0=rotateLeft(v0,32);
    v2+=v1;
    v0+=v3;
    v1=rotateLeft(v1,17);
    v3=rotateLeft(v3,21);
    v1^=v2;
    v3^=v0;
    v2=rotateLeft(v2,32);
  }
}","protected void applySipRounds(int n){
  long r0=v0, r1=v1, r2=v2, r3=v3;
  for (int r=0; r < n; ++r) {
    r0+=r1;
    r2+=r3;
    r1=rotateLeft(r1,13);
    r3=rotateLeft(r3,16);
    r1^=r0;
    r3^=r2;
    r0=rotateLeft(r0,32);
    r2+=r1;
    r0+=r3;
    r1=rotateLeft(r1,17);
    r3=rotateLeft(r3,21);
    r1^=r2;
    r3^=r0;
    r2=rotateLeft(r2,32);
  }
  v0=r0;
  v1=r1;
  v2=r2;
  v3=r3;
}"
52545,"/** 
 * return a sqrt root - the routine verifies that the calculation returns the right value - if none exists it returns null.
 */
public ECFieldElement sqrt(){
  int[] c=this.x;
  if (Nat224.isZero(c) || Nat224.isOne(c)) {
    return this;
  }
  int[] nc=Nat224.create();
  SecP224R1Field.negate(c,nc);
  int[] r=Mod.random(SecP224R1Field.P);
  int[] t=Nat224.create();
  for (; ; ) {
    int[] d1=Nat224.create();
    Nat224.copy(r,d1);
    int[] e1=Nat224.create();
    e1[0]=1;
    int[] f1=Nat224.create();
    RP(nc,d1,e1,f1,t);
    int[] d0=Nat224.create();
    int[] e0=Nat224.create();
    for (int k=1; k < 96; ++k) {
      Nat224.copy(d1,d0);
      Nat224.copy(e1,e0);
      RS(d1,e1,f1,t);
      if (Nat224.isZero(d1)) {
        Mod.invert(SecP224R1Field.P,e0,f1);
        SecP224R1Field.multiply(f1,d0,f1);
        SecP224R1Field.square(f1,d1);
        return Nat224.eq(c,d1) ? new SecP224R1FieldElement(f1) : null;
      }
    }
    SecP224R1Field.addOne(r,r);
  }
}","/** 
 * return a sqrt root - the routine verifies that the calculation returns the right value - if none exists it returns null.
 */
public ECFieldElement sqrt(){
  int[] c=this.x;
  if (Nat224.isZero(c) || Nat224.isOne(c)) {
    return this;
  }
  int[] nc=Nat224.create();
  SecP224R1Field.negate(c,nc);
  int[] r=Mod.random(SecP224R1Field.P);
  int[] t=Nat224.create();
  if (!isSquare(c)) {
    return null;
  }
  while (!trySqrt(nc,r,t)) {
    SecP224R1Field.addOne(r,r);
  }
  SecP224R1Field.square(t,r);
  return Nat224.eq(c,r) ? new SecP224R1FieldElement(t) : null;
}"
52546,"private void implAddSubtractMultiplyTwiceEncodingTestAllCoords(X9ECParameters x9ECParameters){
  BigInteger n=x9ECParameters.getN();
  ECPoint G=x9ECParameters.getG();
  ECCurve C=x9ECParameters.getCurve();
  int[] coords=ECCurve.getAllCoordinateSystems();
  for (int i=0; i < coords.length; ++i) {
    int coord=coords[i];
    if (C.supportsCoordinateSystem(coord)) {
      ECCurve c=C;
      ECPoint g=G;
      if (c.getCoordinateSystem() != coord) {
        c=C.configure().setCoordinateSystem(coord).create();
        g=c.importPoint(G);
      }
      BigInteger b=new BigInteger(n.bitLength(),secRand);
      ECPoint q=g.multiply(b).normalize();
      implAddSubtractMultiplyTwiceEncodingTest(c,q,n);
    }
  }
}","private void implAddSubtractMultiplyTwiceEncodingTestAllCoords(X9ECParameters x9ECParameters){
  BigInteger n=x9ECParameters.getN();
  ECPoint G=x9ECParameters.getG();
  ECCurve C=x9ECParameters.getCurve();
  int[] coords=ECCurve.getAllCoordinateSystems();
  for (int i=0; i < coords.length; ++i) {
    int coord=coords[i];
    if (C.supportsCoordinateSystem(coord)) {
      ECCurve c=C;
      ECPoint g=G;
      if (c.getCoordinateSystem() != coord) {
        c=C.configure().setCoordinateSystem(coord).create();
        g=c.importPoint(G);
      }
      BigInteger b=new BigInteger(n.bitLength(),secRand);
      ECPoint q=g.multiply(b).normalize();
      implAddSubtractMultiplyTwiceEncodingTest(c,q,n);
      implSqrtTest(c);
    }
  }
}"
52547,"/** 
 * Create an iso7816Certificate structure from a body and its signature.
 * @param body the Iso7816CertificateBody object containing the body.
 * @param signature   the byte array containing the signature
 * @return the Iso7816CertificateStructure
 * @throws IOException if there is a problem parsing the data.
 */
public CVCertificate(CertificateBody body,byte[] signature) throws IOException {
  certificateBody=body;
  this.signature=signature;
  valid|=bodyValid;
  valid|=signValid;
}","/** 
 * Create an iso7816Certificate structure from a body and its signature.
 * @param body the Iso7816CertificateBody object containing the body.
 * @param signature   the byte array containing the signature
 * @throws IOException if there is a problem parsing the data.
 */
public CVCertificate(CertificateBody body,byte[] signature) throws IOException {
  certificateBody=body;
  this.signature=signature;
  valid|=bodyValid;
  valid|=signValid;
}"
52548,"/** 
 * Create an iso7816Certificate structure from an object.
 * @param obj the Object to extract the certificate from.
 * @return the Iso7816CertificateStructure represented by the byte stream.
 * @throws IOException if there is a problem parsing the data.
 */
public static CVCertificate getInstance(Object obj){
  if (obj instanceof CVCertificate) {
    return (CVCertificate)obj;
  }
 else   if (obj != null) {
    try {
      return new CVCertificate(DERApplicationSpecific.getInstance(obj));
    }
 catch (    IOException e) {
      throw new ASN1ParsingException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
  return null;
}","/** 
 * Create an iso7816Certificate structure from an object.
 * @param obj the Object to extract the certificate from.
 * @return the Iso7816CertificateStructure represented by the byte stream.
 */
public static CVCertificate getInstance(Object obj){
  if (obj instanceof CVCertificate) {
    return (CVCertificate)obj;
  }
 else   if (obj != null) {
    try {
      return new CVCertificate(DERApplicationSpecific.getInstance(obj));
    }
 catch (    IOException e) {
      throw new ASN1ParsingException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
  return null;
}"
52549,"/** 
 * create a ""request"" or ""profile"" type Iso7816CertificateBody according to the variables sets.
 * @return return the ASN1Primitive representing the ""request"" or ""profile"" type certificate body.
 * @throws IOException if the DERApplicationSpecific cannot be created or if data are missings to create a valid certificate.
 */
public ASN1Primitive toASN1Primitive(){
  try {
    if (certificateType == profileType) {
      return profileToASN1Object();
    }
    if (certificateType == requestType) {
      return requestToASN1Object();
    }
  }
 catch (  IOException e) {
    return null;
  }
  return null;
}","/** 
 * create a ""request"" or ""profile"" type Iso7816CertificateBody according to the variables sets.
 * @return return the ASN1Primitive representing the ""request"" or ""profile"" type certificate body.
 */
public ASN1Primitive toASN1Primitive(){
  try {
    if (certificateType == profileType) {
      return profileToASN1Object();
    }
    if (certificateType == requestType) {
      return requestToASN1Object();
    }
  }
 catch (  IOException e) {
    return null;
  }
  return null;
}"
52550,"/** 
 * Produce an object suitable for an ASN1OutputStream. <p/> Returns: <p/> <pre> CertHash ::= SEQUENCE { hashAlgorithm AlgorithmIdentifier, certificateHash OCTET STRING } </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  ASN1EncodableVector vec=new ASN1EncodableVector();
  vec.add(hashAlgorithm);
  vec.add(new DEROctetString(certificateHash));
  return new DERSequence(vec);
}","/** 
 * Produce an object suitable for an ASN1OutputStream. <p> Returns: <pre> CertHash ::= SEQUENCE { hashAlgorithm AlgorithmIdentifier, certificateHash OCTET STRING } </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  ASN1EncodableVector vec=new ASN1EncodableVector();
  vec.add(hashAlgorithm);
  vec.add(new DEROctetString(certificateHash));
  return new DERSequence(vec);
}"
52551,"/** 
 * Produce an object suitable for an ASN1OutputStream. <p/> Returns: <p/> <pre> RequestedCertificate ::= CHOICE { Certificate Certificate, publicKeyCertificate [0] EXPLICIT OCTET STRING, attributeCertificate [1] EXPLICIT OCTET STRING } </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  if (publicKeyCert != null) {
    return new DERTaggedObject(0,new DEROctetString(publicKeyCert));
  }
  if (attributeCert != null) {
    return new DERTaggedObject(1,new DEROctetString(attributeCert));
  }
  return cert.toASN1Primitive();
}","/** 
 * Produce an object suitable for an ASN1OutputStream. <p> Returns: <pre> RequestedCertificate ::= CHOICE { Certificate Certificate, publicKeyCertificate [0] EXPLICIT OCTET STRING, attributeCertificate [1] EXPLICIT OCTET STRING } </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  if (publicKeyCert != null) {
    return new DERTaggedObject(0,new DEROctetString(publicKeyCert));
  }
  if (attributeCert != null) {
    return new DERTaggedObject(1,new DEROctetString(attributeCert));
  }
  return cert.toASN1Primitive();
}"
52552,"/** 
 * Produce an object suitable for an ASN1OutputStream. <p/> Returns: <p/> <pre> AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048)) </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  return information.toASN1Primitive();
}","/** 
 * Produce an object suitable for an ASN1OutputStream. <p> Returns: <pre> AdditionalInformationSyntax ::= DirectoryString (SIZE(1..2048)) </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  return information.toASN1Primitive();
}"
52553,"/** 
 * Produce an object suitable for an ASN1OutputStream. <p/> Returns: <p/> <pre> AdmissionSyntax ::= SEQUENCE { admissionAuthority GeneralName OPTIONAL, contentsOfAdmissions SEQUENCE OF Admissions } <p/> Admissions ::= SEQUENCE { admissionAuthority [0] EXPLICIT GeneralName OPTIONAL namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL professionInfos SEQUENCE OF ProfessionInfo } <p/> NamingAuthority ::= SEQUENCE { namingAuthorityId OBJECT IDENTIFIER OPTIONAL, namingAuthorityUrl IA5String OPTIONAL, namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL } <p/> ProfessionInfo ::= SEQUENCE { namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL, professionItems SEQUENCE OF DirectoryString (SIZE(1..128)), professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL, registrationNumber PrintableString(SIZE(1..128)) OPTIONAL, addProfessionInfo OCTET STRING OPTIONAL } </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  ASN1EncodableVector vec=new ASN1EncodableVector();
  if (admissionAuthority != null) {
    vec.add(admissionAuthority);
  }
  vec.add(contentsOfAdmissions);
  return new DERSequence(vec);
}","/** 
 * Produce an object suitable for an ASN1OutputStream. <p> Returns: <pre> AdmissionSyntax ::= SEQUENCE { admissionAuthority GeneralName OPTIONAL, contentsOfAdmissions SEQUENCE OF Admissions } Admissions ::= SEQUENCE { admissionAuthority [0] EXPLICIT GeneralName OPTIONAL namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL professionInfos SEQUENCE OF ProfessionInfo } NamingAuthority ::= SEQUENCE { namingAuthorityId OBJECT IDENTIFIER OPTIONAL, namingAuthorityUrl IA5String OPTIONAL, namingAuthorityText DirectoryString(SIZE(1..128)) OPTIONAL } ProfessionInfo ::= SEQUENCE { namingAuthority [0] EXPLICIT NamingAuthority OPTIONAL, professionItems SEQUENCE OF DirectoryString (SIZE(1..128)), professionOIDs SEQUENCE OF OBJECT IDENTIFIER OPTIONAL, registrationNumber PrintableString(SIZE(1..128)) OPTIONAL, addProfessionInfo OCTET STRING OPTIONAL } </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  ASN1EncodableVector vec=new ASN1EncodableVector();
  if (admissionAuthority != null) {
    vec.add(admissionAuthority);
  }
  vec.add(contentsOfAdmissions);
  return new DERSequence(vec);
}"
52554,"/** 
 * Produce an object suitable for an ASN1OutputStream. <p/> Returns: <p/> <pre> Admissions ::= SEQUENCE { admissionAuthority [0] EXPLICIT GeneralName OPTIONAL namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL professionInfos SEQUENCE OF ProfessionInfo } <p/> </pre>
 * @return an ASN1Primitive
 */
public ASN1Primitive toASN1Primitive(){
  ASN1EncodableVector vec=new ASN1EncodableVector();
  if (admissionAuthority != null) {
    vec.add(new DERTaggedObject(true,0,admissionAuthority));
  }
  if (namingAuthority != null) {
    vec.add(new DERTaggedObject(true,1,namingAuthority));
  }
  vec.add(professionInfos);
  return new DERSequence(vec);
}","/** 
 * Produce an object suitable for an ASN1OutputStream. <p> Returns: <pre> Admissions ::= SEQUENCE { admissionAuthority [0] EXPLICIT GeneralName OPTIONAL namingAuthority [1] EXPLICIT NamingAuthority OPTIONAL professionInfos SEQUENCE OF ProfessionInfo } </pre>
 * @return an ASN1Primitive
 */
public ASN1Primitive toASN1Primitive(){
  ASN1EncodableVector vec=new ASN1EncodableVector();
  if (admissionAuthority != null) {
    vec.add(new DERTaggedObject(true,0,admissionAuthority));
  }
  if (namingAuthority != null) {
    vec.add(new DERTaggedObject(true,1,namingAuthority));
  }
  vec.add(professionInfos);
  return new DERSequence(vec);
}"
52555,"/** 
 * Constructor from a given details. <p/> Parameter <code>professionInfos</code> is mandatory.
 * @param admissionAuthority The admission authority.
 * @param namingAuthority    The naming authority.
 * @param professionInfos    The profession infos.
 */
public Admissions(GeneralName admissionAuthority,NamingAuthority namingAuthority,ProfessionInfo[] professionInfos){
  this.admissionAuthority=admissionAuthority;
  this.namingAuthority=namingAuthority;
  this.professionInfos=new DERSequence(professionInfos);
}","/** 
 * Constructor from a given details. <p> Parameter <code>professionInfos</code> is mandatory.
 * @param admissionAuthority The admission authority.
 * @param namingAuthority    The naming authority.
 * @param professionInfos    The profession infos.
 */
public Admissions(GeneralName admissionAuthority,NamingAuthority namingAuthority,ProfessionInfo[] professionInfos){
  this.admissionAuthority=admissionAuthority;
  this.namingAuthority=namingAuthority;
  this.professionInfos=new DERSequence(professionInfos);
}"
52556,"/** 
 * Produce an object suitable for an ASN1OutputStream. <p/> Returns: <p/> <pre> DeclarationOfMajoritySyntax ::= CHOICE { notYoungerThan [0] IMPLICIT INTEGER, fullAgeAtCountry [1] IMPLICIT SEQUENCE { fullAge BOOLEAN DEFAULT TRUE, country PrintableString (SIZE(2)) } dateOfBirth [2] IMPLICIT GeneralizedTime } </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  return declaration;
}","/** 
 * Produce an object suitable for an ASN1OutputStream. <p> Returns: <pre> DeclarationOfMajoritySyntax ::= CHOICE { notYoungerThan [0] IMPLICIT INTEGER, fullAgeAtCountry [1] IMPLICIT SEQUENCE { fullAge BOOLEAN DEFAULT TRUE, country PrintableString (SIZE(2)) } dateOfBirth [2] IMPLICIT GeneralizedTime } </pre>
 * @return a DERObject
 */
public ASN1Primitive toASN1Primitive(){
  return declaration;
}"
52557,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _origDsaKP=CMSTestUtil.makeDsaKeyPair();
    _origDsaCert=CMSTestUtil.makeCertificate(_origDsaKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _signCrl=CMSTestUtil.makeCrl(_signKP);
    _origCrl=CMSTestUtil.makeCrl(_origKP);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _origDsaKP=CMSTestUtil.makeDsaKeyPair();
    _origDsaCert=CMSTestUtil.makeCertificate(_origDsaKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _signCrl=CMSTestUtil.makeCrl(_signKP);
    _origCrl=CMSTestUtil.makeCrl(_origKP);
  }
}"
52558,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
  }
}"
52559,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
  }
}"
52560,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciDN2=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _reciCertOaep=CMSTestUtil.makeOaepCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
    _reciEcKP2=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert2=CMSTestUtil.makeCertificate(_reciEcKP2,_reciDN2,_signKP,_signDN);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciDN2=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _reciCertOaep=CMSTestUtil.makeOaepCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
    _reciEcKP2=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert2=CMSTestUtil.makeCertificate(_reciEcKP2,_reciDN2,_signKP,_signDN);
  }
}"
52561,"private byte[] decryptBlock(byte[] in_enc,int inOff,int inLen) throws InvalidCipherTextException {
  byte[] M=null, K=null, K1=null, K2=null;
  int len;
  if (inLen <= (macKeySize / 8)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  if (cipher == null) {
    K1=new byte[inLen - V.length - mac.getMacSize()];
    K2=new byte[param.getMacKeySize() / 8];
    K=new byte[K1.length + K2.length];
    kdf.generateBytes(K,0,K.length);
    if (V.length != 0) {
      System.arraycopy(K,0,K2,0,K2.length);
      System.arraycopy(K,K2.length,K1,0,K1.length);
    }
 else {
      System.arraycopy(K,0,K1,0,K1.length);
      System.arraycopy(K,K1.length,K2,0,K2.length);
    }
    M=new byte[K1.length];
    for (int i=0; i != K1.length; i++) {
      M[i]=(byte)(in_enc[inOff + V.length + i] ^ K1[i]);
    }
    len=K1.length;
  }
 else {
    K1=new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];
    K2=new byte[param.getMacKeySize() / 8];
    K=new byte[K1.length + K2.length];
    kdf.generateBytes(K,0,K.length);
    System.arraycopy(K,0,K1,0,K1.length);
    System.arraycopy(K,K1.length,K2,0,K2.length);
    if (nonce != null) {
      byte[] IV=((Nonce)nonce).nextNonce();
      cipher.init(false,new ParametersWithIV(new KeyParameter(K1),IV));
    }
 else {
      cipher.init(false,new KeyParameter(K1));
    }
    M=new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];
    len=cipher.processBytes(in_enc,inOff + V.length,inLen - V.length - mac.getMacSize(),M,0);
    len+=cipher.doFinal(M,len);
  }
  byte[] P2=param.getEncodingV();
  byte[] L2=new byte[4];
  if (V.length != 0 && P2 != null) {
    Pack.intToBigEndian(P2.length * 8,L2,0);
  }
  int end=inOff + inLen;
  byte[] T1=Arrays.copyOfRange(in_enc,end - mac.getMacSize(),end);
  byte[] T2=new byte[T1.length];
  mac.init(new KeyParameter(K2));
  mac.update(in_enc,inOff + V.length,inLen - V.length - T2.length);
  if (P2 != null) {
    mac.update(P2,0,P2.length);
  }
  if (V.length != 0) {
    mac.update(L2,0,L2.length);
  }
  mac.doFinal(T2,0);
  if (!Arrays.constantTimeAreEqual(T1,T2)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  return Arrays.copyOfRange(M,0,len);
}","private byte[] decryptBlock(byte[] in_enc,int inOff,int inLen) throws InvalidCipherTextException {
  byte[] M=null, K=null, K1=null, K2=null;
  int len;
  if (inLen <= (param.getMacKeySize() / 8)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  if (cipher == null) {
    K1=new byte[inLen - V.length - mac.getMacSize()];
    K2=new byte[param.getMacKeySize() / 8];
    K=new byte[K1.length + K2.length];
    kdf.generateBytes(K,0,K.length);
    if (V.length != 0) {
      System.arraycopy(K,0,K2,0,K2.length);
      System.arraycopy(K,K2.length,K1,0,K1.length);
    }
 else {
      System.arraycopy(K,0,K1,0,K1.length);
      System.arraycopy(K,K1.length,K2,0,K2.length);
    }
    M=new byte[K1.length];
    for (int i=0; i != K1.length; i++) {
      M[i]=(byte)(in_enc[inOff + V.length + i] ^ K1[i]);
    }
    len=K1.length;
  }
 else {
    K1=new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];
    K2=new byte[param.getMacKeySize() / 8];
    K=new byte[K1.length + K2.length];
    kdf.generateBytes(K,0,K.length);
    System.arraycopy(K,0,K1,0,K1.length);
    System.arraycopy(K,K1.length,K2,0,K2.length);
    if (nonce != null) {
      byte[] IV=((Nonce)nonce).nextNonce();
      cipher.init(false,new ParametersWithIV(new KeyParameter(K1),IV));
    }
 else {
      cipher.init(false,new KeyParameter(K1));
    }
    M=new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];
    len=cipher.processBytes(in_enc,inOff + V.length,inLen - V.length - mac.getMacSize(),M,0);
    len+=cipher.doFinal(M,len);
  }
  byte[] P2=param.getEncodingV();
  byte[] L2=new byte[4];
  if (V.length != 0 && P2 != null) {
    Pack.intToBigEndian(P2.length * 8,L2,0);
  }
  int end=inOff + inLen;
  byte[] T1=Arrays.copyOfRange(in_enc,end - mac.getMacSize(),end);
  byte[] T2=new byte[T1.length];
  mac.init(new KeyParameter(K2));
  mac.update(in_enc,inOff + V.length,inLen - V.length - T2.length);
  if (P2 != null) {
    mac.update(P2,0,P2.length);
  }
  if (V.length != 0) {
    mac.update(L2,0,L2.length);
  }
  mac.doFinal(T2,0);
  if (!Arrays.constantTimeAreEqual(T1,T2)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  return Arrays.copyOfRange(M,0,len);
}"
52562,"private byte[] decryptBlock(byte[] in_enc,int inOff,int inLen) throws InvalidCipherTextException {
  byte[] M=null, K=null, K1=null, K2=null;
  int len;
  if (cipher == null) {
    K1=new byte[inLen - V.length - mac.getMacSize()];
    K2=new byte[param.getMacKeySize() / 8];
    K=new byte[K1.length + K2.length];
    kdf.generateBytes(K,0,K.length);
    if (V.length != 0) {
      System.arraycopy(K,0,K2,0,K2.length);
      System.arraycopy(K,K2.length,K1,0,K1.length);
    }
 else {
      System.arraycopy(K,0,K1,0,K1.length);
      System.arraycopy(K,K1.length,K2,0,K2.length);
    }
    M=new byte[K1.length];
    for (int i=0; i != K1.length; i++) {
      M[i]=(byte)(in_enc[inOff + V.length + i] ^ K1[i]);
    }
    len=K1.length;
  }
 else {
    K1=new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];
    K2=new byte[param.getMacKeySize() / 8];
    K=new byte[K1.length + K2.length];
    kdf.generateBytes(K,0,K.length);
    System.arraycopy(K,0,K1,0,K1.length);
    System.arraycopy(K,K1.length,K2,0,K2.length);
    if (nonce != null) {
      byte[] IV=((Nonce)nonce).nextNonce();
      cipher.init(false,new ParametersWithIV(new KeyParameter(K1),IV));
    }
 else {
      cipher.init(false,new KeyParameter(K1));
    }
    M=new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];
    len=cipher.processBytes(in_enc,inOff + V.length,inLen - V.length - mac.getMacSize(),M,0);
    len+=cipher.doFinal(M,len);
  }
  byte[] P2=param.getEncodingV();
  byte[] L2=new byte[4];
  if (V.length != 0 && P2 != null) {
    Pack.intToBigEndian(P2.length * 8,L2,0);
  }
  int end=inOff + inLen;
  byte[] T1=Arrays.copyOfRange(in_enc,end - mac.getMacSize(),end);
  byte[] T2=new byte[T1.length];
  mac.init(new KeyParameter(K2));
  mac.update(in_enc,inOff + V.length,inLen - V.length - T2.length);
  if (P2 != null) {
    mac.update(P2,0,P2.length);
  }
  if (V.length != 0) {
    mac.update(L2,0,L2.length);
  }
  mac.doFinal(T2,0);
  if (!Arrays.constantTimeAreEqual(T1,T2)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  return Arrays.copyOfRange(M,0,len);
}","private byte[] decryptBlock(byte[] in_enc,int inOff,int inLen) throws InvalidCipherTextException {
  byte[] M=null, K=null, K1=null, K2=null;
  int len;
  if (inLen <= (macKeySize / 8)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  if (cipher == null) {
    K1=new byte[inLen - V.length - mac.getMacSize()];
    K2=new byte[param.getMacKeySize() / 8];
    K=new byte[K1.length + K2.length];
    kdf.generateBytes(K,0,K.length);
    if (V.length != 0) {
      System.arraycopy(K,0,K2,0,K2.length);
      System.arraycopy(K,K2.length,K1,0,K1.length);
    }
 else {
      System.arraycopy(K,0,K1,0,K1.length);
      System.arraycopy(K,K1.length,K2,0,K2.length);
    }
    M=new byte[K1.length];
    for (int i=0; i != K1.length; i++) {
      M[i]=(byte)(in_enc[inOff + V.length + i] ^ K1[i]);
    }
    len=K1.length;
  }
 else {
    K1=new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];
    K2=new byte[param.getMacKeySize() / 8];
    K=new byte[K1.length + K2.length];
    kdf.generateBytes(K,0,K.length);
    System.arraycopy(K,0,K1,0,K1.length);
    System.arraycopy(K,K1.length,K2,0,K2.length);
    if (nonce != null) {
      byte[] IV=((Nonce)nonce).nextNonce();
      cipher.init(false,new ParametersWithIV(new KeyParameter(K1),IV));
    }
 else {
      cipher.init(false,new KeyParameter(K1));
    }
    M=new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];
    len=cipher.processBytes(in_enc,inOff + V.length,inLen - V.length - mac.getMacSize(),M,0);
    len+=cipher.doFinal(M,len);
  }
  byte[] P2=param.getEncodingV();
  byte[] L2=new byte[4];
  if (V.length != 0 && P2 != null) {
    Pack.intToBigEndian(P2.length * 8,L2,0);
  }
  int end=inOff + inLen;
  byte[] T1=Arrays.copyOfRange(in_enc,end - mac.getMacSize(),end);
  byte[] T2=new byte[T1.length];
  mac.init(new KeyParameter(K2));
  mac.update(in_enc,inOff + V.length,inLen - V.length - T2.length);
  if (P2 != null) {
    mac.update(P2,0,P2.length);
  }
  if (V.length != 0) {
    mac.update(L2,0,L2.length);
  }
  mac.doFinal(T2,0);
  if (!Arrays.constantTimeAreEqual(T1,T2)) {
    throw new InvalidCipherTextException(""String_Node_Str"");
  }
  return Arrays.copyOfRange(M,0,len);
}"
52563,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _origDsaKP=CMSTestUtil.makeDsaKeyPair();
    _origDsaCert=CMSTestUtil.makeCertificate(_origDsaKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _signCrl=CMSTestUtil.makeCrl(_signKP);
    _origCrl=CMSTestUtil.makeCrl(_origKP);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _origDsaKP=CMSTestUtil.makeDsaKeyPair();
    _origDsaCert=CMSTestUtil.makeCertificate(_origDsaKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _signCrl=CMSTestUtil.makeCrl(_signKP);
    _origCrl=CMSTestUtil.makeCrl(_origKP);
  }
}"
52564,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
  }
}"
52565,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
  }
}"
52566,"private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciDN2=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _reciCertOaep=CMSTestUtil.makeOaepCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
    _reciEcKP2=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert2=CMSTestUtil.makeCertificate(_reciEcKP2,_reciDN2,_signKP,_signDN);
  }
}","private static void init() throws Exception {
  if (!_initialised) {
    _initialised=true;
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
    _signDN=""String_Node_Str"";
    _signKP=CMSTestUtil.makeKeyPair();
    _signCert=CMSTestUtil.makeCertificate(_signKP,_signDN,_signKP,_signDN);
    _origDN=""String_Node_Str"";
    _origKP=CMSTestUtil.makeKeyPair();
    _origCert=CMSTestUtil.makeCertificate(_origKP,_origDN,_signKP,_signDN);
    _reciDN=""String_Node_Str"";
    _reciDN2=""String_Node_Str"";
    _reciKP=CMSTestUtil.makeKeyPair();
    _reciCert=CMSTestUtil.makeCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _reciCertOaep=CMSTestUtil.makeOaepCertificate(_reciKP,_reciDN,_signKP,_signDN);
    _origEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcKP=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert=CMSTestUtil.makeCertificate(_reciEcKP,_reciDN,_signKP,_signDN);
    _reciEcKP2=CMSTestUtil.makeEcDsaKeyPair();
    _reciEcCert2=CMSTestUtil.makeCertificate(_reciEcKP2,_reciDN2,_signKP,_signDN);
  }
}"
52567,"public ECPoint createPoint(BigInteger x,BigInteger y,boolean withCompression){
  ECFieldElement X=fromBigInteger(x), Y=fromBigInteger(y);
switch (this.getCoordinateSystem()) {
case COORD_LAMBDA_AFFINE:
case COORD_LAMBDA_PROJECTIVE:
{
      if (!X.isZero()) {
        Y=Y.divide(X).add(X);
      }
      break;
    }
default :
{
    break;
  }
}
return createRawPoint(X,Y,withCompression);
}","public ECPoint createPoint(BigInteger x,BigInteger y,boolean withCompression){
  ECFieldElement X=fromBigInteger(x), Y=fromBigInteger(y);
switch (this.getCoordinateSystem()) {
case COORD_LAMBDA_AFFINE:
case COORD_LAMBDA_PROJECTIVE:
{
      if (X.isZero()) {
        if (!Y.square().equals(getB())) {
          throw new IllegalArgumentException();
        }
      }
 else {
        Y=Y.divide(X).add(X);
      }
      break;
    }
default :
{
    break;
  }
}
return createRawPoint(X,Y,withCompression);
}"
52568,"/** 
 * Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
 * @param yTilde ~yp, an indication bit for the decompression of yp.
 * @param X1 The field element xp.
 * @return the decompressed point.
 */
protected ECPoint decompressPoint(int yTilde,BigInteger X1){
  ECFieldElement xp=fromBigInteger(X1);
  ECFieldElement yp=null;
  if (xp.isZero()) {
    yp=(ECFieldElement.F2m)b;
    for (int i=0; i < m - 1; i++) {
      yp=yp.square();
    }
  }
 else {
    ECFieldElement beta=xp.add(a).add(b.multiply(xp.square().invert()));
    ECFieldElement z=solveQuadraticEquation(beta);
    if (z == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (z.testBitZero() != (yTilde == 1)) {
      z=z.addOne();
    }
    yp=xp.multiply(z);
switch (this.getCoordinateSystem()) {
case COORD_LAMBDA_AFFINE:
case COORD_LAMBDA_PROJECTIVE:
{
        yp=yp.divide(xp).add(xp);
        break;
      }
default :
{
      break;
    }
}
}
return new ECPoint.F2m(this,xp,yp,true);
}","/** 
 * Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
 * @param yTilde ~yp, an indication bit for the decompression of yp.
 * @param X1 The field element xp.
 * @return the decompressed point.
 */
protected ECPoint decompressPoint(int yTilde,BigInteger X1){
  ECFieldElement xp=fromBigInteger(X1);
  ECFieldElement yp;
  if (xp.isZero()) {
    yp=b.sqrt();
  }
 else {
    ECFieldElement beta=xp.add(a).add(b.multiply(xp.square().invert()));
    ECFieldElement z=solveQuadraticEquation(beta);
    if (z == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (z.testBitZero() != (yTilde == 1)) {
      z=z.addOne();
    }
    yp=xp.multiply(z);
switch (this.getCoordinateSystem()) {
case COORD_LAMBDA_AFFINE:
case COORD_LAMBDA_PROJECTIVE:
{
        yp=yp.divide(xp).add(xp);
        break;
      }
default :
{
      break;
    }
}
}
return new ECPoint.F2m(this,xp,yp,true);
}"
52569,"protected ECFieldElement getRawYCoord(){
  return y;
}","protected final ECFieldElement getRawYCoord(){
  return y;
}"
52570,"public ECPoint threeTimes(){
  if (this.isInfinity() || this.y.isZero()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  int coord=curve.getCoordinateSystem();
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement X1=this.x, Y1=this.y;
      ECFieldElement _2Y1=two(Y1);
      ECFieldElement X=_2Y1.square();
      ECFieldElement Z=three(X1.square()).add(this.getCurve().getA());
      ECFieldElement Y=Z.square();
      ECFieldElement d=three(X1).multiply(X).subtract(Y);
      if (d.isZero()) {
        return this.getCurve().getInfinity();
      }
      ECFieldElement D=d.multiply(_2Y1);
      ECFieldElement I=D.invert();
      ECFieldElement L1=d.multiply(I).multiply(Z);
      ECFieldElement L2=X.square().multiply(I).subtract(L1);
      ECFieldElement X4=(L2.subtract(L1)).multiply(L1.add(L2)).add(X1);
      ECFieldElement Y4=(X1.subtract(X4)).multiply(L2).subtract(Y1);
      return new ECPoint.Fp(curve,X4,Y4,this.withCompression);
    }
case ECCurve.COORD_JACOBIAN_MODIFIED:
{
    return twiceJacobianModified(false).add(this);
  }
default :
{
  return twice().add(this);
}
}
}","public ECPoint threeTimes(){
  if (this.isInfinity()) {
    return this;
  }
  ECFieldElement Y1=this.y;
  if (Y1.isZero()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  int coord=curve.getCoordinateSystem();
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement X1=this.x;
      ECFieldElement _2Y1=two(Y1);
      ECFieldElement X=_2Y1.square();
      ECFieldElement Z=three(X1.square()).add(this.getCurve().getA());
      ECFieldElement Y=Z.square();
      ECFieldElement d=three(X1).multiply(X).subtract(Y);
      if (d.isZero()) {
        return this.getCurve().getInfinity();
      }
      ECFieldElement D=d.multiply(_2Y1);
      ECFieldElement I=D.invert();
      ECFieldElement L1=d.multiply(I).multiply(Z);
      ECFieldElement L2=X.square().multiply(I).subtract(L1);
      ECFieldElement X4=(L2.subtract(L1)).multiply(L1.add(L2)).add(X1);
      ECFieldElement Y4=(X1.subtract(X4)).multiply(L2).subtract(Y1);
      return new ECPoint.Fp(curve,X4,Y4,this.withCompression);
    }
case ECCurve.COORD_JACOBIAN_MODIFIED:
{
    return twiceJacobianModified(false).add(this);
  }
default :
{
  return twice().add(this);
}
}
}"
52571,"protected ECFieldElement getRawXCoord(){
  return x;
}","protected final ECFieldElement getRawXCoord(){
  return x;
}"
52572,"public ECPoint twicePlus(ECPoint b){
  if (this.isInfinity()) {
    return b;
  }
  if (b.isInfinity()) {
    return twice();
  }
  ECCurve curve=this.getCurve();
  ECFieldElement X1=this.x;
  if (X1.isZero()) {
    return b;
  }
  int coord=curve.getCoordinateSystem();
switch (coord) {
case ECCurve.COORD_LAMBDA_PROJECTIVE:
{
      ECFieldElement X2=b.x, Z2=b.zs[0];
      if (X2.isZero() || !Z2.isOne()) {
        return twice().add(b);
      }
      ECFieldElement L1=this.y, Z1=this.zs[0];
      ECFieldElement L2=b.y;
      ECFieldElement X1Sq=X1.square();
      ECFieldElement L1Sq=L1.square();
      ECFieldElement Z1Sq=Z1.square();
      ECFieldElement L1Z1=L1.multiply(Z1);
      ECFieldElement T=curve.getA().multiply(Z1Sq).add(L1Sq).add(L1Z1);
      ECFieldElement L2plus1=L2.addOne();
      ECFieldElement A=curve.getA().add(L2plus1).multiply(Z1Sq).add(L1Sq).multiply(T).add(X1Sq.multiply(Z1Sq));
      ECFieldElement X2Z1Sq=X2.multiply(Z1Sq);
      ECFieldElement B=X2Z1Sq.add(T).square();
      ECFieldElement X3=A.square().multiply(X2Z1Sq);
      ECFieldElement Z3=A.multiply(B).multiply(Z1Sq);
      ECFieldElement L3=A.add(B).square().multiply(T).add(L2plus1.multiply(Z3));
      return new ECPoint.F2m(curve,X3,L3,new ECFieldElement[]{Z3},this.withCompression);
    }
default :
{
    return twice().add(b);
  }
}
}","public ECPoint twicePlus(ECPoint b){
  if (this == b) {
    return threeTimes();
  }
  if (this.isInfinity()) {
    return b;
  }
  if (b.isInfinity()) {
    return twice();
  }
  ECFieldElement Y1=this.y;
  if (Y1.isZero()) {
    return b;
  }
  ECCurve curve=this.getCurve();
  int coord=curve.getCoordinateSystem();
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement X1=this.x;
      ECFieldElement X2=b.x, Y2=b.y;
      ECFieldElement dx=X2.subtract(X1), dy=Y2.subtract(Y1);
      if (dx.isZero()) {
        if (dy.isZero()) {
          return threeTimes();
        }
        return this;
      }
      ECFieldElement X=dx.square(), Y=dy.square();
      ECFieldElement d=X.multiply(two(X1).add(X2)).subtract(Y);
      if (d.isZero()) {
        return curve.getInfinity();
      }
      ECFieldElement D=d.multiply(dx);
      ECFieldElement I=D.invert();
      ECFieldElement L1=d.multiply(I).multiply(dy);
      ECFieldElement L2=two(Y1).multiply(X).multiply(dx).multiply(I).subtract(L1);
      ECFieldElement X4=(L2.subtract(L1)).multiply(L1.add(L2)).add(X2);
      ECFieldElement Y4=(X1.subtract(X4)).multiply(L2).subtract(Y1);
      return new ECPoint.Fp(curve,X4,Y4,this.withCompression);
    }
case ECCurve.COORD_JACOBIAN_MODIFIED:
{
    return twiceJacobianModified(false).add(b);
  }
default :
{
  return twice().add(b);
}
}
}"
52573,"public ECPoint twice(){
  if (this.isInfinity()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  ECFieldElement X1=this.x;
  if (X1.isZero()) {
    return curve.getInfinity();
  }
  int coord=curve.getCoordinateSystem();
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement Y1=this.y;
      ECFieldElement L1=Y1.divide(X1).add(X1);
      ECFieldElement X3=L1.square().add(L1).add(curve.getA());
      ECFieldElement Y3=X1.square().add(X3.multiply(L1.addOne()));
      return new ECPoint.F2m(curve,X3,Y3,this.withCompression);
    }
case ECCurve.COORD_HOMOGENEOUS:
{
    ECFieldElement Y1=this.y, Z1=this.zs[0];
    boolean Z1IsOne=Z1.isOne();
    ECFieldElement X1Z1=Z1IsOne ? X1 : X1.multiply(Z1);
    ECFieldElement Y1Z1=Z1IsOne ? Y1 : Y1.multiply(Z1);
    ECFieldElement X1Sq=X1.square();
    ECFieldElement S=X1Sq.add(Y1Z1);
    ECFieldElement V=X1Z1;
    ECFieldElement vSquared=V.square();
    ECFieldElement h=S.square().add(S.multiply(V)).add(curve.getA().multiply(vSquared));
    ECFieldElement X3=V.multiply(h);
    ECFieldElement Y3=h.multiply(S.add(V)).add(X1Sq.square().multiply(V));
    ECFieldElement Z3=V.multiply(vSquared);
    return new ECPoint.F2m(curve,X3,Y3,new ECFieldElement[]{Z3},this.withCompression);
  }
case ECCurve.COORD_LAMBDA_PROJECTIVE:
{
  ECFieldElement L1=this.y, Z1=this.zs[0];
  boolean Z1IsOne=Z1.isOne();
  ECFieldElement L1Z1=Z1IsOne ? L1 : L1.multiply(Z1);
  ECFieldElement Z1Sq=Z1IsOne ? Z1 : Z1.square();
  ECFieldElement a=curve.getA();
  ECFieldElement aZ1Sq=Z1IsOne ? a : a.multiply(Z1Sq);
  ECFieldElement T=L1.square().add(L1Z1).add(aZ1Sq);
  ECFieldElement X3=T.square();
  ECFieldElement Z3=Z1IsOne ? T : T.multiply(Z1Sq);
  ECFieldElement b=curve.getB();
  ECFieldElement L3;
  if (b.bitLength() < (curve.getFieldSize() >> 1)) {
    ECFieldElement t1=L1.add(X1).square();
    ECFieldElement t4;
    if (b.isOne()) {
      t4=aZ1Sq.add(Z1Sq).square();
    }
 else {
      ECFieldElement t2=aZ1Sq.square();
      ECFieldElement t3=b.multiply(Z1Sq.square());
      t4=t2.add(t3);
    }
    L3=t1.add(T).add(Z1Sq).multiply(t1).add(t4).add(X3);
    if (a.isZero()) {
      L3=L3.add(Z3);
    }
 else     if (!a.isOne()) {
      L3=L3.add(a.addOne().multiply(Z3));
    }
  }
 else {
    ECFieldElement X1Z1=Z1IsOne ? X1 : X1.multiply(Z1);
    L3=X1Z1.square().add(X3).add(T.multiply(L1Z1)).add(Z3);
  }
  return new ECPoint.F2m(curve,X3,L3,new ECFieldElement[]{Z3},this.withCompression);
}
default :
{
throw new IllegalStateException(""String_Node_Str"");
}
}
}","public ECPoint twice(){
  if (this.isInfinity()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  ECFieldElement X1=this.x;
  if (X1.isZero()) {
    return curve.getInfinity();
  }
  int coord=curve.getCoordinateSystem();
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement Y1=this.y;
      ECFieldElement L1=Y1.divide(X1).add(X1);
      ECFieldElement X3=L1.square().add(L1).add(curve.getA());
      ECFieldElement Y3=X1.square().add(X3.multiply(L1.addOne()));
      return new ECPoint.F2m(curve,X3,Y3,this.withCompression);
    }
case ECCurve.COORD_HOMOGENEOUS:
{
    ECFieldElement Y1=this.y, Z1=this.zs[0];
    boolean Z1IsOne=Z1.isOne();
    ECFieldElement X1Z1=Z1IsOne ? X1 : X1.multiply(Z1);
    ECFieldElement Y1Z1=Z1IsOne ? Y1 : Y1.multiply(Z1);
    ECFieldElement X1Sq=X1.square();
    ECFieldElement S=X1Sq.add(Y1Z1);
    ECFieldElement V=X1Z1;
    ECFieldElement vSquared=V.square();
    ECFieldElement h=S.square().add(S.multiply(V)).add(curve.getA().multiply(vSquared));
    ECFieldElement X3=V.multiply(h);
    ECFieldElement Y3=h.multiply(S.add(V)).add(X1Sq.square().multiply(V));
    ECFieldElement Z3=V.multiply(vSquared);
    return new ECPoint.F2m(curve,X3,Y3,new ECFieldElement[]{Z3},this.withCompression);
  }
case ECCurve.COORD_LAMBDA_PROJECTIVE:
{
  ECFieldElement L1=this.y, Z1=this.zs[0];
  boolean Z1IsOne=Z1.isOne();
  ECFieldElement L1Z1=Z1IsOne ? L1 : L1.multiply(Z1);
  ECFieldElement Z1Sq=Z1IsOne ? Z1 : Z1.square();
  ECFieldElement a=curve.getA();
  ECFieldElement aZ1Sq=Z1IsOne ? a : a.multiply(Z1Sq);
  ECFieldElement T=L1.square().add(L1Z1).add(aZ1Sq);
  ECFieldElement X3=T.square();
  if (X3.isZero()) {
    return new ECPoint.F2m(curve,X3,curve.getB().sqrt(),withCompression);
  }
  ECFieldElement Z3=Z1IsOne ? T : T.multiply(Z1Sq);
  ECFieldElement b=curve.getB();
  ECFieldElement L3;
  if (b.bitLength() < (curve.getFieldSize() >> 1)) {
    ECFieldElement t1=L1.add(X1).square();
    ECFieldElement t4;
    if (b.isOne()) {
      t4=aZ1Sq.add(Z1Sq).square();
    }
 else {
      ECFieldElement t2=aZ1Sq.square();
      ECFieldElement t3=b.multiply(Z1Sq.square());
      t4=t2.add(t3);
    }
    L3=t1.add(T).add(Z1Sq).multiply(t1).add(t4).add(X3);
    if (a.isZero()) {
      L3=L3.add(Z3);
    }
 else     if (!a.isOne()) {
      L3=L3.add(a.addOne().multiply(Z3));
    }
  }
 else {
    ECFieldElement X1Z1=Z1IsOne ? X1 : X1.multiply(Z1);
    L3=X1Z1.square().add(X3).add(T.multiply(L1Z1)).add(Z3);
  }
  return new ECPoint.F2m(curve,X3,L3,new ECFieldElement[]{Z3},this.withCompression);
}
default :
{
throw new IllegalStateException(""String_Node_Str"");
}
}
}"
52574,"/** 
 * Adds another <code>ECPoints.F2m</code> to <code>this</code> without checking if both points are on the same curve. Used by multiplication algorithms, because there all points are a multiple of the same point and hence the checks can be omitted.
 * @param b The other <code>ECPoints.F2m</code> to add to<code>this</code>.
 * @return <code>this + b</code>
 */
public ECPoint.F2m addSimple(ECPoint.F2m b){
  if (this.isInfinity()) {
    return b;
  }
  if (b.isInfinity()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  int coord=curve.getCoordinateSystem();
  ECFieldElement X1=this.x;
  ECFieldElement X2=b.x;
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement Y1=this.y;
      ECFieldElement Y2=b.y;
      if (X1.equals(X2)) {
        if (Y1.equals(Y2)) {
          return (ECPoint.F2m)twice();
        }
        return (ECPoint.F2m)curve.getInfinity();
      }
      ECFieldElement sumX=X1.add(X2);
      ECFieldElement L=Y1.add(Y2).divide(sumX);
      ECFieldElement X3=L.square().add(L).add(sumX).add(curve.getA());
      ECFieldElement Y3=L.multiply(X1.add(X3)).add(X3).add(Y1);
      return new ECPoint.F2m(curve,X3,Y3,this.withCompression);
    }
case ECCurve.COORD_HOMOGENEOUS:
{
    ECFieldElement Y1=this.y, Z1=this.zs[0];
    ECFieldElement Y2=b.y, Z2=b.zs[0];
    boolean Z2IsOne=Z2.isOne();
    ECFieldElement U1=Z1.multiply(Y2);
    ECFieldElement U2=Z2IsOne ? Y1 : Y1.multiply(Z2);
    ECFieldElement U=U1.subtract(U2);
    ECFieldElement V1=Z1.multiply(X2);
    ECFieldElement V2=Z2IsOne ? X1 : X1.multiply(Z2);
    ECFieldElement V=V1.subtract(V2);
    if (V1.equals(V2)) {
      if (U1.equals(U2)) {
        return (ECPoint.F2m)twice();
      }
      return (ECPoint.F2m)curve.getInfinity();
    }
    ECFieldElement VSq=V.square();
    ECFieldElement W=Z2IsOne ? Z1 : Z1.multiply(Z2);
    ECFieldElement A=U.square().add(U.multiply(V).add(VSq.multiply(curve.getA()))).multiply(W).add(V.multiply(VSq));
    ECFieldElement X3=V.multiply(A);
    ECFieldElement VSqZ2=Z2IsOne ? VSq : VSq.multiply(Z2);
    ECFieldElement Y3=VSqZ2.multiply(U.multiply(X1).add(Y1.multiply(V))).add(A.multiply(U.add(V)));
    ECFieldElement Z3=VSq.multiply(V).multiply(W);
    return new ECPoint.F2m(curve,X3,Y3,new ECFieldElement[]{Z3},this.withCompression);
  }
case ECCurve.COORD_LAMBDA_PROJECTIVE:
{
  if (X1.isZero()) {
    return b.addSimple(this);
  }
  ECFieldElement L1=this.y, Z1=this.zs[0];
  ECFieldElement L2=b.y, Z2=b.zs[0];
  boolean Z1IsOne=Z1.isOne();
  ECFieldElement U2=X2, S2=L2;
  if (!Z1IsOne) {
    U2=U2.multiply(Z1);
    S2=S2.multiply(Z1);
  }
  boolean Z2IsOne=Z2.isOne();
  ECFieldElement U1=X1, S1=L1;
  if (!Z2IsOne) {
    U1=U1.multiply(Z2);
    S1=S1.multiply(Z2);
  }
  ECFieldElement A=S1.add(S2);
  ECFieldElement B=U1.add(U2);
  if (B.isZero()) {
    if (A.isZero()) {
      return (ECPoint.F2m)twice();
    }
    return (ECPoint.F2m)curve.getInfinity();
  }
  ECFieldElement X3, L3, Z3;
  if (X2.isZero()) {
    ECFieldElement Y1=getYCoord(), Y2=L2;
    ECFieldElement L=Y1.add(Y2).divide(X1);
    X3=L.square().add(L).add(X1).add(curve.getA());
    ECFieldElement Y3=L.multiply(X1.add(X3)).add(X3).add(Y1);
    L3=X3.isZero() ? Y3 : Y3.divide(X3).add(X3);
    Z3=curve.fromBigInteger(ECConstants.ONE);
  }
 else {
    B=B.square();
    ECFieldElement AU1=A.multiply(U1);
    ECFieldElement AU2=A.multiply(U2);
    ECFieldElement ABZ2=A.multiply(B);
    if (!Z2IsOne) {
      ABZ2=ABZ2.multiply(Z2);
    }
    X3=AU1.multiply(AU2);
    L3=AU2.add(B).square().add(ABZ2.multiply(L1.add(Z1)));
    Z3=ABZ2;
    if (!Z1IsOne) {
      Z3=Z3.multiply(Z1);
    }
  }
  return new ECPoint.F2m(curve,X3,L3,new ECFieldElement[]{Z3},this.withCompression);
}
default :
{
throw new IllegalStateException(""String_Node_Str"");
}
}
}","/** 
 * Adds another <code>ECPoints.F2m</code> to <code>this</code> without checking if both points are on the same curve. Used by multiplication algorithms, because there all points are a multiple of the same point and hence the checks can be omitted.
 * @param b The other <code>ECPoints.F2m</code> to add to<code>this</code>.
 * @return <code>this + b</code>
 */
public ECPoint.F2m addSimple(ECPoint.F2m b){
  if (this.isInfinity()) {
    return b;
  }
  if (b.isInfinity()) {
    return this;
  }
  ECCurve curve=this.getCurve();
  int coord=curve.getCoordinateSystem();
  ECFieldElement X1=this.x;
  ECFieldElement X2=b.x;
switch (coord) {
case ECCurve.COORD_AFFINE:
{
      ECFieldElement Y1=this.y;
      ECFieldElement Y2=b.y;
      if (X1.equals(X2)) {
        if (Y1.equals(Y2)) {
          return (ECPoint.F2m)twice();
        }
        return (ECPoint.F2m)curve.getInfinity();
      }
      ECFieldElement sumX=X1.add(X2);
      ECFieldElement L=Y1.add(Y2).divide(sumX);
      ECFieldElement X3=L.square().add(L).add(sumX).add(curve.getA());
      ECFieldElement Y3=L.multiply(X1.add(X3)).add(X3).add(Y1);
      return new ECPoint.F2m(curve,X3,Y3,this.withCompression);
    }
case ECCurve.COORD_HOMOGENEOUS:
{
    ECFieldElement Y1=this.y, Z1=this.zs[0];
    ECFieldElement Y2=b.y, Z2=b.zs[0];
    boolean Z2IsOne=Z2.isOne();
    ECFieldElement U1=Z1.multiply(Y2);
    ECFieldElement U2=Z2IsOne ? Y1 : Y1.multiply(Z2);
    ECFieldElement U=U1.subtract(U2);
    ECFieldElement V1=Z1.multiply(X2);
    ECFieldElement V2=Z2IsOne ? X1 : X1.multiply(Z2);
    ECFieldElement V=V1.subtract(V2);
    if (V1.equals(V2)) {
      if (U1.equals(U2)) {
        return (ECPoint.F2m)twice();
      }
      return (ECPoint.F2m)curve.getInfinity();
    }
    ECFieldElement VSq=V.square();
    ECFieldElement W=Z2IsOne ? Z1 : Z1.multiply(Z2);
    ECFieldElement A=U.square().add(U.multiply(V).add(VSq.multiply(curve.getA()))).multiply(W).add(V.multiply(VSq));
    ECFieldElement X3=V.multiply(A);
    ECFieldElement VSqZ2=Z2IsOne ? VSq : VSq.multiply(Z2);
    ECFieldElement Y3=VSqZ2.multiply(U.multiply(X1).add(Y1.multiply(V))).add(A.multiply(U.add(V)));
    ECFieldElement Z3=VSq.multiply(V).multiply(W);
    return new ECPoint.F2m(curve,X3,Y3,new ECFieldElement[]{Z3},this.withCompression);
  }
case ECCurve.COORD_LAMBDA_PROJECTIVE:
{
  if (X1.isZero()) {
    if (X2.isZero()) {
      return (ECPoint.F2m)curve.getInfinity();
    }
    return b.addSimple(this);
  }
  ECFieldElement L1=this.y, Z1=this.zs[0];
  ECFieldElement L2=b.y, Z2=b.zs[0];
  boolean Z1IsOne=Z1.isOne();
  ECFieldElement U2=X2, S2=L2;
  if (!Z1IsOne) {
    U2=U2.multiply(Z1);
    S2=S2.multiply(Z1);
  }
  boolean Z2IsOne=Z2.isOne();
  ECFieldElement U1=X1, S1=L1;
  if (!Z2IsOne) {
    U1=U1.multiply(Z2);
    S1=S1.multiply(Z2);
  }
  ECFieldElement A=S1.add(S2);
  ECFieldElement B=U1.add(U2);
  if (B.isZero()) {
    if (A.isZero()) {
      return (ECPoint.F2m)twice();
    }
    return (ECPoint.F2m)curve.getInfinity();
  }
  ECFieldElement X3, L3, Z3;
  if (X2.isZero()) {
    ECPoint p=this.normalize();
    X1=p.getXCoord();
    ECFieldElement Y1=p.getYCoord();
    ECFieldElement Y2=L2;
    ECFieldElement L=Y1.add(Y2).divide(X1);
    X3=L.square().add(L).add(X1).add(curve.getA());
    if (X3.isZero()) {
      return new ECPoint.F2m(curve,X3,curve.getB().sqrt(),this.withCompression);
    }
    ECFieldElement Y3=L.multiply(X1.add(X3)).add(X3).add(Y1);
    L3=Y3.divide(X3).add(X3);
    Z3=curve.fromBigInteger(ECConstants.ONE);
  }
 else {
    B=B.square();
    ECFieldElement AU1=A.multiply(U1);
    ECFieldElement AU2=A.multiply(U2);
    X3=AU1.multiply(AU2);
    if (X3.isZero()) {
      return new ECPoint.F2m(curve,X3,curve.getB().sqrt(),this.withCompression);
    }
    ECFieldElement ABZ2=A.multiply(B);
    if (!Z2IsOne) {
      ABZ2=ABZ2.multiply(Z2);
    }
    L3=AU2.add(B).square().add(ABZ2.multiply(L1.add(Z1)));
    Z3=ABZ2;
    if (!Z1IsOne) {
      Z3=Z3.multiply(Z1);
    }
  }
  return new ECPoint.F2m(curve,X3,L3,new ECFieldElement[]{Z3},this.withCompression);
}
default :
{
throw new IllegalStateException(""String_Node_Str"");
}
}
}"
52575,"public void testGenerateWithMetadata() throws Exception {
  cmsTimeStampedDataGenerator.setMetaData(true,fileInput,""String_Node_Str"");
  BcDigestCalculatorProvider calculatorProvider=new BcDigestCalculatorProvider();
  String algOID=""String_Node_Str"";
  DigestCalculator hashCalculator=calculatorProvider.get(new AlgorithmIdentifier(algOID));
  cmsTimeStampedDataGenerator.initialiseMessageImprintDigestCalculator(hashCalculator);
  hashCalculator.getOutputStream().write(baseData);
  hashCalculator.getOutputStream().close();
  TimeStampToken timeStampToken=createTimeStampToken(hashCalculator.getDigest(),NISTObjectIdentifiers.id_sha256);
  CMSTimeStampedData cmsTimeStampedData=cmsTimeStampedDataGenerator.generate(timeStampToken,baseData);
  for (int i=0; i < 3; i++) {
    byte[] newRequestData=cmsTimeStampedData.calculateNextHash(hashCalculator);
    TimeStampToken newTimeStampToken=createTimeStampToken(newRequestData,NISTObjectIdentifiers.id_sha256);
    cmsTimeStampedData=cmsTimeStampedData.addTimeStamp(newTimeStampToken);
  }
  byte[] timeStampedData=cmsTimeStampedData.getEncoded();
  metadataCheck(timeStampedData);
  metadataParserCheck(timeStampedData);
}","public void testGenerateWithMetadata() throws Exception {
  cmsTimeStampedDataGenerator.setMetaData(true,fileInput,""String_Node_Str"");
  BcDigestCalculatorProvider calculatorProvider=new BcDigestCalculatorProvider();
  String algOID=""String_Node_Str"";
  DigestCalculator hashCalculator=calculatorProvider.get(new AlgorithmIdentifier(algOID));
  cmsTimeStampedDataGenerator.initialiseMessageImprintDigestCalculator(hashCalculator);
  hashCalculator.getOutputStream().write(baseData);
  hashCalculator.getOutputStream().close();
  TimeStampToken timeStampToken=createTimeStampToken(hashCalculator.getDigest(),NISTObjectIdentifiers.id_sha256);
  CMSTimeStampedData cmsTimeStampedData=cmsTimeStampedDataGenerator.generate(timeStampToken,baseData);
  for (int i=0; i <= 3; i++) {
    byte[] newRequestData=cmsTimeStampedData.calculateNextHash(hashCalculator);
    TimeStampToken newTimeStampToken=createTimeStampToken(newRequestData,NISTObjectIdentifiers.id_sha256);
    cmsTimeStampedData=cmsTimeStampedData.addTimeStamp(newTimeStampToken);
  }
  byte[] timeStampedData=cmsTimeStampedData.getEncoded();
  metadataCheck(timeStampedData);
  metadataParserCheck(timeStampedData);
}"
52576,"private void metadataCheck(byte[] timeStampedData) throws Exception {
  CMSTimeStampedData cmsTspData=new CMSTimeStampedData(timeStampedData);
  DigestCalculatorProvider newCalculatorProvider=new BcDigestCalculatorProvider();
  DigestCalculator imprintCalculator=cmsTspData.getMessageImprintDigestCalculator(newCalculatorProvider);
  byte[] newContent=cmsTspData.getContent();
  assertEquals(""String_Node_Str"",true,Arrays.areEqual(newContent,baseData));
  imprintCalculator.getOutputStream().write(newContent);
  assertEquals(fileInput,cmsTspData.getFileName());
  assertEquals(""String_Node_Str"",cmsTspData.getMediaType());
  byte[] digest=imprintCalculator.getDigest();
  TimeStampToken[] tokens=cmsTspData.getTimeStampTokens();
  assertEquals(""String_Node_Str"",4,tokens.length);
  for (int i=0; i < tokens.length; i++) {
    cmsTspData.validate(newCalculatorProvider,digest,tokens[i]);
  }
}","private void metadataCheck(byte[] timeStampedData) throws Exception {
  CMSTimeStampedData cmsTspData=new CMSTimeStampedData(timeStampedData);
  DigestCalculatorProvider newCalculatorProvider=new BcDigestCalculatorProvider();
  DigestCalculator imprintCalculator=cmsTspData.getMessageImprintDigestCalculator(newCalculatorProvider);
  byte[] newContent=cmsTspData.getContent();
  assertEquals(""String_Node_Str"",true,Arrays.areEqual(newContent,baseData));
  imprintCalculator.getOutputStream().write(newContent);
  assertEquals(fileInput,cmsTspData.getFileName());
  assertEquals(""String_Node_Str"",cmsTspData.getMediaType());
  byte[] digest=imprintCalculator.getDigest();
  TimeStampToken[] tokens=cmsTspData.getTimeStampTokens();
  assertEquals(""String_Node_Str"",5,tokens.length);
  for (int i=0; i < tokens.length; i++) {
    cmsTspData.validate(newCalculatorProvider,digest,tokens[i]);
  }
}"
52577,"private void metadataParserCheck(byte[] timeStampedData) throws Exception {
  CMSTimeStampedDataParser cmsTspData=new CMSTimeStampedDataParser(timeStampedData);
  DigestCalculatorProvider newCalculatorProvider=new BcDigestCalculatorProvider();
  InputStream input=cmsTspData.getContent();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  Streams.pipeAll(input,bOut);
  assertEquals(""String_Node_Str"",true,Arrays.areEqual(bOut.toByteArray(),baseData));
  DigestCalculator imprintCalculator=cmsTspData.getMessageImprintDigestCalculator(newCalculatorProvider);
  Streams.pipeAll(new ByteArrayInputStream(bOut.toByteArray()),imprintCalculator.getOutputStream());
  assertEquals(fileInput,cmsTspData.getFileName());
  assertEquals(""String_Node_Str"",cmsTspData.getMediaType());
  byte[] digest=imprintCalculator.getDigest();
  TimeStampToken[] tokens=cmsTspData.getTimeStampTokens();
  assertEquals(""String_Node_Str"",4,tokens.length);
  for (int i=0; i < tokens.length; i++) {
    cmsTspData.validate(newCalculatorProvider,digest,tokens[i]);
  }
}","private void metadataParserCheck(byte[] timeStampedData) throws Exception {
  CMSTimeStampedDataParser cmsTspData=new CMSTimeStampedDataParser(timeStampedData);
  DigestCalculatorProvider newCalculatorProvider=new BcDigestCalculatorProvider();
  InputStream input=cmsTspData.getContent();
  ByteArrayOutputStream bOut=new ByteArrayOutputStream();
  Streams.pipeAll(input,bOut);
  assertEquals(""String_Node_Str"",true,Arrays.areEqual(bOut.toByteArray(),baseData));
  DigestCalculator imprintCalculator=cmsTspData.getMessageImprintDigestCalculator(newCalculatorProvider);
  Streams.pipeAll(new ByteArrayInputStream(bOut.toByteArray()),imprintCalculator.getOutputStream());
  assertEquals(fileInput,cmsTspData.getFileName());
  assertEquals(""String_Node_Str"",cmsTspData.getMediaType());
  byte[] digest=imprintCalculator.getDigest();
  TimeStampToken[] tokens=cmsTspData.getTimeStampTokens();
  assertEquals(""String_Node_Str"",5,tokens.length);
  for (int i=0; i < tokens.length; i++) {
    cmsTspData.validate(newCalculatorProvider,digest,tokens[i]);
  }
}"
52578,"/** 
 * Create a TimeStampRequest from the past in input stream.
 * @param in input stream containing the request.
 * @throws IOException if the request is malformed.
 */
public TimeStampRequest(InputStream in) throws IOException {
  try {
    this.req=TimeStampReq.getInstance(new ASN1InputStream(in).readObject());
  }
 catch (  ClassCastException e) {
    throw new IOException(""String_Node_Str"" + e);
  }
catch (  IllegalArgumentException e) {
    throw new IOException(""String_Node_Str"" + e);
  }
}","/** 
 * Create a TimeStampRequest from the past in input stream.
 * @param in input stream containing the request.
 * @throws IOException if the request is malformed.
 */
public TimeStampRequest(InputStream in) throws IOException {
  this(loadRequest(in));
}"
52579,"public int receive(byte[] buf,int off,int len,int waitMillis) throws IOException {
  byte[] record=null;
  for (; ; ) {
    int receiveLimit=Math.min(len,getReceiveLimit()) + RECORD_HEADER_LENGTH;
    if (record == null || record.length < receiveLimit) {
      record=new byte[receiveLimit];
    }
    try {
      if (retransmit != null && System.currentTimeMillis() > retransmitExpiry) {
        retransmit=null;
        retransmitEpoch=null;
      }
      int received=receiveRecord(record,0,receiveLimit,waitMillis);
      if (received < 0) {
        return received;
      }
      if (received < RECORD_HEADER_LENGTH) {
        continue;
      }
      int length=TlsUtils.readUint16(record,11);
      if (received != (length + RECORD_HEADER_LENGTH)) {
        continue;
      }
      short type=TlsUtils.readUint8(record,0);
switch (type) {
case ContentType.alert:
case ContentType.application_data:
case ContentType.change_cipher_spec:
case ContentType.handshake:
case ContentType.heartbeat:
        break;
default :
      continue;
  }
  int epoch=TlsUtils.readUint16(record,3);
  DTLSEpoch recordEpoch=null;
  if (epoch == readEpoch.getEpoch()) {
    recordEpoch=readEpoch;
  }
 else   if (type == ContentType.handshake && retransmitEpoch != null && epoch == retransmitEpoch.getEpoch()) {
    recordEpoch=retransmitEpoch;
  }
  if (recordEpoch == null) {
    continue;
  }
  long seq=TlsUtils.readUint48(record,5);
  if (recordEpoch.getReplayWindow().shouldDiscard(seq)) {
    continue;
  }
  ProtocolVersion version=TlsUtils.readVersion(record,1);
  if (discoveredPeerVersion != null && !discoveredPeerVersion.equals(version)) {
    continue;
  }
  byte[] plaintext=recordEpoch.getCipher().decodeCiphertext(getMacSequenceNumber(recordEpoch.getEpoch(),seq),type,record,RECORD_HEADER_LENGTH,received - RECORD_HEADER_LENGTH);
  recordEpoch.getReplayWindow().reportAuthenticated(seq);
  if (plaintext.length > this.plaintextLimit) {
    continue;
  }
  if (discoveredPeerVersion == null) {
    discoveredPeerVersion=version;
  }
switch (type) {
case ContentType.alert:
{
      if (plaintext.length == 2) {
        short alertLevel=plaintext[0];
        short alertDescription=plaintext[1];
        peer.notifyAlertReceived(alertLevel,alertDescription);
        if (alertLevel == AlertLevel.fatal) {
          fail(alertDescription);
          throw new TlsFatalAlert(alertDescription);
        }
        if (alertDescription == AlertDescription.close_notify) {
          closeTransport();
        }
      }
 else {
      }
      continue;
    }
case ContentType.application_data:
{
    if (inHandshake) {
      continue;
    }
    break;
  }
case ContentType.change_cipher_spec:
{
  for (int i=0; i < plaintext.length; ++i) {
    short message=TlsUtils.readUint8(plaintext,i);
    if (message != ChangeCipherSpec.change_cipher_spec) {
      continue;
    }
    if (pendingEpoch != null) {
      readEpoch=pendingEpoch;
    }
  }
  continue;
}
case ContentType.handshake:
{
if (!inHandshake) {
  if (retransmit != null) {
    retransmit.receivedHandshakeRecord(epoch,plaintext,0,plaintext.length);
  }
  continue;
}
}
case ContentType.heartbeat:
{
continue;
}
}
if (!inHandshake && retransmit != null) {
this.retransmit=null;
this.retransmitEpoch=null;
}
System.arraycopy(plaintext,0,buf,off,plaintext.length);
return plaintext.length;
}
 catch (IOException e) {
throw e;
}
}
}","public int receive(byte[] buf,int off,int len,int waitMillis) throws IOException {
  byte[] record=null;
  for (; ; ) {
    int receiveLimit=Math.min(len,getReceiveLimit()) + RECORD_HEADER_LENGTH;
    if (record == null || record.length < receiveLimit) {
      record=new byte[receiveLimit];
    }
    try {
      if (retransmit != null && System.currentTimeMillis() > retransmitExpiry) {
        retransmit=null;
        retransmitEpoch=null;
      }
      int received=receiveRecord(record,0,receiveLimit,waitMillis);
      if (received < 0) {
        return received;
      }
      if (received < RECORD_HEADER_LENGTH) {
        continue;
      }
      int length=TlsUtils.readUint16(record,11);
      if (received != (length + RECORD_HEADER_LENGTH)) {
        continue;
      }
      short type=TlsUtils.readUint8(record,0);
switch (type) {
case ContentType.alert:
case ContentType.application_data:
case ContentType.change_cipher_spec:
case ContentType.handshake:
case ContentType.heartbeat:
        break;
default :
      continue;
  }
  int epoch=TlsUtils.readUint16(record,3);
  DTLSEpoch recordEpoch=null;
  if (epoch == readEpoch.getEpoch()) {
    recordEpoch=readEpoch;
  }
 else   if (type == ContentType.handshake && retransmitEpoch != null && epoch == retransmitEpoch.getEpoch()) {
    recordEpoch=retransmitEpoch;
  }
  if (recordEpoch == null) {
    continue;
  }
  long seq=TlsUtils.readUint48(record,5);
  if (recordEpoch.getReplayWindow().shouldDiscard(seq)) {
    continue;
  }
  ProtocolVersion version=TlsUtils.readVersion(record,1);
  if (discoveredPeerVersion != null && !discoveredPeerVersion.equals(version)) {
    continue;
  }
  byte[] plaintext=recordEpoch.getCipher().decodeCiphertext(getMacSequenceNumber(recordEpoch.getEpoch(),seq),type,record,RECORD_HEADER_LENGTH,received - RECORD_HEADER_LENGTH);
  recordEpoch.getReplayWindow().reportAuthenticated(seq);
  if (plaintext.length > this.plaintextLimit) {
    continue;
  }
  if (discoveredPeerVersion == null) {
    discoveredPeerVersion=version;
  }
switch (type) {
case ContentType.alert:
{
      if (plaintext.length == 2) {
        short alertLevel=plaintext[0];
        short alertDescription=plaintext[1];
        peer.notifyAlertReceived(alertLevel,alertDescription);
        if (alertLevel == AlertLevel.fatal) {
          fail(alertDescription);
          throw new TlsFatalAlert(alertDescription);
        }
        if (alertDescription == AlertDescription.close_notify) {
          closeTransport();
        }
      }
 else {
      }
      continue;
    }
case ContentType.application_data:
{
    if (inHandshake) {
      continue;
    }
    break;
  }
case ContentType.change_cipher_spec:
{
  for (int i=0; i < plaintext.length; ++i) {
    short message=TlsUtils.readUint8(plaintext,i);
    if (message != ChangeCipherSpec.change_cipher_spec) {
      continue;
    }
    if (pendingEpoch != null) {
      readEpoch=pendingEpoch;
    }
  }
  continue;
}
case ContentType.handshake:
{
if (!inHandshake) {
  if (retransmit != null) {
    retransmit.receivedHandshakeRecord(epoch,plaintext,0,plaintext.length);
  }
  continue;
}
break;
}
case ContentType.heartbeat:
{
continue;
}
}
if (!inHandshake && retransmit != null) {
this.retransmit=null;
this.retransmitEpoch=null;
}
System.arraycopy(plaintext,0,buf,off,plaintext.length);
return plaintext.length;
}
 catch (IOException e) {
throw e;
}
}
}"
52580,"private byte[] bigIntToBytes(BigInteger r){
  byte[] tmp=r.toByteArray();
  if (tmp[0] == 0) {
    byte[] ntmp=new byte[tmp.length - 1];
    System.arraycopy(tmp,1,ntmp,0,ntmp.length);
    return ntmp;
  }
  return tmp;
}","private byte[] bigIntToBytes(BigInteger r){
  int expectedLength=(p.bitLength() + 7) / 8;
  byte[] tmp=r.toByteArray();
  if (tmp.length == expectedLength) {
    return tmp;
  }
  if (tmp[0] == 0 && tmp.length == expectedLength + 1) {
    byte[] rv=new byte[tmp.length - 1];
    System.arraycopy(tmp,1,rv,0,rv.length);
    return rv;
  }
  byte[] rv=new byte[expectedLength];
  System.arraycopy(tmp,0,rv,rv.length - tmp.length,tmp.length);
  return rv;
}"
52581,"private void testTwoParty(String algName,int size,int privateValueSize,KeyPairGenerator keyGen) throws Exception {
  KeyPair aKeyPair=keyGen.generateKeyPair();
  KeyAgreement aKeyAgree=KeyAgreement.getInstance(algName,""String_Node_Str"");
  checkKeySize(privateValueSize,aKeyPair);
  aKeyAgree.init(aKeyPair.getPrivate());
  KeyPair bKeyPair=keyGen.generateKeyPair();
  KeyAgreement bKeyAgree=KeyAgreement.getInstance(algName,""String_Node_Str"");
  checkKeySize(privateValueSize,bKeyPair);
  bKeyAgree.init(bKeyPair.getPrivate());
  aKeyAgree.doPhase(bKeyPair.getPublic(),true);
  bKeyAgree.doPhase(aKeyPair.getPublic(),true);
  BigInteger k1=new BigInteger(aKeyAgree.generateSecret());
  BigInteger k2=new BigInteger(bKeyAgree.generateSecret());
  if (!k1.equals(k2)) {
    fail(size + ""String_Node_Str"");
  }
}","private byte[] testTwoParty(String algName,int size,int privateValueSize,KeyPair aKeyPair,KeyPair bKeyPair) throws Exception {
  KeyAgreement aKeyAgree=KeyAgreement.getInstance(algName,""String_Node_Str"");
  checkKeySize(privateValueSize,aKeyPair);
  aKeyAgree.init(aKeyPair.getPrivate());
  KeyAgreement bKeyAgree=KeyAgreement.getInstance(algName,""String_Node_Str"");
  checkKeySize(privateValueSize,bKeyPair);
  bKeyAgree.init(bKeyPair.getPrivate());
  aKeyAgree.doPhase(bKeyPair.getPublic(),true);
  bKeyAgree.doPhase(aKeyPair.getPublic(),true);
  byte[] aSecret=aKeyAgree.generateSecret();
  byte[] bSecret=bKeyAgree.generateSecret();
  if (!Arrays.areEqual(aSecret,bSecret)) {
    fail(size + ""String_Node_Str"");
  }
  return aSecret;
}"
52582,"public void performTest() throws Exception {
  testDefault(64,g512,p512);
  testEnc();
  testGP(""String_Node_Str"",512,0,g512,p512);
  testGP(""String_Node_Str"",768,0,g768,p768);
  testGP(""String_Node_Str"",1024,0,g1024,p1024);
  testGP(""String_Node_Str"",512,64,g512,p512);
  testGP(""String_Node_Str"",768,128,g768,p768);
  testGP(""String_Node_Str"",1024,256,g1024,p1024);
  testExplicitWrapping(512,0,g512,p512);
  testRandom(256);
  testECDH(""String_Node_Str"");
  testECDH(""String_Node_Str"");
  testExceptions();
  testDESAndDESede(g768,p768);
  testInitialise();
  testConfig();
}","public void performTest() throws Exception {
  testDefault(64,g512,p512);
  testEnc();
  testGP(""String_Node_Str"",512,0,g512,p512);
  testGP(""String_Node_Str"",768,0,g768,p768);
  testGP(""String_Node_Str"",1024,0,g1024,p1024);
  testGP(""String_Node_Str"",512,64,g512,p512);
  testGP(""String_Node_Str"",768,128,g768,p768);
  testGP(""String_Node_Str"",1024,256,g1024,p1024);
  testExplicitWrapping(512,0,g512,p512);
  testRandom(256);
  testECDH(""String_Node_Str"");
  testECDH(""String_Node_Str"");
  testExceptions();
  testDESAndDESede(g768,p768);
  testInitialise();
  testSmallSecret();
  testConfig();
}"
52583,"private void appendValue(StringBuffer buf,Hashtable oidSymbols,ASN1ObjectIdentifier oid,String value){
  String sym=(String)oidSymbols.get(oid);
  if (sym != null) {
    buf.append(sym);
  }
 else {
    buf.append(oid.getId());
  }
  buf.append('=');
  int index=buf.length();
  int start=index;
  buf.append(value);
  int end=buf.length();
  if (value.length() >= 2 && value.charAt(0) == '\\' && value.charAt(1) == '#') {
    index+=2;
  }
  while (index != end) {
    if ((buf.charAt(index) == ',') || (buf.charAt(index) == '""') || (buf.charAt(index) == '\\')|| (buf.charAt(index) == '+')|| (buf.charAt(index) == '=')|| (buf.charAt(index) == '<')|| (buf.charAt(index) == '>')|| (buf.charAt(index) == ';')) {
      buf.insert(index,""String_Node_Str"");
      index++;
      end++;
    }
    index++;
  }
  while (buf.charAt(start) == ' ') {
    buf.insert(start,""String_Node_Str"");
    start+=2;
  }
  int endBuf=buf.length() - 1;
  while (endBuf >= 0 && buf.charAt(endBuf) == ' ') {
    buf.insert(endBuf,'\\');
    endBuf--;
  }
}","private void appendValue(StringBuffer buf,Hashtable oidSymbols,ASN1ObjectIdentifier oid,String value){
  String sym=(String)oidSymbols.get(oid);
  if (sym != null) {
    buf.append(sym);
  }
 else {
    buf.append(oid.getId());
  }
  buf.append('=');
  int index=buf.length();
  int start=index;
  buf.append(value);
  int end=buf.length();
  if (value.length() >= 2 && value.charAt(0) == '\\' && value.charAt(1) == '#') {
    index+=2;
  }
  while (index != end) {
    if ((buf.charAt(index) == ',') || (buf.charAt(index) == '""') || (buf.charAt(index) == '\\')|| (buf.charAt(index) == '+')|| (buf.charAt(index) == '=')|| (buf.charAt(index) == '<')|| (buf.charAt(index) == '>')|| (buf.charAt(index) == ';')) {
      buf.insert(index,""String_Node_Str"");
      index++;
      end++;
    }
    index++;
  }
  while (start < buf.length() && buf.charAt(start) == ' ') {
    buf.insert(start,""String_Node_Str"");
    start+=2;
  }
  int endBuf=buf.length() - 1;
  while (endBuf >= 0 && buf.charAt(endBuf) == ' ') {
    buf.insert(endBuf,'\\');
    endBuf--;
  }
}"
52584,"/** 
 * Encode this   {@link HeartbeatMessage} to an {@link OutputStream}.
 * @param output the  {@link OutputStream} to encode to.
 * @throws IOException
 */
public void encode(TlsContext context,OutputStream output) throws IOException {
  TlsUtils.writeUint8(type,output);
  if (payload == null) {
    TlsUtils.writeUint16(0,output);
  }
 else {
    TlsUtils.checkUint16(payload.length);
    TlsUtils.writeUint16(payload.length,output);
    output.write(payload);
  }
  byte[] padding=new byte[paddingLength];
  context.getSecureRandom().nextBytes(padding);
  output.write(padding);
}","/** 
 * Encode this   {@link HeartbeatMessage} to an {@link OutputStream}.
 * @param output the  {@link OutputStream} to encode to.
 * @throws IOException
 */
public void encode(TlsContext context,OutputStream output) throws IOException {
  TlsUtils.writeUint8(type,output);
  TlsUtils.checkUint16(payload.length);
  TlsUtils.writeUint16(payload.length,output);
  output.write(payload);
  byte[] padding=new byte[paddingLength];
  context.getSecureRandom().nextBytes(padding);
  output.write(padding);
}"
52585,"protected DTLSTransport clientHandshake(ClientHandshakeState state,DTLSRecordLayer recordLayer) throws IOException {
  SecurityParameters securityParameters=state.clientContext.getSecurityParameters();
  DTLSReliableHandshake handshake=new DTLSReliableHandshake(state.clientContext,recordLayer);
  byte[] clientHelloBody=generateClientHello(state,state.client);
  handshake.sendMessage(HandshakeType.client_hello,clientHelloBody);
  DTLSReliableHandshake.Message serverMessage=handshake.receiveMessage();
{
    ProtocolVersion server_version=recordLayer.getDiscoveredPeerVersion();
    ProtocolVersion client_version=state.clientContext.getClientVersion();
    if (!server_version.isEqualOrEarlierVersionOf(client_version)) {
      throw new TlsFatalAlert(AlertDescription.illegal_parameter);
    }
    state.clientContext.setServerVersion(server_version);
    state.client.notifyServerVersion(server_version);
  }
  while (serverMessage.getType() == HandshakeType.hello_verify_request) {
    byte[] cookie=parseHelloVerifyRequest(state.clientContext,serverMessage.getBody());
    byte[] patched=patchClientHelloWithCookie(clientHelloBody,cookie);
    handshake.resetHandshakeMessagesDigest();
    handshake.sendMessage(HandshakeType.client_hello,patched);
    serverMessage=handshake.receiveMessage();
  }
  if (serverMessage.getType() == HandshakeType.server_hello) {
    processServerHello(state,serverMessage.getBody());
    if (state.maxFragmentLength >= 0) {
      int plainTextLimit=1 << (8 + state.maxFragmentLength);
      recordLayer.setPlaintextLimit(plainTextLimit);
    }
    serverMessage=handshake.receiveMessage();
  }
 else {
    throw new TlsFatalAlert(AlertDescription.unexpected_message);
  }
  securityParameters.cipherSuite=state.selectedCipherSuite;
  securityParameters.compressionAlgorithm=state.selectedCompressionMethod;
  securityParameters.prfAlgorithm=TlsProtocol.getPRFAlgorithm(state.clientContext,state.selectedCipherSuite);
  securityParameters.verifyDataLength=12;
  handshake.notifyHelloComplete();
  boolean resumedSession=state.selectedSessionID.length > 0 && state.tlsSession != null && Arrays.areEqual(state.selectedSessionID,state.tlsSession.getSessionID());
  if (resumedSession) {
    if (securityParameters.getCipherSuite() != state.sessionParameters.getCipherSuite() || securityParameters.getCompressionAlgorithm() != state.sessionParameters.getCompressionAlgorithm()) {
      throw new TlsFatalAlert(AlertDescription.illegal_parameter);
    }
    securityParameters.masterSecret=Arrays.clone(state.sessionParameters.getMasterSecret());
    recordLayer.initPendingEpoch(state.client.getCipher());
    byte[] expectedServerVerifyData=TlsUtils.calculateVerifyData(state.clientContext,""String_Node_Str"",handshake.getCurrentHash());
    processFinished(handshake.receiveMessageBody(HandshakeType.finished),expectedServerVerifyData);
    byte[] clientVerifyData=TlsUtils.calculateVerifyData(state.clientContext,""String_Node_Str"",handshake.getCurrentHash());
    handshake.sendMessage(HandshakeType.finished,clientVerifyData);
    handshake.finish();
    state.clientContext.setResumableSession(state.tlsSession);
    state.client.notifyHandshakeComplete();
    return new DTLSTransport(recordLayer);
  }
  invalidateSession(state);
  if (state.selectedSessionID.length > 0) {
    state.tlsSession=new TlsSessionImpl(state.selectedSessionID,null);
  }
  if (serverMessage.getType() == HandshakeType.supplemental_data) {
    processServerSupplementalData(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
    state.client.processServerSupplementalData(null);
  }
  state.keyExchange=state.client.getKeyExchange();
  state.keyExchange.init(state.clientContext);
  Certificate serverCertificate=null;
  if (serverMessage.getType() == HandshakeType.certificate) {
    serverCertificate=processServerCertificate(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
    state.keyExchange.skipServerCredentials();
  }
  if (serverCertificate == null || serverCertificate.isEmpty()) {
    state.allowCertificateStatus=false;
  }
  if (serverMessage.getType() == HandshakeType.certificate_status) {
    processCertificateStatus(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
  }
  if (serverMessage.getType() == HandshakeType.server_key_exchange) {
    processServerKeyExchange(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
    state.keyExchange.skipServerKeyExchange();
  }
  if (serverMessage.getType() == HandshakeType.certificate_request) {
    processCertificateRequest(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
  }
  if (serverMessage.getType() == HandshakeType.server_hello_done) {
    if (serverMessage.getBody().length != 0) {
      throw new TlsFatalAlert(AlertDescription.decode_error);
    }
  }
 else {
    throw new TlsFatalAlert(AlertDescription.unexpected_message);
  }
  Vector clientSupplementalData=state.client.getClientSupplementalData();
  if (clientSupplementalData != null) {
    byte[] supplementalDataBody=generateSupplementalData(clientSupplementalData);
    handshake.sendMessage(HandshakeType.supplemental_data,supplementalDataBody);
  }
  if (state.certificateRequest != null) {
    state.clientCredentials=state.authentication.getClientCredentials(state.certificateRequest);
    Certificate clientCertificate=null;
    if (state.clientCredentials != null) {
      clientCertificate=state.clientCredentials.getCertificate();
    }
    if (clientCertificate == null) {
      clientCertificate=Certificate.EMPTY_CHAIN;
    }
    byte[] certificateBody=generateCertificate(clientCertificate);
    handshake.sendMessage(HandshakeType.certificate,certificateBody);
  }
  if (state.clientCredentials != null) {
    state.keyExchange.processClientCredentials(state.clientCredentials);
  }
 else {
    state.keyExchange.skipClientCredentials();
  }
  byte[] clientKeyExchangeBody=generateClientKeyExchange(state);
  handshake.sendMessage(HandshakeType.client_key_exchange,clientKeyExchangeBody);
  TlsProtocol.establishMasterSecret(state.clientContext,state.keyExchange);
  recordLayer.initPendingEpoch(state.client.getCipher());
  if (state.clientCredentials != null && state.clientCredentials instanceof TlsSignerCredentials) {
    TlsSignerCredentials signerCredentials=(TlsSignerCredentials)state.clientCredentials;
    byte[] md5andsha1=handshake.getCurrentHash();
    byte[] signature=signerCredentials.generateCertificateSignature(md5andsha1);
    DigitallySigned certificateVerify=new DigitallySigned(null,signature);
    byte[] certificateVerifyBody=generateCertificateVerify(state,certificateVerify);
    handshake.sendMessage(HandshakeType.certificate_verify,certificateVerifyBody);
  }
  byte[] clientVerifyData=TlsUtils.calculateVerifyData(state.clientContext,""String_Node_Str"",handshake.getCurrentHash());
  handshake.sendMessage(HandshakeType.finished,clientVerifyData);
  if (state.expectSessionTicket) {
    serverMessage=handshake.receiveMessage();
    if (serverMessage.getType() == HandshakeType.session_ticket) {
      processNewSessionTicket(state,serverMessage.getBody());
    }
 else {
      throw new TlsFatalAlert(AlertDescription.unexpected_message);
    }
  }
  byte[] expectedServerVerifyData=TlsUtils.calculateVerifyData(state.clientContext,""String_Node_Str"",handshake.getCurrentHash());
  processFinished(handshake.receiveMessageBody(HandshakeType.finished),expectedServerVerifyData);
  handshake.finish();
  if (state.tlsSession != null) {
    state.sessionParameters=new SessionParameters(serverCertificate,securityParameters);
    state.tlsSession=new TlsSessionImpl(state.tlsSession.getSessionID(),state.sessionParameters);
    state.clientContext.setResumableSession(state.tlsSession);
  }
  state.client.notifyHandshakeComplete();
  return new DTLSTransport(recordLayer);
}","protected DTLSTransport clientHandshake(ClientHandshakeState state,DTLSRecordLayer recordLayer) throws IOException {
  SecurityParameters securityParameters=state.clientContext.getSecurityParameters();
  DTLSReliableHandshake handshake=new DTLSReliableHandshake(state.clientContext,recordLayer);
  byte[] clientHelloBody=generateClientHello(state,state.client);
  handshake.sendMessage(HandshakeType.client_hello,clientHelloBody);
  DTLSReliableHandshake.Message serverMessage=handshake.receiveMessage();
{
    ProtocolVersion server_version=recordLayer.getDiscoveredPeerVersion();
    ProtocolVersion client_version=state.clientContext.getClientVersion();
    if (!server_version.isEqualOrEarlierVersionOf(client_version)) {
      throw new TlsFatalAlert(AlertDescription.illegal_parameter);
    }
    state.clientContext.setServerVersion(server_version);
    state.client.notifyServerVersion(server_version);
  }
  while (serverMessage.getType() == HandshakeType.hello_verify_request) {
    byte[] cookie=parseHelloVerifyRequest(state.clientContext,serverMessage.getBody());
    byte[] patched=patchClientHelloWithCookie(clientHelloBody,cookie);
    handshake.resetHandshakeMessagesDigest();
    handshake.sendMessage(HandshakeType.client_hello,patched);
    serverMessage=handshake.receiveMessage();
  }
  if (serverMessage.getType() == HandshakeType.server_hello) {
    processServerHello(state,serverMessage.getBody());
    if (state.maxFragmentLength >= 0) {
      int plainTextLimit=1 << (8 + state.maxFragmentLength);
      recordLayer.setPlaintextLimit(plainTextLimit);
    }
  }
 else {
    throw new TlsFatalAlert(AlertDescription.unexpected_message);
  }
  securityParameters.cipherSuite=state.selectedCipherSuite;
  securityParameters.compressionAlgorithm=state.selectedCompressionMethod;
  securityParameters.prfAlgorithm=TlsProtocol.getPRFAlgorithm(state.clientContext,state.selectedCipherSuite);
  securityParameters.verifyDataLength=12;
  handshake.notifyHelloComplete();
  boolean resumedSession=state.selectedSessionID.length > 0 && state.tlsSession != null && Arrays.areEqual(state.selectedSessionID,state.tlsSession.getSessionID());
  if (resumedSession) {
    if (securityParameters.getCipherSuite() != state.sessionParameters.getCipherSuite() || securityParameters.getCompressionAlgorithm() != state.sessionParameters.getCompressionAlgorithm()) {
      throw new TlsFatalAlert(AlertDescription.illegal_parameter);
    }
    securityParameters.masterSecret=Arrays.clone(state.sessionParameters.getMasterSecret());
    recordLayer.initPendingEpoch(state.client.getCipher());
    byte[] expectedServerVerifyData=TlsUtils.calculateVerifyData(state.clientContext,""String_Node_Str"",handshake.getCurrentHash());
    processFinished(handshake.receiveMessageBody(HandshakeType.finished),expectedServerVerifyData);
    byte[] clientVerifyData=TlsUtils.calculateVerifyData(state.clientContext,""String_Node_Str"",handshake.getCurrentHash());
    handshake.sendMessage(HandshakeType.finished,clientVerifyData);
    handshake.finish();
    state.clientContext.setResumableSession(state.tlsSession);
    state.client.notifyHandshakeComplete();
    return new DTLSTransport(recordLayer);
  }
  invalidateSession(state);
  if (state.selectedSessionID.length > 0) {
    state.tlsSession=new TlsSessionImpl(state.selectedSessionID,null);
  }
  serverMessage=handshake.receiveMessage();
  if (serverMessage.getType() == HandshakeType.supplemental_data) {
    processServerSupplementalData(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
    state.client.processServerSupplementalData(null);
  }
  state.keyExchange=state.client.getKeyExchange();
  state.keyExchange.init(state.clientContext);
  Certificate serverCertificate=null;
  if (serverMessage.getType() == HandshakeType.certificate) {
    serverCertificate=processServerCertificate(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
    state.keyExchange.skipServerCredentials();
  }
  if (serverCertificate == null || serverCertificate.isEmpty()) {
    state.allowCertificateStatus=false;
  }
  if (serverMessage.getType() == HandshakeType.certificate_status) {
    processCertificateStatus(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
  }
  if (serverMessage.getType() == HandshakeType.server_key_exchange) {
    processServerKeyExchange(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
    state.keyExchange.skipServerKeyExchange();
  }
  if (serverMessage.getType() == HandshakeType.certificate_request) {
    processCertificateRequest(state,serverMessage.getBody());
    serverMessage=handshake.receiveMessage();
  }
 else {
  }
  if (serverMessage.getType() == HandshakeType.server_hello_done) {
    if (serverMessage.getBody().length != 0) {
      throw new TlsFatalAlert(AlertDescription.decode_error);
    }
  }
 else {
    throw new TlsFatalAlert(AlertDescription.unexpected_message);
  }
  Vector clientSupplementalData=state.client.getClientSupplementalData();
  if (clientSupplementalData != null) {
    byte[] supplementalDataBody=generateSupplementalData(clientSupplementalData);
    handshake.sendMessage(HandshakeType.supplemental_data,supplementalDataBody);
  }
  if (state.certificateRequest != null) {
    state.clientCredentials=state.authentication.getClientCredentials(state.certificateRequest);
    Certificate clientCertificate=null;
    if (state.clientCredentials != null) {
      clientCertificate=state.clientCredentials.getCertificate();
    }
    if (clientCertificate == null) {
      clientCertificate=Certificate.EMPTY_CHAIN;
    }
    byte[] certificateBody=generateCertificate(clientCertificate);
    handshake.sendMessage(HandshakeType.certificate,certificateBody);
  }
  if (state.clientCredentials != null) {
    state.keyExchange.processClientCredentials(state.clientCredentials);
  }
 else {
    state.keyExchange.skipClientCredentials();
  }
  byte[] clientKeyExchangeBody=generateClientKeyExchange(state);
  handshake.sendMessage(HandshakeType.client_key_exchange,clientKeyExchangeBody);
  TlsProtocol.establishMasterSecret(state.clientContext,state.keyExchange);
  recordLayer.initPendingEpoch(state.client.getCipher());
  if (state.clientCredentials != null && state.clientCredentials instanceof TlsSignerCredentials) {
    TlsSignerCredentials signerCredentials=(TlsSignerCredentials)state.clientCredentials;
    byte[] md5andsha1=handshake.getCurrentHash();
    byte[] signature=signerCredentials.generateCertificateSignature(md5andsha1);
    DigitallySigned certificateVerify=new DigitallySigned(null,signature);
    byte[] certificateVerifyBody=generateCertificateVerify(state,certificateVerify);
    handshake.sendMessage(HandshakeType.certificate_verify,certificateVerifyBody);
  }
  byte[] clientVerifyData=TlsUtils.calculateVerifyData(state.clientContext,""String_Node_Str"",handshake.getCurrentHash());
  handshake.sendMessage(HandshakeType.finished,clientVerifyData);
  if (state.expectSessionTicket) {
    serverMessage=handshake.receiveMessage();
    if (serverMessage.getType() == HandshakeType.session_ticket) {
      processNewSessionTicket(state,serverMessage.getBody());
    }
 else {
      throw new TlsFatalAlert(AlertDescription.unexpected_message);
    }
  }
  byte[] expectedServerVerifyData=TlsUtils.calculateVerifyData(state.clientContext,""String_Node_Str"",handshake.getCurrentHash());
  processFinished(handshake.receiveMessageBody(HandshakeType.finished),expectedServerVerifyData);
  handshake.finish();
  if (state.tlsSession != null) {
    state.sessionParameters=new SessionParameters(serverCertificate,securityParameters);
    state.tlsSession=new TlsSessionImpl(state.tlsSession.getSessionID(),state.sessionParameters);
    state.clientContext.setResumableSession(state.tlsSession);
  }
  state.client.notifyHandshakeComplete();
  return new DTLSTransport(recordLayer);
}"
52586,"public static void main(String[] args) throws Exception {
  InetAddress address=InetAddress.getLocalHost();
  int port=5556;
  TlsSession session=null;
  MockDTLSClient client=new MockDTLSClient(session);
  DTLSTransport dtls=openDTLSConnection(address,port,client);
  System.out.println(""String_Node_Str"" + dtls.getReceiveLimit());
  System.out.println(""String_Node_Str"" + dtls.getSendLimit());
  byte[] request=""String_Node_Str"".getBytes(""String_Node_Str"");
  dtls.send(request,0,request.length);
  byte[] response=new byte[dtls.getReceiveLimit()];
  int received=dtls.receive(response,0,response.length,30000);
  if (received >= 0) {
    System.out.println(new String(response,0,received,""String_Node_Str""));
  }
  dtls.close();
}","public static void main(String[] args) throws Exception {
  InetAddress address=InetAddress.getLocalHost();
  int port=5556;
  TlsSession session=createSession(address,port);
  MockDTLSClient client=new MockDTLSClient(session);
  DTLSTransport dtls=openDTLSConnection(address,port,client);
  System.out.println(""String_Node_Str"" + dtls.getReceiveLimit());
  System.out.println(""String_Node_Str"" + dtls.getSendLimit());
  byte[] request=""String_Node_Str"".getBytes(""String_Node_Str"");
  dtls.send(request,0,request.length);
  byte[] response=new byte[dtls.getReceiveLimit()];
  int received=dtls.receive(response,0,response.length,30000);
  if (received >= 0) {
    System.out.println(new String(response,0,received,""String_Node_Str""));
  }
  dtls.close();
}"
52587,"/** 
 * Add some data to our buffer.
 * @param data   A byte-array to read data from.
 * @param offset How many bytes to skip at the beginning of the array.
 * @param len    How many bytes to read from the array.
 */
public void addData(byte[] data,int offset,int len){
  if ((skipped + available + len) > databuf.length) {
    byte[] tmp=new byte[ByteQueue.nextTwoPow(data.length)];
    System.arraycopy(databuf,skipped,tmp,0,available);
    skipped=0;
    databuf=tmp;
  }
  System.arraycopy(data,offset,databuf,skipped + available,len);
  available+=len;
}","/** 
 * Add some data to our buffer.
 * @param data   A byte-array to read data from.
 * @param offset How many bytes to skip at the beginning of the array.
 * @param len    How many bytes to read from the array.
 */
public void addData(byte[] data,int offset,int len){
  if ((skipped + available + len) > databuf.length) {
    int desiredSize=ByteQueue.nextTwoPow(available + len);
    if (desiredSize > databuf.length) {
      byte[] tmp=new byte[desiredSize];
      System.arraycopy(databuf,skipped,tmp,0,available);
      databuf=tmp;
    }
 else {
      System.arraycopy(databuf,skipped,databuf,0,available);
    }
    skipped=0;
  }
  System.arraycopy(data,offset,databuf,skipped + available,len);
  available+=len;
}"
52588,"/** 
 * Remove some bytes from our data from the beginning.
 * @param i How many bytes to remove.
 */
public void removeData(int i){
  if (i > available) {
    throw new TlsRuntimeException(""String_Node_Str"" + i + ""String_Node_Str""+ available);
  }
  available-=i;
  skipped+=i;
  if (skipped > (databuf.length / 2)) {
    System.arraycopy(databuf,skipped,databuf,0,available);
    skipped=0;
  }
}","/** 
 * Remove some bytes from our data from the beginning.
 * @param i How many bytes to remove.
 */
public void removeData(int i){
  if (i > available) {
    throw new TlsRuntimeException(""String_Node_Str"" + i + ""String_Node_Str""+ available);
  }
  available-=i;
  skipped+=i;
}"
52589,"public void encode(BCPGOutputStream out) throws IOException {
  byte[] oid=this.oid.getEncoded();
  out.write(oid.length);
  out.write(oid);
  MPInteger point=new MPInteger(new BigInteger(1,this.point.getEncoded()));
  out.writeObject(point);
}","public void encode(BCPGOutputStream out) throws IOException {
  byte[] oid=this.oid.getEncoded();
  out.write(oid,1,oid.length - 1);
  MPInteger point=new MPInteger(new BigInteger(1,this.point.getEncoded()));
  out.writeObject(point);
}"
52590,"public void testGetEntry(){
  LocalizedMessage msg;
  msg=new LocalizedMessage(TEST_RESOURCE,localeTestId);
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getDefault()));
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getDefault()));
  Object[] args=new Object[]{""String_Node_Str""};
  msg=new LocalizedMessage(TEST_RESOURCE,argsTestId,args);
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getDefault()));
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getDefault()));
  Date testDate=new Date(1155820320000l);
  args=new Object[]{new TrustedInput(testDate)};
  msg=new LocalizedMessage(TEST_RESOURCE,timeTestId,args);
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getTimeZone(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getTimeZone(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str""));
  args=new Object[]{new TrustedInput(testDate)};
  msg=new LocalizedMessage(TEST_RESOURCE,timeTestId,args);
  msg.setFilter(new HTMLFilter());
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getTimeZone(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getTimeZone(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str""));
  args=new Object[]{new TrustedInput(new Float(0.2))};
  msg=new LocalizedMessage(TEST_RESOURCE,""String_Node_Str"",args);
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getDefault()));
  String untrusted=""String_Node_Str"";
  args=new Object[]{untrusted};
  msg=new LocalizedMessage(TEST_RESOURCE,filterTestId,args);
  msg.setFilter(new HTMLFilter());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getDefault()));
  msg=new LocalizedMessage(TEST_RESOURCE,missingTestId);
  try {
    String text=msg.getEntry(""String_Node_Str"",Locale.UK,TimeZone.getDefault());
    fail();
  }
 catch (  MissingEntryException e) {
    System.out.println(e.getDebugMsg());
  }
  try {
    URLClassLoader cl=URLClassLoader.newInstance(new URL[]{new URL(""String_Node_Str"")});
    msg=new LocalizedMessage(TEST_RESOURCE,missingTestId);
    msg.setClassLoader(cl);
    try {
      String text=msg.getEntry(""String_Node_Str"",Locale.UK,TimeZone.getDefault());
      fail();
    }
 catch (    MissingEntryException e) {
      System.out.println(e.getDebugMsg());
    }
  }
 catch (  MalformedURLException e) {
  }
  try {
    msg=new LocalizedMessage(UTF8_TEST_RESOURCE,utf8TestId,""String_Node_Str"");
    assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getDefault()));
  }
 catch (  UnsupportedEncodingException e) {
  }
}","public void testGetEntry(){
  LocalizedMessage msg;
  msg=new LocalizedMessage(TEST_RESOURCE,localeTestId);
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getDefault()));
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getDefault()));
  Object[] args=new Object[]{""String_Node_Str""};
  msg=new LocalizedMessage(TEST_RESOURCE,argsTestId,args);
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getDefault()));
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getDefault()));
  Date testDate=new Date(1155820320000l);
  args=new Object[]{new TrustedInput(testDate)};
  msg=new LocalizedMessage(TEST_RESOURCE,timeTestId,args);
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getTimeZone(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getTimeZone(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str""));
  args=new Object[]{new TrustedInput(testDate)};
  msg=new LocalizedMessage(TEST_RESOURCE,timeTestId,args);
  msg.setFilter(new HTMLFilter());
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getTimeZone(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getTimeZone(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str""));
  args=new Object[]{new TrustedInput(new Float(0.2))};
  msg=new LocalizedMessage(TEST_RESOURCE,""String_Node_Str"",args);
  assertEquals(""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getDefault()));
  String untrusted=""String_Node_Str"";
  args=new Object[]{untrusted};
  msg=new LocalizedMessage(TEST_RESOURCE,filterTestId,args);
  msg.setFilter(new HTMLFilter());
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",msg.getEntry(""String_Node_Str"",Locale.ENGLISH,TimeZone.getDefault()));
  msg=new LocalizedMessage(TEST_RESOURCE,missingTestId);
  try {
    String text=msg.getEntry(""String_Node_Str"",Locale.UK,TimeZone.getDefault());
    fail();
  }
 catch (  MissingEntryException e) {
  }
  try {
    URLClassLoader cl=URLClassLoader.newInstance(new URL[]{new URL(""String_Node_Str"")});
    msg=new LocalizedMessage(TEST_RESOURCE,missingTestId);
    msg.setClassLoader(cl);
    try {
      String text=msg.getEntry(""String_Node_Str"",Locale.UK,TimeZone.getDefault());
      fail();
    }
 catch (    MissingEntryException e) {
    }
  }
 catch (  MalformedURLException e) {
  }
  try {
    String expectedUtf8=new String(Hex.decode(""String_Node_Str""),""String_Node_Str"");
    msg=new LocalizedMessage(UTF8_TEST_RESOURCE,utf8TestId,""String_Node_Str"");
    assertEquals(expectedUtf8,msg.getEntry(""String_Node_Str"",Locale.GERMAN,TimeZone.getDefault()));
  }
 catch (  UnsupportedEncodingException e) {
  }
}"
52591,"public OAEPEncoding(AsymmetricBlockCipher cipher,Digest hash,Digest mgf1Hash,byte[] encodingParams){
  this.engine=cipher;
  this.hash=hash;
  this.mgf1Hash=mgf1Hash;
  this.defHash=new byte[hash.getDigestSize()];
  if (encodingParams != null) {
    hash.update(encodingParams,0,encodingParams.length);
  }
  hash.doFinal(defHash,0);
}","public OAEPEncoding(AsymmetricBlockCipher cipher,Digest hash,Digest mgf1Hash,byte[] encodingParams){
  this.engine=cipher;
  this.mgf1Hash=mgf1Hash;
  this.defHash=new byte[hash.getDigestSize()];
  hash.reset();
  if (encodingParams != null) {
    hash.update(encodingParams,0,encodingParams.length);
  }
  hash.doFinal(defHash,0);
}"
52592,"/** 
 * mask generator function, as described in PKCS1v2.
 */
private byte[] maskGeneratorFunction1(byte[] Z,int zOff,int zLen,int length){
  byte[] mask=new byte[length];
  byte[] hashBuf=new byte[mgf1Hash.getDigestSize()];
  byte[] C=new byte[4];
  int counter=0;
  hash.reset();
  do {
    ItoOSP(counter,C);
    mgf1Hash.update(Z,zOff,zLen);
    mgf1Hash.update(C,0,C.length);
    mgf1Hash.doFinal(hashBuf,0);
    System.arraycopy(hashBuf,0,mask,counter * hashBuf.length,hashBuf.length);
  }
 while (++counter < (length / hashBuf.length));
  if ((counter * hashBuf.length) < length) {
    ItoOSP(counter,C);
    mgf1Hash.update(Z,zOff,zLen);
    mgf1Hash.update(C,0,C.length);
    mgf1Hash.doFinal(hashBuf,0);
    System.arraycopy(hashBuf,0,mask,counter * hashBuf.length,mask.length - (counter * hashBuf.length));
  }
  return mask;
}","/** 
 * mask generator function, as described in PKCS1v2.
 */
private byte[] maskGeneratorFunction1(byte[] Z,int zOff,int zLen,int length){
  byte[] mask=new byte[length];
  byte[] hashBuf=new byte[mgf1Hash.getDigestSize()];
  byte[] C=new byte[4];
  int counter=0;
  mgf1Hash.reset();
  while (counter < (length / hashBuf.length)) {
    ItoOSP(counter,C);
    mgf1Hash.update(Z,zOff,zLen);
    mgf1Hash.update(C,0,C.length);
    mgf1Hash.doFinal(hashBuf,0);
    System.arraycopy(hashBuf,0,mask,counter * hashBuf.length,hashBuf.length);
    counter++;
  }
  if ((counter * hashBuf.length) < length) {
    ItoOSP(counter,C);
    mgf1Hash.update(Z,zOff,zLen);
    mgf1Hash.update(C,0,C.length);
    mgf1Hash.doFinal(hashBuf,0);
    System.arraycopy(hashBuf,0,mask,counter * hashBuf.length,mask.length - (counter * hashBuf.length));
  }
  return mask;
}"
52593,"public void performTest() throws Exception {
  baseOaepTest(1,pubKeyEnc1,privKeyEnc1,output1);
  baseOaepTest(2,pubKeyEnc2,privKeyEnc2,output2);
  baseOaepTest(3,pubKeyEnc3,privKeyEnc3,output3);
  RSAKeyParameters pubParam=new RSAKeyParameters(false,new BigInteger(1,modulus_1024),new BigInteger(1,pubExp_1024));
  RSAKeyParameters privParam=new RSAPrivateCrtKeyParameters(pubParam.getModulus(),pubParam.getExponent(),new BigInteger(1,privExp_1024),new BigInteger(1,prime1_1024),new BigInteger(1,prime2_1024),new BigInteger(1,primeExp1_1024),new BigInteger(1,primeExp2_1024),new BigInteger(1,crtCoef_1024));
  oaepVecTest(1024,1,pubParam,privParam,seed_1024_1,input_1024_1,output_1024_1);
  oaepVecTest(1024,2,pubParam,privParam,seed_1024_2,input_1024_2,output_1024_2);
  oaepVecTest(1024,3,pubParam,privParam,seed_1024_3,input_1024_3,output_1024_3);
  oaepVecTest(1024,4,pubParam,privParam,seed_1024_4,input_1024_4,output_1024_4);
  oaepVecTest(1024,5,pubParam,privParam,seed_1024_5,input_1024_5,output_1024_5);
  oaepVecTest(1024,6,pubParam,privParam,seed_1024_6,input_1024_6,output_1024_6);
  pubParam=new RSAKeyParameters(false,new BigInteger(1,modulus_1027),new BigInteger(1,pubExp_1027));
  privParam=new RSAPrivateCrtKeyParameters(pubParam.getModulus(),pubParam.getExponent(),new BigInteger(1,privExp_1027),new BigInteger(1,prime1_1027),new BigInteger(1,prime2_1027),new BigInteger(1,primeExp1_1027),new BigInteger(1,primeExp2_1027),new BigInteger(1,crtCoef_1027));
  oaepVecTest(1027,1,pubParam,privParam,seed_1027_1,input_1027_1,output_1027_1);
  oaepVecTest(1027,2,pubParam,privParam,seed_1027_2,input_1027_2,output_1027_2);
  oaepVecTest(1027,3,pubParam,privParam,seed_1027_3,input_1027_3,output_1027_3);
  oaepVecTest(1027,4,pubParam,privParam,seed_1027_4,input_1027_4,output_1027_4);
  oaepVecTest(1027,5,pubParam,privParam,seed_1027_5,input_1027_5,output_1027_5);
  oaepVecTest(1027,6,pubParam,privParam,seed_1027_6,input_1027_6,output_1027_6);
}","public void performTest() throws Exception {
  baseOaepTest(1,pubKeyEnc1,privKeyEnc1,output1);
  baseOaepTest(2,pubKeyEnc2,privKeyEnc2,output2);
  baseOaepTest(3,pubKeyEnc3,privKeyEnc3,output3);
  RSAKeyParameters pubParam=new RSAKeyParameters(false,new BigInteger(1,modulus_1024),new BigInteger(1,pubExp_1024));
  RSAKeyParameters privParam=new RSAPrivateCrtKeyParameters(pubParam.getModulus(),pubParam.getExponent(),new BigInteger(1,privExp_1024),new BigInteger(1,prime1_1024),new BigInteger(1,prime2_1024),new BigInteger(1,primeExp1_1024),new BigInteger(1,primeExp2_1024),new BigInteger(1,crtCoef_1024));
  oaepVecTest(1024,1,pubParam,privParam,seed_1024_1,input_1024_1,output_1024_1);
  oaepVecTest(1024,2,pubParam,privParam,seed_1024_2,input_1024_2,output_1024_2);
  oaepVecTest(1024,3,pubParam,privParam,seed_1024_3,input_1024_3,output_1024_3);
  oaepVecTest(1024,4,pubParam,privParam,seed_1024_4,input_1024_4,output_1024_4);
  oaepVecTest(1024,5,pubParam,privParam,seed_1024_5,input_1024_5,output_1024_5);
  oaepVecTest(1024,6,pubParam,privParam,seed_1024_6,input_1024_6,output_1024_6);
  pubParam=new RSAKeyParameters(false,new BigInteger(1,modulus_1027),new BigInteger(1,pubExp_1027));
  privParam=new RSAPrivateCrtKeyParameters(pubParam.getModulus(),pubParam.getExponent(),new BigInteger(1,privExp_1027),new BigInteger(1,prime1_1027),new BigInteger(1,prime2_1027),new BigInteger(1,primeExp1_1027),new BigInteger(1,primeExp2_1027),new BigInteger(1,crtCoef_1027));
  oaepVecTest(1027,1,pubParam,privParam,seed_1027_1,input_1027_1,output_1027_1);
  oaepVecTest(1027,2,pubParam,privParam,seed_1027_2,input_1027_2,output_1027_2);
  oaepVecTest(1027,3,pubParam,privParam,seed_1027_3,input_1027_3,output_1027_3);
  oaepVecTest(1027,4,pubParam,privParam,seed_1027_4,input_1027_4,output_1027_4);
  oaepVecTest(1027,5,pubParam,privParam,seed_1027_5,input_1027_5,output_1027_5);
  oaepVecTest(1027,6,pubParam,privParam,seed_1027_6,input_1027_6,output_1027_6);
  AsymmetricBlockCipher cipher=new OAEPEncoding(new RSAEngine(),new SHA256Digest(),new SHA1Digest(),new byte[10]);
  cipher.init(true,new ParametersWithRandom(pubParam,new SecureRandom()));
  byte[] input=new byte[10];
  byte[] out=cipher.processBlock(input,0,input.length);
  cipher.init(false,privParam);
  out=cipher.processBlock(out,0,out.length);
  for (int i=0; i != input.length; i++) {
    if (out[i] != input[i]) {
      fail(""String_Node_Str"");
    }
  }
  cipher=new OAEPEncoding(new RSAEngine(),new SHA1Digest(),new SHA256Digest(),new byte[10]);
  cipher.init(true,new ParametersWithRandom(pubParam,new SecureRandom()));
  out=cipher.processBlock(input,0,input.length);
  cipher.init(false,privParam);
  out=cipher.processBlock(out,0,out.length);
  for (int i=0; i != input.length; i++) {
    if (out[i] != input[i]) {
      fail(""String_Node_Str"");
    }
  }
}"
52594,"public int generate(byte[] output,byte[] additionalInput,boolean predictionResistant){
  int numberOfBits=output.length * 8;
  if (predictionResistant) {
    reseed(additionalInput);
  }
  if (additionalInput != null) {
    hmac_DRBG_Update(additionalInput);
  }
  byte[] rv=new byte[output.length];
  int m=output.length / _V.length;
  _hMac.init(new KeyParameter(_K));
  for (int i=0; i < m; i++) {
    _hMac.update(_V,0,_V.length);
    _hMac.doFinal(_V,0);
    System.arraycopy(_V,0,rv,i * _V.length,_V.length);
  }
  if (m * _V.length < rv.length) {
    _hMac.update(_V,0,_V.length);
    _hMac.doFinal(_V,0);
    System.arraycopy(_V,0,rv,m * _V.length,rv.length - (m * _V.length));
  }
  hmac_DRBG_Update(additionalInput);
  _reseedCounter++;
  System.arraycopy(rv,0,output,0,output.length);
  return numberOfBits;
}","public int generate(byte[] output,byte[] additionalInput,boolean predictionResistant){
  int numberOfBits=output.length * 8;
  if (predictionResistant) {
    reseed(additionalInput);
    additionalInput=null;
  }
  if (additionalInput != null) {
    hmac_DRBG_Update(additionalInput);
  }
  byte[] rv=new byte[output.length];
  int m=output.length / _V.length;
  _hMac.init(new KeyParameter(_K));
  for (int i=0; i < m; i++) {
    _hMac.update(_V,0,_V.length);
    _hMac.doFinal(_V,0);
    System.arraycopy(_V,0,rv,i * _V.length,_V.length);
  }
  if (m * _V.length < rv.length) {
    _hMac.update(_V,0,_V.length);
    _hMac.doFinal(_V,0);
    System.arraycopy(_V,0,rv,m * _V.length,rv.length - (m * _V.length));
  }
  hmac_DRBG_Update(additionalInput);
  _reseedCounter++;
  System.arraycopy(rv,0,output,0,output.length);
  return numberOfBits;
}"
52595,"private DRBGTestVector[] createTestVectorData(){
  return new DRBGTestVector[]{new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalisationString(""String_Node_Str""),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalisationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA384Digest(),new SHA384EntropyProvider().get(192),false,""String_Node_Str"",192,new String[]{""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""}),new DRBGTestVector(new SHA384Digest(),new SHA384EntropyProvider().get(192),true,""String_Node_Str"",192,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""}),new DRBGTestVector(new SHA512Digest(),new SHA512EntropyProvider().get(256),false,""String_Node_Str"",256,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""}),new DRBGTestVector(new SHA512Digest(),new SHA512EntropyProvider().get(256),true,""String_Node_Str"",256,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""}).setPersonalisationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA512Digest(),new SHA512EntropyProvider().get(256),true,""String_Node_Str"",256,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""})};
}","private DRBGTestVector[] createTestVectorData(){
  return new DRBGTestVector[]{new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),false,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}),new DRBGTestVector(new SHA256Digest(),new SHA256EntropyProvider().get(128),true,""String_Node_Str"",128,new String[]{""String_Node_Str"",""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA384Digest(),new SHA384EntropyProvider().get(192),false,""String_Node_Str"",192,new String[]{""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""}),new DRBGTestVector(new SHA384Digest(),new SHA384EntropyProvider().get(192),false,""String_Node_Str"",192,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""}).setPersonalizationString(""String_Node_Str""),new DRBGTestVector(new SHA384Digest(),new SHA384EntropyProvider().get(192),false,""String_Node_Str"",192,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA384Digest(),new SHA384EntropyProvider().get(192),true,""String_Node_Str"",192,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""}).addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA384Digest(),new SHA384EntropyProvider().get(192),true,""String_Node_Str"",192,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""}),new DRBGTestVector(new SHA512Digest(),new SHA512EntropyProvider().get(256),false,""String_Node_Str"",256,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""}),new DRBGTestVector(new SHA512Digest(),new SHA512EntropyProvider().get(256),true,""String_Node_Str"",256,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""}).setPersonalizationString(""String_Node_Str"").addAdditionalInput(""String_Node_Str"").addAdditionalInput(""String_Node_Str""),new DRBGTestVector(new SHA512Digest(),new SHA512EntropyProvider().get(256),true,""String_Node_Str"",256,new String[]{""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""})};
}"
52596,"public void performTest() throws Exception {
  DRBGTestVector[] tests=createTestVectorData();
  for (int i=0; i != tests.length; i++) {
    DRBGTestVector tv=tests[i];
    byte[] nonce=Hex.decode(tv.nonce());
    byte[] personalisationString=Hex.decode(tv.personalizationString());
    SP80090DRBG d=new DualECSP800DRBG(tv.getDigest(),tv.entropySource(),nonce,personalisationString,tv.securityStrength());
    byte[] output=new byte[tv.expectedValue(0).length];
    d.generate(output,tv.additionalInput(0),tv.predictionResistance());
    byte[] expected=tv.expectedValue(0);
    if (!areEqual(expected,output)) {
      fail(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ new String(Hex.encode(tv.expectedValue(0)))+ ""String_Node_Str""+ new String(Hex.encode(output)));
    }
    output=new byte[tv.expectedValue(1).length];
    d.generate(output,tv.additionalInput(1),tv.predictionResistance());
    expected=tv.expectedValue(1);
    if (!areEqual(expected,output)) {
      fail(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ new String(Hex.encode(tv.expectedValue(1)))+ ""String_Node_Str""+ new String(Hex.encode(output)));
    }
  }
}","public void performTest() throws Exception {
  DRBGTestVector[] tests=createTestVectorData();
  for (int i=0; i != tests.length; i++) {
    DRBGTestVector tv=tests[i];
    byte[] nonce=tv.nonce();
    byte[] personalisationString=tv.personalizationString();
    SP80090DRBG d=new DualECSP800DRBG(tv.getDigest(),tv.entropySource(),nonce,personalisationString,tv.securityStrength());
    byte[] output=new byte[tv.expectedValue(0).length];
    d.generate(output,tv.additionalInput(0),tv.predictionResistance());
    byte[] expected=tv.expectedValue(0);
    if (!areEqual(expected,output)) {
      fail(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ new String(Hex.encode(tv.expectedValue(0)))+ ""String_Node_Str""+ new String(Hex.encode(output)));
    }
    output=new byte[tv.expectedValue(1).length];
    d.generate(output,tv.additionalInput(1),tv.predictionResistance());
    expected=tv.expectedValue(1);
    if (!areEqual(expected,output)) {
      fail(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ new String(Hex.encode(tv.expectedValue(1)))+ ""String_Node_Str""+ new String(Hex.encode(output)));
    }
  }
}"
52597,"public void performTest() throws Exception {
  DRBGTestVector[] tests=createTestVectorData();
  for (int i=0; i != tests.length; i++) {
    DRBGTestVector tv=tests[i];
    byte[] nonce=Hex.decode(tv.nonce());
    byte[] personalisationString=Hex.decode(tv.personalizationString());
    SP80090DRBG d=new HMacSP800DRBG(new HMac(tv.getDigest()),tv.entropySource(),nonce,personalisationString,tv.securityStrength());
    byte[] output=new byte[tv.expectedValue(0).length];
    d.generate(output,tv.additionalInput(0),tv.predictionResistance());
    byte[] expected=tv.expectedValue(0);
    if (!areEqual(expected,output)) {
      fail(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ new String(Hex.encode(tv.expectedValue(0)))+ ""String_Node_Str""+ new String(Hex.encode(output)));
    }
    output=new byte[tv.expectedValue(0).length];
    d.generate(output,tv.additionalInput(1),tv.predictionResistance());
    expected=tv.expectedValue(1);
    if (!areEqual(expected,output)) {
      fail(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ new String(Hex.encode(tv.expectedValue(1)))+ ""String_Node_Str""+ new String(Hex.encode(output)));
    }
  }
}","public void performTest() throws Exception {
  DRBGTestVector[] tests=createTestVectorData();
  for (int i=0; i != tests.length; i++) {
    DRBGTestVector tv=tests[i];
    byte[] nonce=tv.nonce();
    byte[] personalisationString=tv.personalizationString();
    SP80090DRBG d=new HMacSP800DRBG(new HMac(tv.getDigest()),tv.entropySource(),nonce,personalisationString,tv.securityStrength());
    byte[] output=new byte[tv.expectedValue(0).length];
    d.generate(output,tv.additionalInput(0),tv.predictionResistance());
    byte[] expected=tv.expectedValue(0);
    if (!areEqual(expected,output)) {
      fail(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ new String(Hex.encode(tv.expectedValue(0)))+ ""String_Node_Str""+ new String(Hex.encode(output)));
    }
    output=new byte[tv.expectedValue(0).length];
    d.generate(output,tv.additionalInput(1),tv.predictionResistance());
    expected=tv.expectedValue(1);
    if (!areEqual(expected,output)) {
      fail(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ new String(Hex.encode(tv.expectedValue(1)))+ ""String_Node_Str""+ new String(Hex.encode(output)));
    }
  }
}"
52598,"/** 
 * initialize the distributed leaf calculation reset i,j and compute OTSseed with seed0
 * @param seed0 the starting seed
 */
public void initLeafCalc(byte[] seed0){
  this.i=0;
  this.j=0;
  byte[] dummy=new byte[mdsize];
  System.arraycopy(seed0,0,dummy,0,seed.length);
  this.seed=gmssRandom.nextSeed(dummy);
}","/** 
 * initialize the distributed leaf calculation reset i,j and compute OTSseed with seed0
 * @param seed0 the starting seed
 */
void initLeafCalc(byte[] seed0){
  this.i=0;
  this.j=0;
  byte[] dummy=new byte[mdsize];
  System.arraycopy(seed0,0,dummy,0,seed.length);
  this.seed=gmssRandom.nextSeed(dummy);
}"
52599,"/** 
 * Processes <code>steps</code> steps of distributed leaf calculation
 * @return true if leaf is completed, else false
 */
public boolean updateLeafCalc(){
  for (int s=0; s < steps; s++) {
    if (i == keysize && j == two_power_w - 1) {
      messDigestOTS.update(concHashs,0,concHashs.length);
      leaf=new byte[messDigestOTS.getDigestSize()];
      messDigestOTS.doFinal(leaf,0);
      return true;
    }
 else     if (i == 0 || j == two_power_w - 1) {
      i++;
      j=0;
      this.privateKeyOTS=gmssRandom.nextSeed(seed);
    }
 else {
      messDigestOTS.update(privateKeyOTS,0,privateKeyOTS.length);
      privateKeyOTS=new byte[messDigestOTS.getDigestSize()];
      messDigestOTS.doFinal(privateKeyOTS,0);
      j++;
      if (j == two_power_w - 1) {
        System.arraycopy(privateKeyOTS,0,concHashs,mdsize * (i - 1),mdsize);
      }
    }
  }
  return false;
}","/** 
 * Processes <code>steps</code> steps of distributed leaf calculation
 * @return true if leaf is completed, else false
 */
private void updateLeafCalc(){
  byte[] buf=new byte[messDigestOTS.getDigestSize()];
  for (int s=0; s < steps + 10000; s++) {
    if (i == keysize && j == two_power_w - 1) {
      messDigestOTS.update(concHashs,0,concHashs.length);
      leaf=new byte[messDigestOTS.getDigestSize()];
      messDigestOTS.doFinal(leaf,0);
      return;
    }
 else     if (i == 0 || j == two_power_w - 1) {
      i++;
      j=0;
      this.privateKeyOTS=gmssRandom.nextSeed(seed);
    }
 else {
      messDigestOTS.update(privateKeyOTS,0,privateKeyOTS.length);
      privateKeyOTS=buf;
      messDigestOTS.doFinal(privateKeyOTS,0);
      j++;
      if (j == two_power_w - 1) {
        System.arraycopy(privateKeyOTS,0,concHashs,mdsize * (i - 1),mdsize);
      }
    }
  }
  throw new IllegalStateException(""String_Node_Str"" + steps + ""String_Node_Str""+ i+ ""String_Node_Str""+ j);
}"
52600,"/** 
 * The constructor precomputes some needed variables for distributed leaf calculation
 * @param digest     an array of strings, containing the digest of the used hashfunction and PRNG and the digest of the corresponding provider
 * @param w        the winterniz parameter of that tree the leaf is computedfor
 * @param numLeafs the number of leafs of the tree from where the distributedcomputation is called
 */
public GMSSLeaf(Digest digest,int w,int numLeafs){
  this.w=w;
  messDigestOTS=digest;
  gmssRandom=new GMSSRandom(messDigestOTS);
  mdsize=messDigestOTS.getDigestSize();
  int mdsizeBit=mdsize << 3;
  int messagesize=(int)Math.ceil((double)(mdsizeBit) / (double)w);
  int checksumsize=getLog((messagesize << w) + 1);
  this.keysize=messagesize + (int)Math.ceil((double)checksumsize / (double)w);
  this.two_power_w=1 << w;
  this.steps=(int)Math.ceil((double)(((1 << w) - 1) * keysize + 1 + keysize) / (double)(numLeafs));
  this.seed=new byte[mdsize];
  this.leaf=new byte[mdsize];
  this.privateKeyOTS=new byte[mdsize];
  this.concHashs=new byte[mdsize * keysize];
}","private GMSSLeaf(GMSSLeaf original){
  this.messDigestOTS=original.messDigestOTS;
  this.mdsize=original.mdsize;
  this.keysize=original.keysize;
  this.gmssRandom=original.gmssRandom;
  this.leaf=Arrays.clone(original.leaf);
  this.concHashs=Arrays.clone(original.concHashs);
  this.i=original.i;
  this.j=original.j;
  this.two_power_w=original.two_power_w;
  this.w=original.w;
  this.steps=original.steps;
  this.seed=Arrays.clone(original.seed);
  this.privateKeyOTS=Arrays.clone(original.privateKeyOTS);
}"
52601,"int generate(byte[] output,byte[] additionalInput,int inOff,int inLen);","int generate(byte[] output,byte[] additionalInput,boolean predictionResistant);"
52602,"private byte[] hashDFProcess(Digest digest,int bitLength,byte[] inputString){
  byte[] temp=new byte[bitLength / 8];
  int len=temp.length / digest.getDigestSize();
  int counter=1;
  byte[] dig=new byte[digest.getDigestSize()];
  for (int i=0; i <= len; i++) {
    digest.update((byte)(counter >> 24));
    digest.update((byte)(counter >> 16));
    digest.update((byte)(counter >> 8));
    digest.update((byte)counter);
    digest.update((byte)(bitLength >> 24));
    digest.update((byte)(bitLength >> 16));
    digest.update((byte)(bitLength >> 8));
    digest.update((byte)bitLength);
    digest.update(inputString,0,inputString.length);
    digest.doFinal(dig,0);
    int bytesToCopy=((temp.length - i * dig.length) > dig.length) ? dig.length : (temp.length - i * dig.length);
    System.arraycopy(dig,0,temp,i * dig.length,bytesToCopy);
    counter++;
  }
  return temp;
}","private byte[] hashDFProcess(Digest digest,int bitLength,byte[] inputString){
  byte[] temp=new byte[bitLength / 8];
  int len=temp.length / digest.getDigestSize();
  int counter=1;
  byte[] dig=new byte[digest.getDigestSize()];
  for (int i=0; i <= len; i++) {
    digest.update((byte)counter);
    digest.update((byte)(bitLength >> 24));
    digest.update((byte)(bitLength >> 16));
    digest.update((byte)(bitLength >> 8));
    digest.update((byte)bitLength);
    digest.update(inputString,0,inputString.length);
    digest.doFinal(dig,0);
    int bytesToCopy=((temp.length - i * dig.length) > dig.length) ? dig.length : (temp.length - i * dig.length);
    System.arraycopy(dig,0,temp,i * dig.length,bytesToCopy);
    counter++;
  }
  return temp;
}"
52603,"public SP800DRBG(DRBGDerivationFunction function,EntropySource entropySource,byte[] nonce,byte[] personalisationString,int securityStrength){
  if (securityStrength > function.getSecurityStrength()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  _function=function;
  int entropyLengthInBytes=securityStrength;
  byte[] entropy=entropySource.getEntropy(entropyLengthInBytes);
  byte[] seedMaterial=new byte[entropy.length + nonce.length + personalisationString.length];
  System.arraycopy(entropy,0,seedMaterial,0,entropy.length);
  System.arraycopy(nonce,0,seedMaterial,entropy.length,nonce.length);
  System.arraycopy(personalisationString,0,seedMaterial,entropy.length + nonce.length,personalisationString.length);
  byte[] seed=function.getDFBytes(seedMaterial,function.getSeedlength());
  _V=seed;
  byte[] subV=new byte[_V.length + 1];
  System.arraycopy(_V,0,subV,1,_V.length);
  _C=function.getDFBytes(subV,function.getSeedlength());
  _reseedCounter=1;
}","public SP800DRBG(DRBGDerivationFunction function,EntropySource entropySource,byte[] nonce,byte[] personalisationString,int securityStrength){
  if (securityStrength > function.getSecurityStrength()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  _function=function;
  _entropySource=entropySource;
  _securityStrength=securityStrength;
  int entropyLengthInBytes=securityStrength;
  byte[] entropy=entropySource.getEntropy(entropyLengthInBytes / 8);
  System.out.println(""String_Node_Str"" + new String(Hex.encode(entropy)));
  byte[] seedMaterial=new byte[entropy.length + nonce.length + personalisationString.length];
  System.arraycopy(entropy,0,seedMaterial,0,entropy.length);
  System.arraycopy(nonce,0,seedMaterial,entropy.length,nonce.length);
  System.arraycopy(personalisationString,0,seedMaterial,entropy.length + nonce.length,personalisationString.length);
  System.out.println(""String_Node_Str"" + new String(Hex.encode(seedMaterial)));
  byte[] seed=function.getDFBytes(seedMaterial,function.getSeedlength());
  System.out.println(""String_Node_Str"" + new String(Hex.encode(seed)));
  _V=seed;
  byte[] subV=new byte[_V.length + 1];
  System.arraycopy(_V,0,subV,1,_V.length);
  _C=function.getDFBytes(subV,function.getSeedlength());
  _reseedCounter=1;
  System.out.println(""String_Node_Str"" + new String(Hex.encode(_C)));
}"
52604,"public void reseed(byte[] additionalInput){
}","public void reseed(byte[] additionalInput){
  if (additionalInput == null) {
    additionalInput=new byte[0];
  }
  int entropyLengthInBytes=_securityStrength;
  byte[] entropy=_entropySource.getEntropy(entropyLengthInBytes / 8);
  System.out.println(""String_Node_Str"" + new String(Hex.encode(entropy)));
  byte[] seedMaterial=new byte[1 + _V.length + entropy.length+ additionalInput.length];
  seedMaterial[0]=0x01;
  System.arraycopy(_V,0,seedMaterial,1,_V.length);
  System.arraycopy(entropy,0,seedMaterial,1 + _V.length,entropy.length);
  System.arraycopy(additionalInput,0,seedMaterial,1 + _V.length + entropy.length,additionalInput.length);
  System.out.println(""String_Node_Str"" + new String(Hex.encode(seedMaterial)));
  byte[] seed=_function.getDFBytes(seedMaterial,_function.getSeedlength());
  System.out.println(""String_Node_Str"" + new String(Hex.encode(seed)));
  _V=seed;
  byte[] subV=new byte[_V.length + 1];
  subV[0]=0x00;
  System.arraycopy(_V,0,subV,1,_V.length);
  _C=_function.getDFBytes(subV,_function.getSeedlength());
  _reseedCounter=1;
  System.out.println(""String_Node_Str"" + new String(Hex.encode(_C)));
}"
52605,"public int generate(byte[] output,byte[] additionalInput,int inOff,int inLen){
  int numberOfBits=output.length * 8;
  if (_reseedCounter > 10) {
    return 0;
  }
  if (additionalInput != null) {
    byte[] newInput=new byte[1 + _V.length + additionalInput.length];
    newInput[0]=0x02;
    System.arraycopy(_V,0,newInput,1,_V.length);
    System.arraycopy(additionalInput,0,newInput,1 + _V.length,additionalInput.length);
    byte[] w=_function.getBytes(newInput);
    addTo(_V,w);
  }
  byte[] rv=_function.getByteGen(_V,numberOfBits);
  byte[] subH=new byte[_V.length + 1];
  System.arraycopy(_V,0,subH,1,_V.length);
  subH[0]=0x03;
  byte[] H=_function.getBytes(subH);
  addTo(_V,H);
  addTo(_V,_C);
  byte[] c=new byte[4];
  c[0]=(byte)(_reseedCounter >> 24);
  c[1]=(byte)(_reseedCounter >> 16);
  c[2]=(byte)(_reseedCounter >> 8);
  c[3]=(byte)_reseedCounter;
  addTo(_V,c);
  _reseedCounter++;
  System.arraycopy(rv,0,output,0,output.length);
  return numberOfBits;
}","public int generate(byte[] output,byte[] additionalInput,boolean predictionResistant){
  int numberOfBits=output.length * 8;
  if (predictionResistant) {
    reseed(additionalInput);
  }
  if (additionalInput != null) {
    byte[] newInput=new byte[1 + _V.length + additionalInput.length];
    newInput[0]=0x02;
    System.arraycopy(_V,0,newInput,1,_V.length);
    System.arraycopy(additionalInput,0,newInput,1 + _V.length,additionalInput.length);
    byte[] w=_function.getBytes(newInput);
    addTo(_V,w);
  }
  byte[] rv=_function.getByteGen(_V,numberOfBits);
  byte[] subH=new byte[_V.length + 1];
  System.arraycopy(_V,0,subH,1,_V.length);
  subH[0]=0x03;
  byte[] H=_function.getBytes(subH);
  addTo(_V,H);
  addTo(_V,_C);
  byte[] c=new byte[4];
  c[0]=(byte)(_reseedCounter >> 24);
  c[1]=(byte)(_reseedCounter >> 16);
  c[2]=(byte)(_reseedCounter >> 8);
  c[3]=(byte)_reseedCounter;
  addTo(_V,c);
  _reseedCounter++;
  System.arraycopy(rv,0,output,0,output.length);
  System.out.println(""String_Node_Str"" + new String(Hex.encode(_V)));
  return numberOfBits;
}"
52606,"public void performTest() throws Exception {
  Digest digest=new SHA512Digest();
  HashDerivationFunction hf=new HashDerivationFunction(digest,888);
  EntropySource entropySource=new BasicEntropySource(new SecureRandom(),false);
  byte[] nonce=new byte[0];
  byte[] personalisationString=new byte[0];
  int securityStrength=128;
  DRBG d=new SP800DRBG(hf,entropySource,nonce,personalisationString,securityStrength);
  byte[] output=new byte[10];
  int rv=d.generate(output,null,0,0);
  String out=new String(Hex.encode(output));
  System.out.println(out);
  for (int i=out.length() - 1; i >= 0; i--) {
    if (out.charAt(i) != '0') {
      System.out.println(i);
      return;
    }
  }
}","public void performTest() throws Exception {
  Digest digest=new SHA1Digest();
  HashDerivationFunction hf=new HashDerivationFunction(digest,440);
  EntropySource tes=new TestEntropySource(Hex.decode(""String_Node_Str""),true);
  byte[] nonce=Hex.decode(""String_Node_Str"");
  byte[] personalisationString=new byte[0];
  int securityStrength=128;
  DRBG d=new SP800DRBG(hf,tes,nonce,personalisationString,securityStrength);
  byte[] output=new byte[20];
  int rv=d.generate(output,null,true);
  String out=new String(Hex.encode(output));
  System.out.println(out);
  rv=d.generate(output,null,true);
  out=new String(Hex.encode(output));
  System.out.println(out);
}"
52607,"public WebScrollPane(final Component view,final boolean drawBorder,final boolean drawInnerBorder){
  super(view);
  setDrawBorder(drawBorder);
  getWebHorizontalScrollBar().setPaintTrack(drawInnerBorder);
  getWebVerticalScrollBar().setPaintTrack(drawInnerBorder);
  if (!drawInnerBorder) {
    setCorner(JScrollPane.LOWER_RIGHT_CORNER,null);
  }
}","public WebScrollPane(final Component view,final boolean drawBorder,final boolean drawInnerBorder){
  super(view);
  setDrawBorder(drawBorder);
  getWebHorizontalScrollBar().setPaintTrack(drawInnerBorder);
  getWebHorizontalScrollBar().setUnitIncrement(16);
  getWebVerticalScrollBar().setPaintTrack(drawInnerBorder);
  getWebVerticalScrollBar().setUnitIncrement(16);
  if (!drawInnerBorder) {
    setCorner(JScrollPane.LOWER_RIGHT_CORNER,null);
  }
}"
52608,"@Override protected void paintTabBackground(final Graphics g,final int tabPlacement,final int tabIndex,final int x,final int y,final int w,final int h,final boolean isSelected){
  final Graphics2D g2d=(Graphics2D)g;
  final Object aa=GraphicsUtils.setupAntialias(g2d);
  final GeneralPath borderShape=createTabShape(TabShapeType.border,tabPlacement,x,y,w,h,isSelected);
  if (tabbedPaneStyle.equals(TabbedPaneStyle.standalone)) {
    final GeneralPath shadeShape=createTabShape(TabShapeType.shade,tabPlacement,x,y,w,h,isSelected);
    GraphicsUtils.drawShade(g2d,shadeShape,StyleConstants.shadeColor,shadeWidth,new Rectangle2D.Double(0,0,tabPane.getWidth(),y + h),round > 0);
  }
  final GeneralPath bgShape=createTabShape(TabShapeType.background,tabPlacement,x,y,w,h,isSelected);
  if (backgroundPainterAt.containsKey(tabIndex) && isSelected) {
    final Shape old=GraphicsUtils.intersectClip(g2d,bgShape);
    final Painter bp=backgroundPainterAt.get(tabIndex);
    bp.paint(g2d,new Rectangle(x,y,w,h),tabPane);
    GraphicsUtils.restoreClip(g2d,old);
  }
 else {
    final Point topPoint=getTopTabBgPoint(tabPlacement,x,y,w,h);
    final Point bottomPoint=getBottomTabBgPoint(tabPlacement,x,y,w,h);
    if (isSelected) {
      if (forceUseSelectedTabBgColors) {
        g2d.setPaint(new GradientPaint(topPoint.x,topPoint.y,selectedTopBg,bottomPoint.x,bottomPoint.y,selectedTopBg));
      }
 else {
        Color bg=tabPane.getBackgroundAt(tabIndex);
        bg=bg != null ? bg : tabPane.getBackground();
        g2d.setPaint(new GradientPaint(topPoint.x,topPoint.y,selectedTopBg,bottomPoint.x,bottomPoint.y,bg));
      }
    }
 else {
      g2d.setPaint(new GradientPaint(topPoint.x,topPoint.y,topBg,bottomPoint.x,bottomPoint.y,bottomBg));
    }
    g2d.fill(isSelected ? borderShape : bgShape);
  }
  g2d.setPaint(tabBorderColor);
  g2d.draw(borderShape);
  final boolean drawFocus=isSelected && tabPane.isFocusOwner();
  if (tabbedPaneStyle.equals(TabbedPaneStyle.standalone)) {
    LafUtils.drawCustomWebFocus(g2d,null,StyleConstants.focusType,borderShape,null,drawFocus);
  }
  GraphicsUtils.restoreAntialias(g2d,aa);
}","@Override protected void paintTabBackground(final Graphics g,final int tabPlacement,final int tabIndex,final int x,final int y,final int w,final int h,final boolean isSelected){
  final Graphics2D g2d=(Graphics2D)g;
  final Object aa=GraphicsUtils.setupAntialias(g2d);
  final GeneralPath borderShape=createTabShape(TabShapeType.border,tabPlacement,x,y,w,h,isSelected);
  if (tabbedPaneStyle.equals(TabbedPaneStyle.standalone)) {
    final GeneralPath shadeShape=createTabShape(TabShapeType.shade,tabPlacement,x,y,w,h,isSelected);
    GraphicsUtils.drawShade(g2d,shadeShape,StyleConstants.shadeColor,shadeWidth,new Rectangle2D.Double(0,0,tabPane.getWidth(),y + h),round > 0);
  }
  final GeneralPath bgShape=createTabShape(TabShapeType.background,tabPlacement,x,y,w,h,isSelected);
  if (backgroundPainterAt.containsKey(tabIndex) && isSelected) {
    final Shape old=GraphicsUtils.intersectClip(g2d,bgShape);
    final Painter bp=backgroundPainterAt.get(tabIndex);
    bp.paint(g2d,new Rectangle(x,y,w,h),tabPane);
    GraphicsUtils.restoreClip(g2d,old);
  }
 else {
    final Point topPoint=getTopTabBgPoint(tabPlacement,x,y,w,h);
    final Point bottomPoint=getBottomTabBgPoint(tabPlacement,x,y,w,h);
    if (isSelected) {
      if (forceUseSelectedTabBgColors) {
        g2d.setPaint(new GradientPaint(topPoint.x,topPoint.y,selectedTopBg,bottomPoint.x,bottomPoint.y,selectedBottomBg));
      }
 else {
        Color bg=tabPane.getBackgroundAt(tabIndex);
        bg=bg != null ? bg : tabPane.getBackground();
        g2d.setPaint(new GradientPaint(topPoint.x,topPoint.y,selectedTopBg,bottomPoint.x,bottomPoint.y,bg));
      }
    }
 else {
      g2d.setPaint(new GradientPaint(topPoint.x,topPoint.y,topBg,bottomPoint.x,bottomPoint.y,bottomBg));
    }
    g2d.fill(isSelected ? borderShape : bgShape);
  }
  g2d.setPaint(tabBorderColor);
  g2d.draw(borderShape);
  final boolean drawFocus=isSelected && tabPane.isFocusOwner();
  if (tabbedPaneStyle.equals(TabbedPaneStyle.standalone)) {
    LafUtils.drawCustomWebFocus(g2d,null,StyleConstants.focusType,borderShape,null,drawFocus);
  }
  GraphicsUtils.restoreAntialias(g2d,aa);
}"
52609,"/** 
 * Returns list of selected files.
 * @return list of selected files
 */
public List<File> getSelectedFiles(){
  final Object[] selectedValues=getSelectedValues();
  final List<File> selectedFiles=new ArrayList<File>(selectedValues.length);
  for (  Object value : selectedValues) {
    selectedFiles.add(((FileElement)value).getFile());
  }
  return selectedFiles;
}","/** 
 * Returns list of selected files.
 * @return list of selected files
 */
public List<File> getSelectedFiles(){
  final Object[] selectedValues=getSelectedValues();
  final List<File> selectedFiles=new ArrayList<File>(selectedValues.length);
  for (  final Object value : selectedValues) {
    selectedFiles.add(((FileElement)value).getFile());
  }
  return selectedFiles;
}"
52610,"/** 
 * Returns new scroll pane with fixed preferred size that fits file list settings.
 * @return new scroll pane with fixed preferred size that fits file list settings
 */
public WebScrollPane createScrollView(){
  return new WebScrollPane(WebFileList.this){
    @Override public Dimension getPreferredSize(){
      final Dimension ps=super.getPreferredSize();
      final Dimension oneCell;
      if (getModel().getSize() > 0) {
        oneCell=getCellBounds(0,0).getSize();
      }
 else {
        final WebFileListCellRenderer fileListCellRenderer=getWebFileListCellRenderer();
        if (fileListCellRenderer != null) {
          oneCell=fileListCellRenderer.getPreferredSize();
        }
 else {
          oneCell=new Dimension(400,300);
        }
      }
      final Insets bi=getInsets();
      ps.width=oneCell.width * preferredColumnCount + bi.left + bi.right + WebScrollBarUI.LENGTH + 1;
      ps.height=oneCell.height * preferredRowCount + bi.top + bi.bottom + 1;
      return ps;
    }
  }
;
}","/** 
 * Returns new scroll pane with fixed preferred size that fits file list settings.
 * @return new scroll pane with fixed preferred size that fits file list settings
 */
public WebScrollPane createScrollView(){
  return new WebScrollPane(WebFileList.this){
    @Override public Dimension getPreferredSize(){
      final Dimension ps=super.getPreferredSize();
      final int fcw=getFixedCellWidth();
      final int fch=getFixedCellHeight();
      final Dimension oneCell;
      if (fcw != -1 && fch != -1) {
        oneCell=new Dimension(fcw,fch);
      }
 else {
        if (getModel().getSize() > 0) {
          oneCell=getCellBounds(0,0).getSize();
        }
 else {
          final WebFileListCellRenderer fileListCellRenderer=getWebFileListCellRenderer();
          if (fileListCellRenderer != null) {
            oneCell=fileListCellRenderer.getPreferredSize();
          }
 else {
            oneCell=new Dimension(90,90);
          }
        }
        if (fcw != -1) {
          oneCell.width=fcw;
        }
 else         if (fch != -1) {
          oneCell.width=fcw;
        }
      }
      final Insets bi=getInsets();
      ps.width=oneCell.width * preferredColumnCount + bi.left + bi.right + WebScrollBarUI.LENGTH + 1;
      ps.height=oneCell.height * preferredRowCount + bi.top + bi.bottom + 1;
      return ps;
    }
  }
;
}"
52611,"/** 
 * Selects specified files if they present in the list.
 * @param files files to select
 */
public void setSelectedFiles(final Collection<File> files){
  final List<FileElement> elements=new ArrayList<FileElement>(files.size());
  for (  File file : files) {
    final FileElement element=getFileListModel().getElement(file);
    if (element != null) {
      elements.add(element);
    }
  }
  setSelectedValues(elements);
}","/** 
 * Selects specified files if they present in the list.
 * @param files files to select
 */
public void setSelectedFiles(final Collection<File> files){
  final List<FileElement> elements=new ArrayList<FileElement>(files.size());
  for (  final File file : files) {
    final FileElement element=getFileListModel().getElement(file);
    if (element != null) {
      elements.add(element);
    }
  }
  setSelectedValues(elements);
}"
52612,"/** 
 * Informs model that childs were loaded successfully.
 * @param childs list of loaded childs
 */
public void childsLoadCompleted(final List<E> childs);","/** 
 * Informs model that childs were loaded successfully.
 * @param childs list of loaded childs
 */
public void childsLoadCompleted(List<E> childs);"
52613,"/** 
 * Informs model that childs load failed due to the specified exception.
 * @param cause exception
 */
public void childsLoadFailed(final Throwable cause);","/** 
 * Informs model that childs load failed due to the specified exception.
 * @param cause exception
 */
public void childsLoadFailed(Throwable cause);"
52614,"/** 
 * Creates file table and all related components.
 */
protected void createFileTable(){
  fileTable=new WebFileTable();
  fileTable.setOpaque(false);
  fileTable.setTransferHandler(new FilesLocateDropHandler(UpdateSource.table));
  fileTable.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  fileTable.getActionMap().put(""String_Node_Str"",new AbstractAction(){
    @Override public boolean isEnabled(){
      return fileTable.getSelectedRow() != -1;
    }
    @Override public void actionPerformed(    final ActionEvent e){
      File file=fileTable.getSelectedFile();
      if (file.isDirectory()) {
        updateCurrentFolder(file,UpdateSource.table);
      }
    }
  }
);
  fileTable.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    final MouseEvent e){
      if (SwingUtilities.isLeftMouseButton(e) && e.getClickCount() % 2 == 0 && fileTable.getSelectedRow() != -1) {
        final File file=fileTable.getSelectedFile();
        if (file.isDirectory()) {
          updateCurrentFolder(file,UpdateSource.table);
        }
 else {
          fireApproveAction(new ActionEvent(fileTable,e.getID(),""String_Node_Str"",e.getWhen(),e.getModifiers()));
        }
      }
    }
  }
);
  fileTable.getSelectionModel().addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    final ListSelectionEvent e){
      updateSelectedFilesField();
    }
  }
);
  fileTable.getDefaultEditor(File.class).addCellEditorListener(new CellEditorListener(){
    @Override public void editingStopped(    final ChangeEvent e){
      final File file=fileTable.getSelectedFile();
      reloadCurrentFolder();
      fileTable.setSelectedFile(file);
    }
    @Override public void editingCanceled(    final ChangeEvent e){
    }
  }
);
  fileTableScroll=new WebScrollPane(fileTable,true);
  fileTableScroll.getViewport().setOpaque(true);
  fileTableScroll.getViewport().setBackground(Color.WHITE);
  fileTableScroll.setHorizontalScrollBarPolicy(WebScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  fileTableScroll.setVerticalScrollBarPolicy(WebScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
}","/** 
 * Creates file table and all related components.
 */
protected void createFileTable(){
  fileTable=new WebFileTable();
  fileTable.setOpaque(false);
  fileTable.setTransferHandler(new FilesLocateDropHandler(UpdateSource.table));
  fileTable.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  fileTable.getActionMap().put(""String_Node_Str"",new AbstractAction(){
    @Override public boolean isEnabled(){
      return fileTable.getSelectedRow() != -1;
    }
    @Override public void actionPerformed(    final ActionEvent e){
      final File file=fileTable.getSelectedFile();
      if (file.isDirectory()) {
        updateCurrentFolder(file,UpdateSource.table);
      }
    }
  }
);
  fileTable.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    final MouseEvent e){
      if (SwingUtilities.isLeftMouseButton(e) && e.getClickCount() % 2 == 0 && fileTable.getSelectedRow() != -1) {
        final File file=fileTable.getSelectedFile();
        if (file.isDirectory()) {
          updateCurrentFolder(file,UpdateSource.table);
        }
 else {
          fireApproveAction(new ActionEvent(fileTable,e.getID(),""String_Node_Str"",e.getWhen(),e.getModifiers()));
        }
      }
    }
  }
);
  fileTable.getSelectionModel().addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    final ListSelectionEvent e){
      updateSelectedFilesField();
    }
  }
);
  fileTable.getDefaultEditor(File.class).addCellEditorListener(new CellEditorListener(){
    @Override public void editingStopped(    final ChangeEvent e){
      final File file=fileTable.getSelectedFile();
      reloadCurrentFolder();
      fileTable.setSelectedFile(file);
    }
    @Override public void editingCanceled(    final ChangeEvent e){
    }
  }
);
  fileTableScroll=new WebScrollPane(fileTable,true);
  fileTableScroll.getViewport().setOpaque(true);
  fileTableScroll.getViewport().setBackground(Color.WHITE);
  fileTableScroll.setHorizontalScrollBarPolicy(WebScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  fileTableScroll.setVerticalScrollBarPolicy(WebScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
}"
52615,"/** 
 * Sets whether should display hidden files or not.
 * @param showHiddenFiles whether should display hidden files or not
 */
public void setShowHiddenFiles(boolean showHiddenFiles){
  this.showHiddenFiles=showHiddenFiles;
  updateDirectoryComponentFilters();
  updateFileComponentFilters();
}","/** 
 * Sets whether should display hidden files or not.
 * @param showHiddenFiles whether should display hidden files or not
 */
public void setShowHiddenFiles(final boolean showHiddenFiles){
  this.showHiddenFiles=showHiddenFiles;
  updateDirectoryComponentFilters();
  updateFileComponentFilters();
}"
52616,"/** 
 * {@inheritDoc}
 */
@Override public boolean accept(File file){
  return showHiddenFiles || !file.isHidden();
}","/** 
 * {@inheritDoc}
 */
@Override public boolean accept(final File file){
  return showHiddenFiles || !file.isHidden();
}"
52617,"/** 
 * Creates file list and all related components.
 */
protected void createFileList(){
  fileList=new WebFileList();
  fileList.setGenerateThumbnails(true);
  fileList.setDropMode(DropMode.ON);
  fileList.setEditable(true);
  fileList.setPreferredColumnCount(3);
  fileList.setPreferredRowCount(5);
  fileList.setTransferHandler(new FilesLocateDropHandler(UpdateSource.list));
  fileList.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  fileList.getActionMap().put(""String_Node_Str"",new AbstractAction(){
    @Override public boolean isEnabled(){
      return fileList.getSelectedIndex() != -1;
    }
    @Override public void actionPerformed(    final ActionEvent e){
      File file=fileList.getSelectedFile();
      if (file.isDirectory()) {
        updateCurrentFolder(file,UpdateSource.list);
      }
    }
  }
);
  fileList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    final MouseEvent e){
      if (SwingUtilities.isLeftMouseButton(e) && e.getClickCount() % 2 == 0 && fileList.getSelectedIndex() != -1) {
        final File file=fileList.getSelectedFile();
        if (file.isDirectory()) {
          updateCurrentFolder(file,UpdateSource.list);
        }
 else {
          fireApproveAction(new ActionEvent(fileList,e.getID(),""String_Node_Str"",e.getWhen(),e.getModifiers()));
        }
      }
    }
  }
);
  fileList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    final ListSelectionEvent e){
      updateSelectedFilesField();
    }
  }
);
  fileList.addListEditListener(new ListEditAdapter(){
    @Override public void editFinished(    final int index,    final Object oldValue,    final Object newValue){
      final File file=((FileElement)newValue).getFile();
      reloadCurrentFolder();
      fileList.setSelectedFile(file);
    }
  }
);
  fileListScroll=fileList.getScrollView();
  fileListScroll.setHorizontalScrollBarPolicy(WebScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  fileListScroll.setVerticalScrollBarPolicy(WebScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
}","/** 
 * Creates file list and all related components.
 */
protected void createFileList(){
  fileList=new WebFileList();
  fileList.setGenerateThumbnails(true);
  fileList.setDropMode(DropMode.ON);
  fileList.setEditable(true);
  fileList.setPreferredColumnCount(3);
  fileList.setPreferredRowCount(5);
  fileList.setTransferHandler(new FilesLocateDropHandler(UpdateSource.list));
  fileList.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),""String_Node_Str"");
  fileList.getActionMap().put(""String_Node_Str"",new AbstractAction(){
    @Override public boolean isEnabled(){
      return fileList.getSelectedIndex() != -1;
    }
    @Override public void actionPerformed(    final ActionEvent e){
      final File file=fileList.getSelectedFile();
      if (file.isDirectory()) {
        updateCurrentFolder(file,UpdateSource.list);
      }
    }
  }
);
  fileList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    final MouseEvent e){
      if (SwingUtilities.isLeftMouseButton(e) && e.getClickCount() % 2 == 0 && fileList.getSelectedIndex() != -1) {
        final File file=fileList.getSelectedFile();
        if (file.isDirectory()) {
          updateCurrentFolder(file,UpdateSource.list);
        }
 else {
          fireApproveAction(new ActionEvent(fileList,e.getID(),""String_Node_Str"",e.getWhen(),e.getModifiers()));
        }
      }
    }
  }
);
  fileList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    final ListSelectionEvent e){
      updateSelectedFilesField();
    }
  }
);
  fileList.addListEditListener(new ListEditAdapter(){
    @Override public void editFinished(    final int index,    final Object oldValue,    final Object newValue){
      final File file=((FileElement)newValue).getFile();
      reloadCurrentFolder();
      fileList.setSelectedFile(file);
    }
  }
);
  fileListScroll=fileList.getScrollView();
  fileListScroll.setHorizontalScrollBarPolicy(WebScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  fileListScroll.setVerticalScrollBarPolicy(WebScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
}"
52618,"@Override public Dimension getPreferredSize(){
  Dimension ps=super.getPreferredSize();
  ps.width=ps.width + WebScrollBarUI.LENGTH;
  ps.height=Math.min(ps.height,100);
  return ps;
}","@Override public Dimension getPreferredSize(){
  final Dimension ps=super.getPreferredSize();
  ps.width=ps.width + WebScrollBarUI.LENGTH;
  ps.height=Math.min(ps.height,100);
  return ps;
}"
52619,"/** 
 * Delete all selected in view files.
 */
public void deleteSelectedFiles(){
  final List<File> files=getAllSelectedFiles();
  if (files.isEmpty()) {
    return;
  }
  final WebPanel all=new WebPanel(new BorderLayout(0,5));
  all.add(new WebLabel(LanguageManager.get(""String_Node_Str"")),BorderLayout.NORTH);
  final WebPanel deleteFilesPanel=new WebPanel(new VerticalFlowLayout(VerticalFlowLayout.TOP,0,5,true,false));
  deleteFilesPanel.setMargin(3);
  deleteFilesPanel.setBackground(Color.WHITE);
  for (  File file : files) {
    deleteFilesPanel.add(new WebLabel(file.getName(),FileUtils.getFileIcon(file),WebLabel.LEFT));
  }
  final WebScrollPane scroll=new WebScrollPane(deleteFilesPanel){
    @Override public Dimension getPreferredSize(){
      Dimension ps=super.getPreferredSize();
      ps.width=ps.width + WebScrollBarUI.LENGTH;
      ps.height=Math.min(ps.height,100);
      return ps;
    }
  }
;
  all.add(scroll,BorderLayout.CENTER);
  final String title=LanguageManager.get(""String_Node_Str"");
  final int confirm=WebOptionPane.showConfirmDialog(WebFileChooserPanel.this,all,title,WebOptionPane.YES_NO_OPTION,WebOptionPane.QUESTION_MESSAGE);
  if (confirm == WebOptionPane.YES_OPTION) {
    FileUtils.deleteFiles(files);
    reloadCurrentFolder();
  }
}","/** 
 * Delete all selected in view files.
 */
public void deleteSelectedFiles(){
  final List<File> files=getAllSelectedFiles();
  if (files.isEmpty()) {
    return;
  }
  final WebPanel all=new WebPanel(new BorderLayout(0,5));
  all.add(new WebLabel(LanguageManager.get(""String_Node_Str"")),BorderLayout.NORTH);
  final WebPanel deleteFilesPanel=new WebPanel(new VerticalFlowLayout(VerticalFlowLayout.TOP,0,5,true,false));
  deleteFilesPanel.setMargin(3);
  deleteFilesPanel.setBackground(Color.WHITE);
  for (  final File file : files) {
    deleteFilesPanel.add(new WebLabel(file.getName(),FileUtils.getFileIcon(file),WebLabel.LEFT));
  }
  final WebScrollPane scroll=new WebScrollPane(deleteFilesPanel){
    @Override public Dimension getPreferredSize(){
      final Dimension ps=super.getPreferredSize();
      ps.width=ps.width + WebScrollBarUI.LENGTH;
      ps.height=Math.min(ps.height,100);
      return ps;
    }
  }
;
  all.add(scroll,BorderLayout.CENTER);
  final String title=LanguageManager.get(""String_Node_Str"");
  final int confirm=WebOptionPane.showConfirmDialog(WebFileChooserPanel.this,all,title,WebOptionPane.YES_NO_OPTION,WebOptionPane.QUESTION_MESSAGE);
  if (confirm == WebOptionPane.YES_OPTION) {
    FileUtils.deleteFiles(files);
    reloadCurrentFolder();
  }
}"
52620,"/** 
 * Replaces the element at the specified position in this list with the specified element. <p/> Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is out of range (<code>index &lt; 0 || index &gt;= size()</code>).
 * @param index   index of element to replace
 * @param element element to be stored at the specified position
 * @return the element previously at the specified position
 */
@Override public CheckBoxCellData set(int index,Object element){
  return (CheckBoxCellData)super.set(index,element);
}","/** 
 * Replaces the element at the specified position in this list with the specified element. <p> Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is out of range (<code>index &lt; 0 || index &gt;= size()</code>).
 * @param index   index of element to replace
 * @param element element to be stored at the specified position
 * @return the element previously at the specified position
 */
@Override public CheckBoxCellData set(int index,Object element){
  return (CheckBoxCellData)super.set(index,element);
}"
52621,"/** 
 * Removes the element at the specified position in this list. Returns the element that was removed from the list. <p/> Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is out of range (<code>index &lt; 0 || index &gt;= size()</code>).
 * @param index the index of the element to removed
 */
@Override public CheckBoxCellData remove(int index){
  return (CheckBoxCellData)super.remove(index);
}","/** 
 * Removes the element at the specified position in this list. Returns the element that was removed from the list. <p> Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is out of range (<code>index &lt; 0 || index &gt;= size()</code>).
 * @param index the index of the element to removed
 */
@Override public CheckBoxCellData remove(int index){
  return (CheckBoxCellData)super.remove(index);
}"
52622,"/** 
 * Returns the element at the specified position in this list. <p/> Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is out of range (<code>index &lt; 0 || index &gt;= size()</code>).
 * @param index index of element to return
 */
@Override public CheckBoxCellData get(int index){
  return (CheckBoxCellData)super.get(index);
}","/** 
 * Returns the element at the specified position in this list. <p> Throws an <code>ArrayIndexOutOfBoundsException</code> if the index is out of range (<code>index &lt; 0 || index &gt;= size()</code>).
 * @param index index of element to return
 */
@Override public CheckBoxCellData get(int index){
  return (CheckBoxCellData)super.get(index);
}"
52623,"/** 
 * Returns asynchronous tree root node. <p/> This request uses the EDT and should be processed quickly.
 * @return root node
 */
public E getRoot();","/** 
 * Returns asynchronous tree root node. <p> This request uses the EDT and should be processed quickly.
 * @return root node
 */
public E getRoot();"
52624,"/** 
 * Returns child nodes for the specified asynchronous tree node. <p/> This request uses a separate thread and might take a lot of time to process.
 * @param node parent node
 * @return list of child nodes
 */
public List<E> getChilds(E node);","/** 
 * Returns child nodes for the specified asynchronous tree node. <p> This request uses a separate thread and might take a lot of time to process.
 * @param node parent node
 * @return list of child nodes
 */
public List<E> getChilds(E node);"
52625,"/** 
 * Returns whether the specified node is leaf (doesn't have any childs) or not. <p/> This request uses the EDT and should be processed quickly. If you cannot be sure if the node is leaf or not - simply return false - this will allow the tree to expand this node on request.
 * @param node node
 * @return true if the specified node is leaf, false otherwise
 */
public boolean isLeaf(E node);","/** 
 * Returns whether the specified node is leaf (doesn't have any childs) or not. <p> This request uses the EDT and should be processed quickly. If you cannot be sure if the node is leaf or not - simply return false - this will allow the tree to expand this node on request.
 * @param node node
 * @return true if the specified node is leaf, false otherwise
 */
public boolean isLeaf(E node);"
52626,"/** 
 * Expands all visible tree rows in a single call. <p/> This method provides similar functionality to WebTree expandAll method and will actually expand all tree elements - even those which are not yet loaded from data provider. Make sure you know what you are doing before calling this method.
 */
@Override public final void expandAll(){
  for (int i=getRowCount() - 1; i >= 0; i--) {
    final TreePath path=getPathForRow(i);
    if (!getModel().isLeaf(getNodeForPath(path))) {
      performPathExpand(path);
    }
  }
}","/** 
 * Expands all visible tree rows in a single call. <p> This method provides similar functionality to WebTree expandAll method and will actually expand all tree elements - even those which are not yet loaded from data provider. Make sure you know what you are doing before calling this method.
 */
@Override public final void expandAll(){
  for (int i=getRowCount() - 1; i >= 0; i--) {
    final TreePath path=getPathForRow(i);
    if (!getModel().isLeaf(getNodeForPath(path))) {
      performPathExpand(path);
    }
  }
}"
52627,"@Override public void onActivityResult(int requestCode,int resultCode,Intent intent){
  if (resultCode == RESULT_OK && intent != null && intent.getData() != null) {
    Intent displayIntent=new Intent(this,TaskListActivity.class);
    displayIntent.putExtra(TaskListActivity.EXTRA_DISPLAY_TASK,true);
    displayIntent.putExtra(TaskListActivity.EXTRA_FORCE_LIST_SELECTION,true);
    Uri newTaskUri=intent.getData();
    displayIntent.setData(newTaskUri);
    onNewIntent(displayIntent);
  }
}","@Override public void onActivityResult(int requestCode,int resultCode,Intent intent){
  if (resultCode == RESULT_OK && intent != null && intent.getData() != null) {
    Intent displayIntent=new Intent(this,TaskListActivity.class);
    displayIntent.putExtra(TaskListActivity.EXTRA_DISPLAY_TASK,true);
    displayIntent.putExtra(TaskListActivity.EXTRA_FORCE_LIST_SELECTION,true);
    Uri newTaskUri=intent.getData();
    displayIntent.setData(newTaskUri);
    onNewIntent(displayIntent);
    setupTabIcons();
  }
}"
52628,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mTwoPane=getResources().getBoolean(R.bool.has_two_panes);
  resolveIntentAction(getIntent());
  if (mSelectedTaskUri != null) {
    if (mShouldShowDetails && mShouldSwitchToDetail) {
      Intent viewTaskIntent=new Intent(Intent.ACTION_VIEW);
      viewTaskIntent.setData(mSelectedTaskUri);
      startActivity(viewTaskIntent);
      mShouldSwitchToDetail=false;
      mTransientState=true;
    }
  }
 else {
    mShouldShowDetails=false;
  }
  setContentView(R.layout.activity_task_list);
  mAppBarLayout=(AppBarLayout)findViewById(R.id.appbar);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  mAuthority=AuthorityUtil.taskAuthority(this);
  mSearchHistoryHelper=new SearchHistoryHelper(this);
  if (findViewById(R.id.task_detail_container) != null) {
    loadTaskDetailFragment(mSelectedTaskUri);
  }
 else {
    FragmentManager fragmentManager=getSupportFragmentManager();
    Fragment detailFragment=fragmentManager.findFragmentByTag(DETAIL_FRAGMENT_TAG);
    if (detailFragment != null) {
      fragmentManager.beginTransaction().remove(detailFragment).commit();
    }
  }
  mGroupingFactories=new AbstractGroupingFactory[]{new ByList(mAuthority,this),new ByDueDate(mAuthority),new ByStartDate(mAuthority),new ByPriority(mAuthority,this),new ByProgress(mAuthority),new BySearch(mAuthority,mSearchHistoryHelper)};
  mPagerAdapter=new Unchecked<>(() -> new TaskGroupPagerAdapter(getSupportFragmentManager(),mGroupingFactories,this,R.xml.listview_tabs)).value();
  mPagerAdapter.setTwoPaneLayout(mTwoPane);
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setAdapter(mPagerAdapter);
  int currentPageIndex=mPagerAdapter.getPagePosition(mCurrentPageId);
  if (currentPageIndex >= 0) {
    mCurrentPagePosition=currentPageIndex;
    mViewPager.setCurrentItem(currentPageIndex);
    if (mCurrentPageId == R.id.task_group_search) {
      if (mSearchItem != null) {
        MenuItemCompat.expandActionView(mSearchItem);
      }
 else {
        mAutoExpandSearchView=true;
      }
    }
  }
  updateTitle(currentPageIndex);
  mTabs=(TabLayout)findViewById(R.id.tabs);
  mTabs.setupWithViewPager(mViewPager);
  for (int i=0, count=mPagerAdapter.getCount(); i < count; ++i) {
    mTabs.getTabAt(i).setIcon(mPagerAdapter.getTabIcon(i));
  }
  mViewPager.addOnPageChangeListener(new OnPageChangeListener(){
    @Override public void onPageSelected(    int position){
      mSelectedTaskUri=null;
      mCurrentPagePosition=position;
      int newPageId=mPagerAdapter.getPageId(mCurrentPagePosition);
      if (newPageId == R.id.task_group_search) {
        int oldPageId=mCurrentPageId;
        mCurrentPageId=newPageId;
        mPreviousPagePosition=mPagerAdapter.getPagePosition(oldPageId);
      }
 else       if (mCurrentPageId == R.id.task_group_search) {
        mSearchHistoryHelper.commitSearch();
        mHandler.post(mSearchUpdater);
        mCurrentPageId=newPageId;
        hideSearchActionView();
      }
      mCurrentPageId=newPageId;
      updateTitle(mCurrentPageId);
    }
    @Override public void onPageScrolled(    int position,    float positionOffset,    int positionOffsetPixels){
    }
    @Override public void onPageScrollStateChanged(    int state){
      if (state == ViewPager.SCROLL_STATE_IDLE && mCurrentPageId == R.id.task_group_search) {
        mHandler.postDelayed(new Runnable(){
          @Override public void run(){
            MenuItemCompat.expandActionView(mSearchItem);
          }
        }
,50);
      }
    }
  }
);
  mFloatingActionButton=(FloatingActionButton)findViewById(R.id.floating_action_button);
  if (mFloatingActionButton != null) {
    mFloatingActionButton.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        onAddNewTask();
      }
    }
);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mTwoPane=getResources().getBoolean(R.bool.has_two_panes);
  resolveIntentAction(getIntent());
  if (mSelectedTaskUri != null) {
    if (mShouldShowDetails && mShouldSwitchToDetail) {
      Intent viewTaskIntent=new Intent(Intent.ACTION_VIEW);
      viewTaskIntent.setData(mSelectedTaskUri);
      startActivity(viewTaskIntent);
      mShouldSwitchToDetail=false;
      mTransientState=true;
    }
  }
 else {
    mShouldShowDetails=false;
  }
  setContentView(R.layout.activity_task_list);
  mAppBarLayout=(AppBarLayout)findViewById(R.id.appbar);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  mAuthority=AuthorityUtil.taskAuthority(this);
  mSearchHistoryHelper=new SearchHistoryHelper(this);
  if (findViewById(R.id.task_detail_container) != null) {
    loadTaskDetailFragment(mSelectedTaskUri);
  }
 else {
    FragmentManager fragmentManager=getSupportFragmentManager();
    Fragment detailFragment=fragmentManager.findFragmentByTag(DETAIL_FRAGMENT_TAG);
    if (detailFragment != null) {
      fragmentManager.beginTransaction().remove(detailFragment).commit();
    }
  }
  mGroupingFactories=new AbstractGroupingFactory[]{new ByList(mAuthority,this),new ByDueDate(mAuthority),new ByStartDate(mAuthority),new ByPriority(mAuthority,this),new ByProgress(mAuthority),new BySearch(mAuthority,mSearchHistoryHelper)};
  mPagerAdapter=new Unchecked<>(() -> new TaskGroupPagerAdapter(getSupportFragmentManager(),mGroupingFactories,this,R.xml.listview_tabs)).value();
  mPagerAdapter.setTwoPaneLayout(mTwoPane);
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setAdapter(mPagerAdapter);
  int currentPageIndex=mPagerAdapter.getPagePosition(mCurrentPageId);
  if (currentPageIndex >= 0) {
    mCurrentPagePosition=currentPageIndex;
    mViewPager.setCurrentItem(currentPageIndex);
    if (mCurrentPageId == R.id.task_group_search) {
      if (mSearchItem != null) {
        MenuItemCompat.expandActionView(mSearchItem);
      }
 else {
        mAutoExpandSearchView=true;
      }
    }
  }
  updateTitle(currentPageIndex);
  mTabs=(TabLayout)findViewById(R.id.tabs);
  mTabs.setupWithViewPager(mViewPager);
  setupTabIcons();
  mViewPager.addOnPageChangeListener(new OnPageChangeListener(){
    @Override public void onPageSelected(    int position){
      mSelectedTaskUri=null;
      mCurrentPagePosition=position;
      int newPageId=mPagerAdapter.getPageId(mCurrentPagePosition);
      if (newPageId == R.id.task_group_search) {
        int oldPageId=mCurrentPageId;
        mCurrentPageId=newPageId;
        mPreviousPagePosition=mPagerAdapter.getPagePosition(oldPageId);
      }
 else       if (mCurrentPageId == R.id.task_group_search) {
        mSearchHistoryHelper.commitSearch();
        mHandler.post(mSearchUpdater);
        mCurrentPageId=newPageId;
        hideSearchActionView();
      }
      mCurrentPageId=newPageId;
      updateTitle(mCurrentPageId);
    }
    @Override public void onPageScrolled(    int position,    float positionOffset,    int positionOffsetPixels){
    }
    @Override public void onPageScrollStateChanged(    int state){
      if (state == ViewPager.SCROLL_STATE_IDLE && mCurrentPageId == R.id.task_group_search) {
        mHandler.postDelayed(new Runnable(){
          @Override public void run(){
            MenuItemCompat.expandActionView(mSearchItem);
          }
        }
,50);
      }
    }
  }
);
  mFloatingActionButton=(FloatingActionButton)findViewById(R.id.floating_action_button);
  if (mFloatingActionButton != null) {
    mFloatingActionButton.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        onAddNewTask();
      }
    }
);
  }
}"
52629,"@Override public boolean onOptionsItemSelected(MenuItem item){
  int itemId=item.getItemId();
  if (itemId == R.id.edit_task) {
    mCallback.onEditTask(mTaskUri,mContentSet);
    return true;
  }
 else   if (itemId == R.id.delete_task) {
    new AlertDialog.Builder(getActivity()).setTitle(R.string.confirm_delete_title).setCancelable(true).setNegativeButton(android.R.string.cancel,new OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
      }
    }
).setPositiveButton(android.R.string.ok,new OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        if (mContentSet != null) {
          mContentSet.delete(mAppContext);
          mCallback.onDelete(mTaskUri);
        }
      }
    }
).setMessage(R.string.confirm_delete_message).create().show();
    return true;
  }
 else   if (itemId == R.id.complete_task) {
    completeTask();
    return true;
  }
 else   if (itemId == R.id.pin_task) {
    if (TaskFieldAdapters.PINNED.get(mContentSet)) {
      item.setIcon(R.drawable.ic_pin_white_24dp);
      TaskNotificationHandler.unpinTask(mAppContext,mContentSet);
    }
 else {
      item.setIcon(R.drawable.ic_pin_off_white_24dp);
      TaskNotificationHandler.pinTask(mAppContext,mContentSet);
    }
    persistTask();
    return true;
  }
 else   if (itemId == R.id.opentasks_send_task) {
    setSendMenuIntent();
    return false;
  }
 else {
    return super.onOptionsItemSelected(item);
  }
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  mDetailView.updateValues();
  int itemId=item.getItemId();
  if (itemId == R.id.edit_task) {
    mCallback.onEditTask(mTaskUri,mContentSet);
    return true;
  }
 else   if (itemId == R.id.delete_task) {
    new AlertDialog.Builder(getActivity()).setTitle(R.string.confirm_delete_title).setCancelable(true).setNegativeButton(android.R.string.cancel,new OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
      }
    }
).setPositiveButton(android.R.string.ok,new OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        if (mContentSet != null) {
          mContentSet.delete(mAppContext);
          mCallback.onDelete(mTaskUri);
        }
      }
    }
).setMessage(R.string.confirm_delete_message).create().show();
    return true;
  }
 else   if (itemId == R.id.complete_task) {
    completeTask();
    return true;
  }
 else   if (itemId == R.id.pin_task) {
    if (TaskFieldAdapters.PINNED.get(mContentSet)) {
      item.setIcon(R.drawable.ic_pin_white_24dp);
      TaskNotificationHandler.unpinTask(mAppContext,mContentSet);
    }
 else {
      item.setIcon(R.drawable.ic_pin_off_white_24dp);
      TaskNotificationHandler.pinTask(mAppContext,mContentSet);
    }
    persistTask();
    return true;
  }
 else   if (itemId == R.id.opentasks_send_task) {
    setSendMenuIntent();
    return false;
  }
 else {
    return super.onOptionsItemSelected(item);
  }
}"
52630,"@Override public void onFocusChange(View v,boolean hasFocus){
  itemView.findViewById(R.id.drag_handle).setVisibility(hasFocus ? View.INVISIBLE : View.VISIBLE);
  itemView.findViewById(R.id.remove_item).setVisibility(hasFocus ? View.VISIBLE : View.INVISIBLE);
}","@Override public void onFocusChange(View v,boolean hasFocus){
  itemView.findViewById(R.id.drag_handle).setVisibility(hasFocus ? View.INVISIBLE : View.VISIBLE);
  itemView.findViewById(R.id.remove_item).setVisibility(hasFocus ? View.VISIBLE : View.INVISIBLE);
  String newText=text.getText().toString();
  if (!hasFocus && !newText.equals(item.text) && mValues != null && !mCurrentValue.equals(mAdapter.get(mValues))) {
    item.text=newText;
    mAdapter.validateAndSet(mValues,mCurrentValue);
  }
}"
52631,"@Override public void afterTextChanged(Editable s){
  String newText=s.toString();
  if (!newText.equals(item.text) && mValues != null) {
    item.text=newText;
    mAdapter.validateAndSet(mValues,mCurrentValue);
  }
}","@Override public void afterTextChanged(Editable s){
  item.text=s.toString();
}"
52632,"@SuppressWarnings(""String_Node_Str"") private void bindItemView(final View itemView,final CheckListItem item){
  CheckBox checkbox=(CheckBox)itemView.findViewById(android.R.id.checkbox);
  checkbox.setOnCheckedChangeListener(null);
  checkbox.setChecked(item.checked);
  checkbox.setOnCheckedChangeListener(CheckListFieldView.this);
  final EditText text=(EditText)itemView.findViewById(android.R.id.title);
  text.setTextAppearance(getContext(),item.checked ? R.style.checklist_checked_item_text : R.style.dark_text);
  text.setText(item.text);
  text.setOnFocusChangeListener(new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      itemView.findViewById(R.id.drag_handle).setVisibility(hasFocus ? View.INVISIBLE : View.VISIBLE);
      itemView.findViewById(R.id.remove_item).setVisibility(hasFocus ? View.VISIBLE : View.INVISIBLE);
    }
  }
);
  text.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES);
  text.setMaxLines(100);
  text.setHorizontallyScrolling(false);
  text.setOnEditorActionListener(new OnEditorActionListener(){
    @Override public boolean onEditorAction(    TextView v,    int actionId,    KeyEvent event){
      if (actionId == EditorInfo.IME_ACTION_NEXT) {
        int pos=mContainer.indexOfChild(itemView);
        insertEmptyItem(pos + 1);
        return true;
      }
      return false;
    }
  }
);
  text.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  text.addTextChangedListener(new TextWatcher(){
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void afterTextChanged(    Editable s){
      String newText=s.toString();
      if (!newText.equals(item.text) && mValues != null) {
        item.text=newText;
        mAdapter.validateAndSet(mValues,mCurrentValue);
      }
    }
  }
);
  if (VERSION.SDK_INT < 18) {
    int inputType=text.getInputType();
    text.setInputType(inputType | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
  }
  View removeButton=itemView.findViewById(R.id.remove_item);
  removeButton.setTag(item);
  removeButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mImm.hideSoftInputFromWindow(text.getWindowToken(),0);
      mCurrentValue.remove(v.getTag());
      mAdapter.validateAndSet(mValues,mCurrentValue);
      mContainer.removeDragView(itemView);
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") private void bindItemView(final View itemView,final CheckListItem item){
  CheckBox checkbox=(CheckBox)itemView.findViewById(android.R.id.checkbox);
  checkbox.setOnCheckedChangeListener(null);
  checkbox.setChecked(item.checked);
  checkbox.setOnCheckedChangeListener(CheckListFieldView.this);
  final EditText text=(EditText)itemView.findViewById(android.R.id.title);
  text.setTextAppearance(getContext(),item.checked ? R.style.checklist_checked_item_text : R.style.dark_text);
  text.setText(item.text);
  text.setOnFocusChangeListener(new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      itemView.findViewById(R.id.drag_handle).setVisibility(hasFocus ? View.INVISIBLE : View.VISIBLE);
      itemView.findViewById(R.id.remove_item).setVisibility(hasFocus ? View.VISIBLE : View.INVISIBLE);
      String newText=text.getText().toString();
      if (!hasFocus && !newText.equals(item.text) && mValues != null && !mCurrentValue.equals(mAdapter.get(mValues))) {
        item.text=newText;
        mAdapter.validateAndSet(mValues,mCurrentValue);
      }
    }
  }
);
  text.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES);
  text.setMaxLines(100);
  text.setHorizontallyScrolling(false);
  text.setOnEditorActionListener(new OnEditorActionListener(){
    @Override public boolean onEditorAction(    TextView v,    int actionId,    KeyEvent event){
      if (actionId == EditorInfo.IME_ACTION_NEXT) {
        int pos=mContainer.indexOfChild(itemView);
        insertEmptyItem(pos + 1);
        return true;
      }
      return false;
    }
  }
);
  text.setImeOptions(EditorInfo.IME_ACTION_NEXT);
  text.addTextChangedListener(new TextWatcher(){
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void afterTextChanged(    Editable s){
      item.text=s.toString();
    }
  }
);
  if (VERSION.SDK_INT < 18) {
    int inputType=text.getInputType();
    text.setInputType(inputType | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
  }
  View removeButton=itemView.findViewById(R.id.remove_item);
  removeButton.setTag(item);
  removeButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mImm.hideSoftInputFromWindow(text.getWindowToken(),0);
      mCurrentValue.remove(v.getTag());
      mAdapter.validateAndSet(mValues,mCurrentValue);
      mContainer.removeDragView(itemView);
    }
  }
);
}"
52633,"@Override public void onClick(DialogInterface dialog,int which){
  mAppContext.getContentResolver().delete(taskUri,null,null);
  Snackbar.make(mExpandableListView,getString(R.string.toast_task_deleted,taskTitle),Snackbar.LENGTH_SHORT).show();
}","@Override public void onClick(DialogInterface dialog,int which){
  mAppContext.getContentResolver().delete(taskUri,null,null);
  Snackbar.make(mExpandableListView,getString(R.string.toast_task_deleted,taskTitle),Snackbar.LENGTH_SHORT).show();
  mCallbacks.onItemSelected(null,false,-1);
}"
52634,"/** 
 * Remove the task with the given   {@link Uri} and title, asking for confirmation first.
 * @param taskUri The  {@link Uri} of the atsk to remove.
 * @param taskTitle the title of the task to remove.
 * @return
 */
private void removeTask(final Uri taskUri,final String taskTitle){
  new AlertDialog.Builder(getActivity()).setTitle(R.string.confirm_delete_title).setCancelable(true).setNegativeButton(android.R.string.cancel,new OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
).setPositiveButton(android.R.string.ok,new OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      mAppContext.getContentResolver().delete(taskUri,null,null);
      Snackbar.make(mExpandableListView,getString(R.string.toast_task_deleted,taskTitle),Snackbar.LENGTH_SHORT).show();
    }
  }
).setMessage(getString(R.string.confirm_delete_message_with_title,taskTitle)).create().show();
}","/** 
 * Remove the task with the given   {@link Uri} and title, asking for confirmation first.
 * @param taskUri The  {@link Uri} of the atsk to remove.
 * @param taskTitle the title of the task to remove.
 * @return
 */
private void removeTask(final Uri taskUri,final String taskTitle){
  new AlertDialog.Builder(getActivity()).setTitle(R.string.confirm_delete_title).setCancelable(true).setNegativeButton(android.R.string.cancel,new OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
).setPositiveButton(android.R.string.ok,new OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      mAppContext.getContentResolver().delete(taskUri,null,null);
      Snackbar.make(mExpandableListView,getString(R.string.toast_task_deleted,taskTitle),Snackbar.LENGTH_SHORT).show();
      mCallbacks.onItemSelected(null,false,-1);
    }
  }
).setMessage(getString(R.string.confirm_delete_message_with_title,taskTitle)).create().show();
}"
52635,"public void reload(){
  mItems=null;
  mExecutor.execute(mReloadTasks);
}","public void reload(){
  mExecutor.execute(mReloadTasks);
}"
52636,"@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) private void notifyUser(boolean close){
  if (VERSION.SDK_INT >= 14) {
    mContent.animate().alpha(0).setDuration(250).start();
    mConfirmation.setAlpha(0);
    mConfirmation.setVisibility(View.VISIBLE);
    mConfirmation.animate().alpha(1).setDuration(250).start();
  }
 else {
    mContent.setVisibility(View.INVISIBLE);
    mConfirmation.setVisibility(View.VISIBLE);
  }
  if (close) {
    mContent.postDelayed(mDismiss,1000);
  }
 else {
    int duration=COMPLETION_DELAY_BASE + COMPLETION_DELAY_MAX / ++mSaveCounter;
    mContent.postDelayed(mReset,duration);
  }
}","@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) private void notifyUser(boolean close){
  if (VERSION.SDK_INT >= 14) {
    mContent.animate().alpha(0).setDuration(250).start();
    mConfirmation.setAlpha(0);
    mConfirmation.setVisibility(View.VISIBLE);
    mConfirmation.animate().alpha(1).setDuration(250).start();
  }
 else {
    mContent.setVisibility(View.INVISIBLE);
    mConfirmation.setVisibility(View.VISIBLE);
  }
  if (close) {
    delayedDismiss();
  }
 else {
    int duration=COMPLETION_DELAY_BASE + COMPLETION_DELAY_MAX / ++mSaveCounter;
    mContent.postDelayed(mReset,duration);
  }
}"
52637,"@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) @Override protected void onCreate(Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_task_list);
  mAuthority=getString(R.string.org_dmfs_tasks_authority);
  mSearchHistoryHelper=new SearchHistoryHelper(this);
  if (findViewById(R.id.task_detail_container) != null) {
    mTwoPane=true;
    mTaskDetailFrag=new ViewTaskFragment();
    getSupportFragmentManager().beginTransaction().replace(R.id.task_detail_container,mTaskDetailFrag).commit();
  }
  mGroupingFactories=new AbstractGroupingFactory[]{new ByList(mAuthority),new ByDueDate(mAuthority),new ByStartDate(mAuthority),new ByPriority(mAuthority),new ByProgress(mAuthority),new BySearch(mAuthority,mSearchHistoryHelper)};
  try {
    mPagerAdapter=new TaskGroupPagerAdapter(getSupportFragmentManager(),mGroupingFactories,this,R.xml.listview_tabs);
  }
 catch (  XmlPullParserException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  XmlObjectPullParserException e) {
    e.printStackTrace();
  }
  mPagerAdapter.setTwoPaneLayout(mTwoPane);
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setAdapter(mPagerAdapter);
  int currentPageIndex=mPagerAdapter.getPagePosition(mCurrentPageId);
  if (currentPageIndex >= 0) {
    mViewPager.setCurrentItem(currentPageIndex);
    if (VERSION.SDK_INT >= 14 && mCurrentPageId == R.id.task_group_search) {
      if (mSearchItem != null) {
        MenuItemCompat.expandActionView(mSearchItem);
      }
 else {
        mAutoExpandSearchView=true;
      }
    }
  }
  updateTitle(currentPageIndex);
  mTabs=(PagerSlidingTabStrip)findViewById(R.id.tabs);
  mTabs.setViewPager(mViewPager);
  mTabs.setOnPageChangeListener(new OnPageChangeListener(){
    @Override public void onPageSelected(    int position){
      int newPageId=mPagerAdapter.getPageId(position);
      if (newPageId == R.id.task_group_search) {
        int oldPageId=mCurrentPageId;
        mCurrentPageId=newPageId;
        MenuItemCompat.expandActionView(mSearchItem);
        mPreviousPagePosition=mPagerAdapter.getPagePosition(oldPageId);
      }
 else       if (mCurrentPageId == R.id.task_group_search) {
        mSearchHistoryHelper.commitSearch();
        mHandler.post(mSearchUpdater);
        mCurrentPageId=newPageId;
        hideSearchActionView();
      }
      mCurrentPageId=newPageId;
      updateTitle(mCurrentPageId);
    }
    @Override public void onPageScrolled(    int position,    float positionOffset,    int positionOffsetPixels){
    }
    @Override public void onPageScrollStateChanged(    int position){
    }
  }
);
}","@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) @Override protected void onCreate(Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_task_list);
  mAuthority=getString(R.string.org_dmfs_tasks_authority);
  mSearchHistoryHelper=new SearchHistoryHelper(this);
  if (findViewById(R.id.task_detail_container) != null) {
    mTwoPane=true;
    mTaskDetailFrag=new ViewTaskFragment();
    getSupportFragmentManager().beginTransaction().replace(R.id.task_detail_container,mTaskDetailFrag).commit();
  }
  mGroupingFactories=new AbstractGroupingFactory[]{new ByList(mAuthority),new ByDueDate(mAuthority),new ByStartDate(mAuthority),new ByPriority(mAuthority),new ByProgress(mAuthority),new BySearch(mAuthority,mSearchHistoryHelper)};
  try {
    mPagerAdapter=new TaskGroupPagerAdapter(getSupportFragmentManager(),mGroupingFactories,this,R.xml.listview_tabs);
  }
 catch (  XmlPullParserException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  XmlObjectPullParserException e) {
    e.printStackTrace();
  }
  mPagerAdapter.setTwoPaneLayout(mTwoPane);
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setAdapter(mPagerAdapter);
  int currentPageIndex=mPagerAdapter.getPagePosition(mCurrentPageId);
  if (currentPageIndex >= 0) {
    mViewPager.setCurrentItem(currentPageIndex);
    if (VERSION.SDK_INT >= 14 && mCurrentPageId == R.id.task_group_search) {
      if (mSearchItem != null) {
        MenuItemCompat.expandActionView(mSearchItem);
      }
 else {
        mAutoExpandSearchView=true;
      }
    }
  }
  updateTitle(currentPageIndex);
  mTabs=(PagerSlidingTabStrip)findViewById(R.id.tabs);
  mTabs.setViewPager(mViewPager);
  mTabs.setOnPageChangeListener(new OnPageChangeListener(){
    @Override public void onPageSelected(    int position){
      int newPageId=mPagerAdapter.getPageId(position);
      if (newPageId == R.id.task_group_search) {
        int oldPageId=mCurrentPageId;
        mCurrentPageId=newPageId;
        mPreviousPagePosition=mPagerAdapter.getPagePosition(oldPageId);
      }
 else       if (mCurrentPageId == R.id.task_group_search) {
        mSearchHistoryHelper.commitSearch();
        mHandler.post(mSearchUpdater);
        mCurrentPageId=newPageId;
        hideSearchActionView();
      }
      mCurrentPageId=newPageId;
      updateTitle(mCurrentPageId);
    }
    @Override public void onPageScrolled(    int position,    float positionOffset,    int positionOffsetPixels){
    }
    @Override public void onPageScrollStateChanged(    int state){
      if (state == ViewPager.SCROLL_STATE_IDLE && mCurrentPageId == R.id.task_group_search) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            MenuItemCompat.expandActionView(mSearchItem);
          }
        }
);
      }
    }
  }
);
}"
52638,"@Override public void onPageSelected(int position){
  int newPageId=mPagerAdapter.getPageId(position);
  if (newPageId == R.id.task_group_search) {
    int oldPageId=mCurrentPageId;
    mCurrentPageId=newPageId;
    MenuItemCompat.expandActionView(mSearchItem);
    mPreviousPagePosition=mPagerAdapter.getPagePosition(oldPageId);
  }
 else   if (mCurrentPageId == R.id.task_group_search) {
    mSearchHistoryHelper.commitSearch();
    mHandler.post(mSearchUpdater);
    mCurrentPageId=newPageId;
    hideSearchActionView();
  }
  mCurrentPageId=newPageId;
  updateTitle(mCurrentPageId);
}","@Override public void onPageSelected(int position){
  int newPageId=mPagerAdapter.getPageId(position);
  if (newPageId == R.id.task_group_search) {
    int oldPageId=mCurrentPageId;
    mCurrentPageId=newPageId;
    mPreviousPagePosition=mPagerAdapter.getPagePosition(oldPageId);
  }
 else   if (mCurrentPageId == R.id.task_group_search) {
    mSearchHistoryHelper.commitSearch();
    mHandler.post(mSearchUpdater);
    mCurrentPageId=newPageId;
    hideSearchActionView();
  }
  mCurrentPageId=newPageId;
  updateTitle(mCurrentPageId);
}"
52639,"@Override public void onPageScrollStateChanged(int position){
}","@Override public void onPageScrollStateChanged(int state){
  if (state == ViewPager.SCROLL_STATE_IDLE && mCurrentPageId == R.id.task_group_search) {
    mHandler.post(new Runnable(){
      @Override public void run(){
        MenuItemCompat.expandActionView(mSearchItem);
      }
    }
);
  }
}"
52640,"@Override public boolean onQueryTextChange(String query){
  mHandler.removeCallbacks(mSearchUpdater);
  if (query.length() > 0) {
    mSearchHistoryHelper.updateSearch(query);
    mHandler.postDelayed(mSearchUpdater,SEARCH_UPDATE_DELAY);
  }
 else {
    mSearchHistoryHelper.removeCurrentSearch();
    mHandler.post(mSearchUpdater);
  }
  return true;
}","@Override public boolean onQueryTextChange(String query){
  if (mCurrentPageId != R.id.task_group_search) {
    return true;
  }
  mHandler.removeCallbacks(mSearchUpdater);
  if (query.length() > 0) {
    mSearchHistoryHelper.updateSearch(query);
    mHandler.postDelayed(mSearchUpdater,SEARCH_UPDATE_DELAY);
  }
 else {
    mSearchHistoryHelper.removeCurrentSearch();
    mHandler.post(mSearchUpdater);
  }
  return true;
}"
52641,"@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void setupSearch(Menu menu){
  if (Build.VERSION.SDK_INT < 11) {
    return;
  }
  mSearchItem=menu.findItem(R.id.search);
  MenuItemCompat.setOnActionExpandListener(mSearchItem,new OnActionExpandListener(){
    @Override public boolean onMenuItemActionExpand(    MenuItem item){
      return mCurrentPageId == R.id.task_group_search;
    }
    @Override public boolean onMenuItemActionCollapse(    MenuItem item){
      if (mPreviousPagePosition >= 0 && mCurrentPageId == R.id.task_group_search) {
        mViewPager.setCurrentItem(mPreviousPagePosition);
        mCurrentPageId=mPagerAdapter.getPageId(mPreviousPagePosition);
      }
      return mPreviousPagePosition >= 0 || mCurrentPageId != R.id.task_group_search;
    }
  }
);
  SearchView searchView=(SearchView)MenuItemCompat.getActionView(mSearchItem);
  SearchManager searchManager=(SearchManager)getSystemService(Context.SEARCH_SERVICE);
  if (null != searchManager) {
    searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));
  }
  searchView.setQueryHint(getString(R.string.menu_search_hint));
  searchView.setIconified(true);
  searchView.setOnQueryTextListener(new OnQueryTextListener(){
    @Override public boolean onQueryTextSubmit(    String query){
      mSearchHistoryHelper.commitSearch();
      mHandler.post(mSearchUpdater);
      return true;
    }
    @Override public boolean onQueryTextChange(    String query){
      mHandler.removeCallbacks(mSearchUpdater);
      if (query.length() > 0) {
        mSearchHistoryHelper.updateSearch(query);
        mHandler.postDelayed(mSearchUpdater,SEARCH_UPDATE_DELAY);
      }
 else {
        mSearchHistoryHelper.removeCurrentSearch();
        mHandler.post(mSearchUpdater);
      }
      return true;
    }
  }
);
  if (mAutoExpandSearchView) {
    mSearchItem.expandActionView();
  }
}","@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void setupSearch(Menu menu){
  if (Build.VERSION.SDK_INT < 11) {
    return;
  }
  mSearchItem=menu.findItem(R.id.search);
  MenuItemCompat.setOnActionExpandListener(mSearchItem,new OnActionExpandListener(){
    @Override public boolean onMenuItemActionExpand(    MenuItem item){
      return mCurrentPageId == R.id.task_group_search;
    }
    @Override public boolean onMenuItemActionCollapse(    MenuItem item){
      if (mPreviousPagePosition >= 0 && mCurrentPageId == R.id.task_group_search) {
        mViewPager.setCurrentItem(mPreviousPagePosition);
        mCurrentPageId=mPagerAdapter.getPageId(mPreviousPagePosition);
      }
      return mPreviousPagePosition >= 0 || mCurrentPageId != R.id.task_group_search;
    }
  }
);
  SearchView searchView=(SearchView)MenuItemCompat.getActionView(mSearchItem);
  SearchManager searchManager=(SearchManager)getSystemService(Context.SEARCH_SERVICE);
  if (null != searchManager) {
    searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));
  }
  searchView.setQueryHint(getString(R.string.menu_search_hint));
  searchView.setIconified(true);
  searchView.setOnQueryTextListener(new OnQueryTextListener(){
    @Override public boolean onQueryTextSubmit(    String query){
      mSearchHistoryHelper.commitSearch();
      mHandler.post(mSearchUpdater);
      return true;
    }
    @Override public boolean onQueryTextChange(    String query){
      if (mCurrentPageId != R.id.task_group_search) {
        return true;
      }
      mHandler.removeCallbacks(mSearchUpdater);
      if (query.length() > 0) {
        mSearchHistoryHelper.updateSearch(query);
        mHandler.postDelayed(mSearchUpdater,SEARCH_UPDATE_DELAY);
      }
 else {
        mSearchHistoryHelper.removeCurrentSearch();
        mHandler.post(mSearchUpdater);
      }
      return true;
    }
  }
);
  if (mAutoExpandSearchView) {
    mSearchItem.expandActionView();
  }
}"
52642,"@Override public RemoteViews getViewAt(int position){
  if (items == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (items[position] == null) {
    throw new NullPointerException(""String_Node_Str"" + items.length + ""String_Node_Str""+ position);
  }
  if (items[position].getTaskTitle() == null) {
    throw new NullPointerException(""String_Node_Str"" + position + ""String_Node_Str"");
  }
  RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.task_list_widget_item);
  row.setTextViewText(android.R.id.title,items[position].getTaskTitle());
  row.setInt(R.id.task_list_color,""String_Node_Str"",items[position].getTaskColor());
  Time dueDate=items[position].getDueDate();
  if (dueDate != null) {
    if (mNow == null) {
      mNow=new Time();
    }
    mNow.clear(TimeZone.getDefault().getID());
    mNow.setToNow();
    row.setTextViewText(android.R.id.text1,mDueDateFormatter.format(dueDate));
    if (dueDate.before(mNow) & !items[position].getIsClosed()) {
      row.setTextColor(android.R.id.text1,mResources.getColor(android.R.color.holo_red_light));
    }
 else {
      row.setTextColor(android.R.id.text1,mResources.getColor(R.color.lighter_gray));
    }
  }
 else {
    row.setTextViewText(android.R.id.text1,null);
  }
  Uri taskUri=ContentUris.withAppendedId(Tasks.CONTENT_URI,items[position].getTaskId());
  Intent i=new Intent();
  i.setData(taskUri);
  row.setOnClickFillInIntent(android.R.id.title,i);
  return (row);
}","@Override public RemoteViews getViewAt(int position){
  if (position < 0 || position > getCount()) {
    return null;
  }
  RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.task_list_widget_item);
  row.setTextViewText(android.R.id.title,items[position].getTaskTitle());
  row.setInt(R.id.task_list_color,""String_Node_Str"",items[position].getTaskColor());
  Time dueDate=items[position].getDueDate();
  if (dueDate != null) {
    if (mNow == null) {
      mNow=new Time();
    }
    mNow.clear(TimeZone.getDefault().getID());
    mNow.setToNow();
    row.setTextViewText(android.R.id.text1,mDueDateFormatter.format(dueDate));
    if (dueDate.before(mNow) & !items[position].getIsClosed()) {
      row.setTextColor(android.R.id.text1,mResources.getColor(android.R.color.holo_red_light));
    }
 else {
      row.setTextColor(android.R.id.text1,mResources.getColor(R.color.lighter_gray));
    }
  }
 else {
    row.setTextViewText(android.R.id.text1,null);
  }
  Uri taskUri=ContentUris.withAppendedId(Tasks.CONTENT_URI,items[position].getTaskId());
  Intent i=new Intent();
  i.setData(taskUri);
  row.setOnClickFillInIntent(android.R.id.title,i);
  return (row);
}"
52643,"/** 
 * Persist the current task (if anything has been edited) and close the editor.
 */
public void saveAndExit(){
  Activity activity=getActivity();
  int resultCode=Activity.RESULT_CANCELED;
  Intent result=null;
  int toastId=-1;
  if (mValues.isInsert() || mValues.isUpdate()) {
    if (!TextUtils.isEmpty(TaskFieldAdapters.TITLE.get(mValues)) || mValues.isUpdate()) {
      if (mValues.updatesAnyKey(RECURRENCE_VALUES)) {
        mValues.ensureUpdates(RECURRENCE_VALUES);
      }
      mTaskUri=mValues.persist(activity);
      result=new Intent();
      result.setData(mTaskUri);
      resultCode=Activity.RESULT_OK;
      toastId=R.string.activity_edit_task_task_saved;
    }
 else {
      toastId=R.string.activity_edit_task_empty_task_not_saved;
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  if (toastId != -1) {
    Toast.makeText(activity,toastId,Toast.LENGTH_SHORT).show();
  }
  if (result != null) {
    activity.setResult(resultCode,result);
  }
 else {
    activity.setResult(resultCode);
  }
  if (!mAppForEdit) {
    SharedPreferences prefs=getActivity().getPreferences(Activity.MODE_PRIVATE);
    Editor editor=prefs.edit();
    editor.putLong(PREFERENCE_LAST_LIST,mListSpinner.getSelectedItemId());
    editor.commit();
  }
  activity.finish();
}","/** 
 * Persist the current task (if anything has been edited) and close the editor.
 */
public void saveAndExit(){
  Activity activity=getActivity();
  int resultCode=Activity.RESULT_CANCELED;
  Intent result=null;
  int toastId=-1;
  if (mValues.isInsert() || mValues.isUpdate()) {
    if (!TextUtils.isEmpty(TaskFieldAdapters.TITLE.get(mValues)) || mValues.isUpdate()) {
      if (mValues.updatesAnyKey(RECURRENCE_VALUES)) {
        mValues.ensureUpdates(RECURRENCE_VALUES);
      }
      mTaskUri=mValues.persist(activity);
      result=new Intent();
      result.setData(mTaskUri);
      resultCode=Activity.RESULT_OK;
      toastId=R.string.activity_edit_task_task_saved;
    }
 else {
      toastId=R.string.activity_edit_task_empty_task_not_saved;
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  if (toastId != -1) {
    Toast.makeText(activity,toastId,Toast.LENGTH_SHORT).show();
  }
  if (result != null) {
    activity.setResult(resultCode,result);
  }
 else {
    activity.setResult(resultCode);
  }
  if (!mAppForEdit) {
    SharedPreferences prefs=getActivity().getPreferences(Activity.MODE_PRIVATE);
    Editor editor=prefs.edit();
    editor.putLong(PREFERENCE_LAST_LIST,mListSpinner.getSelectedItemId());
    editor.commit();
  }
  WidgetUtils.broadcastWidgetUpdate(mAppContext);
  activity.finish();
}"
52644,"@Override public boolean onFling(ListView v,int pos){
  long packedPos=mExpandableListView.getExpandableListPosition(pos);
  if (ExpandableListView.getPackedPositionType(packedPos) == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {
    ExpandableListAdapter listAdapter=mExpandableListView.getExpandableListAdapter();
    Cursor cursor=(Cursor)listAdapter.getChild(ExpandableListView.getPackedPositionGroup(packedPos),ExpandableListView.getPackedPositionChild(packedPos));
    if (cursor != null) {
      Long taskId=cursor.getLong(cursor.getColumnIndex(Instances.TASK_ID));
      if (taskId != null) {
        boolean closed=cursor.getLong(cursor.getColumnIndex(Instances.IS_CLOSED)) > 0;
        String title=cursor.getString(cursor.getColumnIndex(Instances.TITLE));
        Uri taskUri=ContentUris.withAppendedId(Tasks.CONTENT_URI,taskId);
        if (closed) {
          removeTask(taskUri,title);
          return false;
        }
 else {
          return completeTask(taskUri,title);
        }
      }
    }
  }
  return false;
}","@Override public boolean onFling(ListView v,int pos){
  long packedPos=mExpandableListView.getExpandableListPosition(pos);
  if (ExpandableListView.getPackedPositionType(packedPos) == ExpandableListView.PACKED_POSITION_TYPE_CHILD) {
    ExpandableListAdapter listAdapter=mExpandableListView.getExpandableListAdapter();
    Cursor cursor=(Cursor)listAdapter.getChild(ExpandableListView.getPackedPositionGroup(packedPos),ExpandableListView.getPackedPositionChild(packedPos));
    if (cursor != null) {
      Long taskId=cursor.getLong(cursor.getColumnIndex(Instances.TASK_ID));
      if (taskId != null) {
        boolean closed=cursor.getLong(cursor.getColumnIndex(Instances.IS_CLOSED)) > 0;
        String title=cursor.getString(cursor.getColumnIndex(Instances.TITLE));
        Uri taskUri=ContentUris.withAppendedId(Tasks.CONTENT_URI,taskId);
        if (closed) {
          removeTask(taskUri,title);
          WidgetUtils.broadcastWidgetUpdate(mAppContext);
          return false;
        }
 else {
          boolean result=completeTask(taskUri,title);
          if (result) {
            WidgetUtils.broadcastWidgetUpdate(mAppContext);
          }
          return result;
        }
      }
    }
  }
  return false;
}"
52645,"@SuppressWarnings(""String_Node_Str"") public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  if (android.os.Build.VERSION.SDK_INT < 11) {
    RemoteViews widget=new RemoteViews(context.getPackageName(),R.layout.task_list_widget);
    widget.removeAllViews(android.R.id.list);
    DueDateFormatter dateFormatter=new DueDateFormatter(context);
    ContentResolver resolver=context.getContentResolver();
    Cursor cursor=resolver.query(TaskContract.Instances.CONTENT_URI,null,TaskContract.Instances.VISIBLE + ""String_Node_Str"" + TaskContract.Instances.IS_CLOSED+ ""String_Node_Str""+ TaskContract.Instances.INSTANCE_START+ ""String_Node_Str""+ System.currentTimeMillis()+ ""String_Node_Str""+ TaskContract.Instances.INSTANCE_START+ ""String_Node_Str"",null,TaskContract.Instances.DEFAULT_SORT_ORDER);
    cursor.moveToFirst();
    int count=0;
    while (!cursor.isAfterLast() && count < 7) {
      RemoteViews taskItem=new RemoteViews(context.getPackageName(),R.layout.task_list_widget_item);
      int taskColor=TaskFieldAdapters.LIST_COLOR.get(cursor);
      taskItem.setInt(R.id.task_list_color,""String_Node_Str"",taskColor);
      String title=TaskFieldAdapters.TITLE.get(cursor);
      taskItem.setTextViewText(android.R.id.title,title);
      Time dueDate=TaskFieldAdapters.DUE.get(cursor);
      if (dueDate != null) {
        taskItem.setTextViewText(android.R.id.text1,dateFormatter.format(dueDate));
      }
      widget.addView(android.R.id.list,taskItem);
      cursor.moveToNext();
      count++;
    }
    cursor.close();
    Intent launchIntent=context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());
    PendingIntent launchPI=PendingIntent.getActivity(context,0,launchIntent,0);
    widget.setOnClickPendingIntent(android.R.id.list,launchPI);
    appWidgetManager.updateAppWidget(appWidgetIds,widget);
    return;
  }
  for (int i=0; i < appWidgetIds.length; i++) {
    Intent remoteServiceIntent=new Intent(context,TaskListWidgetUpdaterService.class);
    remoteServiceIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetIds[i]);
    remoteServiceIntent.setData(Uri.parse(remoteServiceIntent.toUri(Intent.URI_INTENT_SCHEME)));
    RemoteViews widget=new RemoteViews(context.getPackageName(),R.layout.task_list_widget);
    if (android.os.Build.VERSION.SDK_INT < 14) {
      widget.setRemoteAdapter(appWidgetIds[i],R.id.task_list_widget_lv,remoteServiceIntent);
    }
 else {
      widget.setRemoteAdapter(R.id.task_list_widget_lv,remoteServiceIntent);
    }
    Intent detailIntent=new Intent(Intent.ACTION_VIEW);
    PendingIntent clickPI=PendingIntent.getActivity(context,0,detailIntent,PendingIntent.FLAG_UPDATE_CURRENT);
    widget.setPendingIntentTemplate(R.id.task_list_widget_lv,clickPI);
    appWidgetManager.updateAppWidget(appWidgetIds[i],widget);
  }
  super.onUpdate(context,appWidgetManager,appWidgetIds);
}","@SuppressWarnings(""String_Node_Str"") public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  if (android.os.Build.VERSION.SDK_INT < 11) {
    RemoteViews widget=new RemoteViews(context.getPackageName(),R.layout.task_list_widget);
    widget.removeAllViews(android.R.id.list);
    DueDateFormatter dateFormatter=new DueDateFormatter(context);
    ContentResolver resolver=context.getContentResolver();
    Cursor cursor=resolver.query(TaskContract.Instances.CONTENT_URI,null,TaskContract.Instances.VISIBLE + ""String_Node_Str"" + TaskContract.Instances.IS_CLOSED+ ""String_Node_Str""+ TaskContract.Instances.INSTANCE_START+ ""String_Node_Str""+ System.currentTimeMillis()+ ""String_Node_Str""+ TaskContract.Instances.INSTANCE_START+ ""String_Node_Str"",null,TaskContract.Instances.DEFAULT_SORT_ORDER);
    cursor.moveToFirst();
    int count=0;
    while (!cursor.isAfterLast() && count < 7) {
      RemoteViews taskItem=new RemoteViews(context.getPackageName(),R.layout.task_list_widget_item);
      int taskColor=TaskFieldAdapters.LIST_COLOR.get(cursor);
      taskItem.setInt(R.id.task_list_color,""String_Node_Str"",taskColor);
      String title=TaskFieldAdapters.TITLE.get(cursor);
      taskItem.setTextViewText(android.R.id.title,title);
      Time dueDate=TaskFieldAdapters.DUE.get(cursor);
      if (dueDate != null) {
        taskItem.setTextViewText(android.R.id.text1,dateFormatter.format(dueDate));
      }
      widget.addView(android.R.id.list,taskItem);
      cursor.moveToNext();
      count++;
    }
    cursor.close();
    Intent launchIntent=context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());
    PendingIntent launchPI=PendingIntent.getActivity(context,0,launchIntent,0);
    widget.setOnClickPendingIntent(android.R.id.list,launchPI);
    appWidgetManager.updateAppWidget(appWidgetIds,widget);
    return;
  }
  for (int i=0; i < appWidgetIds.length; i++) {
    Intent remoteServiceIntent=new Intent(context,TaskListWidgetUpdaterService.class);
    remoteServiceIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetIds[i]);
    remoteServiceIntent.setData(Uri.parse(remoteServiceIntent.toUri(Intent.URI_INTENT_SCHEME)));
    RemoteViews widget=new RemoteViews(context.getPackageName(),R.layout.task_list_widget);
    if (android.os.Build.VERSION.SDK_INT < 14) {
      widget.setRemoteAdapter(appWidgetIds[i],R.id.task_list_widget_lv,remoteServiceIntent);
    }
 else {
      widget.setRemoteAdapter(R.id.task_list_widget_lv,remoteServiceIntent);
    }
    appWidgetManager.notifyAppWidgetViewDataChanged(i,R.id.task_list_widget_lv);
    Intent detailIntent=new Intent(Intent.ACTION_VIEW);
    PendingIntent clickPI=PendingIntent.getActivity(context,0,detailIntent,PendingIntent.FLAG_UPDATE_CURRENT);
    widget.setPendingIntentTemplate(R.id.task_list_widget_lv,clickPI);
    appWidgetManager.updateAppWidget(appWidgetIds[i],widget);
  }
  super.onUpdate(context,appWidgetManager,appWidgetIds);
}"
52646,"/** 
 * Animate the fling of the given   {@link View} at position <code>pos</code> and calls the onFling handler when the animation has finished.
 * @param v The  {@link View} to fling.
 * @param pos The position of the element in ListView.
 * @param velocity The velocity to use. The harder you fling the faster the animation will be.
 */
@TargetApi(14) private void animateFling(final View v,final int pos,float velocity){
  if (android.os.Build.VERSION.SDK_INT >= 14 && v != null) {
    int parentWidth=((View)v.getParent()).getWidth();
    if (parentWidth > v.getTranslationX()) {
      v.animate().alpha(0).translationX(parentWidth).setDuration((long)((parentWidth - v.getTranslationX()) / velocity)).setListener(new AnimatorListener(){
        @Override public void onAnimationStart(        Animator animation){
        }
        @Override public void onAnimationRepeat(        Animator animation){
        }
        @Override public void onAnimationEnd(        Animator animation){
          if (mListener != null) {
            if (!mListener.onFling(mListView,pos)) {
              resetView(v);
            }
          }
        }
        @Override public void onAnimationCancel(        Animator animation){
          if (mListener != null) {
            if (!mListener.onFling(mListView,pos)) {
              resetView(v);
            }
          }
        }
      }
).start();
    }
  }
 else {
    if (mListener != null) {
      if (!mListener.onFling(mListView,pos)) {
        resetView(v);
      }
    }
  }
}","/** 
 * Animate the fling of the given   {@link View} at position <code>pos</code> and calls the onFling handler when the animation has finished.
 * @param v The  {@link View} to fling.
 * @param pos The position of the element in ListView.
 * @param velocity The velocity to use. The harder you fling the faster the animation will be.
 */
@TargetApi(14) private void animateFling(final View v,final int pos,float velocity){
  if (android.os.Build.VERSION.SDK_INT >= 14 && v != null) {
    int parentWidth=((View)v.getParent()).getWidth();
    if (parentWidth > v.getTranslationX()) {
      v.animate().alpha(0).translationX(parentWidth).setDuration((long)((parentWidth - v.getTranslationX()) / velocity)).setListener(new AnimatorListener(){
        @Override public void onAnimationStart(        Animator animation){
        }
        @Override public void onAnimationRepeat(        Animator animation){
        }
        @Override public void onAnimationEnd(        Animator animation){
          if (mListener != null) {
            if (!mListener.onFling(mListView,pos)) {
              resetView(v);
            }
          }
        }
        @Override public void onAnimationCancel(        Animator animation){
          if (mListener != null) {
            if (!mListener.onFling(mListView,pos)) {
              resetView(v);
            }
          }
        }
      }
).start();
    }
 else     if (mListener != null) {
      if (!mListener.onFling(mListView,pos)) {
        resetView(v);
      }
    }
  }
 else {
    if (mListener != null) {
      if (!mListener.onFling(mListView,pos)) {
        resetView(v);
      }
    }
  }
}"
52647,"/** 
 * Create a new   {@link FlingDetector} for the given {@link ListView}.
 * @param listview The  {@link ListView}.
 */
public FlingDetector(ListView listview){
  listview.setOnTouchListener(this);
  listview.setOnScrollListener(this);
  mListView=listview;
  ViewConfiguration vc=ViewConfiguration.get(listview.getContext());
  mTouchSlop=vc.getScaledTouchSlop();
  mMinimumFlingVelocity=vc.getScaledMinimumFlingVelocity() * 24;
  if (android.os.Build.VERSION.SDK_INT == 8) {
    mMaximumFlingVelocity=vc.getScaledMaximumFlingVelocity() * 2;
  }
 else {
    mMaximumFlingVelocity=vc.getScaledMaximumFlingVelocity();
  }
}","/** 
 * Create a new   {@link FlingDetector} for the given {@link ListView}.
 * @param listview The  {@link ListView}.
 */
public FlingDetector(ListView listview){
  listview.setOnTouchListener(this);
  listview.setOnScrollListener(this);
  mListView=listview;
  ViewConfiguration vc=ViewConfiguration.get(listview.getContext());
  mTouchSlop=vc.getScaledTouchSlop();
  mMinimumFlingVelocity=vc.getScaledMinimumFlingVelocity() * 16;
  if (android.os.Build.VERSION.SDK_INT == 8) {
    mMaximumFlingVelocity=vc.getScaledMaximumFlingVelocity() * 2;
  }
 else {
    mMaximumFlingVelocity=vc.getScaledMaximumFlingVelocity();
  }
}"
52648,"@SuppressWarnings(""String_Node_Str"") public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  if (android.os.Build.VERSION.SDK_INT < 11) {
    RemoteViews widget=new RemoteViews(context.getPackageName(),R.layout.task_list_widget);
    DueDateFormatter dateFormatter=new DueDateFormatter(context);
    ContentResolver resolver=context.getContentResolver();
    Cursor cursor=resolver.query(TaskContract.Instances.CONTENT_URI,null,TaskContract.Instances.VISIBLE + ""String_Node_Str"" + TaskContract.Instances.IS_CLOSED+ ""String_Node_Str""+ TaskContract.Instances.INSTANCE_START+ ""String_Node_Str""+ System.currentTimeMillis()+ ""String_Node_Str""+ TaskContract.Instances.INSTANCE_START+ ""String_Node_Str"",null,TaskContract.Instances.DEFAULT_SORT_ORDER);
    cursor.moveToFirst();
    int count=0;
    while (!cursor.isAfterLast() && count < 7) {
      RemoteViews taskItem=new RemoteViews(context.getPackageName(),R.layout.task_list_widget_item);
      int taskColor=TaskFieldAdapters.LIST_COLOR.get(cursor);
      taskItem.setInt(R.id.task_list_color,""String_Node_Str"",taskColor);
      String title=TaskFieldAdapters.TITLE.get(cursor);
      taskItem.setTextViewText(android.R.id.title,title);
      Time dueDate=TaskFieldAdapters.DUE.get(cursor);
      if (dueDate != null) {
        taskItem.setTextViewText(android.R.id.text1,dateFormatter.format(dueDate));
      }
      widget.addView(android.R.id.list,taskItem);
      cursor.moveToNext();
      count++;
    }
    cursor.close();
    Intent launchIntent=context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());
    PendingIntent launchPI=PendingIntent.getActivity(context,0,launchIntent,0);
    widget.setOnClickPendingIntent(android.R.id.list,launchPI);
    appWidgetManager.updateAppWidget(appWidgetIds,widget);
    return;
  }
  for (int i=0; i < appWidgetIds.length; i++) {
    Intent remoteServiceIntent=new Intent(context,TaskListWidgetUpdaterService.class);
    remoteServiceIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetIds[i]);
    remoteServiceIntent.setData(Uri.parse(remoteServiceIntent.toUri(Intent.URI_INTENT_SCHEME)));
    RemoteViews widget=new RemoteViews(context.getPackageName(),R.layout.task_list_widget);
    if (android.os.Build.VERSION.SDK_INT < 14) {
      widget.setRemoteAdapter(appWidgetIds[i],R.id.task_list_widget_lv,remoteServiceIntent);
    }
 else {
      widget.setRemoteAdapter(R.id.task_list_widget_lv,remoteServiceIntent);
    }
    Intent detailIntent=new Intent(Intent.ACTION_VIEW);
    PendingIntent clickPI=PendingIntent.getActivity(context,0,detailIntent,PendingIntent.FLAG_UPDATE_CURRENT);
    widget.setPendingIntentTemplate(R.id.task_list_widget_lv,clickPI);
    appWidgetManager.updateAppWidget(appWidgetIds[i],widget);
  }
  super.onUpdate(context,appWidgetManager,appWidgetIds);
}","@SuppressWarnings(""String_Node_Str"") public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  if (android.os.Build.VERSION.SDK_INT < 11) {
    RemoteViews widget=new RemoteViews(context.getPackageName(),R.layout.task_list_widget);
    widget.removeAllViews(android.R.id.list);
    DueDateFormatter dateFormatter=new DueDateFormatter(context);
    ContentResolver resolver=context.getContentResolver();
    Cursor cursor=resolver.query(TaskContract.Instances.CONTENT_URI,null,TaskContract.Instances.VISIBLE + ""String_Node_Str"" + TaskContract.Instances.IS_CLOSED+ ""String_Node_Str""+ TaskContract.Instances.INSTANCE_START+ ""String_Node_Str""+ System.currentTimeMillis()+ ""String_Node_Str""+ TaskContract.Instances.INSTANCE_START+ ""String_Node_Str"",null,TaskContract.Instances.DEFAULT_SORT_ORDER);
    cursor.moveToFirst();
    int count=0;
    while (!cursor.isAfterLast() && count < 7) {
      RemoteViews taskItem=new RemoteViews(context.getPackageName(),R.layout.task_list_widget_item);
      int taskColor=TaskFieldAdapters.LIST_COLOR.get(cursor);
      taskItem.setInt(R.id.task_list_color,""String_Node_Str"",taskColor);
      String title=TaskFieldAdapters.TITLE.get(cursor);
      taskItem.setTextViewText(android.R.id.title,title);
      Time dueDate=TaskFieldAdapters.DUE.get(cursor);
      if (dueDate != null) {
        taskItem.setTextViewText(android.R.id.text1,dateFormatter.format(dueDate));
      }
      widget.addView(android.R.id.list,taskItem);
      cursor.moveToNext();
      count++;
    }
    cursor.close();
    Intent launchIntent=context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());
    PendingIntent launchPI=PendingIntent.getActivity(context,0,launchIntent,0);
    widget.setOnClickPendingIntent(android.R.id.list,launchPI);
    appWidgetManager.updateAppWidget(appWidgetIds,widget);
    return;
  }
  for (int i=0; i < appWidgetIds.length; i++) {
    Intent remoteServiceIntent=new Intent(context,TaskListWidgetUpdaterService.class);
    remoteServiceIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetIds[i]);
    remoteServiceIntent.setData(Uri.parse(remoteServiceIntent.toUri(Intent.URI_INTENT_SCHEME)));
    RemoteViews widget=new RemoteViews(context.getPackageName(),R.layout.task_list_widget);
    if (android.os.Build.VERSION.SDK_INT < 14) {
      widget.setRemoteAdapter(appWidgetIds[i],R.id.task_list_widget_lv,remoteServiceIntent);
    }
 else {
      widget.setRemoteAdapter(R.id.task_list_widget_lv,remoteServiceIntent);
    }
    Intent detailIntent=new Intent(Intent.ACTION_VIEW);
    PendingIntent clickPI=PendingIntent.getActivity(context,0,detailIntent,PendingIntent.FLAG_UPDATE_CURRENT);
    widget.setPendingIntentTemplate(R.id.task_list_widget_lv,clickPI);
    appWidgetManager.updateAppWidget(appWidgetIds[i],widget);
  }
  super.onUpdate(context,appWidgetManager,appWidgetIds);
}"
52649,"@Override public RemoteViews getViewAt(int position){
  RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.task_list_widget_item);
  row.setTextViewText(android.R.id.title,items[position].getTaskTitle());
  row.setInt(R.id.task_list_color,""String_Node_Str"",items[position].getTaskColor());
  Time dueDate=items[position].getDueDate();
  if (dueDate != null) {
    if (mNow == null) {
      mNow=new Time();
    }
    mNow.clear(TimeZone.getDefault().getID());
    mNow.setToNow();
    row.setTextViewText(android.R.id.text1,mDueDateFormatter.format(dueDate));
    if (dueDate.before(mNow) & !items[position].getIsClosed()) {
      row.setTextColor(android.R.id.text1,mResources.getColor(android.R.color.holo_red_light));
    }
 else {
      row.setTextColor(android.R.id.text1,mResources.getColor(R.color.lighter_gray));
    }
  }
  Uri taskUri=ContentUris.withAppendedId(Tasks.CONTENT_URI,items[position].getTaskId());
  Intent i=new Intent();
  i.setData(taskUri);
  row.setOnClickFillInIntent(android.R.id.title,i);
  return (row);
}","@Override public RemoteViews getViewAt(int position){
  RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.task_list_widget_item);
  row.setTextViewText(android.R.id.title,items[position].getTaskTitle());
  row.setInt(R.id.task_list_color,""String_Node_Str"",items[position].getTaskColor());
  Time dueDate=items[position].getDueDate();
  if (dueDate != null) {
    if (mNow == null) {
      mNow=new Time();
    }
    mNow.clear(TimeZone.getDefault().getID());
    mNow.setToNow();
    row.setTextViewText(android.R.id.text1,mDueDateFormatter.format(dueDate));
    if (dueDate.before(mNow) & !items[position].getIsClosed()) {
      row.setTextColor(android.R.id.text1,mResources.getColor(android.R.color.holo_red_light));
    }
 else {
      row.setTextColor(android.R.id.text1,mResources.getColor(R.color.lighter_gray));
    }
  }
 else {
    row.setTextViewText(android.R.id.text1,null);
  }
  Uri taskUri=ContentUris.withAppendedId(Tasks.CONTENT_URI,items[position].getTaskId());
  Intent i=new Intent();
  i.setData(taskUri);
  row.setOnClickFillInIntent(android.R.id.title,i);
  return (row);
}"
52650,"private void initNgrams(){
  for (int i=0; i < size_; i++) {
    String word=BOW + words_.get(i).word + EOW;
    if (args_.wordNgrams > 1 && !words_.get(i).word.equals(EOS)) {
      words_.get(i).subwords=computeSubWords(word,i);
    }
  }
}","private void initNgrams(){
  for (int i=0; i < size_; i++) {
    String word=BOW + words_.get(i).word + EOW;
    if (!words_.get(i).word.equals(EOS)) {
      words_.get(i).subwords=computeSubWords(word,i);
    }
  }
}"
52651,"private void initTableNegatives(long[] counts){
  IntVector vec=new IntVector(counts.length * 10);
  float z=0.0f;
  for (  long count : counts) {
    z+=(float)Math.pow(count,0.5);
  }
  for (int i=0; i < counts.length; i++) {
    float c=(float)Math.pow(counts[i],0.5);
    for (int j=0; j < c * NEGATIVE_TABLE_SIZE / z; j++) {
      vec.add(i);
    }
  }
  vec.shuffle(rng);
  negatives=vec.copyOf();
}","private void initTableNegatives(int[] counts){
  IntVector vec=new IntVector(counts.length * 10);
  float z=0.0f;
  for (  int count : counts) {
    z+=(float)Math.pow(count,0.5);
  }
  for (int i=0; i < counts.length; i++) {
    float c=(float)Math.pow(counts[i],0.5);
    for (int j=0; j < c * NEGATIVE_TABLE_SIZE / z; j++) {
      vec.add(i);
    }
  }
  vec.shuffle(rng);
  negatives=vec.copyOf();
}"
52652,"void setTargetCounts(long[] counts){
  assert(counts.length == osz_);
  if (args_.loss == Args.loss_name.ns) {
    initTableNegatives(counts);
  }
  if (args_.loss == Args.loss_name.hs) {
    buildTree(counts);
  }
}","void setTargetCounts(int[] counts){
  assert(counts.length == osz_);
  if (args_.loss == Args.loss_name.ns) {
    initTableNegatives(counts);
  }
  if (args_.loss == Args.loss_name.hs) {
    buildTree(counts);
  }
}"
52653,"/** 
 * This is used for hierarchical softmax calculation.
 */
private void buildTree(long[] counts){
  int nodeCount=2 * osz_ - 1;
  tree=new Node[nodeCount];
  for (int i=0; i < nodeCount; i++) {
    tree[i]=new Node();
    tree[i].parent=-1;
    tree[i].left=-1;
    tree[i].right=-1;
    tree[i].count=(long)1e15;
    tree[i].binary=false;
  }
  for (int i=0; i < osz_; i++) {
    tree[i].count=counts[i];
  }
  int leaf=osz_ - 1;
  int node=osz_;
  for (int i=osz_; i < nodeCount; i++) {
    int[] mini=new int[2];
    for (int j=0; j < 2; j++) {
      if (leaf >= 0 && tree[leaf].count < tree[node].count) {
        mini[j]=leaf--;
      }
 else {
        mini[j]=node++;
      }
    }
    tree[i].left=mini[0];
    tree[i].right=mini[1];
    tree[i].count=tree[mini[0]].count + tree[mini[1]].count;
    tree[mini[0]].parent=i;
    tree[mini[1]].parent=i;
    tree[mini[1]].binary=true;
  }
  for (int i=0; i < osz_; i++) {
    IntVector path=new IntVector();
    IntVector code=new IntVector();
    int j=i;
    while (tree[j].parent != -1) {
      path.add(tree[j].parent - osz_);
      code.add(tree[j].binary ? 1 : 0);
      j=tree[j].parent;
    }
    paths.add(path);
    codes.add(code);
  }
}","/** 
 * This is used for hierarchical softmax calculation.
 */
private void buildTree(int[] counts){
  int nodeCount=2 * osz_ - 1;
  tree=new Node[nodeCount];
  for (int i=0; i < nodeCount; i++) {
    tree[i]=new Node();
    tree[i].parent=-1;
    tree[i].left=-1;
    tree[i].right=-1;
    tree[i].count=(long)1e15;
    tree[i].binary=false;
  }
  for (int i=0; i < osz_; i++) {
    tree[i].count=counts[i];
  }
  int leaf=osz_ - 1;
  int node=osz_;
  for (int i=osz_; i < nodeCount; i++) {
    int[] mini=new int[2];
    for (int j=0; j < 2; j++) {
      if (leaf >= 0 && tree[leaf].count < tree[node].count) {
        mini[j]=leaf--;
      }
 else {
        mini[j]=node++;
      }
    }
    tree[i].left=mini[0];
    tree[i].right=mini[1];
    tree[i].count=tree[mini[0]].count + tree[mini[1]].count;
    tree[mini[0]].parent=i;
    tree[mini[1]].parent=i;
    tree[mini[1]].binary=true;
  }
  for (int i=0; i < osz_; i++) {
    IntVector path=new IntVector();
    IntVector code=new IntVector();
    int j=i;
    while (tree[j].parent != -1) {
      path.add(tree[j].parent - osz_);
      code.add(tree[j].binary ? 1 : 0);
      j=tree[j].parent;
    }
    paths.add(path);
    codes.add(code);
  }
}"
52654,"@Override public void run() throws IOException {
  Log.info(""String_Node_Str"",input);
  WordVectorsTrainer trainer=WordVectorsTrainer.builder().epochCount(epochCount).learningRate(learningRate).modelType(modelType).minWordCount(minWordCount).threadCount(threadCount).wordNgramOrder(wordNGrams).dimension(dimension).contextWindowSize(contextWindowSize).build();
  trainer.getEventBus().register(this);
  Log.info(""String_Node_Str"");
  FastText fastText=trainer.train(input);
  Log.info(""String_Node_Str"",output);
  fastText.saveVectors(output);
}","@Override public void run() throws IOException {
  Log.info(""String_Node_Str"",input);
  WordVectorsTrainer trainer=WordVectorsTrainer.builder().epochCount(epochCount).learningRate(learningRate).modelType(modelType).minWordCount(minWordCount).threadCount(threadCount).wordNgramOrder(wordNGrams).dimension(dimension).contextWindowSize(contextWindowSize).build();
  Log.info(""String_Node_Str"");
  trainer.getEventBus().register(this);
  FastText fastText=trainer.train(input);
  if (pb != null) {
    pb.close();
  }
  Log.info(""String_Node_Str"",output);
  fastText.saveVectors(output);
}"
52655,"@Subscribe public void trainingProgress(FastTextTrainer.Progress progress){
  Log.info(""String_Node_Str"",progress.percentProgress,progress.wordsPerSecond,progress.learningRate,progress.loss,progress.eta);
}","@Subscribe public void trainingProgress(FastTextTrainer.Progress progress){
synchronized (this) {
    if (pb == null) {
      System.setProperty(""String_Node_Str"",""String_Node_Str"");
      pb=new ProgressBar(""String_Node_Str"",progress.total,ProgressBarStyle.ASCII);
    }
  }
  pb.stepTo(progress.current);
  pb.setExtraMessage(String.format(""String_Node_Str"",progress.learningRate));
}"
52656,"private void printInfo(float progress,float loss){
  float t=stopwatch.elapsed(TimeUnit.MILLISECONDS) / 1000f;
  float wst=(float)tokenCount.get() / t;
  float lr=(float)(args_.lr * (1.0f - progress));
  int eta=(int)(t / progress * (1 - progress) / args_.thread);
  int etah=eta / 3600;
  int etam=(eta - etah * 3600) / 60;
  Progress p=new Progress(100 * progress,wst,lr,loss,String.format(""String_Node_Str"",etah,etam));
  eventBus.post(p);
}","private void printInfo(float progress,float loss){
  float t=stopwatch.elapsed(TimeUnit.MILLISECONDS) / 1000f;
  float wst=(float)tokenCount.get() / t;
  float lr=(float)(args_.lr * (1.0f - progress));
  int eta=(int)(t / progress * (1 - progress) / args_.thread);
  int etah=eta / 3600;
  int etam=(eta - etah * 3600) / 60;
  Progress p=new Progress(100 * progress,wst,lr,loss,String.format(""String_Node_Str"",etah,etam));
  p.total=args_.epoch * dictionary.ntokens();
  p.current=tokenCount.get();
  eventBus.post(p);
}"
52657,"/** 
 * Trains a model for the input with given arguments, returns a FastText instance. Input can be a text corpus, or a corpus with text and labels.
 */
public FastText train(Path input,Args args_) throws Exception {
  Dictionary dict_=Dictionary.readFromFile(input,args_);
  Matrix input_=null;
  if (args_.pretrainedVectors.length() != 0) {
  }
 else {
    input_=new Matrix(dict_.nwords() + args_.bucket,args_.dim);
    input_.uniform(1.0f / args_.dim);
  }
  Matrix output_;
  if (args_.model == Args.model_name.supervised) {
    output_=new Matrix(dict_.nlabels(),args_.dim);
  }
 else {
    output_=new Matrix(dict_.nwords(),args_.dim);
  }
  Model model_=new Model(input_,output_,args_,0);
  if (args_.model == Args.model_name.supervised) {
    model_.setTargetCounts(dict_.getCounts(Dictionary.TYPE_LABEL));
  }
 else {
    model_.setTargetCounts(dict_.getCounts(Dictionary.TYPE_WORD));
  }
  Stopwatch stopwatch=Stopwatch.createStarted();
  AtomicLong tokenCount=new AtomicLong(0);
  ExecutorService es=Executors.newFixedThreadPool(args_.thread);
  CompletionService<Model> completionService=new ExecutorCompletionService<>(es);
  long charCount=TextIO.charCount(input,StandardCharsets.UTF_8);
  Log.info(""String_Node_Str"");
  Stopwatch sw=Stopwatch.createStarted();
  for (int i=0; i < args_.thread; i++) {
    Model threadModel=new Model(model_,i);
    completionService.submit(new TrainTask(i,input,(int)(i * charCount / args_.thread),threadModel,stopwatch,dict_,args_,tokenCount));
  }
  es.shutdown();
  int c=0;
  while (c < args_.thread) {
    completionService.take().get();
    c++;
  }
  Log.info(""String_Node_Str"",sw.elapsed(TimeUnit.MILLISECONDS) / 1000d);
  return new FastText(args_,dict_,model_);
}","/** 
 * Trains a model for the input with given arguments, returns a FastText instance. Input can be a text corpus, or a corpus with text and labels.
 */
public FastText train(Path input) throws Exception {
  Dictionary dict_=Dictionary.readFromFile(input,args_);
  Matrix input_=null;
  if (args_.pretrainedVectors.length() != 0) {
  }
 else {
    input_=new Matrix(dict_.nwords() + args_.bucket,args_.dim);
    input_.uniform(1.0f / args_.dim);
  }
  Matrix output_;
  if (args_.model == Args.model_name.supervised) {
    output_=new Matrix(dict_.nlabels(),args_.dim);
  }
 else {
    output_=new Matrix(dict_.nwords(),args_.dim);
  }
  Model model_=new Model(input_,output_,args_,0);
  if (args_.model == Args.model_name.supervised) {
    model_.setTargetCounts(dict_.getCounts(Dictionary.TYPE_LABEL));
  }
 else {
    model_.setTargetCounts(dict_.getCounts(Dictionary.TYPE_WORD));
  }
  Stopwatch stopwatch=Stopwatch.createStarted();
  AtomicLong tokenCount=new AtomicLong(0);
  ExecutorService es=Executors.newFixedThreadPool(args_.thread);
  CompletionService<Model> completionService=new ExecutorCompletionService<>(es);
  long charCount=TextIO.charCount(input,StandardCharsets.UTF_8);
  Log.info(""String_Node_Str"");
  Stopwatch sw=Stopwatch.createStarted();
  for (int i=0; i < args_.thread; i++) {
    Model threadModel=new Model(model_,i);
    completionService.submit(new TrainTask(i,input,(int)(i * charCount / args_.thread),threadModel,stopwatch,dict_,args_,tokenCount));
  }
  es.shutdown();
  int c=0;
  while (c < args_.thread) {
    completionService.take().get();
    c++;
  }
  Log.info(""String_Node_Str"",sw.elapsed(TimeUnit.MILLISECONDS) / 1000d);
  return new FastText(args_,dict_,model_);
}"
52658,"public FastText train(Path corpus){
  Args.model_name m=builder.type == ModelType.SKIP_GRAM ? model_name.skipGram : model_name.cbow;
  Args args=Args.forWordVectors(m);
  args.dim=builder.dimension;
  args.wordNgrams=builder.wordNgramOrder;
  args.thread=builder.threadCount;
  args.epoch=builder.epochCount;
  args.lr=builder.learningRate;
  args.ws=builder.contextWindowSize;
  SubWordHashProvider p=builder.subWordHashProvider;
  args.subWordHashProvider=p;
  args.minn=p.getMinN();
  args.maxn=p.getMaxN();
  args.minCount=builder.minWordCount;
  FastTextTrainer trainer=new FastTextTrainer();
  trainer.getEventBus().register(this);
  try {
    return trainer.train(corpus,args);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}","public FastText train(Path corpus){
  Args.model_name m=builder.type == ModelType.SKIP_GRAM ? model_name.skipGram : model_name.cbow;
  Args args=Args.forWordVectors(m);
  args.dim=builder.dimension;
  args.wordNgrams=builder.wordNgramOrder;
  args.thread=builder.threadCount;
  args.epoch=builder.epochCount;
  args.lr=builder.learningRate;
  args.ws=builder.contextWindowSize;
  SubWordHashProvider p=builder.subWordHashProvider;
  args.subWordHashProvider=p;
  args.minn=p.getMinN();
  args.maxn=p.getMaxN();
  args.minCount=builder.minWordCount;
  FastTextTrainer trainer=new FastTextTrainer(args);
  trainer.getEventBus().register(this);
  try {
    return trainer.train(corpus);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}"
52659,"public void generateVectorModel(Path input,Path modelFile) throws Exception {
  Args argz=Args.forWordVectors(Args.model_name.skipGram);
  argz.thread=16;
  argz.epoch=10;
  argz.dim=250;
  argz.bucket=10;
  argz.minCount=10;
  argz.minn=0;
  argz.maxn=0;
  argz.subWordHashProvider=new EmbeddingHashProviders.EmptySubwordHashProvider();
  FastText fastText=new FastTextTrainer().train(input,argz);
  Log.info(""String_Node_Str"",modelFile);
  fastText.saveModel(modelFile);
}","public void generateVectorModel(Path input,Path modelFile) throws Exception {
  Args argz=Args.forWordVectors(Args.model_name.skipGram);
  argz.thread=16;
  argz.epoch=10;
  argz.dim=250;
  argz.bucket=10;
  argz.minCount=10;
  argz.minn=0;
  argz.maxn=0;
  argz.subWordHashProvider=new EmbeddingHashProviders.EmptySubwordHashProvider();
  FastText fastText=new FastTextTrainer(argz).train(input);
  Log.info(""String_Node_Str"",modelFile);
  fastText.saveModel(modelFile);
}"
52660,"public TrainerBuilder skipSpaceFrequencyonCount(int count){
  this.skipSpaceFrequency=skipSpaceFrequency;
  return this;
}","public TrainerBuilder skipSpaceFrequencyonCount(int count){
  this.skipSpaceFrequency=count;
  return this;
}"
52661,"public TrainerBuilder lowerCaseFirstLetterFrequency(int count){
  this.lowerCaseFirstLetterFrequency=lowerCaseFirstLetterFrequency;
  return this;
}","public TrainerBuilder lowerCaseFirstLetterFrequency(int count){
  this.lowerCaseFirstLetterFrequency=count;
  return this;
}"
52662,"private void extractData(Path p,Path outRoot,int resultLimit,int maxAmbigiousWordCount) throws IOException {
  List<Path> files=Files.walk(p,1).filter(s -> s.toFile().isFile()).collect(Collectors.toList());
  BatchResult result=new BatchResult();
  int i=0;
  for (  Path file : files) {
    Log.info(""String_Node_Str"",file);
    collect(result,file,maxAmbigiousWordCount,resultLimit);
    i++;
    Log.info(""String_Node_Str"",i,files.size());
    if (resultLimit > 0 && result.results.size() > resultLimit) {
      break;
    }
  }
  String s=p.toFile().getName();
  Log.info(""String_Node_Str"");
  Path out=outRoot.resolve(s + ""String_Node_Str"");
  Path amb=outRoot.resolve(s + ""String_Node_Str"");
  try (PrintWriter pwu=new PrintWriter(out.toFile(),""String_Node_Str"");PrintWriter pwa=new PrintWriter(amb.toFile(),""String_Node_Str"")){
    for (    ResultSentence sentence : result.results) {
      pwu.println(""String_Node_Str"" + sentence.sentence);
      pwa.println(""String_Node_Str"" + sentence.sentence);
      for (      AmbiguityAnalysis analysis : sentence.results) {
        List<String> forTrain=analysis.getForTrainingOutput();
        forTrain.forEach(pwu::println);
        pwa.println(analysis.token);
        for (        AnalysisDecision r : analysis.choices) {
          pwa.println(r.analysis.formatLong());
        }
      }
      pwu.println();
      pwa.println();
    }
  }
 }","private void extractData(Path p,Path outRoot,int resultLimit,int maxAmbigiousWordCount) throws IOException {
  List<Path> files=Files.walk(p,1).filter(s -> s.toFile().isFile()).collect(Collectors.toList());
  BatchResult result=new BatchResult();
  int i=0;
  for (  Path file : files) {
    Log.info(""String_Node_Str"",file);
    LinkedHashSet<String> sentences=getSentences(p);
    collect(result,sentences,maxAmbigiousWordCount,resultLimit);
    i++;
    Log.info(""String_Node_Str"",i,files.size());
    if (resultLimit > 0 && result.results.size() > resultLimit) {
      break;
    }
  }
  String s=p.toFile().getName();
  Log.info(""String_Node_Str"");
  Path out=outRoot.resolve(s + ""String_Node_Str"");
  Path amb=outRoot.resolve(s + ""String_Node_Str"");
  try (PrintWriter pwu=new PrintWriter(out.toFile(),""String_Node_Str"");PrintWriter pwa=new PrintWriter(amb.toFile(),""String_Node_Str"")){
    for (    ResultSentence sentence : result.results) {
      pwu.println(""String_Node_Str"" + sentence.sentence);
      pwa.println(""String_Node_Str"" + sentence.sentence);
      for (      AmbiguityAnalysis analysis : sentence.results) {
        List<String> forTrain=analysis.getForTrainingOutput();
        forTrain.forEach(pwu::println);
        pwa.println(analysis.token);
        for (        AnalysisDecision r : analysis.choices) {
          pwa.println(r.analysis.formatLong());
        }
      }
      pwu.println();
      pwa.println();
    }
  }
 }"
52663,"public static void main(String[] args) throws IOException {
  Path p=Paths.get(""String_Node_Str"");
  Path outRoot=Paths.get(""String_Node_Str"");
  Files.createDirectories(outRoot);
  acceptWordPredicates.add(maxAnalysisCount(10));
  acceptWordPredicates.add(hasAnalysis());
  ignoreSentencePredicates.add(contains(""String_Node_Str""));
  ignoreSentencePredicates.add(contains(""String_Node_Str""));
  ignoreSentencePredicates.add(probablyNotTurkish());
  ignoreSentencePredicates.add(tooLongSentence(25));
  new GenerateDataWithRules().extractData(p,outRoot,150000,0);
}","public static void main(String[] args) throws IOException {
  Path p=Paths.get(""String_Node_Str"");
  Path outRoot=Paths.get(""String_Node_Str"");
  Files.createDirectories(outRoot);
  acceptWordPredicates.add(maxAnalysisCount(10));
  acceptWordPredicates.add(hasAnalysis());
  ignoreSentencePredicates.add(contains(""String_Node_Str""));
  ignoreSentencePredicates.add(contains(""String_Node_Str""));
  ignoreSentencePredicates.add(probablyNotTurkish());
  ignoreSentencePredicates.add(tooLongSentence(25));
  new GenerateDataWithRules().extractHighlyAmbigiousWordSentences(p,outRoot,3,1000);
}"
52664,"private void collect(BatchResult batchResult,Path p,int maxAmbigiousWordCount,int resultLimit) throws IOException {
  LinkedHashSet<String> sentences=getSentences(p);
  List<List<String>> group=group(new ArrayList<>(sentences),5000);
  for (  List<String> strings : group) {
    List<String> normalized=new ArrayList<>();
    for (    String sentence : strings) {
      sentence=sentence.replaceAll(""String_Node_Str"",""String_Node_Str"");
      sentence=sentence.replaceAll(""String_Node_Str"",""String_Node_Str"");
      sentence=sentence.replaceAll(""String_Node_Str"",""String_Node_Str"");
      normalized.add(sentence);
    }
    LinkedHashSet<String> toProcess=new LinkedHashSet<>();
    for (    String s : normalized) {
      boolean ok=true;
      for (      Predicate<String> ignorePredicate : ignoreSentencePredicates) {
        if (ignorePredicate.test(s)) {
          ok=false;
          break;
        }
      }
      if (!ok) {
        batchResult.ignoredSentences.add(s);
      }
 else {
        toProcess.add(s);
      }
    }
    Log.info(""String_Node_Str"",batchResult.acceptedSentences.size());
    Log.info(morphology.getCache().toString());
    for (    String sentence : toProcess) {
      ResultSentence r=ruleBasedDisambiguator.disambiguate(sentence);
      if (r.ambiguousWordCount() > maxAmbigiousWordCount) {
        continue;
      }
      if (r.zeroAnalysisCount() > 0) {
        continue;
      }
      if (r.allIgnoredCount() > 0) {
        Log.warn(""String_Node_Str"",r.sentence);
        continue;
      }
      boolean sentenceOk=true;
      for (      WordAnalysis an : r.sentenceAnalysis) {
        boolean ok=true;
        for (        Predicate<WordAnalysis> predicate : acceptWordPredicates) {
          if (!predicate.test(an)) {
            ok=false;
            break;
          }
        }
        if (!ok) {
          batchResult.ignoredSentences.add(sentence);
          sentenceOk=false;
          break;
        }
      }
      if (sentenceOk) {
        batchResult.acceptedSentences.add(sentence);
        batchResult.results.add(r);
        if (resultLimit > 0 && batchResult.results.size() > resultLimit) {
          return;
        }
      }
    }
  }
}","private void collect(BatchResult batchResult,Collection<String> sentences,int maxAmbigiousWordCount,int resultLimit) throws IOException {
  List<List<String>> group=group(new ArrayList<>(sentences),5000);
  for (  List<String> strings : group) {
    LinkedHashSet<String> toProcess=getAccpetableSentences(strings);
    Log.info(""String_Node_Str"",batchResult.acceptedSentences.size());
    Log.info(morphology.getCache().toString());
    for (    String sentence : toProcess) {
      ResultSentence r=ruleBasedDisambiguator.disambiguate(sentence);
      if (r.ambiguousWordCount() > maxAmbigiousWordCount) {
        continue;
      }
      if (r.zeroAnalysisCount() > 0) {
        continue;
      }
      if (r.allIgnoredCount() > 0) {
        Log.warn(""String_Node_Str"",r.sentence);
        continue;
      }
      boolean sentenceOk=true;
      for (      WordAnalysis an : r.sentenceAnalysis) {
        boolean ok=true;
        for (        Predicate<WordAnalysis> predicate : acceptWordPredicates) {
          if (!predicate.test(an)) {
            ok=false;
            break;
          }
        }
        if (!ok) {
          batchResult.ignoredSentences.add(sentence);
          sentenceOk=false;
          break;
        }
      }
      if (sentenceOk) {
        batchResult.acceptedSentences.add(sentence);
        batchResult.results.add(r);
        if (resultLimit > 0 && batchResult.results.size() > resultLimit) {
          return;
        }
      }
    }
  }
}"
52665,"private WordAnalysis analyzeWithoutCache(Token token){
  String word=token.getText();
  String s=normalizeForAnalysis(word);
  if (s.length() == 0) {
    return WordAnalysis.EMPTY_INPUT_RESULT;
  }
  List<SingleAnalysis> result=analyzer.analyze(s);
  if (result.size() == 0) {
    result=analyzeWordsWithApostrophe(s);
  }
  if (result.size() == 0 && useUnidentifiedTokenAnalyzer) {
    result=unidentifiedTokenAnalyzer.analyze(token);
  }
  if (result.size() == 1 && result.get(0).getDictionaryItem().isUnknown()) {
    result=Collections.emptyList();
  }
  return new WordAnalysis(word,s,result);
}","private WordAnalysis analyzeWithoutCache(Token token){
  String word=token.getText();
  String s=normalizeForAnalysis(word);
  if (s.length() == 0) {
    return WordAnalysis.EMPTY_INPUT_RESULT;
  }
  List<SingleAnalysis> result=analyzer.analyze(s);
  if (result.size() == 0) {
    result=analyzeWordsWithApostrophe(s);
  }
  if (result.size() == 0 && useUnidentifiedTokenAnalyzer) {
    result=unidentifiedTokenAnalyzer.analyze(token);
  }
  if (result.size() == 0) {
    result=new ArrayList<>(1);
    result.add(SingleAnalysis.unknown(word));
  }
  return new WordAnalysis(word,s,result);
}"
52666,"ParseResult bestPath(List<WordAnalysis> sentence){
  if (sentence.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ActiveList<Hypothesis> currentList=new ActiveList<>();
  currentList.add(new Hypothesis(sentenceBegin,sentenceBegin,null,0));
  for (  WordAnalysis analysisData : sentence) {
    ActiveList<Hypothesis> nextList=new ActiveList<>();
    for (    SingleAnalysis analysis : analysisData) {
      for (      Hypothesis h : currentList) {
        SingleAnalysis[] trigram={h.prev,h.current,analysis};
        IntValueMap<String> features=extractor.extractFromTrigram(trigram);
        float trigramScore=0;
        for (        String key : features) {
          trigramScore+=(model.get(key) * features.get(key));
        }
        Hypothesis newHyp=new Hypothesis(h.current,analysis,h,h.score + trigramScore);
        nextList.add(newHyp);
      }
    }
    currentList=nextList;
  }
  for (  Hypothesis h : currentList) {
    SingleAnalysis[] trigram={h.prev,h.current,sentenceEnd};
    IntValueMap<String> features=extractor.extractFromTrigram(trigram);
    float trigramScore=0;
    for (    String key : features) {
      trigramScore+=(model.get(key) * features.get(key));
    }
    h.score+=trigramScore;
  }
  Hypothesis best=currentList.getBest();
  float bestScore=best.score;
  List<SingleAnalysis> result=Lists.newArrayList();
  while (best.previous != null) {
    result.add(best.current);
    best=best.previous;
  }
  Collections.reverse(result);
  return new ParseResult(result,bestScore);
}","ParseResult bestPath(List<WordAnalysis> sentence){
  if (sentence.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ActiveList<Hypothesis> currentList=new ActiveList<>();
  currentList.add(new Hypothesis(sentenceBegin,sentenceBegin,null,0));
  for (  WordAnalysis analysisData : sentence) {
    ActiveList<Hypothesis> nextList=new ActiveList<>();
    List<SingleAnalysis> analyses=analysisData.getAnalysisResults();
    if (analyses.size() == 0) {
      analyses.add(SingleAnalysis.unknown(analysisData.getInput()));
    }
    for (    SingleAnalysis analysis : analysisData) {
      for (      Hypothesis h : currentList) {
        SingleAnalysis[] trigram={h.prev,h.current,analysis};
        IntValueMap<String> features=extractor.extractFromTrigram(trigram);
        float trigramScore=0;
        for (        String key : features) {
          trigramScore+=(model.get(key) * features.get(key));
        }
        Hypothesis newHyp=new Hypothesis(h.current,analysis,h,h.score + trigramScore);
        nextList.add(newHyp);
      }
    }
    currentList=nextList;
  }
  for (  Hypothesis h : currentList) {
    SingleAnalysis[] trigram={h.prev,h.current,sentenceEnd};
    IntValueMap<String> features=extractor.extractFromTrigram(trigram);
    float trigramScore=0;
    for (    String key : features) {
      trigramScore+=(model.get(key) * features.get(key));
    }
    h.score+=trigramScore;
  }
  Hypothesis best=currentList.getBest();
  float bestScore=best.score;
  List<SingleAnalysis> result=Lists.newArrayList();
  while (best.previous != null) {
    result.add(best.current);
    best=best.previous;
  }
  Collections.reverse(result);
  return new ParseResult(result,bestScore);
}"
52667,"@Override public SentenceAnalysis disambiguate(String sentence,List<WordAnalysis> allAnalyses){
  ParseResult best=decoder.bestPath(allAnalyses);
  List<SentenceWordAnalysis> l=new ArrayList<>();
  for (int i=0; i < allAnalyses.size(); i++) {
    l.add(new SentenceWordAnalysis(best.bestParse.get(i),allAnalyses.get(i)));
  }
  return new SentenceAnalysis(sentence,l);
}","@Override public SentenceAnalysis disambiguate(String sentence,List<WordAnalysis> allAnalyses){
  ParseResult best=decoder.bestPath(allAnalyses);
  List<SentenceWordAnalysis> l=new ArrayList<>();
  for (int i=0; i < allAnalyses.size(); i++) {
    WordAnalysis wordAnalysis=allAnalyses.get(i);
    SingleAnalysis analysis=best.bestParse.get(i);
    l.add(new SentenceWordAnalysis(analysis,wordAnalysis));
  }
  return new SentenceAnalysis(sentence,l);
}"
52668,"private Node<T> walkToNode(String input,Consumer<Node<T>> nodeCallback){
  Node<T> node=root;
  int i=0;
  while (i < input.length()) {
    node=node.getChildNode(input.charAt(i));
    if (node == null) {
      break;
    }
    char[] fragment=node.fragment;
    boolean fail=false;
    int j;
    for (j=0; j < fragment.length && i < input.length(); j++, i++) {
      if (!fail && fragment[j] != input.charAt(i)) {
        fail=true;
      }
    }
    if (nodeCallback != null && !fail && j == fragment.length && node.hasItem()) {
      nodeCallback.accept(node);
    }
  }
  return node;
}","private Node<T> walkToNode(String input,Consumer<Node<T>> nodeCallback){
  Node<T> node=root;
  int i=0;
  while (i < input.length()) {
    node=node.getChildNode(input.charAt(i));
    if (node == null) {
      break;
    }
    char[] fragment=node.fragment;
    boolean fail=false;
    int j;
    for (j=0; j < fragment.length && i < input.length(); j++, i++) {
      if (!fail && fragment[j] != input.charAt(i)) {
        fail=true;
      }
    }
    if (nodeCallback != null) {
      if (!fail && j == fragment.length) {
        if (node.hasItem()) {
          nodeCallback.accept(node);
        }
      }
 else {
        break;
      }
    }
  }
  return node;
}"
52669,"/** 
 * Finds the last position of common chars for 2 char arrays relative to a given index.
 * @param input input char array to look in the fragment
 * @param start start index where method starts looking the input in the fragment
 * @param fragment the char array to look input array.
 * @return <pre> for input: ""foo"" fragment = ""foobar"" index = 0, returns 3 for input: ""fool"" fragment = ""foobar"" index = 0, returns 3 for input: ""fool"" fragment = ""foobar"" index = 1, returns 2 for input: ""foo"" fragment = ""obar"" index = 1, returns 2 for input: ""xyzfoo"" fragment = ""foo"" index = 3, returns 2 for input: ""xyzfoo"" fragment = ""xyz"" index = 3, returns 0 for input: ""xyz"" fragment = ""abc"" index = 0, returns 0 </pre>
 */
private static int getSplitPoint(char[] input,int start,char[] fragment){
  int fragmentIndex=0;
  while (start < input.length && fragmentIndex < fragment.length && input[start++] == fragment[fragmentIndex]) {
    fragmentIndex++;
  }
  return fragmentIndex;
}","/** 
 * Finds the last position of common chars for 2 char arrays relative to a given index.
 * @param input input char array to look in the fragment
 * @param start start index where method starts looking the input in the fragment
 * @param fragment the char array to look input array.
 * @return <pre>for input: ""foo"" fragment = ""foobar"" index = 0, returns 3 for input: ""fool"" fragment = ""foobar"" index = 0, returns 3 for input: ""fool"" fragment = ""foobar"" index = 1, returns 2 for input: ""foo"" fragment = ""obar"" index = 1, returns 2 for input: ""xyzfoo"" fragment = ""foo"" index = 3, returns 2 for input: ""xyzfoo"" fragment = ""xyz"" index = 3, returns 0 for input: ""xyz"" fragment = ""abc"" index = 0, returns 0 </pre>
 */
private static int getSplitPoint(char[] input,int start,char[] fragment){
  int fragmentIndex=0;
  while (start < input.length && fragmentIndex < fragment.length && input[start++] == fragment[fragmentIndex]) {
    fragmentIndex++;
  }
  return fragmentIndex;
}"
52670,"private Node<T> walkToNode(String input,Consumer<Node<T>> nodeCallback){
  Node<T> node=root;
  int i=0;
  while (i < input.length()) {
    node=node.getChildNode(input.charAt(i));
    if (node == null) {
      break;
    }
    char[] fragment=node.fragment;
    int j=0;
    while (j < fragment.length && i < input.length() && fragment[j++] == input.charAt(i++)) {
    }
    if (nodeCallback != null) {
      if (j == fragment.length && i <= input.length() && node.hasItem()) {
        nodeCallback.accept(node);
      }
    }
  }
  return node;
}","private Node<T> walkToNode(String input,Consumer<Node<T>> nodeCallback){
  Node<T> node=root;
  int i=0;
  while (i < input.length()) {
    node=node.getChildNode(input.charAt(i));
    if (node == null) {
      break;
    }
    char[] fragment=node.fragment;
    boolean fail=false;
    int j;
    for (j=0; j < fragment.length && i < input.length(); j++, i++) {
      if (!fail && fragment[j] != input.charAt(i)) {
        fail=true;
      }
    }
    if (nodeCallback != null && !fail && j == fragment.length && node.hasItem()) {
      nodeCallback.accept(node);
    }
  }
  return node;
}"
52671,"/** 
 * Finds the last position of common chars for 2 char arrays relative to a given index.
 * @param input input char array to look in the fragment
 * @param start start index where method starts looking the input in the fragment
 * @param fragment the char array to look input array.
 * @return for input: ""foo"" fragment = ""foobar"" index = 0, returns 3 for input: ""fool"" fragment =""foobar"" index = 0, returns 3 for input: ""fool"" fragment = ""foobar"" index = 1, returns 2 for input: ""foo"" fragment = ""obar"" index = 1, returns 2 for input: ""xyzfoo"" fragment = ""foo"" index = 3, returns 2 for input: ""xyzfoo"" fragment = ""xyz"" index = 3, returns 0 for input: ""xyz"" fragment = ""abc"" index = 0, returns 0
 */
private static int getSplitPoint(char[] input,int start,char[] fragment){
  int fragmentIndex=0;
  while (start < input.length && fragmentIndex < fragment.length && input[start++] == fragment[fragmentIndex]) {
    fragmentIndex++;
  }
  return fragmentIndex;
}","/** 
 * Finds the last position of common chars for 2 char arrays relative to a given index.
 * @param input input char array to look in the fragment
 * @param start start index where method starts looking the input in the fragment
 * @param fragment the char array to look input array.
 * @return <pre> for input: ""foo"" fragment = ""foobar"" index = 0, returns 3 for input: ""fool"" fragment = ""foobar"" index = 0, returns 3 for input: ""fool"" fragment = ""foobar"" index = 1, returns 2 for input: ""foo"" fragment = ""obar"" index = 1, returns 2 for input: ""xyzfoo"" fragment = ""foo"" index = 3, returns 2 for input: ""xyzfoo"" fragment = ""xyz"" index = 3, returns 0 for input: ""xyz"" fragment = ""abc"" index = 0, returns 0 </pre>
 */
private static int getSplitPoint(char[] input,int start,char[] fragment){
  int fragmentIndex=0;
  while (start < input.length && fragmentIndex < fragment.length && input[start++] == fragment[fragmentIndex]) {
    fragmentIndex++;
  }
  return fragmentIndex;
}"
52672,"@Test public void stemsWrongMatchTest(){
  List<Item> items=createitems(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  additems(items);
  checkitemsExist(items);
  checkitemsMatches(""String_Node_Str"",createitems(""String_Node_Str""));
  checkitemsMustNotMatch(""String_Node_Str"",createitems(""String_Node_Str"",""String_Node_Str""));
}","@Test public void stemsWrongMatchTest(){
  List<Item> items=createitems(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  additems(items);
  checkitemsExist(items);
  checkitemsMustNotMatch(""String_Node_Str"",createitems(""String_Node_Str"",""String_Node_Str""));
}"
52673,"public void removeDictionaryItem(DictionaryItem item){
  lock.writeLock().lock();
  try {
    List<StemTransition> transitions=generate(item);
    for (    StemTransition transition : transitions) {
      stemTransitionTrie.add(transition.surface,transition);
    }
    if (differentStemItems.containsKey(item)) {
      differentStemItems.removeAll(item);
    }
  }
 catch (  Exception e) {
    Log.warn(""String_Node_Str"",e.getMessage());
  }
 finally {
    lock.writeLock().unlock();
  }
}","public void removeDictionaryItem(DictionaryItem item){
  lock.writeLock().lock();
  try {
    List<StemTransition> transitions=generate(item);
    for (    StemTransition transition : transitions) {
      stemTransitionTrie.remove(transition.surface,transition);
    }
    if (differentStemItems.containsKey(item)) {
      differentStemItems.removeAll(item);
    }
  }
 catch (  Exception e) {
    Log.warn(""String_Node_Str"",e.getMessage());
  }
 finally {
    lock.writeLock().unlock();
  }
}"
52674,"private List<SingleAnalysis> tryWithoutApostrophe(String word){
  String normalized=TurkishAlphabet.INSTANCE.normalize(word);
  String pronunciation=guessPronunciation(normalized.replaceAll(""String_Node_Str"",""String_Node_Str""));
  DictionaryItem itemProp=new DictionaryItem(Turkish.capitalize(normalized),normalized,pronunciation,PrimaryPos.Noun,normalized.contains(""String_Node_Str"") ? SecondaryPos.Abbreviation : SecondaryPos.ProperNoun);
  itemProp.attributes.add(RootAttribute.Runtime);
  analyzer.getStemTransitions().addDictionaryItem(itemProp);
  List<SingleAnalysis> properResults=analyzer.analyze(normalized);
  analyzer.getStemTransitions().removeDictionaryItem(itemProp);
  return properResults;
}","private List<SingleAnalysis> tryWithoutApostrophe(String word){
  String normalized=TurkishAlphabet.INSTANCE.normalize(word);
  String pronunciation=guessPronunciation(normalized.replaceAll(""String_Node_Str"",""String_Node_Str""));
  DictionaryItem itemProp=new DictionaryItem(Turkish.capitalize(normalized),normalized,pronunciation,PrimaryPos.Noun,normalized.contains(""String_Node_Str"") ? SecondaryPos.Abbreviation : SecondaryPos.ProperNoun);
  boolean itemDoesNotExist=!lexicon.containsItem(itemProp);
  if (!itemDoesNotExist) {
    itemProp.attributes.add(RootAttribute.Runtime);
    analyzer.getStemTransitions().addDictionaryItem(itemProp);
  }
  List<SingleAnalysis> properResults=analyzer.analyze(normalized);
  if (itemDoesNotExist) {
    analyzer.getStemTransitions().removeDictionaryItem(itemProp);
  }
  return properResults;
}"
52675,"public UnidentifiedTokenAnalyzer(InterpretingAnalyzer analyzer){
  this.analyzer=analyzer;
}","public UnidentifiedTokenAnalyzer(InterpretingAnalyzer analyzer){
  this.analyzer=analyzer;
  this.lexicon=analyzer.getLexicon();
}"
52676,"private List<SingleAnalysis> tryWordWithApostrophe(String word){
  int index=word.indexOf('\'');
  if (index < 0 || index == 0 || index == word.length() - 1) {
    return Collections.emptyList();
  }
  String stem=word.substring(0,index);
  String ending=word.substring(index + 1);
  StemAndEnding se=new StemAndEnding(stem,ending);
  String stemNormalized=TurkishAlphabet.INSTANCE.normalize(se.stem).replaceAll(""String_Node_Str"",""String_Node_Str"");
  String endingNormalized=TurkishAlphabet.INSTANCE.normalize(se.ending);
  String pronunciation=guessPronunciation(stemNormalized);
  DictionaryItem itemProp=new DictionaryItem(Turkish.capitalize(stemNormalized),stemNormalized,pronunciation,PrimaryPos.Noun,SecondaryPos.ProperNoun);
  itemProp.attributes.add(RootAttribute.Runtime);
  analyzer.getStemTransitions().addDictionaryItem(itemProp);
  String toParse=stemNormalized + endingNormalized;
  List<SingleAnalysis> properResults=analyzer.analyze(toParse);
  analyzer.getStemTransitions().removeDictionaryItem(itemProp);
  return properResults;
}","private List<SingleAnalysis> tryWordWithApostrophe(String word){
  int index=word.indexOf('\'');
  if (index < 0 || index == 0 || index == word.length() - 1) {
    return Collections.emptyList();
  }
  String stem=word.substring(0,index);
  String ending=word.substring(index + 1);
  StemAndEnding se=new StemAndEnding(stem,ending);
  String stemNormalized=TurkishAlphabet.INSTANCE.normalize(se.stem).replaceAll(""String_Node_Str"",""String_Node_Str"");
  String endingNormalized=TurkishAlphabet.INSTANCE.normalize(se.ending);
  String pronunciation=guessPronunciation(stemNormalized);
  DictionaryItem itemProp=new DictionaryItem(Turkish.capitalize(stemNormalized),stemNormalized,pronunciation,PrimaryPos.Noun,SecondaryPos.ProperNoun);
  boolean itemDoesNotExist=!lexicon.containsItem(itemProp);
  if (itemDoesNotExist) {
    itemProp.attributes.add(RootAttribute.Runtime);
    analyzer.getStemTransitions().addDictionaryItem(itemProp);
  }
  String toParse=stemNormalized + endingNormalized;
  List<SingleAnalysis> properResults=analyzer.analyze(toParse);
  if (itemDoesNotExist) {
    analyzer.getStemTransitions().removeDictionaryItem(itemProp);
  }
  return properResults;
}"
52677,"@Test public void test2() throws IOException {
  TurkishMorphology morphology=TurkishMorphology.builder().addDefaultDictionaries().disableCache().build();
  morphology.analyze(""String_Node_Str"");
}","@Test public void test2(){
  TurkishMorphology morphology=TurkishMorphology.builder().addDictionaryLines(""String_Node_Str"").disableCache().build();
  Assert.assertEquals(0,morphology.analyze(""String_Node_Str"").analysisCount());
  Assert.assertEquals(1,morphology.analyze(""String_Node_Str"").analysisCount());
}"
52678,"@Test @Ignore(""String_Node_Str"") public void reduceOflazerAnalysisResult() throws IOException {
  Path inPath=DATA_PATH.resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  List<String> lines=Files.readAllLines(inPath,StandardCharsets.UTF_8);
  Log.info(""String_Node_Str"");
  LinkedHashSet<String> accepted=new LinkedHashSet<>(lines.size() / 5);
  for (  String line : lines) {
    if (line.trim().length() == 0 || line.endsWith(""String_Node_Str"")) {
      continue;
    }
    accepted.add(line.trim());
  }
  sortAndSave(DATA_PATH.resolve(""String_Node_Str"").resolve(""String_Node_Str""),new ArrayList<>(accepted));
}","@Test @Ignore(""String_Node_Str"") public void reduceOflazerAnalysisResult() throws IOException {
  Path inPath=DATA_PATH.resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  List<String> lines=Files.readAllLines(inPath,StandardCharsets.UTF_8);
  Log.info(""String_Node_Str"");
  LinkedHashSet<String> accepted=new LinkedHashSet<>(lines.size() / 5);
  for (  String line : lines) {
    if (line.trim().length() == 0 || line.endsWith(""String_Node_Str"")) {
      continue;
    }
    accepted.add(line.trim());
  }
  save(DATA_PATH.resolve(""String_Node_Str"").resolve(""String_Node_Str""),new ArrayList<>(accepted));
}"
52679,"private void connectPronounStates(){
  DictionaryItem ben=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem sen=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem o=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem biz=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem siz=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem falan=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem falanca=lexicon.getItemById(""String_Node_Str"");
  pronPers_S.addEmpty(pA1sg_S,rootIs(ben));
  pronPers_S.addEmpty(pA2sg_S,rootIs(sen));
  pronPers_S.addEmpty(pA3sg_S,rootIsAny(o,falan,falanca));
  pronPers_S.add(pA3pl_S,""String_Node_Str"",rootIs(o));
  pronPers_S.add(pA3pl_S,""String_Node_Str"",rootIsAny(falan,falanca));
  pronPers_S.addEmpty(pA1pl_S,rootIs(biz));
  pronPers_S.add(pA1pl_S,""String_Node_Str"",rootIs(biz));
  pronPers_S.addEmpty(pA2pl_S,rootIs(siz));
  pronPers_S.add(pA2pl_S,""String_Node_Str"",rootIs(siz));
  pronPers_Mod_S.addEmpty(pA1sgMod_S,rootIs(ben));
  pronPers_Mod_S.addEmpty(pA2sgMod_S,rootIs(sen));
  pA1sgMod_S.addEmpty(pPnonMod_S);
  pA2sgMod_S.addEmpty(pPnonMod_S);
  pPnonMod_S.add(pDat_ST,""String_Node_Str"");
  pA1sg_S.addEmpty(pPnon_S);
  pA1sg_S.add(pP1sg_S,""String_Node_Str"",rootIs(ben));
  pA2sg_S.addEmpty(pPnon_S);
  pA2sg_S.add(pP2sg_S,""String_Node_Str"",rootIs(sen));
  pA3sg_S.addEmpty(pPnon_S);
  pA3sg_S.add(pP3sg_S,""String_Node_Str"",rootIs(o));
  pA1pl_S.addEmpty(pPnon_S);
  pA1pl_S.add(pP1pl_S,""String_Node_Str"",rootIs(biz));
  pA2pl_S.addEmpty(pPnon_S);
  pA1pl_S.add(pP2pl_S,""String_Node_Str"",rootIs(siz));
  pA3pl_S.addEmpty(pPnon_S);
  pA3pl_S.add(pP3pl_S,""String_Node_Str"",rootIs(o));
  pronAfterRel_S.addEmpty(pA3sgRel_S);
  pronAfterRel_S.add(pA3plRel_S,""String_Node_Str"");
  pA3sgRel_S.addEmpty(pPnonRel_S);
  pA3plRel_S.addEmpty(pPnonRel_S);
  pPnonRel_S.addEmpty(pNom_ST);
  pPnonRel_S.add(pDat_ST,""String_Node_Str"");
  pPnonRel_S.add(pAcc_ST,""String_Node_Str"");
  pPnonRel_S.add(pAbl_ST,""String_Node_Str"");
  pPnonRel_S.add(pLoc_ST,""String_Node_Str"");
  pPnonRel_S.add(pIns_ST,""String_Node_Str"");
  pPnonRel_S.add(pGen_ST,""String_Node_Str"");
  DictionaryItem bu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem su=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem o_demons=lexicon.getItemById(""String_Node_Str"");
  pronDemons_S.addEmpty(pA3sg_S);
  pronDemons_S.add(pA3pl_S,""String_Node_Str"");
  DictionaryItem birbiri=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem biri=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem bazi=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem bircogu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem birkaci=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem beriki=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem cogu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem cumlesi=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem hep=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem herbiri=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem herkes=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem hicbiri=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem hepsi=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem kimi=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem kimse=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem oburku=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem oburu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem tumu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem topu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem umum=lexicon.getItemById(""String_Node_Str"");
  pronQuant_S.addEmpty(pQuantA3sg_S,rootIsNone(herkes,umum,hepsi,cumlesi,hep,tumu,birkaci,topu));
  pronQuant_S.add(pQuantA3pl_S,""String_Node_Str"",rootIsNone(hep,hepsi,birkaci,umum,cumlesi,cogu,bircogu,herbiri,tumu,hicbiri,topu,oburu));
  pronQuant_S.add(pQuantA1pl_S,""String_Node_Str"",rootIsAny(bazi));
  pronQuant_S.add(pQuantA2pl_S,""String_Node_Str"",rootIsAny(bazi));
  pronQuant_S.addEmpty(pQuantA3pl_S,rootIsAny(herkes,umum,birkaci,hepsi,cumlesi,cogu,bircogu,tumu,topu));
  pronQuant_S.addEmpty(a3sg_S,rootIs(kimse));
  pronQuant_S.add(a3pl_S,""String_Node_Str"",rootIsAny(kimse));
  pronQuant_S.addEmpty(pQuantA1pl_S,rootIsAny(biri,bazi,birbiri,birkaci,herbiri,hep,kimi,cogu,bircogu,tumu,topu,hicbiri));
  pronQuant_S.addEmpty(pQuantA2pl_S,rootIsAny(biri,bazi,birbiri,birkaci,herbiri,hep,kimi,cogu,bircogu,tumu,topu,hicbiri));
  pronQuantModified_S.addEmpty(pQuantModA3pl_S);
  pQuantModA3pl_S.add(pP3pl_S,""String_Node_Str"");
  pQuantA3sg_S.addEmpty(pP3sg_S,rootIsAny(biri,birbiri,kimi,herbiri,hicbiri,oburu,oburku,beriki).and(notHave(PhoneticAttribute.ModifiedPronoun)));
  pQuantA3sg_S.add(pP3sg_S,""String_Node_Str"",rootIsAny(biri,bazi,birbiri,herbiri,hicbiri,oburku).and(notHave(PhoneticAttribute.ModifiedPronoun)));
  pQuantA3pl_S.add(pP3pl_S,""String_Node_Str"",rootIsAny(biri,bazi,birbiri,kimi,oburku,beriki));
  pQuantA3pl_S.addEmpty(pP3pl_S,rootIsAny(hepsi,birkaci,cumlesi,cogu,tumu,topu,bircogu));
  pQuantA3pl_S.addEmpty(pPnon_S,rootIsAny(herkes,umum,oburku,beriki));
  pQuantA1pl_S.add(pP1pl_S,""String_Node_Str"");
  pQuantA2pl_S.add(pP2pl_S,""String_Node_Str"");
  DictionaryItem ne=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem nere=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem kim=lexicon.getItemById(""String_Node_Str"");
  pronQues_S.addEmpty(pQuesA3sg_S);
  pronQues_S.add(pQuesA3pl_S,""String_Node_Str"");
  pQuesA3sg_S.addEmpty(pPnon_S).add(pP3sg_S,""String_Node_Str"").add(pP1sg_S,""String_Node_Str"",rootIsNot(ne)).add(pP1sg_S,""String_Node_Str"",rootIs(ne)).add(pP2sg_S,""String_Node_Str"",rootIsNot(ne)).add(pP2sg_S,""String_Node_Str"",rootIs(ne)).add(pP1pl_S,""String_Node_Str"",rootIsNot(ne)).add(pP1pl_S,""String_Node_Str"",rootIs(ne));
  pQuesA3pl_S.addEmpty(pPnon_S).add(pP3sg_S,""String_Node_Str"").add(pP1sg_S,""String_Node_Str"").add(pP1pl_S,""String_Node_Str"");
  pronReflex_S.addEmpty(pReflexA1sg_S).addEmpty(pReflexA2sg_S).addEmpty(pReflexA3sg_S).addEmpty(pReflexA1pl_S).addEmpty(pReflexA2pl_S).addEmpty(pReflexA3pl_S);
  pReflexA1sg_S.add(pP1sg_S,""String_Node_Str"");
  pReflexA2sg_S.add(pP2sg_S,""String_Node_Str"");
  pReflexA3sg_S.add(pP3sg_S,""String_Node_Str"").addEmpty(pP3sg_S);
  pReflexA1pl_S.add(pP1pl_S,""String_Node_Str"");
  pReflexA2pl_S.add(pP2pl_S,""String_Node_Str"");
  pReflexA3pl_S.add(pP3pl_S,""String_Node_Str"");
  Condition nGroup=rootIsNone(ne,nere,falan,falanca,hep);
  Condition yGroup=rootIsAny(ne,nere,falan,falanca,hep);
  pPnon_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",rootIsNone(ben,sen,ne,nere,falan,falanca)).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",nGroup).add(pLoc_ST,""String_Node_Str"",yGroup).add(pAbl_ST,""String_Node_Str"",nGroup).add(pAbl_ST,""String_Node_Str"",yGroup).add(pGen_ST,""String_Node_Str"",nGroup.and(rootIsNone(biz))).add(pGen_ST,""String_Node_Str"",yGroup.and(rootIsNone(biz))).add(pEqu_ST,""String_Node_Str"",yGroup).add(pEqu_ST,""String_Node_Str"",nGroup).add(pIns_ST,""String_Node_Str"",yGroup).add(pIns_ST,""String_Node_Str"",nGroup).add(pIns_ST,""String_Node_Str"",nGroup.and(rootIsAny(bu,su,o))).add(pIns_ST,""String_Node_Str"",rootIs(siz));
  Condition conditionpP1sg_S=Conditions.rootIsAny(kim,ben,ne,nere);
  pP1sg_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pIns_ST,""String_Node_Str"",conditionpP1sg_S).add(pAbl_ST,""String_Node_Str"",conditionpP1sg_S).add(pGen_ST,""String_Node_Str"",conditionpP1sg_S);
  Condition conditionP2sg=Conditions.rootIsAny(kim,sen,ne,nere);
  pP2sg_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pIns_ST,""String_Node_Str"",conditionP2sg).add(pAbl_ST,""String_Node_Str"",conditionP2sg).add(pGen_ST,""String_Node_Str"",conditionP2sg);
  Condition p3sgCond=Conditions.rootIsAny(kim,ne,nere,o,bazi,biri,birbiri,herbiri,hep,kimi,hicbiri);
  pP3sg_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",p3sgCond).add(pAbl_ST,""String_Node_Str"",p3sgCond).add(pGen_ST,""String_Node_Str"",p3sgCond).add(pEqu_ST,""String_Node_Str"",p3sgCond).add(pIns_ST,""String_Node_Str"",p3sgCond);
  Condition hepCnd=Conditions.rootIsAny(kim,ne,nere,biz,siz,biri,birbiri,birkaci,herbiri,hep,kimi,cogu,bircogu,tumu,topu,bazi,hicbiri);
  pP1pl_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",hepCnd).add(pAbl_ST,""String_Node_Str"",hepCnd).add(pGen_ST,""String_Node_Str"",hepCnd).add(pEqu_ST,""String_Node_Str"",hepCnd).add(pIns_ST,""String_Node_Str"",hepCnd);
  pP2pl_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",hepCnd).add(pAbl_ST,""String_Node_Str"",hepCnd).add(pGen_ST,""String_Node_Str"",hepCnd).add(pEqu_ST,""String_Node_Str"",hepCnd).add(pIns_ST,""String_Node_Str"",hepCnd);
  Condition hepsiCnd=Conditions.rootIsAny(kim,ne,nere,o,bazi,biri,herkes,umum,birkaci,hepsi,cumlesi,cogu,bircogu,birbiri,tumu,kimi,topu);
  pP3pl_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",hepsiCnd).add(pAbl_ST,""String_Node_Str"",hepsiCnd).add(pGen_ST,""String_Node_Str"",hepsiCnd.or(Conditions.rootIsAny(sen,siz))).add(pEqu_ST,""String_Node_Str"",hepsiCnd).add(pIns_ST,""String_Node_Str"",hepsiCnd);
  pNom_ST.add(with_S,""String_Node_Str"",Conditions.rootIsAny(bu,su,o_demons,ben,sen,o,biz,siz));
  pNom_ST.add(with_S,""String_Node_Str"",Conditions.rootIsAny(nere));
  pNom_ST.add(with_S,""String_Node_Str"",Conditions.rootIsAny(ne));
  pNom_ST.add(without_S,""String_Node_Str"",Conditions.rootIsAny(nere,bu,su,o_demons,ben,sen,o,biz,siz));
  pNom_ST.add(without_S,""String_Node_Str"",Conditions.rootIsAny(ne));
  pGen_ST.add(rel_S,""String_Node_Str"",Conditions.rootIsAny(nere,bu,su,o_demons,ne,sen,o,biz,siz));
  pIns_ST.add(vWhile_S,""String_Node_Str"");
  pNom_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pDat_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pLoc_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pAbl_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pGen_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pIns_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pronZeroDeriv_S.addEmpty(pvVerbRoot_S);
}","private void connectPronounStates(){
  DictionaryItem ben=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem sen=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem o=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem biz=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem siz=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem falan=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem falanca=lexicon.getItemById(""String_Node_Str"");
  pronPers_S.addEmpty(pA1sg_S,rootIs(ben));
  pronPers_S.addEmpty(pA2sg_S,rootIs(sen));
  pronPers_S.addEmpty(pA3sg_S,rootIsAny(o,falan,falanca));
  pronPers_S.add(pA3pl_S,""String_Node_Str"",rootIs(o));
  pronPers_S.add(pA3pl_S,""String_Node_Str"",rootIsAny(falan,falanca));
  pronPers_S.addEmpty(pA1pl_S,rootIs(biz));
  pronPers_S.add(pA1pl_S,""String_Node_Str"",rootIs(biz));
  pronPers_S.addEmpty(pA2pl_S,rootIs(siz));
  pronPers_S.add(pA2pl_S,""String_Node_Str"",rootIs(siz));
  pronPers_Mod_S.addEmpty(pA1sgMod_S,rootIs(ben));
  pronPers_Mod_S.addEmpty(pA2sgMod_S,rootIs(sen));
  pA1sgMod_S.addEmpty(pPnonMod_S);
  pA2sgMod_S.addEmpty(pPnonMod_S);
  pPnonMod_S.add(pDat_ST,""String_Node_Str"");
  pA1sg_S.addEmpty(pPnon_S);
  pA1sg_S.add(pP1sg_S,""String_Node_Str"",rootIs(ben));
  pA2sg_S.addEmpty(pPnon_S);
  pA2sg_S.add(pP2sg_S,""String_Node_Str"",rootIs(sen));
  pA3sg_S.addEmpty(pPnon_S);
  pA3sg_S.add(pP3sg_S,""String_Node_Str"",rootIs(o));
  pA1pl_S.addEmpty(pPnon_S);
  pA1pl_S.add(pP1pl_S,""String_Node_Str"",rootIs(biz));
  pA2pl_S.addEmpty(pPnon_S);
  pA1pl_S.add(pP2pl_S,""String_Node_Str"",rootIs(siz));
  pA3pl_S.addEmpty(pPnon_S);
  pA3pl_S.add(pP3pl_S,""String_Node_Str"",rootIs(o));
  pronAfterRel_S.addEmpty(pA3sgRel_S);
  pronAfterRel_S.add(pA3plRel_S,""String_Node_Str"");
  pA3sgRel_S.addEmpty(pPnonRel_S);
  pA3plRel_S.addEmpty(pPnonRel_S);
  pPnonRel_S.addEmpty(pNom_ST);
  pPnonRel_S.add(pDat_ST,""String_Node_Str"");
  pPnonRel_S.add(pAcc_ST,""String_Node_Str"");
  pPnonRel_S.add(pAbl_ST,""String_Node_Str"");
  pPnonRel_S.add(pLoc_ST,""String_Node_Str"");
  pPnonRel_S.add(pIns_ST,""String_Node_Str"");
  pPnonRel_S.add(pGen_ST,""String_Node_Str"");
  DictionaryItem bu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem su=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem o_demons=lexicon.getItemById(""String_Node_Str"");
  pronDemons_S.addEmpty(pA3sg_S);
  pronDemons_S.add(pA3pl_S,""String_Node_Str"");
  DictionaryItem birbiri=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem biri=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem bazi=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem bircogu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem birkaci=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem beriki=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem cogu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem cumlesi=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem hep=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem herbiri=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem herkes=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem hicbiri=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem hepsi=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem kimi=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem kimse=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem oburku=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem oburu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem tumu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem topu=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem umum=lexicon.getItemById(""String_Node_Str"");
  pronQuant_S.addEmpty(pQuantA3sg_S,rootIsNone(herkes,umum,hepsi,cumlesi,hep,tumu,birkaci,topu));
  pronQuant_S.add(pQuantA3pl_S,""String_Node_Str"",rootIsNone(hep,hepsi,birkaci,umum,cumlesi,cogu,bircogu,herbiri,tumu,hicbiri,topu,oburu));
  pronQuant_S.add(pQuantA1pl_S,""String_Node_Str"",rootIsAny(bazi));
  pronQuant_S.add(pQuantA2pl_S,""String_Node_Str"",rootIsAny(bazi));
  pronQuant_S.addEmpty(pQuantA3pl_S,rootIsAny(herkes,umum,birkaci,hepsi,cumlesi,cogu,bircogu,tumu,topu));
  pronQuant_S.addEmpty(a3sg_S,rootIs(kimse));
  pronQuant_S.add(a3pl_S,""String_Node_Str"",rootIsAny(kimse));
  pronQuant_S.addEmpty(pQuantA1pl_S,rootIsAny(biri,bazi,birbiri,birkaci,herbiri,hep,kimi,cogu,bircogu,tumu,topu,hicbiri));
  pronQuant_S.addEmpty(pQuantA2pl_S,rootIsAny(biri,bazi,birbiri,birkaci,herbiri,hep,kimi,cogu,bircogu,tumu,topu,hicbiri));
  pronQuantModified_S.addEmpty(pQuantModA3pl_S);
  pQuantModA3pl_S.add(pP3pl_S,""String_Node_Str"");
  pQuantA3sg_S.addEmpty(pP3sg_S,rootIsAny(biri,birbiri,kimi,herbiri,hicbiri,oburu,oburku,beriki).and(notHave(PhoneticAttribute.ModifiedPronoun)));
  pQuantA3sg_S.add(pP3sg_S,""String_Node_Str"",rootIsAny(biri,bazi,kimi,birbiri,herbiri,hicbiri,oburku).and(notHave(PhoneticAttribute.ModifiedPronoun)));
  pQuantA3pl_S.add(pP3pl_S,""String_Node_Str"",rootIsAny(biri,bazi,birbiri,kimi,oburku,beriki));
  pQuantA3pl_S.addEmpty(pP3pl_S,rootIsAny(hepsi,birkaci,cumlesi,cogu,tumu,topu,bircogu));
  pQuantA3pl_S.addEmpty(pPnon_S,rootIsAny(herkes,umum,oburku,beriki));
  pQuantA1pl_S.add(pP1pl_S,""String_Node_Str"");
  pQuantA2pl_S.add(pP2pl_S,""String_Node_Str"");
  DictionaryItem ne=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem nere=lexicon.getItemById(""String_Node_Str"");
  DictionaryItem kim=lexicon.getItemById(""String_Node_Str"");
  pronQues_S.addEmpty(pQuesA3sg_S);
  pronQues_S.add(pQuesA3pl_S,""String_Node_Str"");
  pQuesA3sg_S.addEmpty(pPnon_S).add(pP3sg_S,""String_Node_Str"").add(pP1sg_S,""String_Node_Str"",rootIsNot(ne)).add(pP1sg_S,""String_Node_Str"",rootIs(ne)).add(pP2sg_S,""String_Node_Str"",rootIsNot(ne)).add(pP2sg_S,""String_Node_Str"",rootIs(ne)).add(pP1pl_S,""String_Node_Str"",rootIsNot(ne)).add(pP1pl_S,""String_Node_Str"",rootIs(ne));
  pQuesA3pl_S.addEmpty(pPnon_S).add(pP3sg_S,""String_Node_Str"").add(pP1sg_S,""String_Node_Str"").add(pP1pl_S,""String_Node_Str"");
  pronReflex_S.addEmpty(pReflexA1sg_S).addEmpty(pReflexA2sg_S).addEmpty(pReflexA3sg_S).addEmpty(pReflexA1pl_S).addEmpty(pReflexA2pl_S).addEmpty(pReflexA3pl_S);
  pReflexA1sg_S.add(pP1sg_S,""String_Node_Str"");
  pReflexA2sg_S.add(pP2sg_S,""String_Node_Str"");
  pReflexA3sg_S.add(pP3sg_S,""String_Node_Str"").addEmpty(pP3sg_S);
  pReflexA1pl_S.add(pP1pl_S,""String_Node_Str"");
  pReflexA2pl_S.add(pP2pl_S,""String_Node_Str"");
  pReflexA3pl_S.add(pP3pl_S,""String_Node_Str"");
  Condition nGroup=rootIsNone(ne,nere,falan,falanca,hep);
  Condition yGroup=rootIsAny(ne,nere,falan,falanca,hep);
  pPnon_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",rootIsNone(ben,sen,ne,nere,falan,falanca)).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",nGroup).add(pLoc_ST,""String_Node_Str"",yGroup).add(pAbl_ST,""String_Node_Str"",nGroup).add(pAbl_ST,""String_Node_Str"",yGroup).add(pGen_ST,""String_Node_Str"",nGroup.and(rootIsNone(biz))).add(pGen_ST,""String_Node_Str"",yGroup.and(rootIsNone(biz))).add(pEqu_ST,""String_Node_Str"",yGroup).add(pEqu_ST,""String_Node_Str"",nGroup).add(pIns_ST,""String_Node_Str"",yGroup).add(pIns_ST,""String_Node_Str"",nGroup).add(pIns_ST,""String_Node_Str"",nGroup.and(rootIsAny(bu,su,o))).add(pIns_ST,""String_Node_Str"",rootIs(siz));
  Condition conditionpP1sg_S=Conditions.rootIsAny(kim,ben,ne,nere);
  pP1sg_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pIns_ST,""String_Node_Str"",conditionpP1sg_S).add(pAbl_ST,""String_Node_Str"",conditionpP1sg_S).add(pGen_ST,""String_Node_Str"",conditionpP1sg_S);
  Condition conditionP2sg=Conditions.rootIsAny(kim,sen,ne,nere);
  pP2sg_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pIns_ST,""String_Node_Str"",conditionP2sg).add(pAbl_ST,""String_Node_Str"",conditionP2sg).add(pGen_ST,""String_Node_Str"",conditionP2sg);
  Condition p3sgCond=Conditions.rootIsAny(kim,ne,nere,o,bazi,biri,birbiri,herbiri,hep,kimi,hicbiri);
  pP3sg_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",p3sgCond).add(pAbl_ST,""String_Node_Str"",p3sgCond).add(pGen_ST,""String_Node_Str"",p3sgCond).add(pEqu_ST,""String_Node_Str"",p3sgCond).add(pIns_ST,""String_Node_Str"",p3sgCond);
  Condition hepCnd=Conditions.rootIsAny(kim,ne,nere,biz,siz,biri,birbiri,birkaci,herbiri,hep,kimi,cogu,bircogu,tumu,topu,bazi,hicbiri);
  pP1pl_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",hepCnd).add(pAbl_ST,""String_Node_Str"",hepCnd).add(pGen_ST,""String_Node_Str"",hepCnd).add(pEqu_ST,""String_Node_Str"",hepCnd).add(pIns_ST,""String_Node_Str"",hepCnd);
  pP2pl_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",hepCnd).add(pAbl_ST,""String_Node_Str"",hepCnd).add(pGen_ST,""String_Node_Str"",hepCnd).add(pEqu_ST,""String_Node_Str"",hepCnd).add(pIns_ST,""String_Node_Str"",hepCnd);
  Condition hepsiCnd=Conditions.rootIsAny(kim,ne,nere,o,bazi,biri,herkes,umum,birkaci,hepsi,cumlesi,cogu,bircogu,birbiri,tumu,kimi,topu);
  pP3pl_S.addEmpty(pNom_ST).add(pDat_ST,""String_Node_Str"",nGroup).add(pAcc_ST,""String_Node_Str"",nGroup).add(pDat_ST,""String_Node_Str"",yGroup).add(pAcc_ST,""String_Node_Str"",yGroup).add(pLoc_ST,""String_Node_Str"",hepsiCnd).add(pAbl_ST,""String_Node_Str"",hepsiCnd).add(pGen_ST,""String_Node_Str"",hepsiCnd.or(Conditions.rootIsAny(sen,siz))).add(pEqu_ST,""String_Node_Str"",hepsiCnd).add(pIns_ST,""String_Node_Str"",hepsiCnd);
  pNom_ST.add(with_S,""String_Node_Str"",Conditions.rootIsAny(bu,su,o_demons,ben,sen,o,biz,siz));
  pNom_ST.add(with_S,""String_Node_Str"",Conditions.rootIsAny(nere));
  pNom_ST.add(with_S,""String_Node_Str"",Conditions.rootIsAny(ne));
  pNom_ST.add(without_S,""String_Node_Str"",Conditions.rootIsAny(nere,bu,su,o_demons,ben,sen,o,biz,siz));
  pNom_ST.add(without_S,""String_Node_Str"",Conditions.rootIsAny(ne));
  pGen_ST.add(rel_S,""String_Node_Str"",Conditions.rootIsAny(nere,bu,su,o_demons,ne,sen,o,biz,siz));
  pIns_ST.add(vWhile_S,""String_Node_Str"");
  pNom_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pDat_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pLoc_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pAbl_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pGen_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pIns_ST.addEmpty(pronZeroDeriv_S,Conditions.HAS_TAIL);
  pronZeroDeriv_S.addEmpty(pvVerbRoot_S);
}"
52680,"@Test public void kimTest(){
  AnalysisTester tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
}","@Test public void kimTest(){
  AnalysisTester tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
}"
52681,"@Test public void kimiTest(){
  AnalysisTester tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectFail(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void kimiTest(){
  AnalysisTester tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectFail(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
52682,"private List<StemTransition> generateModifiedRootNodes(DictionaryItem dicItem){
  TurkishLetterSequence modifiedSeq=new TurkishLetterSequence(dicItem.pronunciation,alphabet);
  AttributeSet<PhoneticAttribute> originalAttrs=calculateAttributes(dicItem.pronunciation);
  AttributeSet<PhoneticAttribute> modifiedAttrs=originalAttrs.copy();
  for (  RootAttribute attribute : dicItem.attributes) {
switch (attribute) {
case Voicing:
      TurkicLetter last=modifiedSeq.lastLetter();
    TurkicLetter modifiedLetter=alphabet.voice(last);
  if (modifiedLetter == null) {
    throw new LexiconException(""String_Node_Str"" + dicItem);
  }
if (dicItem.lemma.endsWith(""String_Node_Str"")) {
  modifiedLetter=TurkishAlphabet.L_g;
}
modifiedSeq.changeLetter(modifiedSeq.length() - 1,modifiedLetter);
modifiedAttrs.remove(PhoneticAttribute.LastLetterVoicelessStop);
originalAttrs.add(PhoneticAttribute.ExpectsConsonant);
modifiedAttrs.add(PhoneticAttribute.ExpectsVowel);
modifiedAttrs.add(PhoneticAttribute.CannotTerminate);
break;
case Doubling:
modifiedSeq.append(modifiedSeq.lastLetter());
originalAttrs.add(PhoneticAttribute.ExpectsConsonant);
modifiedAttrs.add(PhoneticAttribute.ExpectsVowel);
modifiedAttrs.add(PhoneticAttribute.CannotTerminate);
break;
case LastVowelDrop:
if (modifiedSeq.lastLetter().isVowel()) {
modifiedSeq.delete(modifiedSeq.length() - 1);
modifiedAttrs.add(PhoneticAttribute.ExpectsConsonant);
modifiedAttrs.add(PhoneticAttribute.CannotTerminate);
}
 else {
modifiedSeq.delete(modifiedSeq.length() - 2);
if (!dicItem.primaryPos.equals(PrimaryPos.Verb)) {
originalAttrs.add(PhoneticAttribute.ExpectsConsonant);
}
modifiedAttrs.add(PhoneticAttribute.ExpectsVowel);
modifiedAttrs.add(PhoneticAttribute.CannotTerminate);
}
break;
case InverseHarmony:
originalAttrs.add(PhoneticAttribute.LastVowelFrontal);
originalAttrs.remove(PhoneticAttribute.LastVowelBack);
modifiedAttrs.add(PhoneticAttribute.LastVowelFrontal);
modifiedAttrs.remove(PhoneticAttribute.LastVowelBack);
break;
case ProgressiveVowelDrop:
modifiedSeq.delete(modifiedSeq.length() - 1);
if (modifiedSeq.hasVowel()) {
modifiedAttrs=calculateAttributes(modifiedSeq);
}
modifiedAttrs.add(PhoneticAttribute.LastVowelDropped);
break;
default :
break;
}
}
StemTransition original=new StemTransition(dicItem.root,dicItem,originalAttrs,morphotactics.getRootState(dicItem,originalAttrs));
StemTransition modified=new StemTransition(modifiedSeq.toString(),dicItem,modifiedAttrs,morphotactics.getRootState(dicItem,modifiedAttrs));
if (original.equals(modified)) {
return Collections.singletonList(original);
}
return Lists.newArrayList(original,modified);
}","private List<StemTransition> generateModifiedRootNodes(DictionaryItem dicItem){
  TurkishLetterSequence modifiedSeq=new TurkishLetterSequence(dicItem.pronunciation,alphabet);
  AttributeSet<PhoneticAttribute> originalAttrs=calculateAttributes(dicItem.pronunciation);
  AttributeSet<PhoneticAttribute> modifiedAttrs=originalAttrs.copy();
  for (  RootAttribute attribute : dicItem.attributes) {
switch (attribute) {
case Voicing:
      TurkicLetter last=modifiedSeq.lastLetter();
    TurkicLetter modifiedLetter=alphabet.voice(last);
  if (modifiedLetter == null) {
    throw new LexiconException(""String_Node_Str"" + dicItem);
  }
if (dicItem.lemma.endsWith(""String_Node_Str"")) {
  modifiedLetter=TurkishAlphabet.L_g;
}
modifiedSeq.changeLetter(modifiedSeq.length() - 1,modifiedLetter);
modifiedAttrs.remove(PhoneticAttribute.LastLetterVoicelessStop);
originalAttrs.add(PhoneticAttribute.ExpectsConsonant);
modifiedAttrs.add(PhoneticAttribute.ExpectsVowel);
modifiedAttrs.add(PhoneticAttribute.CannotTerminate);
break;
case Doubling:
modifiedSeq.append(modifiedSeq.lastLetter());
originalAttrs.add(PhoneticAttribute.ExpectsConsonant);
modifiedAttrs.add(PhoneticAttribute.ExpectsVowel);
modifiedAttrs.add(PhoneticAttribute.CannotTerminate);
break;
case LastVowelDrop:
if (modifiedSeq.lastLetter().isVowel()) {
modifiedSeq.delete(modifiedSeq.length() - 1);
modifiedAttrs.add(PhoneticAttribute.ExpectsConsonant);
modifiedAttrs.add(PhoneticAttribute.CannotTerminate);
}
 else {
modifiedSeq.delete(modifiedSeq.length() - 2);
if (!dicItem.primaryPos.equals(PrimaryPos.Verb)) {
originalAttrs.add(PhoneticAttribute.ExpectsConsonant);
}
modifiedAttrs.add(PhoneticAttribute.ExpectsVowel);
modifiedAttrs.add(PhoneticAttribute.CannotTerminate);
}
break;
case InverseHarmony:
originalAttrs.add(PhoneticAttribute.LastVowelFrontal);
originalAttrs.remove(PhoneticAttribute.LastVowelBack);
modifiedAttrs.add(PhoneticAttribute.LastVowelFrontal);
modifiedAttrs.remove(PhoneticAttribute.LastVowelBack);
break;
case ProgressiveVowelDrop:
modifiedSeq.delete(modifiedSeq.length() - 1);
if (modifiedSeq.hasVowel()) {
modifiedAttrs=calculateAttributes(modifiedSeq);
}
modifiedAttrs.add(PhoneticAttribute.LastLetterDropped);
break;
default :
break;
}
}
StemTransition original=new StemTransition(dicItem.root,dicItem,originalAttrs,morphotactics.getRootState(dicItem,originalAttrs));
StemTransition modified=new StemTransition(modifiedSeq.toString(),dicItem,modifiedAttrs,morphotactics.getRootState(dicItem,modifiedAttrs));
if (original.equals(modified)) {
return Collections.singletonList(original);
}
return Lists.newArrayList(original,modified);
}"
52683,"private List<StemTransition> handleSpecialRoots(DictionaryItem item){
  String id=item.getId();
  AttributeSet<PhoneticAttribute> originalAttrs=calculateAttributes(item.pronunciation);
  StemTransition original, modified;
  MorphemeState unmodifiedRootState=morphotactics.getRootState(item,originalAttrs);
switch (id) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
    original=new StemTransition(item.root,item,originalAttrs,unmodifiedRootState);
  String m=item.root.substring(0,item.root.length() - 1);
modified=new StemTransition(m,item,calculateAttributes(m),unmodifiedRootState);
modified.getPhoneticAttributes().add(PhoneticAttribute.ExpectsConsonant);
modified.getPhoneticAttributes().add(PhoneticAttribute.CannotTerminate);
return Lists.newArrayList(original,modified);
case ""String_Node_Str"":
case ""String_Node_Str"":
original=new StemTransition(item.root,item,originalAttrs,unmodifiedRootState);
if (item.lemma.equals(""String_Node_Str"")) {
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronPers_Mod_S);
}
 else {
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronPers_Mod_S);
}
original.getPhoneticAttributes().add(PhoneticAttribute.UnModifiedPronoun);
modified.getPhoneticAttributes().add(PhoneticAttribute.ModifiedPronoun);
return Lists.newArrayList(original,modified);
case ""String_Node_Str"":
case ""String_Node_Str"":
original=new StemTransition(item.root,item,originalAttrs,morphotactics.vDeYeRoot_S);
switch (item.lemma) {
case ""String_Node_Str"":
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.vDeYeRoot_S);
break;
default :
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.vDeYeRoot_S);
}
return Lists.newArrayList(original,modified);
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
original=new StemTransition(item.root,item,originalAttrs,morphotactics.pronQuant_S);
switch (item.lemma) {
case ""String_Node_Str"":
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronQuantModified_S);
break;
case ""String_Node_Str"":
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronQuantModified_S);
break;
case ""String_Node_Str"":
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronQuantModified_S);
break;
default :
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronQuantModified_S);
break;
}
original.getPhoneticAttributes().add(PhoneticAttribute.UnModifiedPronoun);
modified.getPhoneticAttributes().add(PhoneticAttribute.ModifiedPronoun);
return Lists.newArrayList(original,modified);
default :
throw new IllegalArgumentException(""String_Node_Str"" + item);
}
}","private List<StemTransition> handleSpecialRoots(DictionaryItem item){
  String id=item.getId();
  AttributeSet<PhoneticAttribute> originalAttrs=calculateAttributes(item.pronunciation);
  StemTransition original, modified;
  MorphemeState unmodifiedRootState=morphotactics.getRootState(item,originalAttrs);
switch (id) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
    original=new StemTransition(item.root,item,originalAttrs,unmodifiedRootState);
  String m=item.root.substring(0,item.root.length() - 1);
modified=new StemTransition(m,item,calculateAttributes(m),unmodifiedRootState);
modified.getPhoneticAttributes().add(PhoneticAttribute.ExpectsConsonant);
modified.getPhoneticAttributes().add(PhoneticAttribute.CannotTerminate);
return Lists.newArrayList(original,modified);
case ""String_Node_Str"":
case ""String_Node_Str"":
original=new StemTransition(item.root,item,originalAttrs,unmodifiedRootState);
if (item.lemma.equals(""String_Node_Str"")) {
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronPers_Mod_S);
}
 else {
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronPers_Mod_S);
}
original.getPhoneticAttributes().add(PhoneticAttribute.UnModifiedPronoun);
modified.getPhoneticAttributes().add(PhoneticAttribute.ModifiedPronoun);
return Lists.newArrayList(original,modified);
case ""String_Node_Str"":
case ""String_Node_Str"":
original=new StemTransition(item.root,item,originalAttrs,morphotactics.vDeYeRoot_S);
switch (item.lemma) {
case ""String_Node_Str"":
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.vDeYeRoot_S);
break;
default :
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.vDeYeRoot_S);
}
return Lists.newArrayList(original,modified);
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
original=new StemTransition(item.root,item,originalAttrs,morphotactics.pronQuant_S);
switch (item.lemma) {
case ""String_Node_Str"":
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronQuantModified_S);
break;
case ""String_Node_Str"":
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronQuantModified_S);
break;
case ""String_Node_Str"":
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronQuantModified_S);
break;
default :
modified=new StemTransition(""String_Node_Str"",item,calculateAttributes(""String_Node_Str""),morphotactics.pronQuantModified_S);
break;
}
original.getPhoneticAttributes().add(PhoneticAttribute.UnModifiedPronoun);
modified.getPhoneticAttributes().add(PhoneticAttribute.ModifiedPronoun);
return Lists.newArrayList(original,modified);
default :
throw new IllegalArgumentException(""String_Node_Str"" + item);
}
}"
52684,"public MorphemeState getRootState(DictionaryItem dictionaryItem,AttributeSet<PhoneticAttribute> phoneticAttributes){
  MorphemeState root=itemRootStateMap.get(dictionaryItem.id);
  if (root != null) {
    return root;
  }
  if (phoneticAttributes.contains(PhoneticAttribute.LastVowelDropped)) {
    return verbRoot_Prog_S;
  }
switch (dictionaryItem.primaryPos) {
case Noun:
    if (dictionaryItem.hasAttribute(RootAttribute.CompoundP3sgRoot)) {
      return nounCompoundRoot_S;
    }
 else {
      return noun_S;
    }
case Adjective:
case Numeral:
  return adj_ST;
case Pronoun:
switch (dictionaryItem.secondaryPos) {
case PersonalPron:
  return pronPers_S;
case DemonstrativePron:
return pronDemons_S;
case QuantitivePron:
return pronQuant_S;
case QuestionPron:
return pronQues_S;
case ReflexivePron:
return pronReflex_S;
default :
return pronQuant_S;
}
case Adverb:
return advRoot_ST;
case Conjunction:
return conjRoot_ST;
case Question:
return questionRoot_S;
case Interjection:
return interjRoot_ST;
case Verb:
return verbRoot_S;
case Punctuation:
return puncRoot_ST;
default :
return noun_S;
}
}","public MorphemeState getRootState(DictionaryItem dictionaryItem,AttributeSet<PhoneticAttribute> phoneticAttributes){
  MorphemeState root=itemRootStateMap.get(dictionaryItem.id);
  if (root != null) {
    return root;
  }
  if (phoneticAttributes.contains(PhoneticAttribute.LastLetterDropped)) {
    return verbRoot_Prog_S;
  }
switch (dictionaryItem.primaryPos) {
case Noun:
    if (dictionaryItem.hasAttribute(RootAttribute.CompoundP3sgRoot)) {
      return nounCompoundRoot_S;
    }
 else {
      return noun_S;
    }
case Adjective:
case Numeral:
  return adj_ST;
case Pronoun:
switch (dictionaryItem.secondaryPos) {
case PersonalPron:
  return pronPers_S;
case DemonstrativePron:
return pronDemons_S;
case QuantitivePron:
return pronQuant_S;
case QuestionPron:
return pronQues_S;
case ReflexivePron:
return pronReflex_S;
default :
return pronQuant_S;
}
case Adverb:
return advRoot_ST;
case Conjunction:
return conjRoot_ST;
case Question:
return questionRoot_S;
case Interjection:
return interjRoot_ST;
case Verb:
return verbRoot_S;
case Punctuation:
return puncRoot_ST;
default :
return noun_S;
}
}"
52685,"@Test public void lastVowelDropExceptionTest(){
  AnalysisTester t=getTester(""String_Node_Str"");
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectFail(""String_Node_Str"");
}","@Test public void lastVowelDropExceptionTest(){
  AnalysisTester t=getTester(""String_Node_Str"");
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectFail(""String_Node_Str"");
  t.expectFail(""String_Node_Str"");
  t=getTester(""String_Node_Str"");
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectAny(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  t.expectFail(""String_Node_Str"");
  t.expectFail(""String_Node_Str"");
}"
52686,"public _PerceptronAmbiguityResolver train(Path trainFile,Path devFile) throws IOException {
  FeatureExtractor extractor=new FeatureExtractor();
  Decoder decoder=new Decoder(averagedWeights,extractor);
  DataSet trainingSet=com.google.common.io.Files.readLines(trainFile.toFile(),Charsets.UTF_8,new DataSetLoader());
  int numExamples=0;
  for (int i=0; i < 4; i++) {
    Log.info(""String_Node_Str"" + i);
    for (    SentenceData sentence : trainingSet) {
      numExamples++;
      ParseResult result=decoder.bestPath(sentence);
      if (numExamples % 500 == 0) {
        Log.info(""String_Node_Str"",numExamples);
      }
      if (sentence.correctParse.equals(result.bestParse)) {
        continue;
      }
      IntValueMap<String> correctFeatures=extractor.extractFromSentence(sentence.correctParse);
      IntValueMap<String> bestFeatures=extractor.extractFromSentence(result.bestParse);
      updateModel(correctFeatures,bestFeatures,numExamples);
    }
    for (    String key : averagedWeights) {
      updateAverageWeights(numExamples,key);
    }
    Log.info(""String_Node_Str"");
    _PerceptronAmbiguityResolver disambiguator=new _PerceptronAmbiguityResolver(averagedWeights,extractor);
    disambiguator.test(devFile.toFile());
  }
  return new _PerceptronAmbiguityResolver(averagedWeights,extractor);
}","public _PerceptronAmbiguityResolver train(Path trainFile,Path devFile) throws IOException {
  FeatureExtractor extractor=new FeatureExtractor();
  Decoder decoder=new Decoder(averagedWeights,extractor);
  DataSet trainingSet=com.google.common.io.Files.readLines(trainFile.toFile(),Charsets.UTF_8,new DataSetLoader());
  int numExamples=0;
  for (int i=0; i < 4; i++) {
    Log.info(""String_Node_Str"" + i);
    for (    SentenceData sentence : trainingSet) {
      if (sentence.size() == 0) {
        continue;
      }
      numExamples++;
      ParseResult result=decoder.bestPath(sentence);
      if (numExamples % 500 == 0) {
        Log.info(""String_Node_Str"",numExamples);
      }
      if (sentence.correctParse.equals(result.bestParse)) {
        continue;
      }
      if (sentence.correctParse.size() != result.bestParse.size()) {
        throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + sentence.correctParse + ""String_Node_Str""+ result.bestParse);
      }
      IntValueMap<String> correctFeatures=extractor.extractFromSentence(sentence.correctParse);
      IntValueMap<String> bestFeatures=extractor.extractFromSentence(result.bestParse);
      updateModel(correctFeatures,bestFeatures,numExamples);
    }
    for (    String feat : averagedWeights) {
      int featureCount=counts.get(feat);
      float updatedWeight=(averagedWeights.get(feat) * featureCount + (numExamples - featureCount) * weights.get(feat)) / numExamples;
      averagedWeights.put(feat,updatedWeight);
      counts.put(feat,numExamples);
    }
    Log.info(""String_Node_Str"");
    _PerceptronAmbiguityResolver disambiguator=new _PerceptronAmbiguityResolver(averagedWeights,extractor);
    disambiguator.test(devFile.toFile());
  }
  return new _PerceptronAmbiguityResolver(averagedWeights,extractor);
}"
52687,"private ParseResult(LinkedList<String> bestParse,float score){
  this.bestParse=bestParse;
  this.score=score;
}","private ParseResult(List<String> bestParse,float score){
  this.bestParse=bestParse;
  this.score=score;
}"
52688,"/** 
 * Calculates the best path using Viterbi decoding.
 * @param sentence sentece with ambiguous wrods.
 * @return best parse sequence and its score.
 */
ParseResult bestPath(SentenceData sentence){
  sentence.allWordAnalyses.add(WordData.SENTENCE_END);
  Hypothesis initialHypothesis=new Hypothesis(""String_Node_Str"",""String_Node_Str"",null,0);
  ActiveList currentList=new ActiveList();
  currentList.add(initialHypothesis);
  for (  WordData wordAnalysis : sentence.allWordAnalyses) {
    ActiveList nextList=new ActiveList();
    for (    String analysis : wordAnalysis.allParses) {
      for (      Hypothesis h : currentList) {
        String[] trigram={h.prev,h.current,analysis};
        IntValueMap<String> features=extractor.extractFromTrigram(trigram);
        float trigramScore=0;
        for (        String key : features) {
          trigramScore+=(model.data.get(key) * features.get(key));
        }
        Hypothesis newHyp=new Hypothesis(h.current,analysis,h,h.score + trigramScore);
        nextList.add(newHyp);
      }
    }
    currentList=nextList;
  }
  Hypothesis best=currentList.getBest();
  LinkedList<String> result=Lists.newLinkedList();
  while (best.previous != null) {
    result.addFirst(best.current);
    best=best.previous;
  }
  result.removeLast();
  return new ParseResult(result,best.score);
}","/** 
 * Calculates the best path using Viterbi decoding.
 * @param sentence sentece with ambiguous wrods.
 * @return best parse sequence and its score.
 */
ParseResult bestPath(SentenceData sentence){
  ActiveList currentList=new ActiveList();
  currentList.add(new Hypothesis(""String_Node_Str"",""String_Node_Str"",null,0));
  for (  WordData analysisData : sentence.allWordAnalyses) {
    ActiveList nextList=new ActiveList();
    for (    String analysis : analysisData.allAnalyses) {
      for (      Hypothesis h : currentList) {
        String[] trigram={h.prev,h.current,analysis};
        IntValueMap<String> features=extractor.extractFromTrigram(trigram);
        float trigramScore=0;
        for (        String key : features) {
          trigramScore+=(model.get(key) * features.get(key));
        }
        Hypothesis newHyp=new Hypothesis(h.current,analysis,h,h.score + trigramScore);
        nextList.add(newHyp);
      }
    }
    currentList=nextList;
  }
  for (  Hypothesis h : currentList) {
    String sentenceEnd=""String_Node_Str"";
    String[] trigram={h.prev,h.current,sentenceEnd};
    IntValueMap<String> features=extractor.extractFromTrigram(trigram);
    float trigramScore=0;
    for (    String key : features) {
      trigramScore+=(model.get(key) * features.get(key));
    }
    h.score+=trigramScore;
  }
  Hypothesis best=currentList.getBest();
  float bestScore=best.score;
  List<String> result=Lists.newArrayList();
  if (best.previous == null) {
    result.add(best.current);
    return new ParseResult(result,bestScore);
  }
  while (best.previous != null) {
    result.add(best.current);
    best=best.previous;
  }
  Collections.reverse(result);
  return new ParseResult(result,bestScore);
}"
52689,"private void updateModel(IntValueMap<String> correctFeatures,IntValueMap<String> bestFeatures,int numExamples){
  Set<String> keySet=Sets.newHashSet();
  keySet.addAll(correctFeatures.getKeyList());
  keySet.addAll(bestFeatures.getKeyList());
  for (  String feat : keySet) {
    updateAverageWeights(numExamples,feat);
    weights.increment(feat,(correctFeatures.get(feat) - bestFeatures.get(feat)));
    counts.put(feat,numExamples);
    if (averagedWeights.get(feat) == 0) {
      averagedWeights.data.remove(feat);
    }
    if (weights.get(feat) == 0) {
      weights.data.remove(feat);
    }
  }
}","private void updateModel(IntValueMap<String> correctFeatures,IntValueMap<String> bestFeatures,int numExamples){
  Set<String> keySet=Sets.newHashSet();
  keySet.addAll(correctFeatures.getKeyList());
  keySet.addAll(bestFeatures.getKeyList());
  for (  String feat : keySet) {
    updateAverageWeights(numExamples,feat);
    weights.increment(feat,(correctFeatures.get(feat) - bestFeatures.get(feat)));
    counts.put(feat,numExamples);
  }
}"
52690,"WordData(String line){
  int i=0;
  for (  String s : Splitter.on(WHITE_SPACE).omitEmptyStrings().trimResults().split(line)) {
    if (i == 0) {
      this.word=s;
    }
 else {
      allParses.add(s);
    }
    if (i == 1) {
      this.correctParse=s;
    }
    i++;
  }
}","WordData(String line){
  int i=0;
  for (  String s : Splitter.on(WHITE_SPACE).omitEmptyStrings().trimResults().split(line)) {
    if (i == 0) {
      this.word=s;
    }
 else {
      allAnalyses.add(s);
    }
    if (i == 1) {
      this.correctParse=s;
    }
    i++;
  }
}"
52691,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + word + '\''+ ""String_Node_Str""+ correctParse+ '\''+ ""String_Node_Str""+ allParses+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + word + '\''+ ""String_Node_Str""+ correctParse+ '\''+ ""String_Node_Str""+ allAnalyses+ '}';
}"
52692,"SentenceData(List<WordData> allWordAnalyses){
  this.allWordAnalyses=allWordAnalyses;
  for (  WordData word : allWordAnalyses) {
    correctParse.add(word.correctParse);
  }
  for (  WordData word : allWordAnalyses) {
    allParse.add(word.allParses);
  }
}","SentenceData(List<WordData> allWordAnalyses){
  this.allWordAnalyses=allWordAnalyses;
  for (  WordData word : allWordAnalyses) {
    correctParse.add(word.correctParse);
  }
  for (  WordData word : allWordAnalyses) {
    allParse.add(word.allAnalyses);
  }
}"
52693,"/** 
 * Calculates the best path using Viterbi decoding.
 * @param sentence sentece with ambiguous wrods.
 * @param useAveragedWeights if true, average weights are used for scoring, else, normal weightsare used.
 * @return best parse sequence and its score.
 */
ParseResult bestParse(SentenceData sentence,boolean useAveragedWeights){
  sentence.allWordAnalyses.add(WordData.SENTENCE_END);
  IntValueMap<StateId> stateIds=new IntValueMap<>();
  UIntMap<State> bestPath=new UIntMap<>();
  bestPath.put(0,new State(-1,0,null));
  stateIds.put(new StateId(""String_Node_Str"",""String_Node_Str""),0);
  int bestStateNum=0;
  float bestScore=-100000;
  int n=0;
  for (  WordData word : sentence.allWordAnalyses) {
    IntValueMap<StateId> nextStates=new IntValueMap<>();
    List<String> allAnalyses=Lists.newArrayList(word.allParses);
    bestScore=-100000;
    for (    String analysis : allAnalyses) {
      for (      StateId id : stateIds) {
        int stateNum=stateIds.get(id);
        State state=bestPath.get(stateNum);
        List<String> trigram=Lists.newArrayList(id.first,id.second,analysis);
        IntValueMap<String> features=new IntValueMap<>();
        extractTrigramFeatures(trigram,features);
        float trigramScore=0;
        for (        String key : features) {
          if (useAveragedWeights) {
            trigramScore+=averagedWeights.weight(key) * features.get(key);
          }
 else {
            trigramScore+=weights.weight(key) * features.get(key);
          }
        }
        float newScore=trigramScore + state.score;
        StateId newStateId=new StateId(id.second,analysis);
        if (!nextStates.contains(newStateId)) {
          nextStates.put(newStateId,++n);
        }
        int nextStateNum=nextStates.get(newStateId);
        if (bestPath.containsKey(nextStateNum)) {
          State s=bestPath.get(nextStateNum);
          if (newScore > s.score) {
            bestPath.put(nextStateNum,new State(stateNum,newScore,analysis));
          }
        }
 else {
          bestPath.put(nextStateNum,new State(stateNum,newScore,analysis));
        }
        if (newScore > bestScore) {
          bestScore=newScore;
          bestStateNum=nextStateNum;
        }
      }
    }
    stateIds=nextStates;
  }
  LinkedList<String> best=Lists.newLinkedList();
  int stateNum=bestStateNum;
  while (stateNum > 0) {
    State s=bestPath.get(stateNum);
    best.addFirst(s.parse);
    stateNum=s.previous;
  }
  best.removeLast();
  return new ParseResult(best,bestScore);
}","/** 
 * Calculates the best path using Viterbi decoding.
 * @param sentence sentece with ambiguous wrods.
 * @param useAveragedWeights if true, average weights are used for scoring, else, normal weightsare used.
 * @return best parse sequence and its score.
 */
ParseResult bestParse(SentenceData sentence,boolean useAveragedWeights){
  sentence.allWordAnalyses.add(WordData.SENTENCE_END);
  IntValueMap<StateId> stateIds=new IntValueMap<>();
  UIntMap<State> bestPath=new UIntMap<>();
  bestPath.put(0,new State(-1,0,null));
  stateIds.put(new StateId(""String_Node_Str"",""String_Node_Str""),0);
  int bestStateNum=0;
  float bestScore=-100000;
  int n=0;
  for (  WordData word : sentence.allWordAnalyses) {
    IntValueMap<StateId> nextStates=new IntValueMap<>();
    List<String> allAnalyses=Lists.newArrayList(word.allAnalyses);
    bestScore=-100000;
    for (    String analysis : allAnalyses) {
      for (      StateId id : stateIds) {
        int stateNum=stateIds.get(id);
        State state=bestPath.get(stateNum);
        List<String> trigram=Lists.newArrayList(id.first,id.second,analysis);
        IntValueMap<String> features=new IntValueMap<>();
        extractTrigramFeatures(trigram,features);
        float trigramScore=0;
        for (        String key : features) {
          if (useAveragedWeights) {
            trigramScore+=averagedWeights.weight(key) * features.get(key);
          }
 else {
            trigramScore+=weights.weight(key) * features.get(key);
          }
        }
        float newScore=trigramScore + state.score;
        StateId newStateId=new StateId(id.second,analysis);
        if (!nextStates.contains(newStateId)) {
          nextStates.put(newStateId,++n);
        }
        int nextStateNum=nextStates.get(newStateId);
        if (bestPath.containsKey(nextStateNum)) {
          State s=bestPath.get(nextStateNum);
          if (newScore > s.score) {
            bestPath.put(nextStateNum,new State(stateNum,newScore,analysis));
          }
        }
 else {
          bestPath.put(nextStateNum,new State(stateNum,newScore,analysis));
        }
        if (newScore > bestScore) {
          bestScore=newScore;
          bestStateNum=nextStateNum;
        }
      }
    }
    stateIds=nextStates;
  }
  LinkedList<String> best=Lists.newLinkedList();
  int stateNum=bestStateNum;
  while (stateNum > 0) {
    State s=bestPath.get(stateNum);
    best.addFirst(s.parse);
    stateNum=s.previous;
  }
  best.removeLast();
  return new ParseResult(best,bestScore);
}"
52694,"public void test(File testFile) throws IOException {
  DataSet testSet=Files.readLines(testFile,Charsets.UTF_8,new DataSetLoader());
  System.out.println(""String_Node_Str"" + testSet.sentences.size());
  System.out.println(""String_Node_Str"" + testSet.tokenCount());
  int hit=0, total=0;
  Stopwatch sw=Stopwatch.createStarted();
  Random r=new Random(5);
  for (  SentenceData sentence : testSet.sentences) {
    for (    WordData word : sentence.allWordAnalyses) {
      Collections.shuffle(word.allParses,r);
    }
    Ambiguous[] seq=getAmbiguousSequence(sentence);
    int[] bestSeq=bestSequence(seq);
    int j=0;
    for (    int parseIndex : bestSeq) {
      WordData wordData=sentence.allWordAnalyses.get(j);
      if (wordData.allParses.get(parseIndex).equals(wordData.correctParse)) {
        hit++;
      }
 else {
      }
      total++;
      j++;
    }
  }
  System.out.println(""String_Node_Str"" + sw.elapsed(TimeUnit.MILLISECONDS) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + total + ""String_Node_Str""+ hit);
  System.out.println(String.format(""String_Node_Str"",(double)hit / total * 100));
  if (sw.elapsed(TimeUnit.MILLISECONDS) > 0) {
    System.out.println(""String_Node_Str"" + (1000L * total / sw.elapsed(TimeUnit.MILLISECONDS)) + ""String_Node_Str"");
  }
}","public void test(File testFile) throws IOException {
  DataSet testSet=Files.readLines(testFile,Charsets.UTF_8,new DataSetLoader());
  System.out.println(""String_Node_Str"" + testSet.sentences.size());
  System.out.println(""String_Node_Str"" + testSet.tokenCount());
  int hit=0, total=0;
  Stopwatch sw=Stopwatch.createStarted();
  Random r=new Random(5);
  for (  SentenceData sentence : testSet.sentences) {
    for (    WordData word : sentence.allWordAnalyses) {
      Collections.shuffle(word.allAnalyses,r);
    }
    Ambiguous[] seq=getAmbiguousSequence(sentence);
    int[] bestSeq=bestSequence(seq);
    int j=0;
    for (    int parseIndex : bestSeq) {
      WordData wordData=sentence.allWordAnalyses.get(j);
      if (wordData.allAnalyses.get(parseIndex).equals(wordData.correctParse)) {
        hit++;
      }
 else {
      }
      total++;
      j++;
    }
  }
  System.out.println(""String_Node_Str"" + sw.elapsed(TimeUnit.MILLISECONDS) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + total + ""String_Node_Str""+ hit);
  System.out.println(String.format(""String_Node_Str"",(double)hit / total * 100));
  if (sw.elapsed(TimeUnit.MILLISECONDS) > 0) {
    System.out.println(""String_Node_Str"" + (1000L * total / sw.elapsed(TimeUnit.MILLISECONDS)) + ""String_Node_Str"");
  }
}"
52695,"public Ambiguous[] getAmbiguousSequence(SentenceData sentence){
  Ambiguous[] awords=new Ambiguous[sentence.size() + 3];
  awords[0]=startWord;
  awords[1]=startWord;
  int i=2;
  for (  WordData word : sentence.allWordAnalyses) {
    int[] roots=new int[word.allParses.size()];
    int[][] igs=new int[word.allParses.size()][];
    int j=0;
    for (    String parseStr : word.allParses) {
      WordParse parse=new WordParse(parseStr);
      String rootPart=parse.root;
      roots[j]=rootLm.getVocabulary().indexOf(rootPart);
      if (parse.igs.size() == 0) {
        igs[j]=new int[]{-1};
      }
 else {
        igs[j]=new int[parse.igs.size()];
        for (int k=0; k < parse.igs.size(); k++) {
          igs[j][k]=igLm.getVocabulary().indexOf(parse.igs.get(k));
        }
      }
      j++;
    }
    awords[i]=new Ambiguous(roots,igs);
    i++;
  }
  awords[i]=endWord;
  return awords;
}","public Ambiguous[] getAmbiguousSequence(SentenceData sentence){
  Ambiguous[] awords=new Ambiguous[sentence.size() + 3];
  awords[0]=startWord;
  awords[1]=startWord;
  int i=2;
  for (  WordData word : sentence.allWordAnalyses) {
    int[] roots=new int[word.allAnalyses.size()];
    int[][] igs=new int[word.allAnalyses.size()][];
    int j=0;
    for (    String parseStr : word.allAnalyses) {
      WordParse parse=new WordParse(parseStr);
      String rootPart=parse.root;
      roots[j]=rootLm.getVocabulary().indexOf(rootPart);
      if (parse.igs.size() == 0) {
        igs[j]=new int[]{-1};
      }
 else {
        igs[j]=new int[parse.igs.size()];
        for (int k=0; k < parse.igs.size(); k++) {
          igs[j][k]=igLm.getVocabulary().indexOf(parse.igs.get(k));
        }
      }
      j++;
    }
    awords[i]=new Ambiguous(roots,igs);
    i++;
  }
  awords[i]=endWord;
  return awords;
}"
52696,"private void connectVerbs(){
  verb_S.addEmpty(vImp_S);
  vImp_S.addEmpty(vA2sg_ST);
  vImp_S.add(vA3sg_ST,""String_Node_Str"");
  vImp_S.add(vA3pl_ST,""String_Node_Str"");
  verb_S.add(vCausT_S,""String_Node_Str"",has(PhoneticAttribute.LastLetterVowel).or(new Conditions.LastDerivationIs(vCausTR_S)).andNot(new Conditions.LastDerivationIs(vCausT_S)));
  verb_S.add(vCausTR_S,""String_Node_Str"",has(PhoneticAttribute.LastLetterConsonant).andNot(new Conditions.LastDerivationIs(vCausTR_S)));
  vCausT_S.addEmpty(verb_S);
  vCausTR_S.addEmpty(verb_S);
  verb_Prog_S.add(vProgYor_S,""String_Node_Str"");
  vProgYor_S.add(vA1sg_ST,""String_Node_Str"");
  vProgYor_S.add(vA2sg_ST,""String_Node_Str"");
  vProgYor_S.addEmpty(vA3sg_ST);
  vProgYor_S.add(vA1pl_ST,""String_Node_Str"");
  vProgYor_S.add(vA3pl_ST,""String_Node_Str"");
}","private void connectVerbs(){
  verb_S.addEmpty(vImp_S);
  vImp_S.addEmpty(vA2sg_ST);
  vImp_S.add(vA3sg_ST,""String_Node_Str"");
  vImp_S.add(vA3pl_ST,""String_Node_Str"");
  verb_S.add(vCausT_S,""String_Node_Str"",has(PhoneticAttribute.LastLetterVowel).or(new Conditions.LastDerivationIs(vCausTR_S)).andNot(new Conditions.LastDerivationIs(vCausT_S)));
  verb_S.add(vCausTR_S,""String_Node_Str"",has(PhoneticAttribute.LastLetterConsonant).andNot(new Conditions.LastDerivationIs(vCausTR_S)));
  vCausT_S.addEmpty(verb_S);
  vCausTR_S.addEmpty(verb_S);
  verb_S.add(vProgYor_S,""String_Node_Str"",notHave(PhoneticAttribute.LastLetterVowel));
  verb_Prog_S.add(vProgYor_S,""String_Node_Str"");
  vProgYor_S.add(vA1sg_ST,""String_Node_Str"");
  vProgYor_S.add(vA2sg_ST,""String_Node_Str"");
  vProgYor_S.addEmpty(vA3sg_ST);
  vProgYor_S.add(vA1pl_ST,""String_Node_Str"");
  vProgYor_S.add(vA3pl_ST,""String_Node_Str"");
}"
52697,"@Test public void progressive1Drop(){
  AnalysisTester tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
}","@Test public void progressive1Drop(){
  AnalysisTester tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
}"
52698,"@Test public void progressive1(){
  AnalysisTester tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
}","@Test public void progressive1(){
  AnalysisTester tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester=getTester(""String_Node_Str"");
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
  tester.expectSingle(""String_Node_Str"",matchesTailLex(""String_Node_Str""));
}"
52699,"@Override public String toString(){
  return lexicalTransition.to.morpheme.id + ""String_Node_Str"" + (surface.isEmpty() ? ""String_Node_Str"" : surface);
}","@Override public String toString(){
  return lexicalTransition.to.id + ""String_Node_Str"" + (surface.isEmpty() ? ""String_Node_Str"" : surface);
}"
52700,"public boolean containsPhoneticExpectation(PhoneticExpectation expectation){
  return stemTransition.item.attributes.contains(expectation);
}","public boolean containsPhoneticExpectation(PhoneticExpectation expectation){
  return phoneticExpectations.contains(expectation);
}"
52701,"/** 
 * Turkish Nouns always have Noun-Person-Possession-Case morphemes. Even there are no suffix characters. elma -> Noun:elma - A3sg:ε - Pnon:ε - Nom:ε (Third person singular, No possession, Nominal Case)
 */
public void addNounTransitions(){
  noun_SnT.transition(a3sg_SnT).add();
  noun_SnT.transition(a3pl_SnT,""String_Node_Str"").add();
  a3sg_SnT.transition(pnon_SnT).add();
  a3sg_SnT.transition(p1sg_SnT,""String_Node_Str"").add();
  a3sg_SnT.transition(p1sg_SnT,""String_Node_Str"").addRule(mandatory(""String_Node_Str"")).add();
  a3sg_SnT.transition(p3sg_SnT,""String_Node_Str"").add();
  a3sg_SnT.transition(p3sg_SnT,""String_Node_Str"").addRule(mandatory(""String_Node_Str"")).add();
  a3pl_SnT.transition(pnon_SnT).add();
  a3pl_SnT.transition(p1sg_SnT,""String_Node_Str"").add();
  a3pl_SnT.transition(p3sg_SnT,""String_Node_Str"").add();
  pnon_SnT.transition(nom_ST).addRule(Rules.rejectIfContains(PhoneticExpectation.VowelStart)).add();
  nom_ST.transition(dim_SnT,""String_Node_Str"").addRule(rejectAny(""String_Node_Str"")).addRule(Rules.allowTailSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).add();
  nom_SnT.transition(dim_SnT,""String_Node_Str"").addRule(rejectAny(""String_Node_Str"")).addRule(Rules.allowTailSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).add();
  nom_ST.transition(dim_SnT,""String_Node_Str"").addRule(rejectAny(""String_Node_Str"")).addRule(Rules.allowTailSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).add();
  dim_SnT.transition(noun_SnT).add();
  pnon_SnT.transition(nom_SnT).addRule(Rules.allowOnly(PhoneticExpectation.VowelStart)).add();
  pnon_SnT.transition(dat_ST).surfaceTemplate(""String_Node_Str"").add();
  pnon_SnT.transition(dat_ST).addRule(Rules.allowOnly(RootAttribute.ImplicitDative)).add();
  p1sg_SnT.transition(nom_ST).add();
  p1sg_SnT.transition(dat_ST,""String_Node_Str"").add();
  p3sg_SnT.transition(nom_SnT).add();
  p3sg_SnT.transition(dat_ST,""String_Node_Str"").add();
}","/** 
 * Turkish Nouns always have Noun-Person-Possession-Case morphemes. Even there are no suffix characters. elma -> Noun:elma - A3sg:ε - Pnon:ε - Nom:ε (Third person singular, No possession, Nominal Case)
 */
public void addNounTransitions(){
  noun_SnT.transition(a3sg_SnT).add();
  noun_SnT.transition(a3pl_SnT,""String_Node_Str"").add();
  a3sg_SnT.transition(pnon_SnT).add();
  a3sg_SnT.transition(p1sg_SnT,""String_Node_Str"").add();
  a3sg_SnT.transition(p1sg_SnT,""String_Node_Str"").addRule(mandatory(""String_Node_Str"")).add();
  a3sg_SnT.transition(p3sg_SnT,""String_Node_Str"").add();
  a3sg_SnT.transition(p3sg_SnT,""String_Node_Str"").addRule(mandatory(""String_Node_Str"")).add();
  a3pl_SnT.transition(pnon_SnT).add();
  a3pl_SnT.transition(p1sg_SnT,""String_Node_Str"").add();
  a3pl_SnT.transition(p3sg_SnT,""String_Node_Str"").add();
  pnon_SnT.transition(nom_ST).addRule(Rules.rejectIfContains(PhoneticExpectation.VowelStart)).add();
  pnon_SnT.transition(nom_SnT).addRule(Rules.allowOnly(PhoneticExpectation.VowelStart)).add();
  pnon_SnT.transition(dat_ST).surfaceTemplate(""String_Node_Str"").add();
  pnon_SnT.transition(dat_ST).addRule(Rules.allowOnly(RootAttribute.ImplicitDative)).add();
  p1sg_SnT.transition(nom_ST).add();
  p1sg_SnT.transition(dat_ST,""String_Node_Str"").add();
  p3sg_SnT.transition(nom_SnT).add();
  p3sg_SnT.transition(dat_ST,""String_Node_Str"").add();
  nom_ST.transition(dim_SnT,""String_Node_Str"").addRule(rejectAny(""String_Node_Str"")).addRule(Rules.allowTailSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).add();
  nom_SnT.transition(dim_SnT,""String_Node_Str"").addRule(rejectAny(""String_Node_Str"")).addRule(Rules.allowTailSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).add();
  nom_ST.transition(dim_SnT,""String_Node_Str"").addRule(rejectAny(""String_Node_Str"")).addRule(Rules.allowTailSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).add();
  dim_SnT.transition(noun_SnT).add();
}"
52702,"@Test public void implicitDative_1(){
  List<AnalysisResult> results=getAnalyzer(""String_Node_Str"").analyze(""String_Node_Str"");
  printResults(results);
  Assert.assertEquals(2,results.size());
  AnalysisResult first=results.get(1);
  Assert.assertEquals(""String_Node_Str"",first.getDictionaryItem().id);
  Assert.assertEquals(""String_Node_Str"",first.root);
  Assert.assertTrue(containsMorpheme(first,""String_Node_Str""));
}","@Test public void implicitDative_1(){
  String in=""String_Node_Str"";
  List<AnalysisResult> results=getAnalyzer(""String_Node_Str"").analyze(in);
  printAndSort(in,results);
  Assert.assertEquals(2,results.size());
  AnalysisResult first=results.get(0);
  Assert.assertEquals(""String_Node_Str"",first.getDictionaryItem().id);
  Assert.assertEquals(""String_Node_Str"",first.root);
  Assert.assertTrue(containsMorpheme(first,""String_Node_Str""));
}"
52703,"@Test public void shouldParse_1(){
  List<AnalysisResult> results=getAnalyzer(""String_Node_Str"").analyze(""String_Node_Str"");
  printResults(results);
  Assert.assertEquals(1,results.size());
  AnalysisResult first=results.get(0);
  Assert.assertEquals(""String_Node_Str"",first.getDictionaryItem().id);
  Assert.assertEquals(""String_Node_Str"",first.root);
  Assert.assertTrue(containsMorpheme(first,""String_Node_Str""));
}","@Test public void shouldParse_1(){
  String in=""String_Node_Str"";
  List<AnalysisResult> results=getAnalyzer(""String_Node_Str"").analyze(in);
  printAndSort(in,results);
  Assert.assertEquals(1,results.size());
  AnalysisResult first=results.get(0);
  Assert.assertEquals(""String_Node_Str"",first.getDictionaryItem().id);
  Assert.assertEquals(""String_Node_Str"",first.root);
  Assert.assertTrue(containsMorpheme(first,""String_Node_Str""));
}"
52704,"/** 
 * Returns string representation of node and all child nodes until leafs.
 * @param b     string buffer to append.
 * @param level level of the operation
 */
private void toDeepString(StringBuffer b,int level){
  char[] indentChars=new char[level * 2];
  for (int i=0; i < indentChars.length; i++)   indentChars[i]=' ';
  b.append(indentChars).append(this.toString());
  b.append(""String_Node_Str"");
  if (children_ != null) {
    for (    Node subNode : this.children_.getValues()) {
      if (subNode != null) {
        subNode.toDeepString(b,level + 1);
      }
    }
  }
}","/** 
 * Returns string representation of node and all child nodes until leafs.
 * @param b     string buffer to append.
 * @param level level of the operation
 */
private void toDeepString(StringBuffer b,int level){
  char[] indentChars=new char[level * 2];
  for (int i=0; i < indentChars.length; i++)   indentChars[i]=' ';
  b.append(indentChars).append(this.toString());
  b.append(""String_Node_Str"");
  if (children != null) {
    for (    Node subNode : this.children.getValues()) {
      if (subNode != null) {
        subNode.toDeepString(b,level + 1);
      }
    }
  }
}"
52705,"public List<StemNode> getMatchingStems(String input){
  Node node=root;
  int i=0;
  List<StemNode> stems=new ArrayList<>();
  while (i < input.length()) {
    node=node.getChildNode(input.charAt(i));
    if (node == null) {
      break;
    }
    char[] fragment=node.fragment;
    int j=0;
    while (j < fragment.length && i < input.length() && fragment[j++] == input.charAt(i++))     ;
    if (i <= input.length() && node.hasStem()) {
      stems.addAll(node.stems);
    }
  }
  return stems;
}","public List<StemNode> getMatchingStems(String input){
  Node node=root;
  int i=0;
  List<StemNode> stems=new ArrayList<>();
  while (i < input.length()) {
    node=node.getChildNode(input.charAt(i));
    if (node == null) {
      break;
    }
    char[] fragment=node.fragment;
    int j=0;
    while (j < fragment.length && i < input.length() && fragment[j++] == input.charAt(i++))     ;
    if (j == fragment.length && i <= input.length() && node.hasStem()) {
      stems.addAll(node.stems);
    }
  }
  return stems;
}"
52706,"public Node getChildNode(char c){
  if (children_ == null)   return null;
  return children_.get(c);
}","public Node getChildNode(char c){
  if (children == null)   return null;
  return children.get(c);
}"
52707,"@Override public String toString(){
  String s=getFragment() + ""String_Node_Str"";
  if (children_ != null) {
    s+=""String_Node_Str"";
    for (    Node node : children_.getValues()) {
      if (node != null) {
        s+=node.getChar() + ""String_Node_Str"";
      }
    }
    s+=""String_Node_Str"";
  }
 else {
    s+=""String_Node_Str"";
  }
  if (stems != null) {
    for (    StemNode stem : stems) {
      s+=""String_Node_Str"" + stem.surfaceForm + ""String_Node_Str"";
    }
  }
  return s;
}","@Override public String toString(){
  String s=getFragment() + ""String_Node_Str"";
  if (children != null) {
    s+=""String_Node_Str"";
    for (    Node node : children.getValues()) {
      if (node != null) {
        s+=node.getChar() + ""String_Node_Str"";
      }
    }
    s+=""String_Node_Str"";
  }
 else {
    s+=""String_Node_Str"";
  }
  if (stems != null) {
    for (    StemNode stem : stems) {
      s+=""String_Node_Str"" + stem.surfaceForm + ""String_Node_Str"";
    }
  }
  return s;
}"
52708,"public void addChild(Node node){
  if (children_ == null) {
    children_=new IntMap<>(2);
  }
  children_.put(node.getChar(),node);
}","public void addChild(Node node){
  if (children == null) {
    children=new IntMap<>(2);
  }
  children.put(node.getChar(),node);
}"
52709,"private void checkNodesMatches(String prefix,List<StemNode> nodes){
  List<StemNode> stems=lt.getMatchingStems(prefix);
  for (  StemNode node : stems) {
    assertTrue(""String_Node_Str"" + node,stems.contains(node));
  }
}","private void checkNodesMatches(String prefix,List<StemNode> nodes){
  List<StemNode> stems=lt.getMatchingStems(prefix);
  for (  StemNode node : nodes) {
    assertTrue(""String_Node_Str"" + node,stems.contains(node));
  }
}"
52710,"@Test public void stemsForLongerInputs(){
  List<StemNode> nodes=createNodes(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addStemNodes(nodes);
  System.out.println(lt);
  checkNodesExist(nodes);
  checkNodesMatches(""String_Node_Str"",createNodes());
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str"",""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str"",""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","@Test public void stemsForLongerInputs(){
  List<StemNode> nodes=createNodes(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addStemNodes(nodes);
  checkNodesExist(nodes);
  checkNodesMatches(""String_Node_Str"",createNodes());
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str"",""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str"",""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  checkNodesMatches(""String_Node_Str"",createNodes(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}"
52711,"PosInfo getPosData(String posStr,String word){
  if (posStr == null) {
    return new PosInfo(inferPrimaryPos(word),inferSecondaryPos(word));
  }
 else {
    PrimaryPos primaryPos=null;
    SecondaryPos secondaryPos=null;
    for (    String s : Splitter.on(""String_Node_Str"").trimResults().split(posStr)) {
      if (PrimaryPos.converter().enumExists(s)) {
        if (primaryPos != null && !SecondaryPos.converter().enumExists(s))         throw new RuntimeException(""String_Node_Str"" + posStr);
 else         primaryPos=PrimaryPos.converter().getEnum(s);
      }
 else       if (SecondaryPos.converter().enumExists(s)) {
        if (secondaryPos != null && !PrimaryPos.converter().enumExists(s))         throw new RuntimeException(""String_Node_Str"" + posStr);
 else         secondaryPos=SecondaryPos.converter().getEnum(s);
      }
 else       throw new RuntimeException(""String_Node_Str"" + s + ""String_Node_Str""+ posStr);
    }
    if (primaryPos == null) {
      primaryPos=inferPrimaryPos(word);
    }
    if (secondaryPos == null) {
      secondaryPos=inferSecondaryPos(word);
    }
    return new PosInfo(primaryPos,secondaryPos);
  }
}","PosInfo getPosData(String posStr,String word){
  if (posStr == null) {
    return new PosInfo(inferPrimaryPos(word),inferSecondaryPos(word));
  }
 else {
    PrimaryPos primaryPos=null;
    SecondaryPos secondaryPos=null;
    List<String> tokens=Splitter.on(""String_Node_Str"").trimResults().splitToList(posStr);
    if (tokens.size() > 2) {
      throw new RuntimeException(""String_Node_Str"" + posStr);
    }
    for (    String token : tokens) {
      if (!PrimaryPos.exists(token) && !SecondaryPos.exists(token)) {
        throw new RuntimeException(""String_Node_Str"" + token + ""String_Node_Str""+ posStr);
      }
    }
    for (    String token : tokens) {
      if (PrimaryPos.exists(token)) {
        if (primaryPos == null) {
          primaryPos=PrimaryPos.converter().getEnum(token);
          continue;
        }
 else         if (!SecondaryPos.exists(token)) {
          throw new RuntimeException(""String_Node_Str"" + posStr);
        }
      }
      if (SecondaryPos.exists(token)) {
        if (secondaryPos == null) {
          secondaryPos=SecondaryPos.converter().getEnum(token);
        }
 else         if (!PrimaryPos.exists(token)) {
          throw new RuntimeException(""String_Node_Str"" + posStr);
        }
      }
    }
    if (primaryPos == null) {
      primaryPos=inferPrimaryPos(word);
    }
    if (secondaryPos == null) {
      secondaryPos=inferSecondaryPos(word);
    }
    return new PosInfo(primaryPos,secondaryPos);
  }
}"
52712,"private void removeStemNode(StemNode stemNode){
  final String surfaceForm=stemNode.surfaceForm;
  if (multiStems.containsKey(surfaceForm)) {
    multiStems.remove(surfaceForm,stemNode);
  }
 else   if (singleStems.containsKey(surfaceForm) && singleStems.get(surfaceForm).equals(stemNode)) {
    singleStems.remove(surfaceForm);
  }
  stemNodes.remove(stemNode);
}","private void removeStemNode(StemNode stemNode){
  final String surfaceForm=stemNode.surfaceForm;
  if (multiStems.containsKey(surfaceForm)) {
    multiStems.remove(surfaceForm,stemNode);
  }
 else   if (singleStems.containsKey(surfaceForm) && singleStems.get(surfaceForm).getDictionaryItem().equals(stemNode.dictionaryItem)) {
    singleStems.remove(surfaceForm);
  }
  stemNodes.remove(stemNode);
}"
52713,"public void run(TurkishWordParserGenerator parser) throws IOException {
  String input;
  System.out.println(""String_Node_Str"");
  Scanner sc=new Scanner(System.in);
  input=sc.nextLine();
  while (!input.equals(""String_Node_Str"") && !input.equals(""String_Node_Str"")) {
    List<MorphParse> tokens=parser.parse(input);
    if (tokens.size() == 0) {
      System.out.println(""String_Node_Str"");
      if (parser.getParser() instanceof WordParser) {
        ((WordParser)parser.getParser()).dump(input);
      }
    }
 else {
      tokens.forEach(this::printMorphParse);
    }
    input=sc.nextLine();
  }
}","public void run(TurkishWordParserGenerator parser) throws IOException {
  String input;
  System.out.println(""String_Node_Str"");
  Scanner sc=new Scanner(System.in);
  input=sc.nextLine();
  while (!input.equals(""String_Node_Str"") && !input.equals(""String_Node_Str"")) {
    List<MorphParse> tokens=parser.parse(input);
    if (tokens.size() == 0 || (tokens.size() == 1 && tokens.get(0).dictionaryItem.primaryPos == PrimaryPos.Unknown)) {
      System.out.println(""String_Node_Str"");
      if (parser.getParser() instanceof WordParser) {
        ((WordParser)parser.getParser()).dump(input);
      }
    }
 else {
      tokens.forEach(this::printMorphParse);
    }
    input=sc.nextLine();
  }
}"
52714,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  SuffixForm that=(SuffixForm)o;
  if (index != that.index)   return false;
  if (!id.equals(that.id))   return false;
  if (!generation.equals(that.generation))   return false;
  if (!suffix.equals(that.suffix))   return false;
  if (!connections.equals(that.connections))   return false;
  if (!indirectConnections.equals(that.indirectConnections))   return false;
  if (terminationType != that.terminationType)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  SuffixForm that=(SuffixForm)o;
  if (index != that.index)   return false;
  if (!id.equals(that.id))   return false;
  if (!generation.equals(that.generation))   return false;
  if (!suffix.equals(that.suffix))   return false;
  if (terminationType != that.terminationType)   return false;
  if (!connections.equals(that.connections))   return false;
  if (!indirectConnections.equals(that.indirectConnections))   return false;
  return true;
}"
52715,"private void removeStemNode(StemNode stemNode){
  final String surfaceForm=stemNode.surfaceForm;
  if (multiStems.containsKey(surfaceForm)) {
    multiStems.remove(surfaceForm,stemNode);
  }
 else   if (singeStems.containsKey(surfaceForm)) {
    singeStems.remove(surfaceForm);
  }
  stemNodes.remove(stemNode);
}","private void removeStemNode(StemNode stemNode){
  final String surfaceForm=stemNode.surfaceForm;
  if (multiStems.containsKey(surfaceForm)) {
    multiStems.remove(surfaceForm,stemNode);
  }
 else   if (singleStems.containsKey(surfaceForm)) {
    singleStems.remove(surfaceForm);
  }
  stemNodes.remove(stemNode);
}"
52716,"public List<StemNode> getMatchingStemNodes(String stem){
  if (singeStems.containsKey(stem)) {
    return Lists.newArrayList(singeStems.get(stem));
  }
 else   if (multiStems.containsKey(stem)) {
    return Lists.newArrayList(multiStems.get(stem));
  }
 else   return Collections.emptyList();
}","public List<StemNode> getMatchingStemNodes(String stem){
  if (singleStems.containsKey(stem)) {
    return Lists.newArrayList(singleStems.get(stem));
  }
 else   if (multiStems.containsKey(stem)) {
    return Lists.newArrayList(multiStems.get(stem));
  }
 else   return Collections.emptyList();
}"
52717,"private void addStemNode(StemNode stemNode){
  final String surfaceForm=stemNode.surfaceForm;
  if (multiStems.containsKey(surfaceForm)) {
    multiStems.put(surfaceForm,stemNode);
  }
 else   if (singeStems.containsKey(surfaceForm)) {
    multiStems.put(surfaceForm,singeStems.get(surfaceForm));
    singeStems.remove(surfaceForm);
    multiStems.put(surfaceForm,stemNode);
  }
 else {
    singeStems.put(surfaceForm,stemNode);
  }
  stemNodes.add(stemNode);
}","private void addStemNode(StemNode stemNode){
  final String surfaceForm=stemNode.surfaceForm;
  if (multiStems.containsKey(surfaceForm)) {
    multiStems.put(surfaceForm,stemNode);
  }
 else   if (singleStems.containsKey(surfaceForm)) {
    multiStems.put(surfaceForm,singleStems.get(surfaceForm));
    singleStems.remove(surfaceForm);
    multiStems.put(surfaceForm,stemNode);
  }
 else {
    singleStems.put(surfaceForm,stemNode);
  }
  stemNodes.add(stemNode);
}"
52718,"private boolean containsNode(StemNode node){
  return multiStems.containsEntry(node.surfaceForm,node) || singeStems.containsKey(node.surfaceForm);
}","private boolean containsNode(StemNode node){
  return multiStems.containsEntry(node.surfaceForm,node) || singleStems.containsKey(node.surfaceForm);
}"
52719,"protected void registerForm(SuffixForm formSet){
  if (formSet instanceof SuffixFormTemplate) {
    formLookupByName.put(formSet.getId(),formSet);
    return;
  }
  if (suffixForms.containsKey(formSet)) {
    return;
  }
  SuffixData allConnections=formSet.allConnections();
  List<SuffixForm> templateFormsToRemove=new ArrayList<SuffixForm>();
  List<SuffixForm> nullFormsToRegister=new ArrayList<SuffixForm>();
  for (  SuffixForm connection : formSet.connections) {
    if (connection instanceof SuffixFormTemplate) {
      NullSuffixForm nullForm=generateNullFormFromTemplate((SuffixFormTemplate)connection,new SuffixData(allConnections)).copy();
      nullFormsToRegister.add(nullForm);
      templateFormsToRemove.add(connection);
    }
  }
  formSet.connections.remove(templateFormsToRemove);
  formSet.indirectConnections.clear();
  formSet.connections.add(nullFormsToRegister);
  if (formSet.index != -1)   formSet.index=getNewIndex();
  suffixForms.put(formSet,formSet);
  formLookupByName.put(formSet.getId(),formSet);
  for (  SuffixForm form : nullFormsToRegister) {
    registerForm(form);
  }
}","protected void registerForm(SuffixForm formSet){
  if (formSet instanceof SuffixFormTemplate) {
    formLookupByName.put(formSet.getId(),formSet);
    return;
  }
  if (suffixForms.containsKey(formSet)) {
    return;
  }
  SuffixData allConnections=formSet.allConnections();
  List<SuffixForm> templateFormsToRemove=new ArrayList<>();
  List<SuffixForm> nullFormsToRegister=new ArrayList<>();
  for (  SuffixForm connection : formSet.connections) {
    if (connection instanceof SuffixFormTemplate) {
      NullSuffixForm nullForm=generateNullFormFromTemplate((SuffixFormTemplate)connection,new SuffixData(allConnections)).copy();
      nullFormsToRegister.add(nullForm);
      templateFormsToRemove.add(connection);
    }
  }
  formSet.connections.remove(templateFormsToRemove);
  formSet.indirectConnections.clear();
  formSet.connections.add(nullFormsToRegister);
  if (formSet.index != -1)   formSet.index=getNewIndex();
  suffixForms.put(formSet,formSet);
  formLookupByName.put(formSet.getId(),formSet);
  for (  SuffixForm form : nullFormsToRegister) {
    registerForm(form);
  }
}"
52720,"private StemNode[] generateModifiedRootNodes(DictionaryItem dicItem){
  if (dicItem.hasAttribute(RootAttribute.Special))   return handleSpecialStems(dicItem);
  TurkicSeq modifiedSeq=new TurkicSeq(dicItem.pronunciation,alphabet);
  EnumSet<PhoneticAttribute> originalAttrs=calculateAttributes(dicItem.pronunciation);
  EnumSet<PhoneticAttribute> modifiedAttrs=originalAttrs.clone();
  EnumSet<PhoneticExpectation> originalExpectations=EnumSet.noneOf(PhoneticExpectation.class);
  EnumSet<PhoneticExpectation> modifiedExpectations=EnumSet.noneOf(PhoneticExpectation.class);
  for (  RootAttribute attribute : dicItem.attributes) {
switch (attribute) {
case Voicing:
      TurkicLetter last=modifiedSeq.lastLetter();
    TurkicLetter modifiedLetter=alphabet.voice(last);
  if (modifiedLetter == null) {
    throw new LexiconException(""String_Node_Str"" + dicItem);
  }
if (dicItem.lemma.endsWith(""String_Node_Str"")) modifiedLetter=TurkishAlphabet.L_g;
modifiedSeq.changeLetter(modifiedSeq.length() - 1,modifiedLetter);
modifiedAttrs.remove(PhoneticAttribute.LastLetterVoicelessStop);
originalExpectations.add(PhoneticExpectation.ConsonantStart);
modifiedExpectations.add(PhoneticExpectation.VowelStart);
break;
case Doubling:
modifiedSeq.append(modifiedSeq.lastLetter());
originalExpectations.add(PhoneticExpectation.ConsonantStart);
modifiedExpectations.add(PhoneticExpectation.VowelStart);
break;
case LastVowelDrop:
modifiedSeq.delete(modifiedSeq.length() - 2);
if (!dicItem.primaryPos.equals(PrimaryPos.Verb)) originalExpectations.add(PhoneticExpectation.ConsonantStart);
modifiedExpectations.add(PhoneticExpectation.VowelStart);
break;
case InverseHarmony:
originalAttrs.add(PhoneticAttribute.LastVowelFrontal);
originalAttrs.remove(PhoneticAttribute.LastVowelBack);
modifiedAttrs.add(PhoneticAttribute.LastVowelFrontal);
modifiedAttrs.remove(PhoneticAttribute.LastVowelBack);
break;
case ProgressiveVowelDrop:
modifiedSeq.delete(modifiedSeq.length() - 1);
if (modifiedSeq.hasVowel()) {
modifiedAttrs=calculateAttributes(modifiedSeq);
}
break;
default :
break;
}
}
StemNode original=new StemNode(dicItem.root,dicItem,originalAttrs,originalExpectations);
StemNode modified=new StemNode(modifiedSeq.toString(),dicItem,modifiedAttrs,modifiedExpectations);
SuffixData[] roots=suffixProvider.defineSuccessorSuffixes(dicItem);
original.exclusiveSuffixData=roots[0];
modified.exclusiveSuffixData=roots[1];
if (original.equals(modified)) return new StemNode[]{original};
modified.setTermination(TerminationType.NON_TERMINAL);
if (dicItem.hasAttribute(RootAttribute.CompoundP3sgRoot)) original.setTermination(TerminationType.NON_TERMINAL);
return new StemNode[]{original,modified};
}","private StemNode[] generateModifiedRootNodes(DictionaryItem dicItem){
  if (dicItem.hasAttribute(RootAttribute.Special))   return handleSpecialStems(dicItem);
  TurkicSeq modifiedSeq=new TurkicSeq(dicItem.pronunciation,alphabet);
  EnumSet<PhoneticAttribute> originalAttrs=calculateAttributes(dicItem.pronunciation);
  EnumSet<PhoneticAttribute> modifiedAttrs=originalAttrs.clone();
  EnumSet<PhoneticExpectation> originalExpectations=EnumSet.noneOf(PhoneticExpectation.class);
  EnumSet<PhoneticExpectation> modifiedExpectations=EnumSet.noneOf(PhoneticExpectation.class);
  for (  RootAttribute attribute : dicItem.attributes) {
switch (attribute) {
case Voicing:
      TurkicLetter last=modifiedSeq.lastLetter();
    TurkicLetter modifiedLetter=alphabet.voice(last);
  if (modifiedLetter == null) {
    throw new LexiconException(""String_Node_Str"" + dicItem);
  }
if (dicItem.lemma.endsWith(""String_Node_Str"")) modifiedLetter=TurkishAlphabet.L_g;
modifiedSeq.changeLetter(modifiedSeq.length() - 1,modifiedLetter);
modifiedAttrs.remove(PhoneticAttribute.LastLetterVoicelessStop);
originalExpectations.add(PhoneticExpectation.ConsonantStart);
modifiedExpectations.add(PhoneticExpectation.VowelStart);
break;
case Doubling:
modifiedSeq.append(modifiedSeq.lastLetter());
originalExpectations.add(PhoneticExpectation.ConsonantStart);
modifiedExpectations.add(PhoneticExpectation.VowelStart);
break;
case LastVowelDrop:
if (modifiedSeq.lastLetter().isVowel()) {
modifiedSeq.delete(modifiedSeq.length() - 1);
modifiedExpectations.add(PhoneticExpectation.ConsonantStart);
}
 else {
modifiedSeq.delete(modifiedSeq.length() - 2);
if (!dicItem.primaryPos.equals(PrimaryPos.Verb)) {
originalExpectations.add(PhoneticExpectation.ConsonantStart);
}
modifiedExpectations.add(PhoneticExpectation.VowelStart);
}
break;
case InverseHarmony:
originalAttrs.add(PhoneticAttribute.LastVowelFrontal);
originalAttrs.remove(PhoneticAttribute.LastVowelBack);
modifiedAttrs.add(PhoneticAttribute.LastVowelFrontal);
modifiedAttrs.remove(PhoneticAttribute.LastVowelBack);
break;
case ProgressiveVowelDrop:
modifiedSeq.delete(modifiedSeq.length() - 1);
if (modifiedSeq.hasVowel()) {
modifiedAttrs=calculateAttributes(modifiedSeq);
}
break;
default :
break;
}
}
StemNode original=new StemNode(dicItem.root,dicItem,originalAttrs,originalExpectations);
StemNode modified=new StemNode(modifiedSeq.toString(),dicItem,modifiedAttrs,modifiedExpectations);
SuffixData[] roots=suffixProvider.defineSuccessorSuffixes(dicItem);
original.exclusiveSuffixData=roots[0];
modified.exclusiveSuffixData=roots[1];
if (original.equals(modified)) return new StemNode[]{original};
modified.setTermination(TerminationType.NON_TERMINAL);
if (dicItem.hasAttribute(RootAttribute.CompoundP3sgRoot)) original.setTermination(TerminationType.NON_TERMINAL);
return new StemNode[]{original,modified};
}"
52721,"public TurkishSuffixes(){
  Noun_TEMPLATE.connections.add(A3pl_lAr,A3pl_Comp_lAr,A3sg_TEMPLATE);
  Noun_TEMPLATE.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,P3pl_I,Gen_yIn).add(Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken).add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz).add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr).add(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Equ_ncA).add(Dim_cIk,Dim2_cAgIz,With_lI,Without_sIz,Agt_cI,JustLike_msI,JustLike_ImsI,Ness_lIk,Related_sAl,FitFor_lIk).add(Become_lAs,Acquire_lAn,Pres_TEMPLATE).add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular);
  Noun_Default.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  Noun_Default.indirectConnections.add(Noun_TEMPLATE.indirectConnections).remove(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Rel_kI).remove(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn);
  Noun_Time_Default.connections.add(Noun_Default.connections);
  Noun_Time_Default.indirectConnections.add(Noun_Default.indirectConnections).add(Rel_kI);
  DemonsPron_TEMPLATE.connections.add(A3sg_TEMPLATE,A3pl_nlAr,A1pl_TEMPLATE);
  DemonsPron_TEMPLATE.indirectConnections.add(With_lI,Inst_ylA,Without_sIz,Acc_nI,Dat_nA,Loc_ndA,Gen_nIn,Nom_TEMPLATE,Abl_ndAn,Cop_dIr,Pron2Verb,Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,A3pl_lAr).add(Pnon_TEMPLATE).add(Noun2Verb,Noun2VerbCopular);
  DemonsPron_Default.copyConnections(DemonsPron_TEMPLATE);
  QuesPron_Default.copyConnections(DemonsPron_TEMPLATE);
  QuantPron_Default.copyConnections(DemonsPron_TEMPLATE).connections.add(A3pl_lAr);
  QuantPron_Default.indirectConnections.add(P3sg_sI,P3pl_I,P1pl_ImIz).remove(P3sg_sI,P3sg_yI);
  PersPron_Default.copyConnections(DemonsPron_TEMPLATE);
  ReflexPron_Default.copyConnections(DemonsPron_TEMPLATE);
  ReflexPron_Default.indirectConnections.add(Dat_nA,P3sg_sI);
  ReflexPron_Default.connections.add(A2sg_TEMPLATE);
  Pron2Verb.connections.add(Noun2VerbCopular.connections);
  Pron2Verb.indirectConnections.add(Noun2VerbCopular.indirectConnections);
  Ques_Template.connections.add(Pres_TEMPLATE,NarrCop_ymIs,PastCop_ydI);
  Ques_Template.indirectConnections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A1pl_yIz,A2pl_sInIz);
  Ques_Default.copyConnections(Ques_Template);
  Numeral_Template.connections.add(Noun_TEMPLATE.connections);
  Numeral_Template.connections.add(Num2Noun,Num2Adj,Num2Adv,Num2Verb);
  Numeral_Template.indirectConnections.add(Noun_TEMPLATE.indirectConnections);
  Numeral_Default.connections.add(Num2Noun,Num2Adj,Num2Adv,Num2Verb);
  Numeral_Default.indirectConnections.add(Noun_TEMPLATE.allConnections());
  Noun2Noun.connections.add(Dim_cIk,Dim2_cAgIz,Agt_cI,Ness_lIk);
  Noun2Adj.connections.add(With_lI,Without_sIz,JustLike_msI,Rel_ki,Rel_kI,Related_sAl,FitFor_lIk);
  Noun2Verb.connections.add(Become_lAs,Acquire_lAn);
  Noun2VerbCopular.connections.add(Pres_TEMPLATE,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken);
  Noun2VerbCopular.indirectConnections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr);
  Noun2VerbCopular.indirectConnections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,Cop_dIr);
  Adj2Noun.connections.add(Noun_TEMPLATE.connections);
  Adj2Noun.indirectConnections.add(Noun_Default.indirectConnections).remove(FitFor_lIk,Related_sAl,Become_lAs,JustLike_ImsI,JustLike_msI,Equ_cA,Equ_ncA);
  Postp2Noun.connections.add(Noun_TEMPLATE.connections);
  Postp2Noun.indirectConnections.add(Noun_Default.indirectConnections).remove(Related_sAl,Become_lAs,JustLike_ImsI,JustLike_msI,Equ_cA,Equ_ncA);
  Adj2Adj.connections.add(Quite_cA,JustLike_Adj_ImsI,JustLike_Adj_msI);
  Adj2Adv.connections.add(Ly_cA);
  Adj2Verb.connections.add(Become_Adj_lAs,Acquire_lAn).add(COPULAR_FORMS);
  Num2Adj.connections.add(Quite_cA,JustLike_Adj_ImsI,JustLike_Adj_msI);
  Num2Noun.connections.add(Adj2Noun.connections);
  Num2Noun.indirectConnections.add(Adj2Noun.indirectConnections).remove(FitFor_lIk);
  Num2Verb.connections.add(Become_Adj_lAs,Acquire_lAn).add(COPULAR_FORMS);
  Adv2Noun.connections.add(A3sg_TEMPLATE);
  Adv2Noun.indirectConnections.add(Pnon_TEMPLATE,Dat_yA);
  Adv2Adj.connections.add(Rel_ki);
  Verb2Verb.connections.add(Caus_t,Caus_tIr,Pass_In,Pass_nIl,Pass_InIl,Abil_yA);
  Verb2VerbCompounds.connections.add(KeepDoing_yAgor,KeepDoing2_yAdur,EverSince_yAgel,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Start_yAkoy);
  Verb2VerbAbility.connections.add(Abil_yAbil);
  Verb2Noun.connections.add(Inf1_mAk,Inf2_mA,Inf3_yIs,FeelLike_yAsI_2Noun,Agt_yIcI_2Noun,ActOf_mAcA,NotState_mAzlIk);
  Verb2NounPart.connections.add(PastPart_dIk_2Noun,NarrPart_mIs_2Noun,FutPart_yAcAk_2Noun);
  Verb2AdjPart.connections.add(PastPart_dIk_2Adj,NarrPart_mIs_2Adj,FutPart_yAcAk_2Adj,AorPart_Ar_2Adj,AorPart_Ir_2Adj,AorPart_z_2Adj,PresPart_yAn);
  Verb2Adv.connections.add(When_yIncA,SinceDoing_yAlI,UnableToDo_yAmAdAn,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn).add(InsteadOfDoing_mAktAnsA,AsLongAs_dIkcA,AfterDoing_yIp,AsIf_cAsInA);
  Verb2Adj.connections.add(When_yIncA,FeelLike_yAsI_2Adj,Agt_yIcI_2Adj);
  Adv_TEMPLATE.connections.add(Adv2Noun,Adv2Adj);
  Adj_TEMPLATE.connections.add(Adj2Noun,Adj2Adj,Adj2Adv,Adj2Verb);
  Adj_TEMPLATE.indirectConnections.add(Adj2Noun.allConnections(),Adj2Adj.allConnections(),Adj2Adv.allConnections(),Adj2Verb.allConnections());
  Postp_Template.connections.add(Postp2Noun);
  Postp_Template.indirectConnections.add(Postp2Noun.allConnections());
  Postp_Default.connections.add(Postp_Template.connections);
  Postp_Default.indirectConnections.add(Postp_Template.indirectConnections);
  Adj_Default.connections.add(Adj_TEMPLATE.connections);
  Adj_Default.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Noun_Comp_P3sg.connections.add(A3sg_TEMPLATE);
  Noun_Comp_P3sg.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,Pres_TEMPLATE).add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular).add(Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA).add(Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken).add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr).add(A1sg_yIm,A1pl_yIz,A2sg_sIn,A2pl_sInIz);
  Noun_Comp_P3sg_Root.connections.add(A3pl_Comp_lAr,A3sg_TEMPLATE);
  Noun_Comp_P3sg_Root.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,With_lI,Without_sIz,Agt_cI,JustLike_msI,JustLike_ImsI,Ness_lIk,Related_sAl).add(P3pl_lArI).add(POSSESSIVE_FORMS).add(Noun2Noun.allConnections()).add(Noun2Noun).add(Noun2Adj.allConnections()).add(Noun2Adj);
  Noun_Su_Root.connections.add(Noun_Default.connections);
  Noun_Su_Root.indirectConnections.add(Noun_Default.indirectConnections).remove(P1sg_Im,P2sg_In,P3sg_sI,P1pl_ImIz,P2pl_InIz,Gen_nIn).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn);
  ProperNoun_Template.connections.add(Noun_Default.connections);
  ProperNoun_Template.indirectConnections.add(Noun_Default.indirectConnections).remove(Related_sAl);
  ProperNoun_Default.copyConnections(ProperNoun_Template);
  Verb_TEMPLATE.connections.add(Neg_mA,Neg_m,Pos_EMPTY,Verb2Verb);
  Verb_TEMPLATE.indirectConnections.add(Prog_Iyor,Prog2_mAktA,Fut_yAcAk,Past_dI,Narr_mIs,Aor_Ir,Aor_Ar,Aor_z,AorPart_Ir_2Adj,AorPart_Ar_2Adj).add(Abil_yAbil,Abil_yA,Caus_tIr,Caus_t,Opt_yA,Imp_TEMPLATE,Agt_yIcI_2Adj,Agt_yIcI_2Noun,Des_sA).add(NotState_mAzlIk,ActOf_mAcA,PastPart_dIk_2Adj,PastPart_dIk_2Noun,NarrPart_mIs_2Adj,NarrPart_mIs_2Noun,Pass_In,Pass_nIl,Pass_InIl).add(FutPart_yAcAk_2Adj,FutPart_yAcAk_2Noun,PresPart_yAn,AsLongAs_dIkcA,A2pl2_sAnIzA).add(A1sg_yIm,A2sg_sIn,A2sg_TEMPLATE,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_yIn,A2pl_sInIz,A3pl_Verb_lAr,A3sg_sIn,A3pl_sInlAr,A2sg2_sAnA,A2sg3_yInIz).add(Inf1_mAk,Inf2_mA,Inf3_yIs,Necess_mAlI).add(Cond_sA,Cond_sA_AfterPerson).add(When_yIncA,FeelLike_yAsI_2Adj,FeelLike_yAsI_2Noun,SinceDoing_yAlI,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn).add(AfterDoing_yIp,When_yIncA,UnableToDo_yAmAdAn,InsteadOfDoing_mAktAnsA,A3pl_Verb_lAr_After_Tense,AsIf_cAsInA).add(KeepDoing2_yAdur,KeepDoing_yAgor,EverSince_yAgel,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Start_yAkoy).add(UntilDoing_yAsIyA,Verb2VerbCompounds,Verb2Noun,Verb2Adv,Verb2Adj,Verb2NounPart,Verb2AdjPart,Verb2VerbAbility);
  Verb_Default.connections.add(Verb_TEMPLATE.connections);
  Verb_Default.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t);
  Verb_Prog_Drop.connections.add(Pos_EMPTY);
  Verb_Prog_Drop.indirectConnections.add(Prog_Iyor).add(Prog_Iyor.allConnections());
  Verb_Ye.connections.add(Neg_m,Neg_mA,Pos_EMPTY,Verb2Verb);
  Verb_Ye.indirectConnections.add(Verb_Default.indirectConnections).remove(Abil_yA,Abil_yAbil,Prog_Iyor,Fut_yAcAk,Caus_tIr,FutPart_yAcAk_2Adj,Opt_yA,When_yIncA,AfterDoing_yIp,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,UnableToDo_yAmAdAn).add(Pass_In,Inf3_yIs);
  Verb_De_Ye_Prog.connections.add(Pos_EMPTY);
  Verb_De_Ye_Prog.indirectConnections.add(Prog_Iyor).add(Prog_Iyor.allConnections());
  Verb_Yi.connections.add(Pos_EMPTY,Verb2Verb);
  Verb_Yi.indirectConnections.add(Opt_yA,Fut_yAcAk,FutPart_yAcAk_2Adj,When_yIncA,AfterDoing_yIp,Abil_yA,Abil_yAbil,Inf3_yIs,FeelLike_yAsI_2Adj,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn,Verb2Adv,Verb2Adj,Verb2NounPart,Verb2AdjPart,Verb2VerbAbility);
  Verb_De.connections.add(Neg_m,Neg_mA,Pos_EMPTY,Verb2Verb);
  Verb_De.indirectConnections.add(Verb_Default.indirectConnections).remove(Abil_yA,Abil_yAbil,Prog_Iyor,Fut_yAcAk,FutPart_yAcAk_2Adj,Opt_yA,PresPart_yAn,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn).add(Pass_In);
  Verb_Di.connections.add(Pos_EMPTY,Verb2Verb);
  Verb_Di.indirectConnections.add(Opt_yA,Fut_yAcAk,FutPart_yAcAk_2Adj,Abil_yA,Abil_yAbil,PresPart_yAn,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn,Verb2Adv);
  A3pl_lAr.connections.add(POSSESSIVE_FORMS).remove(P3pl_lArI).add(P3sg_yI,P3pl_I).remove(P3sg_sI);
  A3pl_lAr.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A3pl_Verb_lAr).add(CASE_FORMS).add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn).add(A1pl_yIz,A2pl_sInIz);
  A3pl_Comp_lAr.connections.add(A3pl_lAr.connections);
  A3pl_Comp_lAr.indirectConnections.add(CASE_FORMS).add(A1pl_yIz,A2pl_sInIz);
  A3sg_TEMPLATE.connections.add(POSSESSIVE_FORMS).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz);
  A3sg_TEMPLATE.indirectConnections.add(Noun_TEMPLATE.indirectConnections).remove(POSSESSIVE_FORMS).add(Gen_yIn).add(Noun2Noun.allConnections()).add(Noun2Noun).add(Noun2VerbCopular.allConnections()).add(Noun2Adj.allConnections().add(Noun2Adj));
  Nom_TEMPLATE.connections.add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular);
  Nom_TEMPLATE.indirectConnections.add(Noun2Noun.allConnections()).add(Noun2Adj.allConnections()).add(Noun2VerbCopular.allConnections()).add(Noun2Verb.allConnections());
  Pres_TEMPLATE.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr);
  Pres_TEMPLATE.indirectConnections.add(Cop_dIr);
  A1sg_yIm.connections.add(Cop_dIr);
  A2sg_sIn.connections.add(Cop_dIr);
  A3sg_Verb_TEMPLATE.connections.add(Cop_dIr,Verb2Adv);
  A3sg_Verb_TEMPLATE.indirectConnections.add(AsIf_cAsInA);
  A1pl_yIz.connections.add(Cop_dIr,Verb2Adv);
  A1pl_yIz.indirectConnections.add(AsIf_cAsInA);
  A2pl_sInIz.connections.add(Cop_dIr,Verb2Adv);
  A2pl_sInIz.indirectConnections.add(AsIf_cAsInA);
  A3pl_Verb_lAr.connections.add(Narr_mIs,Past_dI,Cond_sA,Cop_dIr,Verb2Adv);
  A3pl_Verb_lAr.indirectConnections.add(AsIf_cAsInA);
  Dim_cIk.connections.add(Noun_Default.connections);
  Dim_cIk.indirectConnections.add(Noun_Default.allConnections().add(Noun2VerbCopular).remove(Dim_cIk,Dim2_cAgIz));
  Agt_cI.connections.add(Noun_Default.connections);
  Agt_cI.indirectConnections.add(Noun_Default.allConnections().add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(Agt_cI));
  Dim2_cAgIz.connections.add(Noun_Default.connections);
  Dim2_cAgIz.indirectConnections.add(Noun_Default.allConnections().remove(Dim_cIk,Dim2_cAgIz));
  Ness_lIk.connections.add(Noun_Default.connections);
  Ness_lIk.indirectConnections.add(Noun_Default.allConnections().remove(Ness_lIk));
  Pnon_TEMPLATE.connections.add(CASE_FORMS).add(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Gen_yIn);
  Pnon_TEMPLATE.indirectConnections.add(Nom_TEMPLATE.connections).add(Noun2Noun.allConnections()).add(Noun2Verb.allConnections()).add(Noun2VerbCopular.allConnections()).add(Noun2Adj.allConnections());
  P1sg_Im.connections.add(CASE_FORMS);
  P1sg_Im.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A1pl_yIz,A1sg_yIm);
  P1sg_yIm.connections.add(CASE_FORMS);
  P1sg_yIm.indirectConnections.add(P1sg_Im.indirectConnections);
  P2sg_In.connections.add(CASE_FORMS);
  P2sg_In.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A2sg_sIn,A1pl_yIz,A2pl_nIz,A2pl_sInIz);
  P2sg_yIn.connections.add(CASE_FORMS);
  P2sg_yIn.indirectConnections.add(P2sg_In.indirectConnections);
  P3sg_sI.connections.add(Nom_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  P3sg_sI.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P3sg_yI.connections.add(P3sg_sI.connections);
  P3sg_yI.indirectConnections.add(P3sg_sI.indirectConnections);
  P1pl_ImIz.connections.add(CASE_FORMS);
  P1pl_ImIz.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A1pl_yIz);
  P1pl_yImIz.connections.add(CASE_FORMS);
  P1pl_yImIz.indirectConnections.add(P1pl_ImIz.indirectConnections);
  P2pl_InIz.connections.add(CASE_FORMS);
  P2pl_InIz.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P2pl_yInIz.connections.add(CASE_FORMS);
  P2pl_yInIz.indirectConnections.add(P2pl_InIz.indirectConnections);
  P3pl_lArI.connections.add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn);
  P3pl_lArI.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P3pl_I.connections.add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn);
  P3pl_I.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  With_lI.connections.add(Adj_TEMPLATE.connections);
  With_lI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Related_sAl.connections.add(Adj_TEMPLATE.connections);
  Related_sAl.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Without_sIz.connections.add(Adj_TEMPLATE.connections);
  Without_sIz.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  FitFor_lIk.connections.add(Adj_TEMPLATE.connections);
  FitFor_lIk.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Loc_dA.connections.add(Noun2Adj,Noun2VerbCopular);
  Loc_dA.indirectConnections.add(Rel_ki).add(Noun2VerbCopular.allConnections());
  Loc_ndA.connections.add(Noun2Adj,Noun2VerbCopular);
  Loc_ndA.indirectConnections.add(Rel_ki).add(Noun2VerbCopular.allConnections());
  Dat_nA.connections.add(Noun2VerbCopular);
  Dat_nA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Dat_yA.connections.add(Noun2VerbCopular);
  Dat_yA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Gen_nIn.connections.add(Noun2VerbCopular,Noun2Adj);
  Gen_nIn.indirectConnections.add(Noun2VerbCopular.allConnections()).add(Noun2Adj.connections);
  Dat_yA.connections.add(Noun2VerbCopular);
  Dat_yA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Abl_dAn.connections.add(Noun2VerbCopular);
  Abl_dAn.indirectConnections.add(Noun2VerbCopular.allConnections());
  Abl_ndAn.connections.add(Noun2VerbCopular);
  Abl_ndAn.indirectConnections.add(Noun2VerbCopular.allConnections());
  Inst_ylA.connections.add(Noun2VerbCopular);
  Inst_ylA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Equ_cA.connections.add(Noun2VerbCopular);
  Equ_cA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Rel_ki.connections.add(Adj2Noun);
  Rel_ki.indirectConnections.add(Adj2Noun.indirectConnections).add(A3sg_TEMPLATE,Pnon_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  Rel_kI.connections.add(Adj2Noun);
  Rel_kI.indirectConnections.add(Adj2Noun.indirectConnections).add(A3sg_TEMPLATE,Pnon_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  JustLike_msI.connections.add(Adj_TEMPLATE.connections);
  JustLike_msI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_ImsI.connections.add(Adj_TEMPLATE.connections);
  JustLike_ImsI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_Adj_msI.connections.add(Adj_TEMPLATE.connections);
  JustLike_Adj_msI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_Adj_ImsI.connections.add(Adj_TEMPLATE.connections);
  JustLike_Adj_ImsI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Become_lAs.connections.add(Verb_TEMPLATE.connections);
  Become_lAs.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Acquire_lAn.connections.add(Verb_TEMPLATE.connections);
  Acquire_lAn.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Become_Adj_lAs.connections.add(Verb_TEMPLATE.connections);
  Become_Adj_lAs.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Quite_cA.connections.add(Adj_TEMPLATE.connections);
  Ly_cA.connections.add(Adv_TEMPLATE.connections);
  Pos_EMPTY.connections.add(Verb2VerbCompounds,Verb2Noun,Verb2Adv,Verb2Adj,Verb2AdjPart,Verb2NounPart,Verb2VerbAbility,Imp_TEMPLATE,Prog_Iyor,Prog2_mAktA,Fut_yAcAk,Aor_Ar,Aor_Ir,Past_dI,Narr_mIs,ActOf_mAcA).add(Cond_sA,Necess_mAlI,Opt_yA,Des_sA);
  Pos_EMPTY.indirectConnections.add(Verb_Default.indirectConnections).add(A2pl2_sAnIzA,A2pl_yIn).add(Verb2AdjPart.connections,Verb2NounPart.connections).remove(Neg_m,Neg_mA);
  Neg_mA.connections.add(Verb2VerbCompounds,Verb2VerbAbility,Verb2Noun,Verb2Adv,Verb2Adj,Verb2AdjPart,Verb2NounPart,Aor_z,Aor_EMPTY,Prog2_mAktA,Imp_TEMPLATE,Opt_yA,Des_sA,Fut_yAcAk,Past_dI,Narr_mIs,Necess_mAlI,NotState_mAzlIk,ActOf_mAcA);
  Neg_mA.indirectConnections.add(Verb2VerbCompounds.connections,Verb2AdjPart.connections,Verb2NounPart.connections,Verb2Noun.connections,Verb2Adv.connections,Verb2Adj.connections).add(A2sg_TEMPLATE,A1sg_m,A1sg_yIm,A2sg_sIn,A2sg2_sAnA,A2sg3_yInIz,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A2pl2_sAnIzA,A2pl_yIn,A3pl_Verb_lAr,A3sg_sIn,A3pl_sInlAr).add(Abil_yAbil);
  Neg_m.connections.add(Prog_Iyor);
  Imp_TEMPLATE.connections.add(A2sg_TEMPLATE,A2sg2_sAnA,A2sg3_yInIz,A2pl2_sAnIzA,A2pl_yIn,A3sg_sIn,A3pl_sInlAr);
  Caus_t.connections.add(Verb2Verb,Pos_EMPTY,Neg_mA,Neg_m);
  Caus_t.indirectConnections.add(Verb_TEMPLATE.indirectConnections).add(Pass_nIl).add(Caus_tIr).remove(Caus_t);
  Caus_tIr.connections.add(Verb_TEMPLATE.connections);
  Caus_tIr.indirectConnections.add(Verb_TEMPLATE.indirectConnections).add(Pass_nIl).add(Caus_t).remove(Caus_tIr);
  Pass_nIl.connections.add(Verb_TEMPLATE.connections);
  Pass_nIl.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Pass_In.connections.add(Verb_TEMPLATE.connections);
  Pass_In.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Pass_InIl.connections.add(Verb_TEMPLATE.connections);
  Pass_InIl.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Prog_Iyor.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Prog2_mAktA.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Fut_yAcAk.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Fut_yAcAk.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  Aor_Ar.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Aor_Ar.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_Ir.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Aor_Ir.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_z.connections.add(A3sg_Verb_TEMPLATE,A3sg_sIn,A2pl_sInIz,A3pl_Verb_lAr).add(PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,Cop_dIr);
  Aor_z.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_EMPTY.connections.add(A1sg_m,A1pl_yIz);
  AorPart_Ar_2Adj.connections.add(Adj2Noun);
  AorPart_Ar_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  AorPart_Ir_2Adj.connections.add(Adj2Noun);
  AorPart_Ir_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  AorPart_z_2Adj.connections.add(Adj2Noun);
  AorPart_z_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  PastPart_dIk_2Noun.connections.add(A3sg_TEMPLATE).add(A3pl_lAr);
  PastPart_dIk_2Noun.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS).remove(Equ_cA);
  NarrPart_mIs_2Noun.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  NarrPart_mIs_2Noun.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS);
  FutPart_yAcAk_2Noun.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  FutPart_yAcAk_2Noun.indirectConnections.add(POSSESSIVE_FORMS);
  PastPart_dIk_2Adj.connections.add(POSSESSIVE_FORMS);
  PastPart_dIk_2Adj.indirectConnections.add(POSSESSIVE_FORMS).remove(CASE_FORMS);
  NarrPart_mIs_2Adj.connections.add(Adj2Noun);
  NarrPart_mIs_2Adj.indirectConnections.add(Ness_lIk).add(Ness_lIk.allConnections());
  PresPart_yAn.connections.add(Adj2Noun);
  PresPart_yAn.indirectConnections.add(Adj2Noun.allConnections());
  Past_dI.connections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr,CondCop_ysA,PastCop_ydI);
  A1sg_m.connections.add(Cond_sA_AfterPerson);
  A2sg_n.connections.add(Cond_sA_AfterPerson);
  A1pl_k.connections.add(Cond_sA_AfterPerson);
  A2pl_nIz.connections.add(Cond_sA_AfterPerson);
  A3pl_Verb_lAr.connections.add(Cond_sA_AfterPerson);
  Narr_mIs.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(CondCop_ysA,PastCop_ydI,NarrCop_ymIs,While_ken,Cop_dIr);
  Narr_mIs.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  Cond_sA.connections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr,PastCop_ydI,NarrCop_ymIs);
  PastCop_ydI.connections.add(PERSON_FORMS_COP);
  NarrCop_ymIs.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr);
  NarrCop_ymIs.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  CondCop_ysA.connections.add(PERSON_FORMS_COP);
  Cop_dIr.connections.add(A3pl_Verb_lAr);
  Inf1_mAk.connections.add(A3sg_TEMPLATE);
  Inf1_mAk.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,Inst_ylA,Loc_dA,Dat_yA,Abl_dAn,Acc_yI,Noun2Adj,Noun2Noun,Noun2VerbCopular);
  Inf1_mAk.indirectConnections.add(Noun2Adj.allConnections(),Noun2Noun.allConnections(),Noun2VerbCopular.allConnections());
  Inf1_mAk.indirectConnections.remove(Without_sIz);
  Inf2_mA.connections.add(Noun_Default.connections);
  Inf2_mA.indirectConnections.add(Noun_Default.indirectConnections);
  Inf3_yIs.connections.add(Noun_Default.connections);
  Inf3_yIs.indirectConnections.add(Noun_Default.indirectConnections);
  ActOf_mAcA.connections.add(Noun_Default.connections);
  ActOf_mAcA.indirectConnections.add(Noun_Default.indirectConnections);
  NotState_mAzlIk.connections.add(Noun_Default.connections);
  NotState_mAzlIk.indirectConnections.add(Noun_Default.indirectConnections);
  Abil_yA.connections.add(Neg_mA,Neg_m);
  Abil_yA.indirectConnections.add(Neg_mA.allConnections());
  Abil_yAbil.connections.add(Neg_mA.connections).add(Aor_Ir,Prog_Iyor).remove(Verb2VerbAbility);
  Abil_yAbil.indirectConnections.add(Neg_mA.indirectConnections);
  KeepDoing_yAgor.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  KeepDoing_yAgor.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  KeepDoing2_yAdur.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  KeepDoing2_yAdur.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  EverSince_yAgel.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  EverSince_yAgel.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Almost_yAyAz.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Almost_yAyAz.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Hastily_yIver.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Hastily_yIver.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Stay_yAkal.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Stay_yAkal.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Start_yAkoy.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Start_yAkoy.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Necess_mAlI.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Des_sA.connections.add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr,PastCop_ydI,NarrCop_ymIs);
  When_yIncA.connections.add(Adv2Noun);
  When_yIncA.indirectConnections.add(Adv2Noun.allConnections());
  While_ken.connections.add(Adv2Adj);
  While_ken.indirectConnections.add(Rel_ki);
  FeelLike_yAsI_2Noun.connections.add(Noun_Default.connections);
  FeelLike_yAsI_2Noun.indirectConnections.add(Noun_Default.indirectConnections);
  FeelLike_yAsI_2Adj.connections.add(Adj_TEMPLATE);
  Agt_yIcI_2Noun.connections.add(Noun_Default.connections);
  Agt_yIcI_2Noun.indirectConnections.add(Noun_Default.indirectConnections);
  Agt_yIcI_2Adj.connections.add(Adj_TEMPLATE);
  Opt_yA.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_lIm,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  A2pl_TEMPLATE.connections.add(Pnon_TEMPLATE);
  A2pl_TEMPLATE.indirectConnections.add(Pnon_TEMPLATE.allConnections());
  A2pl_ler.connections.add(Pnon_TEMPLATE);
  A2pl_ler.indirectConnections.add(Pnon_TEMPLATE.allConnections().remove(A3pl_Verb_lAr,A3pl_lAr,A3pl_sInlAr));
  A1pl_TEMPLATE.connections.add(Pnon_TEMPLATE,P1pl_ImIz);
  A1pl_TEMPLATE.indirectConnections.add(Pnon_TEMPLATE.allConnections());
  A1pl_ler.connections.add(Pnon_TEMPLATE);
  A1pl_ler.indirectConnections.add(Pnon_TEMPLATE.allConnections().remove(A3pl_Verb_lAr,A3pl_lAr,A3pl_sInlAr));
  PersPron_TEMPLATE.connections.add(A1sg_TEMPLATE,A2sg_TEMPLATE,A3sg_TEMPLATE,A1pl_TEMPLATE,A2pl_TEMPLATE);
  PersPron_TEMPLATE.indirectConnections.add(CASE_FORMS).add(Pnon_TEMPLATE).add(Noun2Verb,Noun2VerbCopular);
  PersPron_Ben.connections.add(A1sg_TEMPLATE);
  PersPron_Ben.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_Sen.connections.add(A2sg_TEMPLATE);
  PersPron_Sen.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_O.connections.add(A3sg_TEMPLATE);
  PersPron_O.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_Biz.connections.add(A1pl_TEMPLATE,A1pl_ler);
  PersPron_Biz.indirectConnections.add(A1pl_ler.allConnections());
  PersPron_Siz.connections.add(A2pl_TEMPLATE,A2pl_ler);
  PersPron_Siz.indirectConnections.add(A2pl_ler.allConnections());
  registerForms(Noun_TEMPLATE,Verb_TEMPLATE,Adj_TEMPLATE,Adv_TEMPLATE,Numeral_Template,Postp_Template,Dup_Template,PersPron_TEMPLATE,DemonsPron_TEMPLATE,ReflexPron_TEMPLATE,Det_Template,QuantPron_TEMPLATE,Conj_Template,Ques_Template,QuesPron_TEMPLATE,Punc_Template,Noun2Adj,Noun2Noun,Noun2Verb,Noun2VerbCopular,Adj2Adj,Adj2Adv,Adj2Noun,Adj2Verb,Verb2Adj,Verb2Verb,Verb2VerbCompounds,Verb2Noun,Verb2Adv,Postp2Noun,Pron2Verb,Pres_TEMPLATE,Noun_Default,Noun_Time_Default,Det_Default,ProperNoun_Default,Verb_Default,Adj_Default,Numeral_Default,Conj_Default,PersPron_Default,QuantPron_Default,DemonsPron_Default,ReflexPron_Default,Postp_Default,Dup_Default,Ques_Template,QuesPron_TEMPLATE,Punc_Default,JustLike_Adj_ImsI,JustLike_msI,Noun_Su_Root,Pass_InIl,Nom_TEMPLATE,Dat_yA,Dat_nA,Loc_dA,Loc_ndA,Abl_dAn,Abl_ndAn,Gen_nIn,Acc_yI,Acc_nI,Inst_ylA,Pnon_TEMPLATE,P1sg_Im,P2sg_In,P3sg_sI,P1pl_ImIz,P2pl_InIz,P3pl_lArI,P3pl_I,P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn,Dim_cIk,Dim2_cAgIz,With_lI,Without_sIz,Rel_ki,Rel_kI,A1sg_yIm,A1sg_m,A1sg_TEMPLATE,A2sg_sIn,A2sg_n,A2sg_TEMPLATE,A2sg2_sAnA,A3sg_TEMPLATE,A3sg_Verb_TEMPLATE,A2sg3_yInIz,A3sg_sIn,A1pl_yIz,A1pl_k,A1pl_lIm,A1pl_TEMPLATE,A1pl_ler,A2pl_sInIz,A2pl_nIz,A2pl_yIn,A2pl_TEMPLATE,A2pl2_sAnIzA,A2pl_ler,A3pl_lAr,A3pl_Verb_lAr,A3pl_sInlAr,A3pl_nlAr,Agt_cI,Agt_yIcI_2Adj,Agt_yIcI_2Noun,Num2Noun,Num2Adj,Num2Adv,Num2Verb,PersPron_Siz,PersPron_BanSan,PersPron_Biz,PersPron_O,PersPron_Sen,PersPron_BenSen,PersPron_Ben,Ness_lIk,FitFor_lIk,Become_lAs,Become_Adj_lAs,Acquire_lAn,JustLike_ImsI,JustLike_msI,Related_sAl,Aor_Ir,Aor_Ar,Aor_z,Des_sA,Aor_EMPTY,AorPart_Ar_2Adj,AorPart_Ir_2Adj,AorPart_z_2Adj,Prog_Iyor,Prog2_mAktA,Fut_yAcAk,FutPart_yAcAk_2Adj,FutPart_yAcAk_2Noun,Past_dI,PastPart_dIk_2Noun,PastPart_dIk_2Adj,Narr_mIs,NarrPart_mIs_2Adj,NarrPart_mIs_2Noun,PresPart_yAn,Neg_mA,Neg_m,Cond_sA,Cond_sA_AfterPerson,Necess_mAlI,Opt_yA,Pass_In,Pass_nIl,Caus_t,Caus_tIr,Imp_TEMPLATE,Reflex_In,Abil_yAbil,Abil_yA,Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,NotState_mAzlIk,ActOf_mAcA,AsIf_cAsInA,AsLongAs_dIkcA,When_yIncA,FeelLike_yAsI_2Adj,FeelLike_yAsI_2Noun,SinceDoing_yAlI,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn,AfterDoing_yIp,UnableToDo_yAmAdAn,InsteadOfDoing_mAktAnsA,KeepDoing_yAgor,KeepDoing2_yAdur,EverSince_yAgel,Start_yAkoy,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Inf1_mAk,Inf2_mA,Inf3_yIs,Ly_cA,Quite_cA,Equ_cA,Equ_ncA,UntilDoing_yAsIyA,A3pl_Comp_lAr,Interj_Template,Verb_Prog_Drop,PersPron_BenSen,PersPron_BanSan,Ordinal_IncI,Grouping_sAr);
}","public TurkishSuffixes(){
  Noun_TEMPLATE.connections.add(A3pl_lAr,A3pl_Comp_lAr,A3sg_TEMPLATE);
  Noun_TEMPLATE.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,P3pl_I,Gen_yIn).add(Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken).add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz).add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr).add(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Equ_ncA).add(Dim_cIk,Dim2_cAgIz,With_lI,Without_sIz,Agt_cI,JustLike_msI,JustLike_ImsI,Ness_lIk,Related_sAl,FitFor_lIk).add(Become_lAs,Acquire_lAn,Pres_TEMPLATE).add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular);
  Noun_Default.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  Noun_Default.indirectConnections.add(Noun_TEMPLATE.indirectConnections).remove(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Rel_kI).remove(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn);
  Noun_Time_Default.connections.add(Noun_Default.connections);
  Noun_Time_Default.indirectConnections.add(Noun_Default.indirectConnections).add(Rel_kI);
  DemonsPron_TEMPLATE.connections.add(A3sg_TEMPLATE,A3pl_nlAr,A1pl_TEMPLATE);
  DemonsPron_TEMPLATE.indirectConnections.add(With_lI,Inst_ylA,Without_sIz,Acc_nI,Dat_nA,Loc_ndA,Gen_nIn,Nom_TEMPLATE,Abl_ndAn,Cop_dIr,Pron2Verb,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,A3pl_lAr).add(Pnon_TEMPLATE).add(Noun2Verb,Noun2VerbCopular);
  DemonsPron_Default.copyConnections(DemonsPron_TEMPLATE);
  QuantPron_Default.copyConnections(DemonsPron_TEMPLATE).connections.add(A3pl_lAr);
  QuantPron_Default.indirectConnections.add(P3sg_sI,P3pl_I,P1pl_ImIz).remove(P3sg_sI,P3sg_yI);
  PersPron_Default.copyConnections(DemonsPron_TEMPLATE);
  ReflexPron_Default.copyConnections(DemonsPron_TEMPLATE);
  ReflexPron_Default.indirectConnections.add(Dat_nA,P3sg_sI);
  ReflexPron_Default.connections.add(A2sg_TEMPLATE);
  Pron2Verb.connections.add(Noun2VerbCopular.connections);
  Pron2Verb.indirectConnections.add(Noun2VerbCopular.indirectConnections);
  Ques_Template.connections.add(A3sg_TEMPLATE,A3pl_lAr);
  Ques_Template.indirectConnections.add(Pron2Verb,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,Pnon_TEMPLATE,Abl_dAn,A1sg_yIm,A2sg_sIn);
  Ques_Default.copyConnections(Ques_Template);
  Numeral_Template.connections.add(Noun_TEMPLATE.connections);
  Numeral_Template.connections.add(Num2Noun,Num2Adj,Num2Adv,Num2Verb);
  Numeral_Template.indirectConnections.add(Noun_TEMPLATE.indirectConnections);
  Numeral_Default.connections.add(Num2Noun,Num2Adj,Num2Adv,Num2Verb);
  Numeral_Default.indirectConnections.add(Noun_TEMPLATE.allConnections());
  Noun2Noun.connections.add(Dim_cIk,Dim2_cAgIz,Agt_cI,Ness_lIk);
  Noun2Adj.connections.add(With_lI,Without_sIz,JustLike_msI,Rel_ki,Rel_kI,Related_sAl,FitFor_lIk);
  Noun2Verb.connections.add(Become_lAs,Acquire_lAn);
  Noun2VerbCopular.connections.add(Pres_TEMPLATE,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken);
  Noun2VerbCopular.indirectConnections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr);
  Noun2VerbCopular.indirectConnections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,Cop_dIr);
  Adj2Noun.connections.add(Noun_TEMPLATE.connections);
  Adj2Noun.indirectConnections.add(Noun_Default.indirectConnections).remove(FitFor_lIk,Related_sAl,Become_lAs,JustLike_ImsI,JustLike_msI,Equ_cA,Equ_ncA);
  Postp2Noun.connections.add(Noun_TEMPLATE.connections);
  Postp2Noun.indirectConnections.add(Noun_Default.indirectConnections).remove(Related_sAl,Become_lAs,JustLike_ImsI,JustLike_msI,Equ_cA,Equ_ncA);
  Adj2Adj.connections.add(Quite_cA,JustLike_Adj_ImsI,JustLike_Adj_msI);
  Adj2Adv.connections.add(Ly_cA);
  Adj2Verb.connections.add(Become_Adj_lAs,Acquire_lAn).add(COPULAR_FORMS);
  Num2Adj.connections.add(Quite_cA,JustLike_Adj_ImsI,JustLike_Adj_msI);
  Num2Noun.connections.add(Adj2Noun.connections);
  Num2Noun.indirectConnections.add(Adj2Noun.indirectConnections).remove(FitFor_lIk);
  Num2Verb.connections.add(Become_Adj_lAs,Acquire_lAn).add(COPULAR_FORMS);
  Adv2Noun.connections.add(A3sg_TEMPLATE);
  Adv2Noun.indirectConnections.add(Pnon_TEMPLATE,Dat_yA);
  Adv2Adj.connections.add(Rel_ki);
  Verb2Verb.connections.add(Caus_t,Caus_tIr,Pass_In,Pass_nIl,Pass_InIl,Abil_yA);
  Verb2VerbCompounds.connections.add(KeepDoing_yAgor,KeepDoing2_yAdur,EverSince_yAgel,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Start_yAkoy);
  Verb2VerbAbility.connections.add(Abil_yAbil);
  Verb2Noun.connections.add(Inf1_mAk,Inf2_mA,Inf3_yIs,FeelLike_yAsI_2Noun,Agt_yIcI_2Noun,ActOf_mAcA,NotState_mAzlIk);
  Verb2NounPart.connections.add(PastPart_dIk_2Noun,NarrPart_mIs_2Noun,FutPart_yAcAk_2Noun);
  Verb2AdjPart.connections.add(PastPart_dIk_2Adj,NarrPart_mIs_2Adj,FutPart_yAcAk_2Adj,AorPart_Ar_2Adj,AorPart_Ir_2Adj,AorPart_z_2Adj,PresPart_yAn);
  Verb2Adv.connections.add(When_yIncA,SinceDoing_yAlI,UnableToDo_yAmAdAn,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn).add(InsteadOfDoing_mAktAnsA,AsLongAs_dIkcA,AfterDoing_yIp,AsIf_cAsInA);
  Verb2Adj.connections.add(When_yIncA,FeelLike_yAsI_2Adj,Agt_yIcI_2Adj);
  Adv_TEMPLATE.connections.add(Adv2Noun,Adv2Adj);
  Adj_TEMPLATE.connections.add(Adj2Noun,Adj2Adj,Adj2Adv,Adj2Verb);
  Adj_TEMPLATE.indirectConnections.add(Adj2Noun.allConnections(),Adj2Adj.allConnections(),Adj2Adv.allConnections(),Adj2Verb.allConnections());
  Postp_Template.connections.add(Postp2Noun);
  Postp_Template.indirectConnections.add(Postp2Noun.allConnections());
  Postp_Default.connections.add(Postp_Template.connections);
  Postp_Default.indirectConnections.add(Postp_Template.indirectConnections);
  Adj_Default.connections.add(Adj_TEMPLATE.connections);
  Adj_Default.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Noun_Comp_P3sg.connections.add(A3sg_TEMPLATE);
  Noun_Comp_P3sg.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,Pres_TEMPLATE).add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular).add(Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA).add(Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken).add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr).add(A1sg_yIm,A1pl_yIz,A2sg_sIn,A2pl_sInIz);
  Noun_Comp_P3sg_Root.connections.add(A3pl_Comp_lAr,A3sg_TEMPLATE);
  Noun_Comp_P3sg_Root.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,With_lI,Without_sIz,Agt_cI,JustLike_msI,JustLike_ImsI,Ness_lIk,Related_sAl).add(P3pl_lArI).add(POSSESSIVE_FORMS).add(Noun2Noun.allConnections()).add(Noun2Noun).add(Noun2Adj.allConnections()).add(Noun2Adj);
  Noun_Su_Root.connections.add(Noun_Default.connections);
  Noun_Su_Root.indirectConnections.add(Noun_Default.indirectConnections).remove(P1sg_Im,P2sg_In,P3sg_sI,P1pl_ImIz,P2pl_InIz,Gen_nIn).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn);
  ProperNoun_Template.connections.add(Noun_Default.connections);
  ProperNoun_Template.indirectConnections.add(Noun_Default.indirectConnections).remove(Related_sAl);
  ProperNoun_Default.copyConnections(ProperNoun_Template);
  Verb_TEMPLATE.connections.add(Neg_mA,Neg_m,Pos_EMPTY,Verb2Verb);
  Verb_TEMPLATE.indirectConnections.add(Prog_Iyor,Prog2_mAktA,Fut_yAcAk,Past_dI,Narr_mIs,Aor_Ir,Aor_Ar,Aor_z,AorPart_Ir_2Adj,AorPart_Ar_2Adj).add(Abil_yAbil,Abil_yA,Caus_tIr,Caus_t,Opt_yA,Imp_TEMPLATE,Agt_yIcI_2Adj,Agt_yIcI_2Noun,Des_sA).add(NotState_mAzlIk,ActOf_mAcA,PastPart_dIk_2Adj,PastPart_dIk_2Noun,NarrPart_mIs_2Adj,NarrPart_mIs_2Noun,Pass_In,Pass_nIl,Pass_InIl).add(FutPart_yAcAk_2Adj,FutPart_yAcAk_2Noun,PresPart_yAn,AsLongAs_dIkcA,A2pl2_sAnIzA).add(A1sg_yIm,A2sg_sIn,A2sg_TEMPLATE,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_yIn,A2pl_sInIz,A3pl_Verb_lAr,A3sg_sIn,A3pl_sInlAr,A2sg2_sAnA,A2sg3_yInIz).add(Inf1_mAk,Inf2_mA,Inf3_yIs,Necess_mAlI).add(Cond_sA,Cond_sA_AfterPerson).add(When_yIncA,FeelLike_yAsI_2Adj,FeelLike_yAsI_2Noun,SinceDoing_yAlI,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn).add(AfterDoing_yIp,When_yIncA,UnableToDo_yAmAdAn,InsteadOfDoing_mAktAnsA,A3pl_Verb_lAr_After_Tense,AsIf_cAsInA).add(KeepDoing2_yAdur,KeepDoing_yAgor,EverSince_yAgel,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Start_yAkoy).add(UntilDoing_yAsIyA,Verb2VerbCompounds,Verb2Noun,Verb2Adv,Verb2Adj,Verb2NounPart,Verb2AdjPart,Verb2VerbAbility);
  Verb_Default.connections.add(Verb_TEMPLATE.connections);
  Verb_Default.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t);
  Verb_Prog_Drop.connections.add(Pos_EMPTY);
  Verb_Prog_Drop.indirectConnections.add(Prog_Iyor).add(Prog_Iyor.allConnections());
  Verb_Ye.connections.add(Neg_m,Neg_mA,Pos_EMPTY,Verb2Verb);
  Verb_Ye.indirectConnections.add(Verb_Default.indirectConnections).remove(Abil_yA,Abil_yAbil,Prog_Iyor,Fut_yAcAk,Caus_tIr,FutPart_yAcAk_2Adj,Opt_yA,When_yIncA,AfterDoing_yIp,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,UnableToDo_yAmAdAn).add(Pass_In,Inf3_yIs);
  Verb_De_Ye_Prog.connections.add(Pos_EMPTY);
  Verb_De_Ye_Prog.indirectConnections.add(Prog_Iyor).add(Prog_Iyor.allConnections());
  Verb_Yi.connections.add(Pos_EMPTY,Verb2Verb);
  Verb_Yi.indirectConnections.add(Opt_yA,Fut_yAcAk,FutPart_yAcAk_2Adj,When_yIncA,AfterDoing_yIp,Abil_yA,Abil_yAbil,Inf3_yIs,FeelLike_yAsI_2Adj,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn,Verb2Adv,Verb2Adj,Verb2NounPart,Verb2AdjPart,Verb2VerbAbility);
  Verb_De.connections.add(Neg_m,Neg_mA,Pos_EMPTY,Verb2Verb);
  Verb_De.indirectConnections.add(Verb_Default.indirectConnections).remove(Abil_yA,Abil_yAbil,Prog_Iyor,Fut_yAcAk,FutPart_yAcAk_2Adj,Opt_yA,PresPart_yAn,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn).add(Pass_In);
  Verb_Di.connections.add(Pos_EMPTY,Verb2Verb);
  Verb_Di.indirectConnections.add(Opt_yA,Fut_yAcAk,FutPart_yAcAk_2Adj,Abil_yA,Abil_yAbil,PresPart_yAn,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn,Verb2Adv);
  A3pl_lAr.connections.add(POSSESSIVE_FORMS).remove(P3pl_lArI).add(P3sg_yI,P3pl_I).remove(P3sg_sI);
  A3pl_lAr.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A3pl_Verb_lAr).add(CASE_FORMS).add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn).add(A1pl_yIz,A2pl_sInIz);
  A3pl_Comp_lAr.connections.add(A3pl_lAr.connections);
  A3pl_Comp_lAr.indirectConnections.add(CASE_FORMS).add(A1pl_yIz,A2pl_sInIz);
  A3sg_TEMPLATE.connections.add(POSSESSIVE_FORMS).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz);
  A3sg_TEMPLATE.indirectConnections.add(Noun_TEMPLATE.indirectConnections).remove(POSSESSIVE_FORMS).add(Gen_yIn).add(Noun2Noun.allConnections()).add(Noun2Noun).add(Noun2VerbCopular.allConnections()).add(Noun2Adj.allConnections().add(Noun2Adj));
  Nom_TEMPLATE.connections.add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular);
  Nom_TEMPLATE.indirectConnections.add(Noun2Noun.allConnections()).add(Noun2Adj.allConnections()).add(Noun2VerbCopular.allConnections()).add(Noun2Verb.allConnections());
  Pres_TEMPLATE.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr);
  Pres_TEMPLATE.indirectConnections.add(Cop_dIr);
  A1sg_yIm.connections.add(Cop_dIr);
  A2sg_sIn.connections.add(Cop_dIr);
  A3sg_Verb_TEMPLATE.connections.add(Cop_dIr,Verb2Adv);
  A3sg_Verb_TEMPLATE.indirectConnections.add(AsIf_cAsInA);
  A1pl_yIz.connections.add(Cop_dIr,Verb2Adv);
  A1pl_yIz.indirectConnections.add(AsIf_cAsInA);
  A2pl_sInIz.connections.add(Cop_dIr,Verb2Adv);
  A2pl_sInIz.indirectConnections.add(AsIf_cAsInA);
  A3pl_Verb_lAr.connections.add(Narr_mIs,Past_dI,Cond_sA,Cop_dIr,Verb2Adv);
  A3pl_Verb_lAr.indirectConnections.add(AsIf_cAsInA);
  Dim_cIk.connections.add(Noun_Default.connections);
  Dim_cIk.indirectConnections.add(Noun_Default.allConnections().add(Noun2VerbCopular).remove(Dim_cIk,Dim2_cAgIz));
  Agt_cI.connections.add(Noun_Default.connections);
  Agt_cI.indirectConnections.add(Noun_Default.allConnections().add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(Agt_cI));
  Dim2_cAgIz.connections.add(Noun_Default.connections);
  Dim2_cAgIz.indirectConnections.add(Noun_Default.allConnections().remove(Dim_cIk,Dim2_cAgIz));
  Ness_lIk.connections.add(Noun_Default.connections);
  Ness_lIk.indirectConnections.add(Noun_Default.allConnections().remove(Ness_lIk));
  Pnon_TEMPLATE.connections.add(CASE_FORMS).add(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Gen_yIn);
  Pnon_TEMPLATE.indirectConnections.add(Nom_TEMPLATE.connections).add(Noun2Noun.allConnections()).add(Noun2Verb.allConnections()).add(Noun2VerbCopular.allConnections()).add(Noun2Adj.allConnections());
  P1sg_Im.connections.add(CASE_FORMS);
  P1sg_Im.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A1pl_yIz,A1sg_yIm);
  P1sg_yIm.connections.add(CASE_FORMS);
  P1sg_yIm.indirectConnections.add(P1sg_Im.indirectConnections);
  P2sg_In.connections.add(CASE_FORMS);
  P2sg_In.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A2sg_sIn,A1pl_yIz,A2pl_nIz,A2pl_sInIz);
  P2sg_yIn.connections.add(CASE_FORMS);
  P2sg_yIn.indirectConnections.add(P2sg_In.indirectConnections);
  P3sg_sI.connections.add(Nom_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  P3sg_sI.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P3sg_yI.connections.add(P3sg_sI.connections);
  P3sg_yI.indirectConnections.add(P3sg_sI.indirectConnections);
  P1pl_ImIz.connections.add(CASE_FORMS);
  P1pl_ImIz.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A1pl_yIz);
  P1pl_yImIz.connections.add(CASE_FORMS);
  P1pl_yImIz.indirectConnections.add(P1pl_ImIz.indirectConnections);
  P2pl_InIz.connections.add(CASE_FORMS);
  P2pl_InIz.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P2pl_yInIz.connections.add(CASE_FORMS);
  P2pl_yInIz.indirectConnections.add(P2pl_InIz.indirectConnections);
  P3pl_lArI.connections.add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn);
  P3pl_lArI.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P3pl_I.connections.add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn);
  P3pl_I.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  With_lI.connections.add(Adj_TEMPLATE.connections);
  With_lI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Related_sAl.connections.add(Adj_TEMPLATE.connections);
  Related_sAl.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Without_sIz.connections.add(Adj_TEMPLATE.connections);
  Without_sIz.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  FitFor_lIk.connections.add(Adj_TEMPLATE.connections);
  FitFor_lIk.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Loc_dA.connections.add(Noun2Adj,Noun2VerbCopular);
  Loc_dA.indirectConnections.add(Rel_ki).add(Noun2VerbCopular.allConnections());
  Loc_ndA.connections.add(Noun2Adj,Noun2VerbCopular);
  Loc_ndA.indirectConnections.add(Rel_ki).add(Noun2VerbCopular.allConnections());
  Dat_nA.connections.add(Noun2VerbCopular);
  Dat_nA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Dat_yA.connections.add(Noun2VerbCopular);
  Dat_yA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Gen_nIn.connections.add(Noun2VerbCopular,Noun2Adj);
  Gen_nIn.indirectConnections.add(Noun2VerbCopular.allConnections()).add(Noun2Adj.connections);
  Dat_yA.connections.add(Noun2VerbCopular);
  Dat_yA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Abl_dAn.connections.add(Noun2VerbCopular);
  Abl_dAn.indirectConnections.add(Noun2VerbCopular.allConnections());
  Abl_ndAn.connections.add(Noun2VerbCopular);
  Abl_ndAn.indirectConnections.add(Noun2VerbCopular.allConnections());
  Inst_ylA.connections.add(Noun2VerbCopular);
  Inst_ylA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Equ_cA.connections.add(Noun2VerbCopular);
  Equ_cA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Rel_ki.connections.add(Adj2Noun);
  Rel_ki.indirectConnections.add(Adj2Noun.indirectConnections).add(A3sg_TEMPLATE,Pnon_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  Rel_kI.connections.add(Adj2Noun);
  Rel_kI.indirectConnections.add(Adj2Noun.indirectConnections).add(A3sg_TEMPLATE,Pnon_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  JustLike_msI.connections.add(Adj_TEMPLATE.connections);
  JustLike_msI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_ImsI.connections.add(Adj_TEMPLATE.connections);
  JustLike_ImsI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_Adj_msI.connections.add(Adj_TEMPLATE.connections);
  JustLike_Adj_msI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_Adj_ImsI.connections.add(Adj_TEMPLATE.connections);
  JustLike_Adj_ImsI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Become_lAs.connections.add(Verb_TEMPLATE.connections);
  Become_lAs.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Acquire_lAn.connections.add(Verb_TEMPLATE.connections);
  Acquire_lAn.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Become_Adj_lAs.connections.add(Verb_TEMPLATE.connections);
  Become_Adj_lAs.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Quite_cA.connections.add(Adj_TEMPLATE.connections);
  Ly_cA.connections.add(Adv_TEMPLATE.connections);
  Pos_EMPTY.connections.add(Verb2VerbCompounds,Verb2Noun,Verb2Adv,Verb2Adj,Verb2AdjPart,Verb2NounPart,Verb2VerbAbility,Imp_TEMPLATE,Prog_Iyor,Prog2_mAktA,Fut_yAcAk,Aor_Ar,Aor_Ir,Past_dI,Narr_mIs,ActOf_mAcA).add(Cond_sA,Necess_mAlI,Opt_yA,Des_sA);
  Pos_EMPTY.indirectConnections.add(Verb_Default.indirectConnections).add(A2pl2_sAnIzA,A2pl_yIn).add(Verb2AdjPart.connections,Verb2NounPart.connections).remove(Neg_m,Neg_mA);
  Neg_mA.connections.add(Verb2VerbCompounds,Verb2VerbAbility,Verb2Noun,Verb2Adv,Verb2Adj,Verb2AdjPart,Verb2NounPart,Aor_z,Aor_EMPTY,Prog2_mAktA,Imp_TEMPLATE,Opt_yA,Des_sA,Fut_yAcAk,Past_dI,Narr_mIs,Necess_mAlI,NotState_mAzlIk,ActOf_mAcA);
  Neg_mA.indirectConnections.add(Verb2VerbCompounds.connections,Verb2AdjPart.connections,Verb2NounPart.connections,Verb2Noun.connections,Verb2Adv.connections,Verb2Adj.connections).add(A2sg_TEMPLATE,A1sg_m,A1sg_yIm,A2sg_sIn,A2sg2_sAnA,A2sg3_yInIz,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A2pl2_sAnIzA,A2pl_yIn,A3pl_Verb_lAr,A3sg_sIn,A3pl_sInlAr).add(Abil_yAbil);
  Neg_m.connections.add(Prog_Iyor);
  Imp_TEMPLATE.connections.add(A2sg_TEMPLATE,A2sg2_sAnA,A2sg3_yInIz,A2pl2_sAnIzA,A2pl_yIn,A3sg_sIn,A3pl_sInlAr);
  Caus_t.connections.add(Verb2Verb,Pos_EMPTY,Neg_mA,Neg_m);
  Caus_t.indirectConnections.add(Verb_TEMPLATE.indirectConnections).add(Pass_nIl).add(Caus_tIr).remove(Caus_t);
  Caus_tIr.connections.add(Verb_TEMPLATE.connections);
  Caus_tIr.indirectConnections.add(Verb_TEMPLATE.indirectConnections).add(Pass_nIl).add(Caus_t).remove(Caus_tIr);
  Pass_nIl.connections.add(Verb_TEMPLATE.connections);
  Pass_nIl.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Pass_In.connections.add(Verb_TEMPLATE.connections);
  Pass_In.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Pass_InIl.connections.add(Verb_TEMPLATE.connections);
  Pass_InIl.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Prog_Iyor.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Prog2_mAktA.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Fut_yAcAk.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Fut_yAcAk.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  Aor_Ar.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Aor_Ar.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_Ir.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Aor_Ir.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_z.connections.add(A3sg_Verb_TEMPLATE,A3sg_sIn,A2pl_sInIz,A3pl_Verb_lAr).add(PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,Cop_dIr);
  Aor_z.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_EMPTY.connections.add(A1sg_m,A1pl_yIz);
  AorPart_Ar_2Adj.connections.add(Adj2Noun);
  AorPart_Ar_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  AorPart_Ir_2Adj.connections.add(Adj2Noun);
  AorPart_Ir_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  AorPart_z_2Adj.connections.add(Adj2Noun);
  AorPart_z_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  PastPart_dIk_2Noun.connections.add(A3sg_TEMPLATE).add(A3pl_lAr);
  PastPart_dIk_2Noun.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS).remove(Equ_cA);
  NarrPart_mIs_2Noun.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  NarrPart_mIs_2Noun.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS);
  FutPart_yAcAk_2Noun.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  FutPart_yAcAk_2Noun.indirectConnections.add(POSSESSIVE_FORMS);
  PastPart_dIk_2Adj.connections.add(POSSESSIVE_FORMS);
  PastPart_dIk_2Adj.indirectConnections.add(POSSESSIVE_FORMS).remove(CASE_FORMS);
  NarrPart_mIs_2Adj.connections.add(Adj2Noun);
  NarrPart_mIs_2Adj.indirectConnections.add(Ness_lIk).add(Ness_lIk.allConnections());
  PresPart_yAn.connections.add(Adj2Noun);
  PresPart_yAn.indirectConnections.add(Adj2Noun.allConnections());
  Past_dI.connections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr,CondCop_ysA,PastCop_ydI);
  A1sg_m.connections.add(Cond_sA_AfterPerson);
  A2sg_n.connections.add(Cond_sA_AfterPerson);
  A1pl_k.connections.add(Cond_sA_AfterPerson);
  A2pl_nIz.connections.add(Cond_sA_AfterPerson);
  A3pl_Verb_lAr.connections.add(Cond_sA_AfterPerson);
  Narr_mIs.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(CondCop_ysA,PastCop_ydI,NarrCop_ymIs,While_ken,Cop_dIr);
  Narr_mIs.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  Cond_sA.connections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr,PastCop_ydI,NarrCop_ymIs);
  PastCop_ydI.connections.add(PERSON_FORMS_COP);
  NarrCop_ymIs.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr);
  NarrCop_ymIs.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  CondCop_ysA.connections.add(PERSON_FORMS_COP);
  Cop_dIr.connections.add(A3pl_Verb_lAr);
  Inf1_mAk.connections.add(A3sg_TEMPLATE);
  Inf1_mAk.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,Inst_ylA,Loc_dA,Dat_yA,Abl_dAn,Acc_yI,Noun2Adj,Noun2Noun,Noun2VerbCopular);
  Inf1_mAk.indirectConnections.add(Noun2Adj.allConnections(),Noun2Noun.allConnections(),Noun2VerbCopular.allConnections());
  Inf1_mAk.indirectConnections.remove(Without_sIz);
  Inf2_mA.connections.add(Noun_Default.connections);
  Inf2_mA.indirectConnections.add(Noun_Default.indirectConnections);
  Inf3_yIs.connections.add(Noun_Default.connections);
  Inf3_yIs.indirectConnections.add(Noun_Default.indirectConnections);
  ActOf_mAcA.connections.add(Noun_Default.connections);
  ActOf_mAcA.indirectConnections.add(Noun_Default.indirectConnections);
  NotState_mAzlIk.connections.add(Noun_Default.connections);
  NotState_mAzlIk.indirectConnections.add(Noun_Default.indirectConnections);
  Abil_yA.connections.add(Neg_mA,Neg_m);
  Abil_yA.indirectConnections.add(Neg_mA.allConnections());
  Abil_yAbil.connections.add(Neg_mA.connections).add(Aor_Ir,Prog_Iyor).remove(Verb2VerbAbility);
  Abil_yAbil.indirectConnections.add(Neg_mA.indirectConnections);
  KeepDoing_yAgor.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  KeepDoing_yAgor.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  KeepDoing2_yAdur.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  KeepDoing2_yAdur.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  EverSince_yAgel.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  EverSince_yAgel.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Almost_yAyAz.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Almost_yAyAz.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Hastily_yIver.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Hastily_yIver.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Stay_yAkal.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Stay_yAkal.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Start_yAkoy.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Start_yAkoy.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Necess_mAlI.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Des_sA.connections.add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr,PastCop_ydI,NarrCop_ymIs);
  When_yIncA.connections.add(Adv2Noun);
  When_yIncA.indirectConnections.add(Adv2Noun.allConnections());
  While_ken.connections.add(Adv2Adj);
  While_ken.indirectConnections.add(Rel_ki);
  FeelLike_yAsI_2Noun.connections.add(Noun_Default.connections);
  FeelLike_yAsI_2Noun.indirectConnections.add(Noun_Default.indirectConnections);
  FeelLike_yAsI_2Adj.connections.add(Adj_TEMPLATE);
  Agt_yIcI_2Noun.connections.add(Noun_Default.connections);
  Agt_yIcI_2Noun.indirectConnections.add(Noun_Default.indirectConnections);
  Agt_yIcI_2Adj.connections.add(Adj_TEMPLATE);
  Opt_yA.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_lIm,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  A2pl_TEMPLATE.connections.add(Pnon_TEMPLATE);
  A2pl_TEMPLATE.indirectConnections.add(Pnon_TEMPLATE.allConnections());
  A2pl_ler.connections.add(Pnon_TEMPLATE);
  A2pl_ler.indirectConnections.add(Pnon_TEMPLATE.allConnections().remove(A3pl_Verb_lAr,A3pl_lAr,A3pl_sInlAr));
  A1pl_TEMPLATE.connections.add(Pnon_TEMPLATE,P1pl_ImIz);
  A1pl_TEMPLATE.indirectConnections.add(Pnon_TEMPLATE.allConnections());
  A1pl_ler.connections.add(Pnon_TEMPLATE);
  A1pl_ler.indirectConnections.add(Pnon_TEMPLATE.allConnections().remove(A3pl_Verb_lAr,A3pl_lAr,A3pl_sInlAr));
  PersPron_TEMPLATE.connections.add(A1sg_TEMPLATE,A2sg_TEMPLATE,A3sg_TEMPLATE,A1pl_TEMPLATE,A2pl_TEMPLATE);
  PersPron_TEMPLATE.indirectConnections.add(CASE_FORMS).add(Pnon_TEMPLATE).add(Noun2Verb,Noun2VerbCopular);
  PersPron_Ben.connections.add(A1sg_TEMPLATE);
  PersPron_Ben.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_Sen.connections.add(A2sg_TEMPLATE);
  PersPron_Sen.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_O.connections.add(A3sg_TEMPLATE);
  PersPron_O.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_Biz.connections.add(A1pl_TEMPLATE,A1pl_ler);
  PersPron_Biz.indirectConnections.add(A1pl_ler.allConnections());
  PersPron_Siz.connections.add(A2pl_TEMPLATE,A2pl_ler);
  PersPron_Siz.indirectConnections.add(A2pl_ler.allConnections());
  registerForms(Noun_TEMPLATE,Verb_TEMPLATE,Adj_TEMPLATE,Adv_TEMPLATE,Numeral_Template,Postp_Template,Dup_Template,PersPron_TEMPLATE,DemonsPron_TEMPLATE,ReflexPron_TEMPLATE,Det_Template,QuantPron_TEMPLATE,Conj_Template,Ques_Template,QuesPron_TEMPLATE,Punc_Template,Noun2Adj,Noun2Noun,Noun2Verb,Noun2VerbCopular,Adj2Adj,Adj2Adv,Adj2Noun,Adj2Verb,Verb2Adj,Verb2Verb,Verb2VerbCompounds,Verb2Noun,Verb2Adv,Postp2Noun,Pron2Verb,Pres_TEMPLATE,Noun_Default,Noun_Time_Default,Det_Default,ProperNoun_Default,Verb_Default,Adj_Default,Numeral_Default,Conj_Default,PersPron_Default,QuantPron_Default,DemonsPron_Default,ReflexPron_Default,Postp_Default,Dup_Default,Ques_Template,QuesPron_TEMPLATE,Punc_Default,JustLike_Adj_ImsI,JustLike_msI,Noun_Su_Root,Pass_InIl,Nom_TEMPLATE,Dat_yA,Dat_nA,Loc_dA,Loc_ndA,Abl_dAn,Abl_ndAn,Gen_nIn,Acc_yI,Acc_nI,Inst_ylA,Pnon_TEMPLATE,P1sg_Im,P2sg_In,P3sg_sI,P1pl_ImIz,P2pl_InIz,P3pl_lArI,P3pl_I,P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn,Dim_cIk,Dim2_cAgIz,With_lI,Without_sIz,Rel_ki,Rel_kI,A1sg_yIm,A1sg_m,A1sg_TEMPLATE,A2sg_sIn,A2sg_n,A2sg_TEMPLATE,A2sg2_sAnA,A3sg_TEMPLATE,A3sg_Verb_TEMPLATE,A2sg3_yInIz,A3sg_sIn,A1pl_yIz,A1pl_k,A1pl_lIm,A1pl_TEMPLATE,A1pl_ler,A2pl_sInIz,A2pl_nIz,A2pl_yIn,A2pl_TEMPLATE,A2pl2_sAnIzA,A2pl_ler,A3pl_lAr,A3pl_Verb_lAr,A3pl_sInlAr,A3pl_nlAr,Agt_cI,Agt_yIcI_2Adj,Agt_yIcI_2Noun,Num2Noun,Num2Adj,Num2Adv,Num2Verb,PersPron_Siz,PersPron_BanSan,PersPron_Biz,PersPron_O,PersPron_Sen,PersPron_BenSen,PersPron_Ben,Ness_lIk,FitFor_lIk,Become_lAs,Become_Adj_lAs,Acquire_lAn,JustLike_ImsI,JustLike_msI,Related_sAl,Aor_Ir,Aor_Ar,Aor_z,Des_sA,Aor_EMPTY,AorPart_Ar_2Adj,AorPart_Ir_2Adj,AorPart_z_2Adj,Prog_Iyor,Prog2_mAktA,Fut_yAcAk,FutPart_yAcAk_2Adj,FutPart_yAcAk_2Noun,Past_dI,PastPart_dIk_2Noun,PastPart_dIk_2Adj,Narr_mIs,NarrPart_mIs_2Adj,NarrPart_mIs_2Noun,PresPart_yAn,Neg_mA,Neg_m,Cond_sA,Cond_sA_AfterPerson,Necess_mAlI,Opt_yA,Pass_In,Pass_nIl,Caus_t,Caus_tIr,Imp_TEMPLATE,Reflex_In,Abil_yAbil,Abil_yA,Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,NotState_mAzlIk,ActOf_mAcA,AsIf_cAsInA,AsLongAs_dIkcA,When_yIncA,FeelLike_yAsI_2Adj,FeelLike_yAsI_2Noun,SinceDoing_yAlI,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn,AfterDoing_yIp,UnableToDo_yAmAdAn,InsteadOfDoing_mAktAnsA,KeepDoing_yAgor,KeepDoing2_yAdur,EverSince_yAgel,Start_yAkoy,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Inf1_mAk,Inf2_mA,Inf3_yIs,Ly_cA,Quite_cA,Equ_cA,Equ_ncA,UntilDoing_yAsIyA,A3pl_Comp_lAr,Interj_Template,Verb_Prog_Drop,PersPron_BenSen,PersPron_BanSan,Ordinal_IncI,Grouping_sAr);
}"
52722,"private void generateCaches(){
  this.dynamicCache=CacheBuilder.newBuilder().maximumSize(50000).concurrencyLevel(1).initialCapacity(20000).build(new CacheLoader<String,List<MorphParse>>(){
    @Override public List<MorphParse> load(    String s){
      if (s.length() == 0)       return Collections.emptyList();
      List<MorphParse> res=parser.parse(s);
      if (res.size() == 0) {
        res.addAll(unidentifiedTokenParser.parse(s));
      }
      if (res.size() == 0) {
        res.add(new MorphParse(DictionaryItem.UNKNOWN,s,Lists.newArrayList(MorphParse.InflectionalGroup.UNKNOWN)));
      }
      return res;
    }
  }
);
  try {
    List<String> words=Resources.readLines(Resources.getResource(""String_Node_Str""),Charsets.UTF_8);
    staticCache=new StaticMorphCache(parser,words);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void generateCaches(){
  this.dynamicCache=CacheBuilder.newBuilder().maximumSize(50000).concurrencyLevel(1).initialCapacity(20000).build(new MorphParseCacheLoader());
  try {
    List<String> words=Resources.readLines(Resources.getResource(""String_Node_Str""),Charsets.UTF_8);
    staticCache=new StaticMorphCache(parser,words);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
52723,"@Override public List<MorphParse> load(String s){
  if (s.length() == 0)   return Collections.emptyList();
  List<MorphParse> res=parser.parse(s);
  if (res.size() == 0) {
    res.addAll(unidentifiedTokenParser.parse(s));
  }
  if (res.size() == 0) {
    res.add(new MorphParse(DictionaryItem.UNKNOWN,s,Lists.newArrayList(MorphParse.InflectionalGroup.UNKNOWN)));
  }
  return res;
}","@Override public List<MorphParse> load(String s) throws Exception {
  if (s.length() == 0)   return Collections.emptyList();
  List<MorphParse> res=parser.parse(s);
  if (res.size() == 0) {
    res.addAll(quoteParseCheck(s));
  }
  if (res.size() == 0) {
    res.addAll(unidentifiedTokenParser.parse(s));
  }
  if (res.size() == 0) {
    res.add(new MorphParse(DictionaryItem.UNKNOWN,s,Lists.newArrayList(MorphParse.InflectionalGroup.UNKNOWN)));
  }
  return res;
}"
52724,"public List<MorphParse> parse(String word){
  List<MorphParse> results=Lists.newArrayList();
  if (!Strings.containsNone(word,""String_Node_Str"")) {
    results=parseNumeral(word);
    return results;
  }
  if (word.contains(""String_Node_Str"")) {
    StemAndEnding se=new StemAndEnding(Strings.subStringUntilFirst(word,""String_Node_Str""),Strings.subStringAfterFirst(word,""String_Node_Str""));
    String stem=normalize(se.stem);
    String ending=normalize(se.ending);
    String pron=guessPronunciation(stem);
    DictionaryItem itemProp=new DictionaryItem(Turkish.capitalize(stem),stem,pron,PrimaryPos.Noun,SecondaryPos.ProperNoun);
    itemProp.attributes.add(RootAttribute.Runtime);
    String toParse=stem + ending;
    graph.addDictionaryItem(itemProp);
    List<MorphParse> properResults=parser.parse(toParse);
    graph.removeDictionaryItem(itemProp);
    results.addAll(properResults);
  }
 else   if (Character.isUpperCase(word.charAt(0))) {
    String normalized=normalize(word);
    String pron=guessPronunciation(normalized);
    DictionaryItem itemProp=new DictionaryItem(Turkish.capitalize(normalized),normalized,pron,PrimaryPos.Noun,SecondaryPos.ProperNoun);
    itemProp.attributes.add(RootAttribute.Runtime);
    graph.addDictionaryItem(itemProp);
    List<MorphParse> properResults=parser.parse(normalized);
    graph.removeDictionaryItem(itemProp);
    results.addAll(properResults);
  }
  return results;
}","public List<MorphParse> parse(String word){
  List<MorphParse> results=Lists.newArrayListWithCapacity(2);
  if (!Strings.containsNone(word,""String_Node_Str"")) {
    results=parseNumeral(word);
    return results;
  }
  if (word.contains(""String_Node_Str"")) {
    StemAndEnding se=new StemAndEnding(Strings.subStringUntilFirst(word,""String_Node_Str""),Strings.subStringAfterFirst(word,""String_Node_Str""));
    String stem=normalize(se.stem);
    String ending=normalize(se.ending);
    String pron=guessPronunciation(stem);
    DictionaryItem itemProp=new DictionaryItem(Turkish.capitalize(stem),stem,pron,PrimaryPos.Noun,SecondaryPos.ProperNoun);
    itemProp.attributes.add(RootAttribute.Runtime);
    graph.addDictionaryItem(itemProp);
    String toParse=stem + ending;
    List<MorphParse> properResults=parser.parse(toParse);
    graph.removeDictionaryItem(itemProp);
    results.addAll(properResults);
  }
 else   if (Character.isUpperCase(word.charAt(0))) {
    String normalized=normalize(word);
    String pron=guessPronunciation(normalized);
    DictionaryItem itemProp=new DictionaryItem(Turkish.capitalize(normalized),normalized,pron,PrimaryPos.Noun,SecondaryPos.ProperNoun);
    itemProp.attributes.add(RootAttribute.Runtime);
    graph.addDictionaryItem(itemProp);
    List<MorphParse> properResults=parser.parse(normalized);
    graph.removeDictionaryItem(itemProp);
    results.addAll(properResults);
  }
  return results;
}"
52725,"@Test public void extractFromOflazerAnalysisResult() throws IOException {
  Path inPath=DATA_PATH.resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  List<String> lines=Files.readAllLines(inPath,StandardCharsets.UTF_8);
  Log.info(""String_Node_Str"");
  List<String> accepted=new ArrayList<>(lines.size() / 5);
  for (  String line : lines) {
    if (line.trim().length() == 0 || line.endsWith(""String_Node_Str"")) {
      continue;
    }
    accepted.add(line.substring(0,line.indexOf('\t')));
  }
  sortAndSave(DATA_PATH.resolve(""String_Node_Str"").resolve(""String_Node_Str""),accepted);
}","@Test public void extractFromOflazerAnalysisResult() throws IOException {
  Path inPath=DATA_PATH.resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  List<String> lines=Files.readAllLines(inPath,StandardCharsets.UTF_8);
  Log.info(""String_Node_Str"");
  LinkedHashSet<String> accepted=new LinkedHashSet<>(lines.size() / 5);
  for (  String line : lines) {
    if (line.trim().length() == 0 || line.endsWith(""String_Node_Str"")) {
      continue;
    }
    accepted.add(line.substring(0,line.indexOf('\t')));
  }
  sortAndSave(DATA_PATH.resolve(""String_Node_Str"").resolve(""String_Node_Str""),new ArrayList<>(accepted));
}"
52726,"public TurkishMorphParserBuilder addTextDictResources(String... resources) throws IOException {
  List<String> lines=new ArrayList<>();
  for (  String resource : resources) {
    lines.addAll(Resources.readLines(Resources.getResource(resource),Charsets.UTF_8));
  }
  lexicon.addAll(new TurkishDictionaryLoader(suffixProvider).load(lines));
  return this;
}","public TurkishMorphParserBuilder addTextDictResources(String... resources) throws IOException {
  Log.info(""String_Node_Str"");
  List<String> lines=new ArrayList<>();
  for (  String resource : resources) {
    lines.addAll(Resources.readLines(Resources.getResource(resource),Charsets.UTF_8));
  }
  lexicon.addAll(new TurkishDictionaryLoader(suffixProvider).load(lines));
  Log.info(""String_Node_Str"");
  return this;
}"
52727,"void split(String full,int start,int end,LinkedList<String> buffer,List<String> results,boolean findSingle){
  while (end <= full.length()) {
    String sub=full.substring(start,end);
    if (check(sub)) {
      if (end == full.length()) {
        if (buffer.size() < maxTokenCount) {
          results.add(Joiner.on(""String_Node_Str"").join(buffer) + ""String_Node_Str"" + sub);
          if (findSingle) {
            return;
          }
        }
      }
 else {
        buffer.add(sub);
        start=end;
        end=start + 1;
        break;
      }
    }
    end++;
  }
  if (end > full.length()) {
    if (buffer.size() == 0 || start == 0)     return;
    String last=buffer.removeLast();
    start=start - last.length();
    end=start + last.length() + 1;
  }
  split(full,start,end,buffer,results,findSingle);
}","void split(String full,int start,int end,LinkedList<String> buffer,List<String> results,boolean findSingle){
  while (end <= full.length()) {
    String sub=full.substring(start,end);
    if (check(sub)) {
      if (end == full.length()) {
        if (buffer.size() < maxTokenCount) {
          if (buffer.size() == 0)           results.add(sub);
 else           results.add(Joiner.on(""String_Node_Str"").join(buffer) + ""String_Node_Str"" + sub);
          if (findSingle) {
            return;
          }
        }
      }
 else {
        buffer.add(sub);
        start=end;
        end=start + 1;
        break;
      }
    }
    end++;
  }
  if (end > full.length()) {
    if (buffer.size() == 0 || start == 0)     return;
    String last=buffer.removeLast();
    start=start - last.length();
    end=start + last.length() + 1;
  }
  split(full,start,end,buffer,results,findSingle);
}"
52728,"public WordSetSegmenter(Collection<String> words){
  this.words=new HashSet<>(words);
}","public WordSetSegmenter(String... words){
  this.words=new HashSet<>(Arrays.asList(words));
}"
52729,"public String findFirst(String textToSegment){
  if (textToSegment.length() == 0)   return null;
  List<String> results=new ArrayList<>(2);
  LinkedList<String> buffer=new LinkedList<>();
  split(textToSegment,0,1,buffer,results,false);
  if (results.size() == 1)   return results.get(0);
 else   return null;
}","public String findFirst(String textToSegment){
  if (textToSegment.length() == 0)   return null;
  List<String> results=new ArrayList<>(2);
  LinkedList<String> buffer=new LinkedList<>();
  split(textToSegment,0,1,buffer,results,false);
  if (results.size() > 0)   return results.get(0);
 else   return null;
}"
52730,"@Test public void testNormalize16bitLittleEndian(){
  byte[] ba={0x10,0x71,0x18,0x54};
  float[] da=FloatArrays.normalize16bitLittleEndian(ba);
  Assert.assertEquals(da[0] * Short.MAX_VALUE,28944f,0.0001);
  Assert.assertEquals(da[1] * Short.MAX_VALUE,21528f,0.0001);
  byte[] ba2=FloatArrays.denormalize16BitLittleEndian(da);
  Assert.assertEquals(ba2[0],0x10);
  Assert.assertEquals(ba2[3],0x54);
  byte[] ba3=FloatArrays.denormalizeLittleEndian(da,16);
  Assert.assertEquals(ba3[0],0x10);
  Assert.assertEquals(ba3[3],0x54);
  byte[] ba4={(byte)0xCC,(byte)0xAB};
  da=FloatArrays.normalize16bitLittleEndian(ba4);
  Assert.assertEquals(da[0] * Short.MIN_VALUE,21556f);
}","@Test public void testNormalize16bitLittleEndian(){
  byte[] ba={0x10,0x71,0x18,0x54};
  float[] da=FloatArrays.normalize16bitLittleEndian(ba);
  Assert.assertEquals(da[0] * Short.MAX_VALUE,28944f,0.0001);
  Assert.assertEquals(da[1] * Short.MAX_VALUE,21528f,0.0001);
  byte[] ba2=FloatArrays.denormalize16BitLittleEndian(da);
  Assert.assertEquals(ba2[0],0x10);
  Assert.assertEquals(ba2[3],0x54);
  byte[] ba3=FloatArrays.denormalizeLittleEndian(da,16);
  Assert.assertEquals(ba3[0],0x10);
  Assert.assertEquals(ba3[3],0x54);
  byte[] ba4={(byte)0xCC,(byte)0xAB};
  da=FloatArrays.normalize16bitLittleEndian(ba4);
  Assert.assertEquals(da[0] * Short.MIN_VALUE,21556f,0.0001);
}"
52731,"@Test public void testLog2(){
  Assert.assertEquals(2,(int)LogMath.log2(4));
  Assert.assertEquals(3,(int)LogMath.log2(8));
  Assert.assertEquals(-1,(int)LogMath.log2(0.5));
}","@Test public void testLog2(){
  Assert.assertEquals(2,LogMath.log2(4),0.0001);
  Assert.assertEquals(3,LogMath.log2(8),0.0001);
  Assert.assertEquals(10,LogMath.log2(1024),0.0001);
  Assert.assertEquals(-1,LogMath.log2(0.5),0.0001);
}"
52732,"@Test public void logSumErrorFloat() throws IOException {
  int VALS=10000000;
  float[] logA=new float[VALS];
  for (int a=0; a < VALS; a++) {
    if (a == 0)     logA[a]=LogMath.LOG_ZERO_FLOAT;
 else     logA[a]=(float)Math.log((double)a / VALS);
  }
  Stopwatch sw=Stopwatch.createStarted();
  float maxError=0;
  float a=0;
  float b=0;
  for (int i=0; i < logA.length; i++) {
    float la=logA[i];
    float lb=logA[logA.length - i - 1];
    float exact=(float)LogMath.logSum(la,lb);
    float approx=LogMath.LOG_SUM_FLOAT.lookup(la,lb);
    float error=Math.abs(exact - approx);
    if (error > maxError) {
      maxError=error;
      a=la;
      b=lb;
    }
  }
  System.out.println(""String_Node_Str"" + maxError);
  System.out.println(""String_Node_Str"" + a + ""String_Node_Str""+ b);
  Assert.assertTrue(maxError < 0.0005);
  System.out.println(sw.elapsed(TimeUnit.MILLISECONDS));
  sw.stop();
}","@Test public void logSumErrorFloat() throws IOException {
  int VALS=10000000;
  float[] logA=new float[VALS];
  for (int a=0; a < VALS; a++) {
    if (a == 0)     logA[a]=LogMath.LOG_ZERO_FLOAT;
 else     logA[a]=(float)Math.log((double)a / VALS);
  }
  Stopwatch sw=Stopwatch.createStarted();
  float maxError=0;
  float a=0;
  float b=0;
  for (int i=0; i < logA.length; i++) {
    float la=logA[i];
    float lb=logA[logA.length - i - 1];
    float exact=(float)LogMath.logSum(la,lb);
    float approx=LogMath.LOG_SUM_FLOAT.lookup(la,lb);
    float error=Math.abs(exact - approx);
    if (error > maxError) {
      maxError=error;
      a=la;
      b=lb;
    }
  }
  System.out.println(""String_Node_Str"" + maxError);
  System.out.println(""String_Node_Str"" + a + ""String_Node_Str""+ b);
  Assert.assertTrue(maxError < 0.007);
  System.out.println(sw.elapsed(TimeUnit.MILLISECONDS));
  sw.stop();
}"
52733,"public TurkishSuffixes(){
  Noun_TEMPLATE.connections.add(A3pl_lAr,A3pl_Comp_lAr,A3sg_TEMPLATE);
  Noun_TEMPLATE.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,P3pl_I,Gen_yIn).add(Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken).add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz).add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr).add(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Equ_ncA).add(Dim_cIk,Dim2_cAgIz,With_lI,Without_sIz,Agt_cI,JustLike_msI,JustLike_ImsI,Ness_lIk,Related_sAl,FitFor_lIk).add(Become_lAs,Pres_TEMPLATE).add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular);
  Noun_Default.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  Noun_Default.indirectConnections.add(Noun_TEMPLATE.indirectConnections).remove(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Rel_kI).remove(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn);
  Noun_Time_Default.connections.add(Noun_Default.connections);
  Noun_Time_Default.indirectConnections.add(Noun_Default.indirectConnections).add(Rel_kI);
  DemonsPron_TEMPLATE.connections.add(A3sg_TEMPLATE,A3pl_nlAr,A1pl_TEMPLATE);
  DemonsPron_TEMPLATE.indirectConnections.add(With_lI,Inst_ylA,Without_sIz,Acc_nI,Dat_nA,Loc_ndA,Gen_nIn,Nom_TEMPLATE,Abl_ndAn,Cop_dIr,Pron2Verb,Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,A3pl_lAr).add(Pnon_TEMPLATE).add(Noun2Verb,Noun2VerbCopular);
  DemonsPron_Default.copyConnections(DemonsPron_TEMPLATE);
  QuesPron_Default.copyConnections(DemonsPron_TEMPLATE);
  QuantPron_Default.copyConnections(DemonsPron_TEMPLATE).connections.add(A3pl_lAr);
  QuantPron_Default.indirectConnections.add(P3sg_sI,P3pl_I,P1pl_ImIz).remove(P3sg_sI,P3sg_yI);
  PersPron_Default.copyConnections(DemonsPron_TEMPLATE);
  ReflexPron_Default.copyConnections(DemonsPron_TEMPLATE);
  ReflexPron_Default.indirectConnections.add(Dat_nA,P3sg_sI);
  ReflexPron_Default.connections.add(A2sg_TEMPLATE);
  Pron2Verb.connections.add(Noun2VerbCopular.connections);
  Pron2Verb.indirectConnections.add(Noun2VerbCopular.indirectConnections);
  Ques_Template.connections.add(Pres_TEMPLATE,NarrCop_ymIs,PastCop_ydI);
  Ques_Template.indirectConnections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A1pl_yIz,A2pl_sInIz);
  Ques_Default.copyConnections(Ques_Template);
  Numeral_Template.connections.add(Noun_TEMPLATE.connections);
  Numeral_Template.connections.add(Num2Noun,Num2Adj,Num2Adv,Num2Verb);
  Numeral_Template.indirectConnections.add(Noun_TEMPLATE.indirectConnections);
  Numeral_Default.connections.add(Num2Noun,Num2Adj,Num2Adv,Num2Verb);
  Numeral_Default.indirectConnections.add(Noun_TEMPLATE.allConnections());
  Noun2Noun.connections.add(Dim_cIk,Dim2_cAgIz,Agt_cI,Ness_lIk);
  Noun2Adj.connections.add(With_lI,Without_sIz,JustLike_msI,JustLike_ImsI,Rel_ki,Rel_kI,Related_sAl,FitFor_lIk);
  Noun2Verb.connections.add(Become_lAs);
  Noun2VerbCopular.connections.add(Pres_TEMPLATE,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken);
  Noun2VerbCopular.indirectConnections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr);
  Noun2VerbCopular.indirectConnections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,Cop_dIr);
  Adj2Noun.connections.add(Noun_TEMPLATE.connections);
  Adj2Noun.indirectConnections.add(Noun_Default.indirectConnections).remove(FitFor_lIk,Related_sAl,Become_lAs,JustLike_ImsI,JustLike_msI,Equ_cA,Equ_ncA);
  Postp2Noun.connections.add(Noun_TEMPLATE.connections);
  Postp2Noun.indirectConnections.add(Noun_Default.indirectConnections).remove(Related_sAl,Become_lAs,JustLike_ImsI,JustLike_msI,Equ_cA,Equ_ncA);
  Adj2Adj.connections.add(Quite_cA,JustLike_Adj_ImsI,JustLike_Adj_msI);
  Adj2Adv.connections.add(Ly_cA);
  Adj2Verb.connections.add(Become_Adj_lAs).add(COPULAR_FORMS);
  Num2Adj.connections.add(Quite_cA,JustLike_Adj_ImsI,JustLike_Adj_msI);
  Num2Noun.connections.add(Adj2Noun.connections);
  Num2Noun.indirectConnections.add(Adj2Noun.indirectConnections).remove(FitFor_lIk);
  Num2Verb.connections.add(Become_Adj_lAs).add(COPULAR_FORMS);
  Adv2Noun.connections.add(A3sg_TEMPLATE);
  Adv2Noun.indirectConnections.add(Pnon_TEMPLATE,Dat_yA);
  Adv2Adj.connections.add(Rel_ki);
  Verb2Verb.connections.add(Caus_t,Caus_tIr,Pass_In,Pass_nIl,Pass_InIl,Abil_yA);
  Verb2VerbCompounds.connections.add(KeepDoing_yAgor,KeepDoing2_yAdur,EverSince_yAgel,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Start_yAkoy);
  Verb2VerbAbility.connections.add(Abil_yAbil);
  Verb2Noun.connections.add(Inf1_mAk,Inf2_mA,Inf3_yIs,FeelLike_yAsI_2Noun,Agt_yIcI_2Noun,ActOf_mAcA,NotState_mAzlIk);
  Verb2NounPart.connections.add(PastPart_dIk_2Noun,NarrPart_mIs_2Noun,FutPart_yAcAk_2Noun);
  Verb2AdjPart.connections.add(PastPart_dIk_2Adj,NarrPart_mIs_2Adj,FutPart_yAcAk_2Adj,AorPart_Ar_2Adj,AorPart_Ir_2Adj,AorPart_z_2Adj,PresPart_yAn);
  Verb2Adv.connections.add(When_yIncA,SinceDoing_yAlI,UnableToDo_yAmAdAn,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn).add(InsteadOfDoing_mAktAnsA,AsLongAs_dIkcA,AfterDoing_yIp,AsIf_cAsInA);
  Verb2Adj.connections.add(When_yIncA,FeelLike_yAsI_2Adj,Agt_yIcI_2Adj);
  Adv_TEMPLATE.connections.add(Adv2Noun,Adv2Adj);
  Adj_TEMPLATE.connections.add(Adj2Noun,Adj2Adj,Adj2Adv,Adj2Verb);
  Adj_TEMPLATE.indirectConnections.add(Adj2Noun.allConnections(),Adj2Adj.allConnections(),Adj2Adv.allConnections(),Adj2Verb.allConnections());
  Postp_Template.connections.add(Postp2Noun);
  Postp_Template.indirectConnections.add(Postp2Noun.allConnections());
  Postp_Default.connections.add(Postp_Template.connections);
  Postp_Default.indirectConnections.add(Postp_Template.indirectConnections);
  Adj_Default.connections.add(Adj_TEMPLATE.connections);
  Adj_Default.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Noun_Comp_P3sg.connections.add(A3sg_TEMPLATE);
  Noun_Comp_P3sg.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,Pres_TEMPLATE).add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular).add(Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA).add(Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken).add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr).add(A1sg_yIm,A1pl_yIz,A2sg_sIn,A2pl_sInIz);
  Noun_Comp_P3sg_Root.connections.add(A3pl_Comp_lAr,A3sg_TEMPLATE);
  Noun_Comp_P3sg_Root.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,With_lI,Without_sIz,Agt_cI,JustLike_msI,JustLike_ImsI,Ness_lIk,Related_sAl).add(P3pl_lArI).add(POSSESSIVE_FORMS).add(Noun2Noun.allConnections()).add(Noun2Noun).add(Noun2Adj.allConnections()).add(Noun2Adj);
  Noun_Su_Root.connections.add(Noun_Default.connections);
  Noun_Su_Root.indirectConnections.add(Noun_Default.indirectConnections).remove(P1sg_Im,P2sg_In,P3sg_sI,P1pl_ImIz,P2pl_InIz,Gen_nIn).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn);
  ProperNoun_Template.connections.add(Noun_Default.connections);
  ProperNoun_Template.indirectConnections.add(Noun_Default.indirectConnections).remove(Related_sAl);
  ProperNoun_Default.copyConnections(ProperNoun_Template);
  Verb_TEMPLATE.connections.add(Neg_mA,Neg_m,Pos_EMPTY,Verb2Verb);
  Verb_TEMPLATE.indirectConnections.add(Prog_Iyor,Prog2_mAktA,Fut_yAcAk,Past_dI,Narr_mIs,Aor_Ir,Aor_Ar,Aor_z,AorPart_Ir_2Adj,AorPart_Ar_2Adj).add(Abil_yAbil,Abil_yA,Caus_tIr,Caus_t,Opt_yA,Imp_TEMPLATE,Agt_yIcI_2Adj,Agt_yIcI_2Noun,Des_sA).add(NotState_mAzlIk,ActOf_mAcA,PastPart_dIk_2Adj,PastPart_dIk_2Noun,NarrPart_mIs_2Adj,NarrPart_mIs_2Noun,Pass_In,Pass_nIl,Pass_InIl).add(FutPart_yAcAk_2Adj,FutPart_yAcAk_2Noun,PresPart_yAn,AsLongAs_dIkcA,A2pl2_sAnIzA).add(A1sg_yIm,A2sg_sIn,A2sg_TEMPLATE,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_yIn,A2pl_sInIz,A3pl_Verb_lAr,A3sg_sIn,A3pl_sInlAr,A2sg2_sAnA,A2sg3_yInIz).add(Inf1_mAk,Inf2_mA,Inf3_yIs,Necess_mAlI).add(Cond_sA,Cond_sA_AfterPerson).add(When_yIncA,FeelLike_yAsI_2Adj,FeelLike_yAsI_2Noun,SinceDoing_yAlI,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn).add(AfterDoing_yIp,When_yIncA,UnableToDo_yAmAdAn,InsteadOfDoing_mAktAnsA,A3pl_Verb_lAr_After_Tense,AsIf_cAsInA).add(KeepDoing2_yAdur,KeepDoing_yAgor,EverSince_yAgel,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Start_yAkoy).add(UntilDoing_yAsIyA,Verb2VerbCompounds,Verb2Noun,Verb2Adv,Verb2Adj,Verb2NounPart,Verb2AdjPart,Verb2VerbAbility);
  Verb_Default.connections.add(Verb_TEMPLATE.connections);
  Verb_Default.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t);
  Verb_Prog_Drop.connections.add(Pos_EMPTY);
  Verb_Prog_Drop.indirectConnections.add(Prog_Iyor).add(Prog_Iyor.allConnections());
  Verb_Ye.connections.add(Neg_m,Neg_mA,Pos_EMPTY,Verb2Verb);
  Verb_Ye.indirectConnections.add(Verb_Default.indirectConnections).remove(Abil_yA,Abil_yAbil,Prog_Iyor,Fut_yAcAk,Caus_tIr,FutPart_yAcAk_2Adj,Opt_yA,When_yIncA,AfterDoing_yIp,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,UnableToDo_yAmAdAn).add(Pass_In,Inf3_yIs);
  Verb_De_Ye_Prog.connections.add(Pos_EMPTY);
  Verb_De_Ye_Prog.indirectConnections.add(Prog_Iyor).add(Prog_Iyor.allConnections());
  Verb_Yi.connections.add(Pos_EMPTY,Verb2Verb);
  Verb_Yi.indirectConnections.add(Opt_yA,Fut_yAcAk,FutPart_yAcAk_2Adj,When_yIncA,AfterDoing_yIp,Abil_yA,Abil_yAbil,Inf3_yIs,FeelLike_yAsI_2Adj,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn,Verb2Adv,Verb2Adj,Verb2NounPart,Verb2AdjPart,Verb2VerbAbility);
  Verb_De.connections.add(Neg_m,Neg_mA,Pos_EMPTY,Verb2Verb);
  Verb_De.indirectConnections.add(Verb_Default.indirectConnections).remove(Abil_yA,Abil_yAbil,Prog_Iyor,Fut_yAcAk,FutPart_yAcAk_2Adj,Opt_yA,PresPart_yAn,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn).add(Pass_In);
  Verb_Di.connections.add(Pos_EMPTY,Verb2Verb);
  Verb_Di.indirectConnections.add(Opt_yA,Fut_yAcAk,FutPart_yAcAk_2Adj,Abil_yA,Abil_yAbil,PresPart_yAn,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn,Verb2Adv);
  A3pl_lAr.connections.add(POSSESSIVE_FORMS).remove(P3pl_lArI).add(P3sg_yI,P3pl_I).remove(P3sg_sI);
  A3pl_lAr.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A3pl_Verb_lAr).add(CASE_FORMS).add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn).add(A1pl_yIz,A2pl_sInIz);
  A3pl_Comp_lAr.connections.add(A3pl_lAr.connections);
  A3pl_Comp_lAr.indirectConnections.add(CASE_FORMS).add(A1pl_yIz,A2pl_sInIz);
  A3sg_TEMPLATE.connections.add(POSSESSIVE_FORMS).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz);
  A3sg_TEMPLATE.indirectConnections.add(Noun_TEMPLATE.indirectConnections).remove(POSSESSIVE_FORMS).add(Gen_yIn).add(Noun2Noun.allConnections()).add(Noun2Noun).add(Noun2VerbCopular.allConnections()).add(Noun2Adj.allConnections().add(Noun2Adj));
  Nom_TEMPLATE.connections.add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular);
  Nom_TEMPLATE.indirectConnections.add(Noun2Noun.allConnections()).add(Noun2Adj.allConnections()).add(Noun2VerbCopular.allConnections()).add(Noun2Verb.allConnections());
  Pres_TEMPLATE.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr);
  Pres_TEMPLATE.indirectConnections.add(Cop_dIr);
  A1sg_yIm.connections.add(Cop_dIr);
  A2sg_sIn.connections.add(Cop_dIr);
  A3sg_Verb_TEMPLATE.connections.add(Cop_dIr,Verb2Adv);
  A3sg_Verb_TEMPLATE.indirectConnections.add(AsIf_cAsInA);
  A1pl_yIz.connections.add(Cop_dIr,Verb2Adv);
  A1pl_yIz.indirectConnections.add(AsIf_cAsInA);
  A2pl_sInIz.connections.add(Cop_dIr,Verb2Adv);
  A2pl_sInIz.indirectConnections.add(AsIf_cAsInA);
  A3pl_Verb_lAr.connections.add(Narr_mIs,Past_dI,Cond_sA,Cop_dIr,Verb2Adv);
  A3pl_Verb_lAr.indirectConnections.add(AsIf_cAsInA);
  Dim_cIk.connections.add(Noun_Default.connections);
  Dim_cIk.indirectConnections.add(Noun_Default.allConnections().add(Noun2VerbCopular).remove(Dim_cIk,Dim2_cAgIz));
  Agt_cI.connections.add(Noun_Default.connections);
  Agt_cI.indirectConnections.add(Noun_Default.allConnections().add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(Agt_cI));
  Dim2_cAgIz.connections.add(Noun_Default.connections);
  Dim2_cAgIz.indirectConnections.add(Noun_Default.allConnections().remove(Dim_cIk,Dim2_cAgIz));
  Ness_lIk.connections.add(Noun_Default.connections);
  Ness_lIk.indirectConnections.add(Noun_Default.allConnections().remove(Ness_lIk));
  Pnon_TEMPLATE.connections.add(CASE_FORMS).add(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Gen_yIn);
  Pnon_TEMPLATE.indirectConnections.add(Nom_TEMPLATE.connections).add(Noun2Noun.allConnections()).add(Noun2Verb.allConnections()).add(Noun2VerbCopular.allConnections()).add(Noun2Adj.allConnections());
  P1sg_Im.connections.add(CASE_FORMS);
  P1sg_Im.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A1pl_yIz,A1sg_yIm);
  P1sg_yIm.connections.add(CASE_FORMS);
  P1sg_yIm.indirectConnections.add(P1sg_Im.indirectConnections);
  P2sg_In.connections.add(CASE_FORMS);
  P2sg_In.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A2sg_sIn,A1pl_yIz,A2pl_nIz,A2pl_sInIz);
  P2sg_yIn.connections.add(CASE_FORMS);
  P2sg_yIn.indirectConnections.add(P2sg_In.indirectConnections);
  P3sg_sI.connections.add(Nom_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  P3sg_sI.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P3sg_yI.connections.add(P3sg_sI.connections);
  P3sg_yI.indirectConnections.add(P3sg_sI.indirectConnections);
  P1pl_ImIz.connections.add(CASE_FORMS);
  P1pl_ImIz.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A1pl_yIz);
  P1pl_yImIz.connections.add(CASE_FORMS);
  P1pl_yImIz.indirectConnections.add(P1pl_ImIz.indirectConnections);
  P2pl_InIz.connections.add(CASE_FORMS);
  P2pl_InIz.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P2pl_yInIz.connections.add(CASE_FORMS);
  P2pl_yInIz.indirectConnections.add(P2pl_InIz.indirectConnections);
  P3pl_lArI.connections.add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn);
  P3pl_lArI.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P3pl_I.connections.add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn);
  P3pl_I.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  With_lI.connections.add(Adj_TEMPLATE.connections);
  With_lI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Related_sAl.connections.add(Adj_TEMPLATE.connections);
  Related_sAl.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Without_sIz.connections.add(Adj_TEMPLATE.connections);
  Without_sIz.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  FitFor_lIk.connections.add(Adj_TEMPLATE.connections);
  FitFor_lIk.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Loc_dA.connections.add(Noun2Adj,Noun2VerbCopular);
  Loc_dA.indirectConnections.add(Rel_ki).add(Noun2VerbCopular.allConnections());
  Loc_ndA.connections.add(Noun2Adj,Noun2VerbCopular);
  Loc_ndA.indirectConnections.add(Rel_ki).add(Noun2VerbCopular.allConnections());
  Dat_nA.connections.add(Noun2VerbCopular);
  Dat_nA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Dat_yA.connections.add(Noun2VerbCopular);
  Dat_yA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Gen_nIn.connections.add(Noun2VerbCopular,Noun2Adj);
  Gen_nIn.indirectConnections.add(Noun2VerbCopular.allConnections()).add(Noun2Adj.connections);
  Dat_yA.connections.add(Noun2VerbCopular);
  Dat_yA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Abl_dAn.connections.add(Noun2VerbCopular);
  Abl_dAn.indirectConnections.add(Noun2VerbCopular.allConnections());
  Abl_ndAn.connections.add(Noun2VerbCopular);
  Abl_ndAn.indirectConnections.add(Noun2VerbCopular.allConnections());
  Inst_ylA.connections.add(Noun2VerbCopular);
  Inst_ylA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Equ_cA.connections.add(Noun2VerbCopular);
  Equ_cA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Rel_ki.connections.add(Adj2Noun);
  Rel_ki.indirectConnections.add(Adj2Noun.indirectConnections).add(A3sg_TEMPLATE,Pnon_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  Rel_kI.connections.add(Adj2Noun);
  Rel_kI.indirectConnections.add(Adj2Noun.indirectConnections).add(A3sg_TEMPLATE,Pnon_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  JustLike_msI.connections.add(Adj_TEMPLATE.connections);
  JustLike_msI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_ImsI.connections.add(Adj_TEMPLATE.connections);
  JustLike_ImsI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_Adj_msI.connections.add(Adj_TEMPLATE.connections);
  JustLike_Adj_msI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_Adj_ImsI.connections.add(Adj_TEMPLATE.connections);
  JustLike_Adj_ImsI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Become_lAs.connections.add(Verb_TEMPLATE.connections);
  Become_lAs.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Become_Adj_lAs.connections.add(Verb_TEMPLATE.connections);
  Become_Adj_lAs.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Quite_cA.connections.add(Adj_TEMPLATE.connections);
  Ly_cA.connections.add(Adv_TEMPLATE.connections);
  Pos_EMPTY.connections.add(Verb2VerbCompounds,Verb2Noun,Verb2Adv,Verb2Adj,Verb2AdjPart,Verb2NounPart,Verb2VerbAbility,Imp_TEMPLATE,Prog_Iyor,Prog2_mAktA,Fut_yAcAk,Aor_Ar,Aor_Ir,Past_dI,Narr_mIs,ActOf_mAcA).add(Cond_sA,Necess_mAlI,Opt_yA,Des_sA);
  Pos_EMPTY.indirectConnections.add(Verb_Default.indirectConnections).add(A2pl2_sAnIzA,A2pl_yIn).add(Verb2AdjPart.connections,Verb2NounPart.connections).remove(Neg_m,Neg_mA);
  Neg_mA.connections.add(Verb2VerbCompounds,Verb2VerbAbility,Verb2Noun,Verb2Adv,Verb2Adj,Verb2AdjPart,Verb2NounPart,Aor_z,Aor_EMPTY,Prog2_mAktA,Imp_TEMPLATE,Opt_yA,Des_sA,Fut_yAcAk,Past_dI,Narr_mIs,Necess_mAlI,NotState_mAzlIk,ActOf_mAcA);
  Neg_mA.indirectConnections.add(Verb2VerbCompounds.connections,Verb2AdjPart.connections,Verb2NounPart.connections,Verb2Noun.connections,Verb2Adv.connections,Verb2Adj.connections).add(A2sg_TEMPLATE,A1sg_m,A1sg_yIm,A2sg_sIn,A2sg2_sAnA,A2sg3_yInIz,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A2pl2_sAnIzA,A2pl_yIn,A3pl_Verb_lAr,A3sg_sIn,A3pl_sInlAr).add(Abil_yAbil);
  Neg_m.connections.add(Prog_Iyor);
  Imp_TEMPLATE.connections.add(A2sg_TEMPLATE,A2sg2_sAnA,A2sg3_yInIz,A2pl2_sAnIzA,A2pl_yIn,A3sg_sIn,A3pl_sInlAr);
  Caus_t.connections.add(Verb2Verb,Pos_EMPTY,Neg_mA,Neg_m);
  Caus_t.indirectConnections.add(Verb_TEMPLATE.indirectConnections).add(Pass_nIl).add(Caus_tIr).remove(Caus_t);
  Caus_tIr.connections.add(Verb_TEMPLATE.connections);
  Caus_tIr.indirectConnections.add(Verb_TEMPLATE.indirectConnections).add(Pass_nIl).add(Caus_t).remove(Caus_tIr);
  Pass_nIl.connections.add(Verb_TEMPLATE.connections);
  Pass_nIl.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Pass_In.connections.add(Verb_TEMPLATE.connections);
  Pass_In.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Pass_InIl.connections.add(Verb_TEMPLATE.connections);
  Pass_InIl.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Prog_Iyor.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Prog2_mAktA.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Fut_yAcAk.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Fut_yAcAk.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  Aor_Ar.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Aor_Ar.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_Ir.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Aor_Ir.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_z.connections.add(A3sg_Verb_TEMPLATE,A3sg_sIn,A2pl_sInIz,A3pl_Verb_lAr).add(PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,Cop_dIr);
  Aor_z.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_EMPTY.connections.add(A1sg_m,A1pl_yIz);
  AorPart_Ar_2Adj.connections.add(Adj2Noun);
  AorPart_Ar_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  AorPart_Ir_2Adj.connections.add(Adj2Noun);
  AorPart_Ir_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  AorPart_z_2Adj.connections.add(Adj2Noun);
  AorPart_z_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  PastPart_dIk_2Noun.connections.add(A3sg_TEMPLATE).add(A3pl_lAr);
  PastPart_dIk_2Noun.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS).remove(Equ_cA);
  NarrPart_mIs_2Noun.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  NarrPart_mIs_2Noun.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS);
  FutPart_yAcAk_2Noun.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  FutPart_yAcAk_2Noun.indirectConnections.add(POSSESSIVE_FORMS);
  PastPart_dIk_2Adj.connections.add(POSSESSIVE_FORMS);
  PastPart_dIk_2Adj.indirectConnections.add(POSSESSIVE_FORMS).remove(CASE_FORMS);
  NarrPart_mIs_2Adj.connections.add(Adj2Noun);
  NarrPart_mIs_2Adj.indirectConnections.add(Ness_lIk).add(Ness_lIk.allConnections());
  PresPart_yAn.connections.add(Adj2Noun);
  PresPart_yAn.indirectConnections.add(Adj2Noun.allConnections());
  Past_dI.connections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr,CondCop_ysA,PastCop_ydI);
  A1sg_m.connections.add(Cond_sA_AfterPerson);
  A2sg_n.connections.add(Cond_sA_AfterPerson);
  A1pl_k.connections.add(Cond_sA_AfterPerson);
  A2pl_nIz.connections.add(Cond_sA_AfterPerson);
  A3pl_Verb_lAr.connections.add(Cond_sA_AfterPerson);
  Narr_mIs.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(CondCop_ysA,PastCop_ydI,NarrCop_ymIs,While_ken,Cop_dIr);
  Narr_mIs.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  Cond_sA.connections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr,PastCop_ydI,NarrCop_ymIs);
  PastCop_ydI.connections.add(PERSON_FORMS_COP);
  NarrCop_ymIs.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr);
  NarrCop_ymIs.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  CondCop_ysA.connections.add(PERSON_FORMS_COP);
  Cop_dIr.connections.add(A3pl_Verb_lAr);
  Inf1_mAk.connections.add(A3sg_TEMPLATE);
  Inf1_mAk.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,Inst_ylA,Loc_dA,Dat_yA,Abl_dAn,Acc_yI,Noun2Adj,Noun2Noun,Noun2VerbCopular);
  Inf1_mAk.indirectConnections.add(Noun2Adj.allConnections(),Noun2Noun.allConnections(),Noun2VerbCopular.allConnections());
  Inf1_mAk.indirectConnections.remove(Without_sIz);
  Inf2_mA.connections.add(Noun_Default.connections);
  Inf2_mA.indirectConnections.add(Noun_Default.indirectConnections);
  Inf3_yIs.connections.add(Noun_Default.connections);
  Inf3_yIs.indirectConnections.add(Noun_Default.indirectConnections);
  ActOf_mAcA.connections.add(Noun_Default.connections);
  ActOf_mAcA.indirectConnections.add(Noun_Default.indirectConnections);
  NotState_mAzlIk.connections.add(Noun_Default.connections);
  NotState_mAzlIk.indirectConnections.add(Noun_Default.indirectConnections);
  Abil_yA.connections.add(Neg_mA,Neg_m);
  Abil_yA.indirectConnections.add(Neg_mA.allConnections());
  Abil_yAbil.connections.add(Neg_mA.connections).add(Aor_Ir,Prog_Iyor).remove(Verb2VerbAbility);
  Abil_yAbil.indirectConnections.add(Neg_mA.indirectConnections);
  KeepDoing_yAgor.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  KeepDoing_yAgor.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  KeepDoing2_yAdur.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  KeepDoing2_yAdur.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  EverSince_yAgel.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  EverSince_yAgel.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Almost_yAyAz.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Almost_yAyAz.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Hastily_yIver.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Hastily_yIver.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Stay_yAkal.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Stay_yAkal.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Start_yAkoy.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Start_yAkoy.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Necess_mAlI.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Des_sA.connections.add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr,PastCop_ydI,NarrCop_ymIs);
  When_yIncA.connections.add(Adv2Noun);
  When_yIncA.indirectConnections.add(Adv2Noun.allConnections());
  While_ken.connections.add(Adv2Adj);
  While_ken.indirectConnections.add(Rel_ki);
  FeelLike_yAsI_2Noun.connections.add(Noun_Default.connections);
  FeelLike_yAsI_2Noun.indirectConnections.add(Noun_Default.indirectConnections);
  FeelLike_yAsI_2Adj.connections.add(Adj_TEMPLATE);
  Agt_yIcI_2Noun.connections.add(Noun_Default.connections);
  Agt_yIcI_2Noun.indirectConnections.add(Noun_Default.indirectConnections);
  Agt_yIcI_2Adj.connections.add(Adj_TEMPLATE);
  Opt_yA.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_lIm,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  A2pl_TEMPLATE.connections.add(Pnon_TEMPLATE);
  A2pl_TEMPLATE.indirectConnections.add(Pnon_TEMPLATE.allConnections());
  A2pl_ler.connections.add(Pnon_TEMPLATE);
  A2pl_ler.indirectConnections.add(Pnon_TEMPLATE.allConnections().remove(A3pl_Verb_lAr,A3pl_lAr,A3pl_sInlAr));
  A1pl_TEMPLATE.connections.add(Pnon_TEMPLATE,P1pl_ImIz);
  A1pl_TEMPLATE.indirectConnections.add(Pnon_TEMPLATE.allConnections());
  A1pl_ler.connections.add(Pnon_TEMPLATE);
  A1pl_ler.indirectConnections.add(Pnon_TEMPLATE.allConnections().remove(A3pl_Verb_lAr,A3pl_lAr,A3pl_sInlAr));
  PersPron_TEMPLATE.connections.add(A1sg_TEMPLATE,A2sg_TEMPLATE,A3sg_TEMPLATE,A1pl_TEMPLATE,A2pl_TEMPLATE);
  PersPron_TEMPLATE.indirectConnections.add(CASE_FORMS).add(Pnon_TEMPLATE).add(Noun2Verb,Noun2VerbCopular);
  PersPron_Ben.connections.add(A1sg_TEMPLATE);
  PersPron_Ben.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_Sen.connections.add(A2sg_TEMPLATE);
  PersPron_Sen.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_O.connections.add(A3sg_TEMPLATE);
  PersPron_O.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_Biz.connections.add(A1pl_TEMPLATE,A1pl_ler);
  PersPron_Biz.indirectConnections.add(A1pl_ler.allConnections());
  PersPron_Siz.connections.add(A2pl_TEMPLATE,A2pl_ler);
  PersPron_Siz.indirectConnections.add(A2pl_ler.allConnections());
  registerForms(Noun_TEMPLATE,Verb_TEMPLATE,Adj_TEMPLATE,Adv_TEMPLATE,Numeral_Template,Postp_Template,Dup_Template,PersPron_TEMPLATE,DemonsPron_TEMPLATE,ReflexPron_TEMPLATE,Det_Template,QuantPron_TEMPLATE,Conj_Template,Ques_Template,QuesPron_TEMPLATE,Punc_Template,Noun2Adj,Noun2Noun,Noun2Verb,Noun2VerbCopular,Adj2Adj,Adj2Adv,Adj2Noun,Adj2Verb,Verb2Adj,Verb2Verb,Verb2VerbCompounds,Verb2Noun,Verb2Adv,Postp2Noun,Pron2Verb,Pres_TEMPLATE,Noun_Default,Noun_Time_Default,Det_Default,ProperNoun_Default,Verb_Default,Adj_Default,Numeral_Default,Conj_Default,PersPron_Default,QuantPron_Default,DemonsPron_Default,ReflexPron_Default,Postp_Default,Dup_Default,Ques_Template,QuesPron_TEMPLATE,Punc_Default,JustLike_Adj_ImsI,JustLike_msI,Noun_Su_Root,Pass_InIl,Nom_TEMPLATE,Dat_yA,Dat_nA,Loc_dA,Loc_ndA,Abl_dAn,Abl_ndAn,Gen_nIn,Acc_yI,Acc_nI,Inst_ylA,Pnon_TEMPLATE,P1sg_Im,P2sg_In,P3sg_sI,P1pl_ImIz,P2pl_InIz,P3pl_lArI,P3pl_I,P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn,Dim_cIk,Dim2_cAgIz,With_lI,Without_sIz,Rel_ki,Rel_kI,A1sg_yIm,A1sg_m,A1sg_TEMPLATE,A2sg_sIn,A2sg_n,A2sg_TEMPLATE,A2sg2_sAnA,A3sg_TEMPLATE,A3sg_Verb_TEMPLATE,A2sg3_yInIz,A3sg_sIn,A1pl_yIz,A1pl_k,A1pl_lIm,A1pl_TEMPLATE,A1pl_ler,A2pl_sInIz,A2pl_nIz,A2pl_yIn,A2pl_TEMPLATE,A2pl2_sAnIzA,A2pl_ler,A3pl_lAr,A3pl_Verb_lAr,A3pl_sInlAr,A3pl_nlAr,Agt_cI,Agt_yIcI_2Adj,Agt_yIcI_2Noun,Num2Noun,Num2Adj,Num2Adv,Num2Verb,PersPron_Siz,PersPron_BanSan,PersPron_Biz,PersPron_O,PersPron_Sen,PersPron_BenSen,PersPron_Ben,Ness_lIk,FitFor_lIk,Become_lAs,Become_Adj_lAs,JustLike_ImsI,JustLike_msI,Related_sAl,Aor_Ir,Aor_Ar,Aor_z,Des_sA,Aor_EMPTY,AorPart_Ar_2Adj,AorPart_Ir_2Adj,AorPart_z_2Adj,Prog_Iyor,Prog2_mAktA,Fut_yAcAk,FutPart_yAcAk_2Adj,FutPart_yAcAk_2Noun,Past_dI,PastPart_dIk_2Noun,PastPart_dIk_2Adj,Narr_mIs,NarrPart_mIs_2Adj,NarrPart_mIs_2Noun,PresPart_yAn,Neg_mA,Neg_m,Cond_sA,Cond_sA_AfterPerson,Necess_mAlI,Opt_yA,Pass_In,Pass_nIl,Caus_t,Caus_tIr,Imp_TEMPLATE,Reflex_In,Abil_yAbil,Abil_yA,Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,NotState_mAzlIk,ActOf_mAcA,AsIf_cAsInA,AsLongAs_dIkcA,When_yIncA,FeelLike_yAsI_2Adj,FeelLike_yAsI_2Noun,SinceDoing_yAlI,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn,AfterDoing_yIp,UnableToDo_yAmAdAn,InsteadOfDoing_mAktAnsA,KeepDoing_yAgor,KeepDoing2_yAdur,EverSince_yAgel,Start_yAkoy,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Inf1_mAk,Inf2_mA,Inf3_yIs,Ly_cA,Quite_cA,Equ_cA,Equ_ncA,UntilDoing_yAsIyA,A3pl_Comp_lAr,Interj_Template,Verb_Prog_Drop,PersPron_BenSen,PersPron_BanSan,Ordinal_IncI,Grouping_sAr);
}","public TurkishSuffixes(){
  Noun_TEMPLATE.connections.add(A3pl_lAr,A3pl_Comp_lAr,A3sg_TEMPLATE);
  Noun_TEMPLATE.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,P3pl_I,Gen_yIn).add(Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken).add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz).add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr).add(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Equ_ncA).add(Dim_cIk,Dim2_cAgIz,With_lI,Without_sIz,Agt_cI,JustLike_msI,JustLike_ImsI,Ness_lIk,Related_sAl,FitFor_lIk).add(Become_lAs,Pres_TEMPLATE).add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular);
  Noun_Default.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  Noun_Default.indirectConnections.add(Noun_TEMPLATE.indirectConnections).remove(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Rel_kI).remove(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn);
  Noun_Time_Default.connections.add(Noun_Default.connections);
  Noun_Time_Default.indirectConnections.add(Noun_Default.indirectConnections).add(Rel_kI);
  DemonsPron_TEMPLATE.connections.add(A3sg_TEMPLATE,A3pl_nlAr,A1pl_TEMPLATE);
  DemonsPron_TEMPLATE.indirectConnections.add(With_lI,Inst_ylA,Without_sIz,Acc_nI,Dat_nA,Loc_ndA,Gen_nIn,Nom_TEMPLATE,Abl_ndAn,Cop_dIr,Pron2Verb,Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,A3pl_lAr).add(Pnon_TEMPLATE).add(Noun2Verb,Noun2VerbCopular);
  DemonsPron_Default.copyConnections(DemonsPron_TEMPLATE);
  QuesPron_Default.copyConnections(DemonsPron_TEMPLATE);
  QuantPron_Default.copyConnections(DemonsPron_TEMPLATE).connections.add(A3pl_lAr);
  QuantPron_Default.indirectConnections.add(P3sg_sI,P3pl_I,P1pl_ImIz).remove(P3sg_sI,P3sg_yI);
  PersPron_Default.copyConnections(DemonsPron_TEMPLATE);
  ReflexPron_Default.copyConnections(DemonsPron_TEMPLATE);
  ReflexPron_Default.indirectConnections.add(Dat_nA,P3sg_sI);
  ReflexPron_Default.connections.add(A2sg_TEMPLATE);
  Pron2Verb.connections.add(Noun2VerbCopular.connections);
  Pron2Verb.indirectConnections.add(Noun2VerbCopular.indirectConnections);
  Ques_Template.connections.add(Pres_TEMPLATE,NarrCop_ymIs,PastCop_ydI);
  Ques_Template.indirectConnections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A1pl_yIz,A2pl_sInIz);
  Ques_Default.copyConnections(Ques_Template);
  Numeral_Template.connections.add(Noun_TEMPLATE.connections);
  Numeral_Template.connections.add(Num2Noun,Num2Adj,Num2Adv,Num2Verb);
  Numeral_Template.indirectConnections.add(Noun_TEMPLATE.indirectConnections);
  Numeral_Default.connections.add(Num2Noun,Num2Adj,Num2Adv,Num2Verb);
  Numeral_Default.indirectConnections.add(Noun_TEMPLATE.allConnections());
  Noun2Noun.connections.add(Dim_cIk,Dim2_cAgIz,Agt_cI,Ness_lIk);
  Noun2Adj.connections.add(With_lI,Without_sIz,JustLike_msI,Rel_ki,Rel_kI,Related_sAl,FitFor_lIk);
  Noun2Verb.connections.add(Become_lAs);
  Noun2VerbCopular.connections.add(Pres_TEMPLATE,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken);
  Noun2VerbCopular.indirectConnections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr);
  Noun2VerbCopular.indirectConnections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,Cop_dIr);
  Adj2Noun.connections.add(Noun_TEMPLATE.connections);
  Adj2Noun.indirectConnections.add(Noun_Default.indirectConnections).remove(FitFor_lIk,Related_sAl,Become_lAs,JustLike_ImsI,JustLike_msI,Equ_cA,Equ_ncA);
  Postp2Noun.connections.add(Noun_TEMPLATE.connections);
  Postp2Noun.indirectConnections.add(Noun_Default.indirectConnections).remove(Related_sAl,Become_lAs,JustLike_ImsI,JustLike_msI,Equ_cA,Equ_ncA);
  Adj2Adj.connections.add(Quite_cA,JustLike_Adj_ImsI,JustLike_Adj_msI);
  Adj2Adv.connections.add(Ly_cA);
  Adj2Verb.connections.add(Become_Adj_lAs).add(COPULAR_FORMS);
  Num2Adj.connections.add(Quite_cA,JustLike_Adj_ImsI,JustLike_Adj_msI);
  Num2Noun.connections.add(Adj2Noun.connections);
  Num2Noun.indirectConnections.add(Adj2Noun.indirectConnections).remove(FitFor_lIk);
  Num2Verb.connections.add(Become_Adj_lAs).add(COPULAR_FORMS);
  Adv2Noun.connections.add(A3sg_TEMPLATE);
  Adv2Noun.indirectConnections.add(Pnon_TEMPLATE,Dat_yA);
  Adv2Adj.connections.add(Rel_ki);
  Verb2Verb.connections.add(Caus_t,Caus_tIr,Pass_In,Pass_nIl,Pass_InIl,Abil_yA);
  Verb2VerbCompounds.connections.add(KeepDoing_yAgor,KeepDoing2_yAdur,EverSince_yAgel,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Start_yAkoy);
  Verb2VerbAbility.connections.add(Abil_yAbil);
  Verb2Noun.connections.add(Inf1_mAk,Inf2_mA,Inf3_yIs,FeelLike_yAsI_2Noun,Agt_yIcI_2Noun,ActOf_mAcA,NotState_mAzlIk);
  Verb2NounPart.connections.add(PastPart_dIk_2Noun,NarrPart_mIs_2Noun,FutPart_yAcAk_2Noun);
  Verb2AdjPart.connections.add(PastPart_dIk_2Adj,NarrPart_mIs_2Adj,FutPart_yAcAk_2Adj,AorPart_Ar_2Adj,AorPart_Ir_2Adj,AorPart_z_2Adj,PresPart_yAn);
  Verb2Adv.connections.add(When_yIncA,SinceDoing_yAlI,UnableToDo_yAmAdAn,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn).add(InsteadOfDoing_mAktAnsA,AsLongAs_dIkcA,AfterDoing_yIp,AsIf_cAsInA);
  Verb2Adj.connections.add(When_yIncA,FeelLike_yAsI_2Adj,Agt_yIcI_2Adj);
  Adv_TEMPLATE.connections.add(Adv2Noun,Adv2Adj);
  Adj_TEMPLATE.connections.add(Adj2Noun,Adj2Adj,Adj2Adv,Adj2Verb);
  Adj_TEMPLATE.indirectConnections.add(Adj2Noun.allConnections(),Adj2Adj.allConnections(),Adj2Adv.allConnections(),Adj2Verb.allConnections());
  Postp_Template.connections.add(Postp2Noun);
  Postp_Template.indirectConnections.add(Postp2Noun.allConnections());
  Postp_Default.connections.add(Postp_Template.connections);
  Postp_Default.indirectConnections.add(Postp_Template.indirectConnections);
  Adj_Default.connections.add(Adj_TEMPLATE.connections);
  Adj_Default.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Noun_Comp_P3sg.connections.add(A3sg_TEMPLATE);
  Noun_Comp_P3sg.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,Pres_TEMPLATE).add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular).add(Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA).add(Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken).add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr).add(A1sg_yIm,A1pl_yIz,A2sg_sIn,A2pl_sInIz);
  Noun_Comp_P3sg_Root.connections.add(A3pl_Comp_lAr,A3sg_TEMPLATE);
  Noun_Comp_P3sg_Root.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,With_lI,Without_sIz,Agt_cI,JustLike_msI,JustLike_ImsI,Ness_lIk,Related_sAl).add(P3pl_lArI).add(POSSESSIVE_FORMS).add(Noun2Noun.allConnections()).add(Noun2Noun).add(Noun2Adj.allConnections()).add(Noun2Adj);
  Noun_Su_Root.connections.add(Noun_Default.connections);
  Noun_Su_Root.indirectConnections.add(Noun_Default.indirectConnections).remove(P1sg_Im,P2sg_In,P3sg_sI,P1pl_ImIz,P2pl_InIz,Gen_nIn).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn);
  ProperNoun_Template.connections.add(Noun_Default.connections);
  ProperNoun_Template.indirectConnections.add(Noun_Default.indirectConnections).remove(Related_sAl);
  ProperNoun_Default.copyConnections(ProperNoun_Template);
  Verb_TEMPLATE.connections.add(Neg_mA,Neg_m,Pos_EMPTY,Verb2Verb);
  Verb_TEMPLATE.indirectConnections.add(Prog_Iyor,Prog2_mAktA,Fut_yAcAk,Past_dI,Narr_mIs,Aor_Ir,Aor_Ar,Aor_z,AorPart_Ir_2Adj,AorPart_Ar_2Adj).add(Abil_yAbil,Abil_yA,Caus_tIr,Caus_t,Opt_yA,Imp_TEMPLATE,Agt_yIcI_2Adj,Agt_yIcI_2Noun,Des_sA).add(NotState_mAzlIk,ActOf_mAcA,PastPart_dIk_2Adj,PastPart_dIk_2Noun,NarrPart_mIs_2Adj,NarrPart_mIs_2Noun,Pass_In,Pass_nIl,Pass_InIl).add(FutPart_yAcAk_2Adj,FutPart_yAcAk_2Noun,PresPart_yAn,AsLongAs_dIkcA,A2pl2_sAnIzA).add(A1sg_yIm,A2sg_sIn,A2sg_TEMPLATE,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_yIn,A2pl_sInIz,A3pl_Verb_lAr,A3sg_sIn,A3pl_sInlAr,A2sg2_sAnA,A2sg3_yInIz).add(Inf1_mAk,Inf2_mA,Inf3_yIs,Necess_mAlI).add(Cond_sA,Cond_sA_AfterPerson).add(When_yIncA,FeelLike_yAsI_2Adj,FeelLike_yAsI_2Noun,SinceDoing_yAlI,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn).add(AfterDoing_yIp,When_yIncA,UnableToDo_yAmAdAn,InsteadOfDoing_mAktAnsA,A3pl_Verb_lAr_After_Tense,AsIf_cAsInA).add(KeepDoing2_yAdur,KeepDoing_yAgor,EverSince_yAgel,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Start_yAkoy).add(UntilDoing_yAsIyA,Verb2VerbCompounds,Verb2Noun,Verb2Adv,Verb2Adj,Verb2NounPart,Verb2AdjPart,Verb2VerbAbility);
  Verb_Default.connections.add(Verb_TEMPLATE.connections);
  Verb_Default.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t);
  Verb_Prog_Drop.connections.add(Pos_EMPTY);
  Verb_Prog_Drop.indirectConnections.add(Prog_Iyor).add(Prog_Iyor.allConnections());
  Verb_Ye.connections.add(Neg_m,Neg_mA,Pos_EMPTY,Verb2Verb);
  Verb_Ye.indirectConnections.add(Verb_Default.indirectConnections).remove(Abil_yA,Abil_yAbil,Prog_Iyor,Fut_yAcAk,Caus_tIr,FutPart_yAcAk_2Adj,Opt_yA,When_yIncA,AfterDoing_yIp,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,UnableToDo_yAmAdAn).add(Pass_In,Inf3_yIs);
  Verb_De_Ye_Prog.connections.add(Pos_EMPTY);
  Verb_De_Ye_Prog.indirectConnections.add(Prog_Iyor).add(Prog_Iyor.allConnections());
  Verb_Yi.connections.add(Pos_EMPTY,Verb2Verb);
  Verb_Yi.indirectConnections.add(Opt_yA,Fut_yAcAk,FutPart_yAcAk_2Adj,When_yIncA,AfterDoing_yIp,Abil_yA,Abil_yAbil,Inf3_yIs,FeelLike_yAsI_2Adj,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn,Verb2Adv,Verb2Adj,Verb2NounPart,Verb2AdjPart,Verb2VerbAbility);
  Verb_De.connections.add(Neg_m,Neg_mA,Pos_EMPTY,Verb2Verb);
  Verb_De.indirectConnections.add(Verb_Default.indirectConnections).remove(Abil_yA,Abil_yAbil,Prog_Iyor,Fut_yAcAk,FutPart_yAcAk_2Adj,Opt_yA,PresPart_yAn,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn).add(Pass_In);
  Verb_Di.connections.add(Pos_EMPTY,Verb2Verb);
  Verb_Di.indirectConnections.add(Opt_yA,Fut_yAcAk,FutPart_yAcAk_2Adj,Abil_yA,Abil_yAbil,PresPart_yAn,PresPart_yAn,KeepDoing_yAgor,KeepDoing2_yAdur,FeelLike_yAsI_2Adj,UnableToDo_yAmAdAn,Verb2Adv);
  A3pl_lAr.connections.add(POSSESSIVE_FORMS).remove(P3pl_lArI).add(P3sg_yI,P3pl_I).remove(P3sg_sI);
  A3pl_lAr.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A3pl_Verb_lAr).add(CASE_FORMS).add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn).add(A1pl_yIz,A2pl_sInIz);
  A3pl_Comp_lAr.connections.add(A3pl_lAr.connections);
  A3pl_Comp_lAr.indirectConnections.add(CASE_FORMS).add(A1pl_yIz,A2pl_sInIz);
  A3sg_TEMPLATE.connections.add(POSSESSIVE_FORMS).add(P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz);
  A3sg_TEMPLATE.indirectConnections.add(Noun_TEMPLATE.indirectConnections).remove(POSSESSIVE_FORMS).add(Gen_yIn).add(Noun2Noun.allConnections()).add(Noun2Noun).add(Noun2VerbCopular.allConnections()).add(Noun2Adj.allConnections().add(Noun2Adj));
  Nom_TEMPLATE.connections.add(Noun2Noun,Noun2Adj,Noun2Verb,Noun2VerbCopular);
  Nom_TEMPLATE.indirectConnections.add(Noun2Noun.allConnections()).add(Noun2Adj.allConnections()).add(Noun2VerbCopular.allConnections()).add(Noun2Verb.allConnections());
  Pres_TEMPLATE.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr);
  Pres_TEMPLATE.indirectConnections.add(Cop_dIr);
  A1sg_yIm.connections.add(Cop_dIr);
  A2sg_sIn.connections.add(Cop_dIr);
  A3sg_Verb_TEMPLATE.connections.add(Cop_dIr,Verb2Adv);
  A3sg_Verb_TEMPLATE.indirectConnections.add(AsIf_cAsInA);
  A1pl_yIz.connections.add(Cop_dIr,Verb2Adv);
  A1pl_yIz.indirectConnections.add(AsIf_cAsInA);
  A2pl_sInIz.connections.add(Cop_dIr,Verb2Adv);
  A2pl_sInIz.indirectConnections.add(AsIf_cAsInA);
  A3pl_Verb_lAr.connections.add(Narr_mIs,Past_dI,Cond_sA,Cop_dIr,Verb2Adv);
  A3pl_Verb_lAr.indirectConnections.add(AsIf_cAsInA);
  Dim_cIk.connections.add(Noun_Default.connections);
  Dim_cIk.indirectConnections.add(Noun_Default.allConnections().add(Noun2VerbCopular).remove(Dim_cIk,Dim2_cAgIz));
  Agt_cI.connections.add(Noun_Default.connections);
  Agt_cI.indirectConnections.add(Noun_Default.allConnections().add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(Agt_cI));
  Dim2_cAgIz.connections.add(Noun_Default.connections);
  Dim2_cAgIz.indirectConnections.add(Noun_Default.allConnections().remove(Dim_cIk,Dim2_cAgIz));
  Ness_lIk.connections.add(Noun_Default.connections);
  Ness_lIk.indirectConnections.add(Noun_Default.allConnections().remove(Ness_lIk));
  Pnon_TEMPLATE.connections.add(CASE_FORMS).add(Dat_nA,Loc_ndA,Abl_ndAn,Acc_nI,Gen_yIn);
  Pnon_TEMPLATE.indirectConnections.add(Nom_TEMPLATE.connections).add(Noun2Noun.allConnections()).add(Noun2Verb.allConnections()).add(Noun2VerbCopular.allConnections()).add(Noun2Adj.allConnections());
  P1sg_Im.connections.add(CASE_FORMS);
  P1sg_Im.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A1pl_yIz,A1sg_yIm);
  P1sg_yIm.connections.add(CASE_FORMS);
  P1sg_yIm.indirectConnections.add(P1sg_Im.indirectConnections);
  P2sg_In.connections.add(CASE_FORMS);
  P2sg_In.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A2sg_sIn,A1pl_yIz,A2pl_nIz,A2pl_sInIz);
  P2sg_yIn.connections.add(CASE_FORMS);
  P2sg_yIn.indirectConnections.add(P2sg_In.indirectConnections);
  P3sg_sI.connections.add(Nom_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  P3sg_sI.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P3sg_yI.connections.add(P3sg_sI.connections);
  P3sg_yI.indirectConnections.add(P3sg_sI.indirectConnections);
  P1pl_ImIz.connections.add(CASE_FORMS);
  P1pl_ImIz.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections()).remove(A1pl_yIz);
  P1pl_yImIz.connections.add(CASE_FORMS);
  P1pl_yImIz.indirectConnections.add(P1pl_ImIz.indirectConnections);
  P2pl_InIz.connections.add(CASE_FORMS);
  P2pl_InIz.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P2pl_yInIz.connections.add(CASE_FORMS);
  P2pl_yInIz.indirectConnections.add(P2pl_InIz.indirectConnections);
  P3pl_lArI.connections.add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn);
  P3pl_lArI.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  P3pl_I.connections.add(Dat_nA,Abl_ndAn,Loc_ndA,Acc_nI,Nom_TEMPLATE,Gen_nIn);
  P3pl_I.indirectConnections.add(Noun2VerbCopular).add(Noun2VerbCopular.allConnections());
  With_lI.connections.add(Adj_TEMPLATE.connections);
  With_lI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Related_sAl.connections.add(Adj_TEMPLATE.connections);
  Related_sAl.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Without_sIz.connections.add(Adj_TEMPLATE.connections);
  Without_sIz.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  FitFor_lIk.connections.add(Adj_TEMPLATE.connections);
  FitFor_lIk.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Loc_dA.connections.add(Noun2Adj,Noun2VerbCopular);
  Loc_dA.indirectConnections.add(Rel_ki).add(Noun2VerbCopular.allConnections());
  Loc_ndA.connections.add(Noun2Adj,Noun2VerbCopular);
  Loc_ndA.indirectConnections.add(Rel_ki).add(Noun2VerbCopular.allConnections());
  Dat_nA.connections.add(Noun2VerbCopular);
  Dat_nA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Dat_yA.connections.add(Noun2VerbCopular);
  Dat_yA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Gen_nIn.connections.add(Noun2VerbCopular,Noun2Adj);
  Gen_nIn.indirectConnections.add(Noun2VerbCopular.allConnections()).add(Noun2Adj.connections);
  Dat_yA.connections.add(Noun2VerbCopular);
  Dat_yA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Abl_dAn.connections.add(Noun2VerbCopular);
  Abl_dAn.indirectConnections.add(Noun2VerbCopular.allConnections());
  Abl_ndAn.connections.add(Noun2VerbCopular);
  Abl_ndAn.indirectConnections.add(Noun2VerbCopular.allConnections());
  Inst_ylA.connections.add(Noun2VerbCopular);
  Inst_ylA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Equ_cA.connections.add(Noun2VerbCopular);
  Equ_cA.indirectConnections.add(Noun2VerbCopular.allConnections());
  Rel_ki.connections.add(Adj2Noun);
  Rel_ki.indirectConnections.add(Adj2Noun.indirectConnections).add(A3sg_TEMPLATE,Pnon_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  Rel_kI.connections.add(Adj2Noun);
  Rel_kI.indirectConnections.add(Adj2Noun.indirectConnections).add(A3sg_TEMPLATE,Pnon_TEMPLATE,Dat_nA,Loc_ndA,Abl_ndAn,Gen_nIn,Acc_nI,Inst_ylA,Equ_ncA);
  JustLike_msI.connections.add(Adj_TEMPLATE.connections);
  JustLike_msI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_ImsI.connections.add(Adj_TEMPLATE.connections);
  JustLike_ImsI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_Adj_msI.connections.add(Adj_TEMPLATE.connections);
  JustLike_Adj_msI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  JustLike_Adj_ImsI.connections.add(Adj_TEMPLATE.connections);
  JustLike_Adj_ImsI.indirectConnections.add(Adj_TEMPLATE.indirectConnections);
  Become_lAs.connections.add(Verb_TEMPLATE.connections);
  Become_lAs.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Become_Adj_lAs.connections.add(Verb_TEMPLATE.connections);
  Become_Adj_lAs.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Pass_In,Pass_InIl);
  Quite_cA.connections.add(Adj_TEMPLATE.connections);
  Ly_cA.connections.add(Adv_TEMPLATE.connections);
  Pos_EMPTY.connections.add(Verb2VerbCompounds,Verb2Noun,Verb2Adv,Verb2Adj,Verb2AdjPart,Verb2NounPart,Verb2VerbAbility,Imp_TEMPLATE,Prog_Iyor,Prog2_mAktA,Fut_yAcAk,Aor_Ar,Aor_Ir,Past_dI,Narr_mIs,ActOf_mAcA).add(Cond_sA,Necess_mAlI,Opt_yA,Des_sA);
  Pos_EMPTY.indirectConnections.add(Verb_Default.indirectConnections).add(A2pl2_sAnIzA,A2pl_yIn).add(Verb2AdjPart.connections,Verb2NounPart.connections).remove(Neg_m,Neg_mA);
  Neg_mA.connections.add(Verb2VerbCompounds,Verb2VerbAbility,Verb2Noun,Verb2Adv,Verb2Adj,Verb2AdjPart,Verb2NounPart,Aor_z,Aor_EMPTY,Prog2_mAktA,Imp_TEMPLATE,Opt_yA,Des_sA,Fut_yAcAk,Past_dI,Narr_mIs,Necess_mAlI,NotState_mAzlIk,ActOf_mAcA);
  Neg_mA.indirectConnections.add(Verb2VerbCompounds.connections,Verb2AdjPart.connections,Verb2NounPart.connections,Verb2Noun.connections,Verb2Adv.connections,Verb2Adj.connections).add(A2sg_TEMPLATE,A1sg_m,A1sg_yIm,A2sg_sIn,A2sg2_sAnA,A2sg3_yInIz,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A2pl2_sAnIzA,A2pl_yIn,A3pl_Verb_lAr,A3sg_sIn,A3pl_sInlAr).add(Abil_yAbil);
  Neg_m.connections.add(Prog_Iyor);
  Imp_TEMPLATE.connections.add(A2sg_TEMPLATE,A2sg2_sAnA,A2sg3_yInIz,A2pl2_sAnIzA,A2pl_yIn,A3sg_sIn,A3pl_sInlAr);
  Caus_t.connections.add(Verb2Verb,Pos_EMPTY,Neg_mA,Neg_m);
  Caus_t.indirectConnections.add(Verb_TEMPLATE.indirectConnections).add(Pass_nIl).add(Caus_tIr).remove(Caus_t);
  Caus_tIr.connections.add(Verb_TEMPLATE.connections);
  Caus_tIr.indirectConnections.add(Verb_TEMPLATE.indirectConnections).add(Pass_nIl).add(Caus_t).remove(Caus_tIr);
  Pass_nIl.connections.add(Verb_TEMPLATE.connections);
  Pass_nIl.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Pass_In.connections.add(Verb_TEMPLATE.connections);
  Pass_In.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Pass_InIl.connections.add(Verb_TEMPLATE.connections);
  Pass_InIl.indirectConnections.add(Verb_TEMPLATE.indirectConnections).remove(Caus_t,Caus_tIr,Pass_nIl,Pass_InIl,Pass_In);
  Prog_Iyor.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Prog2_mAktA.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Fut_yAcAk.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Fut_yAcAk.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  Aor_Ar.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Aor_Ar.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_Ir.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Aor_Ir.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_z.connections.add(A3sg_Verb_TEMPLATE,A3sg_sIn,A2pl_sInIz,A3pl_Verb_lAr).add(PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,Cop_dIr);
  Aor_z.indirectConnections.add(Verb2Adv,AsIf_cAsInA);
  Aor_EMPTY.connections.add(A1sg_m,A1pl_yIz);
  AorPart_Ar_2Adj.connections.add(Adj2Noun);
  AorPart_Ar_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  AorPart_Ir_2Adj.connections.add(Adj2Noun);
  AorPart_Ir_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  AorPart_z_2Adj.connections.add(Adj2Noun);
  AorPart_z_2Adj.indirectConnections.add(Adj2Noun.allConnections());
  PastPart_dIk_2Noun.connections.add(A3sg_TEMPLATE).add(A3pl_lAr);
  PastPart_dIk_2Noun.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS).remove(Equ_cA);
  NarrPart_mIs_2Noun.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  NarrPart_mIs_2Noun.indirectConnections.add(POSSESSIVE_FORMS,CASE_FORMS);
  FutPart_yAcAk_2Noun.connections.add(A3pl_lAr,A3sg_TEMPLATE);
  FutPart_yAcAk_2Noun.indirectConnections.add(POSSESSIVE_FORMS);
  PastPart_dIk_2Adj.connections.add(POSSESSIVE_FORMS);
  PastPart_dIk_2Adj.indirectConnections.add(POSSESSIVE_FORMS).remove(CASE_FORMS);
  NarrPart_mIs_2Adj.connections.add(Adj2Noun);
  NarrPart_mIs_2Adj.indirectConnections.add(Ness_lIk).add(Ness_lIk.allConnections());
  PresPart_yAn.connections.add(Adj2Noun);
  PresPart_yAn.indirectConnections.add(Adj2Noun.allConnections());
  Past_dI.connections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr,CondCop_ysA,PastCop_ydI);
  A1sg_m.connections.add(Cond_sA_AfterPerson);
  A2sg_n.connections.add(Cond_sA_AfterPerson);
  A1pl_k.connections.add(Cond_sA_AfterPerson);
  A2pl_nIz.connections.add(Cond_sA_AfterPerson);
  A3pl_Verb_lAr.connections.add(Cond_sA_AfterPerson);
  Narr_mIs.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(CondCop_ysA,PastCop_ydI,NarrCop_ymIs,While_ken,Cop_dIr);
  Narr_mIs.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  Cond_sA.connections.add(A1sg_m,A2sg_n,A3sg_Verb_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_Verb_lAr,PastCop_ydI,NarrCop_ymIs);
  PastCop_ydI.connections.add(PERSON_FORMS_COP);
  NarrCop_ymIs.connections.add(A1sg_yIm,A2sg_sIn,A3sg_Verb_TEMPLATE,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr);
  NarrCop_ymIs.indirectConnections.add(A3sg_Verb_TEMPLATE.allConnections());
  CondCop_ysA.connections.add(PERSON_FORMS_COP);
  Cop_dIr.connections.add(A3pl_Verb_lAr);
  Inf1_mAk.connections.add(A3sg_TEMPLATE);
  Inf1_mAk.indirectConnections.add(Pnon_TEMPLATE,Nom_TEMPLATE,Inst_ylA,Loc_dA,Dat_yA,Abl_dAn,Acc_yI,Noun2Adj,Noun2Noun,Noun2VerbCopular);
  Inf1_mAk.indirectConnections.add(Noun2Adj.allConnections(),Noun2Noun.allConnections(),Noun2VerbCopular.allConnections());
  Inf1_mAk.indirectConnections.remove(Without_sIz);
  Inf2_mA.connections.add(Noun_Default.connections);
  Inf2_mA.indirectConnections.add(Noun_Default.indirectConnections);
  Inf3_yIs.connections.add(Noun_Default.connections);
  Inf3_yIs.indirectConnections.add(Noun_Default.indirectConnections);
  ActOf_mAcA.connections.add(Noun_Default.connections);
  ActOf_mAcA.indirectConnections.add(Noun_Default.indirectConnections);
  NotState_mAzlIk.connections.add(Noun_Default.connections);
  NotState_mAzlIk.indirectConnections.add(Noun_Default.indirectConnections);
  Abil_yA.connections.add(Neg_mA,Neg_m);
  Abil_yA.indirectConnections.add(Neg_mA.allConnections());
  Abil_yAbil.connections.add(Neg_mA.connections).add(Aor_Ir,Prog_Iyor).remove(Verb2VerbAbility);
  Abil_yAbil.indirectConnections.add(Neg_mA.indirectConnections);
  KeepDoing_yAgor.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  KeepDoing_yAgor.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  KeepDoing2_yAdur.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  KeepDoing2_yAdur.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  EverSince_yAgel.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  EverSince_yAgel.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Almost_yAyAz.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Almost_yAyAz.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Hastily_yIver.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Hastily_yIver.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Stay_yAkal.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Stay_yAkal.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Start_yAkoy.connections.add(Pos_EMPTY.connections,Neg_mA.connections);
  Start_yAkoy.indirectConnections.add(Pos_EMPTY.indirectConnections,Neg_mA.indirectConnections);
  Necess_mAlI.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_yIz,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  Des_sA.connections.add(A1sg_m,A2sg_n,A3sg_TEMPLATE,A1pl_k,A2pl_nIz,A3pl_lAr,PastCop_ydI,NarrCop_ymIs);
  When_yIncA.connections.add(Adv2Noun);
  When_yIncA.indirectConnections.add(Adv2Noun.allConnections());
  While_ken.connections.add(Adv2Adj);
  While_ken.indirectConnections.add(Rel_ki);
  FeelLike_yAsI_2Noun.connections.add(Noun_Default.connections);
  FeelLike_yAsI_2Noun.indirectConnections.add(Noun_Default.indirectConnections);
  FeelLike_yAsI_2Adj.connections.add(Adj_TEMPLATE);
  Agt_yIcI_2Noun.connections.add(Noun_Default.connections);
  Agt_yIcI_2Noun.indirectConnections.add(Noun_Default.indirectConnections);
  Agt_yIcI_2Adj.connections.add(Adj_TEMPLATE);
  Opt_yA.connections.add(A3sg_Verb_TEMPLATE,A1sg_yIm,A2sg_sIn,A1pl_lIm,A2pl_sInIz,A3pl_Verb_lAr).add(COPULAR_FORMS);
  A2pl_TEMPLATE.connections.add(Pnon_TEMPLATE);
  A2pl_TEMPLATE.indirectConnections.add(Pnon_TEMPLATE.allConnections());
  A2pl_ler.connections.add(Pnon_TEMPLATE);
  A2pl_ler.indirectConnections.add(Pnon_TEMPLATE.allConnections().remove(A3pl_Verb_lAr,A3pl_lAr,A3pl_sInlAr));
  A1pl_TEMPLATE.connections.add(Pnon_TEMPLATE,P1pl_ImIz);
  A1pl_TEMPLATE.indirectConnections.add(Pnon_TEMPLATE.allConnections());
  A1pl_ler.connections.add(Pnon_TEMPLATE);
  A1pl_ler.indirectConnections.add(Pnon_TEMPLATE.allConnections().remove(A3pl_Verb_lAr,A3pl_lAr,A3pl_sInlAr));
  PersPron_TEMPLATE.connections.add(A1sg_TEMPLATE,A2sg_TEMPLATE,A3sg_TEMPLATE,A1pl_TEMPLATE,A2pl_TEMPLATE);
  PersPron_TEMPLATE.indirectConnections.add(CASE_FORMS).add(Pnon_TEMPLATE).add(Noun2Verb,Noun2VerbCopular);
  PersPron_Ben.connections.add(A1sg_TEMPLATE);
  PersPron_Ben.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_Sen.connections.add(A2sg_TEMPLATE);
  PersPron_Sen.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_O.connections.add(A3sg_TEMPLATE);
  PersPron_O.indirectConnections.add(PersPron_TEMPLATE.indirectConnections);
  PersPron_Biz.connections.add(A1pl_TEMPLATE,A1pl_ler);
  PersPron_Biz.indirectConnections.add(A1pl_ler.allConnections());
  PersPron_Siz.connections.add(A2pl_TEMPLATE,A2pl_ler);
  PersPron_Siz.indirectConnections.add(A2pl_ler.allConnections());
  registerForms(Noun_TEMPLATE,Verb_TEMPLATE,Adj_TEMPLATE,Adv_TEMPLATE,Numeral_Template,Postp_Template,Dup_Template,PersPron_TEMPLATE,DemonsPron_TEMPLATE,ReflexPron_TEMPLATE,Det_Template,QuantPron_TEMPLATE,Conj_Template,Ques_Template,QuesPron_TEMPLATE,Punc_Template,Noun2Adj,Noun2Noun,Noun2Verb,Noun2VerbCopular,Adj2Adj,Adj2Adv,Adj2Noun,Adj2Verb,Verb2Adj,Verb2Verb,Verb2VerbCompounds,Verb2Noun,Verb2Adv,Postp2Noun,Pron2Verb,Pres_TEMPLATE,Noun_Default,Noun_Time_Default,Det_Default,ProperNoun_Default,Verb_Default,Adj_Default,Numeral_Default,Conj_Default,PersPron_Default,QuantPron_Default,DemonsPron_Default,ReflexPron_Default,Postp_Default,Dup_Default,Ques_Template,QuesPron_TEMPLATE,Punc_Default,JustLike_Adj_ImsI,JustLike_msI,Noun_Su_Root,Pass_InIl,Nom_TEMPLATE,Dat_yA,Dat_nA,Loc_dA,Loc_ndA,Abl_dAn,Abl_ndAn,Gen_nIn,Acc_yI,Acc_nI,Inst_ylA,Pnon_TEMPLATE,P1sg_Im,P2sg_In,P3sg_sI,P1pl_ImIz,P2pl_InIz,P3pl_lArI,P3pl_I,P1sg_yIm,P2sg_yIn,P3sg_yI,P1pl_yImIz,P2pl_yInIz,Gen_yIn,Dim_cIk,Dim2_cAgIz,With_lI,Without_sIz,Rel_ki,Rel_kI,A1sg_yIm,A1sg_m,A1sg_TEMPLATE,A2sg_sIn,A2sg_n,A2sg_TEMPLATE,A2sg2_sAnA,A3sg_TEMPLATE,A3sg_Verb_TEMPLATE,A2sg3_yInIz,A3sg_sIn,A1pl_yIz,A1pl_k,A1pl_lIm,A1pl_TEMPLATE,A1pl_ler,A2pl_sInIz,A2pl_nIz,A2pl_yIn,A2pl_TEMPLATE,A2pl2_sAnIzA,A2pl_ler,A3pl_lAr,A3pl_Verb_lAr,A3pl_sInlAr,A3pl_nlAr,Agt_cI,Agt_yIcI_2Adj,Agt_yIcI_2Noun,Num2Noun,Num2Adj,Num2Adv,Num2Verb,PersPron_Siz,PersPron_BanSan,PersPron_Biz,PersPron_O,PersPron_Sen,PersPron_BenSen,PersPron_Ben,Ness_lIk,FitFor_lIk,Become_lAs,Become_Adj_lAs,JustLike_ImsI,JustLike_msI,Related_sAl,Aor_Ir,Aor_Ar,Aor_z,Des_sA,Aor_EMPTY,AorPart_Ar_2Adj,AorPart_Ir_2Adj,AorPart_z_2Adj,Prog_Iyor,Prog2_mAktA,Fut_yAcAk,FutPart_yAcAk_2Adj,FutPart_yAcAk_2Noun,Past_dI,PastPart_dIk_2Noun,PastPart_dIk_2Adj,Narr_mIs,NarrPart_mIs_2Adj,NarrPart_mIs_2Noun,PresPart_yAn,Neg_mA,Neg_m,Cond_sA,Cond_sA_AfterPerson,Necess_mAlI,Opt_yA,Pass_In,Pass_nIl,Caus_t,Caus_tIr,Imp_TEMPLATE,Reflex_In,Abil_yAbil,Abil_yA,Cop_dIr,PastCop_ydI,NarrCop_ymIs,CondCop_ysA,While_ken,NotState_mAzlIk,ActOf_mAcA,AsIf_cAsInA,AsLongAs_dIkcA,When_yIncA,FeelLike_yAsI_2Adj,FeelLike_yAsI_2Noun,SinceDoing_yAlI,ByDoing_yArAk,WithoutDoing_mAdAn,WithoutDoing2_mAksIzIn,AfterDoing_yIp,UnableToDo_yAmAdAn,InsteadOfDoing_mAktAnsA,KeepDoing_yAgor,KeepDoing2_yAdur,EverSince_yAgel,Start_yAkoy,Almost_yAyAz,Hastily_yIver,Stay_yAkal,Inf1_mAk,Inf2_mA,Inf3_yIs,Ly_cA,Quite_cA,Equ_cA,Equ_ncA,UntilDoing_yAsIyA,A3pl_Comp_lAr,Interj_Template,Verb_Prog_Drop,PersPron_BenSen,PersPron_BanSan,Ordinal_IncI,Grouping_sAr);
}"
52734,"public void run() throws IOException {
  TurkishWordParserGenerator parser=TurkishWordParserGenerator.createWithDefaults();
  String input;
  System.out.println(""String_Node_Str"");
  Scanner sc=new Scanner(System.in);
  input=sc.nextLine();
  while (!input.equals(""String_Node_Str"") && !input.equals(""String_Node_Str"")) {
    List<MorphParse> tokens=parser.parse(input);
    if (tokens.size() == 0) {
      System.out.println(""String_Node_Str"");
      if (parser.getParser() instanceof WordParser) {
        ((WordParser)parser.getParser()).dump(input);
      }
    }
 else {
      tokens.forEach(this::printMorphParse);
    }
    input=sc.nextLine();
  }
}","public void run(TurkishWordParserGenerator parser) throws IOException {
  String input;
  System.out.println(""String_Node_Str"");
  Scanner sc=new Scanner(System.in);
  input=sc.nextLine();
  while (!input.equals(""String_Node_Str"") && !input.equals(""String_Node_Str"")) {
    List<MorphParse> tokens=parser.parse(input);
    if (tokens.size() == 0) {
      System.out.println(""String_Node_Str"");
      if (parser.getParser() instanceof WordParser) {
        ((WordParser)parser.getParser()).dump(input);
      }
    }
 else {
      tokens.forEach(this::printMorphParse);
    }
    input=sc.nextLine();
  }
}"
52735,"public static void main(String[] args) throws IOException {
  new ParseConsole().run();
}","public static void main(String[] args) throws IOException {
  new ParseConsole().run(TurkishWordParserGenerator.createWithDefaults());
}"
52736,"public static void main(String[] args) throws IOException {
  new DevlParseConsole().doit();
}","public static void main(String[] args) throws IOException {
  new ParseConsole().run(TurkishWordParserGenerator.builder().addTextDictFiles(new File(Resources.getResource(""String_Node_Str"").getFile())).build());
}"
52737,"/** 
 * Returns list of all root and derivational roots of a parse. Examples: ""kitaplar""  ->[""kitap""] ""kitabım""   ->[""kitap""] ""kitaplaşır""->[""kitap"", ""kitaplaş""] ""kitaplaş""  ->[""kitap"", ""kitaplaş""] ""arattıragörür"" -> [""ara"",""arat"",""arattır"",""arattıragör""]
 */
public List<String> getLemmas(){
  List<String> stems=Lists.newArrayListWithCapacity(2);
  stems.add(dictionaryItem.root);
  String previousStem=stems.get(0);
  if (inflectionalGroups.size() > 1) {
    previousStem=previousStem + inflectionalGroups.get(0).surfaceForm();
    for (int i=1; i < inflectionalGroups.size(); i++) {
      InflectionalGroup ig=inflectionalGroups.get(i);
      SuffixData suffixData=ig.suffixList.get(0);
      if (suffixData.surface.length() > 0) {
        String surface=suffixData.surface;
        if (suffixData.lex.endsWith(""String_Node_Str"")) {
          surface=surface.substring(0,surface.length() - 1) + ""String_Node_Str"";
        }
        String stem=previousStem + surface;
        if (!stems.contains(stem))         stems.add(stem);
      }
      previousStem=previousStem + ig.surfaceForm();
    }
  }
  return stems;
}","/** 
 * Returns list of all lemmas of a parse.  Examples: ""kitaplar""  ->[""kitap""] ""kitabım""   ->[""kitap""] ""kitaplaşır""->[""kitap"", ""kitaplaş""] ""kitaplaş""  ->[""kitap"", ""kitaplaş""] ""arattıragörür"" -> [""ara"",""arat"",""arattır"",""arattıragör""]
 */
public List<String> getLemmas(){
  List<String> lemmas=Lists.newArrayListWithCapacity(2);
  lemmas.add(dictionaryItem.root);
  String previousStem=root;
  if (inflectionalGroups.size() > 1) {
    previousStem=previousStem + inflectionalGroups.get(0).surfaceForm();
    for (int i=1; i < inflectionalGroups.size(); i++) {
      InflectionalGroup ig=inflectionalGroups.get(i);
      SuffixData suffixData=ig.suffixList.get(0);
      if (suffixData.surface.length() > 0) {
        String surface=suffixData.surface;
        if (suffixData.lex.endsWith(""String_Node_Str"")) {
          surface=surface.substring(0,surface.length() - 1) + ""String_Node_Str"";
        }
        String stem=previousStem + surface;
        if (!lemmas.contains(stem))         lemmas.add(stem);
      }
      previousStem=previousStem + ig.surfaceForm();
    }
  }
  return lemmas;
}"
52738,"@Test public void getLemmasTest(){
  SimpleParser parser=getParser(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String[] testSet={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String[][] expected={{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str""},{""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  int i=0;
  for (  String s : testSet) {
    List<MorphParse> results=parser.parse(s);
    MorphParse res=results.get(0);
    List<String> expStems=Lists.newArrayList(expected[i]);
    MatcherAssert.assertThat(res.getLemmas(),equalTo(expStems));
    i++;
  }
}","@Test public void getLemmasTest(){
  SimpleParser parser=getParser(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String[] testSet={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String[][] expected={{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str""},{""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  int i=0;
  for (  String s : testSet) {
    List<MorphParse> results=parser.parse(s);
    MorphParse res=results.get(0);
    List<String> expStems=Lists.newArrayList(expected[i]);
    MatcherAssert.assertThat(res.getLemmas(),equalTo(expStems));
    i++;
  }
}"
52739,"public List<MorphParse> parse(String word){
  if (cache != null) {
    List<MorphParse> result=cache.parse(word);
    return result != null ? result : parser.parse(word);
  }
  return parser.parse(word);
}","public List<MorphParse> parse(String word){
  word=normalize(word);
  if (cache != null) {
    List<MorphParse> result=cache.parse(word);
    return result != null ? result : parser.parse(word);
  }
  return parser.parse(word);
}"
52740,"/** 
 * Returns list of all lemmas of a parse.  Examples: ""kitaplar""  ->[""kitap""] ""kitabım""   ->[""kitap""] ""kitaplaşır""->[""kitap"", ""kitaplaş""] ""kitaplaş""  ->[""kitap"", ""kitaplaş""] ""arattıragörür"" -> [""ara"",""arat"",""arattır"",""arattıragör""]
 */
public List<String> getLemmas(){
  List<String> lemmas=Lists.newArrayListWithCapacity(2);
  lemmas.add(dictionaryItem.root);
  String previousStem=root;
  if (inflectionalGroups.size() > 1) {
    previousStem=previousStem + inflectionalGroups.get(0).surfaceForm();
    for (int i=1; i < inflectionalGroups.size(); i++) {
      InflectionalGroup ig=inflectionalGroups.get(i);
      SuffixData suffixData=ig.suffixList.get(0);
      if (suffixData.surface.length() > 0) {
        String surface=suffixData.surface;
        if (suffixData.lex.endsWith(""String_Node_Str"")) {
          surface=surface.substring(0,surface.length() - 1) + ""String_Node_Str"";
        }
        String stem=previousStem + surface;
        if (!lemmas.contains(stem))         lemmas.add(stem);
      }
      previousStem=previousStem + ig.surfaceForm();
    }
  }
  return lemmas;
}","/** 
 * Returns list of all lemmas of a parse. Examples: ""kitaplar""  ->[""kitap""] ""kitabım""   ->[""kitap""] ""kitaplaşır""->[""kitap"", ""kitaplaş""] ""kitaplaş""  ->[""kitap"", ""kitaplaş""] ""arattıragörür"" -> [""ara"",""arat"",""arattır"",""arattıragör""]
 */
public List<String> getLemmas(){
  List<String> lemmas=Lists.newArrayListWithCapacity(2);
  lemmas.add(dictionaryItem.root);
  String previousStem=root;
  if (inflectionalGroups.size() > 1) {
    previousStem=previousStem + inflectionalGroups.get(0).surfaceForm();
    for (int i=1; i < inflectionalGroups.size(); i++) {
      InflectionalGroup ig=inflectionalGroups.get(i);
      SuffixData suffixData=ig.suffixList.get(0);
      if (suffixData.surface.length() > 0) {
        String surface=suffixData.surface;
        if (suffixData.lex.endsWith(""String_Node_Str"")) {
          surface=surface.substring(0,surface.length() - 1) + ""String_Node_Str"";
        }
        String stem=previousStem + surface;
        if (!lemmas.contains(stem))         lemmas.add(stem);
      }
      previousStem=previousStem + ig.surfaceForm();
    }
  }
  return lemmas;
}"
52741,"@Test @Ignore(""String_Node_Str"") public void shouldParse8MWords() throws Exception {
  final List<File> files=Arrays.asList(new File(""String_Node_Str""),new File(""String_Node_Str""),new File(""String_Node_Str""),new File(""String_Node_Str""),new File(""String_Node_Str""));
  final LinkedList<String> words=new LinkedList<>();
  final HashSet<String> uniqueWords=new HashSet<>();
  for (  File tokenizedFile : files) {
    final List<String> lines=Files.readLines(tokenizedFile,Charsets.UTF_8);
    for (    String line : lines) {
      final ArrayList<String> strings=Lists.newArrayList(Splitter.on(""String_Node_Str"").trimResults().omitEmptyStrings().split(line));
      words.addAll(strings);
      uniqueWords.addAll(strings);
    }
  }
  System.out.println(""String_Node_Str"" + words.size());
  System.out.println(""String_Node_Str"" + uniqueWords.size());
  System.out.println(""String_Node_Str"");
  final TurkishMorphParser parser=TurkishMorphParser.newBuilder().addDefaultDictionaries().addDefaultCache().build();
  final Stopwatch stopWatch=new Stopwatch();
  stopWatch.start();
  int i=0;
  for (  String word : words) {
    parser.parse(word);
    if (++i % 500 == 0)     System.out.println(""String_Node_Str"" + i);
  }
  stopWatch.stop();
  System.out.println(""String_Node_Str"" + stopWatch.toString());
  System.out.println(""String_Node_Str"" + words.size());
  System.out.println(""String_Node_Str"" + (stopWatch.elapsed(TimeUnit.MILLISECONDS) * 1.0) / (words.size() * 1.0d) + ""String_Node_Str"");
}","@Test @Ignore(""String_Node_Str"") public void shouldParse8MWords() throws Exception {
  final List<File> files=Arrays.asList(new File(""String_Node_Str""),new File(""String_Node_Str""),new File(""String_Node_Str""),new File(""String_Node_Str""),new File(""String_Node_Str""));
  final LinkedList<String> words=new LinkedList<>();
  final HashSet<String> uniqueWords=new HashSet<>();
  for (  File tokenizedFile : files) {
    final List<String> lines=Files.readLines(tokenizedFile,Charsets.UTF_8);
    for (    String line : lines) {
      final ArrayList<String> strings=Lists.newArrayList(Splitter.on(""String_Node_Str"").trimResults().omitEmptyStrings().split(line));
      words.addAll(strings);
      uniqueWords.addAll(strings);
    }
  }
  System.out.println(""String_Node_Str"" + words.size());
  System.out.println(""String_Node_Str"" + uniqueWords.size());
  System.out.println(""String_Node_Str"");
  final TurkishMorphParser parser=TurkishMorphParser.builder().addDefaultDictionaries().addDefaultCache().build();
  final Stopwatch stopWatch=new Stopwatch();
  stopWatch.start();
  int i=0;
  for (  String word : words) {
    parser.parse(word);
    if (++i % 500 == 0)     System.out.println(""String_Node_Str"" + i);
  }
  stopWatch.stop();
  System.out.println(""String_Node_Str"" + stopWatch.toString());
  System.out.println(""String_Node_Str"" + words.size());
  System.out.println(""String_Node_Str"" + (stopWatch.elapsed(TimeUnit.MILLISECONDS) * 1.0) / (words.size() * 1.0d) + ""String_Node_Str"");
}"
52742,"@Test public void shouldCreateTurkishMorphParserSuccessfully() throws IOException {
  TurkishMorphParser parser=TurkishMorphParser.newBuilder().addDefaultDictionaries().build();
  List<MorphParse> results=parser.parse(""String_Node_Str"");
  for (  MorphParse result : results) {
    System.out.println(result.formatNoEmpty());
    System.out.println(result.formatLong());
  }
}","@Test public void shouldCreateTurkishMorphParserSuccessfully() throws IOException {
  TurkishMorphParser parser=TurkishMorphParser.builder().addDefaultDictionaries().build();
  List<MorphParse> results=parser.parse(""String_Node_Str"");
  for (  MorphParse result : results) {
    System.out.println(result.formatNoEmpty());
    System.out.println(result.formatLong());
  }
}"
52743,"@Before public void setUp() throws Exception {
  TurkishMorphParser morphParser=TurkishMorphParser.newBuilder().addDefaultDictionaries().build();
  parser=new TurkishSentenceParser(morphParser,new Z3MarkovModelDisambiguator());
}","@Before public void setUp() throws Exception {
  TurkishMorphParser morphParser=TurkishMorphParser.builder().addDefaultDictionaries().build();
  parser=new TurkishSentenceParser(morphParser,new Z3MarkovModelDisambiguator());
}"
52744,"@Test public void shouldCreateUnidentifiedTokenParserSuccessfully() throws IOException {
  TurkishMorphParser parser=null;
  UnidentifiedTokenParser uiParser=new UnidentifiedTokenParser(parser);
  List<MorphParse> results=uiParser.parse(""String_Node_Str"");
  for (  MorphParse result : results) {
    System.out.println(result);
  }
}","@Test public void shouldCreateUnidentifiedTokenParserSuccessfully() throws IOException {
  TurkishMorphParser parser=TurkishMorphParser.createWithDefaults();
  UnidentifiedTokenParser uiParser=new UnidentifiedTokenParser(parser);
  List<MorphParse> results=uiParser.parse(""String_Node_Str"");
  for (  MorphParse result : results) {
    System.out.println(result);
  }
}"
52745,"public boolean contains(T key){
  return locate(key) > 0;
}","public boolean contains(T key){
  return locate(key) >= 0;
}"
52746,"public boolean contains(T key){
  return locate(key) > 0;
}","public boolean contains(T key){
  return locate(key) >= 0;
}"
52747,"public static void log(Level level,String message,Object... params){
  final int stackPositionOfCaller=2;
  StackTraceElement caller=new Throwable().getStackTrace()[stackPositionOfCaller];
  String className=caller.getClassName();
  Logger logger;
  logger=loggers.get(className);
  if (logger == null) {
    logger=Logger.getLogger(className);
    loggers.putIfAbsent(className,logger);
  }
  if (logger.isLoggable(level)) {
    String formattedMessage;
    Throwable thrown=null;
    if (params.length == 0) {
      formattedMessage=message;
    }
 else {
      Object last=params[params.length - 1];
      if (last instanceof Throwable) {
        Object[] subParams=new Object[params.length - 1];
        System.arraycopy(params,0,subParams,0,subParams.length);
        formattedMessage=String.format(message,subParams);
        thrown=(Throwable)last;
      }
 else {
        formattedMessage=String.format(message,params);
      }
    }
    LogRecord record=new LogRecord(level,formattedMessage);
    record.setLoggerName(logger.getName());
    record.setSourceClassName(className);
    record.setSourceMethodName(caller.getMethodName());
    record.setThrown(thrown);
    record.setParameters(params);
    logger.log(record);
  }
}","public static void log(Level level,String message,Object... params){
  final int stackPositionOfCaller=2;
  StackTraceElement caller=new Throwable().getStackTrace()[stackPositionOfCaller];
  String className=caller.getClassName();
  Logger logger;
  logger=loggers.get(className);
  if (logger == null) {
    logger=Logger.getLogger(className);
    loggers.putIfAbsent(className,logger);
    logger.setLevel(currentLevel);
  }
  if (logger.isLoggable(level)) {
    String formattedMessage;
    Throwable thrown=null;
    if (params.length == 0) {
      formattedMessage=message;
    }
 else {
      Object last=params[params.length - 1];
      if (last instanceof Throwable) {
        Object[] subParams=new Object[params.length - 1];
        System.arraycopy(params,0,subParams,0,subParams.length);
        formattedMessage=String.format(message,subParams);
        thrown=(Throwable)last;
      }
 else {
        formattedMessage=String.format(message,params);
      }
    }
    LogRecord record=new LogRecord(level,formattedMessage);
    record.setLoggerName(logger.getName());
    record.setSourceClassName(className);
    record.setSourceMethodName(caller.getMethodName());
    record.setThrown(thrown);
    record.setParameters(params);
    logger.log(record);
  }
}"
52748,"public static void setInfo(){
  for (  Logger logger : loggers.values()) {
    logger.setLevel(Level.INFO);
  }
}","public static void setInfo(){
  setLevel(Level.INFO);
}"
52749,"public static void setDebug(){
  for (  Logger logger : loggers.values()) {
    logger.setLevel(Level.FINE);
  }
}","public static void setDebug(){
  setLevel(Level.FINE);
}"
52750,"DoubleValueSet<String> decode(String input){
  Hypothesis hyp=new Hypothesis(null,root,0,Operation.N_A);
  DoubleValueSet<String> hypotheses=new DoubleValueSet<>(3);
  Set<Hypothesis> next=expand(hyp,input,hypotheses);
  while (true) {
    HashSet<Hypothesis> newHyps=new HashSet<>();
    for (    Hypothesis hypothesis : next) {
      newHyps.addAll(expand(hypothesis,input,hypotheses));
    }
    if (newHyps.size() == 0)     break;
    next=newHyps;
  }
  return hypotheses;
}","DoubleValueSet<String> decode(String input){
  Hypothesis hyp=new Hypothesis(null,root,0,Operation.N_A);
  DoubleValueSet<String> hypotheses=new DoubleValueSet<>();
  Set<Hypothesis> next=expand(hyp,input,hypotheses);
  while (true) {
    HashSet<Hypothesis> newHyps=new HashSet<>();
    if (Log.isDebug())     Log.info(""String_Node_Str"");
    for (    Hypothesis hypothesis : next) {
      if (Log.isDebug())       Log.info(""String_Node_Str"",hypothesis);
      newHyps.addAll(expand(hypothesis,input,hypotheses));
    }
    if (newHyps.size() == 0)     break;
    next=newHyps;
  }
  return hypotheses;
}"
52751,"void addHypothesis(DoubleValueSet<String> result,Hypothesis hypothesis){
  String hypWord=hypothesis.node.word;
  if (hypWord == null)   return;
  if (!result.contains(hypWord)) {
    result.set(hypWord,hypothesis.penalty);
  }
 else   if (result.get(hypWord) > hypothesis.penalty) {
    result.set(hypWord,hypothesis.penalty);
  }
}","void addHypothesis(DoubleValueSet<String> result,Hypothesis hypothesis){
  String hypWord=hypothesis.node.word;
  if (hypWord == null) {
    if (Log.isDebug())     Log.info(""String_Node_Str"",hypothesis.toString());
    return;
  }
  if (!result.contains(hypWord)) {
    result.set(hypWord,hypothesis.penalty);
    if (Log.isDebug())     Log.info(""String_Node_Str"",hypWord,hypothesis.toString());
  }
 else   if (result.get(hypWord) > hypothesis.penalty) {
    result.set(hypWord,hypothesis.penalty);
    if (Log.isDebug())     Log.info(""String_Node_Str"",hypWord,hypothesis.toString());
  }
}"
52752,"@Test public void singleWordDictionaryTest2(){
  SingleWordSpellChecker spellChecker=new SingleWordSpellChecker(1);
  spellChecker.addWord(""String_Node_Str"");
  spellChecker.addWord(""String_Node_Str"");
  spellChecker.addWord(""String_Node_Str"");
  spellChecker.addWord(""String_Node_Str"");
  DoubleValueSet<String> result=spellChecker.decode(""String_Node_Str"");
  for (  String s : result) {
    System.out.println(s + ""String_Node_Str"" + result.get(s));
  }
}","@Test public void singleWordDictionaryTest2(){
  Log.setDebug();
  SingleWordSpellChecker spellChecker=new SingleWordSpellChecker(1);
  spellChecker.addWord(""String_Node_Str"");
  spellChecker.addWord(""String_Node_Str"");
  DoubleValueSet<String> result=spellChecker.decode(""String_Node_Str"");
  for (  String s : result) {
    System.out.println(s + ""String_Node_Str"" + result.get(s));
  }
}"
52753,"/** 
 * save session
 * @param session
 * @throws UnknownSessionException
 */
private void saveSession(Session session) throws UnknownSessionException {
  if (session == null || session.getId() == null) {
    logger.error(""String_Node_Str"");
    return;
  }
  byte[] key=getByteKey(session.getId());
  byte[] value=SerializeUtils.serialize(session);
  Long timeout=session.getTimeout() / 1000;
  int expire=timeout.intValue();
  this.redisManager.set(key,value,expire);
}","/** 
 * save session
 * @param session
 * @throws UnknownSessionException
 */
private void saveSession(Session session) throws UnknownSessionException {
  if (session == null || session.getId() == null) {
    logger.error(""String_Node_Str"");
    return;
  }
  byte[] key=getByteKey(session.getId());
  byte[] value=SerializeUtils.serialize(session);
  session.setTimeout(redisManager.getExpire() * 1000);
  this.redisManager.set(key,value,redisManager.getExpire());
}"
52754,"@Override public boolean equals(Object o){
  if (o == null || !o.getClass().equals(this.getClass())) {
    return false;
  }
  Invocation other=(Invocation)o;
  return this.mock.equals(other.mock) && this.method.equals(other.method) && this.equalArguments(other.arguments);
}","@Override public boolean equals(Object o){
  if (o == null || !o.getClass().equals(this.getClass())) {
    return false;
  }
  Invocation other=(Invocation)o;
  return this.mock == other.mock && this.method.equals(other.method) && this.equalArguments(other.arguments);
}"
52755,"@SuppressWarnings(""String_Node_Str"") public <T>T createProxy(Class<T> toMock,InvocationHandler handler,Method[] mockedMethods,ConstructorArgs args){
  Enhancer enhancer=createEnhancer(toMock);
  MockMethodInterceptor interceptor=new MockMethodInterceptor(handler);
  if (mockedMethods != null) {
    interceptor.setMockedMethods(mockedMethods);
  }
  enhancer.setCallbackType(interceptor.getClass());
  Class<?> mockClass;
  try {
    mockClass=enhancer.createClass();
  }
 catch (  CodeGenerationException e) {
    enhancer.setClassLoader(getClass().getClassLoader());
    mockClass=enhancer.createClass();
  }
  try {
    Enhancer.registerCallbacks(mockClass,new Callback[]{interceptor});
    if (args != null) {
      Constructor<?> cstr;
      try {
        cstr=mockClass.getDeclaredConstructor(args.getConstructor().getParameterTypes());
      }
 catch (      NoSuchMethodException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
      T mock;
      try {
        cstr.setAccessible(true);
        mock=(T)cstr.newInstance(args.getInitArgs());
      }
 catch (      InstantiationException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
catch (      IllegalAccessException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
catch (      InvocationTargetException e) {
        throw new RuntimeException(""String_Node_Str"",e.getTargetException());
      }
      return mock;
    }
 else {
      Factory mock;
      try {
        mock=(Factory)ClassInstantiatorFactory.getInstantiator().newInstance(mockClass);
      }
 catch (      InstantiationException e) {
        throw new RuntimeException(""String_Node_Str"" + toMock + ""String_Node_Str""+ ClassInstantiatorFactory.getJVM()+ ""String_Node_Str"");
      }
      mock.getCallback(0);
      return (T)mock;
    }
  }
  finally {
    Enhancer.registerCallbacks(mockClass,null);
  }
}","@SuppressWarnings(""String_Node_Str"") public <T>T createProxy(Class<T> toMock,InvocationHandler handler,Method[] mockedMethods,ConstructorArgs args){
  Enhancer enhancer=createEnhancer(toMock);
  MockMethodInterceptor interceptor=new MockMethodInterceptor(handler);
  if (mockedMethods != null) {
    interceptor.setMockedMethods(mockedMethods);
  }
  enhancer.setCallbackType(interceptor.getClass());
  Class<?> mockClass;
  try {
    mockClass=enhancer.createClass();
  }
 catch (  CodeGenerationException e) {
    LinkedClassLoader linkedClassLoader=new LinkedClassLoader();
    linkedClassLoader.addClassLoader(toMock.getClassLoader());
    linkedClassLoader.addClassLoader(ClassProxyFactory.class.getClassLoader());
    enhancer.setClassLoader(linkedClassLoader);
    mockClass=enhancer.createClass();
  }
  try {
    Enhancer.registerCallbacks(mockClass,new Callback[]{interceptor});
    if (args != null) {
      Constructor<?> cstr;
      try {
        cstr=mockClass.getDeclaredConstructor(args.getConstructor().getParameterTypes());
      }
 catch (      NoSuchMethodException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
      T mock;
      try {
        cstr.setAccessible(true);
        mock=(T)cstr.newInstance(args.getInitArgs());
      }
 catch (      InstantiationException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
catch (      IllegalAccessException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
catch (      InvocationTargetException e) {
        throw new RuntimeException(""String_Node_Str"",e.getTargetException());
      }
      return mock;
    }
 else {
      Factory mock;
      try {
        mock=(Factory)ClassInstantiatorFactory.getInstantiator().newInstance(mockClass);
      }
 catch (      InstantiationException e) {
        throw new RuntimeException(""String_Node_Str"" + toMock + ""String_Node_Str""+ ClassInstantiatorFactory.getJVM()+ ""String_Node_Str"");
      }
      mock.getCallback(0);
      return (T)mock;
    }
  }
  finally {
    Enhancer.registerCallbacks(mockClass,null);
  }
}"
52756,"/** 
 * Reports an argument matcher. This method is needed to define own argument matchers. For details, see the EasyMock documentation.
 * @param matcher
 */
public static void reportMatcher(final IArgumentMatcher matcher){
  LastControl.reportMatcher(matcher);
}","/** 
 * Reports an argument matcher. This method is needed to define own argument matchers. For details, see the EasyMock documentation.
 * @param matcher the matcher to use to match currently mocked method argument
 */
public static void reportMatcher(final IArgumentMatcher matcher){
  LastControl.reportMatcher(matcher);
}"
52757,"/** 
 * Returns the expectation setter for the last expected invocation in the current thread.
 * @param < T > type returned by the expected method
 * @param value the parameter is used to transport the type to the ExpectationSetter. It allows writing the expected call as argument, i.e. <code>expect(mock.getName()).andReturn(""John Doe"")<code>.
 * @return the expectation setter.
 */
public static <T>IExpectationSetters<T> expect(final T value){
  return EasyMock.getControlForLastCall();
}","/** 
 * Returns the expectation setter for the last expected invocation in the current thread.
 * @param < T > type returned by the expected method
 * @param value the parameter is used to transport the type to the ExpectationSetter. It allows writing the expected call as argument, i.e. expect(mock.getName()).andReturn(""John Doe"").
 * @return the expectation setter.
 */
public static <T>IExpectationSetters<T> expect(final T value){
  return EasyMock.getControlForLastCall();
}"
52758,"/** 
 * Create named mock from the provided mock control using the arguments passed to the builder.
 * @param name the mock name
 * @return the newly created mock
 */
T createMock(String name,IMocksControl control);","/** 
 * Create named mock from the provided mock control using the arguments passed to the builder.
 * @param name the mock name
 * @param control {@link org.easymock.classextension.IMocksControl} used tocreate the object
 * @return the newly created mock
 */
T createMock(String name,IMocksControl control);"
52759,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle state){
  Activity activity;
  if ((activity=getActivity()) == null)   return null;
  activity.setTitle(R.string.compose_sampler_cube);
  try {
    cubeMapView=((CubeMapActivity)activity).getCubeMapView();
  }
 catch (  ClassCastException e) {
    throw new ClassCastException(activity.toString() + ""String_Node_Str"" + ""String_Node_Str"");
  }
  View view;
  View fab;
  if ((view=inflater.inflate(R.layout.fragment_cube_map,container,false)) == null || (fab=view.findViewById(R.id.add_texture)) == null) {
    activity.finish();
    return null;
  }
  fab.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      addTexture();
    }
  }
);
  cubeMapView.setVisibility(View.VISIBLE);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle state){
  Activity activity;
  if ((activity=getActivity()) == null)   return null;
  activity.setTitle(R.string.compose_sampler_cube);
  try {
    cubeMapView=((CubeMapViewProvider)activity).getCubeMapView();
  }
 catch (  ClassCastException e) {
    throw new ClassCastException(activity.toString() + ""String_Node_Str"" + ""String_Node_Str"");
  }
  View view;
  View fab;
  if ((view=inflater.inflate(R.layout.fragment_cube_map,container,false)) == null || (fab=view.findViewById(R.id.add_texture)) == null) {
    activity.finish();
    return null;
  }
  fab.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      addTexture();
    }
  }
);
  cubeMapView.setVisibility(View.VISIBLE);
  return view;
}"
52760,"@Override public void onDrawFrame(GL10 gl){
  if (surfaceProgram == 0 || program == 0) {
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
    return;
  }
  final long now=System.nanoTime();
  GLES20.glUseProgram(program);
  GLES20.glVertexAttribPointer(positionLoc,2,GLES20.GL_BYTE,false,0,vertexBuffer);
  if (timeLoc > -1)   GLES20.glUniform1f(timeLoc,(now - startTime) / NS_PER_SECOND);
  if (resolutionLoc > -1)   GLES20.glUniform2fv(resolutionLoc,1,resolution,0);
  if (touchLoc > -1)   GLES20.glUniform2fv(touchLoc,1,touch,0);
  if (mouseLoc > -1)   GLES20.glUniform2fv(mouseLoc,1,mouse,0);
  if (pointerCountLoc > -1)   GLES20.glUniform1i(pointerCountLoc,pointerCount);
  if (pointersLoc > -1)   GLES20.glUniform3fv(pointersLoc,pointerCount,pointers,0);
  if (gravityLoc > -1 && accelerometerListener != null)   GLES20.glUniform3fv(gravityLoc,1,accelerometerListener.gravity,0);
  if (linearLoc > -1 && accelerometerListener != null)   GLES20.glUniform3fv(linearLoc,1,accelerometerListener.linear,0);
  if (rotationLoc > -1 && gyroscopeListener != null)   GLES20.glUniform3fv(rotationLoc,1,gyroscopeListener.rotation,0);
  if (magneticLoc > -1 && magneticFieldListener != null)   GLES20.glUniform3fv(magneticLoc,1,magneticFieldListener.values,0);
  if (lightLoc > -1 && lightListener != null)   GLES20.glUniform1f(lightLoc,lightListener.ambient);
  if (pressureLoc > -1 && pressureListener != null)   GLES20.glUniform1f(pressureLoc,pressureListener.pressure);
  if (proximityLoc > -1 && proximityListener != null)   GLES20.glUniform1f(proximityLoc,proximityListener.centimeters);
  if (offsetLoc > -1)   GLES20.glUniform2fv(offsetLoc,1,offset,0);
  if (batteryLoc > -1) {
    if (now - lastBatteryUpdate > BATTERY_UPDATE_INTERVAL) {
      batteryLevel=getBatteryLevel();
      lastBatteryUpdate=now;
    }
    GLES20.glUniform1f(batteryLoc,batteryLevel);
  }
  if (dateTimeLoc > -1) {
    if (now - lastDateUpdate > DATE_UPDATE_INTERVAL) {
      calendar=Calendar.getInstance();
      dateTime[0]=calendar.get(Calendar.YEAR);
      dateTime[1]=calendar.get(Calendar.MONTH);
      dateTime[2]=calendar.get(Calendar.DAY_OF_MONTH);
      dateTime[3]=calendar.get(Calendar.HOUR_OF_DAY) * 3600f + calendar.get(Calendar.MINUTE) * 60f + calendar.get(Calendar.SECOND);
      lastDateUpdate=now;
    }
    GLES20.glUniform4fv(dateTimeLoc,1,dateTime,0);
  }
  if (startRandomLoc > -1)   GLES20.glUniform1f(startRandomLoc,startRandom);
  if (fb[0] == 0)   createTargets((int)resolution[0],(int)resolution[1]);
  GLES20.glViewport(0,0,(int)resolution[0],(int)resolution[1]);
  textureBinder.reset();
  if (backBufferLoc > -1)   textureBinder.bind(backBufferLoc,GLES20.GL_TEXTURE_2D,tx[backTarget]);
  for (int n=0; n < numberOfTextures; ++n)   textureBinder.bind(textureLocs[n],textureTargets[n],textureIds[n]);
  GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,fb[frontTarget]);
  GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP,0,4);
  GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
  GLES20.glViewport(0,0,(int)surfaceResolution[0],(int)surfaceResolution[1]);
  GLES20.glUseProgram(surfaceProgram);
  GLES20.glVertexAttribPointer(surfacePositionLoc,2,GLES20.GL_BYTE,false,0,vertexBuffer);
  GLES20.glUniform2fv(surfaceResolutionLoc,1,surfaceResolution,0);
  GLES20.glUniform1i(surfaceFrameLoc,0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,tx[frontTarget]);
  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
  GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP,0,4);
  int t=frontTarget;
  frontTarget=backTarget;
  backTarget=t;
  if (thumbnail == null)   thumbnail=saveThumbnail();
  if (onRendererListener != null)   updateFps(now);
}","@Override public void onDrawFrame(GL10 gl){
  if (surfaceProgram == 0 || program == 0) {
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
    return;
  }
  final long now=System.nanoTime();
  GLES20.glUseProgram(program);
  GLES20.glVertexAttribPointer(positionLoc,2,GLES20.GL_BYTE,false,0,vertexBuffer);
  if (timeLoc > -1)   GLES20.glUniform1f(timeLoc,(now - startTime) / NS_PER_SECOND);
  if (resolutionLoc > -1)   GLES20.glUniform2fv(resolutionLoc,1,resolution,0);
  if (touchLoc > -1)   GLES20.glUniform2fv(touchLoc,1,touch,0);
  if (mouseLoc > -1)   GLES20.glUniform2fv(mouseLoc,1,mouse,0);
  if (pointerCountLoc > -1)   GLES20.glUniform1i(pointerCountLoc,pointerCount);
  if (pointersLoc > -1)   GLES20.glUniform3fv(pointersLoc,pointerCount,pointers,0);
  if (gravityLoc > -1 && accelerometerListener != null)   GLES20.glUniform3fv(gravityLoc,1,accelerometerListener.gravity,0);
  if (linearLoc > -1 && accelerometerListener != null)   GLES20.glUniform3fv(linearLoc,1,accelerometerListener.linear,0);
  if (rotationLoc > -1 && gyroscopeListener != null)   GLES20.glUniform3fv(rotationLoc,1,gyroscopeListener.rotation,0);
  if (magneticLoc > -1 && magneticFieldListener != null)   GLES20.glUniform3fv(magneticLoc,1,magneticFieldListener.values,0);
  if (lightLoc > -1 && lightListener != null)   GLES20.glUniform1f(lightLoc,lightListener.ambient);
  if (pressureLoc > -1 && pressureListener != null)   GLES20.glUniform1f(pressureLoc,pressureListener.pressure);
  if (proximityLoc > -1 && proximityListener != null)   GLES20.glUniform1f(proximityLoc,proximityListener.centimeters);
  if (offsetLoc > -1)   GLES20.glUniform2fv(offsetLoc,1,offset,0);
  if (batteryLoc > -1) {
    if (now - lastBatteryUpdate > BATTERY_UPDATE_INTERVAL) {
      batteryLevel=getBatteryLevel();
      lastBatteryUpdate=now;
    }
    GLES20.glUniform1f(batteryLoc,batteryLevel);
  }
  if (dateTimeLoc > -1) {
    if (now - lastDateUpdate > DATE_UPDATE_INTERVAL) {
      Calendar calendar=Calendar.getInstance();
      dateTime[0]=calendar.get(Calendar.YEAR);
      dateTime[1]=calendar.get(Calendar.MONTH);
      dateTime[2]=calendar.get(Calendar.DAY_OF_MONTH);
      dateTime[3]=calendar.get(Calendar.HOUR_OF_DAY) * 3600f + calendar.get(Calendar.MINUTE) * 60f + calendar.get(Calendar.SECOND);
      lastDateUpdate=now;
    }
    GLES20.glUniform4fv(dateTimeLoc,1,dateTime,0);
  }
  if (startRandomLoc > -1)   GLES20.glUniform1f(startRandomLoc,startRandom);
  if (fb[0] == 0)   createTargets((int)resolution[0],(int)resolution[1]);
  GLES20.glViewport(0,0,(int)resolution[0],(int)resolution[1]);
  textureBinder.reset();
  if (backBufferLoc > -1)   textureBinder.bind(backBufferLoc,GLES20.GL_TEXTURE_2D,tx[backTarget]);
  for (int n=0; n < numberOfTextures; ++n)   textureBinder.bind(textureLocs[n],textureTargets[n],textureIds[n]);
  GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,fb[frontTarget]);
  GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP,0,4);
  GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
  GLES20.glViewport(0,0,(int)surfaceResolution[0],(int)surfaceResolution[1]);
  GLES20.glUseProgram(surfaceProgram);
  GLES20.glVertexAttribPointer(surfacePositionLoc,2,GLES20.GL_BYTE,false,0,vertexBuffer);
  GLES20.glUniform2fv(surfaceResolutionLoc,1,surfaceResolution,0);
  GLES20.glUniform1i(surfaceFrameLoc,0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,tx[frontTarget]);
  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
  GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP,0,4);
  int t=frontTarget;
  frontTarget=backTarget;
  backTarget=t;
  if (thumbnail == null)   thumbnail=saveThumbnail();
  if (onRendererListener != null)   updateFps(now);
}"
52761,"public void addUniform(String statement){
  if (statement == null)   return;
  Editable e=getText();
  Matcher m=PATTERN_INSERT_UNIFORM.matcher(e);
  int start=0;
  if (m.find())   start=Math.max(0,m.end() - 1);
 else {
    if ((start=endIndexOfLastEndIf(e)) > -1)     statement=""String_Node_Str"" + statement;
    ++start;
  }
  e.insert(start,statement + ""String_Node_Str"");
}","public void addUniform(String statement){
  if (statement == null)   return;
  Editable e=getText();
  Matcher m=PATTERN_INSERT_UNIFORM.matcher(e);
  int start;
  if (m.find())   start=Math.max(0,m.end() - 1);
 else {
    if ((start=endIndexOfLastEndIf(e)) > -1)     statement=""String_Node_Str"" + statement;
    ++start;
  }
  e.insert(start,statement + ""String_Node_Str"");
}"
52762,"private CharSequence autoIndent(CharSequence source,Spanned dest,int dstart,int dend){
  String indent=""String_Node_Str"";
  int istart=dstart - 1;
  int iend=-1;
  boolean dataBefore=false;
  int pt=0;
  for (; istart > -1; --istart) {
    char c=dest.charAt(istart);
    if (c == '\n')     break;
    if (c != ' ' && c != '\t') {
      if (!dataBefore) {
        if (c == '{' || c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '^' || c == '=')         --pt;
        dataBefore=true;
      }
      if (c == '(')       --pt;
 else       if (c == ')')       ++pt;
    }
  }
  if (istart > -1) {
    char charAtCursor=dest.charAt(dstart);
    for (iend=++istart; iend < dend; ++iend) {
      char c=dest.charAt(iend);
      if (charAtCursor != '\n' && c == '/' && iend + 1 < dend && dest.charAt(iend) == c) {
        iend+=2;
        break;
      }
      if (c != ' ' && c != '\t')       break;
    }
    indent+=dest.subSequence(istart,iend);
  }
  if (pt < 0)   indent+=""String_Node_Str"";
  return source + indent;
}","private CharSequence autoIndent(CharSequence source,Spanned dest,int dstart,int dend){
  String indent=""String_Node_Str"";
  int istart=dstart - 1;
  boolean dataBefore=false;
  int pt=0;
  for (; istart > -1; --istart) {
    char c=dest.charAt(istart);
    if (c == '\n')     break;
    if (c != ' ' && c != '\t') {
      if (!dataBefore) {
        if (c == '{' || c == '+' || c == '-' || c == '*' || c == '/' || c == '%' || c == '^' || c == '=')         --pt;
        dataBefore=true;
      }
      if (c == '(')       --pt;
 else       if (c == ')')       ++pt;
    }
  }
  if (istart > -1) {
    char charAtCursor=dest.charAt(dstart);
    int iend;
    for (iend=++istart; iend < dend; ++iend) {
      char c=dest.charAt(iend);
      if (charAtCursor != '\n' && c == '/' && iend + 1 < dend && dest.charAt(iend) == c) {
        iend+=2;
        break;
      }
      if (c != ' ' && c != '\t')       break;
    }
    indent+=dest.subSequence(istart,iend);
  }
  if (pt < 0)   indent+=""String_Node_Str"";
  return source + indent;
}"
52763,"private void initDrawer(){
  drawerLayout=(TouchThruDrawerlayout)findViewById(R.id.drawer_layout);
  menuFrame=findViewById(R.id.menu_frame);
  drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.drawer_open,R.string.drawer_close){
    public void onDrawerClosed(    View view){
      supportInvalidateOptionsMenu();
    }
    public void onDrawerOpened(    View view){
      supportInvalidateOptionsMenu();
    }
  }
;
  drawerToggle.setDrawerIndicatorEnabled(true);
  drawerLayout.setDrawerListener(drawerToggle);
}","private void initDrawer(){
  drawerLayout=(TouchThruDrawerlayout)findViewById(R.id.drawer_layout);
  menuFrame=findViewById(R.id.menu_frame);
  drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.drawer_open,R.string.drawer_close){
    public void onDrawerClosed(    View view){
      supportInvalidateOptionsMenu();
    }
    public void onDrawerOpened(    View view){
      supportInvalidateOptionsMenu();
    }
  }
;
  drawerToggle.setDrawerIndicatorEnabled(true);
  drawerLayout.addDrawerListener(drawerToggle);
}"
52764,"@Override public void onCreate(){
  super.onCreate();
  preferences.init(this);
  dataSource.openAsync(this);
  if (BuildConfig.DEBUG) {
    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
    StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
  }
}","@Override public void onCreate(){
  super.onCreate();
  preferences.init(this);
  dataSource.openAsync(this);
  if (BuildConfig.DEBUG) {
    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
    StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().penaltyLog().penaltyDeath().build());
  }
}"
52765,"private void saveShader(){
  String src=shaderEditor.getText().toString();
  if (!compileOnChange)   loadShader(src);
  dataSource.update(shaderSpinner.getSelectedItemId(),src,shaderView.renderer.getThumbnail());
  updateAdapter();
}","private void saveShader(){
  String src=shaderEditor.getText().toString();
  if (!compileOnChange) {
    loadShader(src);
    shaderEditor.refresh();
  }
  dataSource.update(shaderSpinner.getSelectedItemId(),src,shaderView.renderer.getThumbnail());
  updateAdapter();
}"
52766,"public static Offset rangeToTextOffset(CharSequence charsSequence,Comment.Range range){
  int startOffset=0;
  int endOffset=0;
  try {
    BufferedReader reader=new BufferedReader(new CharSequenceReader(charsSequence));
    String line;
    int textLineCount=1;
    while ((line=reader.readLine()) != null) {
      if (textLineCount < range.startLine) {
        startOffset+=line.length();
        startOffset++;
      }
      if (textLineCount < range.endLine) {
        endOffset+=line.length();
        endOffset++;
      }
 else {
        break;
      }
      textLineCount++;
    }
  }
 catch (  IOException e) {
    throw Throwables.propagate(e);
  }
  startOffset+=range.startCharacter;
  endOffset+=range.endCharacter;
  return new Offset(startOffset,endOffset);
}","public static Offset rangeToTextOffset(CharSequence charsSequence,Comment.Range range){
  int startOffset=0;
  int endOffset=0;
  CharSequenceReader charSequenceReader=new CharSequenceReader(charsSequence);
  try {
    BufferedReader reader=new BufferedReader(charSequenceReader);
    String line;
    int textLineCount=1;
    while ((line=reader.readLine()) != null) {
      if (textLineCount < range.startLine) {
        startOffset+=line.length();
        startOffset++;
      }
      if (textLineCount < range.endLine) {
        endOffset+=line.length();
        endOffset++;
      }
 else {
        break;
      }
      textLineCount++;
    }
  }
 catch (  IOException e) {
    throw Throwables.propagate(e);
  }
 finally {
    charSequenceReader.close();
  }
  startOffset+=range.startCharacter;
  endOffset+=range.endCharacter;
  return new Offset(startOffset,endOffset);
}"
52767,"public static Comment.Range textOffsetToRange(CharSequence charsSequence,int start,int end){
  int startLine=1;
  int startOffset=-1;
  int endLine=1;
  int endOffset=-1;
  try {
    BufferedReader reader=new BufferedReader(new CharSequenceReader(charsSequence));
    String lineString;
    int currentCharCount=0;
    while ((lineString=reader.readLine()) != null) {
      currentCharCount+=lineString.length();
      currentCharCount++;
      if (start > currentCharCount) {
        startLine++;
      }
 else       if (startOffset < 0) {
        startOffset=start - (currentCharCount - lineString.length() - 1);
      }
      if (end > currentCharCount) {
        endLine++;
      }
 else       if (endOffset < 0) {
        endOffset=end - (currentCharCount - lineString.length() - 1);
        break;
      }
    }
  }
 catch (  IOException e) {
    throw Throwables.propagate(e);
  }
  Comment.Range range=new Comment.Range();
  range.startLine=startLine;
  range.startCharacter=startOffset;
  range.endLine=endLine;
  range.endCharacter=endOffset;
  return range;
}","public static Comment.Range textOffsetToRange(CharSequence charsSequence,int start,int end){
  int startLine=1;
  int startOffset=-1;
  int endLine=1;
  int endOffset=-1;
  CharSequenceReader charSequenceReader=new CharSequenceReader(charsSequence);
  try {
    BufferedReader reader=new BufferedReader(charSequenceReader);
    String lineString;
    int currentCharCount=0;
    while ((lineString=reader.readLine()) != null) {
      currentCharCount+=lineString.length();
      currentCharCount++;
      if (start > currentCharCount) {
        startLine++;
      }
 else       if (startOffset < 0) {
        startOffset=start - (currentCharCount - lineString.length() - 1);
      }
      if (end > currentCharCount) {
        endLine++;
      }
 else       if (endOffset < 0) {
        endOffset=end - (currentCharCount - lineString.length() - 1);
        break;
      }
    }
  }
 catch (  IOException e) {
    throw Throwables.propagate(e);
  }
 finally {
    charSequenceReader.close();
  }
  Comment.Range range=new Comment.Range();
  range.startLine=startLine;
  range.startCharacter=startOffset;
  range.endLine=endLine;
  range.endCharacter=endOffset;
  return range;
}"
52768,"public Offset(int start,int end){
  this.start=start;
  this.end=end;
}","Offset(int start,int end){
  this.start=start;
  this.end=end;
}"
52769,"public Element getState(){
  final Element element=new Element(GERRIT_SETTINGS_TAG);
  element.setAttribute(LOGIN,(getLogin() != null ? getLogin() : ""String_Node_Str""));
  element.setAttribute(HOST,(getHost() != null ? getHost() : ""String_Node_Str""));
  element.setAttribute(LIST_ALL_CHANGES,Boolean.toString(getListAllChanges()));
  element.setAttribute(AUTOMATIC_REFRESH,Boolean.toString(getAutomaticRefresh()));
  element.setAttribute(REFRESH_TIMEOUT,""String_Node_Str"" + getRefreshTimeout());
  element.setAttribute(REVIEW_NOTIFICATIONS,Boolean.toString(getReviewNotifications()));
  element.setAttribute(PUSH_TO_GERRIT,Boolean.toString(getPushToGerrit()));
  element.setAttribute(SHOW_CHANGE_NUMBER_COLUMN,Boolean.toString(getShowChangeNumberColumn()));
  element.setAttribute(SHOW_CHANGE_ID_COLUMN,Boolean.toString(getShowChangeIdColumn()));
  element.setAttribute(SHOW_TOPIC_COLUMN,Boolean.toString(getShowTopicColumn()));
  element.setAttribute(SHOW_PROJECT_COLUMN,getShowProjectColumn().name());
  return element;
}","public Element getState(){
  final Element element=new Element(GERRIT_SETTINGS_TAG);
  element.setAttribute(LOGIN,(getLogin() != null ? getLogin() : ""String_Node_Str""));
  element.setAttribute(HOST,(getHost() != null ? getHost() : ""String_Node_Str""));
  element.setAttribute(LIST_ALL_CHANGES,Boolean.toString(getListAllChanges()));
  element.setAttribute(AUTOMATIC_REFRESH,Boolean.toString(getAutomaticRefresh()));
  element.setAttribute(REFRESH_TIMEOUT,Integer.toString(getRefreshTimeout()));
  element.setAttribute(REVIEW_NOTIFICATIONS,Boolean.toString(getReviewNotifications()));
  element.setAttribute(PUSH_TO_GERRIT,Boolean.toString(getPushToGerrit()));
  element.setAttribute(SHOW_CHANGE_NUMBER_COLUMN,Boolean.toString(getShowChangeNumberColumn()));
  element.setAttribute(SHOW_CHANGE_ID_COLUMN,Boolean.toString(getShowChangeIdColumn()));
  element.setAttribute(SHOW_TOPIC_COLUMN,Boolean.toString(getShowTopicColumn()));
  element.setAttribute(SHOW_PROJECT_COLUMN,getShowProjectColumn().name());
  return element;
}"
52770,"private void postError(String json){
  CloseableHttpClient httpClient=HttpClients.createDefault();
  HttpPost httpPost=new HttpPost(ERROR_REPORT_URL);
  httpPost.setEntity(new StringEntity(json,ContentType.APPLICATION_JSON));
  try {
    CloseableHttpResponse response=httpClient.execute(httpPost);
    try {
      if (response.getStatusLine().getStatusCode() == 406) {
        String reasonPhrase=response.getStatusLine().getReasonPhrase();
        Messages.showErrorDialog(reasonPhrase,""String_Node_Str"");
      }
    }
  finally {
      response.close();
    }
  }
 catch (  IOException e) {
    throw Throwables.propagate(e);
  }
}","private void postError(String json){
  try {
    CloseableHttpClient httpClient=HttpClients.createDefault();
    try {
      HttpPost httpPost=new HttpPost(ERROR_REPORT_URL);
      httpPost.setEntity(new StringEntity(json,ContentType.APPLICATION_JSON));
      CloseableHttpResponse response=httpClient.execute(httpPost);
      if (response.getStatusLine().getStatusCode() == 406) {
        String reasonPhrase=response.getStatusLine().getReasonPhrase();
        Messages.showErrorDialog(reasonPhrase,""String_Node_Str"");
      }
    }
  finally {
      httpClient.close();
    }
  }
 catch (  IOException e) {
    throw Throwables.propagate(e);
  }
}"
52771,"private void addMessages(ChangeInfo changeInfo,StringBuilder sb){
  if (changeInfo.messages != null && changeInfo.messages.size() > 0) {
    sb.append(""String_Node_Str"");
    for (    ChangeMessageInfo changeMessageInfo : changeInfo.messages) {
      AccountInfo author=changeMessageInfo.author;
      if (author != null && author.name != null) {
        sb.append(""String_Node_Str"").append(author.name).append(""String_Node_Str"");
        if (changeMessageInfo.date != null) {
          sb.append(""String_Node_Str"").append(DateFormatUtil.formatPrettyDateTime(changeMessageInfo.date)).append(')');
        }
        sb.append(""String_Node_Str"");
      }
      sb.append(TextToHtml.textToHtml(changeMessageInfo.message)).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
  }
}","private void addMessages(ChangeInfo changeInfo,StringBuilder sb){
  if (changeInfo.messages != null && !changeInfo.messages.isEmpty()) {
    sb.append(""String_Node_Str"");
    for (    ChangeMessageInfo changeMessageInfo : changeInfo.messages) {
      AccountInfo author=changeMessageInfo.author;
      if (author != null && author.name != null) {
        sb.append(""String_Node_Str"").append(author.name).append(""String_Node_Str"");
        if (changeMessageInfo.date != null) {
          sb.append(""String_Node_Str"").append(DateFormatUtil.formatPrettyDateTime(changeMessageInfo.date)).append(')');
        }
        sb.append(""String_Node_Str"");
      }
      sb.append(TextToHtml.textToHtml(changeMessageInfo.message)).append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
  }
}"
52772,"private static String getNumber(ChangeInfo change){
  return ""String_Node_Str"" + change._number;
}","private static String getNumber(ChangeInfo change){
  return Integer.toString(change._number);
}"
52773,"@NotNull private ColumnInfo[] generateColumnsInfo(@NotNull List<ChangeInfo> changes){
  ItemAndWidth number=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth hash=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth topic=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth subject=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth status=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth author=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth project=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth branch=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth time=new ItemAndWidth(""String_Node_Str"",0);
  Set<String> availableLabels=Sets.newTreeSet();
  for (  ChangeInfo change : changes) {
    number=getMax(number,getNumber(change));
    hash=getMax(hash,getHash(change));
    topic=getMax(topic,getTopic(change));
    subject=getMax(subject,getShortenedSubject(change));
    status=getMax(status,getStatus(change));
    author=getMax(author,getOwner(change));
    project=getMax(project,getProject(change));
    branch=getMax(branch,getBranch(change));
    time=getMax(time,getTime(change));
    if (change.labels != null) {
      for (      String label : change.labels.keySet()) {
        availableLabels.add(label);
      }
    }
  }
  List<ColumnInfo> columnList=Lists.newArrayList();
  columnList.add(new GerritChangeColumnStarredInfo());
  boolean showChangeNumberColumn=gerritSettings.getShowChangeNumberColumn();
  if (showChangeNumberColumn) {
    columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",number.item){
      @Override public String valueOf(      ChangeInfo change){
        return getNumber(change);
      }
    }
);
  }
  boolean showChangeIdColumn=gerritSettings.getShowChangeIdColumn();
  if (showChangeIdColumn) {
    columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",hash.item){
      @Override public String valueOf(      ChangeInfo change){
        return getHash(change);
      }
    }
);
  }
  boolean showTopicColumn=gerritSettings.getShowTopicColumn();
  if (showTopicColumn) {
    columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",topic.item){
      @Override public String valueOf(      ChangeInfo change){
        return getTopic(change);
      }
    }
);
  }
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",subject.item){
    @Override public String valueOf(    ChangeInfo change){
      return change.subject;
    }
  }
);
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",status.item){
    @Override public String valueOf(    ChangeInfo change){
      return getStatus(change);
    }
  }
);
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",author.item){
    @Override public String valueOf(    ChangeInfo change){
      return getOwner(change);
    }
  }
);
  ShowProjectColumn showProjectColumn=gerritSettings.getShowProjectColumn();
  boolean listAllChanges=gerritSettings.getListAllChanges();
  if (showProjectColumn == ShowProjectColumn.ALWAYS || (showProjectColumn == ShowProjectColumn.AUTO && (listAllChanges || hasProjectMultipleRepos()))) {
    columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",project.item){
      @Override public String valueOf(      ChangeInfo change){
        return getProject(change);
      }
    }
);
  }
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",branch.item){
    @Override public String valueOf(    ChangeInfo change){
      return getBranch(change);
    }
  }
);
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",time.item){
    @Override public String valueOf(    ChangeInfo change){
      return getTime(change);
    }
  }
);
  for (  final String label : availableLabels) {
    columnList.add(new GerritChangeColumnIconLabelInfo(getShortLabelDisplay(label),label){
      @Override public LabelInfo getLabelInfo(      ChangeInfo change){
        return getLabel(change,label);
      }
    }
);
  }
  columnList.add(selectRevisionInfoColumn);
  return columnList.toArray(new ColumnInfo[columnList.size()]);
}","@NotNull private ColumnInfo[] generateColumnsInfo(@NotNull List<ChangeInfo> changes){
  ItemAndWidth number=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth hash=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth topic=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth subject=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth status=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth author=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth projectName=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth branch=new ItemAndWidth(""String_Node_Str"",0);
  ItemAndWidth time=new ItemAndWidth(""String_Node_Str"",0);
  Set<String> availableLabels=Sets.newTreeSet();
  for (  ChangeInfo change : changes) {
    number=getMax(number,getNumber(change));
    hash=getMax(hash,getHash(change));
    topic=getMax(topic,getTopic(change));
    subject=getMax(subject,getShortenedSubject(change));
    status=getMax(status,getStatus(change));
    author=getMax(author,getOwner(change));
    projectName=getMax(projectName,getProject(change));
    branch=getMax(branch,getBranch(change));
    time=getMax(time,getTime(change));
    if (change.labels != null) {
      for (      String label : change.labels.keySet()) {
        availableLabels.add(label);
      }
    }
  }
  List<ColumnInfo> columnList=Lists.newArrayList();
  columnList.add(new GerritChangeColumnStarredInfo());
  boolean showChangeNumberColumn=gerritSettings.getShowChangeNumberColumn();
  if (showChangeNumberColumn) {
    columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",number.item){
      @Override public String valueOf(      ChangeInfo change){
        return getNumber(change);
      }
    }
);
  }
  boolean showChangeIdColumn=gerritSettings.getShowChangeIdColumn();
  if (showChangeIdColumn) {
    columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",hash.item){
      @Override public String valueOf(      ChangeInfo change){
        return getHash(change);
      }
    }
);
  }
  boolean showTopicColumn=gerritSettings.getShowTopicColumn();
  if (showTopicColumn) {
    columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",topic.item){
      @Override public String valueOf(      ChangeInfo change){
        return getTopic(change);
      }
    }
);
  }
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",subject.item){
    @Override public String valueOf(    ChangeInfo change){
      return change.subject;
    }
  }
);
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",status.item){
    @Override public String valueOf(    ChangeInfo change){
      return getStatus(change);
    }
  }
);
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",author.item){
    @Override public String valueOf(    ChangeInfo change){
      return getOwner(change);
    }
  }
);
  ShowProjectColumn showProjectColumn=gerritSettings.getShowProjectColumn();
  boolean listAllChanges=gerritSettings.getListAllChanges();
  if (showProjectColumn == ShowProjectColumn.ALWAYS || (showProjectColumn == ShowProjectColumn.AUTO && (listAllChanges || hasProjectMultipleRepos()))) {
    columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",projectName.item){
      @Override public String valueOf(      ChangeInfo change){
        return getProject(change);
      }
    }
);
  }
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",branch.item){
    @Override public String valueOf(    ChangeInfo change){
      return getBranch(change);
    }
  }
);
  columnList.add(new GerritChangeColumnInfo(""String_Node_Str"",time.item){
    @Override public String valueOf(    ChangeInfo change){
      return getTime(change);
    }
  }
);
  for (  final String label : availableLabels) {
    columnList.add(new GerritChangeColumnIconLabelInfo(getShortLabelDisplay(label),label){
      @Override public LabelInfo getLabelInfo(      ChangeInfo change){
        return getLabel(change,label);
      }
    }
);
  }
  columnList.add(selectRevisionInfoColumn);
  return columnList.toArray(new ColumnInfo[columnList.size()]);
}"
52774,"public SimpleToolWindowPanel createToolWindowContent(final Project project){
  changeListPanel.registerChangeListPanel(this);
  changeListPanel.setProject(project);
  diffManager.registerDiffTool(commentsDiffTool);
  SimpleToolWindowPanel panel=new SimpleToolWindowPanel(true,true);
  ActionToolbar toolbar=createToolbar(project);
  toolbar.setTargetComponent(changeListPanel);
  panel.setToolbar(toolbar.getComponent());
  RepositoryChangesBrowser repositoryChangesBrowser=repositoryChangesBrowserProvider.get(project,changeListPanel);
  Splitter detailsSplitter=new Splitter(true,0.6f);
  detailsSplitter.setShowDividerControls(true);
  changeListPanel.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT | SideBorder.BOTTOM));
  detailsSplitter.setFirstComponent(changeListPanel);
  detailsPanel=new GerritChangeDetailsPanel(project);
  changeListPanel.addListSelectionListener(new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeInfo){
      changeSelected(changeInfo,project);
    }
  }
);
  JPanel details=detailsPanel.getComponent();
  details.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT));
  detailsSplitter.setSecondComponent(details);
  Splitter horizontalSplitter=new Splitter(false,0.7f);
  horizontalSplitter.setShowDividerControls(true);
  horizontalSplitter.setFirstComponent(detailsSplitter);
  horizontalSplitter.setSecondComponent(repositoryChangesBrowser);
  panel.setContent(horizontalSplitter);
  reloadChanges(project,false);
  changeListPanel.showSetupHintWhenRequired(project);
  return panel;
}","public SimpleToolWindowPanel createToolWindowContent(final Project project){
  changeListPanel.setProject(project);
  diffManager.registerDiffTool(commentsDiffTool);
  SimpleToolWindowPanel panel=new SimpleToolWindowPanel(true,true);
  ActionToolbar toolbar=createToolbar(project);
  toolbar.setTargetComponent(changeListPanel);
  panel.setToolbar(toolbar.getComponent());
  RepositoryChangesBrowser repositoryChangesBrowser=repositoryChangesBrowserProvider.get(project,changeListPanel);
  Splitter detailsSplitter=new Splitter(true,0.6f);
  detailsSplitter.setShowDividerControls(true);
  changeListPanel.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT | SideBorder.BOTTOM));
  detailsSplitter.setFirstComponent(changeListPanel);
  detailsPanel=new GerritChangeDetailsPanel(project);
  changeListPanel.addListSelectionListener(new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeInfo){
      changeSelected(changeInfo,project);
    }
  }
);
  JPanel details=detailsPanel.getComponent();
  details.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT));
  detailsSplitter.setSecondComponent(details);
  Splitter horizontalSplitter=new Splitter(false,0.7f);
  horizontalSplitter.setShowDividerControls(true);
  horizontalSplitter.setFirstComponent(detailsSplitter);
  horizontalSplitter.setSecondComponent(repositoryChangesBrowser);
  panel.setContent(horizontalSplitter);
  reloadChanges(project,false);
  changeListPanel.showSetupHintWhenRequired(project);
  return panel;
}"
52775,"@NotNull protected Action[] createActions(){
  return new Action[]{getOKAction(),getCancelAction(),getHelpAction()};
}","@Override @NotNull protected Action[] createActions(){
  return new Action[]{getOKAction(),getCancelAction(),getHelpAction()};
}"
52776,"private String buildBranchName(ChangeInfo changeDetails){
  RevisionInfo revisionInfo=changeDetails.revisions.get(selectedRevisions.get(changeDetails));
  String topic=changeDetails.topic;
  if (topic == null) {
    topic=""String_Node_Str"" + changeDetails._number;
  }
  String branchName=""String_Node_Str"" + changeDetails.owner.name.toLowerCase().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + '/'+ topic;
  if (revisionInfo._number != changeDetails.revisions.size()) {
    branchName+=""String_Node_Str"" + revisionInfo._number;
  }
  return branchName;
}","private String buildBranchName(ChangeInfo changeDetails){
  RevisionInfo revisionInfo=changeDetails.revisions.get(selectedRevisions.get(changeDetails));
  String topic=changeDetails.topic;
  if (topic == null) {
    topic=Integer.toString(changeDetails._number);
  }
  String branchName=""String_Node_Str"" + changeDetails.owner.name.toLowerCase().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"") + '/'+ topic;
  if (revisionInfo._number != changeDetails.revisions.size()) {
    branchName+=""String_Node_Str"" + revisionInfo._number;
  }
  return branchName;
}"
52777,"public String getLongCommitMessage(){
  return String.format(PATTERN,getParentLine(),gitCommit.getAuthor().getName(),gitCommit.getAuthor().getEmail(),DATE_FORMAT.format(new Date(gitCommit.getAuthorTime())),gitCommit.getCommitter().getName(),gitCommit.getCommitter().getEmail(),DATE_FORMAT.format(gitCommit.getCommitTime()),gitCommit.getFullMessage());
}","public String getLongCommitMessage(){
  return String.format(PATTERN,getParentLine(),gitCommit.getAuthor().getName(),gitCommit.getAuthor().getEmail(),DATE_FORMAT.get().format(new Date(gitCommit.getAuthorTime())),gitCommit.getCommitter().getName(),gitCommit.getCommitter().getEmail(),DATE_FORMAT.get().format(gitCommit.getCommitTime()),gitCommit.getFullMessage());
}"
52778,"public void requestFocus(){
  IdeFocusManager.findInstanceByComponent(reviewTextField).requestFocus(reviewTextField,true);
}","@Override public void requestFocus(){
  IdeFocusManager.findInstanceByComponent(reviewTextField).requestFocus(reviewTextField,true);
}"
52779,"public CommentableDiffPanel(Window window,DiffRequest request,ChangeInfo changeInfo,String selectedRevisionId,Optional<Pair<String,RevisionInfo>> baseRevision){
  super(window,request.getProject(),true,true,DiffManagerImpl.FULL_DIFF_DIVIDER_POLYGONS_OFFSET,CommentsDiffTool.this);
  this.changeInfo=changeInfo;
  this.selectedRevisionId=selectedRevisionId;
  this.baseRevision=baseRevision;
}","private CommentableDiffPanel(Window window,DiffRequest request,ChangeInfo changeInfo,String selectedRevisionId,Optional<Pair<String,RevisionInfo>> baseRevision){
  super(window,request.getProject(),true,true,DiffManagerImpl.FULL_DIFF_DIVIDER_POLYGONS_OFFSET,CommentsDiffTool.this);
  this.changeInfo=changeInfo;
  this.selectedRevisionId=selectedRevisionId;
  this.baseRevision=baseRevision;
}"
52780,"public static RangeHighlighter highlightRangeComment(Comment.Range range,Editor editor,Project project){
  CharSequence charsSequence=editor.getMarkupModel().getDocument().getCharsSequence();
  RangeUtils.Offset offset=RangeUtils.rangeToTextOffset(charsSequence,range);
  TextAttributes attributes=new TextAttributes();
  attributes.setBackgroundColor(JBColor.YELLOW);
  ArrayList<RangeHighlighter> highlighters=Lists.newArrayList();
  HighlightManager highlightManager=HighlightManager.getInstance(project);
  highlightManager.addRangeHighlight(editor,offset.start,offset.end,attributes,false,highlighters);
  return highlighters.get(0);
}","private static RangeHighlighter highlightRangeComment(Comment.Range range,Editor editor,Project project){
  CharSequence charsSequence=editor.getMarkupModel().getDocument().getCharsSequence();
  RangeUtils.Offset offset=RangeUtils.rangeToTextOffset(charsSequence,range);
  TextAttributes attributes=new TextAttributes();
  attributes.setBackgroundColor(JBColor.YELLOW);
  ArrayList<RangeHighlighter> highlighters=Lists.newArrayList();
  HighlightManager highlightManager=HighlightManager.getInstance(project);
  highlightManager.addRangeHighlight(editor,offset.start,offset.end,attributes,false,highlighters);
  return highlighters.get(0);
}"
52781,"@Override @Nullable public String getSearchQueryPart(){
  if (value.isPresent()) {
    if (value.get().forQuery.isPresent()) {
      return String.format(""String_Node_Str"",value.get().forQuery.get());
    }
 else {
      return queryForAll.get();
    }
  }
 else {
    return null;
  }
}","@Override @Nullable public String getSearchQueryPart(){
  if (value.isPresent()) {
    if (value.get().forQuery.isPresent()) {
      return String.format(""String_Node_Str"",value.get().forQuery.get());
    }
 else {
      return QUERY_FOR_ALL.get();
    }
  }
 else {
    return null;
  }
}"
52782,"@Override protected void createActions(Consumer<AnAction> actionConsumer){
  for (  final Status status : statuses) {
    actionConsumer.consume(new DumbAwareAction(status.label){
      @Override public void actionPerformed(      AnActionEvent e){
        value=Optional.of(status);
        updateFilterValueLabel(status.label);
        setChanged();
        notifyObservers(project);
      }
    }
);
  }
}","@Override protected void createActions(Consumer<AnAction> actionConsumer){
  for (  final Status status : STATUSES) {
    actionConsumer.consume(new DumbAwareAction(status.label){
      @Override public void actionPerformed(      AnActionEvent e){
        value=Optional.of(status);
        updateFilterValueLabel(status.label);
        setChanged();
        notifyObservers(project);
      }
    }
);
  }
}"
52783,"@Override public String get(){
  Set<String> queryForAll=Sets.newHashSet();
  for (  Status status : statuses) {
    if (status.forQuery.isPresent()) {
      queryForAll.add(String.format(""String_Node_Str"",status.forQuery.get()));
    }
  }
  return String.format(""String_Node_Str"",Joiner.on(""String_Node_Str"").join(queryForAll));
}","@Override public String get(){
  Set<String> queryForAll=Sets.newHashSet();
  for (  Status status : STATUSES) {
    if (status.forQuery.isPresent()) {
      queryForAll.add(String.format(""String_Node_Str"",status.forQuery.get()));
    }
  }
  return String.format(""String_Node_Str"",Joiner.on(""String_Node_Str"").join(queryForAll));
}"
52784,"public StatusFilter(){
  value=Optional.of(statuses.get(1));
}","public StatusFilter(){
  value=Optional.of(STATUSES.get(1));
}"
52785,"/** 
 * Load the next page of changes into the provided consumer
 */
public void getNextPage(final Consumer<List<ChangeInfo>> consumer){
  if (hasMore) {
    lock.lock();
    Changes.QueryRequest myRequest=queryRequest.withLimit(PAGE_SIZE).withStart(changes.size());
    if (sortkey != null) {
      myRequest.withSortkey(sortkey);
    }
    Consumer<List<ChangeInfo>> myConsumer=new Consumer<List<ChangeInfo>>(){
      @Override public void consume(      List<ChangeInfo> changeInfos){
        if (changeInfos != null && !changeInfos.isEmpty()) {
          ChangeInfo lastChangeInfo=Iterables.getLast(changeInfos);
          hasMore=lastChangeInfo._moreChanges != null && lastChangeInfo._moreChanges;
          sortkey=lastChangeInfo._sortkey;
          changes.addAll(changeInfos);
          consumer.consume(changeInfos);
        }
 else {
          hasMore=false;
        }
        lock.unlock();
      }
    }
;
    gerritUtil.getChanges(myRequest,project,myConsumer);
  }
}","/** 
 * Load the next page of changes into the provided consumer
 */
public void getNextPage(final Consumer<List<ChangeInfo>> consumer){
  if (hasMore) {
    lock.lock();
    Changes.QueryRequest myRequest=queryRequest.withLimit(PAGE_SIZE).withStart(changes.size());
    if (sortkey != null) {
      myRequest.withSortkey(sortkey);
    }
    Consumer<List<ChangeInfo>> myConsumer=new Consumer<List<ChangeInfo>>(){
      @Override public void consume(      List<ChangeInfo> changeInfos){
        if (changeInfos != null && !changeInfos.isEmpty()) {
          ChangeInfo lastChangeInfo=Iterables.getLast(changeInfos);
          hasMore=lastChangeInfo._moreChanges != null && lastChangeInfo._moreChanges;
          sortkey=lastChangeInfo._sortkey;
          changes.addAll(changeInfos);
        }
 else {
          hasMore=false;
        }
        consumer.consume(changeInfos);
        lock.unlock();
      }
    }
;
    gerritUtil.getChanges(myRequest,project,myConsumer);
  }
}"
52786,"@Override public void consume(List<ChangeInfo> changeInfos){
  if (changeInfos != null && !changeInfos.isEmpty()) {
    ChangeInfo lastChangeInfo=Iterables.getLast(changeInfos);
    hasMore=lastChangeInfo._moreChanges != null && lastChangeInfo._moreChanges;
    sortkey=lastChangeInfo._sortkey;
    changes.addAll(changeInfos);
    consumer.consume(changeInfos);
  }
 else {
    hasMore=false;
  }
  lock.unlock();
}","@Override public void consume(List<ChangeInfo> changeInfos){
  if (changeInfos != null && !changeInfos.isEmpty()) {
    ChangeInfo lastChangeInfo=Iterables.getLast(changeInfos);
    hasMore=lastChangeInfo._moreChanges != null && lastChangeInfo._moreChanges;
    sortkey=lastChangeInfo._sortkey;
    changes.addAll(changeInfos);
  }
 else {
    hasMore=false;
  }
  consumer.consume(changeInfos);
  lock.unlock();
}"
52787,"/** 
 * Load the next page of changes into the provided consumer
 */
public void getNextPage(final Consumer<List<ChangeInfo>> consumer){
  if (hasMore) {
    lock.lock();
    Changes.QueryRequest myRequest=queryRequest.withLimit(PAGE_SIZE).withStart(changes.size());
    if (sortkey != null) {
      myRequest.withSortkey(sortkey);
    }
    Consumer<List<ChangeInfo>> myConsumer=new Consumer<List<ChangeInfo>>(){
      @Override public void consume(      List<ChangeInfo> changeInfos){
        if (changeInfos != null && !changeInfos.isEmpty()) {
          ChangeInfo lastChangeInfo=Iterables.getLast(changeInfos);
          hasMore=lastChangeInfo._moreChanges != null && lastChangeInfo._moreChanges;
          sortkey=lastChangeInfo._sortkey;
          changes.addAll(changeInfos);
          consumer.consume(changeInfos);
        }
 else {
          hasMore=false;
        }
        lock.unlock();
      }
    }
;
    gerritUtil.getChanges(myRequest,project,myConsumer);
  }
}","/** 
 * Load the next page of changes into the provided consumer
 */
public void getNextPage(final Consumer<List<ChangeInfo>> consumer){
  if (hasMore) {
    lock.lock();
    Changes.QueryRequest myRequest=queryRequest.withLimit(PAGE_SIZE).withStart(changes.size());
    if (sortkey != null) {
      myRequest.withSortkey(sortkey);
    }
    Consumer<List<ChangeInfo>> myConsumer=new Consumer<List<ChangeInfo>>(){
      @Override public void consume(      List<ChangeInfo> changeInfos){
        if (changeInfos != null && !changeInfos.isEmpty()) {
          ChangeInfo lastChangeInfo=Iterables.getLast(changeInfos);
          hasMore=lastChangeInfo._moreChanges != null && lastChangeInfo._moreChanges;
          sortkey=lastChangeInfo._sortkey;
          changes.addAll(changeInfos);
        }
 else {
          hasMore=false;
        }
        consumer.consume(changeInfos);
        lock.unlock();
      }
    }
;
    gerritUtil.getChanges(myRequest,project,myConsumer);
  }
}"
52788,"@Override public void consume(List<ChangeInfo> changeInfos){
  if (changeInfos != null && !changeInfos.isEmpty()) {
    ChangeInfo lastChangeInfo=Iterables.getLast(changeInfos);
    hasMore=lastChangeInfo._moreChanges != null && lastChangeInfo._moreChanges;
    sortkey=lastChangeInfo._sortkey;
    changes.addAll(changeInfos);
    consumer.consume(changeInfos);
  }
 else {
    hasMore=false;
  }
  lock.unlock();
}","@Override public void consume(List<ChangeInfo> changeInfos){
  if (changeInfos != null && !changeInfos.isEmpty()) {
    ChangeInfo lastChangeInfo=Iterables.getLast(changeInfos);
    hasMore=lastChangeInfo._moreChanges != null && lastChangeInfo._moreChanges;
    sortkey=lastChangeInfo._sortkey;
    changes.addAll(changeInfos);
  }
 else {
    hasMore=false;
  }
  consumer.consume(changeInfos);
  lock.unlock();
}"
52789,"public SimpleToolWindowPanel createToolWindowContent(final Project project){
  this.project=project;
  changeListPanel.registerChangeListPanel(this);
  diffManager.registerDiffTool(commentsDiffTool);
  SimpleToolWindowPanel panel=new SimpleToolWindowPanel(true,true);
  ActionToolbar toolbar=createToolbar(project);
  toolbar.setTargetComponent(changeListPanel);
  panel.setToolbar(toolbar.getComponent());
  RepositoryChangesBrowser repositoryChangesBrowser=repositoryChangesBrowserProvider.get(project);
  Splitter detailsSplitter=new Splitter(true,0.6f);
  detailsSplitter.setShowDividerControls(true);
  changeListPanel.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT | SideBorder.BOTTOM));
  detailsSplitter.setFirstComponent(changeListPanel);
  detailsPanel=new GerritChangeDetailsPanel(project);
  changeListPanel.addListSelectionListener(new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeInfo){
      changeSelected(changeInfo,project);
    }
  }
);
  JPanel details=detailsPanel.getComponent();
  details.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT));
  detailsSplitter.setSecondComponent(details);
  Splitter horizontalSplitter=new Splitter(false,0.7f);
  horizontalSplitter.setShowDividerControls(true);
  horizontalSplitter.setFirstComponent(detailsSplitter);
  horizontalSplitter.setSecondComponent(repositoryChangesBrowser);
  panel.setContent(horizontalSplitter);
  reloadChanges(project,false);
  return panel;
}","public SimpleToolWindowPanel createToolWindowContent(final Project project){
  changeListPanel.registerChangeListPanel(this);
  diffManager.registerDiffTool(commentsDiffTool);
  SimpleToolWindowPanel panel=new SimpleToolWindowPanel(true,true);
  ActionToolbar toolbar=createToolbar(project);
  toolbar.setTargetComponent(changeListPanel);
  panel.setToolbar(toolbar.getComponent());
  RepositoryChangesBrowser repositoryChangesBrowser=repositoryChangesBrowserProvider.get(project,changeListPanel);
  Splitter detailsSplitter=new Splitter(true,0.6f);
  detailsSplitter.setShowDividerControls(true);
  changeListPanel.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT | SideBorder.BOTTOM));
  detailsSplitter.setFirstComponent(changeListPanel);
  detailsPanel=new GerritChangeDetailsPanel(project);
  changeListPanel.addListSelectionListener(new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeInfo){
      changeSelected(changeInfo,project);
    }
  }
);
  JPanel details=detailsPanel.getComponent();
  details.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT));
  detailsSplitter.setSecondComponent(details);
  Splitter horizontalSplitter=new Splitter(false,0.7f);
  horizontalSplitter.setShowDividerControls(true);
  horizontalSplitter.setFirstComponent(detailsSplitter);
  horizontalSplitter.setSecondComponent(repositoryChangesBrowser);
  panel.setContent(horizontalSplitter);
  reloadChanges(project,false);
  return panel;
}"
52790,"@Override protected void configure(){
  install(new GerritFilterModule());
  bind(GerritSelectRevisionInfoColumn.class).asEagerSingleton();
  Multibinder<GerritChangeNodeDecorator> decorators=Multibinder.newSetBinder(binder(),GerritChangeNodeDecorator.class);
  decorators.addBinding().to(GerritCommentCountChangeNodeDecorator.class);
  bind(RepositoryChangesBrowserProvider.class);
  bind(SettingsPanel.class);
  bind(GerritSettingsConfigurable.class);
  bind(GerritUpdatesNotificationComponent.class).asEagerSingleton();
  bind(GerritChangeListPanel.class).asEagerSingleton();
}","@Override protected void configure(){
  install(new GerritFilterModule());
  bind(GerritSelectRevisionInfoColumn.class);
  Multibinder<GerritChangeNodeDecorator> decorators=Multibinder.newSetBinder(binder(),GerritChangeNodeDecorator.class);
  decorators.addBinding().to(GerritCommentCountChangeNodeDecorator.class);
  bind(RepositoryChangesBrowserProvider.class);
  bind(SettingsPanel.class);
  bind(GerritSettingsConfigurable.class);
  bind(GerritUpdatesNotificationComponent.class).asEagerSingleton();
  bind(GerritChangeListPanel.class);
}"
52791,"public RepositoryChangesBrowser get(final Project project){
  selectBaseRevisionAction=new SelectBaseRevisionAction(project,selectedRevisions);
  TableView<ChangeInfo> table=changeListPanel.getTable();
  final GerritRepositoryChangesBrowser changesBrowser=new GerritRepositoryChangesBrowser(project);
  changesBrowser.getDiffAction().registerCustomShortcutSet(CommonShortcuts.getDiff(),table);
  changesBrowser.getViewer().setScrollPaneBorder(IdeBorderFactory.createBorder(SideBorder.LEFT | SideBorder.TOP));
  changesBrowser.getViewer().setChangeDecorator(changesBrowser.getChangeNodeDecorator());
  reviewCommentSink.addObserver(new Observer(){
    @Override public void update(    Observable o,    Object arg){
      changesBrowser.repaint();
    }
  }
);
  changeListPanel.addListSelectionListener(new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeInfo){
      changesBrowser.setSelectedChange(changeInfo);
    }
  }
);
  return changesBrowser;
}","public RepositoryChangesBrowser get(Project project,GerritChangeListPanel changeListPanel){
  selectBaseRevisionAction=new SelectBaseRevisionAction(project,selectedRevisions);
  TableView<ChangeInfo> table=changeListPanel.getTable();
  final GerritRepositoryChangesBrowser changesBrowser=new GerritRepositoryChangesBrowser(project);
  changesBrowser.getDiffAction().registerCustomShortcutSet(CommonShortcuts.getDiff(),table);
  changesBrowser.getViewer().setScrollPaneBorder(IdeBorderFactory.createBorder(SideBorder.LEFT | SideBorder.TOP));
  changesBrowser.getViewer().setChangeDecorator(changesBrowser.getChangeNodeDecorator());
  reviewCommentSink.addObserver(new Observer(){
    @Override public void update(    Observable o,    Object arg){
      changesBrowser.repaint();
    }
  }
);
  changeListPanel.addListSelectionListener(new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeInfo){
      changesBrowser.setSelectedChange(changeInfo);
    }
  }
);
  return changesBrowser;
}"
52792,"public void getChangesToReview(Project project,Consumer<LoadChangesProxy> consumer){
  getChanges(""String_Node_Str"",project,consumer);
}","public void getChangesToReview(Project project,Consumer<List<ChangeInfo>> consumer){
  Changes.QueryRequest queryRequest=gerritClient.changes().query(""String_Node_Str"");
  getChanges(queryRequest,project,consumer);
}"
52793,"@Override public void consume(LoadChangesProxy proxy){
  boolean newChange=false;
  List<ChangeInfo> changes=proxy.getChanges();
  for (  ChangeInfo change : changes) {
    if (!notifiedChanges.contains(change.changeId)) {
      newChange=true;
      break;
    }
  }
  if (newChange) {
    StringBuilder stringBuilder=new StringBuilder();
    stringBuilder.append(""String_Node_Str"");
    for (    ChangeInfo change : changes) {
      stringBuilder.append(""String_Node_Str"").append(!notifiedChanges.contains(change.changeId) ? ""String_Node_Str"" : ""String_Node_Str"").append(change.project).append(""String_Node_Str"").append(change.subject).append(""String_Node_Str"").append(change.owner.name).append(')').append(""String_Node_Str"");
      notifiedChanges.add(change.changeId);
    }
    stringBuilder.append(""String_Node_Str"");
    NotificationBuilder notification=new NotificationBuilder(project,""String_Node_Str"",stringBuilder.toString());
    notificationService.notifyInformation(notification);
  }
}","@Override public void consume(List<ChangeInfo> changes){
  boolean newChange=false;
  for (  ChangeInfo change : changes) {
    if (!notifiedChanges.contains(change.changeId)) {
      newChange=true;
      break;
    }
  }
  if (newChange) {
    StringBuilder stringBuilder=new StringBuilder();
    stringBuilder.append(""String_Node_Str"");
    for (    ChangeInfo change : changes) {
      stringBuilder.append(""String_Node_Str"").append(!notifiedChanges.contains(change.changeId) ? ""String_Node_Str"" : ""String_Node_Str"").append(change.project).append(""String_Node_Str"").append(change.subject).append(""String_Node_Str"").append(change.owner.name).append(')').append(""String_Node_Str"");
      notifiedChanges.add(change.changeId);
    }
    stringBuilder.append(""String_Node_Str"");
    NotificationBuilder notification=new NotificationBuilder(project,""String_Node_Str"",stringBuilder.toString());
    notificationService.notifyInformation(notification);
  }
}"
52794,"@Nullable @Override public AuthData getAuthData(@NotNull String url){
  return delegate.getAuthData(url);
}","@Nullable @Override public AuthData getAuthData(@NotNull String url,@Nullable ModalityState modalityState){
  return delegate.getAuthData(url,modalityState);
}"
52795,"@Override protected void onFailure(){
  log.warn(""String_Node_Str"" + h.errors());
  Collection<Exception> errors=Lists.newArrayList();
  if (!h.hadAuthRequest()) {
    errors.addAll(h.errors());
  }
 else {
    errors.add(new VcsException(""String_Node_Str""));
  }
  result.set(GitFetchResult.error(errors));
}","@Override protected void onFailure(){
  log.warn(""String_Node_Str"" + h.errors());
  Collection<Exception> errors=Lists.newArrayList();
  errors.addAll(h.errors());
  result.set(GitFetchResult.error(errors));
}"
52796,"@NotNull public GitFetchResult fetchNatively(@NotNull VirtualFile root,@NotNull GitRemote remote,@NotNull String url,@Nullable String branch,Project project,ProgressIndicator progressIndicator){
  final GitLineHandlerPasswordRequestAware h=new GitLineHandlerPasswordRequestAware(project,root,GitCommand.FETCH);
  h.setUrl(url);
  h.addProgressParameter();
  String remoteName=remote.getName();
  h.addParameters(remoteName);
  if (branch != null) {
    h.addParameters(branch);
  }
  final GitTask fetchTask=new GitTask(project,h,""String_Node_Str"" + remote.getFirstUrl());
  fetchTask.setProgressIndicator(progressIndicator);
  fetchTask.setProgressAnalyzer(new GitStandardProgressAnalyzer());
  final AtomicReference<GitFetchResult> result=new AtomicReference<GitFetchResult>();
  fetchTask.execute(true,false,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
      result.set(GitFetchResult.success());
    }
    @Override protected void onCancel(){
      log.info(""String_Node_Str"");
      result.set(GitFetchResult.cancel());
    }
    @Override protected void onFailure(){
      log.warn(""String_Node_Str"" + h.errors());
      Collection<Exception> errors=Lists.newArrayList();
      if (!h.hadAuthRequest()) {
        errors.addAll(h.errors());
      }
 else {
        errors.add(new VcsException(""String_Node_Str""));
      }
      result.set(GitFetchResult.error(errors));
    }
  }
);
  return result.get();
}","@NotNull public GitFetchResult fetchNatively(@NotNull VirtualFile root,@NotNull GitRemote remote,@NotNull String url,@Nullable String branch,Project project,ProgressIndicator progressIndicator){
  final GitLineHandler h=new GitLineHandler(project,root,GitCommand.FETCH);
  h.setUrl(url);
  h.addProgressParameter();
  String remoteName=remote.getName();
  h.addParameters(remoteName);
  if (branch != null) {
    h.addParameters(branch);
  }
  final GitTask fetchTask=new GitTask(project,h,""String_Node_Str"" + remote.getFirstUrl());
  fetchTask.setProgressIndicator(progressIndicator);
  fetchTask.setProgressAnalyzer(new GitStandardProgressAnalyzer());
  final AtomicReference<GitFetchResult> result=new AtomicReference<GitFetchResult>();
  fetchTask.execute(true,false,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
      result.set(GitFetchResult.success());
    }
    @Override protected void onCancel(){
      log.info(""String_Node_Str"");
      result.set(GitFetchResult.cancel());
    }
    @Override protected void onFailure(){
      log.warn(""String_Node_Str"" + h.errors());
      Collection<Exception> errors=Lists.newArrayList();
      errors.addAll(h.errors());
      result.set(GitFetchResult.error(errors));
    }
  }
);
  return result.get();
}"
52797,"@Override public void consume(ChangeInfo changeDetails){
  selectedChange=changeDetails;
  baseRevision=Optional.absent();
  updateChangesBrowser();
  selectBaseRevisionAction.setSelectedChange(selectedChange);
  for (  GerritChangeNodeDecorator decorator : changeNodeDecorators) {
    decorator.onChangeSelected(project,selectedChange);
  }
}","@Override public void consume(ChangeInfo changeDetails){
  if (selectedChange.changeId.equals(changeDetails.changeId)) {
    selectedChange=changeDetails;
    baseRevision=Optional.absent();
    selectBaseRevisionAction.setSelectedChange(selectedChange);
    for (    GerritChangeNodeDecorator decorator : changeNodeDecorators) {
      decorator.onChangeSelected(project,selectedChange);
    }
    updateChangesBrowser();
  }
}"
52798,"protected void setSelectedChange(ChangeInfo changeInfo){
  gerritUtil.getChangeDetails(changeInfo._number,project,new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeDetails){
      selectedChange=changeDetails;
      baseRevision=Optional.absent();
      updateChangesBrowser();
      selectBaseRevisionAction.setSelectedChange(selectedChange);
      for (      GerritChangeNodeDecorator decorator : changeNodeDecorators) {
        decorator.onChangeSelected(project,selectedChange);
      }
    }
  }
);
}","protected void setSelectedChange(ChangeInfo changeInfo){
  selectedChange=changeInfo;
  gerritUtil.getChangeDetails(changeInfo._number,project,new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeDetails){
      if (selectedChange.changeId.equals(changeDetails.changeId)) {
        selectedChange=changeDetails;
        baseRevision=Optional.absent();
        selectBaseRevisionAction.setSelectedChange(selectedChange);
        for (        GerritChangeNodeDecorator decorator : changeNodeDecorators) {
          decorator.onChangeSelected(project,selectedChange);
        }
        updateChangesBrowser();
      }
    }
  }
);
}"
52799,"@Override protected void configure(){
  installOpenIdeDependenciesModule();
  setupSettingsProvider();
  bind(NotificationService.class);
  bind(ReviewCommentSink.class).toInstance(new ReviewCommentSink());
  bind(GerritGitUtil.class).asEagerSingleton();
  bind(GerritUtil.class).asEagerSingleton();
  bind(GerritToolWindow.class).asEagerSingleton();
  bind(GerritCheckoutProvider.class);
  bind(GerritHttpAuthDataProvider.class);
  install(new GerritActionsModule());
  install(new GerritDiffModule());
  install(new GerritRestModule());
  install(new GerritUiModule());
}","@Override protected void configure(){
  installOpenIdeDependenciesModule();
  setupSettingsProvider();
  bind(NotificationService.class);
  bind(ReviewCommentSink.class).toInstance(new ReviewCommentSink());
  bind(GerritGitUtil.class).asEagerSingleton();
  bind(GerritUtil.class).asEagerSingleton();
  bind(GerritToolWindow.class);
  bind(GerritCheckoutProvider.class);
  bind(GerritHttpAuthDataProvider.class);
  install(new GerritActionsModule());
  install(new GerritDiffModule());
  install(new GerritRestModule());
  install(new GerritUiModule());
}"
52800,"@Override public void calcData(DataKey key,DataSink sink){
  if (VcsDataKeys.CHANGES.equals(key)) {
    int[] rows=table.getSelectedRows();
    if (rows.length != 1)     return;
    int row=rows[0];
  }
}","@Override public void calcData(DataKey key,DataSink sink){
  sink.put(GerritDataKeys.TOOL_WINDOW,gerritToolWindow);
  if (VcsDataKeys.CHANGES.equals(key)) {
    int[] rows=table.getSelectedRows();
    if (rows.length != 1)     return;
    int row=rows[0];
  }
}"
52801,"public SimpleToolWindowPanel createToolWindowContent(final Project project){
  diffManager.registerDiffTool(commentsDiffTool);
  SimpleToolWindowPanel panel=new SimpleToolWindowPanel(true,true);
  ActionToolbar toolbar=createToolbar(project);
  toolbar.setTargetComponent(changeListPanel);
  panel.setToolbar(toolbar.getComponent());
  repositoryChangesBrowser=createRepositoryChangesBrowser(project);
  detailsSplitter=new Splitter(true,0.6f);
  detailsSplitter.setShowDividerControls(true);
  changeListPanel.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT | SideBorder.BOTTOM));
  detailsSplitter.setFirstComponent(changeListPanel);
  detailsPanel=new GerritChangeDetailsPanel(project);
  JPanel details=detailsPanel.getComponent();
  details.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT));
  detailsSplitter.setSecondComponent(details);
  Splitter horizontalSplitter=new Splitter(false,0.7f);
  horizontalSplitter.setShowDividerControls(true);
  horizontalSplitter.setFirstComponent(detailsSplitter);
  horizontalSplitter.setSecondComponent(repositoryChangesBrowser);
  panel.setContent(horizontalSplitter);
  reloadChanges(project,false);
  return panel;
}","public SimpleToolWindowPanel createToolWindowContent(final Project project){
  changeListPanel.registerChangeListPanel(this);
  diffManager.registerDiffTool(commentsDiffTool);
  SimpleToolWindowPanel panel=new SimpleToolWindowPanel(true,true);
  ActionToolbar toolbar=createToolbar(project);
  toolbar.setTargetComponent(changeListPanel);
  panel.setToolbar(toolbar.getComponent());
  repositoryChangesBrowser=createRepositoryChangesBrowser(project);
  detailsSplitter=new Splitter(true,0.6f);
  detailsSplitter.setShowDividerControls(true);
  changeListPanel.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT | SideBorder.BOTTOM));
  detailsSplitter.setFirstComponent(changeListPanel);
  detailsPanel=new GerritChangeDetailsPanel(project);
  JPanel details=detailsPanel.getComponent();
  details.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT));
  detailsSplitter.setSecondComponent(details);
  Splitter horizontalSplitter=new Splitter(false,0.7f);
  horizontalSplitter.setShowDividerControls(true);
  horizontalSplitter.setFirstComponent(detailsSplitter);
  horizontalSplitter.setSecondComponent(repositoryChangesBrowser);
  panel.setContent(horizontalSplitter);
  reloadChanges(project,false);
  return panel;
}"
52802,"private ActionToolbar createToolbar(final Project project){
  DefaultActionGroup group=(DefaultActionGroup)ActionManager.getInstance().getAction(""String_Node_Str"");
  DefaultActionGroup filterGroup=new DefaultActionGroup();
  Iterable<ChangesFilter> filters=changesFilters.getFilters();
  for (  ChangesFilter filter : filters) {
    filterGroup.add(filter.getAction(project));
  }
  filterGroup.add(new Separator());
  group.add(filterGroup,Constraints.FIRST);
  changesFilters.addObserver(new Observer(){
    @Override public void update(    Observable observable,    Object o){
      reloadChanges(project,true);
    }
  }
);
  return ActionManager.getInstance().createActionToolbar(""String_Node_Str"",group,true);
}","private ActionToolbar createToolbar(final Project project){
  DefaultActionGroup groupFromConfig=(DefaultActionGroup)ActionManager.getInstance().getAction(""String_Node_Str"");
  DefaultActionGroup group=new DefaultActionGroup(groupFromConfig);
  DefaultActionGroup filterGroup=new DefaultActionGroup();
  Iterable<ChangesFilter> filters=changesFilters.getFilters();
  for (  ChangesFilter filter : filters) {
    filterGroup.add(filter.getAction(project));
  }
  filterGroup.add(new Separator());
  group.add(filterGroup,Constraints.FIRST);
  changesFilters.addObserver(new Observer(){
    @Override public void update(    Observable observable,    Object o){
      reloadChanges(project,true);
    }
  }
);
  return ActionManager.getInstance().createActionToolbar(""String_Node_Str"",group,true);
}"
52803,"private void addCommentsGutter(DiffPanelImpl diffPanel,FilePath filePath,TreeMap<String,List<CommentInfo>> comments,ChangeInfo changeInfo,Project project){
  String repositoryPath=getGitRepositoryPathForChange(project,changeInfo);
  List<CommentInfo> fileComments=Lists.newArrayList();
  for (  Map.Entry<String,List<CommentInfo>> entry : comments.entrySet()) {
    if (isForCurrentFile(filePath,entry.getKey(),repositoryPath)) {
      fileComments=entry.getValue();
      break;
    }
  }
  Iterable<CommentInput> commentInputsFromSink=reviewCommentSink.getCommentsForChange(changeInfo.getId());
  for (  CommentInput commentInput : commentInputsFromSink) {
    if (isForCurrentFile(filePath,commentInput.getPath(),repositoryPath)) {
      fileComments.add(commentInput.toCommentInfo());
    }
  }
  for (  CommentInfo fileComment : fileComments) {
    MarkupModel markup;
    if (fileComment.getSide() != null && fileComment.getSide().equals(CommentBase.CommentSide.PARENT)) {
      markup=diffPanel.getEditor1().getMarkupModel();
    }
 else {
      markup=diffPanel.getEditor2().getMarkupModel();
    }
    int lineCount=markup.getDocument().getLineCount();
    int line=fileComment.getLine() - 1;
    if (line < 0) {
      line=0;
    }
    if (line > lineCount - 1) {
      line=lineCount - 1;
    }
    final RangeHighlighter highlighter=markup.addLineHighlighter(line,HighlighterLayer.ERROR + 1,null);
    highlighter.setGutterIconRenderer(new CommentGutterIconRenderer(fileComment,reviewCommentSink,changeInfo,highlighter,markup));
  }
}","private void addCommentsGutter(DiffPanelImpl diffPanel,FilePath filePath,TreeMap<String,List<CommentInfo>> comments,ChangeInfo changeInfo,Project project){
  String repositoryPath=getGitRepositoryPathForChange(project,changeInfo);
  List<CommentInfo> fileComments=Lists.newArrayList();
  for (  Map.Entry<String,List<CommentInfo>> entry : comments.entrySet()) {
    if (isForCurrentFile(filePath,entry.getKey(),repositoryPath)) {
      fileComments=entry.getValue();
      break;
    }
  }
  Iterable<CommentInput> commentInputsFromSink=reviewCommentSink.getCommentsForChange(changeInfo.getId());
  for (  CommentInput commentInput : commentInputsFromSink) {
    if (isForCurrentFile(filePath,commentInput.getPath(),repositoryPath)) {
      fileComments.add(commentInput.toCommentInfo());
    }
  }
  for (  CommentInfo fileComment : fileComments) {
    MarkupModel markup;
    if (fileComment.getSide() != null && fileComment.getSide().equals(CommentBase.CommentSide.PARENT)) {
      markup=diffPanel.getEditor1().getMarkupModel();
    }
 else {
      markup=diffPanel.getEditor2().getMarkupModel();
    }
    int lineCount=markup.getDocument().getLineCount();
    if (lineCount <= 0) {
      return;
    }
    int line=fileComment.getLine() - 1;
    if (line < 0) {
      line=0;
    }
    if (line > lineCount - 1) {
      line=lineCount - 1;
    }
    final RangeHighlighter highlighter=markup.addLineHighlighter(line,HighlighterLayer.ERROR + 1,null);
    highlighter.setGutterIconRenderer(new CommentGutterIconRenderer(fileComment,reviewCommentSink,changeInfo,highlighter,markup));
  }
}"
52804,"private void handleComments(final DiffPanelImpl diffPanel,final String filePathString){
  final FilePath filePath=new FilePathImpl(new File(filePathString),false);
  addCommentAction(diffPanel,filePath,changeInfo);
  gerritUtil.getChangeDetails(changeInfo.getNumber(),project,new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeDetails){
      gerritUtil.getComments(changeDetails.getId(),changeDetails.getCurrentRevision(),project,new Consumer<TreeMap<String,List<CommentInfo>>>(){
        @Override public void consume(        TreeMap<String,List<CommentInfo>> comments){
          addCommentsGutter(diffPanel,filePath,comments,changeInfo,project);
        }
      }
);
      String repositoryPath=getGitRepositoryPathForChange(project,changeDetails);
      String relativePath=filePathString.replace(repositoryPath + File.separator,""String_Node_Str"");
      gerritUtil.getChangeReviewed(changeDetails.getId(),changeDetails.getCurrentRevision(),relativePath,true,project);
    }
  }
);
}","private void handleComments(final DiffPanelImpl diffPanel,final String filePathString,final Project project,final ChangeInfo changeInfo){
  final FilePath filePath=new FilePathImpl(new File(filePathString),false);
  addCommentAction(diffPanel,filePath,changeInfo);
  gerritUtil.getChangeDetails(changeInfo.getNumber(),project,new Consumer<ChangeInfo>(){
    @Override public void consume(    ChangeInfo changeDetails){
      gerritUtil.getComments(changeDetails.getId(),changeDetails.getCurrentRevision(),project,new Consumer<TreeMap<String,List<CommentInfo>>>(){
        @Override public void consume(        TreeMap<String,List<CommentInfo>> comments){
          addCommentsGutter(diffPanel,filePath,comments,changeInfo,project);
        }
      }
);
      String repositoryPath=getGitRepositoryPathForChange(project,changeDetails);
      String relativePath=filePathString.replace(repositoryPath + File.separator,""String_Node_Str"");
      gerritUtil.getChangeReviewed(changeDetails.getId(),changeDetails.getCurrentRevision(),relativePath,true,project);
    }
  }
);
}"
52805,"public CommentableDiffPanel(Window window,DiffRequest request){
  super(window,request.getProject(),true,true,DiffManagerImpl.FULL_DIFF_DIVIDER_POLYGONS_OFFSET,CommentsDiffTool.this);
}","public CommentableDiffPanel(Window window,DiffRequest request,ChangeInfo changeInfo){
  super(window,request.getProject(),true,true,DiffManagerImpl.FULL_DIFF_DIVIDER_POLYGONS_OFFSET,CommentsDiffTool.this);
  this.changeInfo=changeInfo;
}"
52806,"@Override public boolean canShow(DiffRequest request){
  final boolean superCanShow=super.canShow(request);
  final AsyncResult<DataContext> dataContextFromFocus=dataManager.getDataContextFromFocus();
  final DataContext context=dataContextFromFocus.getResult();
  if (context == null)   return false;
  changeInfo=GerritDataKeys.CHANGE.getData(context);
  project=PlatformDataKeys.PROJECT.getData(context);
  return superCanShow && changeInfo != null;
}","@Override public boolean canShow(DiffRequest request){
  final boolean superCanShow=super.canShow(request);
  final AsyncResult<DataContext> dataContextFromFocus=dataManager.getDataContextFromFocus();
  final DataContext context=dataContextFromFocus.getResult();
  if (context == null)   return false;
  ChangeInfo changeInfo=GerritDataKeys.CHANGE.getData(context);
  return superCanShow && changeInfo != null;
}"
52807,"@Override public void setDiffRequest(DiffRequest request){
  super.setDiffRequest(request);
  Object chain=request.getGenericData().get(VcsDataKeys.DIFF_REQUEST_CHAIN.getName());
  if (chain instanceof ChangeRequestChain) {
    DiffRequestPresentable currentRequest=((ChangeRequestChain)chain).getCurrentRequest();
    if (currentRequest != null) {
      String path=currentRequest.getPathPresentation();
      handleComments(this,path);
    }
  }
}","@Override public void setDiffRequest(DiffRequest request){
  super.setDiffRequest(request);
  Object chain=request.getGenericData().get(VcsDataKeys.DIFF_REQUEST_CHAIN.getName());
  if (chain instanceof ChangeRequestChain) {
    DiffRequestPresentable currentRequest=((ChangeRequestChain)chain).getCurrentRequest();
    if (currentRequest != null) {
      String path=currentRequest.getPathPresentation();
      handleComments(this,path,request.getProject(),changeInfo);
    }
  }
}"
52808,"@Nullable @Override protected DiffPanelImpl createDiffPanelImpl(@NotNull DiffRequest request,@Nullable Window window,@NotNull Disposable parentDisposable){
  DiffPanelImpl diffPanel=new CommentableDiffPanel(window,request);
  diffPanel.setDiffRequest(request);
  Disposer.register(parentDisposable,diffPanel);
  return diffPanel;
}","@Nullable @Override protected DiffPanelImpl createDiffPanelImpl(@NotNull DiffRequest request,@Nullable Window window,@NotNull Disposable parentDisposable){
  DataContext context=dataManager.getDataContextFromFocus().getResult();
  ChangeInfo changeInfo=GerritDataKeys.CHANGE.getData(context);
  DiffPanelImpl diffPanel=new CommentableDiffPanel(window,request,changeInfo);
  diffPanel.setDiffRequest(request);
  Disposer.register(parentDisposable,diffPanel);
  return diffPanel;
}"
52809,"public Element getState(){
  log.assertTrue(!ProgressManager.getInstance().hasProgressIndicator(),""String_Node_Str"");
  try {
    if (passwordChanged && !masterPasswordRefused) {
      PasswordSafe.getInstance().storePassword(null,GerritSettings.class,GERRIT_SETTINGS_PASSWORD_KEY,getPassword());
    }
  }
 catch (  MasterPasswordUnavailableException e) {
    log.info(""String_Node_Str"" + GERRIT_SETTINGS_PASSWORD_KEY + ""String_Node_Str"",e);
    masterPasswordRefused=true;
  }
catch (  Exception e) {
    Messages.showErrorDialog(""String_Node_Str"",""String_Node_Str"");
    log.info(""String_Node_Str"" + GERRIT_SETTINGS_PASSWORD_KEY + ""String_Node_Str"",e);
  }
  passwordChanged=false;
  final Element element=new Element(GERRIT_SETTINGS_TAG);
  element.setAttribute(LOGIN,getLogin());
  element.setAttribute(HOST,getHost());
  element.setAttribute(AUTOMATIC_REFRESH,""String_Node_Str"" + getAutomaticRefresh());
  element.setAttribute(REFRESH_TIMEOUT,""String_Node_Str"" + getRefreshTimeout());
  element.setAttribute(REVIEW_NOTIFICATIONS,""String_Node_Str"" + getReviewNotifications());
  Element trustedHosts=new Element(TRUSTED_HOSTS);
  for (  String host : myTrustedHosts) {
    Element hostEl=new Element(TRUSTED_HOST);
    hostEl.setAttribute(TRUSTED_URL,host);
    trustedHosts.addContent(hostEl);
  }
  element.addContent(trustedHosts);
  return element;
}","public Element getState(){
  log.assertTrue(!ProgressManager.getInstance().hasProgressIndicator(),""String_Node_Str"");
  try {
    if (passwordChanged && !masterPasswordRefused) {
      PasswordSafe.getInstance().storePassword(null,GerritSettings.class,GERRIT_SETTINGS_PASSWORD_KEY,getPassword());
    }
  }
 catch (  MasterPasswordUnavailableException e) {
    log.info(""String_Node_Str"" + GERRIT_SETTINGS_PASSWORD_KEY + ""String_Node_Str"",e);
    masterPasswordRefused=true;
  }
catch (  Exception e) {
    Messages.showErrorDialog(""String_Node_Str"",""String_Node_Str"");
    log.info(""String_Node_Str"" + GERRIT_SETTINGS_PASSWORD_KEY + ""String_Node_Str"",e);
  }
  passwordChanged=false;
  final Element element=new Element(GERRIT_SETTINGS_TAG);
  element.setAttribute(LOGIN,(getLogin() != null ? getLogin() : ""String_Node_Str""));
  element.setAttribute(HOST,(getHost() != null ? getHost() : ""String_Node_Str""));
  element.setAttribute(AUTOMATIC_REFRESH,""String_Node_Str"" + getAutomaticRefresh());
  element.setAttribute(REFRESH_TIMEOUT,""String_Node_Str"" + getRefreshTimeout());
  element.setAttribute(REVIEW_NOTIFICATIONS,""String_Node_Str"" + getReviewNotifications());
  Element trustedHosts=new Element(TRUSTED_HOSTS);
  for (  String host : myTrustedHosts) {
    Element hostEl=new Element(TRUSTED_HOST);
    hostEl.setAttribute(TRUSTED_URL,host);
    trustedHosts.addContent(hostEl);
  }
  element.addContent(trustedHosts);
  return element;
}"
52810,"private static String getProjectName(String url){
  String path=parseUri(url).getPath();
  int index=path.indexOf('/');
  path=path.substring(index + 1);
  path=path.replace(""String_Node_Str"",""String_Node_Str"");
  return path;
}","private static String getProjectName(String repositoryUrl,String url){
  if (!repositoryUrl.endsWith(""String_Node_Str""))   repositoryUrl=repositoryUrl + ""String_Node_Str"";
  String basePath=parseUri(repositoryUrl).getPath();
  String path=parseUri(url).getPath();
  path=path.substring(basePath.length());
  path=path.replace(""String_Node_Str"",""String_Node_Str"");
  if (path.endsWith(""String_Node_Str""))   path=path.substring(0,path.length() - 1);
  return path;
}"
52811,"/** 
 * Provide information only for current project
 */
@NotNull public static List<ChangeInfo> getChangesForProject(@NotNull String url,@NotNull String login,@NotNull String password,@NotNull final Project project){
  List<GitRepository> repositories=GitUtil.getRepositoryManager(project).getRepositories();
  if (repositories.isEmpty()) {
    showAddGitRepositoryNotification(project);
    return Lists.newArrayList();
  }
  List<GitRemote> remotes=Lists.newArrayList();
  for (  GitRepository repository : repositories) {
    remotes.addAll(repository.getRemotes());
  }
  String host=parseUri(url).getHost();
  List<String> projectNames=Lists.newArrayList();
  for (  GitRemote remote : remotes) {
    for (    String repositoryUrl : remote.getUrls()) {
      String repositoryHost=parseUri(repositoryUrl).getHost();
      if (repositoryHost != null && repositoryHost.equals(host)) {
        projectNames.add(""String_Node_Str"" + getProjectName(repositoryUrl));
      }
    }
  }
  if (projectNames.isEmpty()) {
    return Collections.emptyList();
  }
  String projectQuery=Joiner.on(""String_Node_Str"").join(projectNames);
  return getChanges(url,login,password,""String_Node_Str"" + projectQuery + ')');
}","/** 
 * Provide information only for current project
 */
@NotNull public static List<ChangeInfo> getChangesForProject(@NotNull String url,@NotNull String login,@NotNull String password,@NotNull final Project project){
  List<GitRepository> repositories=GitUtil.getRepositoryManager(project).getRepositories();
  if (repositories.isEmpty()) {
    showAddGitRepositoryNotification(project);
    return Lists.newArrayList();
  }
  List<GitRemote> remotes=Lists.newArrayList();
  for (  GitRepository repository : repositories) {
    remotes.addAll(repository.getRemotes());
  }
  String host=parseUri(url).getHost();
  List<String> projectNames=Lists.newArrayList();
  for (  GitRemote remote : remotes) {
    for (    String repositoryUrl : remote.getUrls()) {
      String repositoryHost=parseUri(repositoryUrl).getHost();
      if (repositoryHost != null && repositoryHost.equals(host)) {
        projectNames.add(""String_Node_Str"" + getProjectName(url,repositoryUrl));
      }
    }
  }
  if (projectNames.isEmpty()) {
    return Collections.emptyList();
  }
  String projectQuery=Joiner.on(""String_Node_Str"").join(projectNames);
  return getChanges(url,login,password,""String_Node_Str"" + projectQuery + ')');
}"
52812,"public static void cherryPickChange(final Project project,final ChangeInfo changeInfo){
  final Git git=ServiceManager.getService(Git.class);
  final GitPlatformFacade platformFacade=ServiceManager.getService(GitPlatformFacade.class);
  FileDocumentManager.getInstance().saveAllDocuments();
  platformFacade.getChangeListManager(project).blockModalNotifications();
  new Task.Backgroundable(project,""String_Node_Str"",false){
    public void run(    @NotNull ProgressIndicator indicator){
      try {
        final GitRepository gitRepository=getRepositoryForGerritProject(project,changeInfo.getProject());
        final String notLoaded=""String_Node_Str"";
        String ref=changeInfo.getCurrentRevision();
        GitCommit gitCommit=new GitCommit(Hash.create(ref),notLoaded,notLoaded,0,notLoaded,notLoaded,0,notLoaded,notLoaded,Collections.<Hash>emptyList(),Collections.<Change>emptyList());
        cherryPick(gitRepository,gitCommit,git,platformFacade,project);
      }
  finally {
        ApplicationManager.getApplication().invokeLater(new Runnable(){
          public void run(){
            VirtualFileManager.getInstance().syncRefresh();
            platformFacade.getChangeListManager(project).unblockModalNotifications();
          }
        }
);
      }
    }
  }
.queue();
}","public static void cherryPickChange(final Project project,final ChangeInfo changeInfo){
  final Git git=ServiceManager.getService(Git.class);
  final GitPlatformFacade platformFacade=ServiceManager.getService(GitPlatformFacade.class);
  FileDocumentManager.getInstance().saveAllDocuments();
  platformFacade.getChangeListManager(project).blockModalNotifications();
  new Task.Backgroundable(project,""String_Node_Str"",false){
    public void run(    @NotNull ProgressIndicator indicator){
      try {
        final GitRepository gitRepository=getRepositoryForGerritProject(project,changeInfo.getProject());
        final VirtualFile virtualFile=gitRepository.getGitDir();
        final String notLoaded=""String_Node_Str"";
        String ref=changeInfo.getCurrentRevision();
        GitHeavyCommit gitCommit=new GitHeavyCommit(virtualFile,AbstractHash.create(ref),new SHAHash(ref),notLoaded,notLoaded,new Date(0),notLoaded,notLoaded,Collections.<String>emptySet(),Collections.<FilePath>emptyList(),notLoaded,notLoaded,Collections.<String>emptyList(),Collections.<String>emptyList(),Collections.<String>emptyList(),Collections.<Change>emptyList(),0);
        cherryPick(gitRepository,gitCommit,git,platformFacade,project);
      }
  finally {
        ApplicationManager.getApplication().invokeLater(new Runnable(){
          public void run(){
            VirtualFileManager.getInstance().syncRefresh();
            platformFacade.getChangeListManager(project).unblockModalNotifications();
          }
        }
);
      }
    }
  }
.queue();
}"
52813,"/** 
 * A lot of this code is based on: git4idea.cherrypick.GitCherryPicker#cherryPick() (which is private)
 */
private static boolean cherryPick(@NotNull GitRepository repository,@NotNull GitCommit commit,@NotNull Git git,@NotNull GitPlatformFacade platformFacade,@NotNull Project project){
  GitSimpleEventDetector conflictDetector=new GitSimpleEventDetector(CHERRY_PICK_CONFLICT);
  GitSimpleEventDetector localChangesOverwrittenDetector=new GitSimpleEventDetector(LOCAL_CHANGES_OVERWRITTEN_BY_CHERRY_PICK);
  GitUntrackedFilesOverwrittenByOperationDetector untrackedFilesDetector=new GitUntrackedFilesOverwrittenByOperationDetector(repository.getRoot());
  GitCommandResult result=git.cherryPick(repository,commit.getHash().asString(),false,conflictDetector,localChangesOverwrittenDetector,untrackedFilesDetector);
  if (result.success()) {
    return true;
  }
 else   if (conflictDetector.hasHappened()) {
    return new CherryPickConflictResolver(project,git,platformFacade,repository.getRoot(),commit.getHash().asString(),commit.getAuthorName(),commit.getSubject()).merge();
  }
 else   if (untrackedFilesDetector.wasMessageDetected()) {
    String description=""String_Node_Str"" + ""String_Node_Str"";
    UntrackedFilesNotifier.notifyUntrackedFilesOverwrittenBy(project,platformFacade,untrackedFilesDetector.getFiles(),""String_Node_Str"",description);
    return false;
  }
 else   if (localChangesOverwrittenDetector.hasHappened()) {
    GerritUtil.notifyError(project,""String_Node_Str"",""String_Node_Str"");
    return false;
  }
 else {
    GerritUtil.notifyError(project,""String_Node_Str"",result.getErrorOutputAsHtmlString());
    return false;
  }
}","/** 
 * A lot of this code is based on: git4idea.cherrypick.GitCherryPicker#cherryPick() (which is private)
 */
private static boolean cherryPick(@NotNull GitRepository repository,@NotNull GitHeavyCommit commit,@NotNull Git git,@NotNull GitPlatformFacade platformFacade,@NotNull Project project){
  GitSimpleEventDetector conflictDetector=new GitSimpleEventDetector(CHERRY_PICK_CONFLICT);
  GitSimpleEventDetector localChangesOverwrittenDetector=new GitSimpleEventDetector(LOCAL_CHANGES_OVERWRITTEN_BY_CHERRY_PICK);
  GitUntrackedFilesOverwrittenByOperationDetector untrackedFilesDetector=new GitUntrackedFilesOverwrittenByOperationDetector(repository.getRoot());
  GitCommandResult result=git.cherryPick(repository,commit.getHash().getValue(),false,conflictDetector,localChangesOverwrittenDetector,untrackedFilesDetector);
  if (result.success()) {
    return true;
  }
 else   if (conflictDetector.hasHappened()) {
    return new CherryPickConflictResolver(project,git,platformFacade,repository.getRoot(),commit.getShortHash().getString(),commit.getAuthor(),commit.getSubject()).merge();
  }
 else   if (untrackedFilesDetector.wasMessageDetected()) {
    String description=""String_Node_Str"" + ""String_Node_Str"";
    UntrackedFilesNotifier.notifyUntrackedFilesOverwrittenBy(project,platformFacade,untrackedFilesDetector.getFiles(),""String_Node_Str"",description);
    return false;
  }
 else   if (localChangesOverwrittenDetector.hasHappened()) {
    GerritUtil.notifyError(project,""String_Node_Str"",""String_Node_Str"");
    return false;
  }
 else {
    GerritUtil.notifyError(project,""String_Node_Str"",result.getErrorOutputAsHtmlString());
    return false;
  }
}"
52814,"@Nullable private static HttpMethod handleCertificateExceptionAndRetry(@NotNull IOException e,@NotNull String host,@NotNull HttpClient client,@NotNull URI uri,@NotNull ThrowableConvertor<String,HttpMethod,IOException> methodCreator) throws IOException {
  if (!isCertificateException(e)) {
    throw e;
  }
  if (isTrusted(host)) {
    HostConfiguration hc=new HostConfiguration();
    String relativeUri=new URI(uri.getPathQuery(),false).getURI();
    HttpMethod method=methodCreator.convert(relativeUri);
    client.executeMethod(hc,method);
    return method;
  }
  throw e;
}","@Nullable private static HttpMethod handleCertificateExceptionAndRetry(@NotNull IOException e,@NotNull String host,@NotNull HttpClient client,@NotNull URI uri,@NotNull ThrowableConvertor<String,HttpMethod,IOException> methodCreator) throws IOException {
  if (!isCertificateException(e)) {
    throw e;
  }
  if (isTrusted(host)) {
    Protocol easyHttps=new Protocol(""String_Node_Str"",(ProtocolSocketFactory)new EasySSLProtocolSocketFactory(),443);
    HostConfiguration hc=new HostConfiguration();
    hc.setHost(host,443,easyHttps);
    String relativeUri=new URI(uri.getPathQuery(),false).getURI();
    HttpMethod method=methodCreator.convert(relativeUri);
    client.executeMethod(hc,method);
    return method;
  }
  throw e;
}"
52815,"private static void saveToTrusted(@NotNull String host){
  GerritSettings.getInstance().addTrustedHost(host);
}","private static void saveToTrusted(@NotNull String host){
  try {
    GerritSettings.getInstance().addTrustedHost(new java.net.URI(host).getHost());
  }
 catch (  URISyntaxException e) {
    throw Throwables.propagate(e);
  }
}"
52816,"@Nullable private static JsonElement request(@NotNull String host,@Nullable String login,@Nullable String password,@NotNull String path,@Nullable String requestBody,boolean post){
  HttpMethod method=null;
  try {
    method=doREST(host,login,password,path,requestBody,post);
    String resp=method.getResponseBodyAsString();
    if (method.getStatusCode() != 200) {
      String message=String.format(""String_Node_Str"",method.getStatusCode(),method.getStatusText());
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    if (resp == null) {
      String message=String.format(""String_Node_Str"",resp);
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    return parseResponse(resp);
  }
 catch (  IOException e) {
    LOG.warn(String.format(""String_Node_Str"",e.getMessage()),e);
    throw Throwables.propagate(e);
  }
 finally {
    if (method != null) {
      method.releaseConnection();
    }
  }
}","@Nullable private static JsonElement request(@NotNull String host,@Nullable String login,@Nullable String password,@NotNull String path,@Nullable String requestBody,boolean post){
  HttpMethod method=null;
  try {
    method=doREST(host,login,password,path,requestBody,post);
    String resp=method.getResponseBodyAsString();
    if (method.getStatusCode() != 200) {
      String message=String.format(""String_Node_Str"",method.getStatusCode(),method.getStatusText());
      LOG.warn(message);
      throw new HttpStatusException(method.getStatusCode(),method.getStatusText(),message);
    }
    if (resp == null) {
      String message=String.format(""String_Node_Str"",resp);
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    return parseResponse(resp);
  }
 catch (  IOException e) {
    LOG.warn(String.format(""String_Node_Str"",e.getMessage()),e);
    throw Throwables.propagate(e);
  }
 finally {
    if (method != null) {
      method.releaseConnection();
    }
  }
}"
52817,"@NotNull private static JsonElement parseResponse(@NotNull String response){
  try {
    return new JsonParser().parse(response);
  }
 catch (  JsonSyntaxException jse) {
    if (response.startsWith(""String_Node_Str"")) {
      throw new NotFoundException();
    }
    throw new RuntimeException(String.format(""String_Node_Str"",response),jse);
  }
}","@NotNull private static JsonElement parseResponse(@NotNull String response){
  try {
    return new JsonParser().parse(response);
  }
 catch (  JsonSyntaxException jse) {
    throw new RuntimeException(String.format(""String_Node_Str"",response),jse);
  }
}"
52818,"/** 
 * Support starting from Gerrit 2.7.
 */
@NotNull public static TreeMap<String,List<CommentInfo>> getComments(@NotNull String url,@NotNull String login,@NotNull String password,@NotNull String changeId,@NotNull String revision){
  final String request=""String_Node_Str"" + changeId + ""String_Node_Str""+ revision+ ""String_Node_Str"";
  try {
    JsonElement result=GerritApiUtil.getRequest(url,login,password,request);
    if (result == null) {
      return Maps.newTreeMap();
    }
    return parseCommentInfos(result);
  }
 catch (  NotFoundException e) {
    LOG.warn(""String_Node_Str"");
    return Maps.newTreeMap();
  }
}","/** 
 * Support starting from Gerrit 2.7.
 */
@NotNull public static TreeMap<String,List<CommentInfo>> getComments(@NotNull String url,@NotNull String login,@NotNull String password,@NotNull String changeId,@NotNull String revision){
  final String request=""String_Node_Str"" + changeId + ""String_Node_Str""+ revision+ ""String_Node_Str"";
  try {
    JsonElement result=GerritApiUtil.getRequest(url,login,password,request);
    if (result == null) {
      return Maps.newTreeMap();
    }
    return parseCommentInfos(result);
  }
 catch (  HttpStatusException e) {
    if (e.getStatusCode() == 404) {
      LOG.warn(""String_Node_Str"");
    }
    return Maps.newTreeMap();
  }
}"
52819,"@Nullable private static JsonElement request(@NotNull String host,@Nullable String login,@Nullable String password,@NotNull String path,@Nullable String requestBody,boolean post){
  HttpMethod method=null;
  try {
    method=doREST(host,login,password,path,requestBody,post);
    String resp=method.getResponseBodyAsString();
    if (method.getStatusCode() != 200) {
      String message=String.format(""String_Node_Str"",method.getStatusCode(),method.getStatusText());
      LOG.warn(message);
      throw new HttpStatusException(method.getStatusCode(),method.getStatusText(),message);
    }
    if (resp == null) {
      String message=String.format(""String_Node_Str"",resp);
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    return parseResponse(resp);
  }
 catch (  IOException e) {
    LOG.warn(String.format(""String_Node_Str"",e.getMessage()),e);
    throw Throwables.propagate(e);
  }
 finally {
    if (method != null) {
      method.releaseConnection();
    }
  }
}","@Nullable private static JsonElement request(@NotNull String host,@Nullable String login,@Nullable String password,@NotNull String path,@Nullable String requestBody,boolean post){
  HttpMethod method=null;
  try {
    method=doREST(host,login,password,path,requestBody,post);
    String resp=method.getResponseBodyAsString();
    if (method.getStatusCode() != 200) {
      String message=String.format(""String_Node_Str"",method.getStatusText(),method.getStatusCode());
      LOG.warn(message);
      throw new HttpStatusException(method.getStatusCode(),method.getStatusText(),message);
    }
    if (resp == null) {
      String message=String.format(""String_Node_Str"",resp);
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    return parseResponse(resp);
  }
 catch (  IOException e) {
    LOG.warn(String.format(""String_Node_Str"",e.getMessage()),e);
    throw Throwables.propagate(e);
  }
 finally {
    if (method != null) {
      method.releaseConnection();
    }
  }
}"
52820,"@Override public Object invoke(Object proxy,Method method,Object[] parameters) throws Throwable {
  lazyInit();
  List<Interceptor<?>> interceptors=interceptorLookup.lookup(proxy,method);
  if (interceptors != null && !interceptors.isEmpty()) {
    try {
      ManualInvocationContext invocationContext=new ManualInvocationContext(this,interceptors,proxy,method,parameters,null);
      Object returnValue=invocationContext.proceed();
      if (invocationContext.isProceedOriginal()) {
        return invocationContext.getProceedOriginalReturnValue();
      }
      return returnValue;
    }
 catch (    ManualInvocationThrowableWrapperException e) {
      throw e.getCause();
    }
  }
  return proceedOriginal(proxy,method,parameters);
}","@Override public Object invoke(Object proxy,Method method,Object[] parameters) throws Throwable {
  List<Interceptor<?>> interceptors=interceptorLookup.lookup(proxy,method);
  if (interceptors != null && !interceptors.isEmpty()) {
    try {
      ManualInvocationContext invocationContext=new ManualInvocationContext(this,interceptors,proxy,method,parameters,null);
      Object returnValue=invocationContext.proceed();
      if (invocationContext.isProceedOriginal()) {
        return invocationContext.getProceedOriginalReturnValue();
      }
      return returnValue;
    }
 catch (    ManualInvocationThrowableWrapperException e) {
      throw e.getCause();
    }
  }
  return proceedOriginal(proxy,method,parameters);
}"
52821,"/** 
 * Calls the original logic after invoking the interceptor chain.
 * @param proxy The current proxy instance.
 * @param method The current invoked method.
 * @param parameters The method parameter.
 * @return The original value from the original method.
 * @throws Throwable 
 */
protected abstract Object proceedOriginal(Object proxy,Method method,Object[] parameters) throws Throwable ;","/** 
 * Calls the original logic after invoking the interceptor chain.
 * @param proxy The current proxy instance.
 * @param method The current invoked method.
 * @param parameters The method parameter.
 * @return The original value from the original method.
 * @throws Throwable
 */
protected abstract Object proceedOriginal(Object proxy,Method method,Object[] parameters) throws Throwable ;"
52822,"@Override public T getValue(){
  if (cacheTimeMs > 0) {
    long now=System.currentTimeMillis();
    if (now <= reloadAfter) {
      return lastValue;
    }
    reloadAfter=now + cacheTimeMs;
  }
  String valueStr=resolveStringValue();
  T value=convert(valueStr);
  value=fallbackToDefaultIfEmpty(keyResolved,value,defaultValue);
  if (logChanges && (value != null && lastValue == null || !value.equals(lastValue))) {
    LOG.log(Level.INFO,""String_Node_Str"",new Object[]{filterConfigValueForLog(keyOriginal,valueStr),keyOriginal});
  }
  if (cacheTimeMs > 0) {
    lastValue=value;
  }
  return value;
}","@Override public T getValue(){
  long now=-1;
  if (cacheTimeMs > 0) {
    now=System.currentTimeMillis();
    if (now <= reloadAfter) {
      return lastValue;
    }
  }
  String valueStr=resolveStringValue();
  T value=convert(valueStr);
  value=fallbackToDefaultIfEmpty(keyResolved,value,defaultValue);
  if (logChanges && (value != null && lastValue == null || !value.equals(lastValue))) {
    LOG.log(Level.INFO,""String_Node_Str"",new Object[]{filterConfigValueForLog(keyOriginal,valueStr),keyOriginal});
  }
  if (cacheTimeMs > 0) {
    lastValue=value;
    reloadAfter=now + cacheTimeMs;
  }
  return value;
}"
52823,"/** 
 * We make sure that there is a NewAnnotatedMember for every public method/field/constructor <p/> If annotation have been added to other methods as well we add them to
 */
AnnotatedTypeImpl(Class<X> clazz,AnnotationStore typeAnnotations,Map<Field,AnnotationStore> fieldAnnotations,Map<Method,AnnotationStore> methodAnnotations,Map<Method,Map<Integer,AnnotationStore>> methodParameterAnnotations,Map<Constructor<?>,AnnotationStore> constructorAnnotations,Map<Constructor<?>,Map<Integer,AnnotationStore>> constructorParameterAnnotations,Map<Field,Type> fieldTypes,Map<Method,Map<Integer,Type>> methodParameterTypes,Map<Constructor<?>,Map<Integer,Type>> constructorParameterTypes){
  super(clazz,typeAnnotations,null,null);
  javaClass=clazz;
  constructors=new HashSet<AnnotatedConstructor<X>>();
  Set<Constructor<?>> cset=new HashSet<Constructor<?>>();
  Set<Method> mset=new HashSet<Method>();
  Set<Field> fset=new HashSet<Field>();
  for (  Constructor<?> c : clazz.getConstructors()) {
    AnnotatedConstructor<X> nc=new AnnotatedConstructorImpl<X>(this,c,constructorAnnotations.get(c),constructorParameterAnnotations.get(c),constructorParameterTypes.get(c));
    constructors.add(nc);
    cset.add(c);
  }
  for (  Map.Entry<Constructor<?>,AnnotationStore> c : constructorAnnotations.entrySet()) {
    if (!cset.contains(c.getKey())) {
      AnnotatedConstructor<X> nc=new AnnotatedConstructorImpl<X>(this,c.getKey(),c.getValue(),constructorParameterAnnotations.get(c.getKey()),constructorParameterTypes.get(c.getKey()));
      constructors.add(nc);
    }
  }
  methods=new HashSet<AnnotatedMethod<? super X>>();
  for (  Method m : clazz.getMethods()) {
    if (!m.getDeclaringClass().equals(Object.class)) {
      AnnotatedMethodImpl<X> met=new AnnotatedMethodImpl<X>(this,m,methodAnnotations.get(m),methodParameterAnnotations.get(m),methodParameterTypes.get(m));
      methods.add(met);
      mset.add(m);
    }
  }
  for (  Map.Entry<Method,AnnotationStore> c : methodAnnotations.entrySet()) {
    if (!c.getKey().getDeclaringClass().equals(Object.class) && !mset.contains(c.getKey())) {
      AnnotatedMethodImpl<X> nc=new AnnotatedMethodImpl<X>(this,c.getKey(),c.getValue(),methodParameterAnnotations.get(c.getKey()),methodParameterTypes.get(c.getKey()));
      methods.add(nc);
    }
  }
  fields=new HashSet<AnnotatedField<? super X>>();
  for (  Field f : clazz.getFields()) {
    AnnotatedField<X> b=new AnnotatedFieldImpl<X>(this,f,fieldAnnotations.get(f),fieldTypes.get(f));
    fields.add(b);
    fset.add(f);
  }
  for (  Map.Entry<Field,AnnotationStore> e : fieldAnnotations.entrySet()) {
    if (!fset.contains(e.getKey())) {
      fields.add(new AnnotatedFieldImpl<X>(this,e.getKey(),e.getValue(),fieldTypes.get(e.getKey())));
    }
  }
}","/** 
 * We make sure that there is a NewAnnotatedMember for every public method/field/constructor <p/> If annotation have been added to other methods as well we add them to
 */
AnnotatedTypeImpl(Class<X> clazz,AnnotationStore typeAnnotations,Map<Field,AnnotationStore> fieldAnnotations,Map<Method,AnnotationStore> methodAnnotations,Map<Method,Map<Integer,AnnotationStore>> methodParameterAnnotations,Map<Constructor<?>,AnnotationStore> constructorAnnotations,Map<Constructor<?>,Map<Integer,AnnotationStore>> constructorParameterAnnotations,Map<Field,Type> fieldTypes,Map<Method,Map<Integer,Type>> methodParameterTypes,Map<Constructor<?>,Map<Integer,Type>> constructorParameterTypes){
  super(clazz,typeAnnotations,null,null);
  javaClass=clazz;
  constructors=new HashSet<AnnotatedConstructor<X>>();
  Set<Constructor<?>> cset=new HashSet<Constructor<?>>();
  Set<Method> mset=new HashSet<Method>();
  Set<Field> fset=new HashSet<Field>();
  for (  Constructor<?> c : clazz.getConstructors()) {
    AnnotatedConstructor<X> nc=new AnnotatedConstructorImpl<X>(this,c,constructorAnnotations.get(c),constructorParameterAnnotations.get(c),constructorParameterTypes.get(c));
    constructors.add(nc);
    cset.add(c);
  }
  for (  Map.Entry<Constructor<?>,AnnotationStore> c : constructorAnnotations.entrySet()) {
    if (!cset.contains(c.getKey())) {
      AnnotatedConstructor<X> nc=new AnnotatedConstructorImpl<X>(this,c.getKey(),c.getValue(),constructorParameterAnnotations.get(c.getKey()),constructorParameterTypes.get(c.getKey()));
      constructors.add(nc);
    }
  }
  methods=new HashSet<AnnotatedMethod<? super X>>();
  for (  Method m : clazz.getMethods()) {
    if (!m.getDeclaringClass().equals(Object.class) && !m.getDeclaringClass().equals(Annotation.class)) {
      AnnotatedMethodImpl<X> met=new AnnotatedMethodImpl<X>(this,m,methodAnnotations.get(m),methodParameterAnnotations.get(m),methodParameterTypes.get(m));
      methods.add(met);
      mset.add(m);
    }
  }
  for (  Map.Entry<Method,AnnotationStore> c : methodAnnotations.entrySet()) {
    if (!c.getKey().getDeclaringClass().equals(Object.class) && !mset.contains(c.getKey())) {
      AnnotatedMethodImpl<X> nc=new AnnotatedMethodImpl<X>(this,c.getKey(),c.getValue(),methodParameterAnnotations.get(c.getKey()),methodParameterTypes.get(c.getKey()));
      methods.add(nc);
    }
  }
  fields=new HashSet<AnnotatedField<? super X>>();
  for (  Field f : clazz.getFields()) {
    AnnotatedField<X> b=new AnnotatedFieldImpl<X>(this,f,fieldAnnotations.get(f),fieldTypes.get(f));
    fields.add(b);
    fset.add(f);
  }
  for (  Map.Entry<Field,AnnotationStore> e : fieldAnnotations.entrySet()) {
    if (!fset.contains(e.getKey())) {
      fields.add(new AnnotatedFieldImpl<X>(this,e.getKey(),e.getValue(),fieldTypes.get(e.getKey())));
    }
  }
}"
52824,"/** 
 * Observes the event, finds the correct exception handler(s) and invokes them.
 * @param exceptionEventEvent exception to be invoked
 * @param beanManager         active bean manager
 * @throws Throwable If a handler requests the exception to be re-thrown.
 */
public void executeHandlers(@Observes @Any ExceptionToCatchEvent exceptionEventEvent,final BeanManager beanManager) throws Throwable {
  LOG.entering(ExceptionHandlerBroadcaster.class.getName(),""String_Node_Str"",exceptionEventEvent.getException());
  CreationalContext<Object> creationalContext=null;
  Throwable throwException=null;
  final HandlerMethodStorage handlerMethodStorage=BeanProvider.getContextualReference(HandlerMethodStorage.class);
  try {
    creationalContext=beanManager.createCreationalContext(null);
    final Set<HandlerMethod<?>> processedHandlers=new HashSet<HandlerMethod<?>>();
    final ExceptionStackEvent stack=new ExceptionStackEvent(exceptionEventEvent.getException());
    beanManager.fireEvent(stack);
    inbound_cause:     while (stack.getCurrent() != null) {
      final List<HandlerMethod<?>> callbackExceptionEvent=new ArrayList<HandlerMethod<?>>(handlerMethodStorage.getHandlersForException(stack.getCurrent().getClass(),beanManager,exceptionEventEvent.getQualifiers(),true));
      for (      HandlerMethod<?> handler : callbackExceptionEvent) {
        if (!processedHandlers.contains(handler)) {
          LOG.fine(String.format(""String_Node_Str"",handler));
          @SuppressWarnings(""String_Node_Str"") final DefaultExceptionEvent callbackEvent=new DefaultExceptionEvent(stack,true,exceptionEventEvent.isHandled());
          handler.notify(callbackEvent,beanManager);
          LOG.fine(String.format(""String_Node_Str"",handler,callbackEvent.getCurrentExceptionHandlingFlow().name()));
          if (!callbackEvent.isUnmute()) {
            processedHandlers.add(handler);
          }
switch (callbackEvent.getCurrentExceptionHandlingFlow()) {
case HANDLED:
            exceptionEventEvent.setHandled(true);
          return;
case HANDLED_AND_CONTINUE:
        exceptionEventEvent.setHandled(true);
      break;
case ABORT:
    return;
case SKIP_CAUSE:
  exceptionEventEvent.setHandled(true);
stack.skipCause();
continue inbound_cause;
case THROW_ORIGINAL:
throw exceptionEventEvent.getException();
case THROW:
throw callbackEvent.getThrowNewException();
default :
throw new IllegalStateException(""String_Node_Str"" + callbackEvent.getCurrentExceptionHandlingFlow());
}
}
}
final Collection<HandlerMethod<? extends Throwable>> handlersForException=handlerMethodStorage.getHandlersForException(stack.getCurrent().getClass(),beanManager,exceptionEventEvent.getQualifiers(),false);
final List<HandlerMethod<? extends Throwable>> handlerMethods=new ArrayList<HandlerMethod<? extends Throwable>>(handlersForException);
Collections.reverse(handlerMethods);
for (HandlerMethod<?> handler : handlerMethods) {
if (!processedHandlers.contains(handler)) {
LOG.fine(String.format(""String_Node_Str"",handler));
@SuppressWarnings(""String_Node_Str"") final DefaultExceptionEvent depthFirstEvent=new DefaultExceptionEvent(stack,false,exceptionEventEvent.isHandled());
handler.notify(depthFirstEvent,beanManager);
LOG.fine(String.format(""String_Node_Str"",handler,depthFirstEvent.getCurrentExceptionHandlingFlow().name()));
if (!depthFirstEvent.isUnmute()) {
processedHandlers.add(handler);
}
switch (depthFirstEvent.getCurrentExceptionHandlingFlow()) {
case HANDLED:
exceptionEventEvent.setHandled(true);
return;
case HANDLED_AND_CONTINUE:
exceptionEventEvent.setHandled(true);
break;
case ABORT:
return;
case SKIP_CAUSE:
exceptionEventEvent.setHandled(true);
stack.skipCause();
continue inbound_cause;
case THROW_ORIGINAL:
throwException=exceptionEventEvent.getException();
break;
case THROW:
throwException=depthFirstEvent.getThrowNewException();
break;
default :
throw new IllegalStateException(""String_Node_Str"" + depthFirstEvent.getCurrentExceptionHandlingFlow());
}
}
}
stack.skipCause();
}
if (!exceptionEventEvent.isHandled() && throwException == null && !exceptionEventEvent.isOptional()) {
LOG.warning(String.format(""String_Node_Str"",exceptionEventEvent.getException()));
throw exceptionEventEvent.getException();
}
if (throwException != null) {
throw throwException;
}
}
  finally {
if (creationalContext != null) {
creationalContext.release();
}
LOG.exiting(ExceptionHandlerBroadcaster.class.getName(),""String_Node_Str"",exceptionEventEvent.getException());
}
}","/** 
 * Observes the event, finds the correct exception handler(s) and invokes them.
 * @param exceptionEventEvent exception to be invoked
 * @param beanManager active bean manager
 * @throws Throwable If a handler requests the exception to be re-thrown.
 */
public void executeHandlers(@Observes @Any ExceptionToCatchEvent exceptionEventEvent,final BeanManager beanManager) throws Throwable {
  LOG.entering(ExceptionHandlerBroadcaster.class.getName(),""String_Node_Str"",exceptionEventEvent.getException());
  CreationalContext<Object> creationalContext=null;
  Throwable throwException=null;
  final HandlerMethodStorage handlerMethodStorage=BeanProvider.getContextualReference(HandlerMethodStorage.class);
  try {
    creationalContext=beanManager.createCreationalContext(null);
    final Set<HandlerMethod<?>> processedHandlers=new HashSet<HandlerMethod<?>>();
    final ExceptionStackEvent stack=new ExceptionStackEvent(exceptionEventEvent.getException());
    beanManager.fireEvent(stack);
    inbound_cause:     while (stack.getCurrent() != null) {
      final List<HandlerMethod<?>> callbackExceptionEvent=new ArrayList<HandlerMethod<?>>(handlerMethodStorage.getHandlersForException(stack.getCurrent().getClass(),beanManager,exceptionEventEvent.getQualifiers(),true));
      for (      HandlerMethod<?> handler : callbackExceptionEvent) {
        if (!processedHandlers.contains(handler)) {
          LOG.fine(String.format(""String_Node_Str"",handler));
          @SuppressWarnings(""String_Node_Str"") final DefaultExceptionEvent callbackEvent=new DefaultExceptionEvent(stack,true,exceptionEventEvent.isHandled());
          handler.notify(callbackEvent,beanManager);
          LOG.fine(String.format(""String_Node_Str"",handler,callbackEvent.getCurrentExceptionHandlingFlow().name()));
          if (!callbackEvent.isUnmute()) {
            processedHandlers.add(handler);
          }
switch (callbackEvent.getCurrentExceptionHandlingFlow()) {
case HANDLED:
            exceptionEventEvent.setHandled(true);
          return;
case HANDLED_AND_CONTINUE:
        exceptionEventEvent.setHandled(true);
      break;
case ABORT:
    return;
case SKIP_CAUSE:
  exceptionEventEvent.setHandled(true);
stack.skipCause();
continue inbound_cause;
case THROW_ORIGINAL:
throw exceptionEventEvent.getException();
case THROW:
throw callbackEvent.getThrowNewException();
default :
throw new IllegalStateException(""String_Node_Str"" + callbackEvent.getCurrentExceptionHandlingFlow());
}
}
}
final Collection<HandlerMethod<? extends Throwable>> handlersForException=handlerMethodStorage.getHandlersForException(stack.getCurrent().getClass(),beanManager,exceptionEventEvent.getQualifiers(),false);
final List<HandlerMethod<? extends Throwable>> handlerMethods=new ArrayList<HandlerMethod<? extends Throwable>>(handlersForException);
Collections.reverse(handlerMethods);
for (HandlerMethod<?> handler : handlerMethods) {
if (!processedHandlers.contains(handler)) {
LOG.fine(String.format(""String_Node_Str"",handler));
@SuppressWarnings(""String_Node_Str"") final DefaultExceptionEvent depthFirstEvent=new DefaultExceptionEvent(stack,false,exceptionEventEvent.isHandled());
handler.notify(depthFirstEvent,beanManager);
LOG.fine(String.format(""String_Node_Str"",handler,depthFirstEvent.getCurrentExceptionHandlingFlow().name()));
if (!depthFirstEvent.isUnmute()) {
processedHandlers.add(handler);
}
switch (depthFirstEvent.getCurrentExceptionHandlingFlow()) {
case HANDLED:
exceptionEventEvent.setHandled(true);
return;
case HANDLED_AND_CONTINUE:
exceptionEventEvent.setHandled(true);
break;
case ABORT:
return;
case SKIP_CAUSE:
exceptionEventEvent.setHandled(true);
stack.skipCause();
continue inbound_cause;
case THROW_ORIGINAL:
throwException=exceptionEventEvent.getException();
break;
case THROW:
throwException=depthFirstEvent.getThrowNewException();
break;
default :
throw new IllegalStateException(""String_Node_Str"" + depthFirstEvent.getCurrentExceptionHandlingFlow());
}
}
}
stack.skipCause();
}
if (!exceptionEventEvent.isHandled() && throwException == null && !exceptionEventEvent.isOptional()) {
LOG.warning(String.format(""String_Node_Str"",exceptionEventEvent.getException()));
throw exceptionEventEvent.getException();
}
if (throwException != null) {
throw throwException;
}
}
  finally {
if (creationalContext != null) {
creationalContext.release();
}
LOG.exiting(ExceptionHandlerBroadcaster.class.getName(),""String_Node_Str"",exceptionEventEvent.getException());
}
}"
52825,"private void destroyExpiredBeans(){
  ContextualStorage storage=viewAccessScopedBeanHolder.getContextualStorage(beanManager,getCurrentWindowId(),false);
  if (storage != null) {
    for (    Map.Entry<Object,ContextualInstanceInfo<?>> storageEntry : storage.getStorage().entrySet()) {
      if (!viewAccessScopedBeanHistory.getAccessedBeans().contains((String)storageEntry.getKey())) {
        Contextual bean=storage.getBean(storageEntry.getKey());
        AbstractContext.destroyBean(bean,storageEntry.getValue());
        storage.getStorage().remove(storageEntry.getKey());
        break;
      }
    }
  }
}","private void destroyExpiredBeans(){
  ContextualStorage storage=viewAccessScopedBeanHolder.getContextualStorage(beanManager,getCurrentWindowId(),false);
  if (storage != null) {
    for (    Map.Entry<Object,ContextualInstanceInfo<?>> storageEntry : storage.getStorage().entrySet()) {
      if (!viewAccessScopedBeanHistory.getAccessedBeans().contains((String)storageEntry.getKey())) {
        Contextual bean=storage.getBean(storageEntry.getKey());
        AbstractContext.destroyBean(bean,storageEntry.getValue());
        storage.getStorage().remove(storageEntry.getKey());
      }
    }
  }
}"
52826,"@Override public <T>T get(Contextual<T> bean,CreationalContext<T> creationalContext){
  PassivationCapable pc=(PassivationCapable)bean;
  viewAccessScopedBeanHistory.getAccessedBeans().add(pc.getId());
  return super.get(bean,creationalContext);
}","@Override public <T>T get(Contextual<T> bean,CreationalContext<T> creationalContext){
  try {
    return super.get(bean,creationalContext);
  }
  finally {
    if (bean instanceof PassivationCapable) {
      PassivationCapable pc=(PassivationCapable)bean;
      viewAccessScopedBeanHistory.getAccessedBeans().add(pc.getId());
    }
  }
}"
52827,"public void onRenderingFinished(String view){
  if (!view.equals(viewAccessScopedBeanHistory.getLastView())) {
    viewAccessScopedBeanHistory.setLastView(view);
    destroyExpiredBeans();
    viewAccessScopedBeanHistory.getAccessedBeans().clear();
  }
}","public void onRenderingFinished(String view){
  if (!view.equals(viewAccessScopedBeanHistory.getLastView())) {
    viewAccessScopedBeanHistory.setLastView(view);
    destroyExpiredBeans();
  }
  viewAccessScopedBeanHistory.getAccessedBeans().clear();
}"
52828,"@Override public <T extends ConstraintValidator<?,?>>T getInstance(Class<T> validatorClass){
  T resolvedInst=null;
  resolvedInst=BeanProvider.getContextualReference(validatorClass);
  if (resolvedInst == null) {
    if (log.isLoggable(Level.CONFIG)) {
      log.config(""String_Node_Str"" + validatorClass.getCanonicalName() + ""String_Node_Str"");
    }
    resolvedInst=this.delegate.getInstance(validatorClass);
  }
  return resolvedInst;
}","@Override public <T extends ConstraintValidator<?,?>>T getInstance(Class<T> validatorClass){
  T resolvedInst=null;
  resolvedInst=BeanProvider.getContextualReference(validatorClass,true);
  if (resolvedInst == null) {
    if (log.isLoggable(Level.CONFIG)) {
      log.config(""String_Node_Str"" + validatorClass.getCanonicalName() + ""String_Node_Str"");
    }
    resolvedInst=this.delegate.getInstance(validatorClass);
  }
  return resolvedInst;
}"
52829,"public DynamicMBeanWrapper(final Class<?> annotatedMBean,final boolean normalScope,final Annotation[] qualifiers){
  this.clazz=annotatedMBean;
  this.classloader=Thread.currentThread().getContextClassLoader();
  this.normalScope=normalScope;
  this.qualifiers=qualifiers;
  final List<MBeanAttributeInfo> attributeInfos=new ArrayList<MBeanAttributeInfo>();
  final List<MBeanOperationInfo> operationInfos=new ArrayList<MBeanOperationInfo>();
  final List<MBeanNotificationInfo> notificationInfos=new ArrayList<MBeanNotificationInfo>();
  final String description=getDescription(annotatedMBean.getAnnotation(MBean.class).description(),annotatedMBean.getName());
  final NotificationInfo notification=annotatedMBean.getAnnotation(NotificationInfo.class);
  if (notification != null) {
    notificationInfos.add(getNotificationInfo(notification,annotatedMBean.getName()));
  }
  final NotificationInfo.List notifications=annotatedMBean.getAnnotation(NotificationInfo.List.class);
  if (notifications != null) {
    for (    NotificationInfo notificationInfo : notifications.value()) {
      notificationInfos.add(getNotificationInfo(notificationInfo,annotatedMBean.getName()));
    }
  }
  for (  Method method : annotatedMBean.getMethods()) {
    final int modifiers=method.getModifiers();
    final JmxManaged annotation=method.getAnnotation(JmxManaged.class);
    if (method.getDeclaringClass().equals(Object.class) || !Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers)|| Modifier.isStatic(modifiers)|| annotation == null) {
      continue;
    }
    operations.put(method.getName(),method);
    String operationDescr=getDescription(annotation.description(),annotatedMBean.getName() + ""String_Node_Str"" + method.getName());
    operationInfos.add(new MBeanOperationInfo(operationDescr,method));
  }
  Class<?> clazz=annotatedMBean;
  while (!Object.class.equals(clazz) && clazz != null) {
    for (    Field field : clazz.getDeclaredFields()) {
      final JmxManaged annotation=field.getAnnotation(JmxManaged.class);
      if (annotation != null) {
        field.setAccessible(true);
        final String name=field.getName();
        final String fieldDescription=getDescription(annotation.description(),annotatedMBean.getClass() + ""String_Node_Str"" + name);
        final Class<?> type=field.getType();
        final String javaMtdName;
        if (name.length() > 1) {
          javaMtdName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
        }
 else {
          javaMtdName=""String_Node_Str"" + Character.toUpperCase(name.charAt(0));
        }
        Method setter=null;
        Method getter=null;
        try {
          getter=clazz.getMethod(""String_Node_Str"" + javaMtdName);
        }
 catch (        NoSuchMethodException e1) {
          try {
            getter=clazz.getMethod(""String_Node_Str"" + javaMtdName);
          }
 catch (          NoSuchMethodException e2) {
          }
        }
        try {
          setter=clazz.getMethod(""String_Node_Str"" + javaMtdName,field.getType());
        }
 catch (        NoSuchMethodException e) {
        }
        attributeInfos.add(new MBeanAttributeInfo(name,type.getName(),fieldDescription,getter != null,setter != null,false));
        fields.put(name,new FieldInfo(field,getter,setter));
      }
    }
    clazz=clazz.getSuperclass();
  }
  info=new MBeanInfo(annotatedMBean.getName(),description,attributeInfos.toArray(new MBeanAttributeInfo[attributeInfos.size()]),null,operationInfos.toArray(new MBeanOperationInfo[operationInfos.size()]),notificationInfos.toArray(new MBeanNotificationInfo[notificationInfos.size()]));
}","public DynamicMBeanWrapper(final Class<?> annotatedMBean,final boolean normalScope,final Annotation[] qualifiers,final MBean mBeanAnnotation){
  this.clazz=annotatedMBean;
  this.classloader=Thread.currentThread().getContextClassLoader();
  this.normalScope=normalScope;
  this.qualifiers=qualifiers;
  final List<MBeanAttributeInfo> attributeInfos=new ArrayList<MBeanAttributeInfo>();
  final List<MBeanOperationInfo> operationInfos=new ArrayList<MBeanOperationInfo>();
  final List<MBeanNotificationInfo> notificationInfos=new ArrayList<MBeanNotificationInfo>();
  final String description=getDescription(mBeanAnnotation.description(),annotatedMBean.getName());
  final NotificationInfo notification=annotatedMBean.getAnnotation(NotificationInfo.class);
  if (notification != null) {
    notificationInfos.add(getNotificationInfo(notification,annotatedMBean.getName()));
  }
  final NotificationInfo.List notifications=annotatedMBean.getAnnotation(NotificationInfo.List.class);
  if (notifications != null) {
    for (    NotificationInfo notificationInfo : notifications.value()) {
      notificationInfos.add(getNotificationInfo(notificationInfo,annotatedMBean.getName()));
    }
  }
  for (  Method method : annotatedMBean.getMethods()) {
    final int modifiers=method.getModifiers();
    final JmxManaged annotation=method.getAnnotation(JmxManaged.class);
    if (method.getDeclaringClass().equals(Object.class) || !Modifier.isPublic(modifiers) || Modifier.isAbstract(modifiers)|| Modifier.isStatic(modifiers)|| annotation == null) {
      continue;
    }
    operations.put(method.getName(),method);
    String operationDescr=getDescription(annotation.description(),annotatedMBean.getName() + ""String_Node_Str"" + method.getName());
    operationInfos.add(new MBeanOperationInfo(operationDescr,method));
  }
  Class<?> clazz=annotatedMBean;
  while (!Object.class.equals(clazz) && clazz != null) {
    for (    Field field : clazz.getDeclaredFields()) {
      final JmxManaged annotation=field.getAnnotation(JmxManaged.class);
      if (annotation != null) {
        field.setAccessible(true);
        final String name=field.getName();
        final String fieldDescription=getDescription(annotation.description(),annotatedMBean.getClass() + ""String_Node_Str"" + name);
        final Class<?> type=field.getType();
        final String javaMtdName;
        if (name.length() > 1) {
          javaMtdName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
        }
 else {
          javaMtdName=""String_Node_Str"" + Character.toUpperCase(name.charAt(0));
        }
        Method setter=null;
        Method getter=null;
        try {
          getter=clazz.getMethod(""String_Node_Str"" + javaMtdName);
        }
 catch (        NoSuchMethodException e1) {
          try {
            getter=clazz.getMethod(""String_Node_Str"" + javaMtdName);
          }
 catch (          NoSuchMethodException e2) {
          }
        }
        try {
          setter=clazz.getMethod(""String_Node_Str"" + javaMtdName,field.getType());
        }
 catch (        NoSuchMethodException e) {
        }
        attributeInfos.add(new MBeanAttributeInfo(name,type.getName(),fieldDescription,getter != null,setter != null,false));
        fields.put(name,new FieldInfo(field,getter,setter));
      }
    }
    clazz=clazz.getSuperclass();
  }
  info=new MBeanInfo(annotatedMBean.getName(),description,attributeInfos.toArray(new MBeanAttributeInfo[attributeInfos.size()]),null,operationInfos.toArray(new MBeanOperationInfo[operationInfos.size()]),notificationInfos.toArray(new MBeanNotificationInfo[notificationInfos.size()]));
}"
52830,"private MBeanNotificationInfo getNotificationInfo(final NotificationInfo n,String sourceInfo){
  return new MBeanNotificationInfo(n.types(),n.notificationClass().getName(),getDescription(n.description(),sourceInfo),new ImmutableDescriptor(n.descriptorFields()));
}","private MBeanNotificationInfo getNotificationInfo(final NotificationInfo notificationInfo,String sourceInfo){
  return new MBeanNotificationInfo(notificationInfo.types(),notificationInfo.notificationClass().getName(),getDescription(notificationInfo.description(),sourceInfo),new ImmutableDescriptor(notificationInfo.descriptorFields()));
}"
52831,"private boolean isNormalScope(final Annotation[] annotations,final Set<Annotation> annotationSet,final BeanManager bm){
  for (  Annotation annotation : annotations) {
    if (bm.isNormalScope(annotation.annotationType())) {
      return true;
    }
  }
  for (  Annotation annotation : annotationSet) {
    if (bm.isNormalScope(annotation.annotationType())) {
      return true;
    }
  }
  return false;
}","private boolean isNormalScope(final Set<Annotation> annotations,final BeanManager bm){
  for (  Annotation annotation : annotations) {
    if (bm.isNormalScope(annotation.annotationType())) {
      return true;
    }
  }
  return false;
}"
52832,"protected void processBean(@Observes final ProcessManagedBean<?> bean,final BeanManager bm) throws Exception {
  if (!isActivated) {
    return;
  }
  if (bean.getAnnotated().getAnnotation(MBean.class) != null) {
    final ObjectName name=register(bean,bm);
    objectNames.add(name);
    LOGGER.info(""String_Node_Str"" + name.getCanonicalName());
  }
}","protected void processBean(@Observes final ProcessManagedBean<?> bean,final BeanManager bm) throws Exception {
  if (!isActivated) {
    return;
  }
  MBean mBeanAnnotation=bean.getAnnotated().getAnnotation(MBean.class);
  if (mBeanAnnotation != null) {
    registerObject(bean,mBeanAnnotation,bm);
  }
}"
52833,"@Override public String getMessage(MessageContext messageContext,String messageTemplate,String category){
  if (messageTemplate.startsWith(""String_Node_Str"")) {
    return messageTemplate.substring(1);
  }
  if (messageTemplate.startsWith(""String_Node_Str"") && messageTemplate.endsWith(""String_Node_Str"")) {
    String resourceKey=messageTemplate.substring(1,messageTemplate.length() - 1);
    List<String> messageSources=messageContext.getMessageSources();
    if (messageSources == null || messageSources.isEmpty()) {
      return null;
    }
    Iterator<String> messageSourceIterator=messageSources.iterator();
    String currentMessageSource;
    while (messageSourceIterator.hasNext()) {
      currentMessageSource=messageSourceIterator.next();
      try {
        Locale locale=messageContext.getLocale();
        ResourceBundle messageBundle=PropertyFileUtils.getResourceBundle(currentMessageSource,locale);
        if (category != null && category.length() > 0) {
          try {
            return messageBundle.getString(resourceKey + ""String_Node_Str"" + category);
          }
 catch (          MissingResourceException e) {
            messageBundle.getString(resourceKey);
          }
        }
        return messageBundle.getString(resourceKey);
      }
 catch (      MissingResourceException e) {
        if (!messageSourceIterator.hasNext()) {
          return null;
        }
      }
    }
  }
  return messageTemplate;
}","@Override public String getMessage(MessageContext messageContext,String messageTemplate,String category){
  if (messageTemplate.startsWith(""String_Node_Str"")) {
    return messageTemplate.substring(1);
  }
  if (messageTemplate.startsWith(""String_Node_Str"") && messageTemplate.endsWith(""String_Node_Str"")) {
    String resourceKey=messageTemplate.substring(1,messageTemplate.length() - 1);
    List<String> messageSources=messageContext.getMessageSources();
    if (messageSources == null || messageSources.isEmpty()) {
      return null;
    }
    Iterator<String> messageSourceIterator=messageSources.iterator();
    Locale locale=messageContext.getLocale();
    String currentMessageSource;
    while (messageSourceIterator.hasNext()) {
      currentMessageSource=messageSourceIterator.next();
      try {
        ResourceBundle messageBundle=PropertyFileUtils.getResourceBundle(currentMessageSource,locale);
        if (category != null && category.length() > 0) {
          try {
            return messageBundle.getString(resourceKey + ""String_Node_Str"" + category);
          }
 catch (          MissingResourceException e) {
            return messageBundle.getString(resourceKey);
          }
        }
        return messageBundle.getString(resourceKey);
      }
 catch (      MissingResourceException e) {
        if (!messageSourceIterator.hasNext()) {
          return null;
        }
      }
    }
  }
  return messageTemplate;
}"
52834,"@Deployment public static WebArchive deploy(){
  return ShrinkWrap.create(WebArchive.class,""String_Node_Str"").addPackage(JsfMessageBackingBean.class.getPackage()).addAsResource(""String_Node_Str"").addAsLibraries(ArchiveUtils.getDeltaSpikeCoreAndJsfArchive()).addAsWebInfResource(""String_Node_Str"",""String_Node_Str"").addAsWebResource(""String_Node_Str"",""String_Node_Str"").addAsWebInfResource(EmptyAsset.INSTANCE,""String_Node_Str"");
}","@Deployment public static WebArchive deploy(){
  return ShrinkWrap.create(WebArchive.class,""String_Node_Str"").addPackage(JsfMessageBackingBean.class.getPackage()).addAsResource(""String_Node_Str"").addAsResource(""String_Node_Str"").addAsLibraries(ArchiveUtils.getDeltaSpikeCoreAndJsfArchive()).addAsWebInfResource(""String_Node_Str"",""String_Node_Str"").addAsWebResource(""String_Node_Str"",""String_Node_Str"").addAsWebInfResource(EmptyAsset.INSTANCE,""String_Node_Str"");
}"
52835,"/** 
 * Resolve all values for the given key, from all registered ConfigSources ordered by their ordinal value in ascending ways. If more   {@link ConfigSource}s have the same ordinal, their order is undefined.
 * @param key under which configuration is stored
 * @return List with all found property values, sorted in ascending order of their ordinal.
 * @see org.apache.deltaspike.core.spi.config.ConfigSource#getOrdinal()
 */
public static List<String> getAllPropertyValues(String key){
  List<ConfigSource> appConfigSources=sortAscending(Arrays.asList(getConfigSources()));
  List<String> result=new ArrayList<String>();
  String value;
  for (  ConfigSource configSource : appConfigSources) {
    value=configSource.getPropertyValue(key);
    if (value != null && !result.contains(value)) {
      result.add(value);
    }
  }
  return result;
}","/** 
 * Resolve all values for the given key, from all registered ConfigSources ordered by their ordinal value in ascending ways. If more   {@link ConfigSource}s have the same ordinal, their order is undefined.
 * @param key under which configuration is stored
 * @return List with all found property values, sorted in ascending order of their ordinal.
 * @see org.apache.deltaspike.core.spi.config.ConfigSource#getOrdinal()
 */
public static List<String> getAllPropertyValues(String key){
  List<ConfigSource> appConfigSources=sortAscending(new ArrayList<ConfigSource>(Arrays.asList(getConfigSources())));
  List<String> result=new ArrayList<String>();
  String value;
  for (  ConfigSource configSource : appConfigSources) {
    value=configSource.getPropertyValue(key);
    if (value != null && !result.contains(value)) {
      result.add(value);
    }
  }
  return result;
}"
52836,"/** 
 * Check to see if this event has been unmutted and therefore called again.
 */
boolean isUnmute();","/** 
 * Check to see if this event has been unmuted and therefore called again.
 */
boolean isUnmute();"
52837,"/** 
 * Constructor.
 */
public AnnotatedFieldImpl(AnnotatedType<X> declaringType,Field field,AnnotationStore annotations,Type overridenType){
  super(declaringType,field,field.getType(),annotations,field.getGenericType(),overridenType);
}","/** 
 * Constructor.
 */
public AnnotatedFieldImpl(AnnotatedType<X> declaringType,Field field,AnnotationStore annotations,Type overriddenType){
  super(declaringType,field,field.getType(),annotations,field.getGenericType(),overriddenType);
}"
52838,"protected AnnotatedImpl(Class<?> type,AnnotationStore annotations,Type genericType,Type overridenType){
  if (overridenType == null) {
    if (genericType != null) {
      typeClosure=new HierarchyDiscovery(genericType).getTypeClosure();
      this.type=genericType;
    }
 else {
      typeClosure=new HierarchyDiscovery(type).getTypeClosure();
      this.type=type;
    }
  }
 else {
    this.type=overridenType;
    typeClosure=Collections.singleton(overridenType);
  }
  if (annotations == null) {
    this.annotations=new AnnotationStore();
  }
 else {
    this.annotations=annotations;
  }
}","protected AnnotatedImpl(Class<?> type,AnnotationStore annotations,Type genericType,Type overriddenType){
  if (overriddenType == null) {
    if (genericType != null) {
      typeClosure=new HierarchyDiscovery(genericType).getTypeClosure();
      this.type=genericType;
    }
 else {
      typeClosure=new HierarchyDiscovery(type).getTypeClosure();
      this.type=type;
    }
  }
 else {
    this.type=overriddenType;
    typeClosure=Collections.singleton(overriddenType);
  }
  if (annotations == null) {
    this.annotations=new AnnotationStore();
  }
 else {
    this.annotations=annotations;
  }
}"
52839,"protected AnnotatedMemberImpl(AnnotatedType<X> declaringType,M member,Class<?> memberType,AnnotationStore annotations,Type genericType,Type overridenType){
  super(memberType,annotations,genericType,overridenType);
  this.declaringType=declaringType;
  javaMember=member;
}","protected AnnotatedMemberImpl(AnnotatedType<X> declaringType,M member,Class<?> memberType,AnnotationStore annotations,Type genericType,Type overriddenType){
  super(memberType,annotations,genericType,overriddenType);
  this.declaringType=declaringType;
  javaMember=member;
}"
52840,"/** 
 * Create an   {@link AnnotatedType}. Any public members present on the underlying class and not overridden by the builder will be automatically added.
 */
public AnnotatedType<X> create(){
  Map<Constructor<?>,Map<Integer,AnnotationStore>> constructorParameterAnnnotations=new HashMap<Constructor<?>,Map<Integer,AnnotationStore>>();
  Map<Constructor<?>,AnnotationStore> constructorAnnotations=new HashMap<Constructor<?>,AnnotationStore>();
  Map<Method,Map<Integer,AnnotationStore>> methodParameterAnnnotations=new HashMap<Method,Map<Integer,AnnotationStore>>();
  Map<Method,AnnotationStore> methodAnnotations=new HashMap<Method,AnnotationStore>();
  Map<Field,AnnotationStore> fieldAnnotations=new HashMap<Field,AnnotationStore>();
  for (  Map.Entry<Field,AnnotationBuilder> field : fields.entrySet()) {
    fieldAnnotations.put(field.getKey(),field.getValue().create());
  }
  for (  Map.Entry<Method,AnnotationBuilder> method : methods.entrySet()) {
    methodAnnotations.put(method.getKey(),method.getValue().create());
  }
  for (  Map.Entry<Method,Map<Integer,AnnotationBuilder>> parameters : methodParameters.entrySet()) {
    Map<Integer,AnnotationStore> parameterAnnotations=new HashMap<Integer,AnnotationStore>();
    methodParameterAnnnotations.put(parameters.getKey(),parameterAnnotations);
    for (    Map.Entry<Integer,AnnotationBuilder> parameter : parameters.getValue().entrySet()) {
      parameterAnnotations.put(parameter.getKey(),parameter.getValue().create());
    }
  }
  for (  Map.Entry<Constructor<?>,AnnotationBuilder> constructor : constructors.entrySet()) {
    constructorAnnotations.put(constructor.getKey(),constructor.getValue().create());
  }
  for (  Map.Entry<Constructor<?>,Map<Integer,AnnotationBuilder>> parameters : constructorParameters.entrySet()) {
    Map<Integer,AnnotationStore> parameterAnnotations=new HashMap<Integer,AnnotationStore>();
    constructorParameterAnnnotations.put(parameters.getKey(),parameterAnnotations);
    for (    Map.Entry<Integer,AnnotationBuilder> parameter : parameters.getValue().entrySet()) {
      parameterAnnotations.put(parameter.getKey(),parameter.getValue().create());
    }
  }
  return new AnnotatedTypeImpl<X>(javaClass,typeAnnotations.create(),fieldAnnotations,methodAnnotations,methodParameterAnnnotations,constructorAnnotations,constructorParameterAnnnotations,fieldTypes,methodParameterTypes,constructorParameterTypes);
}","/** 
 * Create an   {@link AnnotatedType}. Any public members present on the underlying class and not overridden by the builder will be automatically added.
 */
public AnnotatedType<X> create(){
  Map<Constructor<?>,Map<Integer,AnnotationStore>> constructorParameterAnnotations=new HashMap<Constructor<?>,Map<Integer,AnnotationStore>>();
  Map<Constructor<?>,AnnotationStore> constructorAnnotations=new HashMap<Constructor<?>,AnnotationStore>();
  Map<Method,Map<Integer,AnnotationStore>> methodParameterAnnotations=new HashMap<Method,Map<Integer,AnnotationStore>>();
  Map<Method,AnnotationStore> methodAnnotations=new HashMap<Method,AnnotationStore>();
  Map<Field,AnnotationStore> fieldAnnotations=new HashMap<Field,AnnotationStore>();
  for (  Map.Entry<Field,AnnotationBuilder> field : fields.entrySet()) {
    fieldAnnotations.put(field.getKey(),field.getValue().create());
  }
  for (  Map.Entry<Method,AnnotationBuilder> method : methods.entrySet()) {
    methodAnnotations.put(method.getKey(),method.getValue().create());
  }
  for (  Map.Entry<Method,Map<Integer,AnnotationBuilder>> parameters : methodParameters.entrySet()) {
    Map<Integer,AnnotationStore> parameterAnnotations=new HashMap<Integer,AnnotationStore>();
    methodParameterAnnotations.put(parameters.getKey(),parameterAnnotations);
    for (    Map.Entry<Integer,AnnotationBuilder> parameter : parameters.getValue().entrySet()) {
      parameterAnnotations.put(parameter.getKey(),parameter.getValue().create());
    }
  }
  for (  Map.Entry<Constructor<?>,AnnotationBuilder> constructor : constructors.entrySet()) {
    constructorAnnotations.put(constructor.getKey(),constructor.getValue().create());
  }
  for (  Map.Entry<Constructor<?>,Map<Integer,AnnotationBuilder>> parameters : constructorParameters.entrySet()) {
    Map<Integer,AnnotationStore> parameterAnnotations=new HashMap<Integer,AnnotationStore>();
    constructorParameterAnnotations.put(parameters.getKey(),parameterAnnotations);
    for (    Map.Entry<Integer,AnnotationBuilder> parameter : parameters.getValue().entrySet()) {
      parameterAnnotations.put(parameter.getKey(),parameter.getValue().create());
    }
  }
  return new AnnotatedTypeImpl<X>(javaClass,typeAnnotations.create(),fieldAnnotations,methodAnnotations,methodParameterAnnotations,constructorAnnotations,constructorParameterAnnotations,fieldTypes,methodParameterTypes,constructorParameterTypes);
}"
52841,"/** 
 * {@inheritDoc}
 */
public List<AnnotatedParameter<X>> getParameters(){
  return Collections.unmodifiableList(parameters);
}","/** 
 * {@inheritDoc}
 */
@Override public List<AnnotatedParameter<X>> getParameters(){
  return Collections.unmodifiableList(parameters);
}"
52842,"private Properties loadProperties(URL url){
  Properties props=new Properties();
  InputStream inputStream=null;
  try {
    inputStream=url.openStream();
    if (inputStream != null) {
      props.load(inputStream);
    }
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    try {
      if (inputStream != null) {
        inputStream.close();
      }
    }
 catch (    IOException e) {
    }
  }
  return props;
}","private Properties loadProperties(URL url){
  Properties props=new Properties();
  InputStream inputStream=null;
  try {
    inputStream=url.openStream();
    if (inputStream != null) {
      props.load(inputStream);
    }
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
 finally {
    try {
      if (inputStream != null) {
        inputStream.close();
      }
    }
 catch (    IOException e) {
    }
  }
  return props;
}"
52843,"/** 
 * Access to the   {@link AnnotatedElement} on which this annotation isdefined. If the annotation is defined on a Field, this may be cast to {@link Field}, if defined on a method, this may be cast to   {@link Method}, if defined on a constructor, this may be cast to   {@link Constructor}, if defined on a class, this may be cast to   {@link Class}, or if defined on a parameter, this may be cast to   {@link Parameter}
 */
public AnnotatedElement getAnnotatedElement(){
  return annotatedElement;
}","/** 
 * Access to the   {@link AnnotatedElement} on which this annotation isdefined. If the annotation is defined on a Field, this may be cast to {@link java.lang.reflect.Field}, if defined on a method, this may be cast to   {@link java.lang.reflect.Method}, if defined on a constructor, this may be cast to   {@link java.lang.reflect.Constructor}, if defined on a class, this may be cast to   {@link Class}, or if defined on a parameter, this may be cast to   {@link Parameter}
 */
public AnnotatedElement getAnnotatedElement(){
  return annotatedElement;
}"
52844,"/** 
 * Set the accessibility flag on the   {@link AccessibleObject} as described in{@link AccessibleObject#setAccessible(boolean)} within the context ofa  {@link PrivilegedAction}.
 * @param < A >    member the accessible object type
 * @param member the accessible object
 * @return the accessible object after the accessible flag has been altered
 */
public static <A extends AccessibleObject>A setAccessible(A member){
  AccessController.doPrivileged(new SetAccessiblePrivilegedAction(member));
  return member;
}","/** 
 * Set the accessibility flag on the   {@link AccessibleObject} as described in{@link AccessibleObject#setAccessible(boolean)} within the context ofa  {@link java.security.PrivilegedAction}.
 * @param < A >    member the accessible object type
 * @param member the accessible object
 * @return the accessible object after the accessible flag has been altered
 */
public static <A extends AccessibleObject>A setAccessible(A member){
  AccessController.doPrivileged(new SetAccessiblePrivilegedAction(member));
  return member;
}"
52845,"/** 
 * <p> Loads and initializes a class for the given name. </p> <p/> <p> If the Thread Context Class Loader is available, it will be used, otherwise the classloader used to load   {@link Reflections} will be used</p> <p/> <p> It is also possible to specify additional classloaders to attempt to load the class with. If the first attempt fails, then these additional loaders are tried in order. </p>
 * @param name    the name of the class to load
 * @param loaders additional classloaders to use to attempt to load the class
 * @return the class object
 * @throws ClassNotFoundException if the class cannot be found
 */
public static Class<?> classForName(String name,ClassLoader... loaders) throws ClassNotFoundException {
  try {
    if (Thread.currentThread().getContextClassLoader() != null) {
      return Class.forName(name,true,Thread.currentThread().getContextClassLoader());
    }
 else {
      return Class.forName(name);
    }
  }
 catch (  ClassNotFoundException e) {
    for (    ClassLoader l : loaders) {
      try {
        return Class.forName(name,true,l);
      }
 catch (      ClassNotFoundException ex) {
      }
    }
  }
  if (Thread.currentThread().getContextClassLoader() != null) {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Thread.currentThread().getContextClassLoader().toString()+ ""String_Node_Str""+ Arrays.toString(loaders));
  }
 else {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Arrays.toString(loaders));
  }
}","/** 
 * <p> Loads and initializes a class for the given name. </p> <p/> <p> If the Thread Context Class Loader is available, it will be used, otherwise the classloader used to load   {@link Reflections} will be used</p> <p/> <p> It is also possible to specify additional classloaders to attempt to load the class with. If the first attempt fails, then these additional loaders are tried in order. </p>
 * @param name    the name of the class to load
 * @param loaders additional classloaders to use to attempt to load the class
 * @return the class object
 * @throws ClassNotFoundException if the class cannot be found
 */
public static Class<?> classForName(String name,ClassLoader... loaders) throws ClassNotFoundException {
  try {
    if (Thread.currentThread().getContextClassLoader() != null) {
      return Class.forName(name,true,Thread.currentThread().getContextClassLoader());
    }
 else {
      return Class.forName(name);
    }
  }
 catch (  ClassNotFoundException e) {
    for (    ClassLoader l : loaders) {
      try {
        return Class.forName(name,true,l);
      }
 catch (      ClassNotFoundException ex) {
      }
    }
  }
  if (Thread.currentThread().getContextClassLoader() != null) {
    throw new ClassNotFoundException(String.format(""String_Node_Str"",name,Thread.currentThread().getContextClassLoader(),loaders));
  }
 else {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Arrays.toString(loaders));
  }
}"
52846,"private static String buildInvokeMethodErrorMessage(Method method,Object obj,Object... args){
  StringBuilder message=new StringBuilder(String.format(""String_Node_Str"",method.getName(),obj));
  if (args != null)   for (int i=0; i < args.length; i++)   message.append((i > 0 ? ""String_Node_Str"" : ""String_Node_Str"") + args[i]);
  message.append(""String_Node_Str"");
  return message.toString();
}","private static String buildInvokeMethodErrorMessage(Method method,Object obj,Object... args){
  StringBuilder message=new StringBuilder(String.format(""String_Node_Str"",method.getName(),obj));
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      message.append((i > 0 ? ""String_Node_Str"" : ""String_Node_Str"") + args[i]);
    }
  }
  message.append(""String_Node_Str"");
  return message.toString();
}"
52847,"/** 
 * Access to the   {@link AnnotatedElement} on which this annotation isdefined. If the annotation is defined on a Field, this may be cast to {@link java.lang.reflect.Field}, if defined on a method, this may be cast to   {@link java.lang.reflect.Method}, if defined on a constructor, this may be cast to   {@link java.lang.reflect.Constructor}, if defined on a class, this may be cast to   {@link Class}, or if defined on a parameter, this may be cast to   {@link Parameter}
 */
public AnnotatedElement getAnnotatedElement(){
  return annotatedElement;
}","/** 
 * Access to the   {@link AnnotatedElement} on which this annotation isdefined. If the annotation is defined on a Field, this may be cast to {@link Field}, if defined on a method, this may be cast to   {@link Method}, if defined on a constructor, this may be cast to   {@link Constructor}, if defined on a class, this may be cast to   {@link Class}, or if defined on a parameter, this may be cast to   {@link Parameter}
 */
public AnnotatedElement getAnnotatedElement(){
  return annotatedElement;
}"
52848,"/** 
 * Set the accessibility flag on the   {@link AccessibleObject} as described in{@link AccessibleObject#setAccessible(boolean)} within the context ofa  {@link java.security.PrivilegedAction}.
 * @param < A >    member the accessible object type
 * @param member the accessible object
 * @return the accessible object after the accessible flag has been altered
 */
public static <A extends AccessibleObject>A setAccessible(A member){
  AccessController.doPrivileged(new SetAccessiblePrivilegedAction(member));
  return member;
}","/** 
 * Set the accessibility flag on the   {@link AccessibleObject} as described in{@link AccessibleObject#setAccessible(boolean)} within the context ofa  {@link PrivilegedAction}.
 * @param < A >    member the accessible object type
 * @param member the accessible object
 * @return the accessible object after the accessible flag has been altered
 */
public static <A extends AccessibleObject>A setAccessible(A member){
  AccessController.doPrivileged(new SetAccessiblePrivilegedAction(member));
  return member;
}"
52849,"/** 
 * <p> Loads and initializes a class for the given name. </p> <p/> <p> If the Thread Context Class Loader is available, it will be used, otherwise the classloader used to load   {@link Reflections} will be used</p> <p/> <p> It is also possible to specify additional classloaders to attempt to load the class with. If the first attempt fails, then these additional loaders are tried in order. </p>
 * @param name    the name of the class to load
 * @param loaders additional classloaders to use to attempt to load the class
 * @return the class object
 * @throws ClassNotFoundException if the class cannot be found
 */
public static Class<?> classForName(String name,ClassLoader... loaders) throws ClassNotFoundException {
  try {
    if (Thread.currentThread().getContextClassLoader() != null) {
      return Class.forName(name,true,Thread.currentThread().getContextClassLoader());
    }
 else {
      return Class.forName(name);
    }
  }
 catch (  ClassNotFoundException e) {
    for (    ClassLoader l : loaders) {
      try {
        return Class.forName(name,true,l);
      }
 catch (      ClassNotFoundException ex) {
      }
    }
  }
  if (Thread.currentThread().getContextClassLoader() != null) {
    throw new ClassNotFoundException(String.format(""String_Node_Str"",name,Thread.currentThread().getContextClassLoader(),loaders));
  }
 else {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Arrays.toString(loaders));
  }
}","/** 
 * <p> Loads and initializes a class for the given name. </p> <p/> <p> If the Thread Context Class Loader is available, it will be used, otherwise the classloader used to load   {@link Reflections} will be used</p> <p/> <p> It is also possible to specify additional classloaders to attempt to load the class with. If the first attempt fails, then these additional loaders are tried in order. </p>
 * @param name    the name of the class to load
 * @param loaders additional classloaders to use to attempt to load the class
 * @return the class object
 * @throws ClassNotFoundException if the class cannot be found
 */
public static Class<?> classForName(String name,ClassLoader... loaders) throws ClassNotFoundException {
  try {
    if (Thread.currentThread().getContextClassLoader() != null) {
      return Class.forName(name,true,Thread.currentThread().getContextClassLoader());
    }
 else {
      return Class.forName(name);
    }
  }
 catch (  ClassNotFoundException e) {
    for (    ClassLoader l : loaders) {
      try {
        return Class.forName(name,true,l);
      }
 catch (      ClassNotFoundException ex) {
      }
    }
  }
  if (Thread.currentThread().getContextClassLoader() != null) {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Thread.currentThread().getContextClassLoader().toString()+ ""String_Node_Str""+ Arrays.toString(loaders));
  }
 else {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Arrays.toString(loaders));
  }
}"
52850,"private static String buildInvokeMethodErrorMessage(Method method,Object obj,Object... args){
  StringBuilder message=new StringBuilder(String.format(""String_Node_Str"",method.getName(),obj));
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      message.append((i > 0 ? ""String_Node_Str"" : ""String_Node_Str"") + args[i]);
    }
  }
  message.append(""String_Node_Str"");
  return message.toString();
}","private static String buildInvokeMethodErrorMessage(Method method,Object obj,Object... args){
  StringBuilder message=new StringBuilder(String.format(""String_Node_Str"",method.getName(),obj));
  if (args != null)   for (int i=0; i < args.length; i++)   message.append((i > 0 ? ""String_Node_Str"" : ""String_Node_Str"") + args[i]);
  message.append(""String_Node_Str"");
  return message.toString();
}"
52851,"/** 
 * Access to the   {@link AnnotatedElement} on which this annotation isdefined. If the annotation is defined on a Field, this may be cast to {@link Field}, if defined on a method, this may be cast to   {@link Method}, if defined on a constructor, this may be cast to   {@link Constructor}, if defined on a class, this may be cast to   {@link Class}, or if defined on a parameter, this may be cast to   {@link Parameter}
 */
public AnnotatedElement getAnnotatedElement(){
  return annotatedElement;
}","/** 
 * Access to the   {@link AnnotatedElement} on which this annotation isdefined. If the annotation is defined on a Field, this may be cast to {@link java.lang.reflect.Field}, if defined on a method, this may be cast to   {@link java.lang.reflect.Method}, if defined on a constructor, this may be cast to   {@link java.lang.reflect.Constructor}, if defined on a class, this may be cast to   {@link Class}, or if defined on a parameter, this may be cast to   {@link Parameter}
 */
public AnnotatedElement getAnnotatedElement(){
  return annotatedElement;
}"
52852,"/** 
 * Set the accessibility flag on the   {@link AccessibleObject} as described in{@link AccessibleObject#setAccessible(boolean)} within the context ofa  {@link PrivilegedAction}.
 * @param < A >    member the accessible object type
 * @param member the accessible object
 * @return the accessible object after the accessible flag has been altered
 */
public static <A extends AccessibleObject>A setAccessible(A member){
  AccessController.doPrivileged(new SetAccessiblePrivilegedAction(member));
  return member;
}","/** 
 * Set the accessibility flag on the   {@link AccessibleObject} as described in{@link AccessibleObject#setAccessible(boolean)} within the context ofa  {@link java.security.PrivilegedAction}.
 * @param < A >    member the accessible object type
 * @param member the accessible object
 * @return the accessible object after the accessible flag has been altered
 */
public static <A extends AccessibleObject>A setAccessible(A member){
  AccessController.doPrivileged(new SetAccessiblePrivilegedAction(member));
  return member;
}"
52853,"/** 
 * <p> Loads and initializes a class for the given name. </p> <p/> <p> If the Thread Context Class Loader is available, it will be used, otherwise the classloader used to load   {@link Reflections} will be used</p> <p/> <p> It is also possible to specify additional classloaders to attempt to load the class with. If the first attempt fails, then these additional loaders are tried in order. </p>
 * @param name    the name of the class to load
 * @param loaders additional classloaders to use to attempt to load the class
 * @return the class object
 * @throws ClassNotFoundException if the class cannot be found
 */
public static Class<?> classForName(String name,ClassLoader... loaders) throws ClassNotFoundException {
  try {
    if (Thread.currentThread().getContextClassLoader() != null) {
      return Class.forName(name,true,Thread.currentThread().getContextClassLoader());
    }
 else {
      return Class.forName(name);
    }
  }
 catch (  ClassNotFoundException e) {
    for (    ClassLoader l : loaders) {
      try {
        return Class.forName(name,true,l);
      }
 catch (      ClassNotFoundException ex) {
      }
    }
  }
  if (Thread.currentThread().getContextClassLoader() != null) {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Thread.currentThread().getContextClassLoader().toString()+ ""String_Node_Str""+ Arrays.toString(loaders));
  }
 else {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Arrays.toString(loaders));
  }
}","/** 
 * <p> Loads and initializes a class for the given name. </p> <p/> <p> If the Thread Context Class Loader is available, it will be used, otherwise the classloader used to load   {@link Reflections} will be used</p> <p/> <p> It is also possible to specify additional classloaders to attempt to load the class with. If the first attempt fails, then these additional loaders are tried in order. </p>
 * @param name    the name of the class to load
 * @param loaders additional classloaders to use to attempt to load the class
 * @return the class object
 * @throws ClassNotFoundException if the class cannot be found
 */
public static Class<?> classForName(String name,ClassLoader... loaders) throws ClassNotFoundException {
  try {
    if (Thread.currentThread().getContextClassLoader() != null) {
      return Class.forName(name,true,Thread.currentThread().getContextClassLoader());
    }
 else {
      return Class.forName(name);
    }
  }
 catch (  ClassNotFoundException e) {
    for (    ClassLoader l : loaders) {
      try {
        return Class.forName(name,true,l);
      }
 catch (      ClassNotFoundException ex) {
      }
    }
  }
  if (Thread.currentThread().getContextClassLoader() != null) {
    throw new ClassNotFoundException(String.format(""String_Node_Str"",name,Thread.currentThread().getContextClassLoader(),loaders));
  }
 else {
    throw new ClassNotFoundException(""String_Node_Str"" + name + ""String_Node_Str""+ Arrays.toString(loaders));
  }
}"
52854,"private static String buildInvokeMethodErrorMessage(Method method,Object obj,Object... args){
  StringBuilder message=new StringBuilder(String.format(""String_Node_Str"",method.getName(),obj));
  if (args != null)   for (int i=0; i < args.length; i++)   message.append((i > 0 ? ""String_Node_Str"" : ""String_Node_Str"") + args[i]);
  message.append(""String_Node_Str"");
  return message.toString();
}","private static String buildInvokeMethodErrorMessage(Method method,Object obj,Object... args){
  StringBuilder message=new StringBuilder(String.format(""String_Node_Str"",method.getName(),obj));
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      message.append((i > 0 ? ""String_Node_Str"" : ""String_Node_Str"") + args[i]);
    }
  }
  message.append(""String_Node_Str"");
  return message.toString();
}"
52855,"private static boolean includeIfPackageExists(String jarEntryName,String[] includeOnPackages){
  if (includeOnPackages == null) {
    return true;
  }
  String packageName=jarEntryName.replace('/','.');
  for (  String includeOnPackage : includeOnPackages) {
    if (packageName.startsWith(includeOnPackage)) {
      return true;
    }
  }
  return false;
}","private static boolean includeIfPackageExists(String jarEntryName,String[] includeOnPackages){
  if (includeOnPackages == null) {
    return true;
  }
  String packageName=pathToClassName(jarEntryName);
  for (  String includeOnPackage : includeOnPackages) {
    if (packageName.startsWith(includeOnPackage)) {
      return true;
    }
  }
  return false;
}"
52856,"private static boolean excludeIfPackageExists(String jarEntryName,String[] excludeOnPackages){
  if (excludeOnPackages != null) {
    String packageName=jarEntryName.replace('/','.');
    for (    String excludeOnPackage : excludeOnPackages) {
      if (packageName.startsWith(excludeOnPackage)) {
        return true;
      }
    }
  }
  return false;
}","private static boolean excludeIfPackageExists(String jarEntryName,String[] excludeOnPackages){
  if (excludeOnPackages != null) {
    String packageName=pathToClassName(jarEntryName);
    for (    String excludeOnPackage : excludeOnPackages) {
      if (packageName.startsWith(excludeOnPackage)) {
        return true;
      }
    }
  }
  return false;
}"
52857,"private static JavaArchive addJarArchive(InputStream inputStream,String[] includeIfPackageExists,String[] excludeIfPackageExists) throws IOException {
  JavaArchive ret=null;
  JavaArchive javaArchive=ShrinkWrap.create(JavaArchive.class);
  if (includeIfPackageExists == null) {
    ret=javaArchive;
  }
  JarInputStream jar=new JarInputStream(inputStream);
  try {
    for (ZipEntry jarEntry=jar.getNextEntry(); jarEntry != null; jarEntry=jar.getNextEntry()) {
      String entryName=jarEntry.getName();
      if (jarEntry.isDirectory()) {
        if (excludeIfPackageExists(entryName,excludeIfPackageExists)) {
          return null;
        }
        if (ret == null && includeIfPackageExists(entryName,includeIfPackageExists)) {
          ret=javaArchive;
        }
        continue;
      }
      if (entryName.endsWith(""String_Node_Str"")) {
        String className=entryName.substring(0,entryName.length() - (""String_Node_Str"".length())).replace('/','.');
        javaArchive.addClass(className);
      }
 else {
        javaArchive.addAsResource(entryName);
      }
    }
  }
  finally {
    try {
      jar.close();
    }
 catch (    IOException ignored) {
    }
  }
  return ret;
}","private static JavaArchive addJarArchive(InputStream inputStream,String[] includeIfPackageExists,String[] excludeIfPackageExists) throws IOException {
  JavaArchive ret=null;
  JavaArchive javaArchive=ShrinkWrap.create(JavaArchive.class);
  if (includeIfPackageExists == null) {
    ret=javaArchive;
  }
  JarInputStream jar=new JarInputStream(inputStream);
  try {
    for (ZipEntry jarEntry=jar.getNextEntry(); jarEntry != null; jarEntry=jar.getNextEntry()) {
      String entryName=jarEntry.getName();
      if (jarEntry.isDirectory()) {
        if (excludeIfPackageExists(entryName,excludeIfPackageExists)) {
          return null;
        }
        if (ret == null && includeIfPackageExists(entryName,includeIfPackageExists)) {
          ret=javaArchive;
        }
        continue;
      }
      if (entryName.endsWith(""String_Node_Str"")) {
        String className=pathToClassName(entryName.substring(0,entryName.length() - (""String_Node_Str"".length())));
        javaArchive.addClass(className);
      }
 else {
        javaArchive.addAsResource(entryName);
      }
    }
  }
  finally {
    try {
      jar.close();
    }
 catch (    IOException ignored) {
    }
  }
  return ret;
}"
52858,"private static JavaArchive addFileArchive(File archiveBasePath,String[] includeIfPackageExists,String[] excludeIfPackageExists) throws IOException {
  if (!archiveBasePath.exists()) {
    return null;
  }
  JavaArchive ret=null;
  JavaArchive javaArchive=ShrinkWrap.create(JavaArchive.class);
  if (includeIfPackageExists == null) {
    ret=javaArchive;
  }
  int basePathLength=archiveBasePath.getAbsolutePath().length() + 1;
  for (  File archiveEntry : collectArchiveEntries(archiveBasePath)) {
    String entryName=archiveEntry.getAbsolutePath().substring(basePathLength);
    if (excludeIfPackageExists(entryName,excludeIfPackageExists)) {
      return null;
    }
    if (ret == null && includeIfPackageExists(entryName,includeIfPackageExists)) {
      ret=javaArchive;
    }
    if (entryName.endsWith(""String_Node_Str"")) {
      String className=entryName.substring(0,entryName.length() - (""String_Node_Str"".length())).replace('/','.');
      javaArchive.addClass(className);
    }
 else {
      javaArchive.addAsResource(entryName);
    }
  }
  return ret;
}","private static JavaArchive addFileArchive(File archiveBasePath,String[] includeIfPackageExists,String[] excludeIfPackageExists) throws IOException {
  if (!archiveBasePath.exists()) {
    return null;
  }
  JavaArchive ret=null;
  JavaArchive javaArchive=ShrinkWrap.create(JavaArchive.class);
  if (includeIfPackageExists == null) {
    ret=javaArchive;
  }
  int basePathLength=archiveBasePath.getAbsolutePath().length() + 1;
  for (  File archiveEntry : collectArchiveEntries(archiveBasePath)) {
    String entryName=archiveEntry.getAbsolutePath().substring(basePathLength);
    if (excludeIfPackageExists(entryName,excludeIfPackageExists)) {
      return null;
    }
    if (ret == null && includeIfPackageExists(entryName,includeIfPackageExists)) {
      ret=javaArchive;
    }
    if (entryName.endsWith(""String_Node_Str"")) {
      String className=pathToClassName(entryName.substring(0,entryName.length() - (""String_Node_Str"".length())));
      javaArchive.addClass(className);
    }
 else {
      javaArchive.addAsResource(entryName.replace('\\','/'));
    }
  }
  return ret;
}"
52859,"/** 
 * Instantiates a given class via the default constructor
 * @param targetClass class which should be instantiated
 * @param < T > current type
 * @return created instance or null if the instantiation failed
 */
public static <T>T tryToInstantiateClass(Class<T> targetClass){
  try {
    return targetClass.newInstance();
  }
 catch (  Exception e) {
  }
  return null;
}","/** 
 * Instantiates a given class via the default constructor
 * @param targetClass class which should be instantiated
 * @param < T > current type
 * @return created instance or null if the instantiation failed
 */
public static <T>T tryToInstantiateClass(Class<T> targetClass){
  try {
    return targetClass.newInstance();
  }
 catch (  InstantiationException e) {
  }
catch (  IllegalAccessException e) {
  }
  return null;
}"
52860,"@Override public void calculateBuffer(){
  if (adderUGen == null) {
    for (int j=0; j < outs; j++) {
      float[] bi=bufIn[j];
      float[] bo=bufOut[j];
      for (int i=0; i < bufferSize; i++) {
        bo[i]=bi[j] + adder;
      }
    }
  }
 else {
    adderUGen.update();
    if (outs == 1) {
      float[] bi=bufIn[0];
      float[] bo=bufOut[0];
      for (int i=0; i < bufferSize; i++) {
        adder=adderUGen.getValue(0,i);
        bo[i]=bi[i] + adder;
      }
    }
 else {
      for (int i=0; i < bufferSize; i++) {
        for (int j=0; j < outs; j++) {
          adder=adderUGen.getValue(0,i);
          bufOut[j][i]=bufIn[j][i] + adder;
        }
      }
    }
  }
}","@Override public void calculateBuffer(){
  if (adderUGen == null) {
    for (int j=0; j < outs; j++) {
      float[] bi=bufIn[j];
      float[] bo=bufOut[j];
      for (int i=0; i < bufferSize; i++) {
        bo[i]=bi[i] + adder;
      }
    }
  }
 else {
    adderUGen.update();
    if (outs == 1) {
      float[] bi=bufIn[0];
      float[] bo=bufOut[0];
      for (int i=0; i < bufferSize; i++) {
        adder=adderUGen.getValue(0,i);
        bo[i]=bi[i] + adder;
      }
    }
 else {
      for (int i=0; i < bufferSize; i++) {
        for (int j=0; j < outs; j++) {
          adder=adderUGen.getValue(0,i);
          bufOut[j][i]=bufIn[j][i] + adder;
        }
      }
    }
  }
}"
52861,"public static void main(String[] args){
  AudioContext ac;
  ac=new AudioContext();
  WavePlayer wp=new WavePlayer(ac,500,Buffer.SINE);
  Gain g=new Gain(ac,1,new Envelope(ac,0.1f));
  ((Envelope)g.getGainEnvelope()).addSegment(0,5000,new AudioContextStopTrigger(ac));
  g.addInput(wp);
  ac.out.addInput(g);
  Clock c=new Clock(ac,1000);
  c.setClick(true);
  ac.out.addDependent(c);
  ac.start();
}","public static void main(String[] args){
  AudioContext ac;
  ac=new AudioContext();
  WavePlayer wp=new WavePlayer(ac,500,Buffer.SINE);
  Gain g=new Gain(ac,1,new Envelope(ac,0.1f));
  ((Envelope)g.getGainUGen()).addSegment(0,5000,new AudioContextStopTrigger(ac));
  g.addInput(wp);
  ac.out.addInput(g);
  Clock c=new Clock(ac,1000);
  c.setClick(true);
  ac.out.addDependent(c);
  ac.start();
}"
52862,"public void messageReceived(Bead message){
  Clock c=(Clock)message;
  if (c.isBeat()) {
    WavePlayer wp=new WavePlayer(ac,(float)Math.random() * 3000 + 100,Buffer.SINE);
    Gain g=new Gain(ac,1,new Envelope(ac,0.1f));
    ((Envelope)g.getGainEnvelope()).addSegment(0,1000,new KillTrigger(g));
    g.addInput(wp);
    ac.out.addInput(g);
  }
}","public void messageReceived(Bead message){
  Clock c=(Clock)message;
  if (c.isBeat()) {
    WavePlayer wp=new WavePlayer(ac,(float)Math.random() * 3000 + 100,Buffer.SINE);
    Gain g=new Gain(ac,1,new Envelope(ac,0.1f));
    ((Envelope)g.getGainUGen()).addSegment(0,1000,new KillTrigger(g));
    g.addInput(wp);
    ac.out.addInput(g);
  }
}"
52863,"public static void main(String[] args){
  final AudioContext ac;
  ac=new AudioContext();
  Clock clock=new Clock(ac,700);
  clock.addMessageListener(new Bead(){
    public void messageReceived(    Bead message){
      Clock c=(Clock)message;
      if (c.isBeat()) {
        WavePlayer wp=new WavePlayer(ac,(float)Math.random() * 3000 + 100,Buffer.SINE);
        Gain g=new Gain(ac,1,new Envelope(ac,0.1f));
        ((Envelope)g.getGainEnvelope()).addSegment(0,1000,new KillTrigger(g));
        g.addInput(wp);
        ac.out.addInput(g);
      }
    }
  }
);
  ac.out.addDependent(clock);
  ac.start();
}","public static void main(String[] args){
  final AudioContext ac;
  ac=new AudioContext();
  Clock clock=new Clock(ac,700);
  clock.addMessageListener(new Bead(){
    public void messageReceived(    Bead message){
      Clock c=(Clock)message;
      if (c.isBeat()) {
        WavePlayer wp=new WavePlayer(ac,(float)Math.random() * 3000 + 100,Buffer.SINE);
        Gain g=new Gain(ac,1,new Envelope(ac,0.1f));
        ((Envelope)g.getGainUGen()).addSegment(0,1000,new KillTrigger(g));
        g.addInput(wp);
        ac.out.addInput(g);
      }
    }
  }
);
  ac.out.addDependent(clock);
  ac.start();
}"
52864,"/** 
 * Specify an audio file that the Sample reads from. If BufferedRegime is TOTAL, this will block until the sample is loaded.
 * @throws AudioFileUnsupportedException
 */
private void loadAudioFile(String file) throws IOException {
  Class<? extends AudioFileReader> theRealAudioFileReaderClass=audioFileReaderClass == null ? defaultAudioFileReaderClass : audioFileReaderClass;
  AudioFileReader audioFileReader;
  try {
    audioFileReader=theRealAudioFileReaderClass.getConstructor().newInstance();
  }
 catch (  Exception e1) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    this.theSampleData=audioFileReader.readAudioFile(file);
  }
 catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + file);
  }
  this.sampleRate=audioFileReader.getSampleAudioFormat().sampleRate;
  this.nChannels=theSampleData.length;
  this.nFrames=theSampleData[0].length;
}","/** 
 * Specify an audio file that the Sample reads from. If BufferedRegime is TOTAL, this will block until the sample is loaded.
 * @throws AudioFileUnsupportedException
 */
private void loadAudioFile(String file) throws IOException {
  Class<? extends AudioFileReader> theRealAudioFileReaderClass=audioFileReaderClass == null ? defaultAudioFileReaderClass : audioFileReaderClass;
  AudioFileReader audioFileReader;
  try {
    audioFileReader=theRealAudioFileReaderClass.getConstructor().newInstance();
  }
 catch (  Exception e1) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    this.theSampleData=audioFileReader.readAudioFile(file);
  }
 catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + file + ""String_Node_Str""+ e.getMessage());
  }
  this.sampleRate=audioFileReader.getSampleAudioFormat().sampleRate;
  this.nChannels=theSampleData.length;
  this.nFrames=theSampleData[0].length;
  this.current=new float[nChannels];
  this.next=new float[nChannels];
}"
52865,"public static void main(String[] args){
  AudioContext ac;
  ac=new AudioContext();
  String audioFile=""String_Node_Str"";
  GranularSamplePlayer player=new GranularSamplePlayer(ac,SampleManager.sample(audioFile));
  player.setLoopType(SamplePlayer.LoopType.LOOP_ALTERNATING);
  player.getLoopStartUGen().setValue(0);
  player.getLoopEndUGen().setValue((float)SampleManager.sample(audioFile).getLength());
  Envelope grainIntervalEnvelope=new Envelope(ac,100);
  grainIntervalEnvelope.addSegment(20,10000);
  player.setGrainIntervalUgen(grainIntervalEnvelope);
  Envelope rateEnvelope=new Envelope(ac,1);
  rateEnvelope.addSegment(1,5000);
  rateEnvelope.addSegment(0,5000);
  rateEnvelope.addSegment(0,2000);
  rateEnvelope.addSegment(-0.1f,2000);
  player.setRate(rateEnvelope);
  player.getRandomnessUGen().setValue(0.01f);
  Gain g=new Gain(ac,2,0.2f);
  g.addInput(player);
  ac.out.addInput(g);
  ac.start();
}","public static void main(String[] args){
  AudioContext ac;
  ac=new AudioContext();
  String audioFile=""String_Node_Str"";
  GranularSamplePlayer player=new GranularSamplePlayer(ac,SampleManager.sample(audioFile));
  player.setLoopType(SamplePlayer.LoopType.LOOP_ALTERNATING);
  player.getLoopStartUGen().setValue(0);
  player.getLoopEndUGen().setValue((float)SampleManager.sample(audioFile).getLength());
  Envelope grainIntervalEnvelope=new Envelope(ac,100);
  grainIntervalEnvelope.addSegment(20,10000);
  player.setGrainInterval(grainIntervalEnvelope);
  Envelope rateEnvelope=new Envelope(ac,1);
  rateEnvelope.addSegment(1,5000);
  rateEnvelope.addSegment(0,5000);
  rateEnvelope.addSegment(0,2000);
  rateEnvelope.addSegment(-0.1f,2000);
  player.setRate(rateEnvelope);
  player.getRandomnessUGen().setValue(0.01f);
  Gain g=new Gain(ac,2,0.2f);
  g.addInput(player);
  ac.out.addInput(g);
  ac.start();
}"
52866,"@Override public SRResult similarity(int pageId1,int pageId2,boolean explanations) throws DaoException {
  if (similarityIsTrained()) {
    return new SRResult(0.0);
  }
  CategoryBfs bfs1=new CategoryBfs(graph,pageId1,getLanguage(),Integer.MAX_VALUE,null,catHelper);
  CategoryBfs bfs2=new CategoryBfs(graph,pageId2,getLanguage(),Integer.MAX_VALUE,null,catHelper);
  bfs1.setAddPages(false);
  bfs1.setExploreChildren(false);
  bfs2.setAddPages(false);
  bfs2.setExploreChildren(false);
  double shortestDistance=Double.POSITIVE_INFINITY;
  double maxDist1=0;
  double maxDist2=0;
  while ((bfs1.hasMoreResults() || bfs2.hasMoreResults()) && (maxDist1 + maxDist2 < shortestDistance)) {
    while (bfs1.hasMoreResults() && (maxDist1 <= maxDist2 || !bfs2.hasMoreResults())) {
      CategoryBfs.BfsVisited visited=bfs1.step();
      for (      int catId : visited.cats.keys()) {
        if (bfs2.hasCategoryDistanceForIndex(catId)) {
          double d=bfs1.getCategoryDistanceForIndex(catId) + bfs2.getCategoryDistanceForIndex(catId) - graph.catCosts[catId];
          shortestDistance=Math.min(d,shortestDistance);
        }
      }
      maxDist1=Math.max(maxDist1,visited.maxCatDistance());
    }
    while (bfs2.hasMoreResults() && (maxDist2 <= maxDist1 || !bfs1.hasMoreResults())) {
      CategoryBfs.BfsVisited visited=bfs2.step();
      for (      int catId : visited.cats.keys()) {
        if (bfs1.hasCategoryDistanceForIndex(catId)) {
          double d=bfs1.getCategoryDistanceForIndex(catId) + bfs2.getCategoryDistanceForIndex(catId) + 0 - graph.catCosts[catId];
          shortestDistance=Math.min(d,shortestDistance);
        }
      }
      maxDist2=Math.max(maxDist2,visited.maxCatDistance());
    }
  }
  return new SRResult(distanceToScore(shortestDistance));
}","@Override public SRResult similarity(int pageId1,int pageId2,boolean explanations) throws DaoException {
  if (!similarityIsTrained()) {
    return new SRResult(0.0);
  }
  CategoryBfs bfs1=new CategoryBfs(graph,pageId1,getLanguage(),Integer.MAX_VALUE,null,catHelper);
  CategoryBfs bfs2=new CategoryBfs(graph,pageId2,getLanguage(),Integer.MAX_VALUE,null,catHelper);
  bfs1.setAddPages(false);
  bfs1.setExploreChildren(false);
  bfs2.setAddPages(false);
  bfs2.setExploreChildren(false);
  double shortestDistance=Double.POSITIVE_INFINITY;
  double maxDist1=0;
  double maxDist2=0;
  while ((bfs1.hasMoreResults() || bfs2.hasMoreResults()) && (maxDist1 + maxDist2 < shortestDistance)) {
    while (bfs1.hasMoreResults() && (maxDist1 <= maxDist2 || !bfs2.hasMoreResults())) {
      CategoryBfs.BfsVisited visited=bfs1.step();
      for (      int catId : visited.cats.keys()) {
        if (bfs2.hasCategoryDistanceForIndex(catId)) {
          double d=bfs1.getCategoryDistanceForIndex(catId) + bfs2.getCategoryDistanceForIndex(catId) - graph.catCosts[catId];
          shortestDistance=Math.min(d,shortestDistance);
        }
      }
      maxDist1=Math.max(maxDist1,visited.maxCatDistance());
    }
    while (bfs2.hasMoreResults() && (maxDist2 <= maxDist1 || !bfs1.hasMoreResults())) {
      CategoryBfs.BfsVisited visited=bfs2.step();
      for (      int catId : visited.cats.keys()) {
        if (bfs1.hasCategoryDistanceForIndex(catId)) {
          double d=bfs1.getCategoryDistanceForIndex(catId) + bfs2.getCategoryDistanceForIndex(catId) + 0 - graph.catCosts[catId];
          shortestDistance=Math.min(d,shortestDistance);
        }
      }
      maxDist2=Math.max(maxDist2,visited.maxCatDistance());
    }
  }
  return new SRResult(distanceToScore(shortestDistance));
}"
52867,"/** 
 * Writes out the configuration file.
 */
private void writeConf(){
  try {
    File file=new File(""String_Node_Str"");
    BufferedWriter output=new BufferedWriter(new FileWriter(file));
    output.write(""String_Node_Str"");
    writeHOCONString(output,baseDir.getText());
    if (dataSourceSelection.getSelectedIndex() == 0)     output.write(""String_Node_Str"");
 else     output.write(""String_Node_Str"");
    output.write(""String_Node_Str"");
    writeHOCONString(output,String.format(""String_Node_Str"",h2Path.getText()));
    output.write(""String_Node_Str"");
    writeHOCONString(output,String.format(""String_Node_Str"",postgresHost.getText(),postgresDB.getText()));
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresUser.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresPass.getPassword());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresHost.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresPort.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresDB.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresUser.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresPass.getPassword());
    output.write(""String_Node_Str"");
    output.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Writes out the configuration file.
 */
private void writeConf(){
  try {
    File file=new File(""String_Node_Str"");
    BufferedWriter output=new BufferedWriter(new FileWriter(file));
    output.write(""String_Node_Str"");
    writeHOCONString(output,baseDir.getText());
    if (dataSourceSelection.getSelectedIndex() == 0)     output.write(""String_Node_Str"");
 else     output.write(""String_Node_Str"");
    output.write(""String_Node_Str"");
    writeHOCONString(output,String.format(""String_Node_Str"",h2Path.getText()));
    output.write(""String_Node_Str"");
    writeHOCONString(output,String.format(""String_Node_Str"",postgresHost.getText(),postgresDB.getText()));
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresUser.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,new String(postgresPass.getPassword()));
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresHost.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresPort.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresDB.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresUser.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,new String(postgresPass.getPassword()));
    output.write(""String_Node_Str"");
    output.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
52868,"@Override public SRResult similarity(String phrase1,String phrase2,boolean explanations) throws DaoException {
  double sum=0.0;
  for (  SubMetric m : metrics) {
    SRResult r=m.metric.similarity(phrase1,phrase2,false);
    if (r.isValid()) {
      sum+=m.coefficient * r.getScore();
    }
  }
  return new SRResult(sum);
}","@Override public SRResult similarity(String phrase1,String phrase2,boolean explanations) throws DaoException {
  double sum=0.0;
  double divisor=0.0;
  for (  SubMetric m : metrics) {
    SRResult r=m.metric.similarity(phrase1,phrase2,false);
    if (r != null && r.isValid()) {
      sum+=m.coefficient * r.getScore();
      divisor+=m.coefficient;
    }
  }
  return new SRResult((divisor > 0) ? (sum / divisor) : Double.NaN);
}"
52869,"@Override public Neighborhood query(float[] vector,int k,int maxTraversal,TIntSet validIds){
  if (validIds != null) {
    TIntSet tmp=validIds;
    validIds=new TIntHashSet(tmp.size() * 4);
    tmp.addAll(validIds);
  }
  long vbits[]=new long[2];
  project(vector,vbits);
  long p0=vbits[0];
  long p1=vbits[1];
  int[] numHits=new int[NUM_BITS + 1];
  for (int i=0; i < ids.length; i++) {
    if (validIds != null && !validIds.contains(ids[i]))     continue;
    int nSet=NUM_BITS - Long.bitCount(bits[2 * i] ^ p0) - Long.bitCount(bits[2 * i + 1] ^ p1);
    numHits[nSet]++;
  }
  int threshold;
  int count=0;
  for (threshold=NUM_BITS; threshold > 0; threshold--) {
    count+=numHits[threshold];
    if (count >= maxTraversal) {
      break;
    }
  }
  NeighborhoodAccumulator accum=new NeighborhoodAccumulator(k);
  for (int i=0; i < ids.length; i++) {
    if (validIds != null && !validIds.contains(ids[i]))     continue;
    int nSet=NUM_BITS - Long.bitCount(bits[2 * i] ^ p0) - Long.bitCount(bits[2 * i + 1] ^ p1);
    if (nSet >= threshold) {
      try {
        DenseMatrixRow row=matrix.getRow(ids[i]);
        double sim=KmeansKNNFinder.cosine(vector,row);
        accum.visit(ids[i],sim);
      }
 catch (      IOException e) {
        throw new IllegalStateException(e);
      }
    }
  }
  return accum.get();
}","@Override public Neighborhood query(float[] vector,int k,int maxTraversal,TIntSet validIds){
  if (validIds != null) {
    TIntSet tmp=validIds;
    validIds=new TIntHashSet(tmp.size() * 4);
    validIds.addAll(tmp);
  }
  long vbits[]=new long[2];
  project(vector,vbits);
  long p0=vbits[0];
  long p1=vbits[1];
  int[] numHits=new int[NUM_BITS + 1];
  for (int i=0; i < ids.length; i++) {
    if (validIds != null && !validIds.contains(ids[i]))     continue;
    int nSet=NUM_BITS - Long.bitCount(bits[2 * i] ^ p0) - Long.bitCount(bits[2 * i + 1] ^ p1);
    numHits[nSet]++;
  }
  int threshold;
  int count=0;
  for (threshold=NUM_BITS; threshold > 0; threshold--) {
    count+=numHits[threshold];
    if (count >= maxTraversal) {
      break;
    }
  }
  NeighborhoodAccumulator accum=new NeighborhoodAccumulator(k);
  for (int i=0; i < ids.length; i++) {
    if (validIds != null && !validIds.contains(ids[i]))     continue;
    int nSet=NUM_BITS - Long.bitCount(bits[2 * i] ^ p0) - Long.bitCount(bits[2 * i + 1] ^ p1);
    if (nSet >= threshold) {
      try {
        DenseMatrixRow row=matrix.getRow(ids[i]);
        double sim=KmeansKNNFinder.cosine(vector,row);
        accum.visit(ids[i],sim);
      }
 catch (      IOException e) {
        throw new IllegalStateException(e);
      }
    }
  }
  return accum.get();
}"
52870,"/** 
 * Counts a bigram.
 * @param word
 */
public void countBigram(String word){
  word=word.trim();
  if (word.isEmpty()) {
    return;
  }
  if (containsMentions) {
    Matcher m=PATTERN_MENTION.matcher(word);
    if (m.matches()) {
      word=m.group(1);
    }
  }
synchronized (bigramCounts) {
    bigramCounts.adjustOrPutValue(getHash(word),1,1);
  }
  if (totalBigrams.incrementAndGet() % PRUNE_INTERVAL == 0) {
    pruneIfNecessary();
  }
}","/** 
 * Counts a bigram.
 * @param word
 */
public void countBigram(String word){
  word=word.trim();
  if (word.isEmpty()) {
    return;
  }
  if (containsMentions) {
    Matcher m=PATTERN_MENTION.matcher(word);
    if (m.matches()) {
      word=m.group(1);
    }
  }
  long h=getHash(word);
synchronized (bigramCounts) {
    bigramCounts.adjustOrPutValue(h,1,1);
  }
  if (totalBigrams.incrementAndGet() % PRUNE_INTERVAL == 0) {
    pruneIfNecessary();
  }
}"
52871,"/** 
 * Returns a map of UniversalPages of the specified page type by a collection of universal IDs
 * @param univIds a collection of universal IDs
 * @return a map of universal IDs to UniversalPages
 * @throws DaoException if there was an error retrieving the pages
 */
public Map<Integer,T> getByIds(Collection<Integer> univIds) throws DaoException ;","/** 
 * Returns a map of UniversalPages of the specified page type by a collection of universal IDs
 * @param univIds a collection of universal IDs
 * @return a map of universal IDs to UniversalPages
 * @throws DaoException if there was an error retrieving the pages
 */
public Map<Integer,UniversalPage> getByIds(Collection<Integer> univIds) throws DaoException ;"
52872,"/** 
 * Returns a UniversalPage instance of the specified page type corresponding to the input universal ID
 * @param univId the universal ID to be retrieved
 * @return a UniversalPage
 * @throws DaoException if there was an error retrieving the page
 */
public T getById(int univId) throws DaoException ;","/** 
 * Returns a UniversalPage instance of the specified page type corresponding to the input universal ID
 * @param univId the universal ID to be retrieved
 * @return a UniversalPage
 * @throws DaoException if there was an error retrieving the page
 */
public UniversalPage getById(int univId) throws DaoException ;"
52873,"@Override public Map<Integer,T> getByIds(Collection<Integer> univIds) throws DaoException {
  if (univIds == null || univIds.isEmpty()) {
    return null;
  }
  Map<Integer,T> map=new HashMap<Integer,T>();
  for (  Integer univId : univIds) {
    map.put(univId,getById(univId));
  }
  return map;
}","@Override public Map<Integer,UniversalPage> getByIds(Collection<Integer> univIds) throws DaoException {
  if (univIds == null || univIds.isEmpty()) {
    return null;
  }
  Map<Integer,UniversalPage> map=new HashMap<Integer,UniversalPage>();
  for (  Integer univId : univIds) {
    map.put(univId,getById(univId));
  }
  return map;
}"
52874,"@Override public T transform(int[] item) throws DaoException {
  return getById(item[0]);
}","@Override public UniversalPage transform(int[] item) throws DaoException {
  return getById(item[0]);
}"
52875,"@Override public T getById(int univId) throws DaoException {
  DSLContext context=getJooq();
  try {
    Result<Record> result=context.select().from(Tables.UNIVERSAL_PAGE).where(Tables.UNIVERSAL_PAGE.UNIV_ID.eq(univId)).and(Tables.UNIVERSAL_PAGE.ALGORITHM_ID.eq(algorithmId)).fetch();
    return (T)buildUniversalPage(result);
  }
  finally {
    freeJooq(context);
  }
}","@Override public UniversalPage getById(int univId) throws DaoException {
  DSLContext context=getJooq();
  try {
    Result<Record> result=context.select().from(Tables.UNIVERSAL_PAGE).where(Tables.UNIVERSAL_PAGE.UNIV_ID.eq(univId)).and(Tables.UNIVERSAL_PAGE.ALGORITHM_ID.eq(algorithmId)).fetch();
    return (UniversalPage)buildUniversalPage(result);
  }
  finally {
    freeJooq(context);
  }
}"
52876,"public static void main(String args[]) throws ConfigurationException, ClassNotFoundException, IOException, InterruptedException, SQLException, DaoException {
  try {
    Loader loader=new Loader(args);
    if (!loader.runDiagnostics()) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    System.err.println(""String_Node_Str"");
    Thread.sleep(20000);
    loader.run();
  }
 catch (  ParseException e) {
    usage(""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    usage(""String_Node_Str"",e);
  }
catch (  StageFailedException e) {
    System.err.println(""String_Node_Str"" + e.getStage().getName() + ""String_Node_Str""+ e.getExitCode());
    System.exit(1);
  }
}","public static void main(String args[]) throws ConfigurationException, ClassNotFoundException, IOException, InterruptedException, SQLException, DaoException {
  try {
    Loader loader=new Loader(args);
    if (!loader.runDiagnostics()) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    System.err.println(""String_Node_Str"");
    Thread.sleep(5000);
    System.err.println(""String_Node_Str"");
    Thread.sleep(5000);
    System.err.println(""String_Node_Str"");
    Thread.sleep(5000);
    System.err.println(""String_Node_Str"");
    Thread.sleep(5000);
    loader.run();
  }
 catch (  ParseException e) {
    usage(""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    usage(""String_Node_Str"",e);
  }
catch (  StageFailedException e) {
    System.err.println(""String_Node_Str"" + e.getStage().getName() + ""String_Node_Str""+ e.getExitCode());
    System.exit(1);
  }
}"
52877,"public void runOrStop(){
  if (process != null) {
    process.destroy();
    appendToLog(""String_Node_Str"");
    return;
  }
  String ref=new String();
  String dsSelection;
  if (dataSourceSelection.getSelectedIndex() == 0)   dsSelection=""String_Node_Str"";
 else   dsSelection=""String_Node_Str"";
  Config defaultConf=new Configuration().get();
  ref=defaultConf.toString().substring(defaultConf.toString().indexOf(""String_Node_Str""),defaultConf.toString().lastIndexOf(""String_Node_Str"") + 1);
  JsonParser jp=new JsonParser();
  JsonObject refObj=new JsonObject();
  refObj.addProperty(""String_Node_Str"",baseDir.getText());
  refObj.add(""String_Node_Str"",new JsonObject());
  refObj.add(""String_Node_Str"",new JsonObject());
  refObj.get(""String_Node_Str"").getAsJsonObject().add(""String_Node_Str"",new JsonObject());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().add(""String_Node_Str"",new JsonObject());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().add(""String_Node_Str"",new JsonObject());
  refObj.get(""String_Node_Str"").getAsJsonObject().add(""String_Node_Str"",new JsonObject());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().add(""String_Node_Str"",new JsonObject());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().add(""String_Node_Str"",new JsonObject());
  if (dataSourceSelection.getSelectedIndex() == 0)   refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",""String_Node_Str"");
 else   refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",""String_Node_Str"");
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",String.format(""String_Node_Str"",h2Path.getText()));
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",String.format(""String_Node_Str"",postgresHost.getText(),postgresDB.getText()));
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",postgresUser.getText());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",new String(postgresPass.getPassword()));
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",postgresHost.getText());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",postgresPort.getText());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",postgresDB.getText());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",postgresUser.getText());
  refObj.get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().get(""String_Node_Str"").getAsJsonObject().addProperty(""String_Node_Str"",new String(postgresPass.getPassword()));
  Gson gson=new GsonBuilder().setPrettyPrinting().create();
  ref=gson.toJson(refObj);
  try {
    File file=new File(""String_Node_Str"");
    BufferedWriter output=new BufferedWriter(new FileWriter(file));
    output.write(ref);
    output.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try {
    java.util.List<String> argList=new ArrayList<String>();
    argList.add(""String_Node_Str"");
    argList.add(language.getText());
    if (basicWikipediaButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (luceneButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (phrasesButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (conceptsButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (univeralButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (wikidataButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (spatialButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (srButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    argList.add(""String_Node_Str"");
    argList.add(""String_Node_Str"");
    String arg[]=new String[argList.size()];
    arg=argList.toArray(arg);
    OutputStream out=new PrintStream(new LogOutputStream(System.out),true);
    OutputStream err=new PrintStream(new LogOutputStream(System.err),true);
    runLog.setText(""String_Node_Str"" + StringUtils.join(arg,""String_Node_Str"") + ""String_Node_Str"");
    runButton.setText(""String_Node_Str"");
    runButton.setBackground(Color.RED);
    defaultButton.setEnabled(false);
    this.process=JvmUtils.launch(org.wikibrain.Loader.class,arg,out,err,heapSize.getText());
    final Timer timer=new Timer();
    timer.schedule(new TimerTask(){
      @Override public void run(){
        if (checkIfProcessHasFinished()) {
          timer.cancel();
        }
      }
    }
,1000,100);
  }
 catch (  Exception e) {
    runLog.append(""String_Node_Str"");
    runLog.append(ExceptionUtils.getFullStackTrace(e));
    e.printStackTrace();
  }
}","public void runOrStop(){
  if (process != null) {
    process.destroy();
    appendToLog(""String_Node_Str"");
    return;
  }
  try {
    File file=new File(""String_Node_Str"");
    BufferedWriter output=new BufferedWriter(new FileWriter(file));
    output.write(""String_Node_Str"");
    writeHOCONString(output,baseDir.getText());
    if (dataSourceSelection.getSelectedIndex() == 0)     output.write(""String_Node_Str"");
 else     output.write(""String_Node_Str"");
    output.write(""String_Node_Str"");
    writeHOCONString(output,String.format(""String_Node_Str"",h2Path.getText()));
    output.write(""String_Node_Str"");
    writeHOCONString(output,String.format(""String_Node_Str"",postgresHost.getText(),postgresDB.getText()));
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresUser.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresPass.getPassword());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresHost.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresPort.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresDB.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresUser.getText());
    output.write(""String_Node_Str"");
    writeHOCONString(output,postgresPass.getPassword());
    output.write(""String_Node_Str"");
    output.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try {
    java.util.List<String> argList=new ArrayList<String>();
    argList.add(""String_Node_Str"");
    argList.add(language.getText());
    if (basicWikipediaButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (luceneButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (phrasesButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (conceptsButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (univeralButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (wikidataButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (spatialButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    if (srButton.isSelected()) {
      argList.add(""String_Node_Str"");
      argList.add(""String_Node_Str"");
    }
    argList.add(""String_Node_Str"");
    argList.add(""String_Node_Str"");
    String arg[]=new String[argList.size()];
    arg=argList.toArray(arg);
    OutputStream out=new PrintStream(new LogOutputStream(System.out),true);
    OutputStream err=new PrintStream(new LogOutputStream(System.err),true);
    runLog.setText(""String_Node_Str"" + StringUtils.join(arg,""String_Node_Str"") + ""String_Node_Str"");
    runButton.setText(""String_Node_Str"");
    runButton.setBackground(Color.RED);
    defaultButton.setEnabled(false);
    this.process=JvmUtils.launch(org.wikibrain.Loader.class,arg,out,err,heapSize.getText());
    final Timer timer=new Timer();
    timer.schedule(new TimerTask(){
      @Override public void run(){
        if (checkIfProcessHasFinished()) {
          timer.cancel();
        }
      }
    }
,1000,100);
  }
 catch (  Exception e) {
    runLog.append(""String_Node_Str"");
    runLog.append(ExceptionUtils.getFullStackTrace(e));
    e.printStackTrace();
  }
}"
52878,"public static void main(String args[]) throws ConfigurationException, DaoException {
  Env env=EnvBuilder.envFromArgs(args);
  PageViewDao viewDao=env.getConfigurator().get(PageViewDao.class);
  SpatialDataDao spatialDao=env.getConfigurator().get(SpatialDataDao.class);
  UniversalPageDao conceptDao=env.getConfigurator().get(UniversalPageDao.class);
  LocalPageDao pageDao=env.getConfigurator().get(LocalPageDao.class);
  Language lang=env.getDefaultLanguage();
  DateTime start=new DateTime(2014,8,14,21,0,0);
  DateTime end=new DateTime(2014,8,14,23,0,0);
  viewDao.ensureLoaded(start,end,env.getLanguages());
  Map<Integer,Geometry> countries=spatialDao.getAllGeometriesInLayer(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + countries.size() + ""String_Node_Str"");
  for (  int conceptId : countries.keySet()) {
    int pageId=conceptDao.getById(conceptId).getLocalId(lang);
    if (pageId > 0) {
      LocalPage page=pageDao.getById(lang,pageId);
      System.out.println(""String_Node_Str"" + countries);
    }
  }
}","public static void main(String args[]) throws ConfigurationException, DaoException {
  Env env=EnvBuilder.envFromArgs(args);
  PageViewDao viewDao=env.getConfigurator().get(PageViewDao.class);
  SpatialDataDao spatialDao=env.getConfigurator().get(SpatialDataDao.class);
  UniversalPageDao conceptDao=env.getConfigurator().get(UniversalPageDao.class);
  LocalPageDao pageDao=env.getConfigurator().get(LocalPageDao.class);
  Language lang=env.getDefaultLanguage();
  DateTime start=new DateTime(2014,8,14,21,0,0);
  DateTime end=new DateTime(2014,8,14,23,0,0);
  viewDao.ensureLoaded(start,end,env.getLanguages());
  Map<Integer,Geometry> countries=spatialDao.getAllGeometriesInLayer(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + countries.size() + ""String_Node_Str"");
  Map<LocalPage,Integer> countryViews=new HashMap<LocalPage,Integer>();
  for (  int conceptId : countries.keySet()) {
    int pageId=conceptDao.getById(conceptId).getLocalId(lang);
    if (pageId > 0) {
      LocalPage page=pageDao.getById(lang,pageId);
      int views=viewDao.getNumViews(page.toLocalId(),start,end);
      countryViews.put(page,views);
    }
  }
  for (  LocalPage page : WpCollectionUtils.sortMapKeys(countryViews,true)) {
    System.out.format(""String_Node_Str"",page.getTitle(),countryViews.get(page));
  }
}"
52879,"/** 
 * Returns the total number of views for the requested page.
 * @param lang
 * @param ids
 * @param dates
 * @return
 * @throws ConfigurationException
 * @throws DaoException
 * @throws WikiBrainException
 */
public Map<Integer,Integer> getNumViews(Language lang,Iterable<Integer> ids,ArrayList<DateTime[]> dates) throws ConfigurationException, DaoException, WikiBrainException ;","/** 
 * Returns the total number of views for the requested page.
 * @param lang
 * @param ids
 * @param dates
 * @return
 * @throws ConfigurationException
 * @throws DaoException
 * @throws WikiBrainException
 */
public Map<Integer,Integer> getNumViews(Language lang,Iterable<Integer> ids,ArrayList<DateTime[]> dates) throws ConfigurationException, DaoException ;"
52880,"@Override public Map<Integer,Integer> getNumViews(Language lang,Iterable<Integer> ids,ArrayList<DateTime[]> dates) throws ConfigurationException, DaoException, WikiBrainException {
  Map<Integer,Integer> result=new HashMap<Integer,Integer>();
  DateTime startTime;
  DateTime endTime;
  int count=0;
  for (  DateTime[] date : dates) {
    startTime=date[0];
    endTime=date[1];
    count++;
    for (    Integer id : ids) {
      if (!result.keySet().contains(id)) {
        result.put(id,getNumViews(new LocalId(lang,id),startTime,endTime));
      }
 else {
        int totalViews=result.get(id) + getNumViews(new LocalId(lang,id),startTime,endTime);
        result.put(id,totalViews);
      }
    }
    LOG.info(count + ""String_Node_Str"");
  }
  return result;
}","@Override public Map<Integer,Integer> getNumViews(Language lang,Iterable<Integer> ids,ArrayList<DateTime[]> dates) throws ConfigurationException, DaoException {
  Map<Integer,Integer> result=new HashMap<Integer,Integer>();
  DateTime startTime;
  DateTime endTime;
  int count=0;
  for (  DateTime[] date : dates) {
    startTime=date[0];
    endTime=date[1];
    count++;
    for (    Integer id : ids) {
      if (!result.keySet().contains(id)) {
        result.put(id,getNumViews(new LocalId(lang,id),startTime,endTime));
      }
 else {
        int totalViews=result.get(id) + getNumViews(new LocalId(lang,id),startTime,endTime);
        result.put(id,totalViews);
      }
    }
    LOG.info(count + ""String_Node_Str"");
  }
  return result;
}"
52881,"public void downloadMapping(URL mappingUrl,WikiBrainShapeFile shapeFile) throws IOException, InterruptedException {
  File dest=shapeFile.getMappingFile();
  File tmp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  FileUtils.deleteQuietly(tmp);
  if (!tmp.isFile()) {
    FileDownloader downloader=new FileDownloader();
    downloader.download(mappingUrl,tmp);
  }
  FileUtils.forceDeleteOnExit(tmp);
  File tmpDir;
  try {
    ZipFile zipFile=new ZipFile(tmp.getCanonicalPath());
    tmpDir=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    FileUtils.deleteQuietly(tmpDir);
    FileUtils.forceMkdir(tmpDir);
    LOG.log(Level.INFO,""String_Node_Str"" + mappingUrl + ""String_Node_Str""+ tmpDir);
    zipFile.extractAll(tmpDir.getAbsolutePath());
    FileUtils.forceDeleteOnExit(tmpDir);
  }
 catch (  ZipException e) {
    throw new IOException(e);
  }
  File src=FileUtils.getFile(tmpDir,dest.getName());
  if (!src.isFile()) {
    throw new IOException(""String_Node_Str"" + dest.getName() + ""String_Node_Str""+ mappingUrl);
  }
  FileUtils.forceDelete(dest);
  FileUtils.moveFile(src,dest);
}","public void downloadMapping(URL mappingUrl,WikiBrainShapeFile shapeFile) throws IOException, InterruptedException {
  File dest=shapeFile.getMappingFile();
  File tmp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  FileUtils.deleteQuietly(tmp);
  if (!tmp.isFile()) {
    FileDownloader downloader=new FileDownloader();
    downloader.download(mappingUrl,tmp);
  }
  FileUtils.forceDeleteOnExit(tmp);
  File tmpDir;
  try {
    ZipFile zipFile=new ZipFile(tmp.getCanonicalPath());
    tmpDir=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    FileUtils.deleteQuietly(tmpDir);
    FileUtils.forceMkdir(tmpDir);
    LOG.log(Level.INFO,""String_Node_Str"" + mappingUrl + ""String_Node_Str""+ tmpDir);
    zipFile.extractAll(tmpDir.getAbsolutePath());
    FileUtils.forceDeleteOnExit(tmpDir);
  }
 catch (  ZipException e) {
    throw new IOException(e);
  }
  File src=FileUtils.getFile(tmpDir,dest.getName());
  if (!src.isFile()) {
    throw new IOException(""String_Node_Str"" + dest.getName() + ""String_Node_Str""+ mappingUrl);
  }
  FileUtils.deleteQuietly(dest);
  FileUtils.moveFile(src,dest);
}"
52882,"public synchronized int incrementNumRecords(int n){
  lastUpdated=new Date();
  numRecords+=n;
  return n;
}","public synchronized int incrementNumRecords(int n){
  lastUpdated=new Date();
  numRecords+=n;
  return numRecords;
}"
52883,"private void initialize(Map<String,Object> manualParameters) throws DaoException {
  try {
    store=(JDBCDataStore)DataStoreFinder.getDataStore(manualParameters);
    if (needsToBeInitialized()) {
      LOG.log(Level.INFO,""String_Node_Str"");
      try {
        SimpleFeatureTypeBuilder builder=new SimpleFeatureTypeBuilder();
        builder.setName(SPATIAL_DB_NAME);
        builder.add(ITEM_ID_FIELD_NAME,Integer.class);
        builder.add(LAYER_FIELD_NAME,String.class);
        builder.add(REF_SYS_FIELD_NAME,String.class);
        builder.add(GEOM_FIELD_NAME,Geometry.class);
        SimpleFeatureType featureType=builder.buildFeatureType();
        store.createSchema(featureType);
        Index regIndex=new Index(SPATIAL_DB_NAME,""String_Node_Str"",true,ITEM_ID_FIELD_NAME,LAYER_FIELD_NAME,REF_SYS_FIELD_NAME);
      }
 catch (      Exception e) {
        throw new DaoException(e);
      }
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new DaoException(e);
  }
}","private void initialize(Map<String,Object> manualParameters) throws DaoException {
  try {
    store=(JDBCDataStore)DataStoreFinder.getDataStore(manualParameters);
    if (needsToBeInitialized()) {
      LOG.log(Level.INFO,""String_Node_Str"");
      try {
        SimpleFeatureTypeBuilder builder=new SimpleFeatureTypeBuilder();
        builder.setName(SPATIAL_DB_NAME);
        builder.add(ITEM_ID_FIELD_NAME,Integer.class);
        builder.add(LAYER_FIELD_NAME,String.class);
        builder.add(REF_SYS_FIELD_NAME,String.class);
        builder.add(GEOM_FIELD_NAME,Geometry.class);
        SimpleFeatureType featureType=builder.buildFeatureType();
        store.createSchema(featureType);
        Index regIndex=new Index(SPATIAL_DB_NAME,""String_Node_Str"",true,ITEM_ID_FIELD_NAME,LAYER_FIELD_NAME,REF_SYS_FIELD_NAME);
        Index itemIdIndex=new Index(SPATIAL_DB_NAME,""String_Node_Str"",false,ITEM_ID_FIELD_NAME);
        store.createIndex(itemIdIndex);
      }
 catch (      Exception e) {
        throw new DaoException(e);
      }
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new DaoException(e);
  }
}"
52884,"@Override public MetaInfo getInfo(Class component,Language lang) throws DaoException {
  Map<Language,MetaInfo> langInfos=counters.get(component);
  if (langInfos == null) {
synchronized (counters) {
      if (!counters.containsKey(component)) {
        langInfos=new ConcurrentHashMap<Language,MetaInfo>();
        counters.put(component,langInfos);
      }
 else {
        langInfos=counters.get(component);
      }
    }
  }
  Object langKey=(lang == null ? NULL_KEY : lang);
  MetaInfo info=langInfos.get(langKey);
  if (info == null) {
synchronized (langInfos) {
      if (langInfos.containsKey(langKey)) {
        info=langInfos.get(langKey);
      }
 else {
        DSLContext context=getJooq();
        try {
          if (!tableExists(context)) {
            return new MetaInfo(component,lang);
          }
          Condition langCondition=(lang == null) ? Tables.META_INFO.LANG_ID.isNull() : Tables.META_INFO.LANG_ID.eq(lang.getId());
          Record3<Integer,Integer,Timestamp> record=context.select(Tables.META_INFO.NUM_RECORDS,Tables.META_INFO.NUM_ERRORS,Tables.META_INFO.LAST_UPDATED).from(Tables.META_INFO).where(Tables.META_INFO.COMPONENT.eq(component.getSimpleName())).and(langCondition).fetchOne();
          if (record == null) {
            info=new MetaInfo(component,lang);
          }
 else {
            info=new MetaInfo(component,lang,record.value1(),record.value2(),record.value3());
          }
        }
  finally {
          freeJooq(context);
        }
        ((Map)langInfos).put(langKey,info);
      }
    }
  }
  return info;
}","@Override public MetaInfo getInfo(Class component,Language lang) throws DaoException {
  counters.putIfAbsent(component,new ConcurrentHashMap<Language,MetaInfo>());
  Map<Language,MetaInfo> langInfos=counters.get(component);
  if (langInfos == null) {
    throw new IllegalStateException();
  }
  Object langKey=(lang == null ? NULL_KEY : lang);
  MetaInfo info=langInfos.get(langKey);
  if (info == null) {
synchronized (langInfos) {
      if (langInfos.containsKey(langKey)) {
        info=langInfos.get(langKey);
      }
 else {
        DSLContext context=getJooq();
        try {
          if (!tableExists(context)) {
            info=new MetaInfo(component,lang);
          }
 else {
            Condition langCondition=(lang == null) ? Tables.META_INFO.LANG_ID.isNull() : Tables.META_INFO.LANG_ID.eq(lang.getId());
            Record3<Integer,Integer,Timestamp> record=context.select(Tables.META_INFO.NUM_RECORDS,Tables.META_INFO.NUM_ERRORS,Tables.META_INFO.LAST_UPDATED).from(Tables.META_INFO).where(Tables.META_INFO.COMPONENT.eq(component.getSimpleName())).and(langCondition).fetchOne();
            if (record == null) {
              info=new MetaInfo(component,lang);
            }
 else {
              info=new MetaInfo(component,lang,record.value1(),record.value2(),record.value3());
            }
          }
        }
  finally {
          freeJooq(context);
        }
        ((Map)langInfos).put(langKey,info);
      }
    }
  }
  return info;
}"
52885,"@Override public LanguageSet getLoadedLanguages(Class component) throws DaoException {
  sync(component);
  DSLContext context=getJooq();
  try {
    Set<Language> langs=new HashSet<Language>();
    Result<Record1<Short>> records=context.select(Tables.META_INFO.LANG_ID).from(Tables.META_INFO).where(Tables.META_INFO.COMPONENT.eq(component.getSimpleName())).and(Tables.META_INFO.LANG_ID.isNotNull()).fetch();
    for (    Record1<Short> record : records) {
      langs.add(Language.getById(record.value1()));
    }
    return new LanguageSet(langs);
  }
 catch (  Exception e) {
    throw new DaoException(""String_Node_Str"" + e.toString());
  }
 finally {
    freeJooq(context);
  }
}","@Override public LanguageSet getLoadedLanguages(Class component) throws DaoException {
  sync(component);
  DSLContext context=getJooq();
  try {
    if (!tableExists(context)) {
      return new LanguageSet();
    }
    Set<Language> langs=new HashSet<Language>();
    Result<Record1<Short>> records=context.select(Tables.META_INFO.LANG_ID).from(Tables.META_INFO).where(Tables.META_INFO.COMPONENT.eq(component.getSimpleName())).and(Tables.META_INFO.LANG_ID.isNotNull()).fetch();
    for (    Record1<Short> record : records) {
      langs.add(Language.getById(record.value1()));
    }
    return new LanguageSet(langs);
  }
 catch (  Exception e) {
    throw new DaoException(""String_Node_Str"" + e.toString());
  }
 finally {
    freeJooq(context);
  }
}"
52886,"@Override public MetaInfo getInfo(Class component,Language lang) throws DaoException {
  Map<Language,MetaInfo> langInfos=counters.get(component);
  if (langInfos == null) {
synchronized (counters) {
      if (!counters.containsKey(component)) {
        langInfos=new ConcurrentHashMap<Language,MetaInfo>();
        counters.put(component,langInfos);
      }
 else {
        langInfos=counters.get(component);
      }
    }
  }
  Object langKey=(lang == null ? NULL_KEY : lang);
  MetaInfo info=langInfos.get(langKey);
  if (info == null) {
synchronized (langInfos) {
      if (langInfos.containsKey(langKey)) {
        info=langInfos.get(langKey);
      }
 else {
        DSLContext context=getJooq();
        try {
          Condition langCondition=(lang == null) ? Tables.META_INFO.LANG_ID.isNull() : Tables.META_INFO.LANG_ID.eq(lang.getId());
          Record3<Integer,Integer,Timestamp> record=context.select(Tables.META_INFO.NUM_RECORDS,Tables.META_INFO.NUM_ERRORS,Tables.META_INFO.LAST_UPDATED).from(Tables.META_INFO).where(Tables.META_INFO.COMPONENT.eq(component.getSimpleName())).and(langCondition).fetchOne();
          if (record == null) {
            info=new MetaInfo(component,lang);
          }
 else {
            info=new MetaInfo(component,lang,record.value1(),record.value2(),record.value3());
          }
        }
  finally {
          freeJooq(context);
        }
        ((Map)langInfos).put(langKey,info);
      }
    }
  }
  return info;
}","@Override public MetaInfo getInfo(Class component,Language lang) throws DaoException {
  Map<Language,MetaInfo> langInfos=counters.get(component);
  if (langInfos == null) {
synchronized (counters) {
      if (!counters.containsKey(component)) {
        langInfos=new ConcurrentHashMap<Language,MetaInfo>();
        counters.put(component,langInfos);
      }
 else {
        langInfos=counters.get(component);
      }
    }
  }
  Object langKey=(lang == null ? NULL_KEY : lang);
  MetaInfo info=langInfos.get(langKey);
  if (info == null) {
synchronized (langInfos) {
      if (langInfos.containsKey(langKey)) {
        info=langInfos.get(langKey);
      }
 else {
        DSLContext context=getJooq();
        try {
          if (!tableExists(context)) {
            return new MetaInfo(component,lang);
          }
          Condition langCondition=(lang == null) ? Tables.META_INFO.LANG_ID.isNull() : Tables.META_INFO.LANG_ID.eq(lang.getId());
          Record3<Integer,Integer,Timestamp> record=context.select(Tables.META_INFO.NUM_RECORDS,Tables.META_INFO.NUM_ERRORS,Tables.META_INFO.LAST_UPDATED).from(Tables.META_INFO).where(Tables.META_INFO.COMPONENT.eq(component.getSimpleName())).and(langCondition).fetchOne();
          if (record == null) {
            info=new MetaInfo(component,lang);
          }
 else {
            info=new MetaInfo(component,lang,record.value1(),record.value2(),record.value3());
          }
        }
  finally {
          freeJooq(context);
        }
        ((Map)langInfos).put(langKey,info);
      }
    }
  }
  return info;
}"
52887,"public boolean tableExists() throws DaoException {
  DSLContext context=getJooq();
  try {
    return (context.meta().getTables().contains(Tables.META_INFO));
  }
  finally {
    freeJooq(context);
  }
}","public boolean tableExists(DSLContext context){
  return JooqUtils.tableExists(context,Tables.META_INFO);
}"
52888,"@Override public Map<String,List<MetaInfo>> getAllInfo() throws DaoException {
  DSLContext context=getJooq();
  try {
    Result<Record> result=context.select().from(Tables.META_INFO).fetch();
    Map<String,List<MetaInfo>> components=new HashMap<String,List<MetaInfo>>();
    for (    Record record : result) {
      String klass=record.getValue(Tables.META_INFO.COMPONENT);
      if (!components.containsKey(klass)) {
        components.put(klass,new ArrayList<MetaInfo>());
      }
      Short langId=record.getValue(Tables.META_INFO.LANG_ID);
      components.get(klass).add(new MetaInfo(null,(langId == null) ? null : Language.getById(langId),record.getValue(Tables.META_INFO.ID),record.getValue(Tables.META_INFO.NUM_RECORDS),record.getValue(Tables.META_INFO.NUM_ERRORS),record.getValue(Tables.META_INFO.LAST_UPDATED)));
    }
    return components;
  }
  finally {
    freeJooq(context);
  }
}","@Override public Map<String,List<MetaInfo>> getAllInfo() throws DaoException {
  DSLContext context=getJooq();
  try {
    Map<String,List<MetaInfo>> components=new HashMap<String,List<MetaInfo>>();
    if (!tableExists(context)) {
      return components;
    }
    Result<Record> result=context.select().from(Tables.META_INFO).fetch();
    for (    Record record : result) {
      String klass=record.getValue(Tables.META_INFO.COMPONENT);
      if (!components.containsKey(klass)) {
        components.put(klass,new ArrayList<MetaInfo>());
      }
      Short langId=record.getValue(Tables.META_INFO.LANG_ID);
      components.get(klass).add(new MetaInfo(null,(langId == null) ? null : Language.getById(langId),record.getValue(Tables.META_INFO.ID),record.getValue(Tables.META_INFO.NUM_RECORDS),record.getValue(Tables.META_INFO.NUM_ERRORS),record.getValue(Tables.META_INFO.LAST_UPDATED)));
    }
    return components;
  }
  finally {
    freeJooq(context);
  }
}"
52889,"@Override public Map<String,MetaInfo> getAllCummulativeInfo() throws DaoException {
  sync();
  DSLContext context=getJooq();
  try {
    Result<Record> result=context.select().from(Tables.META_INFO).fetch();
    Map<String,MetaInfo> components=new HashMap<String,MetaInfo>();
    for (    Record record : result) {
      String className=record.getValue(Tables.META_INFO.COMPONENT);
      Class klass=JvmUtils.classForShortName(className);
      if (klass == null) {
        throw new DaoException(""String_Node_Str"" + className);
      }
      if (!components.containsKey(className)) {
        components.put(className,new MetaInfo(klass));
      }
      Short langId=record.getValue(Tables.META_INFO.LANG_ID);
      components.get(className).merge(new MetaInfo(klass,(langId == null) ? null : Language.getById(langId),record.getValue(Tables.META_INFO.ID),record.getValue(Tables.META_INFO.NUM_RECORDS),record.getValue(Tables.META_INFO.NUM_ERRORS),record.getValue(Tables.META_INFO.LAST_UPDATED)));
    }
    return components;
  }
  finally {
    freeJooq(context);
  }
}","@Override public Map<String,MetaInfo> getAllCummulativeInfo() throws DaoException {
  sync();
  DSLContext context=getJooq();
  try {
    Map<String,MetaInfo> components=new HashMap<String,MetaInfo>();
    if (!tableExists(context)) {
      return components;
    }
    Result<Record> result=context.select().from(Tables.META_INFO).fetch();
    for (    Record record : result) {
      String className=record.getValue(Tables.META_INFO.COMPONENT);
      Class klass=JvmUtils.classForShortName(className);
      if (klass == null) {
        throw new DaoException(""String_Node_Str"" + className);
      }
      if (!components.containsKey(className)) {
        components.put(className,new MetaInfo(klass));
      }
      Short langId=record.getValue(Tables.META_INFO.LANG_ID);
      components.get(className).merge(new MetaInfo(klass,(langId == null) ? null : Language.getById(langId),record.getValue(Tables.META_INFO.ID),record.getValue(Tables.META_INFO.NUM_RECORDS),record.getValue(Tables.META_INFO.NUM_ERRORS),record.getValue(Tables.META_INFO.LAST_UPDATED)));
    }
    return components;
  }
  finally {
    freeJooq(context);
  }
}"
52890,"private List<SimpleFeature> inputFeatureHandler(SimpleFeatureCollection inputCollection,String featureName,int level,SimpleFeatureType outputFeatureType,Multimap<String,String> relation){
  GeometryFactory geometryFactory=JTSFactoryFinder.getGeometryFactory();
  List<Geometry> geometryList=new ArrayList<Geometry>();
  SimpleFeatureIterator inputFeatures=inputCollection.features();
  SimpleFeatureBuilder featureBuilder=new SimpleFeatureBuilder(outputFeatureType);
  Multimap<String,String> reverted=ArrayListMultimap.create();
  Geometry newGeom=null;
  String country;
  if (!exceptionList.contains(featureName)) {
    if (level == 1) {
      country=(String)Multimaps.invertFrom(relation,reverted).get(featureName).toArray()[0];
synchronized (this) {
        LOG.log(Level.INFO,""String_Node_Str"" + featureName + ""String_Node_Str""+ country+ ""String_Node_Str""+ countryCount.incrementAndGet()+ ""String_Node_Str""+ relation.keySet().size()+ ""String_Node_Str"");
      }
    }
 else {
      country=featureName;
synchronized (this) {
        LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ countryCount.incrementAndGet()+ ""String_Node_Str""+ relation.keySet().size()+ ""String_Node_Str"");
      }
    }
  }
  if (level == 1) {
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      if (feature.getAttribute(6).equals(featureName))       geometryList.add((Geometry)feature.getAttribute(0));
    }
  }
 else {
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      if (((String)feature.getAttribute(2)).split(""String_Node_Str"")[1].trim().equals(featureName))       geometryList.add((Geometry)feature.getAttribute(0));
    }
  }
  inputFeatures.close();
  try {
    newGeom=geometryFactory.buildGeometry(geometryList).union().getBoundary();
  }
 catch (  Exception e) {
    LOG.log(Level.INFO,""String_Node_Str"" + featureName + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
    newGeom=geometryFactory.buildGeometry(geometryList).buffer(0);
  }
  featureBuilder.add(newGeom);
  if (level == 1) {
    featureBuilder.add(featureName);
    featureBuilder.add(featureName + ""String_Node_Str"" + Multimaps.invertFrom(relation,reverted).get(featureName).toArray()[0]);
  }
 else   featureBuilder.add(featureName);
  SimpleFeature feature=featureBuilder.buildFeature(null);
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  features.add(feature);
  return features;
}","private List<SimpleFeature> inputFeatureHandler(SimpleFeatureCollection inputCollection,String featureName,int level,SimpleFeatureType outputFeatureType,Multimap<String,String> relation){
  GeometryFactory geometryFactory=JTSFactoryFinder.getGeometryFactory();
  List<Geometry> geometryList=new ArrayList<Geometry>();
  SimpleFeatureIterator inputFeatures=inputCollection.features();
  SimpleFeatureBuilder featureBuilder=new SimpleFeatureBuilder(outputFeatureType);
  Multimap<String,String> reverted=ArrayListMultimap.create();
  Geometry newGeom=null;
  String country;
  reverted=Multimaps.invertFrom(relation,reverted);
  if (!exceptionList.contains(featureName)) {
    if (level == 1) {
      country=(String)reverted.get(featureName).toArray()[0];
synchronized (this) {
        LOG.log(Level.INFO,""String_Node_Str"" + featureName + ""String_Node_Str""+ country+ ""String_Node_Str""+ countryCount.incrementAndGet()+ ""String_Node_Str""+ reverted.keySet().size()+ ""String_Node_Str"");
      }
    }
 else {
      country=featureName;
synchronized (this) {
        LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ countryCount.incrementAndGet()+ ""String_Node_Str""+ relation.keySet().size()+ ""String_Node_Str"");
      }
    }
  }
  if (level == 1) {
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      if (feature.getAttribute(6).equals(featureName))       geometryList.add((Geometry)feature.getAttribute(0));
    }
  }
 else {
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      if (((String)feature.getAttribute(2)).replace(feature.getAttribute(1) + ""String_Node_Str"",""String_Node_Str"").equals(featureName))       geometryList.add((Geometry)feature.getAttribute(0));
    }
  }
  inputFeatures.close();
  try {
    newGeom=geometryFactory.buildGeometry(geometryList).union().getBoundary();
  }
 catch (  Exception e) {
    LOG.log(Level.INFO,""String_Node_Str"" + featureName + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
    newGeom=geometryFactory.buildGeometry(geometryList).buffer(0);
  }
  featureBuilder.add(newGeom);
  if (level == 1) {
    featureBuilder.add(featureName);
    featureBuilder.add(featureName + ""String_Node_Str"" + reverted.get(featureName).toArray()[0]);
  }
 else   featureBuilder.add(featureName);
  SimpleFeature feature=featureBuilder.buildFeature(null);
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  features.add(feature);
  return features;
}"
52891,"@Override public void call(String country) throws Exception {
  countInc();
  List<SimpleFeature> features=inputFeatureHandler(inputCollection,country,0,WIKITYPE,countryState);
  writeQueue.push(features);
  writeToShpFile(outputFeatureSource,WIKITYPE,transaction,writeQueue.pop());
  ;
}","@Override public void call(String country) throws Exception {
  countInc();
  List<SimpleFeature> features=inputFeatureHandler(inputCollection,country,0,WIKITYPE,countryState);
  writeQueue.add(features);
  writeToShpFile(outputFeatureSource,WIKITYPE,transaction,writeQueue.poll());
  ;
}"
52892,"/** 
 * @param outputFolder
 * @param level        //TODO: reduce memory usageConverts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException, WikiBrainException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str""+ level+ ""String_Node_Str"");
  ListMultimap<String,String> countryStatePair=ArrayListMultimap.create();
  final SimpleFeatureType WIKITYPE=getOutputFeatureType(level);
  final SimpleFeatureSource outputFeatureSource=getOutputDataFeatureSource(outputFile,WIKITYPE);
  final Transaction transaction=new DefaultTransaction(""String_Node_Str"");
  final SimpleFeatureCollection inputCollection=getInputCollection(rawFile);
  SimpleFeatureIterator inputFeatures=inputCollection.features();
  final ConcurrentLinkedDeque<List<SimpleFeature>> writeQueue=new ConcurrentLinkedDeque<List<SimpleFeature>>();
  try {
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      String country=((String)feature.getAttribute(4)).intern();
      String state=((String)feature.getAttribute(6)).intern();
      if (!countryStatePair.containsEntry(country,state))       countryStatePair.put(country,state);
    }
    final Multimap<String,String> countryState=countryStatePair;
    inputFeatures.close();
    LOG.log(Level.INFO,""String_Node_Str"" + level + ""String_Node_Str"");
    if (level == 1) {
      for (      String country : countryState.keySet()) {
        countInc();
        ParallelForEach.loop(countryState.get(country),new Procedure<String>(){
          @Override public void call(          String state) throws Exception {
            List<SimpleFeature> features=inputFeatureHandler(inputCollection,state,1,WIKITYPE,countryState);
            writeQueue.push(features);
            writeToShpFile(outputFeatureSource,WIKITYPE,transaction,writeQueue.pop());
          }
        }
);
      }
    }
 else {
      ParallelForEach.loop(countryState.keySet(),new Procedure<String>(){
        @Override public void call(        String country) throws Exception {
          countInc();
          List<SimpleFeature> features=inputFeatureHandler(inputCollection,country,0,WIKITYPE,countryState);
          writeQueue.push(features);
          writeToShpFile(outputFeatureSource,WIKITYPE,transaction,writeQueue.pop());
          ;
        }
      }
);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    transaction.close();
    outputFolder.deleteSpecificFile(""String_Node_Str"",RefSys.EARTH);
    outputFolder.deleteLayer(""String_Node_Str"",RefSys.EARTH);
  }
}","/** 
 * @param outputFolder
 * @param level        //TODO: reduce memory usageConverts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException, WikiBrainException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str""+ level+ ""String_Node_Str"");
  ListMultimap<String,String> countryStatePair=ArrayListMultimap.create();
  final SimpleFeatureType WIKITYPE=getOutputFeatureType(level);
  final SimpleFeatureSource outputFeatureSource=getOutputDataFeatureSource(outputFile,WIKITYPE);
  final Transaction transaction=new DefaultTransaction(""String_Node_Str"");
  final SimpleFeatureCollection inputCollection=getInputCollection(rawFile);
  SimpleFeatureIterator inputFeatures=inputCollection.features();
  final ConcurrentLinkedQueue<List<SimpleFeature>> writeQueue=new ConcurrentLinkedQueue<List<SimpleFeature>>();
  try {
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      String country=((String)feature.getAttribute(4)).intern();
      String state=((String)feature.getAttribute(6)).intern();
      if (!countryStatePair.containsEntry(country,state))       countryStatePair.put(country,state);
    }
    final Multimap<String,String> countryState=countryStatePair;
    inputFeatures.close();
    LOG.log(Level.INFO,""String_Node_Str"" + level + ""String_Node_Str"");
    if (level == 1) {
      for (      String country : countryState.keySet()) {
        countInc();
        ParallelForEach.loop(countryState.get(country),new Procedure<String>(){
          @Override public void call(          String state) throws Exception {
            List<SimpleFeature> features=inputFeatureHandler(inputCollection,state,1,WIKITYPE,countryState);
            writeQueue.add(features);
            writeToShpFile(outputFeatureSource,WIKITYPE,transaction,writeQueue.poll());
          }
        }
);
      }
    }
 else {
      ParallelForEach.loop(countryState.keySet(),new Procedure<String>(){
        @Override public void call(        String country) throws Exception {
          countInc();
          List<SimpleFeature> features=inputFeatureHandler(inputCollection,country,0,WIKITYPE,countryState);
          writeQueue.add(features);
          writeToShpFile(outputFeatureSource,WIKITYPE,transaction,writeQueue.poll());
          ;
        }
      }
);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    transaction.close();
    outputFolder.deleteSpecificFile(""String_Node_Str"",RefSys.EARTH);
    outputFolder.deleteLayer(""String_Node_Str"",RefSys.EARTH);
  }
}"
52893,"public static void downloadAndConvert(SpatialDataFolder folder) throws WikiBrainException {
  try {
    WpIOUtils ioUtils=new WpIOUtils();
    String tmpFolderName=""String_Node_Str"";
    File tmpFolder=WpIOUtils.createTempDirectory(tmpFolderName,true);
    File rawFile=downloadGADMShapeFile(tmpFolder.getCanonicalPath());
    LOG.log(Level.INFO,""String_Node_Str"" + folder.getRefSysFolder(""String_Node_Str"").getCanonicalPath());
    FileUtils.copyDirectory(new File(tmpFolder.getCanonicalPath()),folder.getRefSysFolder(""String_Node_Str""));
    LOG.log(Level.INFO,""String_Node_Str"");
    convertShpFile(rawFile,folder,1);
    LOG.log(Level.INFO,""String_Node_Str"");
    convertShpFile(rawFile,folder,0);
  }
 catch (  IOException e) {
    throw new WikiBrainException(e);
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void downloadAndConvert(SpatialDataFolder folder) throws WikiBrainException {
  try {
    WpIOUtils ioUtils=new WpIOUtils();
    String tmpFolderName=""String_Node_Str"";
    File tmpFolder=WpIOUtils.createTempDirectory(tmpFolderName,true);
    File rawFile=new File(""String_Node_Str"");
    LOG.log(Level.INFO,""String_Node_Str"" + folder.getRefSysFolder(""String_Node_Str"").getCanonicalPath());
    LOG.log(Level.INFO,""String_Node_Str"");
    convertShpFile(folder,1);
    LOG.log(Level.INFO,""String_Node_Str"");
    convertShpFile(folder,0);
  }
 catch (  IOException e) {
    throw new WikiBrainException(e);
  }
}"
52894,"/** 
 * Download GADM shape file
 * @param tmpFolder
 * @return
 */
public static File downloadGADMShapeFile(String tmpFolder) throws IOException, ZipException, InterruptedException {
  String baseFileName=""String_Node_Str"";
  String zipFileName=baseFileName + ""String_Node_Str"";
  String gadmURL=""String_Node_Str"" + zipFileName;
  File gadmShapeFile=new File(tmpFolder + ""String_Node_Str"" + zipFileName);
  FileDownloader downloader=new FileDownloader();
  downloader.download(new URL(gadmURL),gadmShapeFile);
  ZipFile zipFile=new ZipFile(gadmShapeFile.getCanonicalPath());
  LOG.log(Level.INFO,""String_Node_Str"" + gadmShapeFile.getParent());
  zipFile.extractAll(gadmShapeFile.getParent());
  File f=new File(tmpFolder + ""String_Node_Str"");
  LOG.log(Level.INFO,""String_Node_Str"");
  gadmShapeFile.delete();
  return f;
}","/** 
 * Download GADM shape file
 * @param tmpFolder
 * @return
 */
public File downloadGADMShapeFile(String tmpFolder) throws IOException, ZipException, InterruptedException {
  String baseFileName=""String_Node_Str"";
  String zipFileName=baseFileName + ""String_Node_Str"";
  String gadmURL=""String_Node_Str"" + zipFileName;
  File gadmShapeFile=new File(tmpFolder + ""String_Node_Str"" + zipFileName);
  FileDownloader downloader=new FileDownloader();
  downloader.download(new URL(gadmURL),gadmShapeFile);
  ZipFile zipFile=new ZipFile(gadmShapeFile.getCanonicalPath());
  LOG.log(Level.INFO,""String_Node_Str"" + gadmShapeFile.getParent());
  zipFile.extractAll(gadmShapeFile.getParent());
  File f=new File(tmpFolder + ""String_Node_Str"");
  LOG.log(Level.INFO,""String_Node_Str"");
  gadmShapeFile.delete();
  return f;
}"
52895,"/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException, WikiBrainException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  List<String> locList=new ArrayList<String>();
  List<Geometry> geoList=new ArrayList<Geometry>();
  List<String> visited=new ArrayList<String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  typeBuilder=new SimpleFeatureTypeBuilder();
  typeBuilder.setName(""String_Node_Str"");
  typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
  typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
  typeBuilder.add(""String_Node_Str"",String.class);
  if (level == 1)   typeBuilder.add(""String_Node_Str"",String.class);
  typeBuilder.setDefaultGeometry(""String_Node_Str"");
  final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
  geometryFactory=JTSFactoryFinder.getGeometryFactory();
  featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
  ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
  Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
  outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
  outputParams.put(""String_Node_Str"",Boolean.TRUE);
  ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
  outputDataStore.createSchema(WIKITYPE);
  Transaction transaction=new DefaultTransaction(""String_Node_Str"");
  String typeName=outputDataStore.getTypeNames()[0];
  SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
  map.put(""String_Node_Str"",rawFile.toURI().toURL());
  inputDataStore=DataStoreFinder.getDataStore(map);
  SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
  SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
  SimpleFeatureIterator inputFeatures=inputCollection.features();
  try {
    int total=0;
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      String country=((String)feature.getAttribute(4)).intern();
      String state=((String)feature.getAttribute(6)).intern();
      if (!locList.contains(state + ""String_Node_Str"" + country))       locList.add(state + ""String_Node_Str"" + country);
    }
    inputFeatures.close();
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"");
      total=locList.size();
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
      for (      String stateCountryPair : locList) {
        String country=stateCountryPair.split(""String_Node_Str"")[1];
        if (!visited.contains(country)) {
          visited.add(country);
          total++;
        }
 else         continue;
      }
    }
    visited.clear();
    int count=0;
    for (    String stateCountryPair : locList) {
      String state=stateCountryPair.split(""String_Node_Str"")[0];
      String country=stateCountryPair.split(""String_Node_Str"")[1];
      inputFeatures=inputCollection.features();
      if (level == 1) {
        count++;
        if (count % 10 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        while (inputFeatures.hasNext()) {
          SimpleFeature feature=inputFeatures.next();
          if (feature.getAttribute(6).equals(state) && feature.getAttribute(4).equals(country))           geoList.add((Geometry)feature.getAttribute(0));
        }
      }
 else {
        if (!visited.contains(country)) {
          visited.add(country);
        }
 else         continue;
        count++;
        LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ count+ ""String_Node_Str""+ total+ ""String_Node_Str"");
        while (inputFeatures.hasNext()) {
          SimpleFeature feature=inputFeatures.next();
          if (feature.getAttribute(4).equals(country))           geoList.add((Geometry)feature.getAttribute(0));
        }
      }
      inputFeatures.close();
      Geometry newGeom;
      try {
        newGeom=geometryFactory.buildGeometry(geoList).union();
      }
 catch (      Exception e) {
        if (level == 1)         LOG.log(Level.INFO,""String_Node_Str"" + state + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
 else         LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
        newGeom=geometryFactory.buildGeometry(geoList).buffer(0);
      }
      featureBuilder.add(newGeom);
      if (level == 1) {
        featureBuilder.add(state);
        featureBuilder.add(state + ""String_Node_Str"" + country);
      }
 else       featureBuilder.add(country);
      SimpleFeature feature=featureBuilder.buildFeature(null);
      features.add(feature);
      if (outputFeatureSource instanceof SimpleFeatureStore) {
        SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
        SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
        featureStore.setTransaction(transaction);
        try {
          featureStore.addFeatures(collection);
          transaction.commit();
          collection=null;
        }
 catch (        Exception e) {
          e.printStackTrace();
          transaction.rollback();
        }
      }
 else {
        LOG.log(Level.INFO,typeName + ""String_Node_Str"");
      }
      features.clear();
      System.gc();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    inputDataStore.dispose();
    transaction.close();
    outputFolder.deleteSpecificFile(""String_Node_Str"",RefSys.EARTH);
    outputFolder.deleteLayer(""String_Node_Str"",RefSys.EARTH);
  }
}","/** 
 * @param outputFolder
 * @param level
 * @return //TODO: reduce memory usageConverts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public void convertShpFile(SpatialDataFolder outputFolder,int level) throws IOException, WikiBrainException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str""+ level+ ""String_Node_Str"");
  List<String> locList=new ArrayList<String>();
  List<Geometry> geoList;
  List<String> visited=new ArrayList<String>();
  GeometryFactory geometryFactory=JTSFactoryFinder.getGeometryFactory();
  ;
  SimpleFeatureBuilder featureBuilder;
  List<SimpleFeature> features;
  final SimpleFeatureType WIKITYPE=getOutputFeatureType(level);
  featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
  SimpleFeatureSource outputFeatureSource=getOutputDataFeatureSource(outputFile,WIKITYPE);
  Transaction transaction=new DefaultTransaction(""String_Node_Str"");
  SimpleFeatureCollection inputCollection=getInputCollection();
  SimpleFeatureIterator inputFeatures=inputCollection.features();
  try {
    int total=0;
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      String country=((String)feature.getAttribute(4)).intern();
      String state=((String)feature.getAttribute(6)).intern();
      if (!locList.contains(state + ""String_Node_Str"" + country))       locList.add(state + ""String_Node_Str"" + country);
    }
    inputFeatures.close();
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"");
      total=locList.size();
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
      for (      String stateCountryPair : locList) {
        String country=stateCountryPair.split(""String_Node_Str"")[1];
        if (!visited.contains(country)) {
          visited.add(country);
          total++;
        }
      }
    }
    visited.clear();
    int count=0;
    for (    String stateCountryPair : locList) {
      features=new ArrayList<SimpleFeature>();
      geoList=new ArrayList<Geometry>();
      String state=stateCountryPair.split(""String_Node_Str"")[0];
      String country=stateCountryPair.split(""String_Node_Str"")[1];
      inputFeatures=inputCollection.features();
      if (level == 1) {
        count++;
        if (count % 10 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        while (inputFeatures.hasNext()) {
          SimpleFeature feature=inputFeatures.next();
          if (feature.getAttribute(6).equals(state) && feature.getAttribute(4).equals(country))           geoList.add((Geometry)feature.getAttribute(0));
        }
      }
 else {
        if (!visited.contains(country)) {
          visited.add(country);
        }
 else         continue;
        count++;
        LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ count+ ""String_Node_Str""+ total+ ""String_Node_Str"");
        while (inputFeatures.hasNext()) {
          SimpleFeature feature=inputFeatures.next();
          if (feature.getAttribute(4).equals(country))           geoList.add((Geometry)feature.getAttribute(0));
        }
      }
      inputFeatures.close();
      Geometry newGeom;
      try {
        newGeom=geometryFactory.buildGeometry(geoList).union();
      }
 catch (      Exception e) {
        if (level == 1)         LOG.log(Level.INFO,""String_Node_Str"" + state + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
 else         LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
        newGeom=geometryFactory.buildGeometry(geoList).buffer(0);
      }
      featureBuilder.add(newGeom);
      if (level == 1) {
        featureBuilder.add(state);
        featureBuilder.add(state + ""String_Node_Str"" + country);
      }
 else       featureBuilder.add(country);
      SimpleFeature feature=featureBuilder.buildFeature(null);
      features.add(feature);
      if (outputFeatureSource instanceof SimpleFeatureStore) {
        SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
        SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
        featureStore.setTransaction(transaction);
        try {
          featureStore.addFeatures(collection);
          transaction.commit();
        }
 catch (        Exception e) {
          e.printStackTrace();
          transaction.rollback();
        }
      }
 else {
        LOG.log(Level.INFO,""String_Node_Str"");
      }
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    transaction.close();
    outputFolder.deleteSpecificFile(""String_Node_Str"",RefSys.EARTH);
    outputFolder.deleteLayer(""String_Node_Str"",RefSys.EARTH);
  }
}"
52896,"public static void main(String args[]){
  try {
    Options options=new Options();
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    EnvBuilder.addStandardOptions(options);
    CommandLineParser parser=new PosixParser();
    CommandLine cmd;
    cmd=parser.parse(options,args);
    Env env=new EnvBuilder(cmd).build();
    Configurator conf=env.getConfigurator();
    String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
    String spatialDataFolderPath=cmd.getOptionValue(""String_Node_Str"",null);
    File spatialDataFolderFile;
    if (spatialDataFolderPath == null) {
      spatialDataFolderFile=new File(""String_Node_Str"");
    }
 else {
      spatialDataFolderFile=new File(spatialDataFolderPath);
    }
    SpatialDataFolder spatialDataFolder=new SpatialDataFolder(spatialDataFolderFile);
    WikidataDao wdDao=conf.get(WikidataDao.class);
    SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
    SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder,env.getLanguages());
    String stepsValue=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    String[] steps=stepsValue.split(""String_Node_Str"");
    for (    String step : steps) {
      if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadWikidataData();
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        GADMConverter.downloadAndConvert(spatialDataFolder);
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadExogenousData();
      }
 else {
        throw new Exception(""String_Node_Str"" + step + ""String_Node_Str"");
      }
    }
    loader.loadWikidataData();
    loader.loadExogenousData();
    LOG.info(""String_Node_Str"");
    conf.get(WpDataSource.class).optimize();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String args[]){
  try {
    Options options=new Options();
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    EnvBuilder.addStandardOptions(options);
    CommandLineParser parser=new PosixParser();
    CommandLine cmd;
    cmd=parser.parse(options,args);
    Env env=new EnvBuilder(cmd).build();
    Configurator conf=env.getConfigurator();
    String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
    String spatialDataFolderPath=cmd.getOptionValue(""String_Node_Str"",null);
    File spatialDataFolderFile;
    if (spatialDataFolderPath == null) {
      spatialDataFolderFile=new File(""String_Node_Str"");
    }
 else {
      spatialDataFolderFile=new File(spatialDataFolderPath);
    }
    SpatialDataFolder spatialDataFolder=new SpatialDataFolder(spatialDataFolderFile);
    WikidataDao wdDao=conf.get(WikidataDao.class);
    SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
    SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder,env.getLanguages());
    String stepsValue=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    String[] steps=stepsValue.split(""String_Node_Str"");
    for (    String step : steps) {
      if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadWikidataData();
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        new GADMConverter().downloadAndConvert(spatialDataFolder);
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadExogenousData();
      }
 else {
        throw new Exception(""String_Node_Str"" + step + ""String_Node_Str"");
      }
    }
    loader.loadWikidataData();
    loader.loadExogenousData();
    LOG.info(""String_Node_Str"");
    conf.get(WpDataSource.class).optimize();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
52897,"@Override protected boolean storeStatement(WikidataStatement statement) throws DaoException {
  int itemId=statement.getItem().getId();
  Geometry g=EarthBasicCoordinatesWikidataLayerLoader.jsonToGeometry(statement.getValue().getJsonValue().getAsJsonObject());
  if (g != null) {
    Iterable<WikidataStatement> instanceOfStatements=wdDao.get((new WikidataFilter.Builder()).withPropertyId(INSTANCE_OF_PROPERTY_ID).withEntityId(itemId).build());
    int count=0;
    for (    WikidataStatement instanceOfStatement : instanceOfStatements) {
      int typeItemId=instanceOfStatement.getValue().getItemValue();
      String layerName=Integer.toString(typeItemId);
      spatialDao.saveGeometry(itemId,layerName,EARTH_REF_SYS_NAME,g);
      count++;
    }
    if (count > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","@Override protected boolean storeStatement(WikidataStatement statement) throws DaoException {
  int itemId=statement.getItem().getId();
  Geometry g=EarthBasicCoordinatesWikidataLayerLoader.jsonToGeometry(statement.getValue().getJsonValue().getAsJsonObject());
  if (g != null) {
    Iterable<WikidataStatement> instanceOfStatements=wdDao.get((new WikidataFilter.Builder()).withEntityId(itemId).withPropertyId(INSTANCE_OF_PROPERTY_ID).build());
    int count=0;
    for (    WikidataStatement instanceOfStatement : instanceOfStatements) {
      int typeItemId=instanceOfStatement.getValue().getItemValue();
      String layerName=""String_Node_Str"" + Integer.toString(typeItemId);
      spatialDao.saveGeometry(itemId,layerName,EARTH_REF_SYS_NAME,g);
      count++;
    }
    if (count > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
52898,"private void loadWikidataData() throws WikiBrainException {
  try {
    spatialDataDao.beginSaveGeometries();
    List<WikidataLayerLoader> layerLoaders=Lists.newArrayList();
    layerLoaders.add(new EarthInstanceOfCoordinatesLayerLoader(wdDao,spatialDataDao));
    for (    WikidataLayerLoader layerLoader : layerLoaders) {
      LOG.log(Level.INFO,""String_Node_Str"" + layerLoader.getClass().getName());
      layerLoader.loadData(langs);
    }
    spatialDataDao.endSaveGeometries();
  }
 catch (  DaoException e) {
    throw new WikiBrainException(e);
  }
}","private void loadWikidataData() throws WikiBrainException {
  try {
    spatialDataDao.beginSaveGeometries();
    List<WikidataLayerLoader> layerLoaders=Lists.newArrayList();
    layerLoaders.add(new EarthBasicCoordinatesWikidataLayerLoader(wdDao,spatialDataDao));
    for (    WikidataLayerLoader layerLoader : layerLoaders) {
      LOG.log(Level.INFO,""String_Node_Str"" + layerLoader.getClass().getName());
      layerLoader.loadData(langs);
    }
    spatialDataDao.endSaveGeometries();
  }
 catch (  DaoException e) {
    throw new WikiBrainException(e);
  }
}"
52899,"private void initWord2Vec(String name) throws ConfigurationException, IOException, DaoException {
  Config config=getMetricConfig(name).getConfig(""String_Node_Str"");
  String corpusName=config.getString(""String_Node_Str"");
  Corpus corpus=null;
  if (!corpusName.equals(""String_Node_Str"")) {
    corpus=env.getConfigurator().get(Corpus.class,config.getString(""String_Node_Str""),""String_Node_Str"",language.getLangCode());
    if (!corpus.exists()) {
      corpus.create();
    }
  }
  File model=Word2VecGenerator.getModelFile(config.getString(""String_Node_Str""),language);
  if (!model.isFile()) {
    if (corpus == null) {
      throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ model+ ""String_Node_Str"");
    }
    Word2VecTrainer trainer=new Word2VecTrainer(env.getConfigurator().get(LocalPageDao.class),language);
    trainer.train(corpus.getDirectory());
    trainer.save(model);
  }
  LinkProbabilityDao lpd=env.getConfigurator().get(LinkProbabilityDao.class);
  if (!lpd.isBuilt()) {
    lpd.build();
  }
}","private void initWord2Vec(String name) throws ConfigurationException, IOException, DaoException {
  LinkProbabilityDao lpd=env.getConfigurator().get(LinkProbabilityDao.class);
  if (!lpd.isBuilt()) {
    lpd.build();
  }
  Config config=getMetricConfig(name).getConfig(""String_Node_Str"");
  String corpusName=config.getString(""String_Node_Str"");
  Corpus corpus=null;
  if (!corpusName.equals(""String_Node_Str"")) {
    corpus=env.getConfigurator().get(Corpus.class,config.getString(""String_Node_Str""),""String_Node_Str"",language.getLangCode());
    if (!corpus.exists()) {
      corpus.create();
    }
  }
  File model=Word2VecGenerator.getModelFile(config.getString(""String_Node_Str""),language);
  if (!model.isFile()) {
    if (corpus == null) {
      throw new ConfigurationException(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ model+ ""String_Node_Str"");
    }
    Word2VecTrainer trainer=new Word2VecTrainer(env.getConfigurator().get(LocalPageDao.class),language);
    trainer.train(corpus.getDirectory());
    trainer.save(model);
  }
}"
52900,"public boolean hasCategoryDistance(int categoryId){
  return catDistances.containsKey(graph.getCategoryIndex(categoryId));
}","public boolean hasCategoryDistance(int pageId){
  return catDistances.containsKey(graph.getCategoryIndex(pageId));
}"
52901,"@Override public SRResult similarity(int pageId1,int pageId2,boolean explanations) throws DaoException {
  CategoryBfs bfs1=new CategoryBfs(graph,pageId1,getLanguage(),Integer.MAX_VALUE,null,catHelper);
  CategoryBfs bfs2=new CategoryBfs(graph,pageId2,getLanguage(),Integer.MAX_VALUE,null,catHelper);
  bfs1.setAddPages(false);
  bfs1.setExploreChildren(false);
  bfs2.setAddPages(false);
  bfs2.setExploreChildren(false);
  double shortestDistance=Double.POSITIVE_INFINITY;
  double maxDist1=0;
  double maxDist2=0;
  while ((bfs1.hasMoreResults() || bfs2.hasMoreResults()) && (maxDist1 + maxDist2 < shortestDistance)) {
    while (bfs1.hasMoreResults() && (maxDist1 <= maxDist2 || !bfs2.hasMoreResults())) {
      CategoryBfs.BfsVisited visited=bfs1.step();
      for (      int catId : visited.cats.keys()) {
        if (bfs2.hasCategoryDistance(catId)) {
          double d=bfs1.getCategoryDistance(catId) + bfs2.getCategoryDistance(catId) - graph.catCosts[catId];
          shortestDistance=Math.min(d,shortestDistance);
        }
      }
      maxDist1=Math.max(maxDist1,visited.maxCatDistance());
    }
    while (bfs2.hasMoreResults() && (maxDist2 <= maxDist1 || !bfs1.hasMoreResults())) {
      CategoryBfs.BfsVisited visited=bfs2.step();
      for (      int catId : visited.cats.keys()) {
        if (bfs1.hasCategoryDistance(catId)) {
          double d=bfs1.getCategoryDistance(catId) + bfs2.getCategoryDistance(catId) + 0 - graph.catCosts[catId];
          shortestDistance=Math.min(d,shortestDistance);
        }
      }
      maxDist2=Math.max(maxDist2,visited.maxCatDistance());
    }
  }
  return new SRResult(distanceToScore(shortestDistance));
}","@Override public SRResult similarity(int pageId1,int pageId2,boolean explanations) throws DaoException {
  CategoryBfs bfs1=new CategoryBfs(graph,pageId1,getLanguage(),Integer.MAX_VALUE,null,catHelper);
  CategoryBfs bfs2=new CategoryBfs(graph,pageId2,getLanguage(),Integer.MAX_VALUE,null,catHelper);
  bfs1.setAddPages(false);
  bfs1.setExploreChildren(false);
  bfs2.setAddPages(false);
  bfs2.setExploreChildren(false);
  double shortestDistance=Double.POSITIVE_INFINITY;
  double maxDist1=0;
  double maxDist2=0;
  while ((bfs1.hasMoreResults() || bfs2.hasMoreResults()) && (maxDist1 + maxDist2 < shortestDistance)) {
    while (bfs1.hasMoreResults() && (maxDist1 <= maxDist2 || !bfs2.hasMoreResults())) {
      CategoryBfs.BfsVisited visited=bfs1.step();
      for (      int catId : visited.cats.keys()) {
        if (bfs2.hasCategoryDistanceForIndex(catId)) {
          double d=bfs1.getCategoryDistanceForIndex(catId) + bfs2.getCategoryDistanceForIndex(catId) - graph.catCosts[catId];
          shortestDistance=Math.min(d,shortestDistance);
        }
      }
      maxDist1=Math.max(maxDist1,visited.maxCatDistance());
    }
    while (bfs2.hasMoreResults() && (maxDist2 <= maxDist1 || !bfs1.hasMoreResults())) {
      CategoryBfs.BfsVisited visited=bfs2.step();
      for (      int catId : visited.cats.keys()) {
        if (bfs1.hasCategoryDistanceForIndex(catId)) {
          double d=bfs1.getCategoryDistanceForIndex(catId) + bfs2.getCategoryDistanceForIndex(catId) + 0 - graph.catCosts[catId];
          shortestDistance=Math.min(d,shortestDistance);
        }
      }
      maxDist2=Math.max(maxDist2,visited.maxCatDistance());
    }
  }
  return new SRResult(distanceToScore(shortestDistance));
}"
52902,"/** 
 * Reads a dataset from a buffered reader.
 * @param name Name of the dataset, must end with csv for comma separated files.
 * @param language Language of the dataset.
 * @param reader The inputsource of the dataset.
 * @return The dataset
 * @throws DaoException
 */
protected Dataset read(String name,Language language,BufferedReader reader) throws DaoException {
  List<KnownSim> result=new ArrayList<KnownSim>();
  try {
    String delim=""String_Node_Str"";
    if (name.toLowerCase().endsWith(""String_Node_Str"")) {
      delim=""String_Node_Str"";
    }
    while (true) {
      String line=reader.readLine();
      if (line == null)       break;
      String tokens[]=line.split(delim);
      if (tokens.length == 3) {
        KnownSim ks=new KnownSim(tokens[0],tokens[1],Double.valueOf(tokens[2]),language);
        if (resolvePhrases) {
          LocalId id1=disambiguator.disambiguateTop(new LocalString(language,ks.phrase1),null);
          LocalId id2=disambiguator.disambiguateTop(new LocalString(language,ks.phrase2),null);
          if (id1 != null) {
            ks.wpId1=id1.getId();
          }
          if (id2 != null) {
            ks.wpId2=id2.getId();
          }
        }
        result.add(ks);
      }
 else {
        throw new DaoException(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ StringEscapeUtils.escapeJava(line)+ ""String_Node_Str"");
      }
    }
    reader.close();
  }
 catch (  IOException e) {
    throw new DaoException(e);
  }
  Dataset dataset=new Dataset(name,language,result);
  if (normalize) {
    dataset.normalize();
  }
  return dataset;
}","/** 
 * Reads a dataset from a buffered reader.
 * @param name Name of the dataset, must end with csv for comma separated files.
 * @param language Language of the dataset.
 * @param reader The inputsource of the dataset.
 * @return The dataset
 * @throws DaoException
 */
protected Dataset read(String name,Language language,BufferedReader reader) throws DaoException {
  List<KnownSim> result=new ArrayList<KnownSim>();
  try {
    String delim=""String_Node_Str"";
    if (name.toLowerCase().endsWith(""String_Node_Str"")) {
      delim=""String_Node_Str"";
    }
    while (true) {
      String line=reader.readLine();
      if (line == null)       break;
      String tokens[]=line.split(delim);
      if (tokens.length >= 3) {
        KnownSim ks=new KnownSim(tokens[0],tokens[1],Double.valueOf(tokens[2]),language);
        if (resolvePhrases) {
          LocalId id1=disambiguator.disambiguateTop(new LocalString(language,ks.phrase1),null);
          LocalId id2=disambiguator.disambiguateTop(new LocalString(language,ks.phrase2),null);
          if (id1 != null) {
            ks.wpId1=id1.getId();
          }
          if (id2 != null) {
            ks.wpId2=id2.getId();
          }
        }
        result.add(ks);
      }
 else {
        throw new DaoException(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ StringEscapeUtils.escapeJava(line)+ ""String_Node_Str"");
      }
    }
    reader.close();
  }
 catch (  IOException e) {
    throw new DaoException(e);
  }
  Dataset dataset=new Dataset(name,language,result);
  if (normalize) {
    dataset.normalize();
  }
  return dataset;
}"
52903,"/** 
 * calculate interpolated values for missing ranks and scores
 * @param examples
 */
public void trainSimilarity(List<EnsembleSim> examples){
  for (int i=0; i < numMetrics; i++) {
    int numMissingScores=0;
    double sumMissingScores=0.0;
    for (    EnsembleSim es : examples) {
      double v=es.getScores().get(i);
      if (Double.isNaN(v) || Double.isInfinite(v)) {
        sumMissingScores+=es.getKnownSim().similarity;
        numMissingScores++;
      }
    }
    missingScores[i]=(numMissingScores > 0) ? (sumMissingScores / numMissingScores) : 0.0;
    LOG.info(""String_Node_Str"" + i + ""String_Node_Str""+ ""String_Node_Str""+ missingScores[i]);
  }
}","/** 
 * calculate interpolated values for missing ranks and scores
 * @param examples
 */
public void trainSimilarity(List<EnsembleSim> examples){
  for (int i=0; i < numMetrics; i++) {
    int numMissingScores=0;
    double sumMissingScores=0.0;
    for (    EnsembleSim es : examples) {
      if (es != null) {
        double v=es.getScores().get(i);
        if (Double.isNaN(v) || Double.isInfinite(v)) {
          sumMissingScores+=es.getKnownSim().similarity;
          numMissingScores++;
        }
      }
    }
    missingScores[i]=(numMissingScores > 0) ? (sumMissingScores / numMissingScores) : 0.0;
    LOG.info(""String_Node_Str"" + i + ""String_Node_Str""+ ""String_Node_Str""+ missingScores[i]);
  }
}"
52904,"/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException, WikiBrainException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  List<String> locList=new ArrayList<String>();
  List<Geometry> geoList=new ArrayList<Geometry>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  typeBuilder=new SimpleFeatureTypeBuilder();
  typeBuilder.setName(""String_Node_Str"");
  typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
  typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
  typeBuilder.add(""String_Node_Str"",String.class);
  if (level == 1)   typeBuilder.add(""String_Node_Str"",String.class);
  typeBuilder.setDefaultGeometry(""String_Node_Str"");
  final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
  geometryFactory=JTSFactoryFinder.getGeometryFactory();
  featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
  ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
  Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
  outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
  outputParams.put(""String_Node_Str"",Boolean.TRUE);
  ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
  outputDataStore.createSchema(WIKITYPE);
  Transaction transaction=new DefaultTransaction(""String_Node_Str"");
  String typeName=outputDataStore.getTypeNames()[0];
  SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
  map.put(""String_Node_Str"",rawFile.toURI().toURL());
  inputDataStore=DataStoreFinder.getDataStore(map);
  SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
  SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
  SimpleFeatureIterator inputFeatures=inputCollection.features();
  try {
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
    }
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      String country=((String)feature.getAttribute(4)).intern();
      String state=((String)feature.getAttribute(6)).intern();
      if (!locList.contains(state + ""String_Node_Str"" + country))       locList.add(state + ""String_Node_Str"" + country);
    }
    inputFeatures.close();
    int total=locList.size();
    int count=0;
    for (    String stateCountryPair : locList) {
      String state=stateCountryPair.split(""String_Node_Str"")[0];
      String country=stateCountryPair.split(""String_Node_Str"")[1];
      count++;
      inputFeatures=inputCollection.features();
      if (level == 1) {
        if (count % 10 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        while (inputFeatures.hasNext()) {
          SimpleFeature feature=inputFeatures.next();
          if (feature.getAttribute(6).equals(state) && feature.getAttribute(4).equals(country))           geoList.add((Geometry)feature.getAttribute(0));
        }
      }
 else {
        LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ count+ ""String_Node_Str""+ total+ ""String_Node_Str"");
        while (inputFeatures.hasNext()) {
          SimpleFeature feature=inputFeatures.next();
          if (feature.getAttribute(4).equals(country))           geoList.add((Geometry)feature.getAttribute(0));
        }
      }
      inputFeatures.close();
      Geometry newGeom;
      try {
        newGeom=geometryFactory.buildGeometry(geoList).union();
      }
 catch (      Exception e) {
        if (level == 1)         LOG.log(Level.INFO,""String_Node_Str"" + state + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
 else         LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
        newGeom=geometryFactory.buildGeometry(geoList).buffer(0);
      }
      featureBuilder.add(newGeom);
      featureBuilder.add(state);
      featureBuilder.add(state + ""String_Node_Str"" + country);
      SimpleFeature feature=featureBuilder.buildFeature(null);
      features.add(feature);
      if (outputFeatureSource instanceof SimpleFeatureStore) {
        SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
        SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
        featureStore.setTransaction(transaction);
        try {
          featureStore.addFeatures(collection);
          transaction.commit();
          collection=null;
        }
 catch (        Exception e) {
          e.printStackTrace();
          transaction.rollback();
        }
      }
 else {
        LOG.log(Level.INFO,typeName + ""String_Node_Str"");
      }
      features.clear();
      System.gc();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    inputDataStore.dispose();
    transaction.close();
    outputFolder.deleteSpecificFile(""String_Node_Str"",RefSys.EARTH);
    outputFolder.deleteLayer(""String_Node_Str"",RefSys.EARTH);
  }
}","/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException, WikiBrainException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  List<String> locList=new ArrayList<String>();
  List<Geometry> geoList=new ArrayList<Geometry>();
  List<String> visited=new ArrayList<String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  typeBuilder=new SimpleFeatureTypeBuilder();
  typeBuilder.setName(""String_Node_Str"");
  typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
  typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
  typeBuilder.add(""String_Node_Str"",String.class);
  if (level == 1)   typeBuilder.add(""String_Node_Str"",String.class);
  typeBuilder.setDefaultGeometry(""String_Node_Str"");
  final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
  geometryFactory=JTSFactoryFinder.getGeometryFactory();
  featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
  ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
  Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
  outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
  outputParams.put(""String_Node_Str"",Boolean.TRUE);
  ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
  outputDataStore.createSchema(WIKITYPE);
  Transaction transaction=new DefaultTransaction(""String_Node_Str"");
  String typeName=outputDataStore.getTypeNames()[0];
  SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
  map.put(""String_Node_Str"",rawFile.toURI().toURL());
  inputDataStore=DataStoreFinder.getDataStore(map);
  SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
  SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
  SimpleFeatureIterator inputFeatures=inputCollection.features();
  try {
    int total=0;
    while (inputFeatures.hasNext()) {
      SimpleFeature feature=inputFeatures.next();
      String country=((String)feature.getAttribute(4)).intern();
      String state=((String)feature.getAttribute(6)).intern();
      if (!locList.contains(state + ""String_Node_Str"" + country))       locList.add(state + ""String_Node_Str"" + country);
    }
    inputFeatures.close();
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"");
      total=locList.size();
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
      for (      String stateCountryPair : locList) {
        String country=stateCountryPair.split(""String_Node_Str"")[1];
        if (!visited.contains(country)) {
          visited.add(country);
          total++;
        }
 else         continue;
      }
    }
    visited.clear();
    int count=0;
    for (    String stateCountryPair : locList) {
      String state=stateCountryPair.split(""String_Node_Str"")[0];
      String country=stateCountryPair.split(""String_Node_Str"")[1];
      inputFeatures=inputCollection.features();
      if (level == 1) {
        count++;
        if (count % 10 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        while (inputFeatures.hasNext()) {
          SimpleFeature feature=inputFeatures.next();
          if (feature.getAttribute(6).equals(state) && feature.getAttribute(4).equals(country))           geoList.add((Geometry)feature.getAttribute(0));
        }
      }
 else {
        if (!visited.contains(country)) {
          visited.add(country);
        }
 else         continue;
        count++;
        LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ count+ ""String_Node_Str""+ total+ ""String_Node_Str"");
        while (inputFeatures.hasNext()) {
          SimpleFeature feature=inputFeatures.next();
          if (feature.getAttribute(4).equals(country))           geoList.add((Geometry)feature.getAttribute(0));
        }
      }
      inputFeatures.close();
      Geometry newGeom;
      try {
        newGeom=geometryFactory.buildGeometry(geoList).union();
      }
 catch (      Exception e) {
        if (level == 1)         LOG.log(Level.INFO,""String_Node_Str"" + state + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
 else         LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
        newGeom=geometryFactory.buildGeometry(geoList).buffer(0);
      }
      featureBuilder.add(newGeom);
      if (level == 1) {
        featureBuilder.add(state);
        featureBuilder.add(state + ""String_Node_Str"" + country);
      }
 else       featureBuilder.add(country);
      SimpleFeature feature=featureBuilder.buildFeature(null);
      features.add(feature);
      if (outputFeatureSource instanceof SimpleFeatureStore) {
        SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
        SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
        featureStore.setTransaction(transaction);
        try {
          featureStore.addFeatures(collection);
          transaction.commit();
          collection=null;
        }
 catch (        Exception e) {
          e.printStackTrace();
          transaction.rollback();
        }
      }
 else {
        LOG.log(Level.INFO,typeName + ""String_Node_Str"");
      }
      features.clear();
      System.gc();
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    inputDataStore.dispose();
    transaction.close();
    outputFolder.deleteSpecificFile(""String_Node_Str"",RefSys.EARTH);
    outputFolder.deleteLayer(""String_Node_Str"",RefSys.EARTH);
  }
}"
52905,"private void buildGraph(CategoryGraph graph,LocalCategoryMemberDao lcmDao) throws DaoException {
  LOG.info(""String_Node_Str"");
  graph.catPages=new int[graph.catIndexes.size()][];
  graph.catParents=new int[graph.catIndexes.size()][];
  graph.catChildren=new int[graph.catIndexes.size()][];
  graph.catCosts=new double[graph.catIndexes.size()];
  Arrays.fill(graph.catPages,new int[0]);
  Arrays.fill(graph.catParents,new int[0]);
  Arrays.fill(graph.catChildren,new int[0]);
  int totalEdges=0;
  int numCatChildren[]=new int[graph.catIndexes.size()];
  int numCatParents[]=new int[graph.catIndexes.size()];
  int numCatPages[]=new int[graph.catIndexes.size()];
  DaoFilter filter=new DaoFilter().setLanguages(graph.language);
  for (  LocalCategoryMember lcm : lcmDao.get(filter)) {
    int catIndex1=graph.getCategoryIndex(lcm.getArticleId());
    int catIndex2=graph.getCategoryIndex(lcm.getCategoryId());
    if (catIndex1 >= 0 && catIndex2 >= 0) {
      numCatChildren[catIndex2]++;
      numCatParents[catIndex1]++;
    }
 else     if (catIndex2 >= 0) {
      numCatPages[catIndex2]++;
    }
    totalEdges++;
  }
  for (int i=0; i < graph.catIndexes.size(); i++) {
    graph.catPages[i]=new int[numCatPages[i]];
    graph.catChildren[i]=new int[numCatChildren[i]];
    graph.catParents[i]=new int[numCatParents[i]];
  }
  for (  LocalCategoryMember lcm : lcmDao.get(filter)) {
    int catIndex1=graph.getCategoryIndex(lcm.getArticleId());
    int catIndex2=graph.getCategoryIndex(lcm.getCategoryId());
    if (catIndex1 >= 0 && catIndex2 >= 0) {
      graph.catChildren[catIndex2][--numCatChildren[catIndex2]]=catIndex1;
      graph.catParents[catIndex1][--numCatParents[catIndex1]]=catIndex2;
    }
 else     if (catIndex2 >= 0) {
      graph.catPages[catIndex2][--numCatPages[catIndex2]]=lcm.getArticleId();
    }
  }
  for (  int n : numCatChildren) {
    assert(n == 0);
  }
  for (  int n : numCatPages) {
    assert(n == 0);
  }
  for (  int n : numCatParents) {
    assert(n == 0);
  }
  LOG.info(""String_Node_Str"" + totalEdges + ""String_Node_Str"");
}","private void buildGraph(CategoryGraph graph) throws DaoException {
  LOG.info(""String_Node_Str"");
  graph.catPages=new int[graph.catIndexes.size()][];
  graph.catParents=new int[graph.catIndexes.size()][];
  graph.catChildren=new int[graph.catIndexes.size()][];
  graph.catCosts=new double[graph.catIndexes.size()];
  Arrays.fill(graph.catPages,new int[0]);
  Arrays.fill(graph.catParents,new int[0]);
  Arrays.fill(graph.catChildren,new int[0]);
  int totalEdges=0;
  int numCatChildren[]=new int[graph.catIndexes.size()];
  int numCatParents[]=new int[graph.catIndexes.size()];
  int numCatPages[]=new int[graph.catIndexes.size()];
  DaoFilter filter=new DaoFilter().setLanguages(graph.language);
  for (  LocalCategoryMember lcm : catDao.get(filter)) {
    int catIndex1=graph.getCategoryIndex(lcm.getArticleId());
    int catIndex2=graph.getCategoryIndex(lcm.getCategoryId());
    if (catIndex1 >= 0 && catIndex2 >= 0) {
      numCatChildren[catIndex2]++;
      numCatParents[catIndex1]++;
    }
 else     if (catIndex2 >= 0) {
      numCatPages[catIndex2]++;
    }
    totalEdges++;
  }
  for (int i=0; i < graph.catIndexes.size(); i++) {
    graph.catPages[i]=new int[numCatPages[i]];
    graph.catChildren[i]=new int[numCatChildren[i]];
    graph.catParents[i]=new int[numCatParents[i]];
  }
  for (  LocalCategoryMember lcm : catDao.get(filter)) {
    int catIndex1=graph.getCategoryIndex(lcm.getArticleId());
    int catIndex2=graph.getCategoryIndex(lcm.getCategoryId());
    if (catIndex1 >= 0 && catIndex2 >= 0) {
      graph.catChildren[catIndex2][--numCatChildren[catIndex2]]=catIndex1;
      graph.catParents[catIndex1][--numCatParents[catIndex1]]=catIndex2;
    }
 else     if (catIndex2 >= 0) {
      graph.catPages[catIndex2][--numCatPages[catIndex2]]=lcm.getArticleId();
    }
  }
  for (  int n : numCatChildren) {
    assert(n == 0);
  }
  for (  int n : numCatPages) {
    assert(n == 0);
  }
  for (  int n : numCatParents) {
    assert(n == 0);
  }
  LOG.info(""String_Node_Str"" + totalEdges + ""String_Node_Str"");
}"
52906,"/** 
 * @param language
 * @param lpDao
 * @param lcmDao
 * @return
 * @throws DaoException
 */
public CategoryGraph build(Language language,LocalPageDao lpDao,LocalCategoryMemberDao lcmDao) throws DaoException {
  CategoryGraph graph=new CategoryGraph(language);
  loadCategories(graph,lpDao);
  buildGraph(graph,lcmDao);
  computePageRanks(graph);
  return graph;
}","/** 
 * @param language
 * @return
 * @throws DaoException
 */
public CategoryGraph build(Language language) throws DaoException {
  CategoryGraph graph=new CategoryGraph(language);
  loadCategories(graph);
  buildGraph(graph);
  computePageRanks(graph);
  return graph;
}"
52907,"private void loadCategories(CategoryGraph graph,LocalPageDao lpDao) throws DaoException {
  LOG.info(""String_Node_Str"");
  graph.catIndexes=new TIntIntHashMap();
  List<String> catList=new ArrayList<String>();
  Iterable<LocalPage> catIter=lpDao.get(new DaoFilter().setNameSpaces(NameSpace.CATEGORY).setLanguages(graph.language));
  for (  LocalPage cat : catIter) {
    if (cat != null) {
      catList.add(cat.getTitle().getCanonicalTitle());
      graph.catIndexes.put(cat.getLocalId(),graph.catIndexes.size());
    }
  }
  graph.cats=catList.toArray(new String[0]);
  LOG.info(""String_Node_Str"" + graph.cats.length + ""String_Node_Str"");
}","private void loadCategories(CategoryGraph graph) throws DaoException {
  LOG.info(""String_Node_Str"");
  graph.catIndexes=new TIntIntHashMap();
  List<String> catList=new ArrayList<String>();
  Iterable<LocalPage> catIter=pageDao.get(new DaoFilter().setNameSpaces(NameSpace.CATEGORY).setLanguages(graph.language));
  TIntList catIds=new TIntArrayList();
  for (  LocalPage cat : catIter) {
    if (cat != null) {
      if (graph.catIndexes.containsKey(cat.getLocalId())) {
        continue;
      }
      assert(catList.size() == graph.catIndexes.size());
      assert(catIds.size() == graph.catIndexes.size());
      int ci=graph.catIndexes.size();
      graph.catIndexes.put(cat.getLocalId(),ci);
      catList.add(cat.getTitle().getCanonicalTitle());
      catIds.add(cat.getLocalId());
    }
  }
  graph.cats=catList.toArray(new String[0]);
  graph.catIds=catIds.toArray();
  LOG.info(""String_Node_Str"" + graph.cats.length + ""String_Node_Str"");
}"
52908,"@Override public CategoryGraph getGraph(Language language) throws DaoException {
  String key=""String_Node_Str"" + language.getLangCode();
  if (cache != null) {
    CategoryGraph graph=(CategoryGraph)cache.get(key,LocalPage.class,LocalCategoryMember.class);
    if (graph != null) {
      return graph;
    }
  }
  LocalCategoryGraphBuilder builder=new LocalCategoryGraphBuilder();
  CategoryGraph graph=builder.build(language,localPageDao,this);
  cache.put(key,graph);
  return graph;
}","@Override public CategoryGraph getGraph(Language language) throws DaoException {
  String key=""String_Node_Str"" + language.getLangCode();
  if (cache != null) {
    CategoryGraph graph=(CategoryGraph)cache.get(key,LocalPage.class,LocalCategoryMember.class);
    if (graph != null) {
      return graph;
    }
  }
  LocalCategoryGraphBuilder builder=new LocalCategoryGraphBuilder(localPageDao,this);
  CategoryGraph graph=builder.build(language);
  cache.put(key,graph);
  return graph;
}"
52909,"public CategoryBfs(CategoryGraph graph,int startCatId,Language language,int maxResults,TIntSet validWpIds,LocalCategoryMemberDao categoryMemberDao) throws DaoException {
  this.startPage=startCatId;
  this.maxResults=maxResults;
  this.graph=graph;
  this.validWpIds=validWpIds;
  this.categoryMemberDao=categoryMemberDao;
  this.language=language;
  pageDistances.put(startPage,0.000000);
  Map<Integer,LocalCategory> cats=categoryMemberDao.getCategories(language,startCatId);
  if (cats != null) {
    for (    int catId : categoryMemberDao.getCategories(language,startCatId).keySet()) {
      int ci=graph.getCategoryIndex(catId);
      if (ci >= 0) {
        openCats.add(new CategoryDistance(ci,graph.cats[ci],graph.catCosts[ci],(byte)+1));
      }
    }
  }
}","public CategoryBfs(CategoryGraph graph,int startId,NameSpace startNamespace,Language language,int maxResults,TIntSet validWpIds,LocalCategoryMemberDao categoryMemberDao,int direction) throws DaoException {
  this.startPage=startId;
  this.maxResults=maxResults;
  this.graph=graph;
  this.validWpIds=validWpIds;
  this.categoryMemberDao=categoryMemberDao;
  this.language=language;
  pageDistances.put(startPage,0.000000);
  if (startNamespace == NameSpace.ARTICLE) {
    Map<Integer,LocalCategory> cats=categoryMemberDao.getCategories(language,startId);
    if (cats != null) {
      for (      int catId : categoryMemberDao.getCategories(language,startId).keySet()) {
        int ci=graph.getCategoryIndex(catId);
        if (ci >= 0) {
          openCats.add(new CategoryDistance(ci,graph.cats[ci],graph.catCosts[ci],(byte)direction));
        }
      }
    }
  }
 else   if (startNamespace == NameSpace.CATEGORY) {
    int ci=graph.getCategoryIndex(startId);
    if (ci >= 0) {
      openCats.add(new CategoryDistance(ci,graph.cats[ci],0.000000001,(byte)direction));
    }
  }
 else {
    throw new IllegalArgumentException();
  }
}"
52910,"public boolean hasCategoryDistance(int categoryId){
  return catDistances.containsKey(categoryId);
}","public boolean hasCategoryDistance(int categoryId){
  return catDistances.containsKey(graph.getCategoryIndex(categoryId));
}"
52911,"public double getCategoryDistance(int categoryId){
  return catDistances.get(categoryId);
}","public double getCategoryDistance(int categoryId){
  return catDistances.get(graph.getCategoryIndex(categoryId));
}"
52912,"/** 
 * Will attempt to spatiotag left ot right with attributes. Need to write up this documentation.
 */
private void parseShapefile(LayerStruct struct) throws WikiBrainException {
  ShapefileReader shpReader;
  DbaseFileReader dbfReader;
  Geometry curGeometry;
  ShpFiles shpFile;
  LOG.log(Level.INFO,""String_Node_Str"" + struct.getDataFile().getName());
  try {
    shpFile=new ShpFiles(struct.getDataFile().getAbsolutePath());
    shpReader=new ShapefileReader(shpFile,true,true,new GeometryFactory(new PrecisionModel(),4326));
    dbfReader=new DbaseFileReader(shpFile,false,Charset.forName(""String_Node_Str""));
    int numDbfFields=dbfReader.getHeader().getNumFields();
    List<IDAttributeHandler> attrHandlers=Lists.newArrayList();
    for (int i=0; i < numDbfFields; i++) {
      attrHandlers.add(IDAttributeHandler.getHandlerByFieldName(dbfReader.getHeader().getFieldName(i),wdDao,analyzer));
    }
    int foundGeomCount=0;
    int missedGeomCount=0;
    while (shpReader.hasNext()) {
      curGeometry=(Geometry)shpReader.nextRecord().shape();
      dbfReader.read();
      int i=0;
      boolean found=false;
      while (i < numDbfFields && !found) {
        IDAttributeHandler attrHandler=attrHandlers.get(i);
        Integer itemId=attrHandler.getWikidataItemIdForId(dbfReader.readField(i));
        if (itemId != null && spatialDataDao.getGeometry(itemId,struct.getLayerName(),struct.getRefSysName()) == null) {
          spatialDataDao.saveGeometry(itemId,struct.getLayerName(),struct.getRefSysName(),curGeometry);
          found=true;
          foundGeomCount++;
          if (foundGeomCount % 10 == 0) {
            LOG.log(Level.INFO,""String_Node_Str"" + foundGeomCount + ""String_Node_Str""+ struct.getLayerName()+ ""String_Node_Str""+ struct.getRefSysName()+ ""String_Node_Str"");
          }
        }
        i++;
      }
      if (!found)       missedGeomCount++;
    }
    double matchRate=((double)foundGeomCount) / (foundGeomCount + missedGeomCount);
    LOG.log(Level.INFO,""String_Node_Str"" + struct.getLayerName() + ""String_Node_Str""+ matchRate);
    dbfReader.close();
    shpReader.close();
  }
 catch (  ShapefileException e) {
    throw new WikiBrainException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new WikiBrainException(""String_Node_Str"",e);
  }
catch (  DaoException e) {
    throw new WikiBrainException(e);
  }
}","/** 
 * Will attempt to spatiotag left ot right with attributes. Need to write up this documentation.
 */
private void parseShapefile(LayerStruct struct) throws WikiBrainException {
  ShapefileReader shpReader;
  DbaseFileReader dbfReader;
  Geometry curGeometry;
  ShpFiles shpFile;
  LOG.log(Level.INFO,""String_Node_Str"" + struct.getDataFile().getName());
  try {
    shpFile=new ShpFiles(struct.getDataFile().getAbsolutePath());
    shpReader=new ShapefileReader(shpFile,true,true,new GeometryFactory(new PrecisionModel(),4326));
    dbfReader=new DbaseFileReader(shpFile,false,Charset.forName(""String_Node_Str""));
    int numDbfFields=dbfReader.getHeader().getNumFields();
    List<IDAttributeHandler> attrHandlers=Lists.newArrayList();
    for (int i=0; i < numDbfFields; i++) {
      attrHandlers.add(IDAttributeHandler.getHandlerByFieldName(dbfReader.getHeader().getFieldName(i),wdDao,analyzer));
    }
    int foundGeomCount=0;
    int missedGeomCount=0;
    while (shpReader.hasNext()) {
      curGeometry=(Geometry)shpReader.nextRecord().shape();
      dbfReader.read();
      int i=0;
      boolean found=false;
      while (i < numDbfFields && !found) {
        IDAttributeHandler attrHandler=attrHandlers.get(i);
        Integer itemId;
        try {
          itemId=attrHandler.getWikidataItemIdForId(dbfReader.readField(i));
        }
 catch (        Exception e) {
          i++;
          continue;
        }
        if (itemId != null && spatialDataDao.getGeometry(itemId,struct.getLayerName(),struct.getRefSysName()) == null) {
          spatialDataDao.saveGeometry(itemId,struct.getLayerName(),struct.getRefSysName(),curGeometry);
          found=true;
          foundGeomCount++;
          if (foundGeomCount % 10 == 0) {
            LOG.log(Level.INFO,""String_Node_Str"" + foundGeomCount + ""String_Node_Str""+ struct.getLayerName()+ ""String_Node_Str""+ struct.getRefSysName()+ ""String_Node_Str"");
          }
        }
        i++;
      }
      if (!found)       missedGeomCount++;
    }
    double matchRate=((double)foundGeomCount) / (foundGeomCount + missedGeomCount);
    LOG.log(Level.INFO,""String_Node_Str"" + struct.getLayerName() + ""String_Node_Str""+ matchRate);
    dbfReader.close();
    shpReader.close();
  }
 catch (  ShapefileException e) {
    throw new WikiBrainException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new WikiBrainException(""String_Node_Str"",e);
  }
catch (  DaoException e) {
    throw new WikiBrainException(e);
  }
}"
52913,"public static void main(String args[]){
  try {
    Options options=new Options();
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    EnvBuilder.addStandardOptions(options);
    CommandLineParser parser=new PosixParser();
    CommandLine cmd;
    cmd=parser.parse(options,args);
    Env env=new EnvBuilder(cmd).build();
    Configurator conf=env.getConfigurator();
    String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
    String spatialDataFolderPath=cmd.getOptionValue(""String_Node_Str"",null);
    File spatialDataFolderFile;
    if (spatialDataFolderPath == null) {
      spatialDataFolderFile=new File(""String_Node_Str"");
    }
 else {
      spatialDataFolderFile=new File(spatialDataFolderPath);
    }
    SpatialDataFolder spatialDataFolder=new SpatialDataFolder(spatialDataFolderFile);
    WikidataDao wdDao=conf.get(WikidataDao.class);
    SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
    SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder,env.getLanguages());
    String stepsValue=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    String[] steps=stepsValue.split(""String_Node_Str"");
    for (    String step : steps) {
      if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadWikidataData();
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        GADMConverter.downloadAndConvert(spatialDataFolder);
        spatialDataFolder.deleteSpecificFile(""String_Node_Str"",RefSys.EARTH);
        spatialDataFolder.deleteLayer(""String_Node_Str"",RefSys.EARTH);
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadExogenousData();
      }
 else {
        throw new Exception(""String_Node_Str"" + step + ""String_Node_Str"");
      }
    }
    loader.loadWikidataData();
    loader.loadExogenousData();
    LOG.info(""String_Node_Str"");
    conf.get(WpDataSource.class).optimize();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String args[]){
  try {
    Options options=new Options();
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    options.addOption(""String_Node_Str"",true,""String_Node_Str"");
    EnvBuilder.addStandardOptions(options);
    CommandLineParser parser=new PosixParser();
    CommandLine cmd;
    cmd=parser.parse(options,args);
    Env env=new EnvBuilder(cmd).build();
    Configurator conf=env.getConfigurator();
    String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
    String spatialDataFolderPath=cmd.getOptionValue(""String_Node_Str"",null);
    File spatialDataFolderFile;
    if (spatialDataFolderPath == null) {
      spatialDataFolderFile=new File(""String_Node_Str"");
    }
 else {
      spatialDataFolderFile=new File(spatialDataFolderPath);
    }
    SpatialDataFolder spatialDataFolder=new SpatialDataFolder(spatialDataFolderFile);
    WikidataDao wdDao=conf.get(WikidataDao.class);
    SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
    SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder,env.getLanguages());
    String stepsValue=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    String[] steps=stepsValue.split(""String_Node_Str"");
    for (    String step : steps) {
      if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadWikidataData();
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        GADMConverter.downloadAndConvert(spatialDataFolder);
        spatialDataFolder.deleteSpecificFile(""String_Node_Str"",RefSys.EARTH);
        spatialDataFolder.deleteLayer(""String_Node_Str"",RefSys.EARTH);
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadExogenousData();
      }
 else {
        throw new Exception(""String_Node_Str"" + step + ""String_Node_Str"");
      }
    }
    LOG.info(""String_Node_Str"");
    conf.get(WpDataSource.class).optimize();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
52914,"@Override public Integer getWikidataItemIdForId(Object id) throws WikiBrainException {
  try {
    LinkedHashMap<LocalId,Float> candidate=analyzer.resolve(myLang,(String)id,1);
    if (candidate.size() == 0)     return null;
    LocalId li=candidate.keySet().iterator().next();
    return li.getId();
  }
 catch (  DaoException e) {
    throw new WikiBrainException(e);
  }
}","@Override public Integer getWikidataItemIdForId(Object id) throws WikiBrainException {
  try {
    LinkedHashMap<LocalId,Float> candidate=analyzer.resolve(myLang,(String)id,1);
    if (candidate.size() == 0)     return null;
    LocalId li=candidate.keySet().iterator().next();
    return wdDao.getItemId(li);
  }
 catch (  DaoException e) {
    throw new WikiBrainException(e);
  }
}"
52915,"/** 
 * Gets the item id for a given LocalPage (the number after ""Q"")
 * @param page
 * @return
 * @throws DaoException
 */
Integer getItemId(LocalPage page) throws DaoException ;",Integer getItemId(LocalId localId) throws DaoException ;
52916,"@Override public Integer getItemId(LocalPage page) throws DaoException {
  return upDao.getUnivPageId(page,WIKIDATA_ALGORITHM_ID);
}","@Override public Integer getItemId(LocalId localId) throws DaoException {
  return upDao.getUnivPageId(localId.getLanguage(),localId.getId(),WIKIDATA_ALGORITHM_ID);
}"
52917,"private void addWikidataIlls(LocalId input,Set<LocalId> curIlls){
  if (localId2ItemIdIndex.contains(input)) {
    Integer itemId=localId2ItemIdIndex.get(input);
    curIlls.addAll(itemId2LocalIdIndex.get(itemId));
  }
}","private void addWikidataIlls(LocalId input,Set<LocalId> curIlls){
  if (localId2ItemIdIndex.contains(input)) {
    Integer itemId=localId2ItemIdIndex.get(input);
    curIlls.addAll(itemId2LocalIdIndex.get(itemId));
    curIlls.remove(input);
  }
}"
52918,"@Override public List<ClusterResult> handle(List<LocalId> curVertices,ILLGraph graph,int componentId) throws WikiBrainException {
  ConceptualignHelper.ScanResult origScanResult=ConceptualignHelper.scanVerticesOfComponent(curVertices);
  boolean origNotAmbiguous=origScanResult.clarity.equals(1.0);
  if (origNotAmbiguous) {
    List<ClusterResult> rVal=Lists.newArrayList();
    rVal.add(new ClusterResult(getCurUnivId(),curVertices));
    return rVal;
  }
  if (print)   printAmbiguousCluster(curVertices);
  Map<LocalId,List<LocalId>> ills=new HashMap<LocalId,List<LocalId>>();
  for (  LocalId curVertex : curVertices) {
    Set<ILLEdge> edges=graph.outgoingEdgesOf(curVertex);
    List<LocalId> dests=new ArrayList<LocalId>();
    for (    ILLEdge edge : edges) {
      dests.add(edge.dest);
    }
    ills.put(curVertex,dests);
  }
  List<ClusterResult> rVal=new ArrayList<ClusterResult>();
  int minLangVotes=(int)Math.floor(minVotesRatio * origScanResult.langCount);
  Set<Set<LocalId>> clusters=ILLSplitter.split(ills,minLangVotes,maxVotesPerLang,print,lpDao);
  for (  Set<LocalId> curCluster : clusters) {
    int clusterUnivId=getCurUnivId();
    List<LocalId> vertexList=new ArrayList<LocalId>();
    vertexList.addAll(curCluster);
    ClusterResult clusterResult=new ClusterResult(clusterUnivId,vertexList);
    rVal.add(clusterResult);
  }
  return rVal;
}","@Override public List<ClusterResult> handle(List<LocalId> curVertices,ILLGraph graph,int componentId) throws WikiBrainException {
  ConceptualignHelper.ScanResult origScanResult=ConceptualignHelper.scanVerticesOfComponent(curVertices);
  boolean origNotAmbiguous=origScanResult.clarity.equals(1.0);
  if (origNotAmbiguous) {
    List<ClusterResult> rVal=Lists.newArrayList();
    rVal.add(new ClusterResult(getCurUnivId(),curVertices));
    return rVal;
  }
  if (print)   printAmbiguousCluster(curVertices);
  Map<LocalId,List<LocalId>> ills=new HashMap<LocalId,List<LocalId>>();
  for (  LocalId curVertex : curVertices) {
    Set<ILLEdge> edges=graph.outgoingEdgesOf(curVertex);
    List<LocalId> dests=new ArrayList<LocalId>();
    for (    ILLEdge edge : edges) {
      dests.add(edge.dest);
    }
    ills.put(curVertex,dests);
  }
  List<ClusterResult> rVal=new ArrayList<ClusterResult>();
  int minLangVotes=(int)Math.floor(minVotesRatio * origScanResult.langCount - 1);
  Set<Set<LocalId>> clusters=ILLSplitter.split(ills,minLangVotes,maxVotesPerLang,print,lpDao);
  for (  Set<LocalId> curCluster : clusters) {
    int clusterUnivId=getCurUnivId();
    List<LocalId> vertexList=new ArrayList<LocalId>();
    vertexList.addAll(curCluster);
    ClusterResult clusterResult=new ClusterResult(clusterUnivId,vertexList);
    rVal.add(clusterResult);
  }
  return rVal;
}"
52919,"@Override public Iterator<UniversalPage> getConceptMap(LanguageSet ls) throws WikiBrainException, DaoException {
  int maxEdge=2;
  double minLang=0.5;
  if (uPages == null) {
    LOG.log(Level.INFO,""String_Node_Str"");
    Iterator<UniversalPage> uPages=wdMapper.getConceptMap(ls);
  }
 else {
    if (!ls.equals(uPageLs)) {
      throw new WikiBrainException(""String_Node_Str"");
    }
  }
  CombinedIllDao combinedDao=new CombinedIllDao(uPages.iterator(),illDao);
  ILLGraph illGraph=new ILLGraph(combinedDao,localPageDao,miDao);
  BreadthFirstIterator<LocalId,ILLEdge> bfi=new BreadthFirstIterator<LocalId,ILLEdge>(illGraph);
  List<ConnectedComponentHandler> ccHandlers=new ArrayList<ConnectedComponentHandler>();
  ccHandlers.add(new Conceptualign3ConnectedComponentHandler(minLang,maxEdge,true,this.localPageDao));
  ConnectedComponentTraversalListener listener=new ConnectedComponentTraversalListener(illGraph,ccHandlers);
  bfi.addTraversalListener(listener);
  while (bfi.hasNext()) {
    LocalId localId=bfi.next();
  }
  return new MapperIterator<UniversalPage>(listener.getClusterResults()){
    @Override public UniversalPage transform(    Object obj){
      ClusterResult curCluster=(ClusterResult)obj;
      return new UniversalPage(curCluster.univId,getId(),NameSpace.ARTICLE,curCluster.vertices);
    }
  }
;
}","@Override public Iterator<UniversalPage> getConceptMap(LanguageSet ls) throws WikiBrainException, DaoException {
  int maxEdge=2;
  double minLang=1.0;
  if (uPages == null) {
    LOG.log(Level.INFO,""String_Node_Str"");
    Iterator<UniversalPage> uPages=wdMapper.getConceptMap(ls);
  }
 else {
    if (!ls.equals(uPageLs)) {
      throw new WikiBrainException(""String_Node_Str"");
    }
  }
  CombinedIllDao combinedDao=new CombinedIllDao(uPages.iterator(),illDao);
  ILLGraph illGraph=new ILLGraph(combinedDao,localPageDao,miDao);
  BreadthFirstIterator<LocalId,ILLEdge> bfi=new BreadthFirstIterator<LocalId,ILLEdge>(illGraph);
  List<ConnectedComponentHandler> ccHandlers=new ArrayList<ConnectedComponentHandler>();
  ccHandlers.add(new Conceptualign3ConnectedComponentHandler(minLang,maxEdge,true,this.localPageDao));
  ConnectedComponentTraversalListener listener=new ConnectedComponentTraversalListener(illGraph,ccHandlers);
  bfi.addTraversalListener(listener);
  while (bfi.hasNext()) {
    LocalId localId=bfi.next();
  }
  return new MapperIterator<UniversalPage>(listener.getClusterResults()){
    @Override public UniversalPage transform(    Object obj){
      ClusterResult curCluster=(ClusterResult)obj;
      return new UniversalPage(curCluster.univId,getId(),NameSpace.ARTICLE,curCluster.vertices);
    }
  }
;
}"
52920,"public static Set<Set<LocalId>> split(Map<LocalId,List<LocalId>> ills,int minVotes,int maxVotesPerLang,boolean print,LocalPageDao lpDao) throws WikiBrainException {
  HashMap<LocalId,SummingHashMap<Integer>> counter=new HashMap<LocalId,SummingHashMap<Integer>>();
  HashMap<LocalId,SummingHashMap<Integer>> outCounter=new HashMap<LocalId,SummingHashMap<Integer>>();
  HashMap<LocalId,LocalId> outFoundLinks=new HashMap<LocalId,LocalId>();
  for (  LocalId curSource : ills.keySet()) {
    outCounter.put(curSource,new SummingHashMap<Integer>());
    for (    LocalId curDest : ills.get(curSource)) {
      if (!outCounter.get(curSource).containsKey(curDest.getLanguage().getId())) {
        outCounter.get(curSource).addValue(new Integer(curDest.getLanguage().getId()),1.0);
        outFoundLinks.put(curSource,curDest);
      }
 else {
        if (!outFoundLinks.get(curSource).equals(curDest)) {
          outCounter.get(curSource).addValue(new Integer(curDest.getLanguage().getId()),1.0);
        }
      }
      if (!counter.containsKey(curDest)) {
        counter.put(curDest,new SummingHashMap<Integer>());
      }
      counter.get(curDest).addValue(new Integer(curSource.getLanguage().getId()),1.0);
    }
  }
  int edgeCounter=0;
  DirectedSparseGraph<LocalId,Integer> graph=new DirectedSparseGraph<LocalId,Integer>();
  for (  LocalId curSource : ills.keySet()) {
    graph.addVertex(curSource);
    for (    LocalId curDest : ills.get(curSource)) {
      if (outCounter.get(curSource).get(new Integer(curDest.getLanguage().getId())) <= maxVotesPerLang) {
        int totalVotes=counter.get(curDest).keySet().size();
        if (totalVotes >= minVotes) {
          if (counter.get(curDest).get(new Integer(curSource.getLanguage().getId())) <= maxVotesPerLang) {
            graph.addEdge(edgeCounter++,curSource,curDest);
          }
        }
      }
 else {
        LOG.warning(""String_Node_Str"" + ""String_Node_Str"" + curSource + ""String_Node_Str""+ curDest);
      }
    }
  }
  WeakComponentClusterer<LocalId,Integer> clusterer=new WeakComponentClusterer<LocalId,Integer>();
  Set<Set<LocalId>> clusters=clusterer.transform(graph);
  if (print) {
    int maxSize=0;
    Set<LocalId> maxCluster=null;
    for (    Set<LocalId> cluster : clusters) {
      StringBuilder sb=new StringBuilder();
      for (      LocalId clusterMemb : cluster) {
        try {
          sb.append(lpDao.getById(clusterMemb).getTitle().toString());
          sb.append(""String_Node_Str"");
        }
 catch (        DaoException e) {
          LOG.severe(""String_Node_Str"" + clusterMemb.toString());
        }
      }
      LOG.info(""String_Node_Str"" + sb.toString());
      maxSize=(maxSize > cluster.size()) ? maxSize : cluster.size();
      maxCluster=(maxSize > cluster.size()) ? maxCluster : cluster;
    }
    LOG.info(""String_Node_Str"" + clusters.size());
    LOG.info(""String_Node_Str"" + maxSize);
  }
  return clusters;
}","public static Set<Set<LocalId>> split(Map<LocalId,List<LocalId>> ills,int minVotes,int maxVotesPerLang,boolean print,LocalPageDao lpDao) throws WikiBrainException {
  HashMap<LocalId,SummingHashMap<Integer>> counter=new HashMap<LocalId,SummingHashMap<Integer>>();
  HashMap<LocalId,SummingHashMap<Integer>> outCounter=new HashMap<LocalId,SummingHashMap<Integer>>();
  HashMap<LocalId,LocalId> outFoundLinks=new HashMap<LocalId,LocalId>();
  for (  LocalId curSource : ills.keySet()) {
    outCounter.put(curSource,new SummingHashMap<Integer>());
    for (    LocalId curDest : ills.get(curSource)) {
      if (!outCounter.get(curSource).containsKey(curDest.getLanguage().getId())) {
        outCounter.get(curSource).addValue(new Integer(curDest.getLanguage().getId()),1.0);
        outFoundLinks.put(curSource,curDest);
      }
 else {
        if (!outFoundLinks.get(curSource).equals(curDest)) {
          outCounter.get(curSource).addValue(new Integer(curDest.getLanguage().getId()),1.0);
        }
      }
      if (!counter.containsKey(curDest)) {
        counter.put(curDest,new SummingHashMap<Integer>());
      }
      counter.get(curDest).addValue(new Integer(curSource.getLanguage().getId()),1.0);
    }
  }
  int edgeCounter=0;
  DirectedSparseGraph<LocalId,Integer> graph=new DirectedSparseGraph<LocalId,Integer>();
  for (  LocalId curSource : ills.keySet()) {
    graph.addVertex(curSource);
    for (    LocalId curDest : ills.get(curSource)) {
      if (outCounter.get(curSource).get(new Integer(curDest.getLanguage().getId())) <= maxVotesPerLang) {
        int totalVotes=counter.get(curDest).keySet().size();
        if (totalVotes >= minVotes) {
          if (counter.get(curDest).get(new Integer(curSource.getLanguage().getId())) <= maxVotesPerLang) {
            graph.addEdge(edgeCounter++,curSource,curDest);
          }
        }
 else {
          if (print) {
            try {
              LOG.info(""String_Node_Str"" + lpDao.getById(curSource).getTitle() + ""String_Node_Str""+ lpDao.getById(curDest).getTitle());
            }
 catch (            DaoException e) {
              throw new WikiBrainException(e);
            }
          }
        }
      }
 else {
        LOG.warning(""String_Node_Str"" + ""String_Node_Str"" + curSource + ""String_Node_Str""+ curDest);
      }
    }
  }
  WeakComponentClusterer<LocalId,Integer> clusterer=new WeakComponentClusterer<LocalId,Integer>();
  Set<Set<LocalId>> clusters=clusterer.transform(graph);
  if (print) {
    int maxSize=0;
    Set<LocalId> maxCluster=null;
    for (    Set<LocalId> cluster : clusters) {
      StringBuilder sb=new StringBuilder();
      for (      LocalId clusterMemb : cluster) {
        try {
          sb.append(lpDao.getById(clusterMemb).getTitle().toString());
          sb.append(""String_Node_Str"");
        }
 catch (        DaoException e) {
          LOG.severe(""String_Node_Str"" + clusterMemb.toString());
        }
      }
      LOG.info(""String_Node_Str"" + sb.toString());
      maxSize=(maxSize > cluster.size()) ? maxSize : cluster.size();
      maxCluster=(maxSize > cluster.size()) ? maxCluster : cluster;
    }
    LOG.info(""String_Node_Str"" + clusters.size());
    LOG.info(""String_Node_Str"" + maxSize);
  }
  return clusters;
}"
52921,"/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  HashMap<String,List<Geometry>> stateShape=new HashMap<String,List<Geometry>>();
  HashMap<String,String> stateCountry=new HashMap<String,String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  ShapefileReader shpReader;
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  try {
    map.put(""String_Node_Str"",rawFile.toURI().toURL());
    inputDataStore=DataStoreFinder.getDataStore(map);
    SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
    SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
    SimpleFeatureIterator inputFeatures=inputCollection.features();
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"");
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        String state=((String)feature.getAttribute(6)).intern();
        if (!stateShape.containsKey(state)) {
          stateShape.put(state,new ArrayList<Geometry>());
          stateCountry.put(state,country);
        }
        stateShape.get(state).add((Geometry)feature.getAttribute(0));
      }
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        if (!stateShape.containsKey(country))         stateShape.put(country,new ArrayList<Geometry>());
        stateShape.get(country).add((Geometry)feature.getAttribute(0));
      }
    }
    inputFeatures.close();
    inputDataStore.dispose();
    LOG.log(Level.INFO,""String_Node_Str"");
    typeBuilder=new SimpleFeatureTypeBuilder();
    typeBuilder.setName(""String_Node_Str"");
    typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
    typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
    typeBuilder.add(""String_Node_Str"",String.class);
    if (level == 1)     typeBuilder.add(""String_Node_Str"",String.class);
    typeBuilder.setDefaultGeometry(""String_Node_Str"");
    final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
    geometryFactory=JTSFactoryFinder.getGeometryFactory();
    featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
    LOG.log(Level.INFO,""String_Node_Str"");
    int count=0;
    if (level == 1) {
      int total=stateShape.keySet().size();
      for (      String state : stateCountry.keySet()) {
        try {
          count++;
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).union();
          featureBuilder.add(newGeom);
          featureBuilder.add(state);
          featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
          SimpleFeature feature=featureBuilder.buildFeature(null);
          if (count % 10 == 0)           LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
          features.add(feature);
          stateShape.remove(state);
          System.gc();
        }
 catch (        Exception e) {
          LOG.log(Level.INFO,""String_Node_Str"" + state + ""String_Node_Str""+ e.getMessage());
          stateShape.remove(state);
          System.gc();
          continue;
        }
      }
    }
 else {
      int total=stateShape.keySet().size();
      HashSet<String> countryList=new HashSet<String>();
      countryList.addAll(stateShape.keySet());
      for (      String country : countryList) {
        try {
          count++;
          LOG.log(Level.INFO,""String_Node_Str"" + stateShape.get(country).size() + ""String_Node_Str""+ country+ ""String_Node_Str""+ count+ ""String_Node_Str""+ total+ ""String_Node_Str"");
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).union();
          featureBuilder.add(newGeom);
          featureBuilder.add(country);
          SimpleFeature feature=featureBuilder.buildFeature(null);
          features.add(feature);
          stateShape.remove(country);
          System.gc();
        }
 catch (        Exception e) {
          LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ e.getMessage());
          stateShape.remove(country);
          System.gc();
          continue;
        }
      }
    }
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    }
    stateCountry=null;
    stateShape=null;
    System.gc();
    ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
    Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
    outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
    outputParams.put(""String_Node_Str"",Boolean.TRUE);
    ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
    outputDataStore.createSchema(WIKITYPE);
    Transaction transaction=new DefaultTransaction(""String_Node_Str"");
    String typeName=outputDataStore.getTypeNames()[0];
    SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
    SimpleFeatureType SHAPE_TYPE=outputFeatureSource.getSchema();
    LOG.log(Level.INFO,""String_Node_Str"" + outputFile.getCanonicalPath());
    if (outputFeatureSource instanceof SimpleFeatureStore) {
      SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
      SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
      featureStore.setTransaction(transaction);
      try {
        featureStore.addFeatures(collection);
        transaction.commit();
      }
 catch (      Exception e) {
        e.printStackTrace();
        transaction.rollback();
      }
 finally {
        transaction.close();
      }
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,typeName + ""String_Node_Str"");
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  HashMap<String,List<Geometry>> stateShape=new HashMap<String,List<Geometry>>();
  HashMap<String,String> stateCountry=new HashMap<String,String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  ShapefileReader shpReader;
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  try {
    map.put(""String_Node_Str"",rawFile.toURI().toURL());
    inputDataStore=DataStoreFinder.getDataStore(map);
    SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
    SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
    SimpleFeatureIterator inputFeatures=inputCollection.features();
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"");
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        String state=((String)feature.getAttribute(6)).intern();
        if (!stateShape.containsKey(state)) {
          stateShape.put(state,new ArrayList<Geometry>());
          stateCountry.put(state,country);
        }
        stateShape.get(state).add((Geometry)feature.getAttribute(0));
      }
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        if (!stateShape.containsKey(country))         stateShape.put(country,new ArrayList<Geometry>());
        stateShape.get(country).add((Geometry)feature.getAttribute(0));
      }
    }
    inputFeatures.close();
    inputDataStore.dispose();
    LOG.log(Level.INFO,""String_Node_Str"");
    typeBuilder=new SimpleFeatureTypeBuilder();
    typeBuilder.setName(""String_Node_Str"");
    typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
    typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
    typeBuilder.add(""String_Node_Str"",String.class);
    if (level == 1)     typeBuilder.add(""String_Node_Str"",String.class);
    typeBuilder.setDefaultGeometry(""String_Node_Str"");
    final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
    geometryFactory=JTSFactoryFinder.getGeometryFactory();
    featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
    LOG.log(Level.INFO,""String_Node_Str"");
    int count=0;
    if (level == 1) {
      int total=stateShape.keySet().size();
      for (      String state : stateCountry.keySet()) {
        count++;
        try {
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).union();
          featureBuilder.add(newGeom);
          featureBuilder.add(state);
          featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
          SimpleFeature feature=featureBuilder.buildFeature(null);
          if (count % 10 == 0)           LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
          features.add(feature);
          stateShape.remove(state);
          System.gc();
        }
 catch (        Exception e) {
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).buffer(0);
          featureBuilder.add(newGeom);
          featureBuilder.add(state);
          featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
          SimpleFeature feature=featureBuilder.buildFeature(null);
          if (count % 10 == 0)           LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
          features.add(feature);
          LOG.log(Level.INFO,""String_Node_Str"" + state + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
          stateShape.remove(state);
          System.gc();
          continue;
        }
      }
    }
 else {
      int total=stateShape.keySet().size();
      HashSet<String> countryList=new HashSet<String>();
      countryList.addAll(stateShape.keySet());
      for (      String country : countryList) {
        count++;
        try {
          LOG.log(Level.INFO,""String_Node_Str"" + stateShape.get(country).size() + ""String_Node_Str""+ country+ ""String_Node_Str""+ count+ ""String_Node_Str""+ total+ ""String_Node_Str"");
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).union();
          featureBuilder.add(newGeom);
          featureBuilder.add(country);
          SimpleFeature feature=featureBuilder.buildFeature(null);
          features.add(feature);
          stateShape.remove(country);
          System.gc();
        }
 catch (        Exception e) {
          LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).buffer(0);
          featureBuilder.add(newGeom);
          featureBuilder.add(country);
          SimpleFeature feature=featureBuilder.buildFeature(null);
          features.add(feature);
          stateShape.remove(country);
          System.gc();
          continue;
        }
      }
    }
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    }
    stateCountry=null;
    stateShape=null;
    System.gc();
    ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
    Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
    outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
    outputParams.put(""String_Node_Str"",Boolean.TRUE);
    ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
    outputDataStore.createSchema(WIKITYPE);
    Transaction transaction=new DefaultTransaction(""String_Node_Str"");
    String typeName=outputDataStore.getTypeNames()[0];
    SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
    SimpleFeatureType SHAPE_TYPE=outputFeatureSource.getSchema();
    LOG.log(Level.INFO,""String_Node_Str"" + outputFile.getCanonicalPath());
    if (outputFeatureSource instanceof SimpleFeatureStore) {
      SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
      SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
      featureStore.setTransaction(transaction);
      try {
        featureStore.addFeatures(collection);
        transaction.commit();
      }
 catch (      Exception e) {
        e.printStackTrace();
        transaction.rollback();
      }
 finally {
        transaction.close();
      }
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,typeName + ""String_Node_Str"");
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}"
52922,"protected static CharArraySet getStopWordsForNonLuceneLangFromFile(Version version,Language language){
  try {
    String langCode=language.getLangCode();
    String fileName=STOP_WORDS + langCode + ""String_Node_Str"";
    InputStream stream=FileUtils.openInputStream(new File(fileName));
    List<String> stopWords=org.apache.commons.io.IOUtils.readLines(stream);
    CharArraySet charArraySet=new CharArraySet(version,0,false);
    for (    String stopWord : stopWords) {
      charArraySet.add(stopWord);
    }
    return charArraySet;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","protected static CharArraySet getStopWordsForNonLuceneLangFromFile(Version version,Language language){
  try {
    String langCode=language.getLangCode();
    String fileName=STOP_WORDS + langCode + ""String_Node_Str"";
    CharArraySet charArraySet=new CharArraySet(version,0,false);
    File stopWordsFile=new File(fileName);
    if (stopWordsFile.exists()) {
      InputStream stream=FileUtils.openInputStream(new File(fileName));
      List<String> stopWords=org.apache.commons.io.IOUtils.readLines(stream);
      for (      String stopWord : stopWords) {
        charArraySet.add(stopWord);
      }
    }
    return charArraySet;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
52923,"public static void main(String[] args) throws WikiBrainException {
  GADMConverter converter=new GADMConverter();
  converter.downloadAndConvert(new SpatialDataFolder(new File(""String_Node_Str"")));
}","public static void main(String[] args) throws WikiBrainException, IOException {
  GADMConverter converter=new GADMConverter();
  converter.downloadAndConvert(new SpatialDataFolder(new File(""String_Node_Str"")));
}"
52924,"/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  HashMap<String,List<Geometry>> stateShape=new HashMap<String,List<Geometry>>();
  HashMap<String,String> stateCountry=new HashMap<String,String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  ShapefileReader shpReader;
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  try {
    map.put(""String_Node_Str"",rawFile.toURI().toURL());
    inputDataStore=DataStoreFinder.getDataStore(map);
    SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
    SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
    SimpleFeatureIterator inputFeatures=inputCollection.features();
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"");
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        String state=((String)feature.getAttribute(6)).intern();
        if (!stateShape.containsKey(state)) {
          stateShape.put(state,new ArrayList<Geometry>());
          stateCountry.put(state,country);
        }
        stateShape.get(state).add((Geometry)feature.getAttribute(0));
      }
    }
 else {
      while (inputFeatures.hasNext()) {
        LOG.log(Level.INFO,""String_Node_Str"");
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        if (!stateShape.containsKey(country))         stateShape.put(country,new ArrayList<Geometry>());
        stateShape.get(country).add((Geometry)feature.getAttribute(0));
      }
    }
    inputFeatures.close();
    inputDataStore.dispose();
    LOG.log(Level.INFO,""String_Node_Str"");
    typeBuilder=new SimpleFeatureTypeBuilder();
    typeBuilder.setName(""String_Node_Str"");
    typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
    typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
    typeBuilder.add(""String_Node_Str"",String.class);
    if (level == 1)     typeBuilder.add(""String_Node_Str"",String.class);
    typeBuilder.setDefaultGeometry(""String_Node_Str"");
    final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
    geometryFactory=JTSFactoryFinder.getGeometryFactory();
    featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
    LOG.log(Level.INFO,""String_Node_Str"");
    int count=0;
    if (level == 1) {
      int total=stateShape.keySet().size();
      for (      String state : stateCountry.keySet()) {
        try {
          count++;
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).union();
          featureBuilder.add(newGeom);
          featureBuilder.add(state);
          featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
          SimpleFeature feature=featureBuilder.buildFeature(null);
          if (count % 10 == 0)           LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
          features.add(feature);
          stateShape.remove(state);
          System.gc();
        }
 catch (        Exception e) {
          LOG.log(Level.INFO,""String_Node_Str"" + state + ""String_Node_Str""+ e.getMessage());
          stateShape.remove(state);
          System.gc();
          continue;
        }
      }
    }
 else {
      int total=stateShape.keySet().size();
      for (      String country : stateShape.keySet()) {
        try {
          count++;
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).union();
          featureBuilder.add(newGeom);
          featureBuilder.add(country);
          SimpleFeature feature=featureBuilder.buildFeature(null);
          if (count % 10 == 0)           LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
          features.add(feature);
          stateShape.remove(country);
          System.gc();
        }
 catch (        Exception e) {
          LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ e.getMessage());
          stateShape.remove(country);
          System.gc();
          continue;
        }
      }
    }
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    }
    stateCountry=null;
    stateShape=null;
    System.gc();
    ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
    Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
    outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
    outputParams.put(""String_Node_Str"",Boolean.TRUE);
    ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
    outputDataStore.createSchema(WIKITYPE);
    Transaction transaction=new DefaultTransaction(""String_Node_Str"");
    String typeName=outputDataStore.getTypeNames()[0];
    SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
    SimpleFeatureType SHAPE_TYPE=outputFeatureSource.getSchema();
    LOG.log(Level.INFO,""String_Node_Str"" + outputFile.getCanonicalPath());
    if (outputFeatureSource instanceof SimpleFeatureStore) {
      SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
      SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
      featureStore.setTransaction(transaction);
      try {
        featureStore.addFeatures(collection);
        transaction.commit();
      }
 catch (      Exception e) {
        e.printStackTrace();
        transaction.rollback();
      }
 finally {
        transaction.close();
      }
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,typeName + ""String_Node_Str"");
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  HashMap<String,List<Geometry>> stateShape=new HashMap<String,List<Geometry>>();
  HashMap<String,String> stateCountry=new HashMap<String,String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  ShapefileReader shpReader;
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  try {
    map.put(""String_Node_Str"",rawFile.toURI().toURL());
    inputDataStore=DataStoreFinder.getDataStore(map);
    SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
    SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
    SimpleFeatureIterator inputFeatures=inputCollection.features();
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"");
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        String state=((String)feature.getAttribute(6)).intern();
        if (!stateShape.containsKey(state)) {
          stateShape.put(state,new ArrayList<Geometry>());
          stateCountry.put(state,country);
        }
        stateShape.get(state).add((Geometry)feature.getAttribute(0));
      }
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"");
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        if (!stateShape.containsKey(country))         stateShape.put(country,new ArrayList<Geometry>());
        stateShape.get(country).add((Geometry)feature.getAttribute(0));
      }
    }
    inputFeatures.close();
    inputDataStore.dispose();
    LOG.log(Level.INFO,""String_Node_Str"");
    typeBuilder=new SimpleFeatureTypeBuilder();
    typeBuilder.setName(""String_Node_Str"");
    typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
    typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
    typeBuilder.add(""String_Node_Str"",String.class);
    if (level == 1)     typeBuilder.add(""String_Node_Str"",String.class);
    typeBuilder.setDefaultGeometry(""String_Node_Str"");
    final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
    geometryFactory=JTSFactoryFinder.getGeometryFactory();
    featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
    LOG.log(Level.INFO,""String_Node_Str"");
    int count=0;
    if (level == 1) {
      int total=stateShape.keySet().size();
      for (      String state : stateCountry.keySet()) {
        try {
          count++;
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).union();
          featureBuilder.add(newGeom);
          featureBuilder.add(state);
          featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
          SimpleFeature feature=featureBuilder.buildFeature(null);
          if (count % 10 == 0)           LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
          features.add(feature);
          stateShape.remove(state);
          System.gc();
        }
 catch (        Exception e) {
          LOG.log(Level.INFO,""String_Node_Str"" + state + ""String_Node_Str""+ e.getMessage());
          stateShape.remove(state);
          System.gc();
          continue;
        }
      }
    }
 else {
      int total=stateShape.keySet().size();
      HashSet<String> countryList=new HashSet<String>();
      countryList.addAll(stateShape.keySet());
      for (      String country : countryList) {
        try {
          count++;
          LOG.log(Level.INFO,""String_Node_Str"" + stateShape.get(country).size() + ""String_Node_Str""+ country+ ""String_Node_Str""+ count+ ""String_Node_Str""+ total+ ""String_Node_Str"");
          Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).union();
          featureBuilder.add(newGeom);
          featureBuilder.add(country);
          SimpleFeature feature=featureBuilder.buildFeature(null);
          features.add(feature);
          stateShape.remove(country);
          System.gc();
        }
 catch (        Exception e) {
          LOG.log(Level.INFO,""String_Node_Str"" + country + ""String_Node_Str""+ e.getMessage());
          stateShape.remove(country);
          System.gc();
          continue;
        }
      }
    }
    if (level == 1) {
      LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    }
    stateCountry=null;
    stateShape=null;
    System.gc();
    ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
    Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
    outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
    outputParams.put(""String_Node_Str"",Boolean.TRUE);
    ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
    outputDataStore.createSchema(WIKITYPE);
    Transaction transaction=new DefaultTransaction(""String_Node_Str"");
    String typeName=outputDataStore.getTypeNames()[0];
    SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
    SimpleFeatureType SHAPE_TYPE=outputFeatureSource.getSchema();
    LOG.log(Level.INFO,""String_Node_Str"" + outputFile.getCanonicalPath());
    if (outputFeatureSource instanceof SimpleFeatureStore) {
      SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
      SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
      featureStore.setTransaction(transaction);
      try {
        featureStore.addFeatures(collection);
        transaction.commit();
      }
 catch (      Exception e) {
        e.printStackTrace();
        transaction.rollback();
      }
 finally {
        transaction.close();
      }
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,typeName + ""String_Node_Str"");
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}"
52925,"public static void main(String[] args) throws WikiBrainException {
  GADMConverter converter=new GADMConverter();
  converter.downloadAndConvert(new SpatialDataFolder(new File(""String_Node_Str"")));
}","public static void main(String[] args) throws WikiBrainException {
  GADMConverter converter=new GADMConverter();
  converter.downloadAndConvert(new File(""String_Node_Str""));
}"
52926,"public static void downloadAndConvert(SpatialDataFolder folder) throws WikiBrainException {
  try {
    WpIOUtils ioUtils=new WpIOUtils();
    String tmpFolderName=""String_Node_Str"";
    File tmpFolder=WpIOUtils.createTempDirectory(tmpFolderName,true);
    folder.createNewReferenceSystemIfNotExists(tmpFolder.getCanonicalPath());
    File rawFile=downloadGADMShapeFile(tmpFolder.getCanonicalPath());
  }
 catch (  IOException e) {
    throw new WikiBrainException(e);
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public static void downloadAndConvert(File folder) throws WikiBrainException {
  try {
    SpatialDataFolder baseFolder=new SpatialDataFolder(folder);
    WpIOUtils ioUtils=new WpIOUtils();
    String tmpFolderName=""String_Node_Str"";
    File tmpFolder=WpIOUtils.createTempDirectory(tmpFolderName,true);
    File rawFile=downloadGADMShapeFile(tmpFolder.getCanonicalPath());
    FileUtils.copyDirectory(new File(tmpFolder.getCanonicalPath() + ""String_Node_Str""),baseFolder.getRefSysFolder(""String_Node_Str""));
    convertShpFile(rawFile,baseFolder,1);
    convertShpFile(rawFile,baseFolder,0);
  }
 catch (  IOException e) {
    throw new WikiBrainException(e);
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
52927,"/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException {
  if ((level != 0) || (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File file=rawFile;
  File outputFile;
  Map map=new HashMap();
  HashMap<String,List<Geometry>> stateShape=new HashMap<String,List<Geometry>>();
  HashMap<String,String> stateCountry=new HashMap<String,String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  ShapefileReader shpReader;
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  try {
    map.put(""String_Node_Str"",file.toURI().toURL());
    inputDataStore=DataStoreFinder.getDataStore(map);
    SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
    SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
    SimpleFeatureIterator inputFeatures=inputCollection.features();
    LOG.log(Level.INFO,""String_Node_Str"");
    if (level == 1) {
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        String state=((String)feature.getAttribute(6)).intern();
        if (!stateShape.containsKey(state)) {
          stateShape.put(state,new ArrayList<Geometry>());
          stateCountry.put(state,country);
        }
        stateShape.get(state).add((Geometry)feature.getAttribute(0));
      }
    }
 else {
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        if (!stateShape.containsKey(country))         stateShape.put(country,new ArrayList<Geometry>());
        stateShape.get(country).add((Geometry)feature.getAttribute(0));
      }
    }
    inputFeatures.close();
    inputDataStore.dispose();
    LOG.log(Level.INFO,""String_Node_Str"");
    typeBuilder=new SimpleFeatureTypeBuilder();
    typeBuilder.setName(""String_Node_Str"");
    typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
    typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
    typeBuilder.add(""String_Node_Str"",String.class);
    if (level == 1)     typeBuilder.add(""String_Node_Str"",String.class);
    typeBuilder.setDefaultGeometry(""String_Node_Str"");
    final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
    geometryFactory=JTSFactoryFinder.getGeometryFactory();
    featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
    LOG.log(Level.INFO,""String_Node_Str"");
    int count=0;
    if (level == 1) {
      int total=stateShape.keySet().size();
      for (      String state : stateCountry.keySet()) {
        count++;
        Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).union();
        featureBuilder.add(newGeom);
        featureBuilder.add(state);
        featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
        SimpleFeature feature=featureBuilder.buildFeature(null);
        if (count % 50 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        features.add(feature);
        stateShape.remove(state);
        System.gc();
      }
    }
 else {
      int total=stateShape.keySet().size();
      for (      String country : stateShape.keySet()) {
        count++;
        Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).union();
        featureBuilder.add(newGeom);
        featureBuilder.add(country);
        SimpleFeature feature=featureBuilder.buildFeature(null);
        if (count % 50 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        features.add(feature);
        stateShape.remove(country);
        System.gc();
      }
    }
    LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    stateCountry=null;
    stateShape=null;
    System.gc();
    ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
    Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
    outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
    outputParams.put(""String_Node_Str"",Boolean.TRUE);
    ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
    outputDataStore.createSchema(WIKITYPE);
    Transaction transaction=new DefaultTransaction(""String_Node_Str"");
    String typeName=outputDataStore.getTypeNames()[0];
    SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
    SimpleFeatureType SHAPE_TYPE=outputFeatureSource.getSchema();
    LOG.log(Level.INFO,""String_Node_Str"" + outputFile.getCanonicalPath());
    if (outputFeatureSource instanceof SimpleFeatureStore) {
      SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
      SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
      featureStore.setTransaction(transaction);
      try {
        featureStore.addFeatures(collection);
        transaction.commit();
      }
 catch (      Exception e) {
        e.printStackTrace();
        transaction.rollback();
      }
 finally {
        transaction.close();
      }
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,typeName + ""String_Node_Str"");
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException {
  if ((level != 0) || (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  HashMap<String,List<Geometry>> stateShape=new HashMap<String,List<Geometry>>();
  HashMap<String,String> stateCountry=new HashMap<String,String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  ShapefileReader shpReader;
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  try {
    map.put(""String_Node_Str"",rawFile.toURI().toURL());
    inputDataStore=DataStoreFinder.getDataStore(map);
    SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
    SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
    SimpleFeatureIterator inputFeatures=inputCollection.features();
    LOG.log(Level.INFO,""String_Node_Str"");
    if (level == 1) {
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        String state=((String)feature.getAttribute(6)).intern();
        if (!stateShape.containsKey(state)) {
          stateShape.put(state,new ArrayList<Geometry>());
          stateCountry.put(state,country);
        }
        stateShape.get(state).add((Geometry)feature.getAttribute(0));
      }
    }
 else {
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        if (!stateShape.containsKey(country))         stateShape.put(country,new ArrayList<Geometry>());
        stateShape.get(country).add((Geometry)feature.getAttribute(0));
      }
    }
    inputFeatures.close();
    inputDataStore.dispose();
    LOG.log(Level.INFO,""String_Node_Str"");
    typeBuilder=new SimpleFeatureTypeBuilder();
    typeBuilder.setName(""String_Node_Str"");
    typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
    typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
    typeBuilder.add(""String_Node_Str"",String.class);
    if (level == 1)     typeBuilder.add(""String_Node_Str"",String.class);
    typeBuilder.setDefaultGeometry(""String_Node_Str"");
    final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
    geometryFactory=JTSFactoryFinder.getGeometryFactory();
    featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
    LOG.log(Level.INFO,""String_Node_Str"");
    int count=0;
    if (level == 1) {
      int total=stateShape.keySet().size();
      for (      String state : stateCountry.keySet()) {
        count++;
        Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).union();
        featureBuilder.add(newGeom);
        featureBuilder.add(state);
        featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
        SimpleFeature feature=featureBuilder.buildFeature(null);
        if (count % 50 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        features.add(feature);
        stateShape.remove(state);
        System.gc();
      }
    }
 else {
      int total=stateShape.keySet().size();
      for (      String country : stateShape.keySet()) {
        count++;
        Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).union();
        featureBuilder.add(newGeom);
        featureBuilder.add(country);
        SimpleFeature feature=featureBuilder.buildFeature(null);
        if (count % 50 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        features.add(feature);
        stateShape.remove(country);
        System.gc();
      }
    }
    LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    stateCountry=null;
    stateShape=null;
    System.gc();
    ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
    Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
    outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
    outputParams.put(""String_Node_Str"",Boolean.TRUE);
    ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
    outputDataStore.createSchema(WIKITYPE);
    Transaction transaction=new DefaultTransaction(""String_Node_Str"");
    String typeName=outputDataStore.getTypeNames()[0];
    SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
    SimpleFeatureType SHAPE_TYPE=outputFeatureSource.getSchema();
    LOG.log(Level.INFO,""String_Node_Str"" + outputFile.getCanonicalPath());
    if (outputFeatureSource instanceof SimpleFeatureStore) {
      SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
      SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
      featureStore.setTransaction(transaction);
      try {
        featureStore.addFeatures(collection);
        transaction.commit();
      }
 catch (      Exception e) {
        e.printStackTrace();
        transaction.rollback();
      }
 finally {
        transaction.close();
      }
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,typeName + ""String_Node_Str"");
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}"
52928,"public static void main(String args[]){
  try {
    Options options=new Options();
    options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
    options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
    options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
    EnvBuilder.addStandardOptions(options);
    CommandLineParser parser=new PosixParser();
    CommandLine cmd;
    try {
      cmd=parser.parse(options,args);
    }
 catch (    ParseException e) {
      System.err.println(""String_Node_Str"" + e.getMessage());
      new HelpFormatter().printHelp(""String_Node_Str"",options);
      return;
    }
    Env env=new EnvBuilder(cmd).build();
    Configurator conf=env.getConfigurator();
    String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
    String spatialDataFolderPath=cmd.getOptionValue('f',null);
    File spatialDataFolder;
    if (spatialDataFolderPath == null) {
      spatialDataFolder=WpIOUtils.createTempDirectory(""String_Node_Str"",false);
    }
 else {
      spatialDataFolder=new File(spatialDataFolderPath);
    }
    WikidataDao wdDao=conf.get(WikidataDao.class);
    SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
    SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder,env.getLanguages());
    String stepsValue=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    String[] steps=stepsValue.split(""String_Node_Str"");
    for (    String step : steps) {
      if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadWikidataData();
      }
      if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadExogenousData();
      }
 else {
        throw new Exception(""String_Node_Str"" + step + ""String_Node_Str"");
      }
    }
    LOG.info(""String_Node_Str"");
    conf.get(WpDataSource.class).optimize();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String args[]){
  try {
    Options options=new Options();
    options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
    options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
    options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
    EnvBuilder.addStandardOptions(options);
    CommandLineParser parser=new PosixParser();
    CommandLine cmd;
    try {
      cmd=parser.parse(options,args);
    }
 catch (    ParseException e) {
      System.err.println(""String_Node_Str"" + e.getMessage());
      new HelpFormatter().printHelp(""String_Node_Str"",options);
      return;
    }
    Env env=new EnvBuilder(cmd).build();
    Configurator conf=env.getConfigurator();
    String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
    String spatialDataFolderPath=cmd.getOptionValue('f',null);
    File spatialDataFolder;
    if (spatialDataFolderPath == null) {
      spatialDataFolder=WpIOUtils.createTempDirectory(""String_Node_Str"",false);
    }
 else {
      spatialDataFolder=new File(spatialDataFolderPath);
    }
    WikidataDao wdDao=conf.get(WikidataDao.class);
    SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
    SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder,env.getLanguages());
    String stepsValue=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
    String[] steps=stepsValue.split(""String_Node_Str"");
    for (    String step : steps) {
      if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadWikidataData();
      }
      if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        GADMConverter.downloadAndConvert(spatialDataFolder);
      }
 else       if (step.trim().toLowerCase().equals(""String_Node_Str"")) {
        LOG.log(Level.INFO,""String_Node_Str"");
        loader.loadExogenousData();
      }
 else {
        throw new Exception(""String_Node_Str"" + step + ""String_Node_Str"");
      }
    }
    LOG.info(""String_Node_Str"");
    conf.get(WpDataSource.class).optimize();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
52929,"public static void downloadAndConvert(SpatialDataFolder folder) throws WikiBrainException {
  try {
    WpIOUtils ioUtils=new WpIOUtils();
    String tmpFolderName=""String_Node_Str"";
    File tmpFolder=WpIOUtils.createTempDirectory(tmpFolderName,true);
    File rawFile=downloadGADMShapeFile(tmpFolder.getCanonicalPath());
    FileUtils.copyDirectory(new File(tmpFolder.getCanonicalPath() + ""String_Node_Str""),folder.getRefSysFolder(""String_Node_Str""));
    convertShpFile(rawFile,folder,1);
    convertShpFile(rawFile,folder,0);
  }
 catch (  IOException e) {
    throw new WikiBrainException(e);
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public static void downloadAndConvert(SpatialDataFolder folder) throws WikiBrainException {
  try {
    WpIOUtils ioUtils=new WpIOUtils();
    String tmpFolderName=""String_Node_Str"";
    File tmpFolder=WpIOUtils.createTempDirectory(tmpFolderName,true);
    File rawFile=downloadGADMShapeFile(tmpFolder.getCanonicalPath());
    LOG.log(Level.INFO,""String_Node_Str"" + folder.getRefSysFolder(""String_Node_Str"").getCanonicalPath());
    FileUtils.copyDirectory(new File(tmpFolder.getCanonicalPath()),folder.getRefSysFolder(""String_Node_Str""));
    LOG.log(Level.INFO,""String_Node_Str"");
    convertShpFile(rawFile,folder,1);
    LOG.log(Level.INFO,""String_Node_Str"");
    convertShpFile(rawFile,folder,0);
  }
 catch (  IOException e) {
    throw new WikiBrainException(e);
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
52930,"/** 
 * Download GADM shape file
 * @param tmpFolder
 * @return
 */
public static File downloadGADMShapeFile(String tmpFolder) throws IOException, ZipException, InterruptedException {
  String baseFileName=""String_Node_Str"";
  String zipFileName=baseFileName + ""String_Node_Str"";
  String gadmURL=""String_Node_Str"" + zipFileName;
  Collection<File> tmpFileList;
  File existingFile=null, f=null;
  boolean found=false;
  tmpFileList=FileUtils.listFiles(new File(new File(tmpFolder).getParent()),null,true);
  for (  File file : tmpFileList)   if (file.getName().equals(""String_Node_Str"")) {
    found=true;
    existingFile=file;
    break;
  }
  if (!found) {
    File gadmShapeFile=new File(tmpFolder + ""String_Node_Str"" + zipFileName);
    FileDownloader downloader=new FileDownloader();
    downloader.download(new URL(gadmURL),gadmShapeFile);
    ZipFile zipFile=new ZipFile(gadmShapeFile.getCanonicalPath());
    LOG.log(Level.INFO,""String_Node_Str"" + gadmShapeFile.getParent());
    zipFile.extractAll(gadmShapeFile.getParent());
    f=new File(tmpFolder + ""String_Node_Str"");
    LOG.log(Level.INFO,""String_Node_Str"");
    return f;
  }
  ZipFile zipFile=new ZipFile(existingFile.getCanonicalPath());
  LOG.log(Level.INFO,""String_Node_Str"" + existingFile.getParent());
  zipFile.extractAll(existingFile.getParent());
  f=new File(existingFile.getCanonicalPath() + ""String_Node_Str"");
  LOG.log(Level.INFO,""String_Node_Str"");
  return f;
}","/** 
 * Download GADM shape file
 * @param tmpFolder
 * @return
 */
public static File downloadGADMShapeFile(String tmpFolder) throws IOException, ZipException, InterruptedException {
  String baseFileName=""String_Node_Str"";
  String zipFileName=baseFileName + ""String_Node_Str"";
  String gadmURL=""String_Node_Str"" + zipFileName;
  File gadmShapeFile=new File(tmpFolder + ""String_Node_Str"" + zipFileName);
  FileDownloader downloader=new FileDownloader();
  downloader.download(new URL(gadmURL),gadmShapeFile);
  ZipFile zipFile=new ZipFile(gadmShapeFile.getCanonicalPath());
  LOG.log(Level.INFO,""String_Node_Str"" + gadmShapeFile.getParent());
  zipFile.extractAll(gadmShapeFile.getParent());
  File f=new File(tmpFolder + ""String_Node_Str"");
  LOG.log(Level.INFO,""String_Node_Str"");
  gadmShapeFile.delete();
  return f;
}"
52931,"public static void downloadAndConvert(File folder) throws WikiBrainException {
  try {
    SpatialDataFolder baseFolder=new SpatialDataFolder(folder);
    WpIOUtils ioUtils=new WpIOUtils();
    String tmpFolderName=""String_Node_Str"";
    File tmpFolder=WpIOUtils.createTempDirectory(tmpFolderName,true);
    File rawFile=downloadGADMShapeFile(tmpFolder.getCanonicalPath());
    FileUtils.copyDirectory(new File(tmpFolder.getCanonicalPath() + ""String_Node_Str""),baseFolder.getRefSysFolder(""String_Node_Str""));
    convertShpFile(rawFile,baseFolder,1);
    convertShpFile(rawFile,baseFolder,0);
  }
 catch (  IOException e) {
    throw new WikiBrainException(e);
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public static void downloadAndConvert(File folder) throws WikiBrainException {
  try {
    SpatialDataFolder baseFolder=new SpatialDataFolder(folder);
    WpIOUtils ioUtils=new WpIOUtils();
    String tmpFolderName=""String_Node_Str"";
    String[] search={""String_Node_Str""};
    File tmpFolder=WpIOUtils.createTempDirectory(tmpFolderName,true);
    File rawFile=downloadGADMShapeFile(tmpFolder.getCanonicalPath());
    LOG.log(Level.INFO,""String_Node_Str"" + folder.getCanonicalPath());
    FileUtils.copyDirectory(new File(rawFile.getParent()),baseFolder.getRefSysFolder(""String_Node_Str""));
    convertShpFile(rawFile,baseFolder,1);
    convertShpFile(rawFile,baseFolder,0);
  }
 catch (  IOException e) {
    throw new WikiBrainException(e);
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
52932,"/** 
 * Download GADM shape file
 * @param tmpFolder
 * @return
 */
public static File downloadGADMShapeFile(String tmpFolder) throws IOException, ZipException, InterruptedException {
  String baseFileName=""String_Node_Str"";
  String zipFileName=baseFileName + ""String_Node_Str"";
  String gadmURL=""String_Node_Str"" + zipFileName;
  File gadmShapeFile=new File(tmpFolder + ""String_Node_Str"" + zipFileName);
  FileDownloader downloader=new FileDownloader();
  if (gadmShapeFile.exists() && !gadmShapeFile.isDirectory())   gadmShapeFile.delete();
  downloader.download(new URL(gadmURL),gadmShapeFile);
  ZipFile zipFile=new ZipFile(gadmShapeFile.getCanonicalPath());
  LOG.log(Level.INFO,""String_Node_Str"" + gadmShapeFile.getParent() + ""String_Node_Str"");
  zipFile.extractAll(gadmShapeFile.getParent());
  File f=new File(tmpFolder + ""String_Node_Str"" + ""String_Node_Str"");
  LOG.log(Level.INFO,""String_Node_Str"");
  gadmShapeFile.delete();
  return f;
}","/** 
 * Download GADM shape file
 * @param tmpFolder
 * @return
 */
public static File downloadGADMShapeFile(String tmpFolder) throws IOException, ZipException, InterruptedException {
  String baseFileName=""String_Node_Str"";
  String zipFileName=baseFileName + ""String_Node_Str"";
  String gadmURL=""String_Node_Str"" + zipFileName;
  Collection<File> tmpFileList;
  File existingFile=null, f=null;
  boolean found=false;
  tmpFileList=FileUtils.listFiles(new File(new File(tmpFolder).getParent()),null,true);
  for (  File file : tmpFileList)   if (file.getName().equals(""String_Node_Str"")) {
    found=true;
    existingFile=file;
    break;
  }
  if (!found) {
    File gadmShapeFile=new File(tmpFolder + ""String_Node_Str"" + zipFileName);
    FileDownloader downloader=new FileDownloader();
    downloader.download(new URL(gadmURL),gadmShapeFile);
    ZipFile zipFile=new ZipFile(gadmShapeFile.getCanonicalPath());
    LOG.log(Level.INFO,""String_Node_Str"" + gadmShapeFile.getParent());
    zipFile.extractAll(gadmShapeFile.getParent());
    f=new File(tmpFolder + ""String_Node_Str"");
    LOG.log(Level.INFO,""String_Node_Str"");
    return f;
  }
  ZipFile zipFile=new ZipFile(existingFile.getCanonicalPath());
  LOG.log(Level.INFO,""String_Node_Str"" + existingFile.getParent());
  zipFile.extractAll(existingFile.getParent());
  f=new File(existingFile.getCanonicalPath() + ""String_Node_Str"");
  LOG.log(Level.INFO,""String_Node_Str"");
  return f;
}"
52933,"/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException {
  if ((level != 0) || (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  HashMap<String,List<Geometry>> stateShape=new HashMap<String,List<Geometry>>();
  HashMap<String,String> stateCountry=new HashMap<String,String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  ShapefileReader shpReader;
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  try {
    map.put(""String_Node_Str"",rawFile.toURI().toURL());
    inputDataStore=DataStoreFinder.getDataStore(map);
    SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
    SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
    SimpleFeatureIterator inputFeatures=inputCollection.features();
    LOG.log(Level.INFO,""String_Node_Str"");
    if (level == 1) {
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        String state=((String)feature.getAttribute(6)).intern();
        if (!stateShape.containsKey(state)) {
          stateShape.put(state,new ArrayList<Geometry>());
          stateCountry.put(state,country);
        }
        stateShape.get(state).add((Geometry)feature.getAttribute(0));
      }
    }
 else {
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        if (!stateShape.containsKey(country))         stateShape.put(country,new ArrayList<Geometry>());
        stateShape.get(country).add((Geometry)feature.getAttribute(0));
      }
    }
    inputFeatures.close();
    inputDataStore.dispose();
    LOG.log(Level.INFO,""String_Node_Str"");
    typeBuilder=new SimpleFeatureTypeBuilder();
    typeBuilder.setName(""String_Node_Str"");
    typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
    typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
    typeBuilder.add(""String_Node_Str"",String.class);
    if (level == 1)     typeBuilder.add(""String_Node_Str"",String.class);
    typeBuilder.setDefaultGeometry(""String_Node_Str"");
    final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
    geometryFactory=JTSFactoryFinder.getGeometryFactory();
    featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
    LOG.log(Level.INFO,""String_Node_Str"");
    int count=0;
    if (level == 1) {
      int total=stateShape.keySet().size();
      for (      String state : stateCountry.keySet()) {
        count++;
        Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).union();
        featureBuilder.add(newGeom);
        featureBuilder.add(state);
        featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
        SimpleFeature feature=featureBuilder.buildFeature(null);
        if (count % 50 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        features.add(feature);
        stateShape.remove(state);
        System.gc();
      }
    }
 else {
      int total=stateShape.keySet().size();
      for (      String country : stateShape.keySet()) {
        count++;
        Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).union();
        featureBuilder.add(newGeom);
        featureBuilder.add(country);
        SimpleFeature feature=featureBuilder.buildFeature(null);
        if (count % 50 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        features.add(feature);
        stateShape.remove(country);
        System.gc();
      }
    }
    LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    stateCountry=null;
    stateShape=null;
    System.gc();
    ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
    Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
    outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
    outputParams.put(""String_Node_Str"",Boolean.TRUE);
    ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
    outputDataStore.createSchema(WIKITYPE);
    Transaction transaction=new DefaultTransaction(""String_Node_Str"");
    String typeName=outputDataStore.getTypeNames()[0];
    SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
    SimpleFeatureType SHAPE_TYPE=outputFeatureSource.getSchema();
    LOG.log(Level.INFO,""String_Node_Str"" + outputFile.getCanonicalPath());
    if (outputFeatureSource instanceof SimpleFeatureStore) {
      SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
      SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
      featureStore.setTransaction(transaction);
      try {
        featureStore.addFeatures(collection);
        transaction.commit();
      }
 catch (      Exception e) {
        e.printStackTrace();
        transaction.rollback();
      }
 finally {
        transaction.close();
      }
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,typeName + ""String_Node_Str"");
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * @param rawFile
 * @param outputFolder
 * @return //TODO: reduce memory usage Converts raw GADM shapefile into WikiBrain readable type Recommended JVM max heapsize = 4G
 */
public static void convertShpFile(File rawFile,SpatialDataFolder outputFolder,int level) throws IOException {
  if ((level != 0) && (level != 1))   throw new IllegalArgumentException(""String_Node_Str"");
  File outputFile;
  Map map=new HashMap();
  HashMap<String,List<Geometry>> stateShape=new HashMap<String,List<Geometry>>();
  HashMap<String,String> stateCountry=new HashMap<String,String>();
  if (level == 1)   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
 else   outputFile=new File(outputFolder.getRefSysFolder(""String_Node_Str"").getCanonicalPath() + ""String_Node_Str"" + ""String_Node_Str"");
  ShapefileReader shpReader;
  GeometryFactory geometryFactory;
  SimpleFeatureTypeBuilder typeBuilder;
  SimpleFeatureBuilder featureBuilder;
  DataStore inputDataStore;
  List<SimpleFeature> features=new ArrayList<SimpleFeature>();
  try {
    map.put(""String_Node_Str"",rawFile.toURI().toURL());
    inputDataStore=DataStoreFinder.getDataStore(map);
    SimpleFeatureSource inputFeatureSource=inputDataStore.getFeatureSource(inputDataStore.getTypeNames()[0]);
    SimpleFeatureCollection inputCollection=inputFeatureSource.getFeatures();
    SimpleFeatureIterator inputFeatures=inputCollection.features();
    LOG.log(Level.INFO,""String_Node_Str"");
    if (level == 1) {
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        String state=((String)feature.getAttribute(6)).intern();
        if (!stateShape.containsKey(state)) {
          stateShape.put(state,new ArrayList<Geometry>());
          stateCountry.put(state,country);
        }
        stateShape.get(state).add((Geometry)feature.getAttribute(0));
      }
    }
 else {
      while (inputFeatures.hasNext()) {
        SimpleFeature feature=inputFeatures.next();
        String country=((String)feature.getAttribute(4)).intern();
        if (!stateShape.containsKey(country))         stateShape.put(country,new ArrayList<Geometry>());
        stateShape.get(country).add((Geometry)feature.getAttribute(0));
      }
    }
    inputFeatures.close();
    inputDataStore.dispose();
    LOG.log(Level.INFO,""String_Node_Str"");
    typeBuilder=new SimpleFeatureTypeBuilder();
    typeBuilder.setName(""String_Node_Str"");
    typeBuilder.setCRS(DefaultGeographicCRS.WGS84);
    typeBuilder.add(""String_Node_Str"",MultiPolygon.class);
    typeBuilder.add(""String_Node_Str"",String.class);
    if (level == 1)     typeBuilder.add(""String_Node_Str"",String.class);
    typeBuilder.setDefaultGeometry(""String_Node_Str"");
    final SimpleFeatureType WIKITYPE=typeBuilder.buildFeatureType();
    geometryFactory=JTSFactoryFinder.getGeometryFactory();
    featureBuilder=new SimpleFeatureBuilder(WIKITYPE);
    LOG.log(Level.INFO,""String_Node_Str"");
    int count=0;
    if (level == 1) {
      int total=stateShape.keySet().size();
      for (      String state : stateCountry.keySet()) {
        count++;
        Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(state)).union();
        featureBuilder.add(newGeom);
        featureBuilder.add(state);
        featureBuilder.add(state + ""String_Node_Str"" + stateCountry.get(state));
        SimpleFeature feature=featureBuilder.buildFeature(null);
        if (count % 50 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        features.add(feature);
        stateShape.remove(state);
        System.gc();
      }
    }
 else {
      int total=stateShape.keySet().size();
      for (      String country : stateShape.keySet()) {
        count++;
        Geometry newGeom=geometryFactory.buildGeometry(stateShape.get(country)).union();
        featureBuilder.add(newGeom);
        featureBuilder.add(country);
        SimpleFeature feature=featureBuilder.buildFeature(null);
        if (count % 50 == 0)         LOG.log(Level.INFO,count + ""String_Node_Str"" + total+ ""String_Node_Str"");
        features.add(feature);
        stateShape.remove(country);
        System.gc();
      }
    }
    LOG.log(Level.INFO,""String_Node_Str"" + count + ""String_Node_Str"");
    stateCountry=null;
    stateShape=null;
    System.gc();
    ShapefileDataStoreFactory dataStoreFactory=new ShapefileDataStoreFactory();
    Map<String,Serializable> outputParams=new HashMap<String,Serializable>();
    outputParams.put(""String_Node_Str"",outputFile.toURI().toURL());
    outputParams.put(""String_Node_Str"",Boolean.TRUE);
    ShapefileDataStore outputDataStore=(ShapefileDataStore)dataStoreFactory.createNewDataStore(outputParams);
    outputDataStore.createSchema(WIKITYPE);
    Transaction transaction=new DefaultTransaction(""String_Node_Str"");
    String typeName=outputDataStore.getTypeNames()[0];
    SimpleFeatureSource outputFeatureSource=outputDataStore.getFeatureSource(typeName);
    SimpleFeatureType SHAPE_TYPE=outputFeatureSource.getSchema();
    LOG.log(Level.INFO,""String_Node_Str"" + outputFile.getCanonicalPath());
    if (outputFeatureSource instanceof SimpleFeatureStore) {
      SimpleFeatureStore featureStore=(SimpleFeatureStore)outputFeatureSource;
      SimpleFeatureCollection collection=new ListFeatureCollection(WIKITYPE,features);
      featureStore.setTransaction(transaction);
      try {
        featureStore.addFeatures(collection);
        transaction.commit();
      }
 catch (      Exception e) {
        e.printStackTrace();
        transaction.rollback();
      }
 finally {
        transaction.close();
      }
      LOG.log(Level.INFO,""String_Node_Str"");
    }
 else {
      LOG.log(Level.INFO,typeName + ""String_Node_Str"");
    }
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}"
52934,"public static void main(String args[]) throws ConfigurationException, DaoException, InterruptedException {
  Env env=EnvBuilder.envFromArgs(args);
  dao=env.getConfigurator().get(LocalLinkDao.class);
  LocalPageDao lpDao=env.getConfigurator().get(LocalPageDao.class);
  for (  LocalPage p : (Iterable<LocalPage>)lpDao.get(new DaoFilter().setRedirect(false).setDisambig(false))) {
    localIds.add(p.toLocalId());
    if (localIds.size() % 100000 == 0) {
      System.err.println(""String_Node_Str"" + localIds);
    }
  }
  List<Worker> workers=new ArrayList<Worker>();
  long start=System.currentTimeMillis();
  for (int i=0; i < WpThreadUtils.getMaxThreads(); i++) {
    Worker worker=new Worker();
    worker.start();
    workers.add(worker);
  }
  for (  Worker worker : workers) {
    System.out.println(""String_Node_Str"" + worker);
    worker.join();
  }
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str""+ numRows.get()+ ""String_Node_Str""+ numCells.get());
}","public static void main(String args[]) throws ConfigurationException, DaoException, InterruptedException {
  Env env=EnvBuilder.envFromArgs(args);
  dao=env.getConfigurator().get(LocalLinkDao.class);
  LocalPageDao lpDao=env.getConfigurator().get(LocalPageDao.class);
  for (  LocalPage p : (Iterable<LocalPage>)lpDao.get(new DaoFilter().setRedirect(false).setDisambig(false))) {
    localIds.add(p.toLocalId());
    if (localIds.size() % 100000 == 0) {
      System.err.println(""String_Node_Str"" + localIds.size());
    }
  }
  List<Worker> workers=new ArrayList<Worker>();
  long start=System.currentTimeMillis();
  for (int i=0; i < WpThreadUtils.getMaxThreads(); i++) {
    Worker worker=new Worker();
    worker.start();
    workers.add(worker);
  }
  for (  Worker worker : workers) {
    System.out.println(""String_Node_Str"" + worker);
    worker.join();
  }
  System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str""+ numRows.get()+ ""String_Node_Str""+ numCells.get());
}"
52935,"protected static CharArraySet getStopWordsForNonLuceneLangFromFile(Version version,Language language){
  try {
    String langCode=language.getLangCode();
    String fileName=STOP_WORDS + langCode + ""String_Node_Str"";
    InputStream stream=FileUtils.openInputStream(new File(fileName));
    List<String> stopWords=org.apache.commons.io.IOUtils.readLines(stream);
    CharArraySet charArraySet=new CharArraySet(version,0,false);
    for (    String stopWord : stopWords) {
      charArraySet.add(stopWord);
    }
    return charArraySet;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","protected static CharArraySet getStopWordsForNonLuceneLangFromFile(Version version,Language language){
  try {
    String langCode=language.getLangCode();
    String fileName=STOP_WORDS + langCode + ""String_Node_Str"";
    File f=new File(fileName);
    CharArraySet charArraySet=new CharArraySet(version,0,false);
    if (f.exists()) {
      InputStream stream=FileUtils.openInputStream(f);
      List<String> stopWords=org.apache.commons.io.IOUtils.readLines(stream);
      for (      String stopWord : stopWords) {
        charArraySet.add(stopWord);
      }
    }
    return charArraySet;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
52936,"public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  MostSimilarInDegrees sim=new MostSimilarInDegrees(""String_Node_Str"");
  String testTitle=""String_Node_Str"";
  int degrees=3;
  System.out.println(System.lineSeparator() + ""String_Node_Str"" + testTitle+ ""String_Node_Str""+ degrees+ ""String_Node_Str""+ sim.getMostSimilar(testTitle,degrees));
}","public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  MostSimilarInDegrees sim=new MostSimilarInDegrees(""String_Node_Str"");
  String testTitle=""String_Node_Str"";
  int degrees=3;
  System.out.println(""String_Node_Str"" + testTitle + ""String_Node_Str""+ degrees+ ""String_Node_Str""+ sim.getMostSimilar(testTitle,degrees));
}"
52937,"public static void main(String[] args) throws Exception {
  Env env=EnvBuilder.envFromArgs(args);
  Configurator conf=env.getConfigurator();
  ToblersLawEvaluator evaluator=new ToblersLawEvaluator(env,new LanguageSet(""String_Node_Str""));
  SpatialDataDao sdDao=conf.get(SpatialDataDao.class);
  SpatialContainmentDao scDao=conf.get(SpatialContainmentDao.class);
  LocalPageDao lpDao=conf.get(LocalPageDao.class);
  WikidataDao wdDao=conf.get(WikidataDao.class);
  UniversalPageDao upDao=conf.get(UniversalPageDao.class);
  String layerName1=""String_Node_Str"";
  String layerName2=""String_Node_Str"";
  Set<String> subLayers=Sets.newHashSet();
  subLayers.add(""String_Node_Str"");
  Integer containerId1=wdDao.getItemId(lpDao.getByTitle(new Title(""String_Node_Str"",Language.getByLangCode(""String_Node_Str"")),NameSpace.ARTICLE));
  TIntSet containedItemIds1=scDao.getContainedItemIds(containerId1,layerName1,""String_Node_Str"",subLayers,SpatialContainmentDao.ContainmentOperationType.CONTAINMENT);
  Integer containerId2=wdDao.getItemId(lpDao.getByTitle(new Title(""String_Node_Str"",Language.getByLangCode(""String_Node_Str"")),NameSpace.ARTICLE));
  TIntSet containedItemIds2=scDao.getContainedItemIds(containerId2,layerName2,""String_Node_Str"",subLayers,SpatialContainmentDao.ContainmentOperationType.CONTAINMENT);
  Map<Integer,Geometry> geometriesToParse=new HashMap<Integer,Geometry>();
  List<UniversalPage> concepts1=new ArrayList<UniversalPage>();
  List<UniversalPage> concepts2=new ArrayList<UniversalPage>();
  final Set<Integer> containedId1=new HashSet<Integer>();
  final Set<Integer> containedId2=new HashSet<Integer>();
  LOG.info(String.format(""String_Node_Str"",containedItemIds1.size(),containedItemIds2.size()));
  int counter=0;
  containedItemIds1.forEach(new TIntProcedure(){
    @Override public boolean execute(    int i){
      containedId1.add(i);
      return true;
    }
  }
);
  Set<Integer> sampledContainedId1=PickSample(containedId1,500);
  Set<Integer> sampledContainedId2=PickSample(containedId2,500);
  for (  Integer i : sampledContainedId1) {
    if (counter % 100 == 0)     LOG.info(String.format(""String_Node_Str"",counter,sampledContainedId1.size()));
    geometriesToParse.put(i,sdDao.getGeometry(i,""String_Node_Str"",""String_Node_Str""));
    concepts1.add(upDao.getById(i,1));
    counter++;
  }
  containedItemIds2.forEach(new TIntProcedure(){
    @Override public boolean execute(    int i){
      containedId2.add(i);
      return true;
    }
  }
);
  counter=0;
  for (  Integer i : sampledContainedId2) {
    if (counter % 100 == 0)     LOG.info(String.format(""String_Node_Str"",counter,sampledContainedId2.size()));
    geometriesToParse.put(i,sdDao.getGeometry(i,""String_Node_Str"",""String_Node_Str""));
    concepts2.add(upDao.getById(i,1));
    counter++;
  }
  LOG.info(String.format(""String_Node_Str"",geometriesToParse.size()));
  evaluator.retrieveLocations(geometriesToParse);
  evaluator.evaluateBipartite(new File(""String_Node_Str""),concepts1,concepts2);
}","public static void main(String[] args) throws Exception {
  LanguageSet languageSet=new LanguageSet(""String_Node_Str"");
  Env env=EnvBuilder.envFromArgs(args);
  Configurator conf=env.getConfigurator();
  ToblersLawEvaluator evaluator=new ToblersLawEvaluator(env,languageSet);
  SpatialDataDao sdDao=conf.get(SpatialDataDao.class);
  SpatialContainmentDao scDao=conf.get(SpatialContainmentDao.class);
  LocalPageDao lpDao=conf.get(LocalPageDao.class);
  WikidataDao wdDao=conf.get(WikidataDao.class);
  UniversalPageDao upDao=conf.get(UniversalPageDao.class);
  String layerName1=""String_Node_Str"";
  String layerName2=""String_Node_Str"";
  Set<String> subLayers=Sets.newHashSet();
  subLayers.add(""String_Node_Str"");
  Integer containerId1=wdDao.getItemId(lpDao.getByTitle(new Title(""String_Node_Str"",Language.getByLangCode(""String_Node_Str"")),NameSpace.ARTICLE));
  TIntSet containedItemIds1=scDao.getContainedItemIds(containerId1,layerName1,""String_Node_Str"",subLayers,SpatialContainmentDao.ContainmentOperationType.CONTAINMENT);
  Integer containerId2=wdDao.getItemId(lpDao.getByTitle(new Title(""String_Node_Str"",Language.getByLangCode(""String_Node_Str"")),NameSpace.ARTICLE));
  TIntSet containedItemIds2=scDao.getContainedItemIds(containerId2,layerName2,""String_Node_Str"",subLayers,SpatialContainmentDao.ContainmentOperationType.CONTAINMENT);
  Map<Integer,Geometry> geometriesToParse=new HashMap<Integer,Geometry>();
  List<UniversalPage> concepts1=new ArrayList<UniversalPage>();
  List<UniversalPage> concepts2=new ArrayList<UniversalPage>();
  final Set<Integer> containedId1=new HashSet<Integer>();
  final Set<Integer> containedId2=new HashSet<Integer>();
  LOG.info(String.format(""String_Node_Str"",containedItemIds1.size(),containedItemIds2.size()));
  int counter=0;
  containedItemIds1.forEach(new TIntProcedure(){
    @Override public boolean execute(    int i){
      containedId1.add(i);
      return true;
    }
  }
);
  containedItemIds2.forEach(new TIntProcedure(){
    @Override public boolean execute(    int i){
      containedId2.add(i);
      return true;
    }
  }
);
  Set<Integer> sampledContainedId1=PickSample(containedId1,500);
  Set<Integer> sampledContainedId2=PickSample(containedId2,500);
  for (  Integer i : sampledContainedId1) {
    if (counter % 100 == 0)     LOG.info(String.format(""String_Node_Str"",counter,sampledContainedId1.size()));
    UniversalPage concept=upDao.getById(i,1);
    if (concept != null && concept.hasAllLanguages(languageSet)) {
      concepts1.add(upDao.getById(i,1));
      geometriesToParse.put(i,sdDao.getGeometry(i,""String_Node_Str"",""String_Node_Str""));
    }
    counter++;
  }
  counter=0;
  for (  Integer i : sampledContainedId2) {
    if (counter % 100 == 0)     LOG.info(String.format(""String_Node_Str"",counter,sampledContainedId2.size()));
    UniversalPage concept=upDao.getById(i,1);
    if (concept != null && concept.hasAllLanguages(languageSet)) {
      concepts2.add(upDao.getById(i,1));
      geometriesToParse.put(i,sdDao.getGeometry(i,""String_Node_Str"",""String_Node_Str""));
    }
    counter++;
  }
  LOG.info(String.format(""String_Node_Str"",geometriesToParse.size()));
  evaluator.retrieveLocations(geometriesToParse);
  evaluator.evaluateBipartite(new File(""String_Node_Str""),concepts1,concepts2);
}"
52938,"/** 
 * Evaluate all pairs that one location is in ""concepts1"" and the other one is in ""concepts2""
 * @param outputPath
 * @param concepts1
 * @param concepts2
 * @throws IOException
 * @throws DaoException
 * @throws WikapidiaException
 */
public void evaluateBipartite(File outputPath,List<UniversalPage> concepts1,List<UniversalPage> concepts2) throws IOException, DaoException, WikapidiaException {
  this.output=new CSVWriter(new FileWriter(outputPath),',');
  writeHeader();
  if (concepts1.size() == 0 || concepts2.size() == 0)   LOG.warning(""String_Node_Str"");
  int counter=0;
  int total_size=concepts1.size() * concepts2.size();
  for (  UniversalPage c1 : concepts1) {
    for (    UniversalPage c2 : concepts2) {
      counter++;
      if (counter % 1000 == 0)       LOG.info(String.format(""String_Node_Str"",counter,total_size));
      if (c1.equals(c2))       continue;
      try {
        List<SRResult> results=new ArrayList<SRResult>();
        for (        Language lang : langs) {
          MonolingualSRMetric sr=metrics.get(lang);
          results.add(sr.similarity(c1.getLocalId(lang),c2.getLocalId(lang),false));
        }
        writeRow(c1,c2,results);
      }
 catch (      Exception e) {
        LOG.warning(String.format(""String_Node_Str"",c1,c2));
      }
    }
  }
  this.output.close();
}","/** 
 * Evaluate all pairs that one location is in ""concepts1"" and the other one is in ""concepts2""
 * @param outputPath
 * @param concepts1
 * @param concepts2
 * @throws IOException
 * @throws DaoException
 * @throws WikapidiaException
 */
public void evaluateBipartite(File outputPath,List<UniversalPage> concepts1,List<UniversalPage> concepts2) throws IOException, DaoException, WikapidiaException {
  this.output=new CSVWriter(new FileWriter(outputPath),',');
  writeHeader();
  if (concepts1.size() == 0 || concepts2.size() == 0)   LOG.warning(""String_Node_Str"");
  int counter=0;
  int total_size=concepts1.size() * concepts2.size();
  for (  UniversalPage c1 : concepts1) {
    for (    UniversalPage c2 : concepts2) {
      counter++;
      if (counter % 1000 == 0)       LOG.info(String.format(""String_Node_Str"",counter,total_size));
      if (c1.equals(c2))       continue;
      try {
        List<SRResult> results=new ArrayList<SRResult>();
        for (        Language lang : langs) {
          MonolingualSRMetric sr=metrics.get(lang);
          results.add(sr.similarity(c1.getLocalId(lang),c2.getLocalId(lang),false));
        }
        writeRow(c1,c2,results);
      }
 catch (      Exception e) {
        LOG.warning(String.format(""String_Node_Str"",c1.getBestEnglishTitle(lpDao,true),c2.getBestEnglishTitle(lpDao,true)));
      }
    }
  }
  this.output.close();
}"
52939,"public static void main(String[] args) throws Exception {
  Env env=EnvBuilder.envFromArgs(args);
  Configurator conf=env.getConfigurator();
  ToblersLawEvaluator evaluator=new ToblersLawEvaluator(env,new LanguageSet(""String_Node_Str""));
  SpatialDataDao sdDao=conf.get(SpatialDataDao.class);
  Map<Integer,Geometry> allGeometries=sdDao.getAllGeometries(""String_Node_Str"",""String_Node_Str"");
  Map<Integer,Geometry> geometryMap=new HashMap<Integer,Geometry>();
  int counter=0;
  for (  Integer id : allGeometries.keySet()) {
    geometryMap.put(id,allGeometries.get(id));
    counter++;
    if (counter >= 100)     break;
  }
  evaluator.retrieveLocations(geometryMap);
  evaluator.evaluateAll(new File(""String_Node_Str""));
}","public static void main(String[] args) throws Exception {
  Env env=EnvBuilder.envFromArgs(args);
  Configurator conf=env.getConfigurator();
  ToblersLawEvaluator evaluator=new ToblersLawEvaluator(env,new LanguageSet(""String_Node_Str""));
  SpatialDataDao sdDao=conf.get(SpatialDataDao.class);
  Map<Integer,Geometry> allGeometries=sdDao.getAllGeometries(""String_Node_Str"",""String_Node_Str"");
  Map<Integer,Geometry> geometryMap=new HashMap<Integer,Geometry>();
  int counter=0;
  for (  Integer id : allGeometries.keySet()) {
    geometryMap.put(id,allGeometries.get(id));
    counter++;
    if (counter >= 100)     break;
  }
  evaluator.retrieveAllLocations();
  evaluator.evaluateSample(new File(""String_Node_Str""),1000000);
}"
52940,"public static void main(String[] args){
  try {
    Env env=new EnvBuilder().build();
    Configurator c=env.getConfigurator();
    SpatialNeighborDao snDao=c.get(SpatialNeighborDao.class);
    WikidataDao wdDao=c.get(WikidataDao.class);
    LocalPageDao lpDao=c.get(LocalPageDao.class);
    LanguageSet loadedLangs=lpDao.getLoadedLanguages();
    String originName=""String_Node_Str"";
    String layerName=""String_Node_Str"";
    Set<String> subLayers=Sets.newHashSet();
    subLayers.add(""String_Node_Str"");
    LocalPage lp=lpDao.getByTitle(new Title(originName,Language.getByLangCode(""String_Node_Str"")),NameSpace.ARTICLE);
    Integer id=wdDao.getItemId(lp);
    TIntSet neighborItemIds=snDao.getNeighboringItemIds(id,layerName,""String_Node_Str"",subLayers,1,50);
    int counter=0;
    System.out.println(""String_Node_Str"" + lp.getTitle() + ""String_Node_Str"");
    for (    int cId : neighborItemIds.toArray()) {
      UniversalPage univPage=wdDao.getUniversalPage(cId);
      Title t=univPage.getBestEnglishTitle(lpDao,true);
      System.out.println(t.getCanonicalTitle());
      counter++;
    }
    System.out.printf(""String_Node_Str"",counter);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  try {
    Env env=new EnvBuilder().build();
    Configurator c=env.getConfigurator();
    SpatialNeighborDao snDao=c.get(SpatialNeighborDao.class);
    WikidataDao wdDao=c.get(WikidataDao.class);
    LocalPageDao lpDao=c.get(LocalPageDao.class);
    SpatialDataDao sdDao=c.get(SpatialDataDao.class);
    LanguageSet loadedLangs=lpDao.getLoadedLanguages();
    String originName=""String_Node_Str"";
    String layerName=""String_Node_Str"";
    Set<String> subLayers=Sets.newHashSet();
    subLayers.add(""String_Node_Str"");
    LocalPage lp=lpDao.getByTitle(new Title(originName,Language.getByLangCode(""String_Node_Str"")),NameSpace.ARTICLE);
    Integer id=wdDao.getItemId(lp);
    TIntSet neighborItemIds=snDao.getNeighboringItemIds(id,layerName,""String_Node_Str"",subLayers,800,1000);
    Point p1=sdDao.getGeometry(id,layerName,""String_Node_Str"").getCentroid();
    int counter=0;
    System.out.println(""String_Node_Str"" + lp.getTitle() + ""String_Node_Str"");
    for (    int cId : neighborItemIds.toArray()) {
      UniversalPage univPage=wdDao.getUniversalPage(cId);
      Title t=univPage.getBestEnglishTitle(lpDao,true);
      System.out.println();
      Point p2=sdDao.getGeometry(cId,""String_Node_Str"",""String_Node_Str"").getCentroid();
      GeodeticCalculator geoCalc=new GeodeticCalculator();
      geoCalc.setStartingGeographicPoint(p1.getX(),p1.getY());
      geoCalc.setDestinationGeographicPoint(p2.getX(),p2.getY());
      System.out.println(t.getCanonicalTitle() + ""String_Node_Str"" + geoCalc.getOrthodromicDistance() / 1000);
      counter++;
    }
    System.out.printf(""String_Node_Str"",counter);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
52941,"@Override public TIntSet getNeighboringItemIds(Geometry g,String refSysName,Set<String> subLayers,double minDist,double maxDist) throws DaoException {
  if (subLayers.size() == 0)   throw new DaoException(""String_Node_Str"");
  FilterFactory2 ff=CommonFactoryFinder.getFilterFactory2();
  PropertyName geomProperty=ff.property(db.getGeometryAttributeName());
  PropertyName refSysProperty=ff.property(db.getRefSysAttributeName());
  Filter refSysFilter=ff.equals(refSysProperty,ff.literal(refSysName));
  PropertyName layerProperty=ff.property(db.getLayerAttributeName());
  List<Filter> layerFilters=Lists.newArrayList();
  for (  String subLayer : subLayers) {
    Filter curLayerFilter=ff.equals(layerProperty,ff.literal(subLayer));
    layerFilters.add(curLayerFilter);
  }
  Filter layerFilter=ff.and(layerFilters);
  Filter withinFilter=ff.dwithin(geomProperty,ff.literal(g),10.0,""String_Node_Str"");
  List<Filter> filters=Lists.newArrayList();
  filters.add(refSysFilter);
  filters.add(layerFilter);
  filters.add(withinFilter);
  Filter finalFilter=ff.and(filters);
  try {
    FeatureSource featureSource=db.getFeatureSource();
    FeatureCollection containedFeatures=featureSource.getFeatures(finalFilter);
    FeatureIterator featureIterator=containedFeatures.features();
    TIntSet rVal=new TIntHashSet();
    while (featureIterator.hasNext()) {
      Feature f=featureIterator.next();
      Integer itemId=(Integer)f.getProperty(db.getItemIdAttributeName()).getValue();
      rVal.add(itemId);
    }
    return rVal;
  }
 catch (  IOException e) {
    throw new DaoException(e);
  }
}","@Override public TIntSet getNeighboringItemIds(Geometry g,String refSysName,Set<String> subLayers,double minDist,double maxDist) throws DaoException {
  if (subLayers.size() == 0)   throw new DaoException(""String_Node_Str"");
  FilterFactory2 ff=CommonFactoryFinder.getFilterFactory2();
  PropertyName geomProperty=ff.property(db.getGeometryAttributeName());
  PropertyName refSysProperty=ff.property(db.getRefSysAttributeName());
  Filter refSysFilter=ff.equals(refSysProperty,ff.literal(refSysName));
  PropertyName layerProperty=ff.property(db.getLayerAttributeName());
  List<Filter> layerFilters=Lists.newArrayList();
  for (  String subLayer : subLayers) {
    Filter curLayerFilter=ff.equals(layerProperty,ff.literal(subLayer));
    layerFilters.add(curLayerFilter);
  }
  Filter layerFilter=ff.and(layerFilters);
  Filter withinFilter=ff.dwithin(geomProperty,ff.literal(g),maxDist / 111.1949266,""String_Node_Str"");
  Filter beyondFilter=ff.beyond(geomProperty,ff.literal(g),minDist / 111.1949266,""String_Node_Str"");
  List<Filter> filters=Lists.newArrayList();
  filters.add(refSysFilter);
  filters.add(layerFilter);
  filters.add(withinFilter);
  filters.add(beyondFilter);
  Filter finalFilter=ff.and(filters);
  try {
    FeatureSource featureSource=db.getFeatureSource();
    FeatureCollection containedFeatures=featureSource.getFeatures(finalFilter);
    FeatureIterator featureIterator=containedFeatures.features();
    TIntSet rVal=new TIntHashSet();
    while (featureIterator.hasNext()) {
      Feature f=featureIterator.next();
      Integer itemId=(Integer)f.getProperty(db.getItemIdAttributeName()).getValue();
      rVal.add(itemId);
    }
    return rVal;
  }
 catch (  IOException e) {
    throw new DaoException(e);
  }
}"
52942,"/** 
 * Downloads the GADM shape file
 */
public void downloadGADMShapeFile(){
  if (countryCode.isEmpty()) {
    buildCodeMap();
  }
  String fileName=""String_Node_Str"";
  String gadmURL=""String_Node_Str"" + fileName;
  File gadmShapeFile=new File(""String_Node_Str"" + fileName);
  try {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    FileUtils.copyURLToFile(new URL(gadmURL),gadmShapeFile,5000,5000);
    System.out.println(""String_Node_Str"");
    System.out.println(gadmShapeFile.getAbsolutePath());
    ZipFile zipFile=new ZipFile(gadmShapeFile.getAbsolutePath());
    System.out.println(""String_Node_Str"");
    zipFile.extractAll(gadmShapeFile.getParent() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
}","/** 
 * Download GADM shape file
 */
public void downloadGADMShapeFile(){
  String fileName=""String_Node_Str"";
  String gadmURL=""String_Node_Str"" + fileName;
  File gadmShapeFile=new File(""String_Node_Str"" + fileName);
  try {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    FileUtils.copyURLToFile(new URL(gadmURL),gadmShapeFile,5000,5000);
    System.out.println(""String_Node_Str"");
    System.out.println(gadmShapeFile.getAbsolutePath());
    ZipFile zipFile=new ZipFile(gadmShapeFile.getAbsolutePath());
    System.out.println(""String_Node_Str"");
    zipFile.extractAll(gadmShapeFile.getParent() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ZipException e) {
    e.printStackTrace();
  }
}"
52943,"public void convertShpFile(ShpFiles shpFile){
  DbaseFileReader dbfReader;
  DbaseFileWriter dbfWriter;
  DbaseFileHeader dbfHeader;
  Object[] entry, newEntry=new Object[2];
  try {
    dbfReader=new DbaseFileReader(shpFile,false,Charset.forName(""String_Node_Str""));
    dbfHeader=new DbaseFileHeader();
    WritableByteChannel out=new FileOutputStream(""String_Node_Str"").getChannel();
    dbfWriter=new DbaseFileWriter(dbfHeader,out);
    dbfHeader.addColumn(""String_Node_Str"",'c',254,0);
    dbfHeader.addColumn(""String_Node_Str"",'c',254,0);
    while (dbfReader.hasNext()) {
      entry=dbfReader.readEntry();
      newEntry[0]=(String)entry[5];
      newEntry[1]=(String)entry[5] + ""String_Node_Str"" + (String)entry[3];
      dbfWriter.write(newEntry);
    }
    dbfWriter.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Convert GADM shapefile into the format we can read
 * @param shpFile
 */
public void convertShpFile(ShpFiles shpFile){
  DbaseFileReader dbfReader;
  DbaseFileWriter dbfWriter;
  DbaseFileHeader dbfHeader;
  Object[] entry, newEntry=new Object[2];
  try {
    dbfReader=new DbaseFileReader(shpFile,false,Charset.forName(""String_Node_Str""));
    dbfHeader=new DbaseFileHeader();
    FileOutputStream out=new FileOutputStream(""String_Node_Str"");
    dbfWriter=new DbaseFileWriter(dbfHeader,out.getChannel());
    dbfHeader.addColumn(""String_Node_Str"",'c',20,0);
    dbfHeader.addColumn(""String_Node_Str"",'c',20,0);
    while (dbfReader.hasNext()) {
      entry=dbfReader.readEntry();
      newEntry[0]=(String)entry[5];
      newEntry[1]=(String)entry[5] + ""String_Node_Str"" + (String)entry[3];
      dbfWriter.write(newEntry);
    }
    dbfWriter.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
52944,"/** 
 * Convert GADM shapefile into the format we can read
 * @param shpFile
 */
public void convertShpFile(ShpFiles shpFile){
  DbaseFileReader dbfReader;
  DbaseFileWriter dbfWriter;
  DbaseFileHeader dbfHeader;
  Object[] entry, newEntry=new Object[2];
  try {
    dbfReader=new DbaseFileReader(shpFile,false,Charset.forName(""String_Node_Str""));
    dbfHeader=new DbaseFileHeader();
    FileOutputStream out=new FileOutputStream(""String_Node_Str"");
    dbfWriter=new DbaseFileWriter(dbfHeader,out.getChannel());
    dbfHeader.addColumn(""String_Node_Str"",'c',20,0);
    dbfHeader.addColumn(""String_Node_Str"",'c',20,0);
    while (dbfReader.hasNext()) {
      entry=dbfReader.readEntry();
      newEntry[0]=(String)entry[5];
      newEntry[1]=(String)entry[5] + ""String_Node_Str"" + (String)entry[3];
      dbfWriter.write(newEntry);
    }
    dbfWriter.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Convert GADM shapefile into the format we can read
 * @param shpFile
 */
public void convertShpFile(ShpFiles shpFile){
  DbaseFileReader dbfReader;
  DbaseFileWriter dbfWriter;
  DbaseFileHeader dbfHeader;
  Object[] entry, newEntry=new Object[2];
  try {
    dbfReader=new DbaseFileReader(shpFile,false,Charset.forName(""String_Node_Str""));
    dbfHeader=new DbaseFileHeader();
    dbfHeader.addColumn(""String_Node_Str"",'c',254,0);
    dbfHeader.addColumn(""String_Node_Str"",'c',254,0);
    File f=new File(""String_Node_Str"");
    FileOutputStream out=new FileOutputStream(f);
    dbfWriter=new DbaseFileWriter(dbfHeader,out.getChannel(),Charset.forName(""String_Node_Str""));
    int count=0;
    HashMap<Integer,HashSet<Integer>> id=new HashMap<Integer,HashSet<Integer>>();
    while (dbfReader.hasNext()) {
      entry=dbfReader.readEntry();
      if (!id.containsKey(entry[1]))       id.put((Integer)entry[1],new HashSet<Integer>());
      if (!id.get(entry[1]).contains(entry[4])) {
        count++;
        newEntry[0]=(String)entry[5];
        newEntry[1]=(String)entry[5] + ""String_Node_Str"" + (String)entry[3];
        dbfWriter.write(newEntry);
        id.get(entry[1]).add((Integer)entry[4]);
      }
 else       continue;
    }
    System.out.println(""String_Node_Str"" + count);
    dbfWriter.close();
    out.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
52945,"protected static Geometry jsonToGeometry(JsonObject json){
  try {
    Double latitude=json.get(""String_Node_Str"").getAsDouble();
    Double longitude=json.get(""String_Node_Str"").getAsDouble();
    String globe=json.get(""String_Node_Str"").getAsString();
    if (globe != null && (!globe.endsWith(EARTH_ITEM_ID) || !globe.endsWith(""String_Node_Str""))) {
      LOG.log(Level.INFO,""String_Node_Str"" + json);
      return null;
    }
    Coordinate[] coords=new Coordinate[1];
    coords[0]=new Coordinate(longitude,latitude);
    CoordinateArraySequence coordArraySeq=new CoordinateArraySequence(coords);
    Point p=new Point(coordArraySeq,new GeometryFactory());
    return p;
  }
 catch (  Exception e) {
    LOG.log(Level.WARNING,""String_Node_Str"" + json + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
    return null;
  }
}","protected static Geometry jsonToGeometry(JsonObject json){
  try {
    Double latitude=json.get(""String_Node_Str"").getAsDouble();
    Double longitude=json.get(""String_Node_Str"").getAsDouble();
    String globe=null;
    try {
      globe=json.get(""String_Node_Str"").getAsString();
    }
 catch (    Exception e) {
    }
    if (globe != null && !(globe.endsWith(EARTH_ITEM_ID) || globe.endsWith(""String_Node_Str""))) {
      LOG.log(Level.INFO,""String_Node_Str"" + json);
      return null;
    }
    Coordinate[] coords=new Coordinate[1];
    coords[0]=new Coordinate(longitude,latitude);
    CoordinateArraySequence coordArraySeq=new CoordinateArraySequence(coords);
    Point p=new Point(coordArraySeq,new GeometryFactory());
    return p;
  }
 catch (  Exception e) {
    LOG.log(Level.WARNING,""String_Node_Str"" + json + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
    return null;
  }
}"
52946,"public static void main(String args[]) throws ConfigurationException, WikapidiaException {
  Options options=new Options();
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  EnvBuilder.addStandardOptions(options);
  CommandLineParser parser=new PosixParser();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return;
  }
  Env env=new EnvBuilder(cmd).build();
  Configurator conf=env.getConfigurator();
  String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
  String spatialDataFolderPath=cmd.getOptionValue('f');
  File spatialDataFolder=new File(""String_Node_Str"");
  WikidataDao wdDao=conf.get(WikidataDao.class);
  SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
  LOG.log(Level.INFO,""String_Node_Str"" + spatialDataFolderPath + ""String_Node_Str"");
  SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder);
  loader.loadExogenousData();
}","public static void main(String args[]) throws ConfigurationException, WikapidiaException {
  Options options=new Options();
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  EnvBuilder.addStandardOptions(options);
  CommandLineParser parser=new PosixParser();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return;
  }
  Env env=new EnvBuilder(cmd).build();
  Configurator conf=env.getConfigurator();
  String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
  File spatialDataFolder=new File(""String_Node_Str"");
  String spatialDataFolderPath=new String(""String_Node_Str"");
  WikidataDao wdDao=conf.get(WikidataDao.class);
  SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
  LOG.log(Level.INFO,""String_Node_Str"" + spatialDataFolderPath + ""String_Node_Str"");
  SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder);
  loader.loadWikidataData();
}"
52947,"@Override public PostGISDB get(String name,Config config,Map<String,String> runtimeParams) throws ConfigurationException {
  try {
    if (PostGISDB.instance != null) {
      Map<String,Object> params=Maps.newHashMap();
      ConfigObject cObject=config.root();
      for (      String key : cObject.keySet()) {
        params.put(key,cObject.get(key).unwrapped());
      }
      PostGISDB.instance=new PostGISDB(params);
    }
    return PostGISDB.instance;
  }
 catch (  DaoException e) {
    throw new ConfigurationException(e);
  }
}","@Override public PostGISDB get(String name,Config config,Map<String,String> runtimeParams) throws ConfigurationException {
  try {
    if (PostGISDB.instance == null) {
      Map<String,Object> params=Maps.newHashMap();
      ConfigObject cObject=config.root();
      for (      String key : cObject.keySet()) {
        params.put(key,cObject.get(key).unwrapped());
      }
      PostGISDB.instance=new PostGISDB(params);
    }
    return PostGISDB.instance;
  }
 catch (  DaoException e) {
    throw new ConfigurationException(e);
  }
}"
52948,"private TIntSet getContainedItemIds(Geometry g,String refSysName,Set<String> subLayers,ContainmentOperationType opType) throws DaoException {
  if (subLayers.size() == 0)   throw new DaoException(""String_Node_Str"");
  FilterFactory2 ff=CommonFactoryFinder.getFilterFactory2();
  PropertyName geomProperty=ff.property(db.getGeometryAttributeName());
  PropertyName refSysProperty=ff.property(db.getRefSysAttributeName());
  Filter refSysFilter=ff.equals(refSysProperty,ff.literal(refSysName));
  PropertyName layerProperty=ff.property(db.getLayerAttributeName());
  List<Filter> layerFilters=Lists.newArrayList();
  for (  String subLayer : subLayers) {
    Filter curLayerFilter=ff.equals(layerProperty,ff.literal(subLayer));
    layerFilters.add(curLayerFilter);
  }
  Filter layerFilter=ff.and(layerFilters);
  Filter geomFilter=null;
switch (opType) {
case CONTAINMENT:
    geomFilter=ff.contains(geomProperty,ff.literal(g));
  break;
case INTERSECTION:
geomFilter=ff.intersects(geomProperty,ff.literal(g));
break;
default :
throw new DaoException(""String_Node_Str"" + opType);
}
List<Filter> filters=Lists.newArrayList();
filters.add(refSysFilter);
filters.add(layerFilter);
filters.add(geomFilter);
Filter finalFilter=ff.and(filters);
try {
FeatureSource featureSource=db.getFeatureSource();
FeatureCollection containedFeatures=featureSource.getFeatures(finalFilter);
FeatureIterator featureIterator=containedFeatures.features();
TIntSet rVal=new TIntHashSet();
while (featureIterator.hasNext()) {
Feature f=featureIterator.next();
Integer itemId=(Integer)f.getProperty(db.getItemIdAttributeName()).getValue();
rVal.add(itemId);
}
return rVal;
}
 catch (IOException e) {
throw new DaoException(e);
}
}","@Override public TIntSet getContainedItemIds(Geometry g,String refSysName,Set<String> subLayers,ContainmentOperationType opType) throws DaoException {
  if (subLayers.size() == 0)   throw new DaoException(""String_Node_Str"");
  FilterFactory2 ff=CommonFactoryFinder.getFilterFactory2();
  PropertyName geomProperty=ff.property(db.getGeometryAttributeName());
  PropertyName refSysProperty=ff.property(db.getRefSysAttributeName());
  Filter refSysFilter=ff.equals(refSysProperty,ff.literal(refSysName));
  PropertyName layerProperty=ff.property(db.getLayerAttributeName());
  List<Filter> layerFilters=Lists.newArrayList();
  for (  String subLayer : subLayers) {
    Filter curLayerFilter=ff.equals(layerProperty,ff.literal(subLayer));
    layerFilters.add(curLayerFilter);
  }
  Filter layerFilter=ff.and(layerFilters);
  Filter geomFilter=null;
switch (opType) {
case CONTAINMENT:
    geomFilter=ff.contains(geomProperty,ff.literal(g));
  break;
case INTERSECTION:
geomFilter=ff.intersects(geomProperty,ff.literal(g));
break;
default :
throw new DaoException(""String_Node_Str"" + opType);
}
List<Filter> filters=Lists.newArrayList();
filters.add(refSysFilter);
filters.add(layerFilter);
filters.add(geomFilter);
Filter finalFilter=ff.and(filters);
try {
FeatureSource featureSource=db.getFeatureSource();
FeatureCollection containedFeatures=featureSource.getFeatures(finalFilter);
FeatureIterator featureIterator=containedFeatures.features();
TIntSet rVal=new TIntHashSet();
while (featureIterator.hasNext()) {
Feature f=featureIterator.next();
Integer itemId=(Integer)f.getProperty(db.getItemIdAttributeName()).getValue();
rVal.add(itemId);
}
return rVal;
}
 catch (IOException e) {
throw new DaoException(e);
}
}"
52949,"@Override public Class getType(){
  return SpatialDataDao.class;
}","@Override public Class getType(){
  return SpatialContainmentDao.class;
}"
52950,"public static void main(String args[]) throws ConfigurationException, WikapidiaException {
  Options options=new Options();
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  EnvBuilder.addStandardOptions(options);
  CommandLineParser parser=new PosixParser();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return;
  }
  Env env=new EnvBuilder(cmd).build();
  Configurator conf=env.getConfigurator();
  String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
  String spatialDataFolderPath=cmd.getOptionValue('f');
  File spatialDataFolder=new File(""String_Node_Str"");
  WikidataDao wdDao=conf.get(WikidataDao.class);
  SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
  LOG.log(Level.INFO,""String_Node_Str"" + spatialDataFolderPath + ""String_Node_Str"");
  SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder);
  loader.loadWikidataData();
}","public static void main(String args[]) throws ConfigurationException, WikapidiaException {
  Options options=new Options();
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  EnvBuilder.addStandardOptions(options);
  CommandLineParser parser=new PosixParser();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return;
  }
  Env env=new EnvBuilder(cmd).build();
  Configurator conf=env.getConfigurator();
  String phraseAnalyzerName=cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  PhraseAnalyzer phraseAnalyzer=conf.get(PhraseAnalyzer.class,phraseAnalyzerName);
  String spatialDataFolderPath=cmd.getOptionValue('f');
  File spatialDataFolder=new File(""String_Node_Str"");
  WikidataDao wdDao=conf.get(WikidataDao.class);
  SpatialDataDao spatialDataDao=conf.get(SpatialDataDao.class);
  LOG.log(Level.INFO,""String_Node_Str"" + spatialDataFolderPath + ""String_Node_Str"");
  SpatialDataLoader loader=new SpatialDataLoader(spatialDataDao,wdDao,phraseAnalyzer,spatialDataFolder);
  loader.loadExogenousData();
}"
52951,"public String getStringValue(){
  return (String)value;
}","public String getStringValue(){
  return value.toString();
}"
52952,"public static Object gsonToPrimitive(JsonElement element){
  if (element.isJsonPrimitive()) {
    JsonPrimitive prim=element.getAsJsonPrimitive();
    if (prim.isString()) {
      return prim.getAsString();
    }
 else     if (prim.isBoolean()) {
      return prim.getAsBoolean();
    }
 else     if (prim.isNumber()) {
      return prim.getAsInt();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + prim);
    }
  }
 else   if (element.isJsonArray()) {
    JsonArray array=element.getAsJsonArray();
    List<Object> list=new ArrayList<Object>();
    for (int i=0; i < array.size(); i++) {
      list.add(gsonToPrimitive(array.get(i)));
    }
    return list;
  }
 else   if (element.isJsonNull()) {
    return null;
  }
 else   if (element.isJsonObject()) {
    Map<String,Object> map=new HashMap<String,Object>();
    for (    Map.Entry<String,JsonElement> entry : element.getAsJsonObject().entrySet()) {
      map.put(entry.getKey(),gsonToPrimitive(entry.getValue()));
    }
    return map;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + element);
  }
}","public static Object gsonToPrimitive(JsonElement element){
  if (element.isJsonPrimitive()) {
    JsonPrimitive prim=element.getAsJsonPrimitive();
    if (prim.isString()) {
      return prim.getAsString();
    }
 else     if (prim.isBoolean()) {
      return prim.getAsBoolean();
    }
 else     if (prim.isNumber()) {
      return prim.getAsNumber();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + prim);
    }
  }
 else   if (element.isJsonArray()) {
    JsonArray array=element.getAsJsonArray();
    List<Object> list=new ArrayList<Object>();
    for (int i=0; i < array.size(); i++) {
      list.add(gsonToPrimitive(array.get(i)));
    }
    return list;
  }
 else   if (element.isJsonNull()) {
    return null;
  }
 else   if (element.isJsonObject()) {
    Map<String,Object> map=new HashMap<String,Object>();
    for (    Map.Entry<String,JsonElement> entry : element.getAsJsonObject().entrySet()) {
      map.put(entry.getKey(),gsonToPrimitive(entry.getValue()));
    }
    return map;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + element);
  }
}"
52953,"@Override public LinkedHashMap<String,Float> describeUniversal(Language language,UniversalPage page,int maxPhrases){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","public LinkedHashMap<String,Float> describeUniversal(Language language,UniversalPage page,int maxPhrases){
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
52954,"@Override public LinkedHashMap<UniversalPage,Float> resolveUniversal(Language language,String phrase,int algorithmId,int maxPages){
  throw new UnsupportedOperationException();
}","public LinkedHashMap<UniversalPage,Float> resolveUniversal(Language language,String phrase,int algorithmId,int maxPages){
  throw new UnsupportedOperationException();
}"
52955,"@Override public LocalWikidataStatement getLocalStatement(Language language,WikidataStatement statement) throws DaoException {
  language=getRealLang(language);
  String item=getLocalName(language,statement.getItem().getType(),statement.getItem().getId());
  String prop=getLocalName(language,statement.getProperty().getType(),statement.getProperty().getId());
  String value=null;
  WikidataValue wdv=statement.getValue();
  if (wdv.getType() == WikidataValue.Type.ITEM) {
    value=getLocalName(language,WikidataEntity.Type.ITEM,wdv.getItemValue());
  }
 else   if (wdv == null) {
    value=""String_Node_Str"";
  }
 else {
    value=wdv.getValue().toString();
  }
  String full=item + ""String_Node_Str"" + prop+ ""String_Node_Str""+ value;
  return new LocalWikidataStatement(language,statement,full,item,prop,value);
}","@Override public LocalWikidataStatement getLocalStatement(Language language,WikidataStatement statement) throws DaoException {
  language=getRealLang(language);
  String item=getLocalName(language,statement.getItem().getType(),statement.getItem().getId());
  String prop=getLocalName(language,statement.getProperty().getType(),statement.getProperty().getId());
  String value=null;
  WikidataValue wdv=statement.getValue();
  if (wdv.getType() == WikidataValue.Type.ITEM) {
    value=getLocalName(language,WikidataEntity.Type.ITEM,wdv.getItemValue());
  }
 else   if (wdv.getValue() == null) {
    value=""String_Node_Str"";
  }
 else {
    value=wdv.getValue().toString();
  }
  String full=item + ""String_Node_Str"" + prop+ ""String_Node_Str""+ value;
  return new LocalWikidataStatement(language,statement,full,item,prop,value);
}"
52956,"/** 
 * Find a shortest chain between two articles using the Bi-directional BFS Prints out the chain, the number of links visited and the number of nodes visited
 * @param srcTitle The page title of source article
 * @param dstTitle The page title of destination article
 * @return The number of degree of the chain found
 * @throws DaoException
 */
public int getRelationBidirectional(String srcTitle,String dstTitle) throws DaoException, ConfigurationException {
  Integer srcId=pDao.getIdByTitle(srcTitle,lang,NameSpace.ARTICLE);
  Integer dstId=pDao.getIdByTitle(dstTitle,lang,NameSpace.ARTICLE);
  return getRelationBidirectional(srcId,dstId);
}","/** 
 * Find a shortest chain between two articles using the Bi-directional BFS Prints out the chain, the number of links visited and the number of nodes visited
 * @param srcTitle The page title of source article
 * @param dstTitle The page title of destination article
 * @return The number of degree of the chain found
 * @throws DaoException
 */
public int getRelationBidirectional(String srcTitle,String dstTitle) throws DaoException, ConfigurationException {
  Integer srcId=pDao.getIdByTitle(srcTitle,lang,NameSpace.ARTICLE);
  Integer dstId=pDao.getIdByTitle(dstTitle,lang,NameSpace.ARTICLE);
  if (srcId == -1 || dstId == -1)   throw new DaoException(""String_Node_Str"");
  return getRelationBidirectional(srcId,dstId);
}"
52957,"/** 
 * Find the shortest chain between two articles (using naive uni-directional BFS, much slower than the bi-directional version) Prints out the chain, the number of links visited and the number of nodes visited
 * @param srcTitle The page title of source article
 * @param dstTitle The page title of destination article
 * @return The number of degree of the chain found
 * @throws DaoException
 */
public int getRelation(String srcTitle,String dstTitle) throws DaoException {
  Integer srcId=pDao.getIdByTitle(srcTitle,lang,NameSpace.ARTICLE);
  Integer dstId=pDao.getIdByTitle(dstTitle,lang,NameSpace.ARTICLE);
  return getRelation(srcId,dstId);
}","/** 
 * Find the shortest chain between two articles (using naive uni-directional BFS, much slower than the bi-directional version) Prints out the chain, the number of links visited and the number of nodes visited
 * @param srcTitle The page title of source article
 * @param dstTitle The page title of destination article
 * @return The number of degree of the chain found
 * @throws DaoException
 */
public int getRelation(String srcTitle,String dstTitle) throws DaoException {
  Integer srcId=pDao.getIdByTitle(srcTitle,lang,NameSpace.ARTICLE);
  Integer dstId=pDao.getIdByTitle(dstTitle,lang,NameSpace.ARTICLE);
  if (srcId == -1 || dstId == -1)   throw new DaoException(""String_Node_Str"");
  return getRelation(srcId,dstId);
}"
52958,"/** 
 * Find a chain between two articles (using the SR (semantic relatedness) between the current article and the destination article as heuristic) Prints out the chain, the number of links visited and the number of nodes visited
 * @param srcTitle The page title of source article
 * @param dstTitle The page title of destination article
 * @return The number of degree of the chain found
 * @throws DaoException
 */
public int getRelationSR(String srcTitle,String dstTitle) throws DaoException, ConfigurationException {
  Integer srcId=pDao.getIdByTitle(srcTitle,lang,NameSpace.ARTICLE);
  Integer dstId=pDao.getIdByTitle(dstTitle,lang,NameSpace.ARTICLE);
  return getRelationSR(srcId,dstId);
}","/** 
 * Find a chain between two articles (using the SR (semantic relatedness) between the current article and the destination article as heuristic) Prints out the chain, the number of links visited and the number of nodes visited
 * @param srcTitle The page title of source article
 * @param dstTitle The page title of destination article
 * @return The number of degree of the chain found
 * @throws DaoException
 */
public int getRelationSR(String srcTitle,String dstTitle) throws DaoException, ConfigurationException {
  Integer srcId=pDao.getIdByTitle(srcTitle,lang,NameSpace.ARTICLE);
  Integer dstId=pDao.getIdByTitle(dstTitle,lang,NameSpace.ARTICLE);
  if (srcId == -1 || dstId == -1)   throw new DaoException(""String_Node_Str"");
  return getRelationSR(srcId,dstId);
}"
52959,"public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  ConceptRelation cr=new ConceptRelation(Language.getByLangCode(""String_Node_Str""));
  System.out.println(cr.getRelationSR(""String_Node_Str"",""String_Node_Str""));
  System.out.println(cr.getRelationBidirectional(""String_Node_Str"",""String_Node_Str""));
  Integer srcId=1527;
  Integer dstId=43788;
}","public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  ConceptRelation cr=new ConceptRelation(Language.getByLangCode(""String_Node_Str""));
  System.out.println(cr.getRelationSR(""String_Node_Str"",""String_Node_Str""));
  System.out.println(cr.getRelationBidirectional(""String_Node_Str"",""String_Node_Str""));
  Integer srcId=1527;
  Integer dstId=43788;
  System.out.println(cr.getWikidataRelation(srcId,dstId));
}"
52960,"@Test public void testLocalStatements() throws DaoException, IOException, ClassNotFoundException {
  WpDataSource ds=TestDaoUtil.getWpDataSource(dbDir);
  WikidataDao wd=new WikidataSqlDao(ds);
  Map<String,List<LocalWikidataStatement>> statements=wd.getLocalStatements(EN,WikidataEntity.Type.ITEM,157);
  assertEquals(25,statements.keySet().size());
  for (  String prop : statements.keySet()) {
    System.out.println(""String_Node_Str"" + prop + ""String_Node_Str"");
    for (    LocalWikidataStatement st : statements.get(prop)) {
      System.out.println(""String_Node_Str"" + st.getFullStatement());
    }
  }
  List<LocalWikidataStatement> almaMaters=statements.get(""String_Node_Str"");
  assertEquals(4,almaMaters.size());
  for (  LocalWikidataStatement lws : almaMaters) {
    assertEquals(""String_Node_Str"",lws.getFullStatement());
  }
}","@Test public void testLocalStatements() throws DaoException, IOException, ClassNotFoundException {
  WpDataSource ds=TestDaoUtil.getWpDataSource(dbDir);
  WikidataDao wd=new WikidataSqlDao(ds,null,null);
  Map<String,List<LocalWikidataStatement>> statements=wd.getLocalStatements(EN,WikidataEntity.Type.ITEM,157);
  assertEquals(25,statements.keySet().size());
  for (  String prop : statements.keySet()) {
    System.out.println(""String_Node_Str"" + prop + ""String_Node_Str"");
    for (    LocalWikidataStatement st : statements.get(prop)) {
      System.out.println(""String_Node_Str"" + st.getFullStatement());
    }
  }
  List<LocalWikidataStatement> almaMaters=statements.get(""String_Node_Str"");
  assertEquals(4,almaMaters.size());
  for (  LocalWikidataStatement lws : almaMaters) {
    assertEquals(""String_Node_Str"",lws.getFullStatement());
  }
}"
52961,"@Test public void testItem() throws DaoException, IOException, ClassNotFoundException {
  WpDataSource ds=TestDaoUtil.getWpDataSource(dbDir);
  WikidataDao wd=new WikidataSqlDao(ds);
  WikidataEntity entity=wd.getItem(157);
  assertEquals(157,entity.getId());
  assertEquals(WikidataEntity.Type.ITEM,entity.getType());
  assertEquals(""String_Node_Str"",entity.getLabels().get(Language.getByLangCode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",entity.getLabels().get(Language.getByLangCode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",entity.getDescriptions().get(Language.getByLangCode(""String_Node_Str"")));
  assertTrue(entity.getAliases().get(Language.getByLangCode(""String_Node_Str"")).contains(""String_Node_Str""));
  assertEquals(36,entity.getStatements().size());
  Map<String,List<WikidataStatement>> statements=entity.getStatementsInLanguage(Language.getByLangCode(""String_Node_Str""));
  assertEquals(4,statements.get(""String_Node_Str"").size());
  TIntSet ids=new TIntHashSet();
  for (  WikidataStatement st : statements.get(""String_Node_Str"")) {
    assertEquals(166,st.getProperty().getId());
    assertEquals(""String_Node_Str"",st.getProperty().getLabels().get(EN));
    assertEquals(WikidataValue.Type.ITEM,st.getValue().getType());
    ids.add(st.getValue().getItemValue());
  }
  assertEquals(new TIntHashSet(new int[]{84020,10855226,13422143,14539990}),ids);
}","@Test public void testItem() throws DaoException, IOException, ClassNotFoundException {
  WpDataSource ds=TestDaoUtil.getWpDataSource(dbDir);
  WikidataDao wd=new WikidataSqlDao(ds,null,null);
  WikidataEntity entity=wd.getItem(157);
  assertEquals(157,entity.getId());
  assertEquals(WikidataEntity.Type.ITEM,entity.getType());
  assertEquals(""String_Node_Str"",entity.getLabels().get(Language.getByLangCode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",entity.getLabels().get(Language.getByLangCode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",entity.getDescriptions().get(Language.getByLangCode(""String_Node_Str"")));
  assertTrue(entity.getAliases().get(Language.getByLangCode(""String_Node_Str"")).contains(""String_Node_Str""));
  assertEquals(36,entity.getStatements().size());
  Map<String,List<WikidataStatement>> statements=entity.getStatementsInLanguage(Language.getByLangCode(""String_Node_Str""));
  assertEquals(4,statements.get(""String_Node_Str"").size());
  TIntSet ids=new TIntHashSet();
  for (  WikidataStatement st : statements.get(""String_Node_Str"")) {
    assertEquals(166,st.getProperty().getId());
    assertEquals(""String_Node_Str"",st.getProperty().getLabels().get(EN));
    assertEquals(WikidataValue.Type.ITEM,st.getValue().getType());
    ids.add(st.getValue().getItemValue());
  }
  assertEquals(new TIntHashSet(new int[]{84020,10855226,13422143,14539990}),ids);
}"
52962,"@Test public void testProps() throws DaoException, IOException, ClassNotFoundException {
  WpDataSource ds=TestDaoUtil.getWpDataSource(dbDir);
  WikidataDao wd=new WikidataSqlDao(ds);
  Map<Integer,WikidataEntity> props=wd.getProperties();
  assertEquals(props.size(),836);
  assertTrue(props.containsKey(127));
  WikidataEntity entity=wd.getProperty(127);
  assertEquals(127,entity.getId());
  assertEquals(WikidataEntity.Type.PROPERTY,entity.getType());
  assertEquals(""String_Node_Str"",entity.getLabels().get(EN));
  assertEquals(""String_Node_Str"",entity.getLabels().get(Language.getByLangCode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",entity.getDescriptions().get(EN));
  assertTrue(entity.getAliases().get(Language.getByLangCode(""String_Node_Str"")).contains(""String_Node_Str""));
  assertEquals(0,entity.getStatements().size());
}","@Test public void testProps() throws DaoException, IOException, ClassNotFoundException {
  WpDataSource ds=TestDaoUtil.getWpDataSource(dbDir);
  WikidataDao wd=new WikidataSqlDao(ds,null,null);
  Map<Integer,WikidataEntity> props=wd.getProperties();
  assertEquals(props.size(),836);
  assertTrue(props.containsKey(127));
  WikidataEntity entity=wd.getProperty(127);
  assertEquals(127,entity.getId());
  assertEquals(WikidataEntity.Type.PROPERTY,entity.getType());
  assertEquals(""String_Node_Str"",entity.getLabels().get(EN));
  assertEquals(""String_Node_Str"",entity.getLabels().get(Language.getByLangCode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",entity.getDescriptions().get(EN));
  assertTrue(entity.getAliases().get(Language.getByLangCode(""String_Node_Str"")).contains(""String_Node_Str""));
  assertEquals(0,entity.getStatements().size());
}"
52963,"@BeforeClass public static void createDb() throws IOException, DaoException, ClassNotFoundException, URISyntaxException {
  dbDir=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  dbDir.delete();
  dbDir.mkdirs();
  cacheFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  cacheFile.delete();
  cacheFile.mkdirs();
  WpDataSource ds=TestDaoUtil.getWpDataSource(dbDir);
  MetaInfoDao md=new MetaInfoSqlDao(ds);
  md.beginLoad();
  WikidataSqlDao wd=new WikidataSqlDao(ds);
  wd.beginLoad();
  WikidataDumpLoader loader=new WikidataDumpLoader(wd,md);
  URL url=TestWikidataDao.class.getResource(""String_Node_Str"");
  loader.load(new File(url.toURI()));
  wd.endLoad();
  md.endLoad();
}","@BeforeClass public static void createDb() throws IOException, DaoException, ClassNotFoundException, URISyntaxException {
  dbDir=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  dbDir.delete();
  dbDir.mkdirs();
  cacheFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  cacheFile.delete();
  cacheFile.mkdirs();
  WpDataSource ds=TestDaoUtil.getWpDataSource(dbDir);
  MetaInfoDao md=new MetaInfoSqlDao(ds);
  md.beginLoad();
  WikidataSqlDao wd=new WikidataSqlDao(ds,null,null);
  wd.beginLoad();
  WikidataDumpLoader loader=new WikidataDumpLoader(wd,md);
  URL url=TestWikidataDao.class.getResource(""String_Node_Str"");
  loader.load(new File(url.toURI()));
  wd.endLoad();
  md.endLoad();
}"
52964,"public static void main(String args[]) throws ClassNotFoundException, SQLException, IOException, ConfigurationException, WikapidiaException, DaoException {
  try {
    DateTime startDate=parseDate(args[1]);
    DateTime endDate=parseDate(args[2]);
    Env env=new EnvBuilder().setLanguages(args[0]).build();
    Configurator conf=env.getConfigurator();
    PageViewSqlDao dao=conf.get(PageViewSqlDao.class);
    final PageViewLoader loader=new PageViewLoader(env.getLanguages(),dao);
    LOG.log(Level.INFO,""String_Node_Str"");
    dao.beginLoad();
    loader.load(startDate,endDate);
    LOG.log(Level.INFO,""String_Node_Str"");
    dao.endLoad();
    LOG.log(Level.INFO,""String_Node_Str"");
  }
 catch (  WikapidiaException wE) {
    System.err.println(""String_Node_Str"" + wE.getMessage());
    return;
  }
}","public static void main(String args[]) throws ClassNotFoundException, SQLException, IOException, ConfigurationException, WikapidiaException, DaoException {
  Options options=new Options();
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").isRequired().hasArg().create(""String_Node_Str""));
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").isRequired().hasArg().create(""String_Node_Str""));
  EnvBuilder.addStandardOptions(options);
  CommandLineParser parser=new PosixParser();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return;
  }
  String startTime=cmd.getOptionValue(""String_Node_Str"",null);
  String endTime=cmd.getOptionValue(""String_Node_Str"",null);
  try {
    DateTime startDate=parseDate(startTime);
    DateTime endDate=parseDate(endTime);
    Env env=new EnvBuilder(cmd).build();
    Configurator conf=env.getConfigurator();
    PageViewSqlDao dao=conf.get(PageViewSqlDao.class);
    final PageViewLoader loader=new PageViewLoader(env.getLanguages(),dao);
    if (cmd.hasOption(""String_Node_Str"")) {
      LOG.log(Level.INFO,""String_Node_Str"");
      dao.clear();
    }
    LOG.log(Level.INFO,""String_Node_Str"");
    dao.beginLoad();
    loader.load(startDate,endDate);
    LOG.log(Level.INFO,""String_Node_Str"");
    dao.endLoad();
    LOG.log(Level.INFO,""String_Node_Str"");
  }
 catch (  WikapidiaException wE) {
    System.err.println(""String_Node_Str"" + wE.getMessage());
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return;
  }
}"
52965,"/** 
 * Util function used to check if all hours in a given period have been parsed
 * @param startTime start time of a period
 * @param endTime end time of a period
 * @return
 */
boolean checkExist(DateTime startTime,DateTime endTime){
  for (DateTime hrTime=startTime; hrTime.getMillis() < endTime.getMillis(); hrTime.plusHours(1)) {
    if (!parsedHourSet.contains(hrTime.getMillis()))     return false;
  }
  return true;
}","/** 
 * Util function used to check if all hours in a given period have been parsed
 * @param startTime start time of a period
 * @param endTime end time of a period
 * @return
 */
boolean checkExist(DateTime startTime,DateTime endTime){
  for (DateTime hrTime=startTime; hrTime.getMillis() < endTime.getMillis(); hrTime=hrTime.plusHours(1)) {
    if (!parsedHourSet.contains(hrTime.getMillis()))     return false;
  }
  return true;
}"
52966,"Map<Integer,Integer> getPageView(Iterable<Integer> ids,int startYear,int startMonth,int startDay,int startHour,int numHours) throws ConfigurationException, DaoException, WikapidiaException {
  Map<Integer,Integer> result=new HashMap<Integer,Integer>();
  DateTime startTime=new DateTime(startYear,startMonth,startDay,startHour,0);
  DateTime endTime=startTime.plusHours(numHours);
  if (!checkExist(startTime,endTime))   parse(startTime,numHours);
  for (  Integer id : ids) {
    if (db.exists(Integer.toString(id)) == false) {
      result.put(id,0);
      continue;
    }
    Map<Long,Integer> hourViewMap=db.getTreeMap(Integer.toString(id));
    int sum=0;
    for (DateTime hrTime=startTime; hrTime.getMillis() < endTime.getMillis(); hrTime.plusHours(1)) {
      if (hourViewMap.containsKey(hrTime.getMillis()) == false)       continue;
      sum+=hourViewMap.get(hrTime.getMillis());
    }
    result.put(id,sum);
  }
  return result;
}","Map<Integer,Integer> getPageView(Iterable<Integer> ids,int startYear,int startMonth,int startDay,int startHour,int numHours) throws ConfigurationException, DaoException, WikapidiaException {
  Map<Integer,Integer> result=new HashMap<Integer,Integer>();
  DateTime startTime=new DateTime(startYear,startMonth,startDay,startHour,0);
  DateTime endTime=startTime.plusHours(numHours);
  if (!checkExist(startTime,endTime))   parse(startTime,numHours);
  for (  Integer id : ids) {
    if (db.exists(Integer.toString(id)) == false) {
      result.put(id,0);
      continue;
    }
    Map<Long,Integer> hourViewMap=db.getTreeMap(Integer.toString(id));
    int sum=0;
    for (DateTime hrTime=startTime; hrTime.getMillis() < endTime.getMillis(); hrTime=hrTime.plusHours(1)) {
      if (hourViewMap.containsKey(hrTime.getMillis()) == false)       continue;
      sum+=hourViewMap.get(hrTime.getMillis());
    }
    result.put(id,sum);
  }
  return result;
}"
52967,"Map<Integer,Integer> getPageView(Iterable<Integer> ids,DateTime startTime,DateTime endTime) throws ConfigurationException, DaoException, WikapidiaException {
  Map<Integer,Integer> result=new HashMap<Integer,Integer>();
  if (!checkExist(startTime,endTime))   parse(startTime,endTime);
  for (  Integer id : ids) {
    if (db.exists(Integer.toString(id)) == false) {
      result.put(id,0);
      break;
    }
    Map<Long,Integer> hourViewMap=db.getTreeMap(Integer.toString(id));
    int sum=0;
    for (long hrTime=dateTimeToHour(startTime); hrTime < dateTimeToHour(endTime); hrTime+=1) {
      if (hourViewMap.containsKey(hrTime) == false)       continue;
      sum+=hourViewMap.get(hrTime);
    }
    result.put(id,sum);
  }
  return result;
}","Map<Integer,Integer> getPageView(Iterable<Integer> ids,DateTime startTime,DateTime endTime) throws ConfigurationException, DaoException, WikapidiaException {
  Map<Integer,Integer> result=new HashMap<Integer,Integer>();
  if (!checkExist(startTime,endTime))   parse(startTime,endTime);
  for (  Integer id : ids) {
    if (db.exists(Integer.toString(id)) == false) {
      result.put(id,0);
      continue;
    }
    Map<Long,Integer> hourViewMap=db.getTreeMap(Integer.toString(id));
    int sum=0;
    for (long hrTime=dateTimeToHour(startTime); hrTime < dateTimeToHour(endTime); hrTime+=1) {
      if (hourViewMap.containsKey(hrTime) == false)       continue;
      sum+=hourViewMap.get(hrTime);
    }
    result.put(id,sum);
  }
  return result;
}"
52968,"public static void main(String[] args) throws WikapidiaException, DaoException, ConfigurationException {
  Language lang=Language.getByLangCode(""String_Node_Str"");
  Env env=new EnvBuilder().build();
  Configurator configurator=env.getConfigurator();
  LocalPageDao pdao=configurator.get(LocalPageDao.class,""String_Node_Str"");
  PageViewIterator it=new PageViewIterator(lang,2013,12,8,1,2013,12,8,4);
  int i=0;
  while (i < 4) {
    double start=System.currentTimeMillis();
    PageViewDataStruct data=it.next();
    double elapsed=(System.currentTimeMillis() - start) / 1000;
    System.out.println(""String_Node_Str"" + elapsed + ""String_Node_Str""+ i);
    TIntIntMap stats=data.getPageViewStats();
    for (    int pageId : stats.keys()) {
      try {
        Title page=pdao.getById(lang,pageId).getTitle();
        System.out.println(""String_Node_Str"" + page + ""String_Node_Str""+ stats.get(pageId));
      }
 catch (      NullPointerException e) {
        continue;
      }
    }
    i++;
  }
}","public static void main(String[] args) throws WikapidiaException, DaoException, ConfigurationException {
  Language lang=Language.getByLangCode(""String_Node_Str"");
  Env env=new EnvBuilder().build();
  Configurator configurator=env.getConfigurator();
  LocalPageDao pdao=configurator.get(LocalPageDao.class,""String_Node_Str"");
  PageViewIterator it=new PageViewIterator(lang,2013,12,8,1,2013,12,8,4);
  int i=0;
  while (i < 4) {
    double start=System.currentTimeMillis();
    PageViewDataStruct data=it.next();
    double elapsed=(System.currentTimeMillis() - start) / 1000;
    System.out.println(""String_Node_Str"" + elapsed + ""String_Node_Str""+ i);
    TIntIntMap stats=data.getPageViewStats();
    for (    int pageId : stats.keys()) {
      try {
        Title page=pdao.getById(lang,pageId).getTitle();
        System.out.println(""String_Node_Str"" + page + ""String_Node_Str""+ stats.get(pageId));
      }
 catch (      NullPointerException e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
        e.printStackTrace();
        continue;
      }
    }
    i++;
  }
}"
52969,"public void constructQueryUrl(){
  String http=""String_Node_Str"";
  String host=""String_Node_Str"";
  String queryUrl=http + lang.getLangCode() + host+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ queryAction+ ""String_Node_Str""+ queryType+ ""String_Node_Str""+ queryLimitPrefix+ ""String_Node_Str"";
  if (this.title != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ (pluralPage ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ title;
  }
  if (this.pageid != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ (pluralPage ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ pageid;
  }
  if ((this.redirects != null) && this.redirects) {
    queryUrl+=""String_Node_Str"";
  }
  if (this.filterredir != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ ""String_Node_Str""+ filterredir;
  }
  if (this.from != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ ""String_Node_Str""+ from;
  }
  if (this.namespace != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ ""String_Node_Str""+ namespace;
  }
  if (this.prop != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ ""String_Node_Str""+ prop;
  }
  this.queryUrl=queryUrl;
}","public void constructQueryUrl(){
  String http=""String_Node_Str"";
  String host=""String_Node_Str"";
  String queryUrl=http + lang.getLangCode() + host+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ queryAction+ ""String_Node_Str""+ queryType+ ""String_Node_Str""+ queryLimitPrefix+ ""String_Node_Str"";
  if (!this.titles.isEmpty()) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ (pluralPage ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ titles.get(0);
    for (int i=1; i < titles.size(); i++) {
      queryUrl+=""String_Node_Str"" + titles.get(i);
    }
  }
  if (!this.pageids.isEmpty()) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ (pluralPage ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ pageids.get(0);
    for (int i=1; i < pageids.size(); i++) {
      queryUrl+=""String_Node_Str"" + pageids.get(i);
    }
  }
  if ((this.redirects != null) && this.redirects) {
    queryUrl+=""String_Node_Str"";
  }
  if (this.filterredir != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ ""String_Node_Str""+ filterredir;
  }
  if (this.from != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ ""String_Node_Str""+ from;
  }
  if (this.namespace != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ ""String_Node_Str""+ namespace;
  }
  if (this.prop != null) {
    queryUrl+=""String_Node_Str"" + queryInfoPrefix + ""String_Node_Str""+ ""String_Node_Str""+ prop;
  }
  this.queryUrl=queryUrl;
}"
52970,"private LiveAPIQuery(LiveAPIQueryBuilder builder){
  this.lang=builder.lang;
  if (builder.redirects != null) {
    this.redirects=builder.redirects;
  }
  if (builder.title != null) {
    this.title=builder.title;
  }
  if (builder.pageid != null) {
    this.pageid=builder.pageid;
  }
  if (builder.filterredir != null) {
    this.filterredir=builder.filterredir;
  }
  if (builder.from != null) {
    this.from=builder.from;
  }
  if (builder.namespace != null) {
    this.namespace=builder.namespace;
  }
switch (builder.queryType) {
case 0:
    this.queryAction=""String_Node_Str"";
  this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=true;
this.queryResultDataSection=""String_Node_Str"";
break;
case 1:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=false;
this.queryResultDataSection=""String_Node_Str"";
break;
case 2:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=true;
this.queryResultDataSection=""String_Node_Str"";
break;
case 3:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=true;
this.queryResultDataSection=""String_Node_Str"";
break;
case 4:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=false;
this.queryResultDataSection=""String_Node_Str"";
break;
case 5:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=false;
this.queryResultDataSection=""String_Node_Str"";
break;
default :
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=false;
this.queryResultDataSection=""String_Node_Str"";
this.prop=""String_Node_Str"";
break;
}
constructQueryUrl();
}","private LiveAPIQuery(LiveAPIQueryBuilder builder){
  this.lang=builder.lang;
  if (builder.redirects != null) {
    this.redirects=builder.redirects;
  }
  if (builder.titles != null) {
    this.titles=builder.titles;
  }
  if (builder.pageids != null) {
    this.pageids=builder.pageids;
  }
  if (builder.filterredir != null) {
    this.filterredir=builder.filterredir;
  }
  if (builder.from != null) {
    this.from=builder.from;
  }
  if (builder.namespace != null) {
    this.namespace=builder.namespace;
  }
switch (builder.queryType) {
case 0:
    this.queryAction=""String_Node_Str"";
  this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=true;
this.queryResultDataSection=""String_Node_Str"";
break;
case 1:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=false;
this.queryResultDataSection=""String_Node_Str"";
break;
case 2:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=true;
this.queryResultDataSection=""String_Node_Str"";
break;
case 3:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=true;
this.queryResultDataSection=""String_Node_Str"";
break;
case 4:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=false;
this.queryResultDataSection=""String_Node_Str"";
break;
case 5:
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=false;
this.queryResultDataSection=""String_Node_Str"";
break;
default :
this.queryAction=""String_Node_Str"";
this.queryType=""String_Node_Str"";
this.queryInfoPrefix=""String_Node_Str"";
this.queryLimitPrefix=""String_Node_Str"";
this.pluralPage=false;
this.queryResultDataSection=""String_Node_Str"";
this.prop=""String_Node_Str"";
break;
}
constructQueryUrl();
}"
52971,"public Iterable<LocalLink> getLinks(Language language,int localId,boolean outlinks) throws DaoException {
  List<LocalLink> links=new ArrayList<LocalLink>();
  LiveAPIQuery.LiveAPIQueryBuilder builder;
  if (outlinks) {
    builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  }
 else {
    builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  }
  builder.setPageid(localId);
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    LocalLink link=outlinks ? reply.getLocalOutLink(language,localId) : reply.getLocalInLink(language,localId);
    links.add(link);
  }
  return links;
}","public Iterable<LocalLink> getLinks(Language language,int localId,boolean outlinks) throws DaoException {
  List<LocalLink> links=new ArrayList<LocalLink>();
  LiveAPIQuery.LiveAPIQueryBuilder builder;
  if (outlinks) {
    builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  }
 else {
    builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  }
  builder.addPageid(localId);
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    LocalLink link=outlinks ? reply.getLocalOutLink(language,localId) : reply.getLocalInLink(language,localId);
    links.add(link);
  }
  return links;
}"
52972,"public LocalLink getLink(Language language,int sourceId,int destId) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  builder.setPageid(sourceId);
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    int pageId=reply.pageId;
    if (pageId == destId) {
      return reply.getLocalOutLink(language,sourceId);
    }
  }
  throw new DaoException(""String_Node_Str"");
}","public LocalLink getLink(Language language,int sourceId,int destId) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  builder.addPageid(sourceId);
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    int pageId=reply.pageId;
    if (pageId == destId) {
      return reply.getLocalOutLink(language,sourceId);
    }
  }
  throw new DaoException(""String_Node_Str"");
}"
52973,"/** 
 * Get an id from a title. Returns -1 if it doesn't exist.
 * @param title
 * @return
 */
public int getIdByTitle(Title title) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",title.getLanguage()).setTitle(title.getCanonicalTitle().replace(""String_Node_Str"",""String_Node_Str"")).setRedirects(followRedirects);
  QueryReply info=builder.build().getValuesFromQueryResult().get(0);
  return info.getId();
}","/** 
 * Get an id from a title. Returns -1 if it doesn't exist.
 * @param title
 * @return
 */
public int getIdByTitle(Title title) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",title.getLanguage()).addTitle(title.getCanonicalTitle().replace(""String_Node_Str"",""String_Node_Str"")).setRedirects(followRedirects);
  QueryReply info=builder.build().getValuesFromQueryResult().get(0);
  return info.getId();
}"
52974,"/** 
 * Get a single page by its title
 * @param title the page's title
 * @param ns the page's namespace
 * @return the requested LocalPage
 * @throws org.wikapidia.core.dao.DaoException if there was an error retrieving the page
 */
public T getByTitle(Title title,NameSpace ns) throws DaoException {
  Language lang=title.getLanguage();
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang).setTitle(title.getCanonicalTitle().replace(""String_Node_Str"",""String_Node_Str"")).setRedirects(followRedirects);
  QueryReply info=builder.build().getValuesFromQueryResult().get(0);
  return (T)info.getLocalPage(lang);
}","/** 
 * Get a single page by its title
 * @param title the page's title
 * @param ns the page's namespace
 * @return the requested LocalPage
 * @throws org.wikapidia.core.dao.DaoException if there was an error retrieving the page
 */
public T getByTitle(Title title,NameSpace ns) throws DaoException {
  Language lang=title.getLanguage();
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang).addTitle(title.getCanonicalTitle().replace(""String_Node_Str"",""String_Node_Str"")).setRedirects(followRedirects);
  QueryReply info=builder.build().getValuesFromQueryResult().get(0);
  return (T)info.getLocalPage(lang);
}"
52975,"/** 
 * Get a set of pages by their ids
 * @param language the language of the pages
 * @param pageIds a Collection of page ids
 * @return a map of ids to pages
 * @throws org.wikapidia.core.dao.DaoException if there was an error retrieving the pages
 */
public Map<Integer,T> getByIds(Language language,Collection<Integer> pageIds) throws DaoException {
  Map<Integer,T> pageMap=new HashMap<Integer,T>();
  for (  Integer pageId : pageIds) {
    LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language).setPageid(pageId).setRedirects(followRedirects);
    QueryReply info=builder.build().getValuesFromQueryResult().get(0);
    pageMap.put(pageId,(T)info.getLocalPage(language));
  }
  return pageMap;
}","/** 
 * Get a set of pages by their ids
 * @param language the language of the pages
 * @param pageIds a Collection of page ids
 * @return a map of ids to pages
 * @throws org.wikapidia.core.dao.DaoException if there was an error retrieving the pages
 */
public Map<Integer,T> getByIds(Language language,Collection<Integer> pageIds) throws DaoException {
  Map<Integer,T> pageMap=new HashMap<Integer,T>();
  for (  Integer pageId : pageIds) {
    LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language).addPageid(pageId).setRedirects(followRedirects);
    QueryReply info=builder.build().getValuesFromQueryResult().get(0);
    pageMap.put(pageId,(T)info.getLocalPage(language));
  }
  return pageMap;
}"
52976,"public T getById(Language language,int pageId) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language).setPageid(pageId).setRedirects(followRedirects);
  QueryReply info=builder.build().getValuesFromQueryResult().get(0);
  return (T)info.getLocalPage(language);
}","public T getById(Language language,int pageId) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language).addPageid(pageId).setRedirects(followRedirects);
  QueryReply info=builder.build().getValuesFromQueryResult().get(0);
  return (T)info.getLocalPage(language);
}"
52977,"/** 
 * Get a map of pages by their titles
 * @param language the language of the pages
 * @param titles a Collection of page titles
 * @param ns the namespace of the pages
 * @return a map of titles to pages
 * @throws org.wikapidia.core.dao.DaoException if there was an error retrieving the pages
 */
public Map<Title,T> getByTitles(Language language,Collection<Title> titles,NameSpace ns) throws DaoException {
  Map<Title,T> pageMap=new HashMap<Title,T>();
  for (  Title title : titles) {
    LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language).setTitle(title.getCanonicalTitle().replace(""String_Node_Str"",""String_Node_Str"")).setRedirects(followRedirects);
    QueryReply info=builder.build().getValuesFromQueryResult().get(0);
    pageMap.put(title,(T)info.getLocalPage(language));
  }
  return pageMap;
}","/** 
 * Get a map of pages by their titles
 * @param language the language of the pages
 * @param titles a Collection of page titles
 * @param ns the namespace of the pages
 * @return a map of titles to pages
 * @throws org.wikapidia.core.dao.DaoException if there was an error retrieving the pages
 */
public Map<Title,T> getByTitles(Language language,Collection<Title> titles,NameSpace ns) throws DaoException {
  Map<Title,T> pageMap=new HashMap<Title,T>();
  for (  Title title : titles) {
    LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language).addTitle(title.getCanonicalTitle().replace(""String_Node_Str"",""String_Node_Str"")).setRedirects(followRedirects);
    QueryReply info=builder.build().getValuesFromQueryResult().get(0);
    pageMap.put(title,(T)info.getLocalPage(language));
  }
  return pageMap;
}"
52978,"public List<Integer> getRedirectsFromId(Language lang,int localId) throws DaoException {
  List<Integer> redirectIds=new ArrayList<Integer>();
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang);
  builder.setPageid(localId).setFilterredir(""String_Node_Str"");
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    redirectIds.add(reply.pageId);
  }
  return redirectIds;
}","public List<Integer> getRedirectsFromId(Language lang,int localId) throws DaoException {
  List<Integer> redirectIds=new ArrayList<Integer>();
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang);
  builder.addPageid(localId).setFilterredir(""String_Node_Str"");
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    redirectIds.add(reply.pageId);
  }
  return redirectIds;
}"
52979,"public Integer resolveRedirect(Language lang,int id) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang);
  builder.setPageid(id).setRedirects(true);
  LiveAPIQuery query=builder.build();
  int redirectId=query.getValuesFromQueryResult().get(0).pageId;
  if (redirectId != id) {
    return redirectId;
  }
  return null;
}","public Integer resolveRedirect(Language lang,int id) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang);
  builder.addPageid(id).setRedirects(true);
  LiveAPIQuery query=builder.build();
  int redirectId=query.getValuesFromQueryResult().get(0).pageId;
  if (redirectId != id) {
    return redirectId;
  }
  return null;
}"
52980,"public boolean isRedirect(Language lang,int id) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang);
  builder.setPageid(id);
  LiveAPIQuery query=builder.build();
  return query.getValuesFromQueryResult().get(0).isRedirect;
}","public boolean isRedirect(Language lang,int id) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang);
  builder.addPageid(id);
  LiveAPIQuery query=builder.build();
  return query.getValuesFromQueryResult().get(0).isRedirect;
}"
52981,"public TIntIntMap getAllRedirectIdsToDestIds(Language lang) throws DaoException {
  TIntIntMap redirects=new TIntIntHashMap();
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang);
  builder.setFilterredir(""String_Node_Str"").setFrom(""String_Node_Str"");
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    int destId=resolveRedirect(lang,reply.pageId);
    redirects.put(reply.pageId,destId);
  }
  return redirects;
}","public TIntIntMap getAllRedirectIdsToDestIds(Language lang) throws DaoException {
  TIntIntMap redirectToDestIds=new TIntIntHashMap();
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",lang);
  builder.setFilterredir(""String_Node_Str"").setFrom(""String_Node_Str"");
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  int i=0;
  int numReplies=replyObjects.size();
  while (i < numReplies) {
    int batchEndPosn=((numReplies - i) > 500) ? i+=500 : numReplies;
    List<QueryReply> batchReplies=replyObjects.subList(i,batchEndPosn);
    List<Integer> redirectIds=new ArrayList<Integer>();
    for (    QueryReply reply : batchReplies) {
      redirectIds.add(reply.getId());
    }
    Map<Integer,Integer> batch=resolveRedirects(lang,redirectIds);
    for (    int redirectId : batch.keySet()) {
      redirectToDestIds.put(redirectId,batch.get(redirectId));
    }
  }
  return redirectToDestIds;
}"
52982,"private static File downloadFile(String folderUrl,String fileName,File localFolder){
  try {
    System.out.println(""String_Node_Str"");
    URL url=new URL(folderUrl + fileName);
    String localPath=localFolder.getAbsolutePath() + ""String_Node_Str"" + fileName;
    File dest=new File(localPath);
    if (!dest.exists()) {
      System.out.println(""String_Node_Str"");
      FileUtils.copyURLToFile(url,dest,60000,60000);
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    File ungzipDest=new File(localPath.split(""String_Node_Str"")[0] + ""String_Node_Str"");
    if (!ungzipDest.exists()) {
      ungzip(dest,ungzipDest);
    }
    System.out.println(""String_Node_Str"");
    return ungzipDest;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return null;
  }
}","private static File downloadFile(String folderUrl,String fileName,File localFolder){
  try {
    System.out.println(""String_Node_Str"");
    URL url=new URL(folderUrl + fileName);
    String localPath=localFolder.getAbsolutePath() + ""String_Node_Str"" + fileName;
    File dest=new File(localPath);
    if (!dest.exists()) {
      System.out.println(""String_Node_Str"");
      FileUtils.copyURLToFile(url,dest,60000,60000);
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    File ungzipDest=new File(localPath.split(""String_Node_Str"")[0] + ""String_Node_Str"");
    if (!ungzipDest.exists()) {
      ungzip(dest,ungzipDest);
    }
    System.out.println(""String_Node_Str"");
    return ungzipDest;
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return null;
  }
}"
52983,"private static TIntIntMap parsePageViewDataFromFile(Language lang,File f) throws WikapidiaException, DaoException, ConfigurationException {
  try {
    Env env=new EnvBuilder().build();
    TIntIntMap data=new TIntIntHashMap();
    Configurator configurator=env.getConfigurator();
    LocalPageDao pdao=configurator.get(LocalPageDao.class,""String_Node_Str"");
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(f),""String_Node_Str""));
    String curLine;
    System.out.println(""String_Node_Str"");
    double start=System.currentTimeMillis();
    while ((curLine=br.readLine()) != null) {
      String[] cols=curLine.split(""String_Node_Str"");
      if (cols[0].equals(lang.getLangCode())) {
        try {
          String title=URLDecoder.decode(cols[1],""String_Node_Str"");
          int pageId=pdao.getIdByTitle(new Title(title,lang));
          int numPageViews=Integer.parseInt(cols[2]);
          data.adjustOrPutValue(pageId,numPageViews,numPageViews);
        }
 catch (        IllegalArgumentException e) {
          System.out.println(""String_Node_Str"" + curLine);
        }
catch (        DaoException de) {
          System.out.println(""String_Node_Str"" + curLine);
          System.out.println(de.getMessage());
        }
      }
    }
    br.close();
    return data;
  }
 catch (  IOException e) {
    throw new WikapidiaException(e);
  }
}","private static TIntIntMap parsePageViewDataFromFile(Language lang,File f) throws WikapidiaException, DaoException, ConfigurationException {
  try {
    Env env=new EnvBuilder().build();
    TIntIntMap data=new TIntIntHashMap();
    Configurator configurator=env.getConfigurator();
    LocalPageDao pdao=configurator.get(LocalPageDao.class,""String_Node_Str"");
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(f),""String_Node_Str""));
    String curLine;
    System.out.println(""String_Node_Str"");
    while ((curLine=br.readLine()) != null) {
      String[] cols=curLine.split(""String_Node_Str"");
      if (cols[0].equals(lang.getLangCode())) {
        try {
          String title=URLDecoder.decode(cols[1],""String_Node_Str"");
          int pageId=pdao.getIdByTitle(new Title(title,lang));
          int numPageViews=Integer.parseInt(cols[2]);
          data.adjustOrPutValue(pageId,numPageViews,numPageViews);
        }
 catch (        IllegalArgumentException e) {
          System.out.println(""String_Node_Str"" + curLine);
        }
catch (        DaoException de) {
          System.out.println(""String_Node_Str"" + curLine);
          System.out.println(de.getMessage());
        }
      }
    }
    br.close();
    return data;
  }
 catch (  IOException e) {
    throw new WikapidiaException(e);
  }
}"
52984,"/** 
 * gets a PageViewDataStruct containing page view info for one hour beginning with current date then increments currentDate by an hour so that this method will get page view info for the next hour next time it's called
 * @return PageViewDataStruct for the current hour, or null if currentDate isn't more recent than endDate
 * @throws WikapidiaException
 * @throws DaoException
 */
private PageViewDataStruct getPageViewData() throws WikapidiaException, DaoException, ConfigurationException {
  if (currentDate.getMillis() >= endDate.getMillis()) {
    return null;
  }
  File tempFolder=new File(""String_Node_Str"" + lang.getLangCode() + ""String_Node_Str"");
  if (!tempFolder.exists()) {
    tempFolder.mkdir();
  }
  String yearString=((Integer)currentDate.getYear()).toString();
  String monthString=twoDigIntStr(currentDate.getMonthOfYear());
  String dayString=twoDigIntStr(currentDate.getDayOfMonth());
  String hourString=twoDigIntStr(currentDate.getHourOfDay());
  String fileName=""String_Node_Str"" + yearString + monthString+ dayString+ ""String_Node_Str""+ hourString;
  String fileNameSuffix=""String_Node_Str"";
  String homeFolder=BASE_URL + String.format(""String_Node_Str"",yearString,yearString,monthString);
  File pageViewDataFile=null;
  int minutes=0;
  while (pageViewDataFile == null && minutes < 60) {
    int seconds=0;
    while (pageViewDataFile == null && seconds < 60) {
      String minutesString=twoDigIntStr(minutes);
      String secondsString=twoDigIntStr(seconds);
      fileName+=minutesString + secondsString + fileNameSuffix;
      pageViewDataFile=downloadFile(homeFolder,fileName,tempFolder);
      seconds++;
    }
    minutes++;
  }
  TIntIntMap pageViewCounts=parsePageViewDataFromFile(lang,pageViewDataFile);
  DateTime nextDate=currentDate.plusHours(1);
  PageViewDataStruct pageViewData=new PageViewDataStruct(lang,currentDate,nextDate,pageViewCounts);
  currentDate=nextDate;
  return pageViewData;
}","/** 
 * gets a PageViewDataStruct containing page view info for one hour beginning with current date then increments currentDate by an hour so that this method will get page view info for the next hour next time it's called
 * @return PageViewDataStruct for the current hour, or null if currentDate isn't more recent than endDate
 * @throws WikapidiaException
 * @throws DaoException
 */
private PageViewDataStruct getPageViewData() throws WikapidiaException, DaoException, ConfigurationException {
  if (currentDate.getMillis() >= endDate.getMillis()) {
    return null;
  }
  File tempFolder=new File(""String_Node_Str"" + lang.getLangCode() + ""String_Node_Str"");
  if (!tempFolder.exists()) {
    tempFolder.mkdir();
  }
  String yearString=((Integer)currentDate.getYear()).toString();
  String monthString=twoDigIntStr(currentDate.getMonthOfYear());
  String dayString=twoDigIntStr(currentDate.getDayOfMonth());
  String hourString=twoDigIntStr(currentDate.getHourOfDay());
  String fileNameSuffix=""String_Node_Str"";
  String homeFolder=BASE_URL + String.format(""String_Node_Str"",yearString,yearString,monthString);
  File pageViewDataFile=null;
  int minutes=0;
  while (pageViewDataFile == null && minutes < 60) {
    int seconds=0;
    while (pageViewDataFile == null && seconds < 60) {
      String minutesString=twoDigIntStr(minutes);
      String secondsString=twoDigIntStr(seconds);
      String fileName=""String_Node_Str"" + yearString + monthString+ dayString+ ""String_Node_Str""+ hourString+ minutesString+ secondsString+ fileNameSuffix;
      pageViewDataFile=downloadFile(homeFolder,fileName,tempFolder);
      seconds++;
    }
    minutes++;
  }
  TIntIntMap pageViewCounts=parsePageViewDataFromFile(lang,pageViewDataFile);
  DateTime nextDate=currentDate.plusHours(1);
  PageViewDataStruct pageViewData=new PageViewDataStruct(lang,currentDate,nextDate,pageViewCounts);
  currentDate=nextDate;
  return pageViewData;
}"
52985,"public static void main(String[] args) throws WikapidiaException, DaoException, ConfigurationException {
  Language lang=Language.getByLangCode(""String_Node_Str"");
  Env env=new EnvBuilder().build();
  Configurator configurator=env.getConfigurator();
  LocalPageDao pdao=configurator.get(LocalPageDao.class,""String_Node_Str"");
  PageViewIterator it=new PageViewIterator(lang,2013,12,8,1,2013,12,8,3);
  int i=0;
  while (i < 2) {
    double start=System.currentTimeMillis();
    PageViewDataStruct data=it.next();
    double elapsed=(System.currentTimeMillis() - start) / 1000;
    System.out.println(""String_Node_Str"" + elapsed + ""String_Node_Str""+ i);
    TIntIntMap stats=data.getPageViewStats();
    for (    int pageId : stats.keys()) {
      try {
        Title page=pdao.getById(lang,pageId).getTitle();
        System.out.println(""String_Node_Str"" + page + ""String_Node_Str""+ stats.get(pageId));
      }
 catch (      NullPointerException e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
        e.printStackTrace();
        continue;
      }
    }
    i++;
  }
}","public static void main(String[] args) throws WikapidiaException, DaoException, ConfigurationException {
  Language lang=Language.getByLangCode(""String_Node_Str"");
  Env env=new EnvBuilder().build();
  Configurator configurator=env.getConfigurator();
  LocalPageDao pdao=configurator.get(LocalPageDao.class,""String_Node_Str"");
  PageViewIterator it=new PageViewIterator(lang,2013,12,8,1,2013,12,8,5);
  int i=0;
  while (it.hasNext()) {
    double start=System.currentTimeMillis();
    PageViewDataStruct data=it.next();
    double elapsed=(System.currentTimeMillis() - start) / 1000;
    System.out.println(""String_Node_Str"" + elapsed + ""String_Node_Str""+ i);
    TIntIntMap stats=data.getPageViewStats();
    for (    int pageId : stats.keys()) {
      try {
        Title page=pdao.getById(lang,pageId).getTitle();
        System.out.println(""String_Node_Str"" + page + ""String_Node_Str""+ stats.get(pageId));
      }
 catch (      NullPointerException e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
        e.printStackTrace();
        continue;
      }
    }
    i++;
  }
}"
52986,"public static void main(String[] args) throws WikapidiaException, DaoException {
  Language lang=Language.getByLangCode(""String_Node_Str"");
  LocalPageLiveDao pdao=new LocalPageLiveDao();
  PageViewIterator it=new PageViewIterator(lang,2013,12,8,1,2013,12,8,2);
  int i=0;
  while (i < 2) {
    double start=System.currentTimeMillis();
    PageViewDataStruct data=it.next();
    double elapsed=(System.currentTimeMillis() - start) / 1000;
    System.out.println(""String_Node_Str"" + elapsed + ""String_Node_Str""+ i);
    TIntIntMap stats=data.getPageViewStats();
    for (    int pageId : stats.keys()) {
      Title page=pdao.getById(lang,pageId).getTitle();
      System.out.println(""String_Node_Str"" + page + ""String_Node_Str""+ stats.get(pageId));
    }
  }
}","public static void main(String[] args) throws WikapidiaException, DaoException {
  Language lang=Language.getByLangCode(""String_Node_Str"");
  LocalPageLiveDao pdao=new LocalPageLiveDao();
  PageViewIterator it=new PageViewIterator(lang,2013,12,8,1,2013,12,8,3);
  int i=0;
  while (i < 2) {
    double start=System.currentTimeMillis();
    PageViewDataStruct data=it.next();
    double elapsed=(System.currentTimeMillis() - start) / 1000;
    System.out.println(""String_Node_Str"" + elapsed + ""String_Node_Str""+ i);
    TIntIntMap stats=data.getPageViewStats();
    for (    int pageId : stats.keys()) {
      Title page=pdao.getById(lang,pageId).getTitle();
      System.out.println(""String_Node_Str"" + page + ""String_Node_Str""+ stats.get(pageId));
    }
    i++;
  }
}"
52987,"public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  LocalLinkDao ldao=new Configurator(new Configuration()).get(LocalLinkDao.class,""String_Node_Str"");
  Language lang=Language.getByLangCode(""String_Node_Str"");
  int sourceId=5079506;
  int destId=454136;
  LocalLink link=ldao.getLink(lang,sourceId,destId);
  System.out.println(""String_Node_Str"" + link.getAnchorText() + ""String_Node_Str""+ sourceId+ ""String_Node_Str""+ destId);
  Iterable<LocalLink> inlinks=ldao.getLinks(lang,sourceId,false);
  System.out.println(""String_Node_Str"" + sourceId + ""String_Node_Str"");
  for (  LocalLink inlink : inlinks) {
    System.out.println(""String_Node_Str"" + inlink.getAnchorText() + ""String_Node_Str""+ inlink.getDestId());
  }
  Iterable<LocalLink> outlinks=ldao.getLinks(lang,sourceId,true);
  System.out.println(""String_Node_Str"" + sourceId + ""String_Node_Str"");
  for (  LocalLink outlink : outlinks) {
    System.out.println(""String_Node_Str"" + outlink.getAnchorText() + ""String_Node_Str""+ outlink.getDestId());
  }
}","public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  LocalLinkDao ldao=new Configurator(new Configuration()).get(LocalLinkDao.class,""String_Node_Str"");
  Language lang=Language.getByLangCode(""String_Node_Str"");
  int sourceId=5079506;
  int destId=454136;
  LocalLink link=ldao.getLink(lang,sourceId,destId);
  System.out.println(""String_Node_Str"" + link.getAnchorText() + ""String_Node_Str""+ sourceId+ ""String_Node_Str""+ destId);
  Iterable<LocalLink> inlinks=ldao.getLinks(lang,sourceId,false);
  System.out.println(""String_Node_Str"" + sourceId + ""String_Node_Str"");
  for (  LocalLink inlink : inlinks) {
    System.out.println(""String_Node_Str"" + inlink.getAnchorText() + ""String_Node_Str""+ inlink.getSourceId());
  }
  Iterable<LocalLink> outlinks=ldao.getLinks(lang,sourceId,true);
  System.out.println(""String_Node_Str"" + sourceId + ""String_Node_Str"");
  for (  LocalLink outlink : outlinks) {
    System.out.println(""String_Node_Str"" + outlink.getAnchorText() + ""String_Node_Str""+ outlink.getDestId());
  }
}"
52988,"public Iterable<LocalLink> getLinks(Language language,int localId,boolean outlinks) throws DaoException {
  List<LocalLink> links=new ArrayList<LocalLink>();
  LiveAPIQuery.LiveAPIQueryBuilder builder;
  if (outlinks) {
    builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  }
 else {
    builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  }
  builder.setPageid(localId);
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    LocalLink link=reply.getLocalLink(language,localId,outlinks);
    links.add(link);
  }
  return links;
}","public Iterable<LocalLink> getLinks(Language language,int localId,boolean outlinks) throws DaoException {
  List<LocalLink> links=new ArrayList<LocalLink>();
  LiveAPIQuery.LiveAPIQueryBuilder builder;
  if (outlinks) {
    builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  }
 else {
    builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  }
  builder.setPageid(localId);
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    LocalLink link=outlinks ? reply.getLocalOutLink(language,localId) : reply.getLocalInLink(language,localId);
    links.add(link);
  }
  return links;
}"
52989,"public LocalLink getLink(Language language,int sourceId,int destId) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  builder.setPageid(sourceId);
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    int pageId=reply.pageId;
    if (pageId == destId) {
      return reply.getLocalLink(language,sourceId,true);
    }
  }
  throw new DaoException(""String_Node_Str"");
}","public LocalLink getLink(Language language,int sourceId,int destId) throws DaoException {
  LiveAPIQuery.LiveAPIQueryBuilder builder=new LiveAPIQuery.LiveAPIQueryBuilder(""String_Node_Str"",language);
  builder.setPageid(sourceId);
  LiveAPIQuery query=builder.build();
  List<QueryReply> replyObjects=query.getValuesFromQueryResult();
  for (  QueryReply reply : replyObjects) {
    int pageId=reply.pageId;
    if (pageId == destId) {
      return reply.getLocalOutLink(language,sourceId);
    }
  }
  throw new DaoException(""String_Node_Str"");
}"
52990,"private static List<String> csv2List(String csv){
  if (csv.length() > 0) {
    return Arrays.asList(csv.split(""String_Node_Str""));
  }
 else {
    return new ArrayList<String>();
  }
}","private static List<String> csv2List(String csv){
  if (csv.length() > 0) {
    if (csv.charAt(0) == '""' && csv.charAt(csv.length() - 1) == '""') {
      csv=csv.substring(1,csv.length() - 1);
    }
    return Arrays.asList(csv.split(""String_Node_Str""));
  }
 else {
    return new ArrayList<String>();
  }
}"
52991,"public static void main(String args[]) throws IOException, InterruptedException {
  run(LuceneLoader.class,args);
  run(ConceptLoader.class,ArrayUtils.add(args,""String_Node_Str""));
  run(UniversalLinkLoader.class,ArrayUtils.add(args,""String_Node_Str""));
  run(PhraseLoader.class,ArrayUtils.addAll(args,""String_Node_Str"",""String_Node_Str""));
}","public static void main(String args[]) throws IOException, InterruptedException {
  run(RequestedLinkGetter.class,args);
  run(FileDownloader.class,args);
  run(DumpLoader.class,ArrayUtils.addAll(args,""String_Node_Str""));
  run(RedirectLoader.class,ArrayUtils.add(args,""String_Node_Str""));
  run(WikiTextLoader.class,ArrayUtils.add(args,""String_Node_Str""));
  run(LuceneLoader.class,args);
  run(ConceptLoader.class,ArrayUtils.add(args,""String_Node_Str""));
  run(UniversalLinkLoader.class,ArrayUtils.add(args,""String_Node_Str""));
  run(PhraseLoader.class,ArrayUtils.addAll(args,""String_Node_Str"",""String_Node_Str""));
}"
52992,"public static void main(String args[]) throws ConfigurationException, DaoException {
  Configurator configurator=new Configurator(new Configuration());
  LocalLinkDao sqlDao=configurator.get(LocalLinkDao.class,""String_Node_Str"");
  LocalLinkDao matrixDao=configurator.get(LocalLinkDao.class,""String_Node_Str"");
  Map<LocalId,Set<LocalId>> outGraph=new HashMap<LocalId,Set<LocalId>>();
  Map<LocalId,Set<LocalId>> inGraph=new HashMap<LocalId,Set<LocalId>>();
  long start=System.currentTimeMillis();
  int i=0;
  for (  LocalLink ll : sqlDao.get(new DaoFilter())) {
    if (ll.getSourceId() < 0 || ll.getDestId() < 0) {
      continue;
    }
    LocalId src=new LocalId(ll.getLanguage(),ll.getSourceId());
    LocalId dest=new LocalId(ll.getLanguage(),ll.getDestId());
    if (!outGraph.containsKey(src)) {
      outGraph.put(src,new HashSet<LocalId>());
    }
    outGraph.get(src).add(dest);
    if (!inGraph.containsKey(dest)) {
      inGraph.put(dest,new HashSet<LocalId>());
    }
    inGraph.get(dest).add(src);
    i++;
  }
  double elapsed=(System.currentTimeMillis() - start) / 1000.0;
  System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
  start=System.currentTimeMillis();
  int different=0;
  int adds=0;
  int dels=0;
  for (  LocalId src : outGraph.keySet()) {
    Set<LocalId> expected=outGraph.get(src);
    Set<LocalId> actual=new HashSet<LocalId>();
    for (    LocalLink ll : matrixDao.getLinks(src.getLanguage(),src.getId(),true)) {
      if (ll.getSourceId() < 0 || ll.getDestId() < 0) {
        continue;
      }
      actual.add(new LocalId(ll.getLanguage(),ll.getDestId()));
    }
    if (!actual.equals(expected)) {
      System.out.println(""String_Node_Str"" + actual + ""String_Node_Str""+ expected);
      different++;
    }
    adds+=retainedSize(actual,expected);
    dels+=retainedSize(expected,actual);
  }
  elapsed=(System.currentTimeMillis() - start) / 1000.0;
  System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + different);
  System.out.println(""String_Node_Str"" + adds);
  System.out.println(""String_Node_Str"" + dels);
}","public static void main(String args[]) throws ConfigurationException, DaoException {
  Env env=new EnvBuilder().build();
  Configurator configurator=env.getConfigurator();
  LocalLinkDao sqlDao=configurator.get(LocalLinkDao.class,""String_Node_Str"");
  LocalLinkDao matrixDao=configurator.get(LocalLinkDao.class,""String_Node_Str"");
  Map<LocalId,Set<LocalId>> outGraph=new HashMap<LocalId,Set<LocalId>>();
  Map<LocalId,Set<LocalId>> inGraph=new HashMap<LocalId,Set<LocalId>>();
  long start=System.currentTimeMillis();
  int i=0;
  for (  LocalLink ll : sqlDao.get(new DaoFilter())) {
    if (ll.getSourceId() < 0 || ll.getDestId() < 0) {
      continue;
    }
    LocalId src=new LocalId(ll.getLanguage(),ll.getSourceId());
    LocalId dest=new LocalId(ll.getLanguage(),ll.getDestId());
    if (!outGraph.containsKey(src)) {
      outGraph.put(src,new HashSet<LocalId>());
    }
    outGraph.get(src).add(dest);
    if (!inGraph.containsKey(dest)) {
      inGraph.put(dest,new HashSet<LocalId>());
    }
    inGraph.get(dest).add(src);
    i++;
  }
  double elapsed=(System.currentTimeMillis() - start) / 1000.0;
  System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
  start=System.currentTimeMillis();
  int different=0;
  int adds=0;
  int dels=0;
  for (  LocalId src : outGraph.keySet()) {
    Set<LocalId> expected=outGraph.get(src);
    Set<LocalId> actual=new HashSet<LocalId>();
    for (    LocalLink ll : matrixDao.getLinks(src.getLanguage(),src.getId(),true)) {
      if (ll.getSourceId() < 0 || ll.getDestId() < 0) {
        continue;
      }
      actual.add(new LocalId(ll.getLanguage(),ll.getDestId()));
    }
    if (!actual.equals(expected)) {
      System.out.println(""String_Node_Str"" + actual + ""String_Node_Str""+ expected);
      different++;
    }
    adds+=retainedSize(actual,expected);
    dels+=retainedSize(expected,actual);
  }
  elapsed=(System.currentTimeMillis() - start) / 1000.0;
  System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + different);
  System.out.println(""String_Node_Str"" + adds);
  System.out.println(""String_Node_Str"" + dels);
}"
52993,"@Test public void testGetOutlinks() throws ConfigurationException, DaoException {
  UniversalLinkDao dao=new Configurator(new Configuration()).get(UniversalLinkDao.class,""String_Node_Str"");
  long start=System.currentTimeMillis();
  UniversalLinkGroup links=dao.getOutlinks(0,0);
  int i=0;
  for (  UniversalLink link : links) {
    i++;
    System.out.println(i + ""String_Node_Str"" + link.getDestId());
  }
  long end=System.currentTimeMillis();
  long total=end - start;
  double seconds=total / 1000.0;
  System.out.println(""String_Node_Str"" + seconds);
  System.out.println(""String_Node_Str"" + total / (double)i);
}","@Test public void testGetOutlinks() throws ConfigurationException, DaoException {
  Env env=new EnvBuilder().build();
  Configurator configurator=env.getConfigurator();
  UniversalLinkDao dao=configurator.get(UniversalLinkDao.class,""String_Node_Str"");
  long start=System.currentTimeMillis();
  UniversalLinkGroup links=dao.getOutlinks(0,0);
  int i=0;
  for (  UniversalLink link : links) {
    i++;
    System.out.println(i + ""String_Node_Str"" + link.getDestId());
  }
  long end=System.currentTimeMillis();
  long total=end - start;
  double seconds=total / 1000.0;
  System.out.println(""String_Node_Str"" + seconds);
  System.out.println(""String_Node_Str"" + total / (double)i);
}"
52994,"@Test public void benchmarkTest() throws ConfigurationException, DaoException {
  UniversalLinkDao dao=new Configurator(new Configuration()).get(UniversalLinkDao.class,""String_Node_Str"");
  long start=System.currentTimeMillis();
  Iterable<UniversalLink> links=dao.get(new DaoFilter());
  int i=0;
  for (  UniversalLink link : links) {
    i++;
    if (i % 100000 == 0)     System.out.println(""String_Node_Str"" + i);
  }
  long end=System.currentTimeMillis();
  long total=end - start;
  double seconds=total / 1000.0;
  System.out.println(""String_Node_Str"" + seconds);
  System.out.println(""String_Node_Str"" + total / (double)i);
}","@Test public void benchmarkTest() throws ConfigurationException, DaoException {
  Env env=new EnvBuilder().build();
  Configurator configurator=env.getConfigurator();
  UniversalLinkDao dao=configurator.get(UniversalLinkDao.class,""String_Node_Str"");
  long start=System.currentTimeMillis();
  Iterable<UniversalLink> links=dao.get(new DaoFilter());
  int i=0;
  for (  UniversalLink link : links) {
    i++;
    if (i % 100000 == 0)     System.out.println(""String_Node_Str"" + i);
  }
  long end=System.currentTimeMillis();
  long total=end - start;
  double seconds=total / 1000.0;
  System.out.println(""String_Node_Str"" + seconds);
  System.out.println(""String_Node_Str"" + total / (double)i);
}"
52995,"public static void main(String args[]) throws ConfigurationException, DaoException {
  Configurator configurator=new Configurator(new Configuration());
  UniversalPageDao pdao=configurator.get(UniversalPageDao.class);
  UniversalLinkDao ldao=configurator.get(UniversalLinkDao.class);
  LocalPageDao lpDao=configurator.get(LocalPageDao.class);
  int i=0;
  for (  UniversalPage page : (Iterable<UniversalPage>)pdao.get(new DaoFilter().setNameSpaces(NameSpace.ARTICLE))) {
    for (    LocalId lId : page.getLocalEntities()) {
      LocalPage lPage=lpDao.getById(lId.getLanguage(),lId.getId());
      System.out.println(lPage);
    }
    System.out.println();
    i++;
  }
  System.out.println(""String_Node_Str"" + i);
}","public static void main(String args[]) throws ConfigurationException, DaoException {
  Env env=new EnvBuilder().build();
  Configurator configurator=env.getConfigurator();
  UniversalPageDao pdao=configurator.get(UniversalPageDao.class);
  UniversalLinkDao ldao=configurator.get(UniversalLinkDao.class);
  LocalPageDao lpDao=configurator.get(LocalPageDao.class);
  int i=0;
  for (  UniversalPage page : (Iterable<UniversalPage>)pdao.get(new DaoFilter().setNameSpaces(NameSpace.ARTICLE))) {
    for (    LocalId lId : page.getLocalEntities()) {
      LocalPage lPage=lpDao.getById(lId.getLanguage(),lId.getId());
      System.out.println(lPage);
    }
    System.out.println();
    i++;
  }
  System.out.println(""String_Node_Str"" + i);
}"
52996,"public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  Language lang=Language.getByLangCode(""String_Node_Str"");
  Configurator c=new Configurator(new Configuration());
  PhraseAnalyzer pa=c.get(PhraseAnalyzer.class,""String_Node_Str"");
  LocalPageDao pageDao=c.get(LocalPageDao.class);
  LocalPage page=pageDao.getByTitle(new Title(""String_Node_Str"",lang),NameSpace.ARTICLE);
  System.out.println(""String_Node_Str"" + page + ""String_Node_Str"");
  LinkedHashMap<String,Float> description=pa.describeLocal(lang,page,20);
  if (description == null) {
    System.out.println(""String_Node_Str"");
  }
 else {
    for (    String phrase : description.keySet()) {
      System.out.println(""String_Node_Str"" + phrase + ""String_Node_Str""+ description.get(phrase));
    }
  }
}","public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  Env env=new EnvBuilder().build();
  Configurator c=env.getConfigurator();
  Language lang=Language.getByLangCode(""String_Node_Str"");
  PhraseAnalyzer pa=c.get(PhraseAnalyzer.class,""String_Node_Str"");
  LocalPageDao pageDao=c.get(LocalPageDao.class);
  LocalPage page=pageDao.getByTitle(new Title(""String_Node_Str"",lang),NameSpace.ARTICLE);
  System.out.println(""String_Node_Str"" + page + ""String_Node_Str"");
  LinkedHashMap<String,Float> description=pa.describeLocal(lang,page,20);
  if (description == null) {
    System.out.println(""String_Node_Str"");
  }
 else {
    for (    String phrase : description.keySet()) {
      System.out.println(""String_Node_Str"" + phrase + ""String_Node_Str""+ description.get(phrase));
    }
  }
}"
52997,"private void insertBatches() throws DaoException, SQLException, InterruptedException {
  Connection cnx=ds.getConnection();
  try {
    String[] names=new String[fields.length];
    String[] questions=new String[fields.length];
    for (int i=0; i < fields.length; i++) {
      names[i]=fields[i].getName();
      questions[i]=""String_Node_Str"";
    }
    String sql=""String_Node_Str"" + table.getName() + ""String_Node_Str""+ StringUtils.join(names,""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtils.join(questions,""String_Node_Str"")+ ""String_Node_Str"";
    PreparedStatement statement=cnx.prepareStatement(sql);
    while (!rowBuffer.isEmpty() || !finished) {
      int batchSize=0;
      while (batchSize < BATCH_SIZE) {
        Object row[]=rowBuffer.poll(100,TimeUnit.MILLISECONDS);
        if (row == null && finished) {
          break;
        }
        if (row != null) {
          batchSize++;
          for (int i=0; i < row.length; i++) {
            statement.setObject(i + 1,row[i]);
          }
          statement.addBatch();
        }
      }
      try {
        statement.executeBatch();
      }
 catch (      SQLException e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
      }
      statement.clearBatch();
    }
    cnx.commit();
  }
  finally {
    AbstractSqlDao.quietlyCloseConn(cnx);
  }
}","private void insertBatches() throws DaoException, SQLException, InterruptedException {
  Connection cnx=ds.getConnection();
  try {
    String[] names=new String[fields.length];
    String[] questions=new String[fields.length];
    for (int i=0; i < fields.length; i++) {
      names[i]=fields[i].getName();
      questions[i]=""String_Node_Str"";
    }
    String sql=""String_Node_Str"" + table.getName() + ""String_Node_Str""+ StringUtils.join(names,""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtils.join(questions,""String_Node_Str"")+ ""String_Node_Str"";
    PreparedStatement statement=cnx.prepareStatement(sql);
    while (!(rowBuffer.isEmpty() && finished)) {
      int batchSize=0;
      while (batchSize < BATCH_SIZE) {
        Object row[]=rowBuffer.poll(100,TimeUnit.MILLISECONDS);
        if (row == null && finished) {
          break;
        }
        if (row != null) {
          batchSize++;
          for (int i=0; i < row.length; i++) {
            statement.setObject(i + 1,row[i]);
          }
          statement.addBatch();
        }
      }
      try {
        statement.executeBatch();
      }
 catch (      SQLException e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
      }
      statement.clearBatch();
    }
    cnx.commit();
  }
  finally {
    AbstractSqlDao.quietlyCloseConn(cnx);
  }
}"
52998,"public void load(Object[] values) throws DaoException {
  if (inserter == null) {
    System.exit(1);
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (values.length != fields.length) {
    throw new IllegalArgumentException();
  }
  try {
    rowBuffer.put(values);
  }
 catch (  InterruptedException e) {
    throw new DaoException(e);
  }
}","public void load(Object[] values) throws DaoException {
  if (inserter == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (values.length != fields.length) {
    throw new IllegalArgumentException();
  }
  try {
    rowBuffer.put(values);
  }
 catch (  InterruptedException e) {
    throw new DaoException(e);
  }
}"
52999,"public void endLoad() throws DaoException {
  finished=true;
  if (inserter != null) {
    try {
      inserter.join(10000);
    }
 catch (    InterruptedException e) {
      throw new DaoException(e);
    }
  }
}","public void endLoad() throws DaoException {
  finished=true;
  if (inserter != null) {
    try {
      inserter.join(60000);
    }
 catch (    InterruptedException e) {
      throw new DaoException(e);
    }
  }
}"
53000,"public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  Options options=new Options();
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  EnvBuilder.addStandardOptions(options);
  CommandLineParser parser=new PosixParser();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return;
  }
  Env env=new EnvBuilder(cmd).build();
  Configurator conf=env.getConfigurator();
  List<ParserVisitor> visitors=new ArrayList<ParserVisitor>();
  RawPageDao rpDao=conf.get(RawPageDao.class);
  LocalPageDao lpDao=conf.get(LocalPageDao.class);
  LocalLinkDao llDao=conf.get(LocalLinkDao.class);
  LocalCategoryMemberDao lcmDao=conf.get(LocalCategoryMemberDao.class);
  MetaInfoDao metaDao=conf.get(MetaInfoDao.class);
  ParserVisitor linkVisitor=new LocalLinkVisitor(llDao,lpDao,metaDao);
  ParserVisitor catVisitor=new LocalCategoryVisitor(lpDao,lcmDao,metaDao);
  visitors.add(linkVisitor);
  visitors.add(catVisitor);
  final WikiTextLoader loader=new WikiTextLoader(visitors,env.getLanguages(),rpDao,env.getMaxThreads());
  if (cmd.hasOption(""String_Node_Str"")) {
    llDao.clear();
    lcmDao.clear();
    metaDao.clear(LocalLink.class);
    metaDao.clear(LocalCategoryMember.class);
  }
  llDao.beginLoad();
  lcmDao.beginLoad();
  metaDao.beginLoad();
  ParallelForEach.loop(env.getLanguages().getLanguages(),Math.max(1,env.getMaxThreads() / maxThreadsPerLang),new Procedure<Language>(){
    @Override public void call(    Language lang) throws Exception {
      loader.load(LanguageInfo.getByLanguage(lang));
    }
  }
);
  llDao.endLoad();
  lcmDao.endLoad();
  metaDao.endLoad();
  System.exit(0);
}","public static void main(String args[]) throws ConfigurationException, DaoException, IOException {
  Options options=new Options();
  options.addOption(new DefaultOptionBuilder().withLongOpt(""String_Node_Str"").withDescription(""String_Node_Str"").create(""String_Node_Str""));
  EnvBuilder.addStandardOptions(options);
  CommandLineParser parser=new PosixParser();
  CommandLine cmd;
  try {
    cmd=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    new HelpFormatter().printHelp(""String_Node_Str"",options);
    return;
  }
  Env env=new EnvBuilder(cmd).build();
  Configurator conf=env.getConfigurator();
  List<ParserVisitor> visitors=new ArrayList<ParserVisitor>();
  RawPageDao rpDao=conf.get(RawPageDao.class);
  LocalPageDao lpDao=conf.get(LocalPageDao.class);
  LocalLinkDao llDao=conf.get(LocalLinkDao.class);
  LocalCategoryMemberDao lcmDao=conf.get(LocalCategoryMemberDao.class);
  MetaInfoDao metaDao=conf.get(MetaInfoDao.class);
  ParserVisitor linkVisitor=new LocalLinkVisitor(llDao,lpDao,metaDao);
  ParserVisitor catVisitor=new LocalCategoryVisitor(lpDao,lcmDao,metaDao);
  visitors.add(linkVisitor);
  visitors.add(catVisitor);
  final WikiTextLoader loader=new WikiTextLoader(visitors,env.getLanguages(),rpDao,env.getMaxThreads());
  if (cmd.hasOption(""String_Node_Str"")) {
    llDao.clear();
    lcmDao.clear();
    metaDao.clear(LocalLink.class);
    metaDao.clear(LocalCategoryMember.class);
  }
  llDao.beginLoad();
  lcmDao.beginLoad();
  metaDao.beginLoad();
  ParallelForEach.loop(env.getLanguages().getLanguages(),Math.max(1,env.getMaxThreads() / maxThreadsPerLang),new Procedure<Language>(){
    @Override public void call(    Language lang) throws Exception {
      loader.load(LanguageInfo.getByLanguage(lang));
    }
  }
);
  llDao.endLoad();
  lcmDao.endLoad();
  metaDao.endLoad();
  System.out.println(""String_Node_Str"" + metaDao.getInfo(LocalLink.class).getNumErrors() + ""String_Node_Str"");
  System.exit(0);
}"
