record_number,buggy_code,fixed_code
75001,"/** 
 * Set the line width. The existing stroke will be removed, but the dash array will be preserved if possible.
 */
public void setLineWidth(float lineWidth){
  repaint();
  if (_stroke instanceof BasicStroke) {
    _stroke=new BasicStroke(lineWidth,((BasicStroke)_stroke).getEndCap(),((BasicStroke)_stroke).getLineJoin(),((BasicStroke)_stroke).getMiterLimit(),((BasicStroke)_stroke).getDashArray(),0.0f);
  }
 else {
    new BasicStroke(lineWidth,BasicStroke.CAP_SQUARE,BasicStroke.JOIN_MITER,10.0f,null,0.0f);
  }
  repaint();
}","/** 
 * Set the line width. The existing stroke will be removed, but the dash array will be preserved if possible.
 */
public void setLineWidth(float lineWidth){
  repaint();
  _lineWidth=lineWidth;
  if (_stroke instanceof BasicStroke) {
    _stroke=new BasicStroke(lineWidth,((BasicStroke)_stroke).getEndCap(),((BasicStroke)_stroke).getLineJoin(),((BasicStroke)_stroke).getMiterLimit(),((BasicStroke)_stroke).getDashArray(),0.0f);
  }
 else {
    new BasicStroke(lineWidth,BasicStroke.CAP_SQUARE,BasicStroke.JOIN_MITER,10.0f,_dashArray,0.0f);
  }
  repaint();
}"
75002,"/** 
 * Set the dash array of the stroke. The existing stroke will be removed, but the line width will be preserved if possible.
 */
public void setDashArray(float[] dashArray){
  repaint();
  if (_stroke instanceof BasicStroke) {
    _stroke=new BasicStroke(((BasicStroke)_stroke).getLineWidth(),((BasicStroke)_stroke).getEndCap(),((BasicStroke)_stroke).getLineJoin(),((BasicStroke)_stroke).getMiterLimit(),dashArray,0.0f);
  }
 else {
    _stroke=new BasicStroke(1.0f,BasicStroke.CAP_SQUARE,BasicStroke.JOIN_MITER,10.0f,dashArray,0.0f);
  }
  repaint();
}","/** 
 * Set the dash array of the stroke. The existing stroke will be removed, but the line width will be preserved if possible.
 */
public void setDashArray(float[] dashArray){
  repaint();
  _dashArray=dashArray;
  if (_stroke instanceof BasicStroke) {
    _stroke=new BasicStroke(((BasicStroke)_stroke).getLineWidth(),((BasicStroke)_stroke).getEndCap(),((BasicStroke)_stroke).getLineJoin(),((BasicStroke)_stroke).getMiterLimit(),dashArray,0.0f);
  }
 else {
    _stroke=new BasicStroke(_lineWidth,BasicStroke.CAP_SQUARE,BasicStroke.JOIN_MITER,10.0f,dashArray,0.0f);
  }
  repaint();
}"
75003,"/** 
 * Handle an attribute assignment that is part of an XML element. This method is called prior to the corresponding startElement() call, so it simply accumulates attributes in a hashtable for use by startElement().
 * @param name The name of the attribute.
 * @param value The value of the attribute, or null if the attributeis <code>#IMPLIED</code> and not specified.
 * @param specified True if the value is specified, false if thevalue comes from the default value in the DTD rather than from the XML file.
 * @exception XmlException If the name or value is null.
 */
public void attribute(String name,String value,boolean specified) throws XmlException {
  if (name == null) {
    throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  if (_namespace.equals(_AUTO_NAMESPACE) && (_current != null) && (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str""))) {
    boolean nameSeenAlready=false;
    if (_namespaceTranslationTable != null) {
      String prefix=value;
      String suffix=""String_Node_Str"";
      int period=-1;
      if (value != null) {
        period=value.indexOf(""String_Node_Str"");
      }
      if (period >= 0) {
        prefix=value.substring(0,period);
        suffix=value.substring(period);
      }
      String replacement=(String)_namespaceTranslationTable.get(prefix);
      if (replacement != null) {
        value=replacement + suffix;
        nameSeenAlready=true;
      }
    }
    if (!nameSeenAlready && name.equals(""String_Node_Str"")) {
      String oldValue=value;
      value=_current.uniqueName(oldValue);
      _namespaceTranslationTable.put(oldValue,value);
    }
  }
 else {
    if (!_namespace.equals(_DEFAULT_NAMESPACE) && !_namespace.equals(_AUTO_NAMESPACE) && (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str""))) {
      value=_namespace + ""String_Node_Str"" + value;
    }
  }
  if (_filterList != null) {
    String currentElement=_parser.getCurrentElement();
    Iterator filters=_filterList.iterator();
    String filteredValue=value;
    while (filters.hasNext()) {
      MoMLFilter filter=(MoMLFilter)filters.next();
      filteredValue=filter.filterAttributeValue(_current,currentElement,name,filteredValue);
    }
    if ((value != null) && (filteredValue == null)) {
      _skipElementIsNew=true;
      _skipElementName=currentElement;
      _skipElement++;
    }
    value=filteredValue;
  }
  _attributes.put(name,value);
  _attributeNameList.add(name);
}","/** 
 * Handle an attribute assignment that is part of an XML element. This method is called prior to the corresponding startElement() call, so it simply accumulates attributes in a hashtable for use by startElement().
 * @param name The name of the attribute.
 * @param value The value of the attribute, or null if the attributeis <code>#IMPLIED</code> and not specified.
 * @param specified True if the value is specified, false if thevalue comes from the default value in the DTD rather than from the XML file.
 * @exception XmlException If the name or value is null.
 */
public void attribute(String name,String value,boolean specified) throws XmlException {
  if (name == null) {
    throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  if (_namespace.equals(_AUTO_NAMESPACE) && (_current != null) && (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.startsWith(""String_Node_Str"")|| name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str""))) {
    boolean nameSeenAlready=false;
    if (_namespaceTranslationTable != null) {
      String prefix=value;
      String suffix=""String_Node_Str"";
      int period=-1;
      if (value != null) {
        period=value.indexOf(""String_Node_Str"");
      }
      if (period >= 0) {
        prefix=value.substring(0,period);
        suffix=value.substring(period);
      }
      String replacement=(String)_namespaceTranslationTable.get(prefix);
      if (replacement != null) {
        value=replacement + suffix;
        nameSeenAlready=true;
      }
    }
    if (!nameSeenAlready && name.equals(""String_Node_Str"")) {
      String oldValue=value;
      value=_current.uniqueName(oldValue);
      _namespaceTranslationTable.put(oldValue,value);
    }
  }
 else {
    if (!_namespace.equals(_DEFAULT_NAMESPACE) && !_namespace.equals(_AUTO_NAMESPACE) && (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str""))) {
      value=_namespace + ""String_Node_Str"" + value;
    }
  }
  if (_filterList != null) {
    String currentElement=_parser.getCurrentElement();
    Iterator filters=_filterList.iterator();
    String filteredValue=value;
    while (filters.hasNext()) {
      MoMLFilter filter=(MoMLFilter)filters.next();
      filteredValue=filter.filterAttributeValue(_current,currentElement,name,filteredValue);
    }
    if ((value != null) && (filteredValue == null)) {
      _skipElementIsNew=true;
      _skipElementName=currentElement;
      _skipElement++;
    }
    value=filteredValue;
  }
  _attributes.put(name,value);
  _attributeNameList.add(name);
}"
75004,"private void _placePortFigures(CompositeFigure figure,List portList,int direction){
  Iterator ports=portList.iterator();
  int number=0;
  int count=portList.size();
  while (ports.hasNext()) {
    Port port=(Port)ports.next();
    Figure portFigure=getController().getFigure(port);
    if (portFigure == null) {
      continue;
    }
    Rectangle2D portBounds=portFigure.getShape().getBounds2D();
    PortSite site=new PortSite(figure.getBackgroundFigure(),port,number,count);
    number++;
    double x=site.getX() - portBounds.getCenterX();
    double y=site.getY() - portBounds.getCenterY();
    portFigure.translate(x,y);
    Attribute showRateAttribute=port.getAttribute(""String_Node_Str"");
    if (port instanceof IOPort && showRateAttribute instanceof Variable) {
      boolean showRate=false;
      try {
        showRate=((Variable)showRateAttribute).getToken().equals(BooleanToken.TRUE);
      }
 catch (      Exception ex) {
      }
      if (showRate) {
        String rateString=""String_Node_Str"";
        Variable rateParameter=null;
        if (((IOPort)port).isInput()) {
          rateParameter=(Variable)port.getAttribute(""String_Node_Str"");
          if (rateParameter == null) {
            String altName=""String_Node_Str"";
            rateParameter=(Variable)port.getAttribute(altName);
          }
        }
 else         if (((IOPort)port).isOutput()) {
          rateParameter=(Variable)port.getAttribute(""String_Node_Str"");
          if (rateParameter == null) {
            String altName=""String_Node_Str"";
            rateParameter=(Variable)port.getAttribute(altName);
          }
        }
        if (rateParameter != null) {
          try {
            rateString=rateParameter.getToken().toString();
          }
 catch (          KernelException ex) {
          }
        }
        LabelFigure labelFigure=_createPortLabelFigure(rateString,_portLabelFont,x,y,direction);
        labelFigure.setFillPaint(Color.BLUE);
        figure.add(labelFigure);
      }
    }
    Attribute showAttribute=port.getAttribute(""String_Node_Str"");
    if (showAttribute != null) {
      boolean show=true;
      if (showAttribute instanceof Parameter) {
        try {
          Token token=((Parameter)showAttribute).getToken();
          if (token instanceof BooleanToken) {
            show=((BooleanToken)token).booleanValue();
          }
        }
 catch (        IllegalActionException e) {
        }
      }
      if (show) {
        LabelFigure labelFigure=_createPortLabelFigure(port.getName(),_portLabelFont,x,y,direction);
        figure.add(labelFigure);
      }
    }
  }
}","private void _placePortFigures(CompositeFigure figure,List portList,int direction){
  Iterator ports=portList.iterator();
  int number=0;
  int count=portList.size();
  Figure background=figure.getBackgroundFigure();
  if (background == null) {
    background=figure;
  }
  while (ports.hasNext()) {
    Port port=(Port)ports.next();
    Figure portFigure=getController().getFigure(port);
    if (portFigure == null) {
      continue;
    }
    Rectangle2D portBounds=portFigure.getShape().getBounds2D();
    PortSite site=new PortSite(background,port,number,count);
    number++;
    double x=site.getX() - portBounds.getCenterX();
    double y=site.getY() - portBounds.getCenterY();
    portFigure.translate(x,y);
    Attribute showRateAttribute=port.getAttribute(""String_Node_Str"");
    if (port instanceof IOPort && showRateAttribute instanceof Variable) {
      boolean showRate=false;
      try {
        showRate=((Variable)showRateAttribute).getToken().equals(BooleanToken.TRUE);
      }
 catch (      Exception ex) {
      }
      if (showRate) {
        String rateString=""String_Node_Str"";
        Variable rateParameter=null;
        if (((IOPort)port).isInput()) {
          rateParameter=(Variable)port.getAttribute(""String_Node_Str"");
          if (rateParameter == null) {
            String altName=""String_Node_Str"";
            rateParameter=(Variable)port.getAttribute(altName);
          }
        }
 else         if (((IOPort)port).isOutput()) {
          rateParameter=(Variable)port.getAttribute(""String_Node_Str"");
          if (rateParameter == null) {
            String altName=""String_Node_Str"";
            rateParameter=(Variable)port.getAttribute(altName);
          }
        }
        if (rateParameter != null) {
          try {
            rateString=rateParameter.getToken().toString();
          }
 catch (          KernelException ex) {
          }
        }
        LabelFigure labelFigure=_createPortLabelFigure(rateString,_portLabelFont,x,y,direction);
        labelFigure.setFillPaint(Color.BLUE);
        figure.add(labelFigure);
      }
    }
    Attribute showAttribute=port.getAttribute(""String_Node_Str"");
    if (showAttribute != null) {
      boolean show=true;
      if (showAttribute instanceof Parameter) {
        try {
          Token token=((Parameter)showAttribute).getToken();
          if (token instanceof BooleanToken) {
            show=((BooleanToken)token).booleanValue();
          }
        }
 catch (        IllegalActionException e) {
        }
      }
      if (show) {
        LabelFigure labelFigure=_createPortLabelFigure(port.getName(),_portLabelFont,x,y,direction);
        figure.add(labelFigure);
      }
    }
  }
}"
75005,"/** 
 * Construct a dialog with the specified owner and target. A ""Commit"" and a ""Cancel"" button are added to the dialog. The dialog is placed relative to the owner.
 * @param owner The object that, per the user, appears to begenerating the dialog.
 * @param target The object whose parameters are being edited.
 */
public EditParametersDialog(Frame owner,NamedObj target){
  super(owner,""String_Node_Str"" + target.getName(),new Configurer(target),_moreButtons);
  _owner=owner;
  _target=target;
  if (buttonPressed().equals(""String_Node_Str"")) {
    _openAddDialog(null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    _target.removeChangeListener(this);
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    List attributeList=_target.attributeList(Settable.class);
    Iterator parameters=attributeList.iterator();
    int count=0;
    while (parameters.hasNext()) {
      Settable parameter=(Settable)parameters.next();
      if (Configurer.isVisible(target,parameter)) {
        count++;
      }
    }
    String[] attributeNames=new String[count];
    parameters=attributeList.iterator();
    int index=0;
    while (parameters.hasNext()) {
      Settable parameter=(Settable)parameters.next();
      if (Configurer.isVisible(target,parameter)) {
        attributeNames[index++]=((Attribute)parameter).getName();
      }
    }
    Query query=new Query();
    query.addChoice(""String_Node_Str"",""String_Node_Str"",attributeNames,null,false);
    ComponentDialog dialog=new ComponentDialog(_owner,""String_Node_Str"" + _target.getFullName(),query,null);
    String deleteName=query.getStringValue(""String_Node_Str"");
    if (dialog.buttonPressed().equals(""String_Node_Str"") && !deleteName.equals(""String_Node_Str"")) {
      String moml=""String_Node_Str"" + deleteName + ""String_Node_Str"";
      _target.addChangeListener(this);
      MoMLChangeRequest request=new MoMLChangeRequest(this,_target,moml);
      request.setUndoable(true);
      _target.requestChange(request);
    }
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    ((Configurer)contents).restoreToDefaults();
    _reOpen();
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    try {
      StyleConfigurer panel=new StyleConfigurer(target);
      ComponentDialog dialog=new ComponentDialog(_owner,""String_Node_Str"" + target.getName(),panel);
      if (!(dialog.buttonPressed().equals(""String_Node_Str""))) {
        panel.restore();
      }
      _reOpen();
    }
 catch (    IllegalActionException ex) {
      MessageHandler.error(""String_Node_Str"",ex);
    }
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    try {
      URL doc=getClass().getClassLoader().getResource(""String_Node_Str"");
      boolean success=false;
      if (_owner instanceof TableauFrame) {
        Configuration configuration=((TableauFrame)_owner).getConfiguration();
        if (configuration != null) {
          configuration.openModel(null,doc,doc.toExternalForm());
          success=true;
        }
      }
      if (!success) {
        HTMLViewer viewer=new HTMLViewer();
        viewer.setPage(doc);
        viewer.pack();
        viewer.show();
      }
    }
 catch (    Exception ex) {
      try {
        MessageHandler.warning(""String_Node_Str"",ex);
      }
 catch (      CancelException exception) {
      }
    }
  }
}","/** 
 * Construct a dialog with the specified owner and target. A ""Commit"" and a ""Cancel"" button are added to the dialog. The dialog is placed relative to the owner.
 * @param owner The object that, per the user, appears to begenerating the dialog.
 * @param target The object whose parameters are being edited.
 * @param label The label for the dialog box.
 */
public EditParametersDialog(Frame owner,NamedObj target,String label){
  super(owner,label,new Configurer(target),_moreButtons);
  _owner=owner;
  _target=target;
  if (buttonPressed().equals(""String_Node_Str"")) {
    _openAddDialog(null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    _target.removeChangeListener(this);
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    List attributeList=_target.attributeList(Settable.class);
    Iterator parameters=attributeList.iterator();
    int count=0;
    while (parameters.hasNext()) {
      Settable parameter=(Settable)parameters.next();
      if (Configurer.isVisible(target,parameter)) {
        count++;
      }
    }
    String[] attributeNames=new String[count];
    parameters=attributeList.iterator();
    int index=0;
    while (parameters.hasNext()) {
      Settable parameter=(Settable)parameters.next();
      if (Configurer.isVisible(target,parameter)) {
        attributeNames[index++]=((Attribute)parameter).getName();
      }
    }
    Query query=new Query();
    query.addChoice(""String_Node_Str"",""String_Node_Str"",attributeNames,null,false);
    ComponentDialog dialog=new ComponentDialog(_owner,""String_Node_Str"" + _target.getFullName(),query,null);
    String deleteName=query.getStringValue(""String_Node_Str"");
    if (dialog.buttonPressed().equals(""String_Node_Str"") && !deleteName.equals(""String_Node_Str"")) {
      String moml=""String_Node_Str"" + deleteName + ""String_Node_Str"";
      _target.addChangeListener(this);
      MoMLChangeRequest request=new MoMLChangeRequest(this,_target,moml);
      request.setUndoable(true);
      _target.requestChange(request);
    }
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    ((Configurer)contents).restoreToDefaults();
    new EditParametersDialog(_owner,_target);
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    try {
      StyleConfigurer panel=new StyleConfigurer(target);
      ComponentDialog dialog=new ComponentDialog(_owner,""String_Node_Str"" + target.getName(),panel);
      if (!(dialog.buttonPressed().equals(""String_Node_Str""))) {
        panel.restore();
      }
      new EditParametersDialog(_owner,_target);
    }
 catch (    IllegalActionException ex) {
      MessageHandler.error(""String_Node_Str"",ex);
    }
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    try {
      URL doc=getClass().getClassLoader().getResource(""String_Node_Str"");
      boolean success=false;
      if (_owner instanceof TableauFrame) {
        Configuration configuration=((TableauFrame)_owner).getConfiguration();
        if (configuration != null) {
          configuration.openModel(null,doc,doc.toExternalForm());
          success=true;
        }
      }
      if (!success) {
        HTMLViewer viewer=new HTMLViewer();
        viewer.setPage(doc);
        viewer.pack();
        viewer.show();
      }
    }
 catch (    Exception ex) {
      try {
        MessageHandler.warning(""String_Node_Str"",ex);
      }
 catch (      CancelException exception) {
      }
    }
  }
}"
75006,"/** 
 * Assuming the contents of the clipboard is MoML code, paste it into the current model by issuing a change request.
 */
public void paste(){
  Clipboard clipboard=java.awt.Toolkit.getDefaultToolkit().getSystemClipboard();
  Transferable transferable=clipboard.getContents(this);
  GraphModel model=_getGraphModel();
  if (transferable == null) {
    return;
  }
  try {
    NamedObj container=(NamedObj)model.getRoot();
    StringBuffer moml=new StringBuffer();
    moml.append(""String_Node_Str"");
    moml.append(offsetPastedMomlLocation((String)transferable.getTransferData(DataFlavor.stringFlavor),10,10));
    moml.append(""String_Node_Str"");
    MoMLChangeRequest change=new MoMLChangeRequest(this,container,moml.toString());
    change.setUndoable(true);
    container.requestChange(change);
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
  }
}","/** 
 * Assuming the contents of the clipboard is MoML code, paste it into the current model by issuing a change request.
 */
public void paste(){
  Clipboard clipboard=java.awt.Toolkit.getDefaultToolkit().getSystemClipboard();
  Transferable transferable=clipboard.getContents(this);
  GraphModel model=_getGraphModel();
  if (transferable == null) {
    return;
  }
  try {
    NamedObj container=(NamedObj)model.getRoot();
    StringBuffer moml=new StringBuffer();
    moml.append(""String_Node_Str"");
    moml.append(_offsetPastedMomlLocation((String)transferable.getTransferData(DataFlavor.stringFlavor),10,10));
    moml.append(""String_Node_Str"");
    MoMLChangeRequest change=new MoMLChangeRequest(this,container,moml.toString());
    change.setUndoable(true);
    container.requestChange(change);
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
  }
}"
75007,"/** 
 * This method, which is required by the ImageObserver interface, is called if something has changed in a background loading of the image.  It simply calls repaint().
 * @param image The image being observed.
 * @param infoflags The bitwise inclusive OR of the following flags:WIDTH, HEIGHT, PROPERTIES, SOMEBITS, FRAMEBITS, ALLBITS, ERROR, ABORT.
 * @param x The x coordinate of the image.
 * @param y The y coordinate of the image.
 * @param width The width of the image.
 * @param height The height of the image.
 * @return False if the infoflags indicate that the image iscompletely loaded; true otherwise.
 */
public boolean imageUpdate(Image image,int infoflags,int x,int y,int width,int height){
  if ((infoflags & (ImageObserver.HEIGHT | ImageObserver.WIDTH)) != 0) {
    _height=height;
    _width=width;
    _image.getWidth(this);
    _image.getHeight(this);
    return true;
  }
  if ((infoflags & (ImageObserver.PROPERTIES | ImageObserver.SOMEBITS)) != 0) {
    _image.getWidth(this);
    _image.getHeight(this);
    return true;
  }
  if ((infoflags & ImageObserver.ALLBITS) != 0) {
    repaint();
    return false;
  }
  _image.getWidth(this);
  _image.getHeight(this);
  return true;
}","/** 
 * This method, which is required by the ImageObserver interface, is called if something has changed in a background loading of the image.  It simply calls repaint().
 * @param image The image being observed.
 * @param infoflags The bitwise inclusive OR of the following flags:WIDTH, HEIGHT, PROPERTIES, SOMEBITS, FRAMEBITS, ALLBITS, ERROR, ABORT.
 * @param x The x coordinate of the image.
 * @param y The y coordinate of the image.
 * @param width The width of the image.
 * @param height The height of the image.
 * @return False if the infoflags indicate that the image iscompletely loaded; true otherwise.
 */
public boolean imageUpdate(Image image,int infoflags,int x,int y,int width,int height){
  if ((infoflags & (ImageObserver.ERROR | ImageObserver.ABORT)) != 0) {
    URL url=getClass().getResource(""String_Node_Str"");
    Toolkit tk=Toolkit.getDefaultToolkit();
    _image=tk.getImage(url);
    return true;
  }
  if ((infoflags & (ImageObserver.HEIGHT | ImageObserver.WIDTH)) != 0) {
    _height=height;
    _width=width;
    _image.getWidth(this);
    _image.getHeight(this);
    return true;
  }
  if ((infoflags & (ImageObserver.PROPERTIES | ImageObserver.SOMEBITS)) != 0) {
    _image.getWidth(this);
    _image.getHeight(this);
    return true;
  }
  if ((infoflags & ImageObserver.ALLBITS) != 0) {
    repaint();
    return false;
  }
  _image.getWidth(this);
  _image.getHeight(this);
  return true;
}"
75008,"/** 
 * Make sure that there is a Link object representing every link connected to the given relation.  Create links if necessary.
 */
private void _updateLinks(ComponentRelation relation){
  List linkedObjects=relation.linkedObjectsList();
  int linkedObjectsCount=linkedObjects.size();
  Iterator links=new LinkedList(_linkSet).iterator();
  while (links.hasNext()) {
    Link link=(Link)links.next();
    Object tail=link.getTail();
    Object tailObj=getSemanticObject(tail);
    Object head=link.getHead();
    Object headObj=getSemanticObject(head);
    if (tailObj != relation && headObj != relation) {
      continue;
    }
    if ((tailObj != null) && linkedObjects.contains(tailObj)) {
      linkedObjects.remove(tailObj);
    }
 else     if (tailObj != relation) {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
    if ((headObj != null) && linkedObjects.contains(headObj)) {
      linkedObjects.remove(headObj);
    }
 else     if (headObj != relation) {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
  }
  int unlinkedPortCount=linkedObjects.size();
  if (unlinkedPortCount == 0) {
    return;
  }
  Vertex rootVertex=null;
  Iterator vertexes=relation.attributeList(Vertex.class).iterator();
  while (vertexes.hasNext()) {
    Vertex v=(Vertex)vertexes.next();
    if (v.getLinkedVertex() == null) {
      rootVertex=v;
    }
  }
  if ((rootVertex == null) && (linkedObjectsCount == 2) && (unlinkedPortCount == 2)&& linkedObjects.get(0) instanceof Port&& linkedObjects.get(1) instanceof Port) {
    Port port1=(Port)linkedObjects.get(0);
    Port port2=(Port)linkedObjects.get(1);
    Object head=null;
    Object tail=null;
    if (port1.getContainer().equals(getRoot())) {
      head=_getLocation(port1);
    }
 else {
      head=port1;
    }
    if (port2.getContainer().equals(getRoot())) {
      tail=_getLocation(port2);
    }
 else {
      tail=port2;
    }
    Link link;
    try {
      link=new Link();
      _linkSet.add(link);
    }
 catch (    Exception e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
    }
    link.setRelation(relation);
    link.setHead(head);
    link.setTail(tail);
  }
 else {
    if (rootVertex == null) {
      try {
        String name=relation.uniqueName(""String_Node_Str"");
        rootVertex=new Vertex(relation,name);
        rootVertex.propagateExistence();
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException(null,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ throwable.getMessage());
      }
    }
    Iterator linkedObjectsIterator=linkedObjects.iterator();
    while (linkedObjectsIterator.hasNext()) {
      Object portOrRelation=linkedObjectsIterator.next();
      Object head=null;
      if (portOrRelation instanceof Port) {
        Port port=(Port)portOrRelation;
        if (port.getContainer().equals(getRoot())) {
          head=_getLocation(port);
        }
 else {
          head=port;
        }
      }
 else {
        vertexes=((Relation)portOrRelation).attributeList(Vertex.class).iterator();
        while (vertexes.hasNext()) {
          Vertex v=(Vertex)vertexes.next();
          if (v.getLinkedVertex() == null) {
            head=v;
          }
        }
      }
      Link link;
      try {
        link=new Link();
        _linkSet.add(link);
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
      link.setRelation(relation);
      link.setHead(head);
      link.setTail(rootVertex);
    }
  }
}","/** 
 * Make sure that there is a Link object representing every link connected to the given relation.  Create links if necessary.
 */
private void _updateLinks(ComponentRelation relation){
  List linkedObjects=relation.linkedObjectsList();
  int linkedObjectsCount=linkedObjects.size();
  Iterator links=new LinkedList(_linkSet).iterator();
  while (links.hasNext()) {
    Link link=(Link)links.next();
    Object tail=link.getTail();
    Object tailObj=getSemanticObject(tail);
    Object head=link.getHead();
    Object headObj=getSemanticObject(head);
    if (tailObj != relation && headObj != relation && link.getRelation() != relation) {
      continue;
    }
    if ((tailObj != null) && linkedObjects.contains(tailObj)) {
      linkedObjects.remove(tailObj);
    }
 else     if (tailObj != relation) {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
    if ((headObj != null) && linkedObjects.contains(headObj)) {
      linkedObjects.remove(headObj);
    }
 else     if (headObj != relation) {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
  }
  int unlinkedPortCount=linkedObjects.size();
  if (unlinkedPortCount == 0) {
    return;
  }
  Vertex rootVertex=null;
  Iterator vertexes=relation.attributeList(Vertex.class).iterator();
  while (vertexes.hasNext()) {
    Vertex v=(Vertex)vertexes.next();
    if (v.getLinkedVertex() == null) {
      rootVertex=v;
    }
  }
  if ((rootVertex == null) && (linkedObjectsCount == 2) && (unlinkedPortCount == 2)&& linkedObjects.get(0) instanceof Port&& linkedObjects.get(1) instanceof Port) {
    Port port1=(Port)linkedObjects.get(0);
    Port port2=(Port)linkedObjects.get(1);
    Object head=null;
    Object tail=null;
    if (port1.getContainer().equals(getRoot())) {
      head=_getLocation(port1);
    }
 else {
      head=port1;
    }
    if (port2.getContainer().equals(getRoot())) {
      tail=_getLocation(port2);
    }
 else {
      tail=port2;
    }
    Link link;
    try {
      link=new Link();
      _linkSet.add(link);
    }
 catch (    Exception e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
    }
    link.setRelation(relation);
    link.setHead(head);
    link.setTail(tail);
  }
 else {
    if (rootVertex == null) {
      try {
        String name=relation.uniqueName(""String_Node_Str"");
        rootVertex=new Vertex(relation,name);
        rootVertex.propagateExistence();
      }
 catch (      Throwable throwable) {
        throw new InternalErrorException(null,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ throwable.getMessage());
      }
    }
    Iterator linkedObjectsIterator=linkedObjects.iterator();
    while (linkedObjectsIterator.hasNext()) {
      Object portOrRelation=linkedObjectsIterator.next();
      Object head=null;
      if (portOrRelation instanceof Port) {
        Port port=(Port)portOrRelation;
        if (port.getContainer().equals(getRoot())) {
          head=_getLocation(port);
        }
 else {
          head=port;
        }
      }
 else {
        vertexes=((Relation)portOrRelation).attributeList(Vertex.class).iterator();
        while (vertexes.hasNext()) {
          Vertex v=(Vertex)vertexes.next();
          if (v.getLinkedVertex() == null) {
            head=v;
          }
        }
      }
      Link link;
      try {
        link=new Link();
        _linkSet.add(link);
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
      link.setRelation(relation);
      link.setHead(head);
      link.setTail(rootVertex);
    }
  }
}"
75009,"/** 
 * Invoke a specified number of iterations of this actor. Each iteration updates the state of the actor by adding the value of the <i>step</i> parameter to the state and sending the value of the state to the output. The iteration count is also incremented by the value of <i>count</i>, and if the result is greater than or equal to <i>firingCountLimit</i> then return STOP_ITERATING. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, if the maximum iteration count has been reached, return STOP_ITERATING.
 * @exception IllegalActionException If iterating cannot beperformed.
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _resultArray.length) {
    _resultArray=new Token[count];
  }
  for (int i=0; i < count; i++) {
    _resultArray[i]=_stateToken;
    try {
      step.update();
      _stateToken=_stateToken.add(step.getToken());
    }
 catch (    IllegalActionException ex) {
      throw new InternalErrorException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  output.send(0,_resultArray,count);
  if (_firingCountLimit != 0) {
    _iterationCount+=count;
    if (_iterationCount >= _firingCountLimit) {
      return STOP_ITERATING;
    }
  }
  return COMPLETED;
}","/** 
 * Invoke a specified number of iterations of this actor. Each iteration updates the state of the actor by adding the value of the <i>step</i> parameter to the state and sending the value of the state to the output. The iteration count is also incremented by the value of <i>count</i>, and if the result is greater than or equal to <i>firingCountLimit</i> then return STOP_ITERATING. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, if the maximum iteration count has been reached, return STOP_ITERATING.
 * @exception IllegalActionException If iterating cannot beperformed.
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _resultArray.length) {
    _resultArray=new Token[count];
  }
  for (int i=0; i < trigger.getWidth(); i++) {
    if (trigger.hasToken(i,count)) {
      trigger.get(i,count);
    }
  }
  for (int i=0; i < count; i++) {
    _resultArray[i]=_stateToken;
    try {
      step.update();
      _stateToken=_stateToken.add(step.getToken());
    }
 catch (    IllegalActionException ex) {
      throw new InternalErrorException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  output.send(0,_resultArray,count);
  if (_firingCountLimit != 0) {
    _iterationCount+=count;
    if (_iterationCount >= _firingCountLimit) {
      return STOP_ITERATING;
    }
  }
  return COMPLETED;
}"
75010,"/** 
 * Return a description of the object.  The level of detail depends on the argument, which is an or-ing of the static final constants defined in the NamedObj class.  Lines are indented according to to the level argument using the protected method _getIndentPrefix(). Zero, one or two brackets can be specified to surround the returned description.  If one is specified it is the the leading bracket. This is used by derived classes that will append to the description. Those derived classes are responsible for the closing bracket. An argument other than 0, 1, or 2 is taken to be equivalent to 0. This method is read-synchronized on the workspace.
 * @param detail The level of detail.
 * @param indent The amount of indenting.
 * @param bracket The number of surrounding brackets (0, 1, or 2).
 * @return A description of the object.
 */
protected String _description(int detail,int indent,int bracket){
  try {
    _workspace.getReadAccess();
    StringBuffer result=new StringBuffer();
    if ((bracket == 1) || (bracket == 2)) {
      result.append(super._description(detail,indent,1));
    }
 else {
      result.append(super._description(detail,indent,0));
    }
    if ((detail & LINKS) != 0) {
      if (result.trim().length() > 0) {
        result.append(""String_Node_Str"");
      }
      detail&=~LINKS;
      result.append(""String_Node_Str"");
      Enumeration links=_linkList.getContainers();
      while (links.hasMoreElements()) {
        Object object=links.nextElement();
        if (object instanceof Port) {
          result.append((((Port)object)._description(detail,indent + 1,2) + ""String_Node_Str""));
        }
 else {
          result.append((((Relation)object)._description(detail,indent + 1,2) + ""String_Node_Str""));
        }
      }
      result.append((_getIndentPrefix(indent) + ""String_Node_Str""));
    }
    if (bracket == 2) {
      result.append(""String_Node_Str"");
    }
    return result.toString();
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Return a description of the object.  The level of detail depends on the argument, which is an or-ing of the static final constants defined in the NamedObj class.  Lines are indented according to to the level argument using the protected method _getIndentPrefix(). Zero, one or two brackets can be specified to surround the returned description.  If one is specified it is the the leading bracket. This is used by derived classes that will append to the description. Those derived classes are responsible for the closing bracket. An argument other than 0, 1, or 2 is taken to be equivalent to 0. This method is read-synchronized on the workspace.
 * @param detail The level of detail.
 * @param indent The amount of indenting.
 * @param bracket The number of surrounding brackets (0, 1, or 2).
 * @return A description of the object.
 */
protected String _description(int detail,int indent,int bracket){
  try {
    _workspace.getReadAccess();
    StringBuffer result=new StringBuffer();
    if ((bracket == 1) || (bracket == 2)) {
      result.append(super._description(detail,indent,1));
    }
 else {
      result.append(super._description(detail,indent,0));
    }
    if ((detail & LINKS) != 0) {
      if (result.toString().trim().length() > 0) {
        result.append(""String_Node_Str"");
      }
      detail&=~LINKS;
      result.append(""String_Node_Str"");
      Enumeration links=_linkList.getContainers();
      while (links.hasMoreElements()) {
        Object object=links.nextElement();
        if (object instanceof Port) {
          result.append((((Port)object)._description(detail,indent + 1,2) + ""String_Node_Str""));
        }
 else {
          result.append((((Relation)object)._description(detail,indent + 1,2) + ""String_Node_Str""));
        }
      }
      result.append((_getIndentPrefix(indent) + ""String_Node_Str""));
    }
    if (bracket == 2) {
      result.append(""String_Node_Str"");
    }
    return result.toString();
  }
  finally {
    _workspace.doneReading();
  }
}"
75011,"/** 
 * Open the MoML file at the given location as a new library in the actor library for this application. An alternate class can be used to build the library if reading the MoML is not desired.  The class must extend ptolemy.moml.LibraryBuilder and the _alternateLibraryBuilder property must be set with the 'value' set to the class that extends LibraryBuilder.
 * @param configuration The configuration where we look for theactor library.
 * @param file The MoML file to open.
 * @exception Exception If there is a problem opening the configuration,opening the MoML file, or opening the MoML file as a new library.
 */
public static void openLibrary(Configuration configuration,File file) throws Exception {
  CompositeEntity library=null;
  final CompositeEntity libraryContainer=(CompositeEntity)configuration.getEntity(""String_Node_Str"");
  if (libraryContainer == null) {
    return;
  }
  StringAttribute alternateLibraryBuilderAttribute=(StringAttribute)libraryContainer.getAttribute(""String_Node_Str"");
  if (alternateLibraryBuilderAttribute != null) {
    List alternatLibrarySubAttributes=alternateLibraryBuilderAttribute.attributeList();
    String libraryBuilderClassName=alternateLibraryBuilderAttribute.getExpression();
    Class libraryBuilderClass=Class.forName(libraryBuilderClassName);
    LibraryBuilder libraryBuilder=(LibraryBuilder)libraryBuilderClass.newInstance();
    libraryBuilder.addAttributes(alternateLibraryBuilderAttribute.attributeList());
    try {
      library=libraryBuilder.buildLibrary(libraryContainer.workspace());
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      throw new Exception(""String_Node_Str"" + ""String_Node_Str"",ex);
    }
    System.out.println(""String_Node_Str"");
  }
  final ModelDirectory directory=(ModelDirectory)configuration.getEntity(Configuration._DIRECTORY_NAME);
  if (directory == null) {
    return;
  }
  URL fileURL=JNLPUtilities.canonicalizeJarURL(file.toURL());
  String identifier=fileURL.toExternalForm();
  Effigy libraryEffigy=directory.getEffigy(identifier);
  if (libraryEffigy == null) {
    if (library == null) {
      MoMLParser parser=new MoMLParser(libraryContainer.workspace());
      MoMLParser.setErrorHandler(new VergilErrorHandler());
      parser.parse(fileURL,fileURL);
      library=(CompositeEntity)parser.getToplevel();
    }
    final PtolemyEffigy finalLibraryEffigy=new PtolemyEffigy(directory.workspace());
    finalLibraryEffigy.setSystemEffigy(true);
    if (library.getName().equals(""String_Node_Str"")) {
      library.setName(BasicGraphFrame.VERGIL_USER_LIBRARY_NAME);
    }
    finalLibraryEffigy.setName(directory.uniqueName(library.getName()));
    _instantiateLibrary(library,directory,configuration,file,libraryContainer,finalLibraryEffigy);
    finalLibraryEffigy.setModel(library);
    URIAttribute uri=new URIAttribute(library,""String_Node_Str"");
    uri.setURL(fileURL);
    finalLibraryEffigy.uri.setURL(fileURL);
    finalLibraryEffigy.identifier.setExpression(identifier);
  }
}","/** 
 * Open the MoML file at the given location as a new library in the actor library for this application. An alternate class can be used to build the library if reading the MoML is not desired.  The class must extend ptolemy.moml.LibraryBuilder and the _alternateLibraryBuilder property must be set with the 'value' set to the class that extends LibraryBuilder.
 * @param configuration The configuration where we look for theactor library.
 * @param file The MoML file to open.
 * @exception Exception If there is a problem opening the configuration,opening the MoML file, or opening the MoML file as a new library.
 */
public static void openLibrary(Configuration configuration,File file) throws Exception {
  CompositeEntity library=null;
  final CompositeEntity libraryContainer=(CompositeEntity)configuration.getEntity(""String_Node_Str"");
  final ModelDirectory directory=(ModelDirectory)configuration.getEntity(Configuration._DIRECTORY_NAME);
  if (directory == null) {
    return;
  }
  if (libraryContainer == null) {
    return;
  }
  StringAttribute alternateLibraryBuilderAttribute=(StringAttribute)libraryContainer.getAttribute(""String_Node_Str"");
  if (alternateLibraryBuilderAttribute != null) {
    List alternatLibrarySubAttributes=alternateLibraryBuilderAttribute.attributeList();
    String libraryBuilderClassName=alternateLibraryBuilderAttribute.getExpression();
    Class libraryBuilderClass=Class.forName(libraryBuilderClassName);
    LibraryBuilder libraryBuilder=(LibraryBuilder)libraryBuilderClass.newInstance();
    libraryBuilder.addAttributes(alternateLibraryBuilderAttribute.attributeList());
    try {
      library=libraryBuilder.buildLibrary(libraryContainer.workspace());
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      throw new Exception(""String_Node_Str"" + ""String_Node_Str"",ex);
    }
    System.out.println(""String_Node_Str"");
  }
  URL fileURL=JNLPUtilities.canonicalizeJarURL(file.toURL());
  String identifier=fileURL.toExternalForm();
  Effigy libraryEffigy=directory.getEffigy(identifier);
  if (libraryEffigy == null) {
    if (library == null) {
      MoMLParser parser=new MoMLParser(libraryContainer.workspace());
      MoMLParser.setErrorHandler(new VergilErrorHandler());
      parser.parse(fileURL,fileURL);
      library=(CompositeEntity)parser.getToplevel();
    }
    final PtolemyEffigy finalLibraryEffigy=new PtolemyEffigy(directory.workspace());
    finalLibraryEffigy.setSystemEffigy(true);
    if (library.getName().equals(""String_Node_Str"")) {
      library.setName(BasicGraphFrame.VERGIL_USER_LIBRARY_NAME);
    }
    finalLibraryEffigy.setName(directory.uniqueName(library.getName()));
    _instantiateLibrary(library,directory,configuration,file,libraryContainer,finalLibraryEffigy);
    finalLibraryEffigy.setModel(library);
    URIAttribute uri=new URIAttribute(library,""String_Node_Str"");
    uri.setURL(fileURL);
    finalLibraryEffigy.uri.setURL(fileURL);
    finalLibraryEffigy.identifier.setExpression(identifier);
  }
}"
75012,"/** 
 * Clear the schedule cache, cache keys and cache for external rates of this scheduler.
 */
public void clearCaches(){
  _scheduleKeyList.clear();
  _scheduleCache.clear();
  _externalRatesCache.clear();
  _mostRecentRates=""String_Node_Str"";
}","/** 
 * Clear the schedule cache, cache keys and cache for external rates of this scheduler.
 */
public void clearCaches(){
  if (_cacheSize > 0) {
    _scheduleKeyList.clear();
  }
  _scheduleCache.clear();
  _externalRatesCache.clear();
  _mostRecentRates=""String_Node_Str"";
}"
75013,"/** 
 * Return the scheduling sequence. If the schedule exist in the cache (schedules are identified by the rate signatures of ports), then return the corresponding schedule in the cache. Otherwise, compute the schedule and return it.
 * @return A schedule of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the super class throws it.
 * @exception IllegalActionException If the super class throws it.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  Schedule schedule;
  if (_inputPortList == null || _workspaceVersion != workspace().getVersion()) {
    _inputPortList=_getInputPortList();
  }
  if (_outputPortList == null || _workspaceVersion != workspace().getVersion()) {
    _outputPortList=_getOutputPortList();
  }
  _workspaceVersion=workspace().getVersion();
  StringBuffer rates=new StringBuffer();
  Iterator inputPorts=_inputPortList.iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    int rate=DFUtilities.getTokenConsumptionRate(inputPort);
    rates.append(rate);
  }
  Iterator outputPorts=_outputPortList.iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    int rate=DFUtilities.getTokenProductionRate(outputPort);
    rates.append(rate);
    int initRate=DFUtilities.getTokenInitProduction(outputPort);
    rates.append(rate);
  }
  String rateKey=rates.toString();
  if (_scheduleCache.containsKey(rateKey)) {
    schedule=(Schedule)_scheduleCache.get(rateKey);
    if (!rateKey.equals(_mostRecentRates)) {
      _mostRecentRates=rateKey;
      if (_cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      Map externalRates=(Map)_externalRatesCache.get(rateKey);
      _saveContainerRates(externalRates);
    }
  }
 else {
    _mostRecentRates=rateKey;
    if (_cacheSize > 0) {
      while (_scheduleKeyList.size() >= _cacheSize) {
        Object object=_scheduleKeyList.get(_cacheSize - 1);
        _scheduleKeyList.remove(_cacheSize - 1);
        _scheduleCache.remove(object);
        _externalRatesCache.remove(object);
        _scheduleKeyList.add(0,rateKey);
      }
    }
    schedule=super._getSchedule();
    _scheduleCache.put(rateKey,schedule);
    Map externalRates=getExternalRates();
    _externalRatesCache.put(rateKey,externalRates);
  }
  setValid(true);
  return schedule;
}","/** 
 * Return the scheduling sequence. If the schedule exist in the cache (schedules are identified by the rate signatures of ports), then return the corresponding schedule in the cache. Otherwise, compute the schedule and return it.
 * @return A schedule of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the super class throws it.
 * @exception IllegalActionException If the super class throws it.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  Schedule schedule;
  if (_inputPortList == null || _workspaceVersion != workspace().getVersion()) {
    _inputPortList=_getInputPortList();
  }
  if (_outputPortList == null || _workspaceVersion != workspace().getVersion()) {
    _outputPortList=_getOutputPortList();
  }
  _workspaceVersion=workspace().getVersion();
  StringBuffer rates=new StringBuffer();
  Iterator inputPorts=_inputPortList.iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    int rate=DFUtilities.getTokenConsumptionRate(inputPort);
    rates.append(rate);
  }
  Iterator outputPorts=_outputPortList.iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    int rate=DFUtilities.getTokenProductionRate(outputPort);
    rates.append(rate);
    int initRate=DFUtilities.getTokenInitProduction(outputPort);
    rates.append(rate);
  }
  String rateKey=rates.toString();
  if (_scheduleCache.containsKey(rateKey)) {
    schedule=(Schedule)_scheduleCache.get(rateKey);
    if (!rateKey.equals(_mostRecentRates)) {
      _mostRecentRates=rateKey;
      if (_cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      Map externalRates=(Map)_externalRatesCache.get(rateKey);
      _saveContainerRates(externalRates);
    }
  }
 else {
    _mostRecentRates=rateKey;
    if (_cacheSize > 0) {
      while (_scheduleKeyList.size() >= _cacheSize) {
        Object key=_scheduleKeyList.get(_cacheSize - 1);
        _scheduleKeyList.remove(_cacheSize - 1);
        _scheduleCache.remove(key);
        _externalRatesCache.remove(key);
      }
      _scheduleKeyList.add(0,rateKey);
    }
    schedule=super._getSchedule();
    _scheduleCache.put(rateKey,schedule);
    Map externalRates=getExternalRates();
    _externalRatesCache.put(rateKey,externalRates);
  }
  setValid(true);
  return schedule;
}"
75014,"/** 
 * Construct the caches of this scheduler with the given cache size.
 * @param cacheSize The given cache sie.
 */
public void constructCaches(int cacheSize){
  _scheduleCache=new HashMap();
  _scheduleKeyList=new ArrayList(cacheSize);
  _externalRatesCache=new TreeMap();
  _cacheSize=cacheSize;
}","/** 
 * Construct the caches of this scheduler with the given cache size.
 * @param cacheSize The given cache sie.
 */
public void constructCaches(int cacheSize){
  _scheduleCache=new HashMap();
  if (cacheSize > 0) {
    _scheduleKeyList=new ArrayList(cacheSize);
  }
  _externalRatesCache=new TreeMap();
  _cacheSize=cacheSize;
}"
75015,"/** 
 * Invalidate the presentation of the positions based on the given added positions and the existing deleted positions. Also unregisters the deleted positions from the document and patches the positions of this presenter. <p> NOTE: Indirectly called from background thread by UI runnable. </p>
 * @param textPresentation the text presentation or <code>null</code>, if the presentation should computed in the UI thread
 * @param addedPositions the added positions
 * @param removedPositions the removed positions
 */
public void updatePresentation(TextPresentation textPresentation,HighlightedPosition[] addedPositions,HighlightedPosition[] removedPositions){
  if (fSourceViewer == null)   return;
  if (isCanceled())   return;
  IDocument document=fSourceViewer.getDocument();
  if (document == null)   return;
  String positionCategory=getPositionCategory();
  List removedPositionsList=Arrays.asList(removedPositions);
  try {
synchronized (fPositionLock) {
      List oldPositions=fPositions;
      int newSize=fPositions.size() + addedPositions.length - removedPositions.length;
      List newPositions=new ArrayList(newSize);
      Position position=null;
      Position addedPosition=null;
      for (int i=0, j=0, n=oldPositions.size(), m=addedPositions.length; i < n || j < m; ) {
        while (position == null && i < n) {
          position=(Position)oldPositions.get(i++);
          if (position.isDeleted() || contain(removedPositionsList,position)) {
            document.removePosition(positionCategory,position);
            position=null;
          }
        }
        if (addedPosition == null && j < m) {
          addedPosition=addedPositions[j++];
          document.addPosition(positionCategory,addedPosition);
        }
        if (position != null)         if (addedPosition != null)         if (position.getOffset() <= addedPosition.getOffset()) {
          newPositions.add(position);
          position=null;
        }
 else {
          newPositions.add(addedPosition);
          addedPosition=null;
        }
 else {
          newPositions.add(position);
          position=null;
        }
 else         if (addedPosition != null) {
          newPositions.add(addedPosition);
          addedPosition=null;
        }
      }
      fPositions=newPositions;
    }
  }
 catch (  BadPositionCategoryException e) {
    JavaPlugin.log(e);
  }
catch (  BadLocationException e) {
    JavaPlugin.log(e);
  }
  if (textPresentation != null)   fSourceViewer.changeTextPresentation(textPresentation,false);
 else   fSourceViewer.invalidateTextPresentation();
}","/** 
 * Invalidate the presentation of the positions based on the given added positions and the existing deleted positions. Also unregisters the deleted positions from the document and patches the positions of this presenter. <p> NOTE: Indirectly called from background thread by UI runnable. </p>
 * @param textPresentation the text presentation or <code>null</code>, if the presentation should computed in the UI thread
 * @param addedPositions the added positions
 * @param removedPositions the removed positions
 */
public void updatePresentation(TextPresentation textPresentation,HighlightedPosition[] addedPositions,HighlightedPosition[] removedPositions){
  if (fSourceViewer == null)   return;
  if (isCanceled())   return;
  IDocument document=fSourceViewer.getDocument();
  if (document == null)   return;
  String positionCategory=getPositionCategory();
  List removedPositionsList=Arrays.asList(removedPositions);
  try {
synchronized (fPositionLock) {
      List oldPositions=fPositions;
      int newSize=fPositions.size() + addedPositions.length - removedPositions.length;
      List newPositions=new ArrayList(newSize);
      Position position=null;
      Position addedPosition=null;
      for (int i=0, j=0, n=oldPositions.size(), m=addedPositions.length; i < n || position != null || j < m || addedPosition != null; ) {
        while (position == null && i < n) {
          position=(Position)oldPositions.get(i++);
          if (position.isDeleted() || contain(removedPositionsList,position)) {
            document.removePosition(positionCategory,position);
            position=null;
          }
        }
        if (addedPosition == null && j < m) {
          addedPosition=addedPositions[j++];
          document.addPosition(positionCategory,addedPosition);
        }
        if (position != null)         if (addedPosition != null)         if (position.getOffset() <= addedPosition.getOffset()) {
          newPositions.add(position);
          position=null;
        }
 else {
          newPositions.add(addedPosition);
          addedPosition=null;
        }
 else {
          newPositions.add(position);
          position=null;
        }
 else         if (addedPosition != null) {
          newPositions.add(addedPosition);
          addedPosition=null;
        }
      }
      fPositions=newPositions;
    }
  }
 catch (  BadPositionCategoryException e) {
    JavaPlugin.log(e);
  }
catch (  BadLocationException e) {
    JavaPlugin.log(e);
  }
  if (textPresentation != null)   fSourceViewer.changeTextPresentation(textPresentation,false);
 else   fSourceViewer.invalidateTextPresentation();
}"
75016,"/** 
 * Add a handler (@link AssignmentTransformer) to the type analyzer. The handler refactors the AST while the type analyzer traverses it.
 * @param analyzer The type analyzer.
 * @param root The root of the AST.
 */
public void beforeTraverse(TypeAnalyzer analyzer,CompilationUnit root){
  AssignmentTransformer assignmentTransformer=new AssignmentTransformer();
  ConstructorTransformer constructorTransformer=new ConstructorTransformer();
  _handlers.add(assignmentTransformer);
  _handlers.add(constructorTransformer);
  analyzer.getHandlers().addAliasHandler(assignmentTransformer);
  analyzer.getHandlers().addAssignmentHandler(assignmentTransformer);
  analyzer.getHandlers().addClassHandler(assignmentTransformer);
  analyzer.getHandlers().addCrossAnalysisHandler(assignmentTransformer);
  analyzer.getHandlers().addMethodDeclarationHandler(assignmentTransformer);
  analyzer.getHandlers().addClassHandler(constructorTransformer);
  analyzer.getHandlers().addConstructorHandler(constructorTransformer);
  analyzer.getHandlers().addCrossAnalysisHandler(constructorTransformer);
  analyzer.getHandlers().addMethodDeclarationHandler(constructorTransformer);
}","/** 
 * Add a handler (@link AssignmentTransformer) to the type analyzer. The handler refactors the AST while the type analyzer traverses it.
 * @param analyzer The type analyzer.
 * @param root The root of the AST.
 */
public void beforeTraverse(TypeAnalyzer analyzer,CompilationUnit root){
  AssignmentTransformer assignmentTransformer=new AssignmentTransformer();
  ConstructorTransformer constructorTransformer=new ConstructorTransformer();
  _handlers.add(assignmentTransformer);
  _handlers.add(constructorTransformer);
  analyzer.getHandlers().addAliasHandler(assignmentTransformer);
  analyzer.getHandlers().addAssignmentHandler(assignmentTransformer);
  analyzer.getHandlers().addClassHandler(assignmentTransformer);
  analyzer.getHandlers().addCrossAnalysisHandler(assignmentTransformer);
  analyzer.getHandlers().addFieldDeclarationHandler(assignmentTransformer);
  analyzer.getHandlers().addMethodDeclarationHandler(assignmentTransformer);
  analyzer.getHandlers().addClassHandler(constructorTransformer);
  analyzer.getHandlers().addConstructorHandler(constructorTransformer);
  analyzer.getHandlers().addCrossAnalysisHandler(constructorTransformer);
  analyzer.getHandlers().addMethodDeclarationHandler(constructorTransformer);
}"
75017,"/** 
 * Handle a class declaration or anonymous class declaration. Records and assignment methods are added to the declaration.
 * @param node The AST node of class declaration or anonymous classdeclaration.
 * @param bodyDeclarations The list of body declarations in the class.
 * @param state The current state of the type analyzer.
 */
private void _handleDeclaration(ASTNode node,List bodyDeclarations,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  List newMethods=new LinkedList();
  List newFields=new LinkedList();
  AST ast=node.getAST();
  CompilationUnit root=(CompilationUnit)node.getRoot();
  List fieldNames=new LinkedList();
  List fieldTypes=new LinkedList();
  Iterator bodyIter=bodyDeclarations.iterator();
  while (bodyIter.hasNext()) {
    Object nextDeclaration=bodyIter.next();
    if (nextDeclaration instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)nextDeclaration;
      boolean isStatic=Modifier.isStatic(fieldDecl.getModifiers());
      if (isStatic && HANDLE_STATIC_FIELDS != true)       continue;
      if (Modifier.isPrivate(fieldDecl.getModifiers())) {
        Type type=Type.getType(fieldDecl);
        Iterator fragmentIter=fieldDecl.fragments().iterator();
        while (fragmentIter.hasNext()) {
          VariableDeclarationFragment fragment=(VariableDeclarationFragment)fragmentIter.next();
          String fieldName=fragment.getName().getIdentifier();
          Hashtable[] tables=new Hashtable[]{_accessedFields,_specialAccessedFields,_backupFields};
          for (int i=0; i < tables.length; i++) {
            List indicesList=_getAccessedField(tables[i],currentClass.getName(),fieldName);
            if (indicesList == null)             continue;
            Iterator indicesIter=indicesList.iterator();
            while (indicesIter.hasNext()) {
              int indices=((Integer)indicesIter.next()).intValue();
              if (tables[i] == _backupFields)               newMethods.add(_createBackupMethod(ast,root,state,fieldName,type,indices,isStatic));
 else               newMethods.add(_createAssignMethod(ast,root,state,fieldName,type,indices,tables[i] == _specialAccessedFields,isStatic));
            }
          }
          fieldNames.add(fieldName);
          fieldTypes.add(type);
          FieldDeclaration field=_createFieldRecord(ast,root,state,fieldName,type.dimensions(),isStatic);
          if (field != null)           newFields.add(field);
        }
      }
    }
  }
  boolean isInterface=node instanceof TypeDeclaration && ((TypeDeclaration)node).isInterface();
  boolean isAnonymous=node instanceof AnonymousClassDeclaration;
  if (isAnonymous) {
    Class[] interfaces=currentClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (state.getCrossAnalyzedTypes().contains(interfaces[i].getName()))     isAnonymous=false;
  }
  RehandleDeclarationRecord declarationRecord=null;
  if (isAnonymous) {
    Class[] interfaces=currentClass.getInterfaces();
    if (interfaces.length == 1) {
      declarationRecord=new RehandleDeclarationRecord(bodyDeclarations);
      addToLists(_rehandleDeclaration,interfaces[0].getName(),declarationRecord);
    }
  }
  boolean ignore=!_isInStaticMethod.isEmpty() && _isInStaticMethod.peek() == Boolean.TRUE && isAnonymous;
  if (!isInterface && !ignore)   newFields.add(_createRecordArray(ast,root,state,fieldNames));
  MethodDeclaration commitMethod=null;
  if (!ignore) {
    commitMethod=_createCommitMethod(ast,root,state,fieldNames,fieldTypes,isAnonymous,isInterface);
    newMethods.add(commitMethod);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(commitMethod);
    MethodDeclaration fixedCommitMethod=_createCommitMethod(ast,root,state,fieldNames,fieldTypes,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedCommitMethod);
  }
  MethodDeclaration restoreMethod=null;
  if (!ignore) {
    restoreMethod=_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,isAnonymous,isInterface);
    newMethods.add(restoreMethod);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(restoreMethod);
    MethodDeclaration fixedRestoreMethod=_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedRestoreMethod);
  }
  MethodDeclaration getCheckpoint=null;
  if (!ignore) {
    getCheckpoint=_createGetCheckpointMethod(ast,root,state,isAnonymous,isInterface);
    if (getCheckpoint != null)     newMethods.add(getCheckpoint);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(getCheckpoint);
    MethodDeclaration fixedGetCheckpoint=_createGetCheckpointMethod(ast,root,state,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedGetCheckpoint);
  }
  MethodDeclaration setCheckpoint=null;
  if (!ignore) {
    setCheckpoint=_createSetCheckpointMethod(ast,root,state,isAnonymous,isInterface);
    if (setCheckpoint != null)     newMethods.add(setCheckpoint);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(setCheckpoint);
    MethodDeclaration fixedSetCheckpoint=_createSetCheckpointMethod(ast,root,state,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedSetCheckpoint);
  }
  if (!ignore) {
    if (isAnonymous) {
      TypeDeclaration proxy=_createProxyClass(ast,root,state);
      bodyDeclarations.add(proxy);
      if (declarationRecord != null)       declarationRecord._addExtendedDeclaration(proxy);
    }
 else {
      if (node instanceof TypeDeclaration) {
        String rollbackType=getClassName(Rollbackable.class,state,root);
        ((TypeDeclaration)node).superInterfaces().add(createName(ast,rollbackType));
      }
      if (!isInterface) {
        FieldDeclaration checkpointField=_createCheckpointField(ast,root,state);
        if (checkpointField != null)         bodyDeclarations.add(0,checkpointField);
        FieldDeclaration record=_createCheckpointRecord(ast,root,state);
        if (record != null)         newFields.add(0,record);
      }
    }
  }
  if (!ignore) {
    bodyDeclarations.addAll(newMethods);
    bodyDeclarations.addAll(newFields);
  }
 else {
    if (declarationRecord != null) {
      declarationRecord._addFixedDeclarations(newMethods);
      declarationRecord._addFixedDeclarations(newFields);
    }
  }
  if (isAnonymous && !ignore) {
    Initializer initializer=ast.newInitializer();
    Block body=ast.newBlock();
    initializer.setBody(body);
    MethodInvocation addInvocation=ast.newMethodInvocation();
    addInvocation.setExpression(ast.newSimpleName(CHECKPOINT_NAME));
    addInvocation.setName(ast.newSimpleName(""String_Node_Str""));
    ClassInstanceCreation proxy=ast.newClassInstanceCreation();
    proxy.setName(ast.newSimpleName(_getProxyName()));
    addInvocation.arguments().add(proxy);
    body.statements().add(ast.newExpressionStatement(addInvocation));
    bodyDeclarations.add(initializer);
    if (declarationRecord != null)     declarationRecord._addExtendedDeclaration(initializer);
  }
}","/** 
 * Handle a class declaration or anonymous class declaration. Records and assignment methods are added to the declaration.
 * @param node The AST node of class declaration or anonymous classdeclaration.
 * @param bodyDeclarations The list of body declarations in the class.
 * @param state The current state of the type analyzer.
 */
private void _handleDeclaration(ASTNode node,List bodyDeclarations,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  List newMethods=new LinkedList();
  List newFields=new LinkedList();
  AST ast=node.getAST();
  CompilationUnit root=(CompilationUnit)node.getRoot();
  List fieldNames=new LinkedList();
  List fieldTypes=new LinkedList();
  Iterator bodyIter=bodyDeclarations.iterator();
  while (bodyIter.hasNext()) {
    Object nextDeclaration=bodyIter.next();
    if (nextDeclaration instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)nextDeclaration;
      boolean isStatic=Modifier.isStatic(fieldDecl.getModifiers());
      if (isStatic && HANDLE_STATIC_FIELDS != true)       continue;
      if (Modifier.isPrivate(fieldDecl.getModifiers())) {
        Type type=Type.getType(fieldDecl);
        Iterator fragmentIter=fieldDecl.fragments().iterator();
        while (fragmentIter.hasNext()) {
          VariableDeclarationFragment fragment=(VariableDeclarationFragment)fragmentIter.next();
          String fieldName=fragment.getName().getIdentifier();
          Hashtable[] tables=new Hashtable[]{_accessedFields,_specialAccessedFields,_backupFields};
          for (int i=0; i < tables.length; i++) {
            List indicesList=_getAccessedField(tables[i],currentClass.getName(),fieldName);
            if (indicesList == null)             continue;
            Iterator indicesIter=indicesList.iterator();
            while (indicesIter.hasNext()) {
              int indices=((Integer)indicesIter.next()).intValue();
              if (tables[i] == _backupFields)               newMethods.add(_createBackupMethod(ast,root,state,fieldName,type,indices,isStatic));
 else               newMethods.add(_createAssignMethod(ast,root,state,fieldName,type,indices,tables[i] == _specialAccessedFields,isStatic));
            }
          }
          fieldNames.add(fieldName);
          fieldTypes.add(type);
          FieldDeclaration field=_createFieldRecord(ast,root,state,fieldName,type.dimensions(),isStatic);
          if (field != null)           newFields.add(field);
        }
      }
    }
  }
  boolean isInterface=node instanceof TypeDeclaration && ((TypeDeclaration)node).isInterface();
  boolean isAnonymous=node instanceof AnonymousClassDeclaration;
  if (isAnonymous) {
    Class[] interfaces=currentClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (state.getCrossAnalyzedTypes().contains(interfaces[i].getName()))     isAnonymous=false;
  }
  RehandleDeclarationRecord declarationRecord=null;
  if (isAnonymous) {
    Class[] interfaces=currentClass.getInterfaces();
    if (interfaces.length == 1) {
      declarationRecord=new RehandleDeclarationRecord(bodyDeclarations);
      addToLists(_rehandleDeclaration,interfaces[0].getName(),declarationRecord);
    }
  }
  boolean ignore=!_isInStatic.isEmpty() && _isInStatic.peek() == Boolean.TRUE && isAnonymous;
  if (!isInterface && !ignore)   newFields.add(_createRecordArray(ast,root,state,fieldNames));
  MethodDeclaration commitMethod=null;
  if (!ignore) {
    commitMethod=_createCommitMethod(ast,root,state,fieldNames,fieldTypes,isAnonymous,isInterface);
    newMethods.add(commitMethod);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(commitMethod);
    MethodDeclaration fixedCommitMethod=_createCommitMethod(ast,root,state,fieldNames,fieldTypes,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedCommitMethod);
  }
  MethodDeclaration restoreMethod=null;
  if (!ignore) {
    restoreMethod=_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,isAnonymous,isInterface);
    newMethods.add(restoreMethod);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(restoreMethod);
    MethodDeclaration fixedRestoreMethod=_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedRestoreMethod);
  }
  MethodDeclaration getCheckpoint=null;
  if (!ignore) {
    getCheckpoint=_createGetCheckpointMethod(ast,root,state,isAnonymous,isInterface);
    if (getCheckpoint != null)     newMethods.add(getCheckpoint);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(getCheckpoint);
    MethodDeclaration fixedGetCheckpoint=_createGetCheckpointMethod(ast,root,state,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedGetCheckpoint);
  }
  MethodDeclaration setCheckpoint=null;
  if (!ignore) {
    setCheckpoint=_createSetCheckpointMethod(ast,root,state,isAnonymous,isInterface);
    if (setCheckpoint != null)     newMethods.add(setCheckpoint);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(setCheckpoint);
    MethodDeclaration fixedSetCheckpoint=_createSetCheckpointMethod(ast,root,state,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedSetCheckpoint);
  }
  if (!ignore) {
    if (isAnonymous) {
      TypeDeclaration proxy=_createProxyClass(ast,root,state);
      bodyDeclarations.add(proxy);
      if (declarationRecord != null)       declarationRecord._addExtendedDeclaration(proxy);
    }
 else {
      if (node instanceof TypeDeclaration) {
        String rollbackType=getClassName(Rollbackable.class,state,root);
        ((TypeDeclaration)node).superInterfaces().add(createName(ast,rollbackType));
      }
      if (!isInterface) {
        FieldDeclaration checkpointField=_createCheckpointField(ast,root,state);
        if (checkpointField != null)         bodyDeclarations.add(0,checkpointField);
        FieldDeclaration record=_createCheckpointRecord(ast,root,state);
        if (record != null)         newFields.add(0,record);
      }
    }
  }
  if (!ignore) {
    bodyDeclarations.addAll(newMethods);
    bodyDeclarations.addAll(newFields);
  }
 else {
    if (declarationRecord != null) {
      declarationRecord._addFixedDeclarations(newMethods);
      declarationRecord._addFixedDeclarations(newFields);
    }
  }
  if (isAnonymous && !ignore) {
    Initializer initializer=ast.newInitializer();
    Block body=ast.newBlock();
    initializer.setBody(body);
    MethodInvocation addInvocation=ast.newMethodInvocation();
    addInvocation.setExpression(ast.newSimpleName(CHECKPOINT_NAME));
    addInvocation.setName(ast.newSimpleName(""String_Node_Str""));
    ClassInstanceCreation proxy=ast.newClassInstanceCreation();
    proxy.setName(ast.newSimpleName(_getProxyName()));
    addInvocation.arguments().add(proxy);
    body.statements().add(ast.newExpressionStatement(addInvocation));
    bodyDeclarations.add(initializer);
    if (declarationRecord != null)     declarationRecord._addExtendedDeclaration(initializer);
  }
}"
75018,"/** 
 * Transform a set of files into backtracking-enabled ones. The set of files is given by an array of strings as their names, or the names of the directories that contain them. If a string in the array is a file name, it is refactored and the output is printed out; if it is the name of a directory, all Java files in the directory and its sub-directories are looked up and refactored in the same way.
 * @param args The array of file names or names of directories.
 * @exception Exception If any exception occues.
 */
public static void main(String[] args) throws Exception {
  if (args.length == 0)   _printUsage();
 else {
    String[] paths=PathFinder.getPtClassPaths();
    int start=0;
    while (start < args.length) {
      int newPosition=parseArguments(args,start);
      if (newPosition != start)       start=newPosition;
 else       break;
    }
    if (_extraClassPaths != null) {
      String[] morePaths=new String[paths.length + _extraClassPaths.length];
      System.arraycopy(paths,0,morePaths,0,paths.length);
      System.arraycopy(_extraClassPaths,0,morePaths,paths.length,_extraClassPaths.length);
      paths=morePaths;
    }
    List fileList=new LinkedList();
    Set crossAnalysis=new HashSet();
    for (int i=start; i < args.length; i++) {
      String pathOrFile=args[i];
      File[] files;
      if (pathOrFile.startsWith(""String_Node_Str"")) {
        String listName=pathOrFile.substring(1);
        File listFile=new File(listName);
        File listPath=listFile.getParentFile();
        BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(listName)));
        List strings=new LinkedList();
        String line=reader.readLine();
        while (line != null) {
          strings.add(new File(listPath,line).getCanonicalPath());
          line=reader.readLine();
        }
        files=new File[strings.size()];
        Iterator stringsIter=strings.iterator();
        for (int j=0; stringsIter.hasNext(); j++)         files[j]=new File((String)stringsIter.next());
      }
 else       files=PathFinder.getJavaFiles(pathOrFile,true);
      ClassFileLoader loader=new ClassFileLoader(paths);
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        if (fileName.endsWith(""String_Node_Str""))         fileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
 else {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str"");
          continue;
        }
        Class c=null;
        try {
          c=loader.loadClass(new File(fileName));
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
          continue;
        }
        fileList.add(files[j]);
        crossAnalysis.add(c.getName());
        _addInnerClasses(crossAnalysis,fileName,c.getPackage() == null ? null : c.getPackage().getName());
      }
    }
    String[] crossAnalyzedTypes=new String[crossAnalysis.size()];
    Iterator crossAnalysisIter=crossAnalysis.iterator();
    for (int i=0; crossAnalysisIter.hasNext(); i++)     crossAnalyzedTypes[i]=(String)crossAnalysisIter.next();
    Writer standardWriter=_defaultToStandardOutput ? new OutputStreamWriter(System.out) : null;
    Iterator filesIter=fileList.iterator();
    while (filesIter.hasNext()) {
      File file=(File)filesIter.next();
      String fileName=file.getPath();
      System.err.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
      transform(file.getPath(),standardWriter,paths,crossAnalyzedTypes);
      if (_defaultToStandardOutput)       standardWriter.flush();
    }
    _outputConfig();
    if (_defaultToStandardOutput)     standardWriter.close();
  }
}","/** 
 * Transform a set of files into backtracking-enabled ones. The set of files is given by an array of strings as their names, or the names of the directories that contain them. If a string in the array is a file name, it is refactored and the output is printed out; if it is the name of a directory, all Java files in the directory and its sub-directories are looked up and refactored in the same way.
 * @param args The array of file names or names of directories.
 * @exception Exception If any exception occues.
 */
public static void main(String[] args) throws Exception {
  if (args.length == 0)   _printUsage();
 else {
    String[] paths=PathFinder.getPtClassPaths();
    int start=0;
    while (start < args.length) {
      int newPosition=parseArguments(args,start);
      if (newPosition != start)       start=newPosition;
 else       break;
    }
    if (_extraClassPaths != null)     paths=Strings.combineArrays(paths,_extraClassPaths);
    List fileList=new LinkedList();
    Set crossAnalysis=new HashSet();
    for (int i=start; i < args.length; i++) {
      String pathOrFile=args[i];
      File[] files;
      if (pathOrFile.startsWith(""String_Node_Str"")) {
        String listName=pathOrFile.substring(1);
        File listFile=new File(listName);
        File listPath=listFile.getParentFile();
        BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(listName)));
        List strings=new LinkedList();
        String line=reader.readLine();
        while (line != null) {
          strings.add(new File(listPath,line).getCanonicalPath());
          line=reader.readLine();
        }
        files=new File[strings.size()];
        Iterator stringsIter=strings.iterator();
        for (int j=0; stringsIter.hasNext(); j++)         files[j]=new File((String)stringsIter.next());
      }
 else       files=PathFinder.getJavaFiles(pathOrFile,true);
      ClassFileLoader loader=new ClassFileLoader(paths);
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        if (fileName.endsWith(""String_Node_Str""))         fileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
 else {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str"");
          continue;
        }
        Class c=null;
        try {
          c=loader.loadClass(new File(fileName));
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
          continue;
        }
        fileList.add(files[j]);
        crossAnalysis.add(c.getName());
        _addInnerClasses(crossAnalysis,fileName,c.getPackage() == null ? null : c.getPackage().getName());
      }
    }
    String[] crossAnalyzedTypes=new String[crossAnalysis.size()];
    Iterator crossAnalysisIter=crossAnalysis.iterator();
    for (int i=0; crossAnalysisIter.hasNext(); i++)     crossAnalyzedTypes[i]=(String)crossAnalysisIter.next();
    Writer standardWriter=_defaultToStandardOutput ? new OutputStreamWriter(System.out) : null;
    Iterator filesIter=fileList.iterator();
    while (filesIter.hasNext()) {
      File file=(File)filesIter.next();
      String fileName=file.getPath();
      System.err.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
      transform(file.getPath(),standardWriter,paths,crossAnalyzedTypes);
      if (_defaultToStandardOutput)       standardWriter.flush();
    }
    _outputConfig();
    if (_defaultToStandardOutput)     standardWriter.close();
  }
}"
75019,"/** 
 * Parse the command-line arguments starting from the given position. If one or more argument corresponds to an option, proper actions are performed to record that option. The position is adjusted to the next file name or option and returned.
 * @param args The command-line arguments.
 * @param position The starting position.
 * @return The new position.
 */
public static int parseArguments(String[] args,int position){
  String arg=args[position];
  if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    String classPaths=args[position];
    _extraClassPaths=classPaths.split(File.pathSeparator);
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _prefix=args[position];
    for (int i=0; i < RULES.length; i++)     if (RULES[i] instanceof PackageRule) {
      ((PackageRule)RULES[i]).setPrefix(_prefix);
      break;
    }
    position++;
    _defaultToStandardOutput=false;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _rootPath=args[position];
    if (_rootPath.length() == 0)     _rootPath=""String_Node_Str"";
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=true;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=false;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _configName=args[position];
    position++;
  }
  return position;
}","/** 
 * Parse the command-line arguments starting from the given position. If one or more argument corresponds to an option, proper actions are performed to record that option. The position is adjusted to the next file name or option and returned.
 * @param args The command-line arguments.
 * @param position The starting position.
 * @return The new position.
 */
public static int parseArguments(String[] args,int position){
  String arg=args[position];
  if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    String classPaths=args[position];
    _extraClassPaths=Strings.combineArrays(_extraClassPaths,Strings.decodeFileNames(classPaths));
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _prefix=args[position];
    for (int i=0; i < RULES.length; i++)     if (RULES[i] instanceof PackageRule) {
      ((PackageRule)RULES[i]).setPrefix(_prefix);
      break;
    }
    position++;
    _defaultToStandardOutput=false;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _rootPath=args[position];
    if (_rootPath.length() == 0)     _rootPath=""String_Node_Str"";
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=true;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=false;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _configName=args[position];
    position++;
  }
  return position;
}"
75020,"private void _setupPreviewPage(){
  int pageIndex=1;
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  try {
    CompilationUnit compilationUnit=_getCompilationUnit();
    String packageName=null;
    if (compilationUnit.getPackage() != null)     packageName=compilationUnit.getPackage().getName().toString();
    IPath refactoredFile=Environment.getRefactoredFile(file.getLocation().toOSString(),packageName);
    IFile previewFile=Environment.getContainer(refactoredFile).getFile(null);
    _preview=new CompilationUnitEditor();
    _preview.init(_editor.getEditorSite(),new FileEditorInput(previewFile){
      public boolean exists(){
        return true;
      }
    }
);
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
}","private void _setupPreviewPage(){
  int pageIndex=1;
  _preview=new CompilationUnitEditor();
  IFile previewFile=_getPreviewFile();
  if (previewFile != null) {
    try {
      _preview.init(_editor.getEditorSite(),new FileEditorInput(previewFile){
        public boolean exists(){
          return true;
        }
      }
);
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}"
75021,"protected void _update(){
  if (!_needRefactoring)   return;
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  IFile previewFile=((IFileEditorInput)_preview.getEditorInput()).getFile();
  PipedOutputStream outputStream=new PipedOutputStream();
  OutputStreamWriter writer=new OutputStreamWriter(outputStream);
  try {
    Environment.createFolders(previewFile.getParent());
    IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
    boolean overwrite=store.getBoolean(PreferenceConstants.BACKTRACK_OVERWRITE);
    if (!overwrite && previewFile.exists() && previewFile.isLocal(0)) {
      OutputConsole.outputError(""String_Node_Str"" + previewFile.getLocation().toOSString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
    PipedInputStream inputStream=new PipedInputStream(outputStream);
    CompilationUnit compilationUnit=_getCompilationUnit();
    new RefactoredOutputThread(previewFile,inputStream).start();
    String[] classPaths=null;
    String[] PTClassPaths=Environment.getClassPaths(null);
    String[] extraClassPaths=new String[0];
    if (file.getProject() != null)     extraClassPaths=new String[]{file.getProject().getLocation().toOSString()};
    if (!Environment.setupTransformerArguments(_container.getShell(),false,true)) {
      OutputConsole.outputError(""String_Node_Str"");
      return;
    }
    BusyIndicator.showWhile(Display.getCurrent(),new TransformerRunnable(file.getName(),compilationUnit,writer,Environment.combineArrays(PTClassPaths,extraClassPaths),new String[]{}));
    _needRefactoring=false;
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      writer.close();
      _preview.setInput(new FileEditorInput(previewFile));
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}","protected void _update(){
  if (!_needRefactoring)   return;
  String PTII=Environment.getPtolemyHome(_container.getShell());
  if (PTII == null)   return;
  String root=Environment.getRefactoringRoot(_container.getShell());
  if (root == null)   return;
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  IFile previewFile=((IFileEditorInput)_preview.getEditorInput()).getFile();
  PipedOutputStream outputStream=new PipedOutputStream();
  OutputStreamWriter writer=new OutputStreamWriter(outputStream);
  try {
    Environment.createFolders(previewFile.getParent());
    boolean overwrite=store.getBoolean(PreferenceConstants.BACKTRACK_OVERWRITE);
    if (!overwrite && previewFile.exists() && previewFile.isLocal(0)) {
      OutputConsole.outputError(""String_Node_Str"" + previewFile.getLocation().toOSString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
    PipedInputStream inputStream=new PipedInputStream(outputStream);
    CompilationUnit compilationUnit=_getCompilationUnit();
    new RefactoredOutputThread(previewFile,inputStream).start();
    String[] classPaths=null;
    String[] PTClassPaths=Environment.getClassPaths(null);
    String[] extraClassPaths=new String[0];
    if (file.getProject() != null)     extraClassPaths=new String[]{file.getProject().getLocation().toOSString()};
    String extraClassPathsInOptions=store.getString(PreferenceConstants.BACKTRACK_EXTRA_CLASSPATHS);
    if (!extraClassPathsInOptions.equals(""String_Node_Str""))     extraClassPaths=Strings.combineArrays(extraClassPaths,Strings.decodeFileNames(extraClassPathsInOptions));
    if (!Environment.setupTransformerArguments(_container.getShell(),false,true)) {
      OutputConsole.outputError(""String_Node_Str"");
      return;
    }
    BusyIndicator.showWhile(Display.getCurrent(),new TransformerRunnable(file.getName(),compilationUnit,writer,Strings.combineArrays(PTClassPaths,extraClassPaths),new String[]{}));
    _needRefactoring=false;
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      writer.close();
      _preview.setInput(new FileEditorInput(previewFile));
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}"
75022,"public void createPartControl(Composite parent){
  _container=_createContainer(parent);
  _createPages();
  _preview.createPartControl((Composite)_container.getItem(1).getControl());
  super.createPartControl((Composite)_container.getItem(0).getControl());
  ISourceViewer sourceViewer=getSourceViewer();
  if (sourceViewer == null)   return;
  IDocument document=sourceViewer.getDocument();
  if (document != null)   document.addDocumentListener(new IDocumentListener(){
    public void documentAboutToBeChanged(    DocumentEvent event){
    }
    public void documentChanged(    DocumentEvent event){
      _needRefactoring=true;
    }
  }
);
  _setActivePage(0);
}","public void createPartControl(Composite parent){
  _container=_createContainer(parent);
  _createPages();
  _preview.createPartControl((Composite)_container.getItem(1).getControl());
  super.createPartControl((Composite)_container.getItem(0).getControl());
  ISourceViewer sourceViewer=getSourceViewer();
  if (sourceViewer == null)   return;
  IDocument document=sourceViewer.getDocument();
  if (document != null)   document.addDocumentListener(new IDocumentListener(){
    public void documentAboutToBeChanged(    DocumentEvent event){
    }
    public void documentChanged(    DocumentEvent event){
      _needRefactoring=true;
    }
  }
);
  _setActivePage(0);
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  store.addPropertyChangeListener(new IPropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent event){
      String property=event.getProperty();
      if (property == PreferenceConstants.BACKTRACK_ROOT || property == PreferenceConstants.BACKTRACK_PREFIX) {
        try {
          IFile previewFile=_getPreviewFile();
          _preview.setInput(new FileEditorInput(previewFile));
        }
 catch (        Exception e) {
          OutputConsole.outputError(e.getMessage());
        }
      }
    }
  }
);
}"
75023,"private void _createSection2(){
  Composite composite=_createSection(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Composite currentComposite=_newComposite(composite);
  _root=new DirectoryFieldEditor(PreferenceConstants.BACKTRACK_ROOT,""String_Node_Str"",currentComposite);
  GridData gridData=new GridData();
  gridData.widthHint=0;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _root.getTextControl(currentComposite).setLayoutData(gridData);
  _setParent(_root,currentComposite);
  addField(_root);
  currentComposite=_newComposite(composite);
  _prefix=new StringFieldEditor(PreferenceConstants.BACKTRACK_PREFIX,""String_Node_Str"",currentComposite);
  _setParent(_prefix,currentComposite);
  addField(_prefix);
}","private void _createSection2(){
  Composite composite=_createSection(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Composite currentComposite=_newComposite(composite);
  _root=new DirectoryFieldEditor(PreferenceConstants.BACKTRACK_ROOT,""String_Node_Str"",currentComposite);
  _root.setCanBeEmpty(true);
  GridData gridData=new GridData();
  gridData.widthHint=0;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _root.getTextControl(currentComposite).setLayoutData(gridData);
  _setParent(_root,currentComposite);
  addField(_root);
  currentComposite=_newComposite(composite);
  _prefix=new StringFieldEditor(PreferenceConstants.BACKTRACK_PREFIX,""String_Node_Str"",currentComposite);
  _setParent(_prefix,currentComposite);
  addField(_prefix);
}"
75024,"private void _createSection1(){
  Composite composite=_createSection(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Composite currentComposite=_newComposite(composite);
  _sourceList=new FileFieldEditor(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"",currentComposite){
    protected boolean checkState(){
      boolean superResult=super.checkState();
      if (!getTextControl(_getParent(this)).isEnabled())       return superResult;
      if (getStringValue().equals(_lastString)) {
        if (superResult)         return true;
      }
 else {
        _lastString=getStringValue();
        _sourcesModified=false;
        if (superResult)         return _updateSources();
      }
      List list=_sources.getListControl(_getParent(_sources));
      list.removeAll();
      return false;
    }
    private String _lastString=null;
  }
;
  GridData gridData=new GridData();
  gridData.widthHint=0;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sourceList.getTextControl(currentComposite).setLayoutData(gridData);
  _sourceList.setFileExtensions(new String[]{""String_Node_Str"",""String_Node_Str""});
  _setParent(_sourceList,currentComposite);
  addField(_sourceList);
  currentComposite=_newComposite(composite);
  _sources=new ListEditor(PreferenceConstants.BACKTRACK_SOURCES,""String_Node_Str"",currentComposite){
    protected String createList(    String[] items){
      StringBuffer path=new StringBuffer(""String_Node_Str"");
      for (int i=0; i < items.length; i++) {
        path.append(items[i]);
        path.append(File.pathSeparator);
      }
      return path.toString();
    }
    protected String getNewInputObject(){
      String sourceList=_sourceList.getStringValue();
      String sourceListPath=new File(sourceList).getParent();
      FileDialog dialog=new FileDialog(getShell());
      dialog.setText(""String_Node_Str"");
      dialog.setFilterPath(sourceListPath);
      dialog.setFilterExtensions(new String[]{""String_Node_Str""});
      String file=dialog.open();
      if (file != null) {
        file=file.trim();
        if (file.length() == 0)         return null;
      }
      return file;
    }
    protected String[] parseString(    String stringList){
      StringTokenizer st=new StringTokenizer(stringList,File.pathSeparator + ""String_Node_Str"");
      ArrayList v=new ArrayList();
      while (st.hasMoreElements()) {
        v.add(st.nextElement());
      }
      return (String[])v.toArray(new String[v.size()]);
    }
    protected void doLoad(){
    }
    protected void doLoadDefault(){
    }
    protected void doStore(){
      if (_sourcesModified) {
        List list=getListControl(_getParent(this));
        String[] items=list.getItems();
        String fileName=_sourceList.getStringValue();
        try {
          PrintWriter writer=new PrintWriter(new FileOutputStream(fileName));
          for (int i=0; i < items.length; i++)           writer.write(items[i] + ""String_Node_Str"");
          writer.close();
        }
 catch (        Exception e) {
          MessageDialog.openError(getShell(),""String_Node_Str"",e.getMessage());
        }
      }
    }
  }
;
  gridData=new GridData();
  gridData.widthHint=0;
  gridData.heightHint=LIST_HEIGHT;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sources.getListControl(currentComposite).setLayoutData(gridData);
  _setParent(_sources,currentComposite);
  addField(_sources);
}","private void _createSection1(){
  Composite composite=_createSection(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Composite currentComposite=_newComposite(composite);
  _sourceList=new FileFieldEditor(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"",currentComposite){
    protected boolean checkState(){
      if (Environment.getPtolemyHome() == null)       return true;
      String currentValue=getStringValue();
      boolean superResult=super.checkState();
      if (!getTextControl(_getParent(this)).isEnabled())       return superResult;
      if (getStringValue().equals(_lastString)) {
        if (superResult)         return true;
      }
 else {
        _lastString=currentValue;
        _sourcesModified=false;
        if (superResult || currentValue.equals(""String_Node_Str""))         return _updateSources();
      }
      List list=_sources.getListControl(_getParent(_sources));
      list.removeAll();
      return false;
    }
    private String _lastString=null;
  }
;
  GridData gridData=new GridData();
  gridData.widthHint=0;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sourceList.getTextControl(currentComposite).setLayoutData(gridData);
  _sourceList.setFileExtensions(new String[]{""String_Node_Str"",""String_Node_Str""});
  _setParent(_sourceList,currentComposite);
  addField(_sourceList);
  currentComposite=_newComposite(composite);
  _sources=new ListEditor(PreferenceConstants.BACKTRACK_SOURCES,""String_Node_Str"",currentComposite){
    protected String createList(    String[] items){
      return Strings.encodeFileNames(items);
    }
    protected String getNewInputObject(){
      String sourceList=_sourceList.getStringValue();
      String sourceListPath=new File(sourceList).getParent();
      FileDialog dialog=new FileDialog(getShell());
      dialog.setText(""String_Node_Str"");
      dialog.setFilterPath(sourceListPath);
      dialog.setFilterExtensions(new String[]{""String_Node_Str""});
      String file=dialog.open();
      if (file != null) {
        file=file.trim();
        if (file.length() == 0)         return null;
      }
      return file;
    }
    protected String[] parseString(    String stringList){
      return Strings.decodeFileNames(stringList);
    }
    protected void doLoad(){
    }
    protected void doLoadDefault(){
    }
    protected void doStore(){
      if (_sourcesModified) {
        List list=getListControl(_getParent(this));
        String[] items=list.getItems();
        String fileName=_sourceList.getStringValue();
        try {
          PrintWriter writer=new PrintWriter(new FileOutputStream(fileName));
          for (int i=0; i < items.length; i++)           writer.write(items[i] + ""String_Node_Str"");
          writer.close();
        }
 catch (        Exception e) {
          MessageDialog.openError(getShell(),""String_Node_Str"",e.getMessage());
        }
      }
    }
  }
;
  gridData=new GridData();
  gridData.widthHint=0;
  gridData.heightHint=LIST_HEIGHT;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sources.getListControl(currentComposite).setLayoutData(gridData);
  _setParent(_sources,currentComposite);
  addField(_sources);
}"
75025,"private boolean _updateSources(){
  String fileName=_sourceList.getStringValue();
  File sourceListFile=new File(fileName);
  File sourceListPath=sourceListFile.getParentFile();
  List list=_sources.getListControl(_getParent(_sources));
  list.removeAll();
  try {
    BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));
    String line;
    while ((line=reader.readLine()) != null) {
      File file=new File(sourceListPath,line);
      if (!file.exists()) {
        MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + line + ""String_Node_Str"");
        throw new FileNotFoundException();
      }
      list.add(line);
    }
    reader.close();
    return true;
  }
 catch (  Exception e) {
    list.removeAll();
    return false;
  }
}","private boolean _updateSources(){
  String fileName=_sourceList.getStringValue();
  List list=_sources.getListControl(_getParent(_sources));
  list.removeAll();
  if (fileName.equals(""String_Node_Str""))   return true;
  File sourceListFile=new File(fileName);
  File sourceListPath=sourceListFile.getParentFile();
  try {
    BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));
    String line;
    while ((line=reader.readLine()) != null) {
      File file=new File(sourceListPath,line);
      if (!file.exists()) {
        MessageDialog.openError(getShell(),""String_Node_Str"",""String_Node_Str"" + line + ""String_Node_Str"");
        throw new FileNotFoundException();
      }
      list.add(line);
    }
    reader.close();
    return true;
  }
 catch (  Exception e) {
    list.removeAll();
    return false;
  }
}"
75026,"protected boolean checkState(){
  boolean superResult=super.checkState();
  if (!getTextControl(_getParent(this)).isEnabled())   return superResult;
  if (getStringValue().equals(_lastString)) {
    if (superResult)     return true;
  }
 else {
    _lastString=getStringValue();
    _sourcesModified=false;
    if (superResult)     return _updateSources();
  }
  List list=_sources.getListControl(_getParent(_sources));
  list.removeAll();
  return false;
}","protected boolean checkState(){
  if (Environment.getPtolemyHome() == null)   return true;
  String currentValue=getStringValue();
  boolean superResult=super.checkState();
  if (!getTextControl(_getParent(this)).isEnabled())   return superResult;
  if (getStringValue().equals(_lastString)) {
    if (superResult)     return true;
  }
 else {
    _lastString=currentValue;
    _sourcesModified=false;
    if (superResult || currentValue.equals(""String_Node_Str""))     return _updateSources();
  }
  List list=_sources.getListControl(_getParent(_sources));
  list.removeAll();
  return false;
}"
75027,"protected String createList(String[] items){
  StringBuffer path=new StringBuffer(""String_Node_Str"");
  for (int i=0; i < items.length; i++) {
    path.append(items[i]);
    path.append(File.pathSeparator);
  }
  return path.toString();
}","protected String createList(String[] items){
  return Strings.encodeFileNames(items);
}"
75028,"protected String[] parseString(String stringList){
  StringTokenizer st=new StringTokenizer(stringList,File.pathSeparator + ""String_Node_Str"");
  ArrayList v=new ArrayList();
  while (st.hasMoreElements()) {
    v.add(st.nextElement());
  }
  return (String[])v.toArray(new String[v.size()]);
}","protected String[] parseString(String stringList){
  return Strings.decodeFileNames(stringList);
}"
75029,"public void initializeDefaultPreferences(){
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  IProject ptIIProject=ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str"");
  if (ptIIProject.exists()) {
    store.setDefault(PreferenceConstants.PTII,ptIIProject.getFullPath().toOSString());
    IFile sourceList=ptIIProject.getFile(""String_Node_Str"");
    if (sourceList.exists())     store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,sourceList.getLocation().toOSString());
 else     store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_ROOT,ptIIProject.getFullPath().toOSString());
    store.setDefault(PreferenceConstants.BACKTRACK_GENERATE_CONFIGURATION,true);
    IFile configuration=ptIIProject.getFile(""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_CONFIGURATION,configuration.getLocation().toOSString());
  }
 else {
    store.setDefault(PreferenceConstants.PTII,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_ROOT,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_GENERATE_CONFIGURATION,false);
    store.setDefault(PreferenceConstants.BACKTRACK_CONFIGURATION,""String_Node_Str"");
  }
  store.setDefault(PreferenceConstants.BACKTRACK_PREFIX,""String_Node_Str"");
  store.setDefault(PreferenceConstants.BACKTRACK_OVERWRITE,false);
}","public void initializeDefaultPreferences(){
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  IProject ptIIProject=ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str"");
  if (ptIIProject.exists()) {
    store.setDefault(PreferenceConstants.PTII,ptIIProject.getLocation().toOSString());
    IFile sourceList=ptIIProject.getFile(""String_Node_Str"");
    if (sourceList.exists())     store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,sourceList.getLocation().toOSString());
 else     store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_ROOT,ptIIProject.getFullPath().toOSString());
    store.setDefault(PreferenceConstants.BACKTRACK_GENERATE_CONFIGURATION,true);
    IFile configuration=ptIIProject.getFile(""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_CONFIGURATION,configuration.getLocation().toOSString());
  }
 else {
    store.setDefault(PreferenceConstants.PTII,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_ROOT,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_GENERATE_CONFIGURATION,false);
    store.setDefault(PreferenceConstants.BACKTRACK_CONFIGURATION,""String_Node_Str"");
  }
  store.setDefault(PreferenceConstants.BACKTRACK_PREFIX,""String_Node_Str"");
  store.setDefault(PreferenceConstants.BACKTRACK_OVERWRITE,false);
}"
75030,"public Object open(){
  Shell parent=getParent();
  _shell=new Shell(parent,SWT.MODELESS | SWT.APPLICATION_MODAL);
  _shell.setText(getText());
  _shell.setLayout(new FillLayout());
  Label logo=new Label(_shell,SWT.NULL);
  ImageDescriptor descriptor=ImageDescriptor.createFromFile(EclipsePlugin.class,""String_Node_Str"");
  Image image=descriptor.createImage();
  logo.setImage(image);
  int width=image.getBounds().width;
  int height=image.getBounds().height;
  Display display=parent.getDisplay();
  Rectangle displayBounds=display.getBounds();
  Rectangle bounds=new Rectangle((displayBounds.width - width) / 2,(displayBounds.height - height) / 2 - 80,width,height);
  _shell.setBounds(bounds);
  _shell.addKeyListener(new KeyListener(){
    public void keyPressed(    KeyEvent e){
    }
    public void keyReleased(    KeyEvent e){
      if (e.keyCode == SWT.CR || e.keyCode == SWT.ESC)       _shell.close();
    }
  }
);
  logo.addMouseListener(new MouseListener(){
    public void mouseDoubleClick(    MouseEvent e){
    }
    public void mouseDown(    MouseEvent e){
    }
    public void mouseUp(    MouseEvent e){
      if (e.button == 1)       _shell.close();
    }
  }
);
  _shell.open();
  while (!_shell.isDisposed()) {
    if (!display.readAndDispatch())     display.sleep();
  }
  return result;
}","public Object open(){
  Shell parent=getParent();
  _shell=new Shell(parent,SWT.MODELESS | SWT.APPLICATION_MODAL);
  _shell.setText(getText());
  _shell.setLayout(new FillLayout());
  Label logo=new Label(_shell,SWT.NULL);
  ImageDescriptor descriptor=EclipsePlugin.getImageDescriptor(""String_Node_Str"");
  Image image=descriptor.createImage();
  logo.setImage(image);
  int width=image.getBounds().width;
  int height=image.getBounds().height;
  Display display=parent.getDisplay();
  Rectangle displayBounds=display.getBounds();
  Rectangle bounds=new Rectangle((displayBounds.width - width) / 2,(displayBounds.height - height) / 2 - 80,width,height);
  _shell.setBounds(bounds);
  _shell.addKeyListener(new KeyListener(){
    public void keyPressed(    KeyEvent e){
    }
    public void keyReleased(    KeyEvent e){
      if (e.keyCode == SWT.CR || e.keyCode == SWT.ESC)       _shell.close();
    }
  }
);
  logo.addMouseListener(new MouseListener(){
    public void mouseDoubleClick(    MouseEvent e){
    }
    public void mouseDown(    MouseEvent e){
    }
    public void mouseUp(    MouseEvent e){
      if (e.button == 1)       _shell.close();
    }
  }
);
  _shell.open();
  while (!_shell.isDisposed()) {
    if (!display.readAndDispatch())     display.sleep();
  }
  return result;
}"
75031,"/** 
 * Creates the field editors. Field editors are abstractions of the common GUI blocks needed to manipulate various types of preferences. Each field editor knows how to save and restore itself.
 */
public void createFieldEditors(){
  Composite parent=getFieldEditorParent();
  DirectoryFieldEditor directoryFieldEditor=new DirectoryFieldEditor(PreferenceConstants.PTII,""String_Node_Str"",getFieldEditorParent()){
    protected void fireValueChanged(    String property,    Object oldValue,    Object newValue){
      if (property == VALUE && isValid()) {
        String PTII=getStringValue();
        File sourceList=new File(PTII + ""String_Node_Str"");
        if (sourceList.exists()) {
          IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
          store.setValue(PreferenceConstants.BACKTRACK_SOURCE_LIST,sourceList.getPath());
        }
      }
      super.fireValueChanged(property,oldValue,newValue);
    }
  }
;
  addField(directoryFieldEditor);
  Label space=new Label(parent,0);
  GridData gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.grabExcessVerticalSpace=true;
  space.setLayoutData(gridData);
  Label logo=new Label(parent,0);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.CENTER;
  logo.setLayoutData(gridData);
  ImageDescriptor descriptor=ImageDescriptor.createFromFile(EclipsePlugin.class,""String_Node_Str"");
  logo.setImage(descriptor.createImage());
}","/** 
 * Creates the field editors. Field editors are abstractions of the common GUI blocks needed to manipulate various types of preferences. Each field editor knows how to save and restore itself.
 */
public void createFieldEditors(){
  Composite parent=getFieldEditorParent();
  DirectoryFieldEditor directoryFieldEditor=new DirectoryFieldEditor(PreferenceConstants.PTII,""String_Node_Str"",getFieldEditorParent()){
    protected void fireValueChanged(    String property,    Object oldValue,    Object newValue){
      if (property == VALUE && isValid()) {
        String PTII=getStringValue();
        File sourceList=new File(PTII + ""String_Node_Str"");
        if (sourceList.exists()) {
          IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
          store.setValue(PreferenceConstants.BACKTRACK_SOURCE_LIST,sourceList.getPath());
        }
      }
      super.fireValueChanged(property,oldValue,newValue);
    }
  }
;
  addField(directoryFieldEditor);
  Label space=new Label(parent,0);
  GridData gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.grabExcessVerticalSpace=true;
  space.setLayoutData(gridData);
  Label logo=new Label(parent,0);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.CENTER;
  logo.setLayoutData(gridData);
  ImageDescriptor descriptor=EclipsePlugin.getImageDescriptor(""String_Node_Str"");
  logo.setImage(descriptor.createImage());
}"
75032,"/** 
 * Leave a class declaration. The current class is set back to the last current class (the class on the top of the previous class stack).
 * @see #enterClass(Class)
 */
public void leaveClass(){
  _currentClass=(Class)_previousClasses.pop();
  _anonymousCounts.pop();
  _loader.setCurrentClass(_currentClass,false);
}","/** 
 * Leave a class declaration. The current class is set back to the last current class (the class on the top of the previous class stack).
 * @see #enterClass(Class)
 */
public void leaveClass(){
  int i=_previousClasses.size() - 1;
  while (i >= 0 && !(_previousClasses.get(i) instanceof Class))   i--;
  _currentClass=i >= 0 ? (Class)_previousClasses.get(i) : null;
  _previousClasses.pop();
  _anonymousCounts.pop();
  _loader.setCurrentClass(_currentClass,false);
}"
75033,"/** 
 * @param root
 */
public void afterTraverse(TypeAnalyzer analyzer,CompilationUnit root){
  PackageDeclaration declaration=root.getPackage();
  AST ast=root.getAST();
  if (_prefix != null && _prefix.length() > 0)   root.accept(new Renamer(analyzer.getState()));
}","/** 
 * @param root
 */
public void afterTraverse(TypeAnalyzer analyzer,CompilationUnit root){
  if (_prefix != null && _prefix.length() > 0) {
    root.accept(new Renamer(analyzer.getState()));
    PackageDeclaration packageDeclaration=root.getPackage();
    AST ast=root.getAST();
    if (packageDeclaration == null) {
      packageDeclaration=ast.newPackageDeclaration();
      packageDeclaration.setName(AbstractTransformer.createName(ast,_prefix));
      root.setPackage(packageDeclaration);
    }
  }
}"
75034,"public void run(){
  try {
    if (_file.exists())     _file.setContents(_inputStream,true,false,null);
 else     _file.create(_inputStream,true,null);
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      _inputStream.close();
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}","public void run(){
  try {
    Transformer.transform(_fileName,_compilationUnit,_writer,_classPaths,_crossAnalyzedTypes);
  }
 catch (  Exception e) {
    e.printStackTrace();
    OutputConsole.outputError(e.getMessage());
  }
}"
75035,"protected void _update(){
  if (!_needRefactoring)   return;
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  IFile previewFile=((IFileEditorInput)_preview.getEditorInput()).getFile();
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  boolean overwrite=store.getBoolean(PreferenceConstants.BACKTRACK_OVERWRITE);
  if (!overwrite && previewFile.exists() && previewFile.isLocal(0)) {
    OutputConsole.outputError(""String_Node_Str"" + previewFile.getLocation().toOSString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return;
  }
  PipedOutputStream outputStream=new PipedOutputStream();
  OutputStreamWriter writer=new OutputStreamWriter(outputStream);
  try {
    PipedInputStream inputStream=new PipedInputStream(outputStream);
    CompilationUnit compilationUnit=_getCompilationUnit();
    new RefactoredOutputThread(previewFile,inputStream).start();
    String[] classPaths=null;
    String[] PTClassPaths=Environment.getClassPaths(null);
    String[] extraClassPaths=new String[0];
    if (file.getProject() != null)     extraClassPaths=new String[]{file.getProject().getLocation().toOSString()};
    if (!Environment.setupTransformerArguments(getContainer().getShell(),false,true)) {
      OutputConsole.outputError(""String_Node_Str"");
      return;
    }
    Environment.createFolders(previewFile.getParent());
    Transformer.transform(file.getName(),compilationUnit,writer,Environment.combineArrays(PTClassPaths,extraClassPaths),new String[]{});
    _needRefactoring=false;
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      writer.close();
      _preview.setInput(new FileEditorInput(previewFile));
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}","protected void _update(){
  if (!_needRefactoring)   return;
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  IFile previewFile=((IFileEditorInput)_preview.getEditorInput()).getFile();
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  boolean overwrite=store.getBoolean(PreferenceConstants.BACKTRACK_OVERWRITE);
  if (!overwrite && previewFile.exists() && previewFile.isLocal(0)) {
    OutputConsole.outputError(""String_Node_Str"" + previewFile.getLocation().toOSString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return;
  }
  PipedOutputStream outputStream=new PipedOutputStream();
  OutputStreamWriter writer=new OutputStreamWriter(outputStream);
  try {
    PipedInputStream inputStream=new PipedInputStream(outputStream);
    CompilationUnit compilationUnit=_getCompilationUnit();
    new RefactoredOutputThread(previewFile,inputStream).start();
    String[] classPaths=null;
    String[] PTClassPaths=Environment.getClassPaths(null);
    String[] extraClassPaths=new String[0];
    if (file.getProject() != null)     extraClassPaths=new String[]{file.getProject().getLocation().toOSString()};
    if (!Environment.setupTransformerArguments(getContainer().getShell(),false,true)) {
      OutputConsole.outputError(""String_Node_Str"");
      return;
    }
    Environment.createFolders(previewFile.getParent());
    BusyIndicator.showWhile(Display.getCurrent(),new TransformerRunnable(file.getName(),compilationUnit,writer,Environment.combineArrays(PTClassPaths,extraClassPaths),new String[]{}));
    _needRefactoring=false;
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      writer.close();
      _preview.setInput(new FileEditorInput(previewFile));
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}"
75036,"private void _createRawPage(){
  int pageIndex=0;
  Composite composite=new Composite(_container,_getOrientation(this));
  composite.setLayout(new FillLayout());
  super.createPartControl(composite);
  _editor=this;
  _createItem(pageIndex,composite).setText(""String_Node_Str"");
}","private void _createRawPage(){
  int pageIndex=0;
  Composite composite=new Composite(_container,_getOrientation(this));
  composite.setLayout(new FillLayout());
  _editor=this;
  _createItem(pageIndex,composite).setText(""String_Node_Str"");
}"
75037,"private void _setupPreviewPage(){
  int pageIndex=1;
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  try {
    CompilationUnit compilationUnit=_getCompilationUnit();
    String packageName=null;
    if (compilationUnit.getPackage() != null)     packageName=compilationUnit.getPackage().getName().toString();
    IPath refactoredFile=Environment.getRefactoredFile(file.getLocation().toOSString(),packageName);
    IFile previewFile=Environment.getContainer(refactoredFile).getFile(null);
    _preview=new CompilationUnitEditor();
    _preview.init(_editor.getEditorSite(),new FileEditorInput(previewFile){
      public boolean exists(){
        return true;
      }
    }
);
    _preview.createPartControl((Composite)_container.getItem(pageIndex).getControl());
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
}","private void _setupPreviewPage(){
  int pageIndex=1;
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  try {
    CompilationUnit compilationUnit=_getCompilationUnit();
    String packageName=null;
    if (compilationUnit.getPackage() != null)     packageName=compilationUnit.getPackage().getName().toString();
    IPath refactoredFile=Environment.getRefactoredFile(file.getLocation().toOSString(),packageName);
    IFile previewFile=Environment.getContainer(refactoredFile).getFile(null);
    _preview=new CompilationUnitEditor();
    _preview.init(_editor.getEditorSite(),new FileEditorInput(previewFile){
      public boolean exists(){
        return true;
      }
    }
);
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
}"
75038,"public void createPartControl(Composite parent){
  _container=_createContainer(parent);
  _createPages();
  ISourceViewer sourceViewer=getSourceViewer();
  if (sourceViewer == null)   return;
  IDocument document=sourceViewer.getDocument();
  if (document != null)   document.addDocumentListener(new IDocumentListener(){
    public void documentAboutToBeChanged(    DocumentEvent event){
    }
    public void documentChanged(    DocumentEvent event){
      _needRefactoring=true;
    }
  }
);
  _setActivePage(0);
}","public void createPartControl(Composite parent){
  _container=_createContainer(parent);
  _createPages();
  _preview.createPartControl((Composite)_container.getItem(1).getControl());
  super.createPartControl((Composite)_container.getItem(0).getControl());
  ISourceViewer sourceViewer=getSourceViewer();
  if (sourceViewer == null)   return;
  IDocument document=sourceViewer.getDocument();
  if (document != null)   document.addDocumentListener(new IDocumentListener(){
    public void documentAboutToBeChanged(    DocumentEvent event){
    }
    public void documentChanged(    DocumentEvent event){
      _needRefactoring=true;
    }
  }
);
  _setActivePage(0);
}"
75039,"public void resourceChanged(final IResourceChangeEvent event){
  if (event.getType() == IResourceChangeEvent.PRE_CLOSE) {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        IWorkbenchPage[] pages=getSite().getWorkbenchWindow().getPages();
        for (int i=0; i < pages.length; i++) {
          if (((FileEditorInput)_editor.getEditorInput()).getFile().getProject().equals(event.getResource())) {
            IEditorPart editorPart=pages[i].findEditor(_editor.getEditorInput());
            pages[i].closeEditor(editorPart,true);
          }
        }
      }
    }
);
  }
}","public void resourceChanged(final IResourceChangeEvent event){
  if (event.getType() == IResourceChangeEvent.PRE_CLOSE) {
    Display.getDefault().asyncExec(new Runnable(){
      public void run(){
        IWorkbenchPage[] pages=getSite().getWorkbenchWindow().getPages();
        for (int i=0; i < pages.length; i++) {
          if (((IFileEditorInput)_editor.getEditorInput()).getFile().getProject().equals(event.getResource())) {
            IEditorPart editorPart=pages[i].findEditor(_editor.getEditorInput());
            pages[i].closeEditor(editorPart,true);
          }
        }
      }
    }
);
  }
}"
75040,"protected void _update(){
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  IFile previewFile=((FileEditorInput)_preview.getEditorInput()).getFile();
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  boolean overwrite=store.getBoolean(PreferenceConstants.BACKTRACK_OVERWRITE);
  if (!overwrite && previewFile.exists() && previewFile.isLocal(0)) {
    OutputConsole.outputError(""String_Node_Str"" + previewFile.getLocation().toOSString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return;
  }
  PipedOutputStream outputStream=new PipedOutputStream();
  OutputStreamWriter writer=new OutputStreamWriter(outputStream);
  try {
    PipedInputStream inputStream=new PipedInputStream(outputStream);
    CompilationUnit compilationUnit=_getCompilationUnit();
    new RefactoredOutputThread(previewFile,inputStream).start();
    String[] classPaths=null;
    String[] PTClassPaths=Environment.getClassPaths(null);
    String[] extraClassPaths=new String[0];
    if (file.getProject() != null)     extraClassPaths=new String[]{file.getProject().getLocation().toOSString()};
    if (!Environment.setupTransformerArguments(getContainer().getShell(),false,true)) {
      OutputConsole.outputError(""String_Node_Str"");
      return;
    }
    Environment.createFolders(previewFile.getParent());
    Transformer.transform(file.getName(),compilationUnit,writer,Environment.combineArrays(PTClassPaths,extraClassPaths),new String[]{});
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      writer.close();
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}","protected void _update(){
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  IFile previewFile=((IFileEditorInput)_preview.getEditorInput()).getFile();
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  boolean overwrite=store.getBoolean(PreferenceConstants.BACKTRACK_OVERWRITE);
  if (!overwrite && previewFile.exists() && previewFile.isLocal(0)) {
    OutputConsole.outputError(""String_Node_Str"" + previewFile.getLocation().toOSString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return;
  }
  PipedOutputStream outputStream=new PipedOutputStream();
  OutputStreamWriter writer=new OutputStreamWriter(outputStream);
  try {
    PipedInputStream inputStream=new PipedInputStream(outputStream);
    CompilationUnit compilationUnit=_getCompilationUnit();
    new RefactoredOutputThread(previewFile,inputStream).start();
    String[] classPaths=null;
    String[] PTClassPaths=Environment.getClassPaths(null);
    String[] extraClassPaths=new String[0];
    if (file.getProject() != null)     extraClassPaths=new String[]{file.getProject().getLocation().toOSString()};
    if (!Environment.setupTransformerArguments(getContainer().getShell(),false,true)) {
      OutputConsole.outputError(""String_Node_Str"");
      return;
    }
    Environment.createFolders(previewFile.getParent());
    Transformer.transform(file.getName(),compilationUnit,writer,Environment.combineArrays(PTClassPaths,extraClassPaths),new String[]{});
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      writer.close();
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}"
75041,"private void _createSection1(){
  Composite composite=_createSection(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Composite currentComposite=_newComposite(composite);
  _sourceList=new FileFieldEditor(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"",currentComposite){
    protected boolean checkState(){
      boolean superResult=super.checkState();
      if (!getTextControl(_getParent(this)).isEnabled())       return superResult;
      if (getStringValue().equals(_lastString)) {
        if (superResult)         return true;
      }
 else {
        _lastString=getStringValue();
        _sourcesModified=false;
        if (superResult)         return _updateSources();
      }
      List list=_sources.getListControl(_getParent(_sources));
      list.removeAll();
      return false;
    }
    protected String changePressed(){
      IProject ptIIProject=ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str"");
      FileSelectionDialog dialog=new FileSelectionDialog(getShell(),new FileSystemElement(""String_Node_Str"",null,true),""String_Node_Str"");
      if (dialog.open() == FileSelectionDialog.OK) {
        Object[] result=dialog.getResult();
        Path p=(Path)result[0];
        return p.toOSString();
      }
 else       return null;
    }
    private String _lastString=null;
  }
;
  GridData gridData=new GridData();
  gridData.widthHint=0;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sourceList.getTextControl(currentComposite).setLayoutData(gridData);
  _sourceList.setFileExtensions(new String[]{""String_Node_Str"",""String_Node_Str""});
  _setParent(_sourceList,currentComposite);
  addField(_sourceList);
  currentComposite=_newComposite(composite);
  _sources=new ListEditor(PreferenceConstants.BACKTRACK_SOURCES,""String_Node_Str"",currentComposite){
    protected String createList(    String[] items){
      StringBuffer path=new StringBuffer(""String_Node_Str"");
      for (int i=0; i < items.length; i++) {
        path.append(items[i]);
        path.append(File.pathSeparator);
      }
      return path.toString();
    }
    protected String getNewInputObject(){
      FileDialog dialog=new FileDialog(getShell());
      dialog.setText(""String_Node_Str"");
      String file=dialog.open();
      if (file != null) {
        file=file.trim();
        if (file.length() == 0)         return null;
      }
      return file;
    }
    protected String[] parseString(    String stringList){
      StringTokenizer st=new StringTokenizer(stringList,File.pathSeparator + ""String_Node_Str"");
      ArrayList v=new ArrayList();
      while (st.hasMoreElements()) {
        v.add(st.nextElement());
      }
      return (String[])v.toArray(new String[v.size()]);
    }
    protected void doLoad(){
    }
    protected void doLoadDefault(){
    }
    protected void doStore(){
      if (_sourcesModified) {
        List list=getListControl(_getParent(this));
        String[] items=list.getItems();
        String fileName=_sourceList.getStringValue();
        try {
          PrintWriter writer=new PrintWriter(new FileOutputStream(fileName));
          for (int i=0; i < items.length; i++)           writer.write(items[i] + ""String_Node_Str"");
          writer.close();
        }
 catch (        Exception e) {
          MessageDialog.openError(getShell(),""String_Node_Str"",e.getMessage());
        }
      }
    }
  }
;
  gridData=new GridData();
  gridData.widthHint=0;
  gridData.heightHint=LIST_HEIGHT;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sources.getListControl(currentComposite).setLayoutData(gridData);
  _setParent(_sources,currentComposite);
  addField(_sources);
}","private void _createSection1(){
  Composite composite=_createSection(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Composite currentComposite=_newComposite(composite);
  _sourceList=new FileFieldEditor(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"",currentComposite){
    protected boolean checkState(){
      boolean superResult=super.checkState();
      if (!getTextControl(_getParent(this)).isEnabled())       return superResult;
      if (getStringValue().equals(_lastString)) {
        if (superResult)         return true;
      }
 else {
        _lastString=getStringValue();
        _sourcesModified=false;
        if (superResult)         return _updateSources();
      }
      List list=_sources.getListControl(_getParent(_sources));
      list.removeAll();
      return false;
    }
    private String _lastString=null;
  }
;
  GridData gridData=new GridData();
  gridData.widthHint=0;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sourceList.getTextControl(currentComposite).setLayoutData(gridData);
  _sourceList.setFileExtensions(new String[]{""String_Node_Str"",""String_Node_Str""});
  _setParent(_sourceList,currentComposite);
  addField(_sourceList);
  currentComposite=_newComposite(composite);
  _sources=new ListEditor(PreferenceConstants.BACKTRACK_SOURCES,""String_Node_Str"",currentComposite){
    protected String createList(    String[] items){
      StringBuffer path=new StringBuffer(""String_Node_Str"");
      for (int i=0; i < items.length; i++) {
        path.append(items[i]);
        path.append(File.pathSeparator);
      }
      return path.toString();
    }
    protected String getNewInputObject(){
      String sourceList=_sourceList.getStringValue();
      String sourceListPath=new File(sourceList).getParent();
      FileDialog dialog=new FileDialog(getShell());
      dialog.setText(""String_Node_Str"");
      dialog.setFilterPath(sourceListPath);
      dialog.setFilterExtensions(new String[]{""String_Node_Str""});
      String file=dialog.open();
      if (file != null) {
        file=file.trim();
        if (file.length() == 0)         return null;
      }
      return file;
    }
    protected String[] parseString(    String stringList){
      StringTokenizer st=new StringTokenizer(stringList,File.pathSeparator + ""String_Node_Str"");
      ArrayList v=new ArrayList();
      while (st.hasMoreElements()) {
        v.add(st.nextElement());
      }
      return (String[])v.toArray(new String[v.size()]);
    }
    protected void doLoad(){
    }
    protected void doLoadDefault(){
    }
    protected void doStore(){
      if (_sourcesModified) {
        List list=getListControl(_getParent(this));
        String[] items=list.getItems();
        String fileName=_sourceList.getStringValue();
        try {
          PrintWriter writer=new PrintWriter(new FileOutputStream(fileName));
          for (int i=0; i < items.length; i++)           writer.write(items[i] + ""String_Node_Str"");
          writer.close();
        }
 catch (        Exception e) {
          MessageDialog.openError(getShell(),""String_Node_Str"",e.getMessage());
        }
      }
    }
  }
;
  gridData=new GridData();
  gridData.widthHint=0;
  gridData.heightHint=LIST_HEIGHT;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sources.getListControl(currentComposite).setLayoutData(gridData);
  _setParent(_sources,currentComposite);
  addField(_sources);
}"
75042,"protected String getNewInputObject(){
  FileDialog dialog=new FileDialog(getShell());
  dialog.setText(""String_Node_Str"");
  String file=dialog.open();
  if (file != null) {
    file=file.trim();
    if (file.length() == 0)     return null;
  }
  return file;
}","protected String getNewInputObject(){
  String sourceList=_sourceList.getStringValue();
  String sourceListPath=new File(sourceList).getParent();
  FileDialog dialog=new FileDialog(getShell());
  dialog.setText(""String_Node_Str"");
  dialog.setFilterPath(sourceListPath);
  dialog.setFilterExtensions(new String[]{""String_Node_Str""});
  String file=dialog.open();
  if (file != null) {
    file=file.trim();
    if (file.length() == 0)     return null;
  }
  return file;
}"
75043,"public static void createFolders(IContainer container) throws CoreException {
  if (!container.exists()) {
    if (container instanceof IFolder) {
      createFolders(container.getParent());
      ((IFolder)container).create(true,false,null);
    }
  }
}","public static void createFolders(IContainer container) throws CoreException {
  if (!container.exists()) {
    if (container instanceof IFolder) {
      createFolders(container.getParent());
      ((IFolder)container).create(true,true,null);
    }
  }
}"
75044,"public static void closeConsole(){
  IConsoleManager manager=ConsolePlugin.getDefault().getConsoleManager();
  OutputConsole console=EclipsePlugin.getDefault().getConsole();
  if (console != null) {
    manager.removeConsoles(new IConsole[]{console});
  }
}","public static void closeConsole(){
  IConsoleManager manager=ConsolePlugin.getDefault().getConsoleManager();
  OutputConsole console=EclipsePlugin.getDefault().getConsole();
  if (console != null)   manager.removeConsoles(new IConsole[]{console});
}"
75045,"private void _createSection1(){
  Composite composite=_createSection(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Composite currentComposite=_newComposite(composite);
  _sourceList=new FileFieldEditor(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"",currentComposite){
    protected boolean checkState(){
      boolean superResult=super.checkState();
      if (!getTextControl(_getParent(this)).isEnabled())       return superResult;
      if (getStringValue().equals(_lastString)) {
        if (superResult)         return true;
      }
 else {
        _lastString=getStringValue();
        _sourcesModified=false;
        if (superResult)         return _updateSources();
      }
      List list=_sources.getListControl(_getParent(_sources));
      list.removeAll();
      return false;
    }
    private String _lastString=null;
  }
;
  GridData gridData=new GridData();
  gridData.widthHint=0;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sourceList.getTextControl(currentComposite).setLayoutData(gridData);
  _sourceList.setFileExtensions(new String[]{""String_Node_Str"",""String_Node_Str""});
  _setParent(_sourceList,currentComposite);
  addField(_sourceList);
  currentComposite=_newComposite(composite);
  _sources=new ListEditor(PreferenceConstants.BACKTRACK_SOURCES,""String_Node_Str"",currentComposite){
    protected String createList(    String[] items){
      StringBuffer path=new StringBuffer(""String_Node_Str"");
      for (int i=0; i < items.length; i++) {
        path.append(items[i]);
        path.append(File.pathSeparator);
      }
      return path.toString();
    }
    protected String getNewInputObject(){
      FileDialog dialog=new FileDialog(getShell());
      dialog.setText(""String_Node_Str"");
      String file=dialog.open();
      if (file != null) {
        file=file.trim();
        if (file.length() == 0)         return null;
      }
      return file;
    }
    protected String[] parseString(    String stringList){
      StringTokenizer st=new StringTokenizer(stringList,File.pathSeparator + ""String_Node_Str"");
      ArrayList v=new ArrayList();
      while (st.hasMoreElements()) {
        v.add(st.nextElement());
      }
      return (String[])v.toArray(new String[v.size()]);
    }
    protected void doLoad(){
    }
    protected void doLoadDefault(){
    }
    protected void doStore(){
      if (_sourcesModified) {
        List list=getListControl(_getParent(this));
        String[] items=list.getItems();
        String fileName=_sourceList.getStringValue();
        try {
          PrintWriter writer=new PrintWriter(new FileOutputStream(fileName));
          for (int i=0; i < items.length; i++)           writer.write(items[i] + ""String_Node_Str"");
          writer.close();
        }
 catch (        Exception e) {
          MessageDialog.openError(getShell(),""String_Node_Str"",e.getMessage());
        }
      }
    }
  }
;
  gridData=new GridData();
  gridData.widthHint=0;
  gridData.heightHint=LIST_HEIGHT;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sources.getListControl(currentComposite).setLayoutData(gridData);
  _setParent(_sources,currentComposite);
  addField(_sources);
}","private void _createSection1(){
  Composite composite=_createSection(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  Composite currentComposite=_newComposite(composite);
  _sourceList=new FileFieldEditor(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"",currentComposite){
    protected boolean checkState(){
      boolean superResult=super.checkState();
      if (!getTextControl(_getParent(this)).isEnabled())       return superResult;
      if (getStringValue().equals(_lastString)) {
        if (superResult)         return true;
      }
 else {
        _lastString=getStringValue();
        _sourcesModified=false;
        if (superResult)         return _updateSources();
      }
      List list=_sources.getListControl(_getParent(_sources));
      list.removeAll();
      return false;
    }
    protected String changePressed(){
      IProject ptIIProject=ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str"");
      FileSelectionDialog dialog=new FileSelectionDialog(getShell(),new FileSystemElement(""String_Node_Str"",null,true),""String_Node_Str"");
      if (dialog.open() == FileSelectionDialog.OK) {
        Object[] result=dialog.getResult();
        Path p=(Path)result[0];
        return p.toOSString();
      }
 else       return null;
    }
    private String _lastString=null;
  }
;
  GridData gridData=new GridData();
  gridData.widthHint=0;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sourceList.getTextControl(currentComposite).setLayoutData(gridData);
  _sourceList.setFileExtensions(new String[]{""String_Node_Str"",""String_Node_Str""});
  _setParent(_sourceList,currentComposite);
  addField(_sourceList);
  currentComposite=_newComposite(composite);
  _sources=new ListEditor(PreferenceConstants.BACKTRACK_SOURCES,""String_Node_Str"",currentComposite){
    protected String createList(    String[] items){
      StringBuffer path=new StringBuffer(""String_Node_Str"");
      for (int i=0; i < items.length; i++) {
        path.append(items[i]);
        path.append(File.pathSeparator);
      }
      return path.toString();
    }
    protected String getNewInputObject(){
      FileDialog dialog=new FileDialog(getShell());
      dialog.setText(""String_Node_Str"");
      String file=dialog.open();
      if (file != null) {
        file=file.trim();
        if (file.length() == 0)         return null;
      }
      return file;
    }
    protected String[] parseString(    String stringList){
      StringTokenizer st=new StringTokenizer(stringList,File.pathSeparator + ""String_Node_Str"");
      ArrayList v=new ArrayList();
      while (st.hasMoreElements()) {
        v.add(st.nextElement());
      }
      return (String[])v.toArray(new String[v.size()]);
    }
    protected void doLoad(){
    }
    protected void doLoadDefault(){
    }
    protected void doStore(){
      if (_sourcesModified) {
        List list=getListControl(_getParent(this));
        String[] items=list.getItems();
        String fileName=_sourceList.getStringValue();
        try {
          PrintWriter writer=new PrintWriter(new FileOutputStream(fileName));
          for (int i=0; i < items.length; i++)           writer.write(items[i] + ""String_Node_Str"");
          writer.close();
        }
 catch (        Exception e) {
          MessageDialog.openError(getShell(),""String_Node_Str"",e.getMessage());
        }
      }
    }
  }
;
  gridData=new GridData();
  gridData.widthHint=0;
  gridData.heightHint=LIST_HEIGHT;
  gridData.horizontalAlignment=SWT.FILL;
  gridData.grabExcessHorizontalSpace=true;
  _sources.getListControl(currentComposite).setLayoutData(gridData);
  _setParent(_sources,currentComposite);
  addField(_sources);
}"
75046,"public Control createContents(Composite parent){
  _toolkit=new FormToolkit(getShell().getDisplay());
  _form=_toolkit.createScrolledForm(parent);
  _form.setLayoutData(new GridData(GridData.FILL_BOTH));
  _form.setBackground(null);
  _form.getBody().setLayout(new TableWrapLayout());
  _createSection1();
  _createSection2();
  _createSection3();
  _createSection4();
  _createSection5();
  initialize();
  checkState();
  return parent;
}","public Control createContents(Composite parent){
  _toolkit=new FormToolkit(getShell().getDisplay());
  _form=_toolkit.createScrolledForm(parent);
  _form.setLayoutData(new GridData(GridData.FILL_BOTH));
  _form.setBackground(parent.getBackground());
  _form.getBody().setLayout(new TableWrapLayout());
  _createSection1();
  _createSection2();
  _createSection3();
  _createSection4();
  _createSection5();
  initialize();
  checkState();
  return parent;
}"
75047,"public void initializeDefaultPreferences(){
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  IProject ptIIProject=ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str"");
  if (ptIIProject.exists()) {
    store.setDefault(PreferenceConstants.PTII,ptIIProject.getLocation().toOSString());
    IFile sourceList=ptIIProject.getFile(""String_Node_Str"");
    if (sourceList.exists())     store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,sourceList.getLocation().toOSString());
 else     store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_ROOT,ptIIProject.getLocation().toOSString());
    store.setDefault(PreferenceConstants.BACKTRACK_GENERATE_CONFIGURATION,true);
    IFile configuration=ptIIProject.getFile(""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_CONFIGURATION,configuration.getLocation().toOSString());
  }
 else {
    store.setDefault(PreferenceConstants.PTII,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_ROOT,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_GENERATE_CONFIGURATION,false);
    store.setDefault(PreferenceConstants.BACKTRACK_CONFIGURATION,""String_Node_Str"");
  }
  store.setDefault(PreferenceConstants.BACKTRACK_PREFIX,""String_Node_Str"");
  store.setDefault(PreferenceConstants.BACKTRACK_OVERWRITE,false);
}","public void initializeDefaultPreferences(){
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  IProject ptIIProject=ResourcesPlugin.getWorkspace().getRoot().getProject(""String_Node_Str"");
  if (ptIIProject.exists()) {
    store.setDefault(PreferenceConstants.PTII,ptIIProject.getFullPath().toOSString());
    IFile sourceList=ptIIProject.getFile(""String_Node_Str"");
    if (sourceList.exists())     store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,sourceList.getLocation().toOSString());
 else     store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_ROOT,ptIIProject.getFullPath().toOSString());
    store.setDefault(PreferenceConstants.BACKTRACK_GENERATE_CONFIGURATION,true);
    IFile configuration=ptIIProject.getFile(""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_CONFIGURATION,configuration.getLocation().toOSString());
  }
 else {
    store.setDefault(PreferenceConstants.PTII,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_SOURCE_LIST,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_ROOT,""String_Node_Str"");
    store.setDefault(PreferenceConstants.BACKTRACK_GENERATE_CONFIGURATION,false);
    store.setDefault(PreferenceConstants.BACKTRACK_CONFIGURATION,""String_Node_Str"");
  }
  store.setDefault(PreferenceConstants.BACKTRACK_PREFIX,""String_Node_Str"");
  store.setDefault(PreferenceConstants.BACKTRACK_OVERWRITE,false);
}"
75048,"/** 
 * Creates the field editors. Field editors are abstractions of the common GUI blocks needed to manipulate various types of preferences. Each field editor knows how to save and restore itself.
 */
public void createFieldEditors(){
  _setDefault();
  Composite parent=getFieldEditorParent();
  addField(new DirectoryFieldEditor(PreferenceConstants.PTII,""String_Node_Str"",getFieldEditorParent()){
    protected void fireValueChanged(    String property,    Object oldValue,    Object newValue){
      if (property == VALUE && isValid()) {
        String PTII=getStringValue();
        IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
        File sourceList=new File(PTII + ""String_Node_Str"");
        if (sourceList.exists())         store.setValue(PreferenceConstants.BACKTRACK_SOURCE_LIST,sourceList.getPath());
      }
      super.fireValueChanged(property,oldValue,newValue);
    }
  }
);
  Label space=new Label(parent,0);
  GridData gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.grabExcessVerticalSpace=true;
  space.setLayoutData(gridData);
  Label logo=new Label(parent,0);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.CENTER;
  logo.setLayoutData(gridData);
  ImageDescriptor descriptor=ImageDescriptor.createFromFile(EclipsePlugin.class,""String_Node_Str"");
  logo.setImage(descriptor.createImage());
}","/** 
 * Creates the field editors. Field editors are abstractions of the common GUI blocks needed to manipulate various types of preferences. Each field editor knows how to save and restore itself.
 */
public void createFieldEditors(){
  Composite parent=getFieldEditorParent();
  DirectoryFieldEditor directoryFieldEditor=new DirectoryFieldEditor(PreferenceConstants.PTII,""String_Node_Str"",getFieldEditorParent()){
    protected void fireValueChanged(    String property,    Object oldValue,    Object newValue){
      if (property == VALUE && isValid()) {
        String PTII=getStringValue();
        IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
        File sourceList=new File(PTII + ""String_Node_Str"");
        if (sourceList.exists())         store.setValue(PreferenceConstants.BACKTRACK_SOURCE_LIST,sourceList.getPath());
      }
      super.fireValueChanged(property,oldValue,newValue);
    }
  }
;
  addField(directoryFieldEditor);
  Label space=new Label(parent,0);
  GridData gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.grabExcessVerticalSpace=true;
  space.setLayoutData(gridData);
  Label logo=new Label(parent,0);
  gridData=new GridData();
  gridData.horizontalSpan=3;
  gridData.horizontalAlignment=SWT.CENTER;
  logo.setLayoutData(gridData);
  ImageDescriptor descriptor=ImageDescriptor.createFromFile(EclipsePlugin.class,""String_Node_Str"");
  logo.setImage(descriptor.createImage());
}"
75049,"/** 
 * Transform a set of files into backtracking-enabled ones. The set of files is given by an array of strings as their names, or the names of the directories that contain them. If a string in the array is a file name, it is refactored and the output is printed out; if it is the name of a directory, all Java files in the directory and its sub-directories are looked up and refactored in the same way.
 * @param args The array of file names or names of directories.
 * @exception Exception If any exception occues.
 */
public static void main(String[] args) throws Exception {
  boolean outputResult=true;
  if (args.length == 0)   _printUsage();
 else {
    String[] paths=PathFinder.getPtClassPaths();
    Writer standardWriter=outputResult ? new OutputStreamWriter(System.out) : null;
    int start=0;
    while (start < args.length) {
      int newPosition=parseArguments(args,start);
      if (newPosition != start)       start=newPosition;
 else       break;
    }
    if (_extraClassPaths != null) {
      String[] morePaths=new String[paths.length + _extraClassPaths.length];
      System.arraycopy(paths,0,morePaths,0,paths.length);
      System.arraycopy(_extraClassPaths,0,morePaths,paths.length,_extraClassPaths.length);
      paths=morePaths;
    }
    List fileList=new LinkedList();
    Set crossAnalysis=new HashSet();
    for (int i=start; i < args.length; i++) {
      String pathOrFile=args[i];
      File[] files;
      if (pathOrFile.startsWith(""String_Node_Str"")) {
        String listName=pathOrFile.substring(1);
        File listFile=new File(listName);
        File listPath=listFile.getParentFile();
        BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(listName)));
        List strings=new LinkedList();
        String line=reader.readLine();
        while (line != null) {
          strings.add(new File(listPath,line).getCanonicalPath());
          line=reader.readLine();
        }
        files=new File[strings.size()];
        Iterator stringsIter=strings.iterator();
        for (int j=0; stringsIter.hasNext(); j++)         files[j]=new File((String)stringsIter.next());
      }
 else       files=PathFinder.getJavaFiles(pathOrFile,true);
      ClassFileLoader loader=new ClassFileLoader(paths);
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        if (fileName.endsWith(""String_Node_Str""))         fileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
 else {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str"");
          continue;
        }
        Class c=null;
        try {
          c=loader.loadClass(new File(fileName));
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
          continue;
        }
        fileList.add(files[j]);
        crossAnalysis.add(c.getName());
        _addInnerClasses(crossAnalysis,fileName,c.getPackage() == null ? null : c.getPackage().getName());
      }
    }
    String[] crossAnalyzedTypes=new String[crossAnalysis.size()];
    Iterator crossAnalysisIter=crossAnalysis.iterator();
    for (int i=0; crossAnalysisIter.hasNext(); i++)     crossAnalyzedTypes[i]=(String)crossAnalysisIter.next();
    Iterator filesIter=fileList.iterator();
    while (filesIter.hasNext()) {
      File file=(File)filesIter.next();
      String fileName=file.getPath();
      System.err.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
      transform(file.getPath(),standardWriter,paths,crossAnalyzedTypes);
      if (outputResult)       standardWriter.flush();
    }
    _outputConfig();
    if (outputResult)     standardWriter.close();
  }
}","/** 
 * Transform a set of files into backtracking-enabled ones. The set of files is given by an array of strings as their names, or the names of the directories that contain them. If a string in the array is a file name, it is refactored and the output is printed out; if it is the name of a directory, all Java files in the directory and its sub-directories are looked up and refactored in the same way.
 * @param args The array of file names or names of directories.
 * @exception Exception If any exception occues.
 */
public static void main(String[] args) throws Exception {
  if (args.length == 0)   _printUsage();
 else {
    String[] paths=PathFinder.getPtClassPaths();
    int start=0;
    while (start < args.length) {
      int newPosition=parseArguments(args,start);
      if (newPosition != start)       start=newPosition;
 else       break;
    }
    if (_extraClassPaths != null) {
      String[] morePaths=new String[paths.length + _extraClassPaths.length];
      System.arraycopy(paths,0,morePaths,0,paths.length);
      System.arraycopy(_extraClassPaths,0,morePaths,paths.length,_extraClassPaths.length);
      paths=morePaths;
    }
    List fileList=new LinkedList();
    Set crossAnalysis=new HashSet();
    for (int i=start; i < args.length; i++) {
      String pathOrFile=args[i];
      File[] files;
      if (pathOrFile.startsWith(""String_Node_Str"")) {
        String listName=pathOrFile.substring(1);
        File listFile=new File(listName);
        File listPath=listFile.getParentFile();
        BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(listName)));
        List strings=new LinkedList();
        String line=reader.readLine();
        while (line != null) {
          strings.add(new File(listPath,line).getCanonicalPath());
          line=reader.readLine();
        }
        files=new File[strings.size()];
        Iterator stringsIter=strings.iterator();
        for (int j=0; stringsIter.hasNext(); j++)         files[j]=new File((String)stringsIter.next());
      }
 else       files=PathFinder.getJavaFiles(pathOrFile,true);
      ClassFileLoader loader=new ClassFileLoader(paths);
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        if (fileName.endsWith(""String_Node_Str""))         fileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
 else {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str"");
          continue;
        }
        Class c=null;
        try {
          c=loader.loadClass(new File(fileName));
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
          continue;
        }
        fileList.add(files[j]);
        crossAnalysis.add(c.getName());
        _addInnerClasses(crossAnalysis,fileName,c.getPackage() == null ? null : c.getPackage().getName());
      }
    }
    String[] crossAnalyzedTypes=new String[crossAnalysis.size()];
    Iterator crossAnalysisIter=crossAnalysis.iterator();
    for (int i=0; crossAnalysisIter.hasNext(); i++)     crossAnalyzedTypes[i]=(String)crossAnalysisIter.next();
    Writer standardWriter=_defaultToStandardOutput ? new OutputStreamWriter(System.out) : null;
    Iterator filesIter=fileList.iterator();
    while (filesIter.hasNext()) {
      File file=(File)filesIter.next();
      String fileName=file.getPath();
      System.err.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
      transform(file.getPath(),standardWriter,paths,crossAnalyzedTypes);
      if (_defaultToStandardOutput)       standardWriter.flush();
    }
    _outputConfig();
    if (_defaultToStandardOutput)     standardWriter.close();
  }
}"
75050,"/** 
 * Transform the AST with given class paths, and output the result to the writer. <p> If a output directory is set with the <tt>-output</tt> command-line argument, the output is written to a Java source file with that directory as the root directory. The given writer is not used in that case.
 * @param fileName The Java file name.
 * @param ast The AST to be refactored.
 * @param writer The writer where output is written.
 * @param classPaths The class paths.
 * @param crossAnalyzedTypes The array of names of types to be added tothe visitor's cross-analyzed types list.
 * @exception IOException If IO exception occurs when reading fromthe Java file or riting to the output.
 * @exception ASTMalformedException If the Java source is illegal.
 * @see #transform(String,Writer)
 */
public static void transform(String fileName,CompilationUnit ast,Writer writer,String[] classPaths,String[] crossAnalyzedTypes) throws IOException, ASTMalformedException {
  boolean needClose=false;
  Transformer transform=new Transformer(fileName,classPaths);
  if (ast == null)   transform._parse();
 else   transform._ast=ast;
  if (crossAnalyzedTypes != null)   transform._visitor.addCrossAnalyzedTypes(crossAnalyzedTypes);
  transform._startTransform();
  if (_rootPath != null) {
    String packageName=transform._ast.getPackage().getName().toString();
    File file=new File(fileName);
    String outputFileName=file.getName();
    SourceOutputStream outputStream=SourceOutputStream.getStream(_rootPath,packageName,outputFileName,_overwrite);
    writer=new OutputStreamWriter(outputStream);
    needClose=true;
  }
  transform._outputSource(writer);
  if (needClose)   writer.close();
  if (_configName != null) {
    File file=new File(fileName);
    String simpleName=file.getName();
    if (simpleName.toUpperCase().endsWith(""String_Node_Str"")) {
      String baseName=simpleName.substring(0,simpleName.length() - 5);
      CompilationUnit root=(CompilationUnit)transform._ast.getRoot();
      String className;
      if (root.getPackage() != null)       className=root.getPackage().getName().toString() + ""String_Node_Str"" + baseName;
 else       className=baseName;
      if (_prefix != null && _prefix.length() > 0)       className=className.substring(_prefix.length() + 1);
      _classes.add(className);
    }
  }
}","/** 
 * Transform the AST with given class paths, and output the result to the writer. <p> If a output directory is set with the <tt>-output</tt> command-line argument, the output is written to a Java source file with that directory as the root directory. The given writer is not used in that case.
 * @param fileName The Java file name.
 * @param ast The AST to be refactored.
 * @param writer The writer where output is written.
 * @param classPaths The class paths.
 * @param crossAnalyzedTypes The array of names of types to be added tothe visitor's cross-analyzed types list.
 * @exception IOException If IO exception occurs when reading fromthe Java file or riting to the output.
 * @exception ASTMalformedException If the Java source is illegal.
 * @see #transform(String,Writer)
 */
public static void transform(String fileName,CompilationUnit ast,Writer writer,String[] classPaths,String[] crossAnalyzedTypes) throws IOException, ASTMalformedException {
  boolean needClose=false;
  Transformer transform=new Transformer(fileName,classPaths);
  if (ast == null)   transform._parse();
 else   transform._ast=ast;
  if (crossAnalyzedTypes != null)   transform._visitor.addCrossAnalyzedTypes(crossAnalyzedTypes);
  transform._startTransform();
  if (writer == null) {
    String packageName=transform._ast.getPackage().getName().toString();
    File file=new File(fileName);
    String outputFileName=file.getName();
    SourceOutputStream outputStream=SourceOutputStream.getStream(_rootPath,packageName,outputFileName,_overwrite);
    writer=new OutputStreamWriter(outputStream);
    needClose=true;
  }
  transform._outputSource(writer);
  if (needClose)   writer.close();
  if (_configName != null) {
    File file=new File(fileName);
    String simpleName=file.getName();
    if (simpleName.toUpperCase().endsWith(""String_Node_Str"")) {
      String baseName=simpleName.substring(0,simpleName.length() - 5);
      CompilationUnit root=(CompilationUnit)transform._ast.getRoot();
      String className;
      if (root.getPackage() != null)       className=root.getPackage().getName().toString() + ""String_Node_Str"" + baseName;
 else       className=baseName;
      if (_prefix != null && _prefix.length() > 0)       className=className.substring(_prefix.length() + 1);
      _classes.add(className);
    }
  }
}"
75051,"/** 
 * Parse the command-line arguments starting from the given position. If one or more argument corresponds to an option, proper actions are performed to record that option. The position is adjusted to the next file name or option and returned.
 * @param args The command-line arguments.
 * @param position The starting position.
 * @return The new position.
 */
public static int parseArguments(String[] args,int position){
  String arg=args[position];
  if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    String classPaths=args[position];
    _extraClassPaths=classPaths.split(File.pathSeparator);
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _prefix=args[position];
    for (int i=0; i < RULES.length; i++)     if (RULES[i] instanceof PackageRule) {
      ((PackageRule)RULES[i]).setPrefix(_prefix);
      break;
    }
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _rootPath=args[position];
    if (_rootPath.length() == 0)     _rootPath=""String_Node_Str"";
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=true;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=false;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _configName=args[position];
    position++;
  }
  return position;
}","/** 
 * Parse the command-line arguments starting from the given position. If one or more argument corresponds to an option, proper actions are performed to record that option. The position is adjusted to the next file name or option and returned.
 * @param args The command-line arguments.
 * @param position The starting position.
 * @return The new position.
 */
public static int parseArguments(String[] args,int position){
  String arg=args[position];
  if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    String classPaths=args[position];
    _extraClassPaths=classPaths.split(File.pathSeparator);
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _prefix=args[position];
    for (int i=0; i < RULES.length; i++)     if (RULES[i] instanceof PackageRule) {
      ((PackageRule)RULES[i]).setPrefix(_prefix);
      break;
    }
    position++;
    _defaultToStandardOutput=false;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _rootPath=args[position];
    if (_rootPath.length() == 0)     _rootPath=""String_Node_Str"";
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=true;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=false;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _configName=args[position];
    position++;
  }
  return position;
}"
75052,"/** 
 * Find the first appearance of any of the given characters in a string.
 * @param s The string.
 * @param chars The array of characters.
 * @param startPos The starting position from which the search begins.
 * @return The index of the first appearance of any of the givencharacters in the string, or -1 if none of them is found.
 */
public static int indexOf(String s,char[] chars,int startPos){
  int pos=-1;
  for (int i=0; i < chars.length; i++) {
    int newPos=s.indexOf(chars[i],startPos);
    if (pos == -1 || newPos < pos)     pos=newPos;
  }
  return pos;
}","/** 
 * Find the first appearance of any of the given characters in a string.
 * @param s The string.
 * @param chars The array of characters.
 * @param startPos The starting position from which the search begins.
 * @return The index of the first appearance of any of the givencharacters in the string, or -1 if none of them is found.
 */
public static int indexOf(String s,char[] chars,int startPos){
  int pos=-1;
  for (int i=0; i < chars.length; i++) {
    int newPos=s.indexOf(chars[i],startPos);
    if (newPos != -1 && (pos == -1 || newPos < pos))     pos=newPos;
  }
  return pos;
}"
75053,"protected static void _outputConfig() throws Exception {
  if (_configName != null) {
    SourceOutputStream stream=SourceOutputStream.getStream(_configName,_overwrite);
    Set classSet=new HashSet();
    classSet.addAll(_classes);
    ConfigParser parser=new ConfigParser();
    parser.parseConfigFile(ConfigParser.DEFAULT_SYSTEM_ID,classSet);
    if (_prefix != null && _prefix.length() > 0)     parser.addPackagePrefix(_prefix,classSet);
    OutputStreamWriter writer=new OutputStreamWriter(stream);
    XmlOutput.outputXmlTree(parser.getTree(),writer);
    writer.close();
  }
}","protected static void _outputConfig() throws Exception {
  if (_configName != null) {
    SourceOutputStream stream=SourceOutputStream.getStream(_configName,_overwrite);
    Set classSet=new HashSet();
    classSet.addAll(_classes);
    ConfigParser parser=new ConfigParser();
    parser.addExcludedFile(new File(_configName).getCanonicalPath());
    parser.parseConfigFile(ConfigParser.DEFAULT_SYSTEM_ID,classSet);
    if (_prefix != null && _prefix.length() > 0)     parser.addPackagePrefix(_prefix,classSet);
    OutputStreamWriter writer=new OutputStreamWriter(stream);
    XmlOutput.outputXmlTree(parser.getTree(),writer);
    writer.close();
  }
}"
75054,"public void parseConfigFile(String fileName,Set includedClasses) throws Exception {
  XmlParser parser=new XmlParser();
  BufferedReader br=new BufferedReader(new FileReader(fileName));
  ConfigXmlHandler handler=new ConfigXmlHandler(_xmlTree,fileName,includedClasses);
  parser.setHandler(handler);
  parser.parse(fileName,null,br);
  _xmlTree.setElementName(""String_Node_Str"");
  _xmlTree.setAttribute(""String_Node_Str"",""String_Node_Str"");
  _xmlTree.setAttribute(""String_Node_Str"",""String_Node_Str"");
}","public void parseConfigFile(String fileName,Set includedClasses,boolean backtrackingElement) throws Exception {
  XmlParser parser=new XmlParser();
  BufferedReader br=new BufferedReader(new FileReader(fileName));
  ConfigXmlHandler handler=new ConfigXmlHandler(_xmlTree,fileName,includedClasses);
  handler.addExcludedFiles(_excludedFiles);
  parser.setHandler(handler);
  parser.parse(fileName,null,br);
  if (backtrackingElement) {
    _xmlTree.setElementName(""String_Node_Str"");
    _xmlTree.setAttribute(""String_Node_Str"",""String_Node_Str"");
    _xmlTree.setAttribute(""String_Node_Str"",""String_Node_Str"");
  }
}"
75055,"public void startElement(String elname) throws Exception {
  super.startElement(elname);
  if (elname.equals(""String_Node_Str"")) {
    String fileName=currentTree.getAttribute(""String_Node_Str"");
    try {
      String newName=PTOLEMY_PATH + fileName;
      File newFile=new File(newName);
      if (!newFile.exists()) {
        File oldFile=new File(systemId);
        newName=oldFile.getParent() + ""String_Node_Str"" + fileName;
      }
      ConfigParser subparser=new ConfigParser(currentTree);
      subparser.parseConfigFile(newName,includedClasses);
    }
 catch (    Exception e) {
    }
  }
}","public void startElement(String elname) throws Exception {
  super.startElement(elname);
  if (elname.equals(""String_Node_Str"")) {
    String fileName=currentTree.getAttribute(""String_Node_Str"");
    try {
      String newName=PathFinder.getPtolemyPath() + fileName;
      File newFile=new File(newName);
      if (!newFile.exists()) {
        File oldFile=new File(systemId);
        newName=oldFile.getParent() + ""String_Node_Str"" + fileName;
        newFile=new File(newName);
      }
      String canonicalPath=newFile.getCanonicalPath();
      if (!_excludedFiles.contains(canonicalPath)) {
        ConfigParser subparser=new ConfigParser(currentTree);
        subparser.addExcludedFiles(_excludedFiles);
        subparser.parseConfigFile(newName,includedClasses,false);
      }
    }
 catch (    Exception e) {
    }
  }
}"
75056,"public void processingInstruction(String target,String data) throws Exception {
  if (target.equals(""String_Node_Str"")) {
    StringReader dataReader=new StringReader(data);
    XmlParser newParser=new XmlParser();
    ConfigXmlHandler newHandler=new ConfigXmlHandler(currentTree,systemId,includedClasses);
    newParser.setHandler(newHandler);
    newParser.parse(systemId,null,dataReader);
    dataReader.close();
  }
}","public void processingInstruction(String target,String data) throws Exception {
  if (target.equals(""String_Node_Str"")) {
    StringReader dataReader=new StringReader(data);
    XmlParser newParser=new XmlParser();
    ConfigXmlHandler newHandler=new ConfigXmlHandler(currentTree,systemId,includedClasses);
    newHandler.addExcludedFiles(_excludedFiles);
    newParser.setHandler(newHandler);
    newParser.parse(systemId,null,dataReader);
    dataReader.close();
  }
}"
75057,"public Object resolveEntity(String publicId,String systemId) throws Exception {
  if (publicId != null && publicId.equals(MoMLParser.MoML_PUBLIC_ID_1)) {
    return new StringReader(MoMLParser.MoML_DTD_1);
  }
 else {
    return null;
  }
}","public Object resolveEntity(String publicId,String systemId) throws Exception {
  if (publicId != null && publicId.equals(MoML_PUBLIC_ID_1)) {
    return new StringReader(MoML_DTD_1);
  }
 else {
    return null;
  }
}"
75058,"/** 
 * Copy sourceURL to destinationFile without doing any byte conversion.
 * @param sourceURL The source URL
 * @param destinationFile The destination File.
 * @return true if the file was copied, false if the file was notcopied because the sourceURL and the destinationFile refer to the same file.
 * @exception IOException If the source file is not the same as thedestination file and the destination file does not exist.
 */
public static boolean binaryCopyURLToFile(URL sourceURL,File destinationFile) throws IOException {
  URL destinationURL=destinationFile.getCanonicalFile().toURL();
  if (sourceURL.sameFile(destinationURL)) {
    return false;
  }
  File sourceFile=new File(sourceURL.getFile());
  if (sourceFile.getPath().indexOf(""String_Node_Str"") != -1) {
    File canonicalFile=null;
    try {
      canonicalFile=sourceFile.getCanonicalFile();
      if (sourceFile.getCanonicalFile().toURL().sameFile(destinationURL)) {
        return false;
      }
    }
 catch (    IOException ex) {
      IOException ioException=new IOException(""String_Node_Str"" + sourceFile + ""String_Node_Str"");
      ioException.initCause(ex);
      throw ioException;
    }
  }
  BufferedInputStream input=null;
  try {
    input=new BufferedInputStream(sourceURL.openStream());
    BufferedOutputStream output=null;
    try {
      output=new BufferedOutputStream(new FileOutputStream(destinationFile));
      int c;
      while ((c=input.read()) != -1) {
        output.write(c);
      }
    }
  finally {
      if (output != null) {
        try {
          output.close();
        }
 catch (        Throwable throwable) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + destinationFile);
          throwable.printStackTrace();
        }
      }
    }
  }
  finally {
    if (input != null) {
      try {
        input.close();
      }
 catch (      Throwable throwable) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + sourceURL);
        throwable.printStackTrace();
      }
    }
  }
  return true;
}","/** 
 * Copy sourceURL to destinationFile without doing any byte conversion.
 * @param sourceURL The source URL
 * @param destinationFile The destination File.
 * @return true if the file was copied, false if the file was notcopied because the sourceURL and the destinationFile refer to the same file.
 * @exception IOException If the source file is not the same as thedestination file and the destination file does not exist.
 */
public static boolean binaryCopyURLToFile(URL sourceURL,File destinationFile) throws IOException {
  URL destinationURL=destinationFile.getCanonicalFile().toURL();
  if (sourceURL.sameFile(destinationURL)) {
    return false;
  }
  File sourceFile=new File(sourceURL.getFile());
  if (sourceFile.getPath().indexOf(""String_Node_Str"") == -1) {
    File canonicalFile=null;
    try {
      canonicalFile=sourceFile.getCanonicalFile();
      if (sourceFile.getCanonicalFile().toURL().sameFile(destinationURL)) {
        return false;
      }
    }
 catch (    IOException ex) {
      IOException ioException=new IOException(""String_Node_Str"" + sourceFile + ""String_Node_Str"");
      ioException.initCause(ex);
      throw ioException;
    }
  }
  BufferedInputStream input=null;
  try {
    input=new BufferedInputStream(sourceURL.openStream());
    BufferedOutputStream output=null;
    try {
      output=new BufferedOutputStream(new FileOutputStream(destinationFile));
      int c;
      while ((c=input.read()) != -1) {
        output.write(c);
      }
    }
  finally {
      if (output != null) {
        try {
          output.close();
        }
 catch (        Throwable throwable) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + destinationFile);
          throwable.printStackTrace();
        }
      }
    }
  }
  finally {
    if (input != null) {
      try {
        input.close();
      }
 catch (      Throwable throwable) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + sourceURL);
        throwable.printStackTrace();
      }
    }
  }
  return true;
}"
75059,"/** 
 * Create a restore method for a class, which restores all its state variables.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @param fieldNames The list of all the accessed fields.
 * @param fieldTypes The types corresponding to the accessed fields.
 * @param isAnonymous Whether the current class is anonymous.
 * @param isInterface Whether the current type is an interface.
 * @return The declaration of the method that restores the old valueof all the private fields.
 */
private MethodDeclaration _createRestoreMethod(AST ast,CompilationUnit root,TypeAnalyzerState state,List fieldNames,List fieldTypes,boolean isAnonymous,boolean isInterface){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  String methodName=_getRestoreMethodName(isAnonymous);
  if (hasMethod(currentClass,methodName,new Class[]{int.class,boolean.class},true))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  MethodDeclaration method=ast.newMethodDeclaration();
  method.setName(ast.newSimpleName(methodName));
  SingleVariableDeclaration timestamp=ast.newSingleVariableDeclaration();
  timestamp.setType(ast.newPrimitiveType(PrimitiveType.LONG));
  timestamp.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(timestamp);
  SingleVariableDeclaration trim=ast.newSingleVariableDeclaration();
  trim.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
  trim.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(trim);
  if (!isInterface) {
    Block body=ast.newBlock();
    method.setBody(body);
    Iterator namesIter=fieldNames.iterator();
    Iterator typesIter=fieldTypes.iterator();
    while (namesIter.hasNext()) {
      String fieldName=(String)namesIter.next();
      Type fieldType=(Type)typesIter.next();
      MethodInvocation restoreMethodCall=ast.newMethodInvocation();
      restoreMethodCall.setExpression(ast.newSimpleName(_getRecordName(fieldName)));
      restoreMethodCall.arguments().add(ast.newSimpleName(fieldName));
      restoreMethodCall.setName(ast.newSimpleName(""String_Node_Str""));
      restoreMethodCall.arguments().add(ast.newSimpleName(""String_Node_Str""));
      restoreMethodCall.arguments().add(ast.newSimpleName(""String_Node_Str""));
      boolean isFinal=false;
      try {
        Field field=currentClass.getDeclaredField(fieldName);
        if (java.lang.reflect.Modifier.isFinal(field.getModifiers()))         isFinal=true;
      }
 catch (      NoSuchFieldException e) {
      }
      if (isFinal) {
        if (_getAccessedField(currentClass.getName(),fieldName) != null || !Type.isPrimitive(Type.getElementType(fieldType.getName())))         body.statements().add(ast.newExpressionStatement(restoreMethodCall));
      }
 else {
        Expression rightHandSide;
        if (fieldType.isPrimitive())         rightHandSide=restoreMethodCall;
 else {
          CastExpression castExpression=ast.newCastExpression();
          String typeName=getClassName(fieldType.getName(),state,root);
          castExpression.setType(createType(ast,typeName));
          castExpression.setExpression(restoreMethodCall);
          rightHandSide=castExpression;
        }
        Assignment assignment=ast.newAssignment();
        assignment.setLeftHandSide(ast.newSimpleName(fieldName));
        assignment.setRightHandSide(rightHandSide);
        body.statements().add(ast.newExpressionStatement(assignment));
      }
    }
    SuperMethodInvocation superRestore=ast.newSuperMethodInvocation();
    superRestore.setName(ast.newSimpleName(_getRestoreMethodName(false)));
    superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
    superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
    Statement superRestoreStatement=ast.newExpressionStatement(superRestore);
    if (parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName()) || hasMethod(parent,methodName,new Class[]{int.class,boolean.class})))     body.statements().add(superRestoreStatement);
 else {
      IfStatement restoreCheckpoint=ast.newIfStatement();
      InfixExpression timestampTester=ast.newInfixExpression();
      timestampTester.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
      timestampTester.setOperator(InfixExpression.Operator.LESS_EQUALS);
      MethodInvocation topTimestamp=ast.newMethodInvocation();
      topTimestamp.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
      topTimestamp.setName(ast.newSimpleName(""String_Node_Str""));
      timestampTester.setRightOperand(topTimestamp);
      restoreCheckpoint.setExpression(timestampTester);
      Block restoreBlock=ast.newBlock();
      restoreCheckpoint.setThenStatement(restoreBlock);
      Assignment assignCheckpoint=ast.newAssignment();
      assignCheckpoint.setLeftHandSide(ast.newSimpleName(CHECKPOINT_NAME));
      MethodInvocation restoreCheckpointInvocation=ast.newMethodInvocation();
      restoreCheckpointInvocation.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
      restoreCheckpointInvocation.setName(ast.newSimpleName(""String_Node_Str""));
      restoreCheckpointInvocation.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
      restoreCheckpointInvocation.arguments().add(_createRollbackableObject(ast,isAnonymous));
      restoreCheckpointInvocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
      restoreCheckpointInvocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
      assignCheckpoint.setRightHandSide(restoreCheckpointInvocation);
      restoreBlock.statements().add(ast.newExpressionStatement(assignCheckpoint));
      MethodInvocation popStates=ast.newMethodInvocation();
      String recordType=getClassName(FieldRecord.class,state,root);
      popStates.setExpression(createName(ast,recordType));
      popStates.setName(ast.newSimpleName(""String_Node_Str""));
      popStates.arguments().add(ast.newSimpleName(RECORDS_NAME));
      restoreBlock.statements().add(ast.newExpressionStatement(popStates));
      body.statements().add(restoreCheckpoint);
      if (parent != null)       addToLists(_nodeSubstitution,parent.getName(),new NodeReplace(restoreCheckpoint,superRestoreStatement));
    }
  }
  method.setModifiers(Modifier.PUBLIC);
  return method;
}","/** 
 * Create a restore method for a class, which restores all its state variables.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @param fieldNames The list of all the accessed fields.
 * @param fieldTypes The types corresponding to the accessed fields.
 * @param isAnonymous Whether the current class is anonymous.
 * @param isInterface Whether the current type is an interface.
 * @return The declaration of the method that restores the old valueof all the private fields.
 */
private MethodDeclaration _createRestoreMethod(AST ast,CompilationUnit root,TypeAnalyzerState state,List fieldNames,List fieldTypes,boolean isAnonymous,boolean isInterface){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  String methodName=_getRestoreMethodName(isAnonymous);
  if (hasMethod(currentClass,methodName,new Class[]{int.class,boolean.class},true))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  MethodDeclaration method=ast.newMethodDeclaration();
  method.setName(ast.newSimpleName(methodName));
  SingleVariableDeclaration timestamp=ast.newSingleVariableDeclaration();
  timestamp.setType(ast.newPrimitiveType(PrimitiveType.LONG));
  timestamp.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(timestamp);
  SingleVariableDeclaration trim=ast.newSingleVariableDeclaration();
  trim.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
  trim.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(trim);
  if (!isInterface) {
    Block body=ast.newBlock();
    method.setBody(body);
    Iterator namesIter=fieldNames.iterator();
    Iterator typesIter=fieldTypes.iterator();
    while (namesIter.hasNext()) {
      String fieldName=(String)namesIter.next();
      Type fieldType=(Type)typesIter.next();
      MethodInvocation restoreMethodCall=ast.newMethodInvocation();
      restoreMethodCall.setExpression(ast.newSimpleName(_getRecordName(fieldName)));
      restoreMethodCall.arguments().add(ast.newSimpleName(fieldName));
      restoreMethodCall.setName(ast.newSimpleName(""String_Node_Str""));
      restoreMethodCall.arguments().add(ast.newSimpleName(""String_Node_Str""));
      restoreMethodCall.arguments().add(ast.newSimpleName(""String_Node_Str""));
      boolean isFinal=false;
      try {
        Field field=currentClass.getDeclaredField(fieldName);
        if (java.lang.reflect.Modifier.isFinal(field.getModifiers()))         isFinal=true;
      }
 catch (      NoSuchFieldException e) {
      }
      if (isFinal) {
        if (_getAccessedField(currentClass.getName(),fieldName) != null || !Type.isPrimitive(Type.getElementType(fieldType.getName())))         body.statements().add(ast.newExpressionStatement(restoreMethodCall));
      }
 else {
        Expression rightHandSide;
        if (fieldType.isPrimitive())         rightHandSide=restoreMethodCall;
 else {
          CastExpression castExpression=ast.newCastExpression();
          String typeName=getClassName(fieldType.getName(),state,root);
          castExpression.setType(createType(ast,typeName));
          castExpression.setExpression(restoreMethodCall);
          rightHandSide=castExpression;
        }
        Assignment assignment=ast.newAssignment();
        assignment.setLeftHandSide(ast.newSimpleName(fieldName));
        assignment.setRightHandSide(rightHandSide);
        body.statements().add(ast.newExpressionStatement(assignment));
      }
    }
    SuperMethodInvocation superRestore=ast.newSuperMethodInvocation();
    superRestore.setName(ast.newSimpleName(_getRestoreMethodName(false)));
    superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
    superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
    Statement superRestoreStatement=ast.newExpressionStatement(superRestore);
    if (parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName()) || hasMethod(parent,methodName,new Class[]{int.class,boolean.class})))     body.statements().add(superRestoreStatement);
 else {
      IfStatement restoreCheckpoint=ast.newIfStatement();
      InfixExpression timestampTester=ast.newInfixExpression();
      timestampTester.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
      timestampTester.setOperator(InfixExpression.Operator.LESS_EQUALS);
      MethodInvocation topTimestamp=ast.newMethodInvocation();
      topTimestamp.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
      topTimestamp.setName(ast.newSimpleName(""String_Node_Str""));
      timestampTester.setRightOperand(topTimestamp);
      restoreCheckpoint.setExpression(timestampTester);
      Block restoreBlock=ast.newBlock();
      restoreCheckpoint.setThenStatement(restoreBlock);
      Assignment assignCheckpoint=ast.newAssignment();
      assignCheckpoint.setLeftHandSide(ast.newSimpleName(CHECKPOINT_NAME));
      MethodInvocation restoreCheckpointInvocation=ast.newMethodInvocation();
      restoreCheckpointInvocation.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
      restoreCheckpointInvocation.setName(ast.newSimpleName(""String_Node_Str""));
      restoreCheckpointInvocation.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
      restoreCheckpointInvocation.arguments().add(_createRollbackableObject(ast,isAnonymous));
      restoreCheckpointInvocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
      restoreCheckpointInvocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
      assignCheckpoint.setRightHandSide(restoreCheckpointInvocation);
      restoreBlock.statements().add(ast.newExpressionStatement(assignCheckpoint));
      MethodInvocation popStates=ast.newMethodInvocation();
      String recordType=getClassName(FieldRecord.class,state,root);
      popStates.setExpression(createName(ast,recordType));
      popStates.setName(ast.newSimpleName(""String_Node_Str""));
      popStates.arguments().add(ast.newSimpleName(RECORDS_NAME));
      restoreBlock.statements().add(ast.newExpressionStatement(popStates));
      MethodInvocation recursion=ast.newMethodInvocation();
      recursion.setName(ast.newSimpleName(methodName));
      recursion.arguments().add(ast.newSimpleName(""String_Node_Str""));
      recursion.arguments().add(ast.newSimpleName(""String_Node_Str""));
      restoreBlock.statements().add(ast.newExpressionStatement(recursion));
      body.statements().add(restoreCheckpoint);
      if (parent != null)       addToLists(_nodeSubstitution,parent.getName(),new NodeReplace(restoreCheckpoint,superRestoreStatement));
    }
  }
  method.setModifiers(Modifier.PUBLIC);
  return method;
}"
75060,"public void $RESTORE(long timestamp,boolean trim){
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
    FieldRecord.popState($RECORDS);
  }
}","public void $RESTORE(long timestamp,boolean trim){
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
    FieldRecord.popState($RECORDS);
    $RESTORE(timestamp,trim);
  }
}"
75061,"public void $RESTORE_ANONYMOUS(long timestamp,boolean trim){
  $RECORD$i.restore(i,timestamp,trim);
  position=$RECORD$position.restore(position,timestamp,trim);
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
    FieldRecord.popState($RECORDS);
  }
}","public void $RESTORE_ANONYMOUS(long timestamp,boolean trim){
  $RECORD$i.restore(i,timestamp,trim);
  position=$RECORD$position.restore(position,timestamp,trim);
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
    FieldRecord.popState($RECORDS);
    $RESTORE_ANONYMOUS(timestamp,trim);
  }
}"
75062,"public ListIterator listIterator(final int index){
  checkMod();
  checkBoundsInclusive(index);
  return new ListIterator(){
    private final ListIterator i=backingList.listIterator(index + offset);
    private int position=index;
    public boolean hasNext(){
      checkMod();
      return position < size;
    }
    public boolean hasPrevious(){
      checkMod();
      return position > 0;
    }
    public Object next(){
      if (position == size)       throw new NoSuchElementException();
      $ASSIGN$SPECIAL$position(11,position);
      return i.next();
    }
    public Object previous(){
      if (position == 0)       throw new NoSuchElementException();
      $ASSIGN$SPECIAL$position(12,position);
      return i.previous();
    }
    public int nextIndex(){
      return i.nextIndex() - offset;
    }
    public int previousIndex(){
      return i.previousIndex() - offset;
    }
    public void remove(){
      i.remove();
      $ASSIGN$SPECIAL$size(12,size);
      $ASSIGN$position(nextIndex());
      setModCount(backingList.getModCount());
    }
    public void set(    Object o){
      i.set(o);
    }
    public void add(    Object o){
      i.add(o);
      $ASSIGN$SPECIAL$size(11,size);
      $ASSIGN$SPECIAL$position(11,position);
      setModCount(backingList.getModCount());
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    private final int $ASSIGN$position(    int newValue){
      if ($CHECKPOINT != null && $CHECKPOINT.getTimestamp() > 0) {
        $RECORD$position.add(null,position,$CHECKPOINT.getTimestamp());
      }
      return position=newValue;
    }
    private final int $ASSIGN$SPECIAL$position(    int operator,    long newValue){
      if ($CHECKPOINT != null && $CHECKPOINT.getTimestamp() > 0) {
        $RECORD$position.add(null,position,$CHECKPOINT.getTimestamp());
      }
switch (operator) {
case 0:
        return position+=newValue;
case 1:
      return position-=newValue;
case 2:
    return position*=newValue;
case 3:
  return position/=newValue;
case 4:
return position&=newValue;
case 5:
return position|=newValue;
case 6:
return position^=newValue;
case 7:
return position%=newValue;
case 8:
return position<<=newValue;
case 9:
return position>>=newValue;
case 10:
return position>>>=newValue;
case 11:
return position++;
case 12:
return position--;
case 13:
return ++position;
case 14:
return --position;
default :
return position;
}
}
public void $COMMIT_ANONYMOUS(long timestamp){
FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
$RECORD$$CHECKPOINT.commit(timestamp);
}
public void $RESTORE_ANONYMOUS(long timestamp,boolean trim){
$RECORD$i.restore(i,timestamp,trim);
position=$RECORD$position.restore(position,timestamp,trim);
if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
$CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
FieldRecord.popState($RECORDS);
}
}
public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
return $CHECKPOINT;
}
public final Object $SET$CHECKPOINT_ANONYMOUS(Checkpoint checkpoint){
if ($CHECKPOINT != checkpoint) {
Checkpoint oldCheckpoint=$CHECKPOINT;
if (checkpoint != null) {
$RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
FieldRecord.pushState($RECORDS);
}
$CHECKPOINT=checkpoint;
oldCheckpoint.setCheckpoint(checkpoint);
checkpoint.addObject(new _PROXY_());
}
return this;
}
private FieldRecord $RECORD$i=new FieldRecord(0);
private FieldRecord $RECORD$position=new FieldRecord(0);
private FieldRecord[] $RECORDS=new FieldRecord[]{$RECORD$i,$RECORD$position};
{
$CHECKPOINT.addObject(new _PROXY_());
}
}
;
}","public ListIterator listIterator(final int index){
  checkMod();
  checkBoundsInclusive(index);
  return new ListIterator(){
    private final ListIterator i=backingList.listIterator(index + offset);
    private int position=index;
    public boolean hasNext(){
      checkMod();
      return position < size;
    }
    public boolean hasPrevious(){
      checkMod();
      return position > 0;
    }
    public Object next(){
      if (position == size)       throw new NoSuchElementException();
      $ASSIGN$SPECIAL$position(11,position);
      return i.next();
    }
    public Object previous(){
      if (position == 0)       throw new NoSuchElementException();
      $ASSIGN$SPECIAL$position(12,position);
      return i.previous();
    }
    public int nextIndex(){
      return i.nextIndex() - offset;
    }
    public int previousIndex(){
      return i.previousIndex() - offset;
    }
    public void remove(){
      i.remove();
      $ASSIGN$SPECIAL$size(12,size);
      $ASSIGN$position(nextIndex());
      setModCount(backingList.getModCount());
    }
    public void set(    Object o){
      i.set(o);
    }
    public void add(    Object o){
      i.add(o);
      $ASSIGN$SPECIAL$size(11,size);
      $ASSIGN$SPECIAL$position(11,position);
      setModCount(backingList.getModCount());
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    private final int $ASSIGN$position(    int newValue){
      if ($CHECKPOINT != null && $CHECKPOINT.getTimestamp() > 0) {
        $RECORD$position.add(null,position,$CHECKPOINT.getTimestamp());
      }
      return position=newValue;
    }
    private final int $ASSIGN$SPECIAL$position(    int operator,    long newValue){
      if ($CHECKPOINT != null && $CHECKPOINT.getTimestamp() > 0) {
        $RECORD$position.add(null,position,$CHECKPOINT.getTimestamp());
      }
switch (operator) {
case 0:
        return position+=newValue;
case 1:
      return position-=newValue;
case 2:
    return position*=newValue;
case 3:
  return position/=newValue;
case 4:
return position&=newValue;
case 5:
return position|=newValue;
case 6:
return position^=newValue;
case 7:
return position%=newValue;
case 8:
return position<<=newValue;
case 9:
return position>>=newValue;
case 10:
return position>>>=newValue;
case 11:
return position++;
case 12:
return position--;
case 13:
return ++position;
case 14:
return --position;
default :
return position;
}
}
public void $COMMIT_ANONYMOUS(long timestamp){
FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
$RECORD$$CHECKPOINT.commit(timestamp);
}
public void $RESTORE_ANONYMOUS(long timestamp,boolean trim){
$RECORD$i.restore(i,timestamp,trim);
position=$RECORD$position.restore(position,timestamp,trim);
if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
$CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
FieldRecord.popState($RECORDS);
$RESTORE_ANONYMOUS(timestamp,trim);
}
}
public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
return $CHECKPOINT;
}
public final Object $SET$CHECKPOINT_ANONYMOUS(Checkpoint checkpoint){
if ($CHECKPOINT != checkpoint) {
Checkpoint oldCheckpoint=$CHECKPOINT;
if (checkpoint != null) {
$RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
FieldRecord.pushState($RECORDS);
}
$CHECKPOINT=checkpoint;
oldCheckpoint.setCheckpoint(checkpoint);
checkpoint.addObject(new _PROXY_());
}
return this;
}
private FieldRecord $RECORD$i=new FieldRecord(0);
private FieldRecord $RECORD$position=new FieldRecord(0);
private FieldRecord[] $RECORDS=new FieldRecord[]{$RECORD$i,$RECORD$position};
{
$CHECKPOINT.addObject(new _PROXY_());
}
}
;
}"
75063,"public Collection values(){
  if (values == null)   $ASSIGN$values(new AbstractCollection(){
    public int size(){
      return AbstractMap.this.size();
    }
    public boolean contains(    Object value){
      return containsValue(value);
    }
    public Iterator iterator(){
      return new Iterator(){
        private final Iterator map_iterator=entrySet().iterator();
        public boolean hasNext(){
          return map_iterator.hasNext();
        }
        public Object next(){
          return ((Map.Entry)map_iterator.next()).getValue();
        }
        public void remove(){
          map_iterator.remove();
        }
final class _PROXY_ implements Rollbackable {
          public final void $COMMIT(          long timestamp){
            $COMMIT_ANONYMOUS(timestamp);
          }
          public final void $RESTORE(          long timestamp,          boolean trim){
            $RESTORE_ANONYMOUS(timestamp,trim);
          }
          public final Checkpoint $GET$CHECKPOINT(){
            return $GET$CHECKPOINT_ANONYMOUS();
          }
          public final Object $SET$CHECKPOINT(          Checkpoint checkpoint){
            $SET$CHECKPOINT_ANONYMOUS(checkpoint);
            return this;
          }
        }
        public void $COMMIT_ANONYMOUS(        long timestamp){
          FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
          $RECORD$$CHECKPOINT.commit(timestamp);
        }
        public void $RESTORE_ANONYMOUS(        long timestamp,        boolean trim){
          $RECORD$map_iterator.restore(map_iterator,timestamp,trim);
          if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
            $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
            FieldRecord.popState($RECORDS);
          }
        }
        public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
          return $CHECKPOINT;
        }
        public final Object $SET$CHECKPOINT_ANONYMOUS(        Checkpoint checkpoint){
          if ($CHECKPOINT != checkpoint) {
            Checkpoint oldCheckpoint=$CHECKPOINT;
            if (checkpoint != null) {
              $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
              FieldRecord.pushState($RECORDS);
            }
            $CHECKPOINT=checkpoint;
            oldCheckpoint.setCheckpoint(checkpoint);
            checkpoint.addObject(new _PROXY_());
          }
          return this;
        }
        private FieldRecord $RECORD$map_iterator=new FieldRecord(0);
        private FieldRecord[] $RECORDS=new FieldRecord[]{$RECORD$map_iterator};
{
          $CHECKPOINT.addObject(new _PROXY_());
        }
      }
;
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    public void $COMMIT_ANONYMOUS(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      super.$COMMIT(timestamp);
    }
    public void $RESTORE_ANONYMOUS(    long timestamp,    boolean trim){
      super.$RESTORE(timestamp,trim);
    }
    public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT_ANONYMOUS(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(new _PROXY_());
      }
      return this;
    }
    private FieldRecord[] $RECORDS=new FieldRecord[]{};
{
      $CHECKPOINT.addObject(new _PROXY_());
    }
  }
);
  return values;
}","public Collection values(){
  if (values == null)   $ASSIGN$values(new AbstractCollection(){
    public int size(){
      return AbstractMap.this.size();
    }
    public boolean contains(    Object value){
      return containsValue(value);
    }
    public Iterator iterator(){
      return new Iterator(){
        private final Iterator map_iterator=entrySet().iterator();
        public boolean hasNext(){
          return map_iterator.hasNext();
        }
        public Object next(){
          return ((Map.Entry)map_iterator.next()).getValue();
        }
        public void remove(){
          map_iterator.remove();
        }
final class _PROXY_ implements Rollbackable {
          public final void $COMMIT(          long timestamp){
            $COMMIT_ANONYMOUS(timestamp);
          }
          public final void $RESTORE(          long timestamp,          boolean trim){
            $RESTORE_ANONYMOUS(timestamp,trim);
          }
          public final Checkpoint $GET$CHECKPOINT(){
            return $GET$CHECKPOINT_ANONYMOUS();
          }
          public final Object $SET$CHECKPOINT(          Checkpoint checkpoint){
            $SET$CHECKPOINT_ANONYMOUS(checkpoint);
            return this;
          }
        }
        public void $COMMIT_ANONYMOUS(        long timestamp){
          FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
          $RECORD$$CHECKPOINT.commit(timestamp);
        }
        public void $RESTORE_ANONYMOUS(        long timestamp,        boolean trim){
          $RECORD$map_iterator.restore(map_iterator,timestamp,trim);
          if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
            $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
            FieldRecord.popState($RECORDS);
            $RESTORE_ANONYMOUS(timestamp,trim);
          }
        }
        public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
          return $CHECKPOINT;
        }
        public final Object $SET$CHECKPOINT_ANONYMOUS(        Checkpoint checkpoint){
          if ($CHECKPOINT != checkpoint) {
            Checkpoint oldCheckpoint=$CHECKPOINT;
            if (checkpoint != null) {
              $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
              FieldRecord.pushState($RECORDS);
            }
            $CHECKPOINT=checkpoint;
            oldCheckpoint.setCheckpoint(checkpoint);
            checkpoint.addObject(new _PROXY_());
          }
          return this;
        }
        private FieldRecord $RECORD$map_iterator=new FieldRecord(0);
        private FieldRecord[] $RECORDS=new FieldRecord[]{$RECORD$map_iterator};
{
          $CHECKPOINT.addObject(new _PROXY_());
        }
      }
;
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    public void $COMMIT_ANONYMOUS(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      super.$COMMIT(timestamp);
    }
    public void $RESTORE_ANONYMOUS(    long timestamp,    boolean trim){
      super.$RESTORE(timestamp,trim);
    }
    public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT_ANONYMOUS(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(new _PROXY_());
      }
      return this;
    }
    private FieldRecord[] $RECORDS=new FieldRecord[]{};
{
      $CHECKPOINT.addObject(new _PROXY_());
    }
  }
);
  return values;
}"
75064,"public Iterator iterator(){
  return new Iterator(){
    private final Iterator map_iterator=entrySet().iterator();
    public boolean hasNext(){
      return map_iterator.hasNext();
    }
    public Object next(){
      return ((Map.Entry)map_iterator.next()).getValue();
    }
    public void remove(){
      map_iterator.remove();
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    public void $COMMIT_ANONYMOUS(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      $RECORD$$CHECKPOINT.commit(timestamp);
    }
    public void $RESTORE_ANONYMOUS(    long timestamp,    boolean trim){
      $RECORD$map_iterator.restore(map_iterator,timestamp,trim);
      if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
        $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
        FieldRecord.popState($RECORDS);
      }
    }
    public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT_ANONYMOUS(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(new _PROXY_());
      }
      return this;
    }
    private FieldRecord $RECORD$map_iterator=new FieldRecord(0);
    private FieldRecord[] $RECORDS=new FieldRecord[]{$RECORD$map_iterator};
{
      $CHECKPOINT.addObject(new _PROXY_());
    }
  }
;
}","public Iterator iterator(){
  return new Iterator(){
    private final Iterator map_iterator=entrySet().iterator();
    public boolean hasNext(){
      return map_iterator.hasNext();
    }
    public Object next(){
      return ((Map.Entry)map_iterator.next()).getValue();
    }
    public void remove(){
      map_iterator.remove();
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    public void $COMMIT_ANONYMOUS(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      $RECORD$$CHECKPOINT.commit(timestamp);
    }
    public void $RESTORE_ANONYMOUS(    long timestamp,    boolean trim){
      $RECORD$map_iterator.restore(map_iterator,timestamp,trim);
      if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
        $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
        FieldRecord.popState($RECORDS);
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
    }
    public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT_ANONYMOUS(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(new _PROXY_());
      }
      return this;
    }
    private FieldRecord $RECORD$map_iterator=new FieldRecord(0);
    private FieldRecord[] $RECORDS=new FieldRecord[]{$RECORD$map_iterator};
{
      $CHECKPOINT.addObject(new _PROXY_());
    }
  }
;
}"
75065,"public Set keySet(){
  if (keys == null)   $ASSIGN$keys(new AbstractSet(){
    public int size(){
      return AbstractMap.this.size();
    }
    public boolean contains(    Object key){
      return containsKey(key);
    }
    public Iterator iterator(){
      return new Iterator(){
        private final Iterator map_iterator=entrySet().iterator();
        public boolean hasNext(){
          return map_iterator.hasNext();
        }
        public Object next(){
          return ((Map.Entry)map_iterator.next()).getKey();
        }
        public void remove(){
          map_iterator.remove();
        }
final class _PROXY_ implements Rollbackable {
          public final void $COMMIT(          long timestamp){
            $COMMIT_ANONYMOUS(timestamp);
          }
          public final void $RESTORE(          long timestamp,          boolean trim){
            $RESTORE_ANONYMOUS(timestamp,trim);
          }
          public final Checkpoint $GET$CHECKPOINT(){
            return $GET$CHECKPOINT_ANONYMOUS();
          }
          public final Object $SET$CHECKPOINT(          Checkpoint checkpoint){
            $SET$CHECKPOINT_ANONYMOUS(checkpoint);
            return this;
          }
        }
        public void $COMMIT_ANONYMOUS(        long timestamp){
          FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
          $RECORD$$CHECKPOINT.commit(timestamp);
        }
        public void $RESTORE_ANONYMOUS(        long timestamp,        boolean trim){
          $RECORD$map_iterator.restore(map_iterator,timestamp,trim);
          if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
            $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
            FieldRecord.popState($RECORDS);
          }
        }
        public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
          return $CHECKPOINT;
        }
        public final Object $SET$CHECKPOINT_ANONYMOUS(        Checkpoint checkpoint){
          if ($CHECKPOINT != checkpoint) {
            Checkpoint oldCheckpoint=$CHECKPOINT;
            if (checkpoint != null) {
              $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
              FieldRecord.pushState($RECORDS);
            }
            $CHECKPOINT=checkpoint;
            oldCheckpoint.setCheckpoint(checkpoint);
            checkpoint.addObject(new _PROXY_());
          }
          return this;
        }
        private FieldRecord $RECORD$map_iterator=new FieldRecord(0);
        private FieldRecord[] $RECORDS=new FieldRecord[]{$RECORD$map_iterator};
{
          $CHECKPOINT.addObject(new _PROXY_());
        }
      }
;
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    public void $COMMIT_ANONYMOUS(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      super.$COMMIT(timestamp);
    }
    public void $RESTORE_ANONYMOUS(    long timestamp,    boolean trim){
      super.$RESTORE(timestamp,trim);
    }
    public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT_ANONYMOUS(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(new _PROXY_());
      }
      return this;
    }
    private FieldRecord[] $RECORDS=new FieldRecord[]{};
{
      $CHECKPOINT.addObject(new _PROXY_());
    }
  }
);
  return keys;
}","public Set keySet(){
  if (keys == null)   $ASSIGN$keys(new AbstractSet(){
    public int size(){
      return AbstractMap.this.size();
    }
    public boolean contains(    Object key){
      return containsKey(key);
    }
    public Iterator iterator(){
      return new Iterator(){
        private final Iterator map_iterator=entrySet().iterator();
        public boolean hasNext(){
          return map_iterator.hasNext();
        }
        public Object next(){
          return ((Map.Entry)map_iterator.next()).getKey();
        }
        public void remove(){
          map_iterator.remove();
        }
final class _PROXY_ implements Rollbackable {
          public final void $COMMIT(          long timestamp){
            $COMMIT_ANONYMOUS(timestamp);
          }
          public final void $RESTORE(          long timestamp,          boolean trim){
            $RESTORE_ANONYMOUS(timestamp,trim);
          }
          public final Checkpoint $GET$CHECKPOINT(){
            return $GET$CHECKPOINT_ANONYMOUS();
          }
          public final Object $SET$CHECKPOINT(          Checkpoint checkpoint){
            $SET$CHECKPOINT_ANONYMOUS(checkpoint);
            return this;
          }
        }
        public void $COMMIT_ANONYMOUS(        long timestamp){
          FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
          $RECORD$$CHECKPOINT.commit(timestamp);
        }
        public void $RESTORE_ANONYMOUS(        long timestamp,        boolean trim){
          $RECORD$map_iterator.restore(map_iterator,timestamp,trim);
          if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
            $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,new _PROXY_(),timestamp,trim);
            FieldRecord.popState($RECORDS);
            $RESTORE_ANONYMOUS(timestamp,trim);
          }
        }
        public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
          return $CHECKPOINT;
        }
        public final Object $SET$CHECKPOINT_ANONYMOUS(        Checkpoint checkpoint){
          if ($CHECKPOINT != checkpoint) {
            Checkpoint oldCheckpoint=$CHECKPOINT;
            if (checkpoint != null) {
              $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
              FieldRecord.pushState($RECORDS);
            }
            $CHECKPOINT=checkpoint;
            oldCheckpoint.setCheckpoint(checkpoint);
            checkpoint.addObject(new _PROXY_());
          }
          return this;
        }
        private FieldRecord $RECORD$map_iterator=new FieldRecord(0);
        private FieldRecord[] $RECORDS=new FieldRecord[]{$RECORD$map_iterator};
{
          $CHECKPOINT.addObject(new _PROXY_());
        }
      }
;
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    public void $COMMIT_ANONYMOUS(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      super.$COMMIT(timestamp);
    }
    public void $RESTORE_ANONYMOUS(    long timestamp,    boolean trim){
      super.$RESTORE(timestamp,trim);
    }
    public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT_ANONYMOUS(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(new _PROXY_());
      }
      return this;
    }
    private FieldRecord[] $RECORDS=new FieldRecord[]{};
{
      $CHECKPOINT.addObject(new _PROXY_());
    }
  }
);
  return keys;
}"
75066,"public void $RESTORE(long timestamp,boolean trim){
  keys=(Set)$RECORD$keys.restore(keys,timestamp,trim);
  values=(Collection)$RECORD$values.restore(values,timestamp,trim);
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
    FieldRecord.popState($RECORDS);
  }
}","public void $RESTORE(long timestamp,boolean trim){
  keys=(Set)$RECORD$keys.restore(keys,timestamp,trim);
  values=(Collection)$RECORD$values.restore(values,timestamp,trim);
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
    FieldRecord.popState($RECORDS);
    $RESTORE(timestamp,trim);
  }
}"
75067,"public Iterator iterator(){
  return new UnmodifiableIterator(c.iterator()){
    public Object next(){
      final Map.Entry e=(Map.Entry)super.next();
      return new Map.Entry(){
        protected Checkpoint $CHECKPOINT=new Checkpoint(this);
        public boolean equals(        Object o){
          return e.equals(o);
        }
        public Object getKey(){
          return e.getKey();
        }
        public Object getValue(){
          return e.getValue();
        }
        public int hashCode(){
          return e.hashCode();
        }
        public Object setValue(        Object value){
          throw new UnsupportedOperationException();
        }
        public String toString(){
          return e.toString();
        }
        public void $COMMIT(        long timestamp){
          FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
          $RECORD$$CHECKPOINT.commit(timestamp);
        }
        public void $RESTORE(        long timestamp,        boolean trim){
          if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
            $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
            FieldRecord.popState($RECORDS);
          }
        }
        public final Checkpoint $GET$CHECKPOINT(){
          return $CHECKPOINT;
        }
        public final Object $SET$CHECKPOINT(        Checkpoint checkpoint){
          if ($CHECKPOINT != checkpoint) {
            Checkpoint oldCheckpoint=$CHECKPOINT;
            if (checkpoint != null) {
              $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
              FieldRecord.pushState($RECORDS);
            }
            $CHECKPOINT=checkpoint;
            oldCheckpoint.setCheckpoint(checkpoint);
            checkpoint.addObject(this);
          }
          return this;
        }
        protected CheckpointRecord $RECORD$$CHECKPOINT=new CheckpointRecord();
        private FieldRecord[] $RECORDS=new FieldRecord[]{};
      }
;
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    public void $COMMIT_ANONYMOUS(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      super.$COMMIT(timestamp);
    }
    public void $RESTORE_ANONYMOUS(    long timestamp,    boolean trim){
      super.$RESTORE(timestamp,trim);
    }
    public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT_ANONYMOUS(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(new _PROXY_());
      }
      return this;
    }
    private FieldRecord[] $RECORDS=new FieldRecord[]{};
{
      $CHECKPOINT.addObject(new _PROXY_());
    }
  }
;
}","public Iterator iterator(){
  return new UnmodifiableIterator(c.iterator()){
    public Object next(){
      final Map.Entry e=(Map.Entry)super.next();
      return new Map.Entry(){
        protected Checkpoint $CHECKPOINT=new Checkpoint(this);
        public boolean equals(        Object o){
          return e.equals(o);
        }
        public Object getKey(){
          return e.getKey();
        }
        public Object getValue(){
          return e.getValue();
        }
        public int hashCode(){
          return e.hashCode();
        }
        public Object setValue(        Object value){
          throw new UnsupportedOperationException();
        }
        public String toString(){
          return e.toString();
        }
        public void $COMMIT(        long timestamp){
          FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
          $RECORD$$CHECKPOINT.commit(timestamp);
        }
        public void $RESTORE(        long timestamp,        boolean trim){
          if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
            $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
            FieldRecord.popState($RECORDS);
            $RESTORE(timestamp,trim);
          }
        }
        public final Checkpoint $GET$CHECKPOINT(){
          return $CHECKPOINT;
        }
        public final Object $SET$CHECKPOINT(        Checkpoint checkpoint){
          if ($CHECKPOINT != checkpoint) {
            Checkpoint oldCheckpoint=$CHECKPOINT;
            if (checkpoint != null) {
              $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
              FieldRecord.pushState($RECORDS);
            }
            $CHECKPOINT=checkpoint;
            oldCheckpoint.setCheckpoint(checkpoint);
            checkpoint.addObject(this);
          }
          return this;
        }
        protected CheckpointRecord $RECORD$$CHECKPOINT=new CheckpointRecord();
        private FieldRecord[] $RECORDS=new FieldRecord[]{};
      }
;
    }
final class _PROXY_ implements Rollbackable {
      public final void $COMMIT(      long timestamp){
        $COMMIT_ANONYMOUS(timestamp);
      }
      public final void $RESTORE(      long timestamp,      boolean trim){
        $RESTORE_ANONYMOUS(timestamp,trim);
      }
      public final Checkpoint $GET$CHECKPOINT(){
        return $GET$CHECKPOINT_ANONYMOUS();
      }
      public final Object $SET$CHECKPOINT(      Checkpoint checkpoint){
        $SET$CHECKPOINT_ANONYMOUS(checkpoint);
        return this;
      }
    }
    public void $COMMIT_ANONYMOUS(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      super.$COMMIT(timestamp);
    }
    public void $RESTORE_ANONYMOUS(    long timestamp,    boolean trim){
      super.$RESTORE(timestamp,trim);
    }
    public final Checkpoint $GET$CHECKPOINT_ANONYMOUS(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT_ANONYMOUS(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(new _PROXY_());
      }
      return this;
    }
    private FieldRecord[] $RECORDS=new FieldRecord[]{};
{
      $CHECKPOINT.addObject(new _PROXY_());
    }
  }
;
}"
75068,"public void $RESTORE(long timestamp,boolean trim){
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
    FieldRecord.popState($RECORDS);
  }
}","public void $RESTORE(long timestamp,boolean trim){
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
    FieldRecord.popState($RECORDS);
    $RESTORE(timestamp,trim);
  }
}"
75069,"public Object next(){
  final Map.Entry e=(Map.Entry)super.next();
  return new Map.Entry(){
    protected Checkpoint $CHECKPOINT=new Checkpoint(this);
    public boolean equals(    Object o){
      return e.equals(o);
    }
    public Object getKey(){
      return e.getKey();
    }
    public Object getValue(){
      return e.getValue();
    }
    public int hashCode(){
      return e.hashCode();
    }
    public Object setValue(    Object value){
      throw new UnsupportedOperationException();
    }
    public String toString(){
      return e.toString();
    }
    public void $COMMIT(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      $RECORD$$CHECKPOINT.commit(timestamp);
    }
    public void $RESTORE(    long timestamp,    boolean trim){
      if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
        $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
        FieldRecord.popState($RECORDS);
      }
    }
    public final Checkpoint $GET$CHECKPOINT(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(this);
      }
      return this;
    }
    protected CheckpointRecord $RECORD$$CHECKPOINT=new CheckpointRecord();
    private FieldRecord[] $RECORDS=new FieldRecord[]{};
  }
;
}","public Object next(){
  final Map.Entry e=(Map.Entry)super.next();
  return new Map.Entry(){
    protected Checkpoint $CHECKPOINT=new Checkpoint(this);
    public boolean equals(    Object o){
      return e.equals(o);
    }
    public Object getKey(){
      return e.getKey();
    }
    public Object getValue(){
      return e.getValue();
    }
    public int hashCode(){
      return e.hashCode();
    }
    public Object setValue(    Object value){
      throw new UnsupportedOperationException();
    }
    public String toString(){
      return e.toString();
    }
    public void $COMMIT(    long timestamp){
      FieldRecord.commit($RECORDS,timestamp,$RECORD$$CHECKPOINT.getTopTimestamp());
      $RECORD$$CHECKPOINT.commit(timestamp);
    }
    public void $RESTORE(    long timestamp,    boolean trim){
      if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
        $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
        FieldRecord.popState($RECORDS);
        $RESTORE(timestamp,trim);
      }
    }
    public final Checkpoint $GET$CHECKPOINT(){
      return $CHECKPOINT;
    }
    public final Object $SET$CHECKPOINT(    Checkpoint checkpoint){
      if ($CHECKPOINT != checkpoint) {
        Checkpoint oldCheckpoint=$CHECKPOINT;
        if (checkpoint != null) {
          $RECORD$$CHECKPOINT.add($CHECKPOINT,checkpoint.getTimestamp());
          FieldRecord.pushState($RECORDS);
        }
        $CHECKPOINT=checkpoint;
        oldCheckpoint.setCheckpoint(checkpoint);
        checkpoint.addObject(this);
      }
      return this;
    }
    protected CheckpointRecord $RECORD$$CHECKPOINT=new CheckpointRecord();
    private FieldRecord[] $RECORDS=new FieldRecord[]{};
  }
;
}"
75070,"public void $RESTORE(long timestamp,boolean trim){
  threshold=$RECORD$threshold.restore(threshold,timestamp,trim);
  buckets=(HashEntry[])$RECORD$buckets.restore(buckets,timestamp,trim);
  modCount=$RECORD$modCount.restore(modCount,timestamp,trim);
  size=$RECORD$size.restore(size,timestamp,trim);
  keys=(Set)$RECORD$keys.restore(keys,timestamp,trim);
  values=(Collection)$RECORD$values.restore(values,timestamp,trim);
  entries=(Set)$RECORD$entries.restore(entries,timestamp,trim);
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
    FieldRecord.popState($RECORDS);
  }
}","public void $RESTORE(long timestamp,boolean trim){
  threshold=$RECORD$threshold.restore(threshold,timestamp,trim);
  buckets=(HashEntry[])$RECORD$buckets.restore(buckets,timestamp,trim);
  modCount=$RECORD$modCount.restore(modCount,timestamp,trim);
  size=$RECORD$size.restore(size,timestamp,trim);
  keys=(Set)$RECORD$keys.restore(keys,timestamp,trim);
  values=(Collection)$RECORD$values.restore(values,timestamp,trim);
  entries=(Set)$RECORD$entries.restore(entries,timestamp,trim);
  if (timestamp <= $RECORD$$CHECKPOINT.getTopTimestamp()) {
    $CHECKPOINT=$RECORD$$CHECKPOINT.restore($CHECKPOINT,this,timestamp,trim);
    FieldRecord.popState($RECORDS);
    $RESTORE(timestamp,trim);
  }
}"
75071,"public Class loadClass(File classFile) throws FileNotFoundException, IOException, LinkageError, ClassNotFoundException {
  FileInputStream inputStream=new FileInputStream(classFile);
  byte[] buffer=new byte[inputStream.available()];
  inputStream.read(buffer);
  try {
    return defineClass(null,buffer,0,buffer.length);
  }
 catch (  LinkageError e) {
    String errorPrefix=""String_Node_Str"";
    String message=e.getMessage();
    if (message.startsWith(errorPrefix)) {
      String path=message.substring(errorPrefix.length());
      String classFullName=path.replace('/','.');
      return loadClass(classFullName);
    }
 else     throw e;
  }
}","public Class loadClass(File classFile) throws FileNotFoundException, IOException, LinkageError, ClassNotFoundException {
  FileInputStream inputStream=new FileInputStream(classFile);
  byte[] buffer=new byte[inputStream.available()];
  inputStream.read(buffer);
  try {
    return defineClass(null,buffer,0,buffer.length);
  }
 catch (  IllegalAccessError e) {
    String errorPrefix=""String_Node_Str"";
    String message=e.getMessage();
    if (message.startsWith(errorPrefix)) {
      String className=message.substring(errorPrefix.length());
      int pos;
      if ((pos=className.indexOf(' ')) >= 0)       className=className.substring(0,pos);
      return loadClass(className);
    }
 else     throw e;
  }
catch (  LinkageError e) {
    String errorPrefix=""String_Node_Str"";
    String message=e.getMessage();
    if (message.startsWith(errorPrefix)) {
      String path=message.substring(errorPrefix.length());
      String classFullName=path.replace('/','.');
      return loadClass(classFullName);
    }
 else     throw e;
  }
}"
75072,"/** 
 * Retun true if all the refinements can resolve their states with the current step size.
 * @return True if all the refinements can resolve their states with thecurrent step size.
 */
public boolean isStateAccurate(){
  boolean result=true;
  CTDirector dir=(CTDirector)(((Actor)getContainer()).getExecutiveDirector());
  if (_enabledRefinements != null) {
    Iterator refinements=_enabledRefinements.iterator();
    while (refinements.hasNext()) {
      Actor refinement=(Actor)refinements.next();
      if (refinement instanceof CTStepSizeControlActor) {
        result=result && ((CTStepSizeControlActor)refinement).isStateAccurate();
      }
    }
  }
  return result;
}","/** 
 * Retun true if all the refinements can resolve their states with the current step size.
 * @return True if all the refinements can resolve their states with thecurrent step size.
 */
public boolean isStateAccurate(){
  boolean result=true;
  if (_enabledRefinements != null) {
    Iterator refinements=_enabledRefinements.iterator();
    while (refinements.hasNext()) {
      Actor refinement=(Actor)refinements.next();
      if (refinement instanceof CTStepSizeControlActor) {
        result=result && ((CTStepSizeControlActor)refinement).isStateAccurate();
      }
    }
  }
  return result;
}"
75073,"/** 
 * Retun true if all the output-step-size-control actors of the enabled refinements are satisfied with the current step size and there is no enabled transition detected.
 * @return True if all the refinements are satisfied with thecurrent step size and there is no enabled transition detected.
 */
public boolean isOutputAccurate(){
  boolean result=true;
  Actor container=(Actor)getContainer();
  CTDirector dir=(CTDirector)(container.getExecutiveDirector());
  if (_enabledRefinements != null) {
    Iterator refinements=_enabledRefinements.iterator();
    while (refinements.hasNext()) {
      Actor refinement=(Actor)refinements.next();
      if (refinement instanceof CTStepSizeControlActor) {
        result=result && ((CTStepSizeControlActor)refinement).isOutputAccurate();
      }
    }
  }
  try {
    List preemptiveEnabledTransitions=_ctrl._checkTransition(_currentState.preemptiveTransitionList());
    if (preemptiveEnabledTransitions.size() != 0) {
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"");
      }
    }
    List nonpreemptiveEnabledTransitions=_ctrl._checkTransition(_currentState.nonpreemptiveTransitionList());
    if (nonpreemptiveEnabledTransitions.size() != 0) {
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"");
      }
    }
    Transition preemptiveTrWithEvent=_checkEvent(_currentState.preemptiveTransitionList());
    if (preemptiveTrWithEvent != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + preemptiveTrWithEvent.getGuardExpression());
      }
    }
    Transition nonPreemptiveTrWithEvent=_checkEvent(_currentState.nonpreemptiveTransitionList());
    if (nonPreemptiveTrWithEvent != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + nonPreemptiveTrWithEvent.getGuardExpression());
      }
    }
    double errorTolerance=dir.getErrorTolerance();
    if ((preemptiveEnabledTransitions.size() == 0) && (nonpreemptiveEnabledTransitions.size() == 0) && (preemptiveTrWithEvent == null)&& (nonPreemptiveTrWithEvent == null)) {
      _transitionHasEvent=false;
      _lastDistanceToBoundary=0.0;
      _distanceToBoundary=0.0;
      _outputAccurate=true;
    }
 else {
      Transition enabledTransition=null;
      _distanceToBoundary=Double.MIN_VALUE;
      Iterator iterator=preemptiveEnabledTransitions.iterator();
      while (iterator.hasNext()) {
        Transition transition=(Transition)iterator.next();
        RelationList relationList=transition.getRelationList();
        double distanceToBoundary=relationList.maximumDifference();
        if (distanceToBoundary > _distanceToBoundary) {
          _distanceToBoundary=distanceToBoundary;
          _lastDistanceToBoundary=relationList.getPreviousMaximumDistance();
          enabledTransition=transition;
        }
      }
      iterator=nonpreemptiveEnabledTransitions.iterator();
      while (iterator.hasNext()) {
        Transition transition=(Transition)iterator.next();
        RelationList relationList=transition.getRelationList();
        double distanceToBoundary=relationList.maximumDifference();
        if (distanceToBoundary > _distanceToBoundary) {
          _distanceToBoundary=distanceToBoundary;
          _lastDistanceToBoundary=relationList.getPreviousMaximumDistance();
          enabledTransition=transition;
        }
      }
      if (preemptiveTrWithEvent != null) {
        RelationList relationList=preemptiveTrWithEvent.getRelationList();
        double distanceToBoundary=relationList.maximumDifference();
        if (distanceToBoundary > _distanceToBoundary) {
          _distanceToBoundary=distanceToBoundary;
          _lastDistanceToBoundary=relationList.getPreviousMaximumDistance();
          enabledTransition=preemptiveTrWithEvent;
        }
      }
      if (nonPreemptiveTrWithEvent != null) {
        RelationList relationList=nonPreemptiveTrWithEvent.getRelationList();
        double distanceToBoundary=relationList.maximumDifference();
        if (distanceToBoundary > _distanceToBoundary) {
          _distanceToBoundary=distanceToBoundary;
          _lastDistanceToBoundary=relationList.getPreviousMaximumDistance();
          enabledTransition=nonPreemptiveTrWithEvent;
        }
      }
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"" + enabledTransition.getGuardExpression() + ""String_Node_Str""+ _distanceToBoundary);
      }
      _outputAccurate=_distanceToBoundary < errorTolerance;
      if (!_outputAccurate) {
        _transitionHasEvent=false;
      }
 else {
        _transitionHasEvent=true;
      }
    }
    return result && _outputAccurate;
  }
 catch (  Exception e) {
    throw new InternalErrorException(e);
  }
}","/** 
 * Retun true if all the output-step-size-control actors of the enabled refinements are satisfied with the current step size and there is no enabled transition detected.
 * @return True if all the refinements are satisfied with thecurrent step size and there is no enabled transition detected.
 */
public boolean isOutputAccurate(){
  boolean result=true;
  Actor container=(Actor)getContainer();
  CTDirector dir=(CTDirector)(container.getExecutiveDirector());
  if (_enabledRefinements != null) {
    Iterator refinements=_enabledRefinements.iterator();
    while (refinements.hasNext()) {
      Actor refinement=(Actor)refinements.next();
      if (refinement instanceof CTStepSizeControlActor) {
        result=result && ((CTStepSizeControlActor)refinement).isOutputAccurate();
      }
    }
  }
  try {
    List preemptiveEnabledTransitions=_ctrl._checkTransition(_currentState.preemptiveTransitionList());
    if (preemptiveEnabledTransitions.size() != 0) {
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"");
      }
    }
    List nonpreemptiveEnabledTransitions=_ctrl._checkTransition(_currentState.nonpreemptiveTransitionList());
    if (nonpreemptiveEnabledTransitions.size() != 0) {
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"");
      }
    }
    Transition preemptiveTrWithEvent=_checkEvent(_currentState.preemptiveTransitionList());
    if (preemptiveTrWithEvent != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + preemptiveTrWithEvent.getGuardExpression());
      }
    }
    Transition nonPreemptiveTrWithEvent=_checkEvent(_currentState.nonpreemptiveTransitionList());
    if (nonPreemptiveTrWithEvent != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + nonPreemptiveTrWithEvent.getGuardExpression());
      }
    }
    double errorTolerance=dir.getErrorTolerance();
    if ((preemptiveEnabledTransitions.size() == 0) && (nonpreemptiveEnabledTransitions.size() == 0) && (preemptiveTrWithEvent == null)&& (nonPreemptiveTrWithEvent == null)) {
      _transitionHasEvent=false;
      _lastDistanceToBoundary=0.0;
      _distanceToBoundary=0.0;
      _outputAccurate=true;
    }
 else {
      Transition enabledTransition=null;
      _distanceToBoundary=Double.MIN_VALUE;
      Iterator iterator=preemptiveEnabledTransitions.iterator();
      while (iterator.hasNext()) {
        Transition transition=(Transition)iterator.next();
        RelationList relationList=transition.getRelationList();
        double distanceToBoundary=relationList.maximumDifference();
        if (distanceToBoundary > _distanceToBoundary) {
          _distanceToBoundary=distanceToBoundary;
          _lastDistanceToBoundary=relationList.getPreviousMaximumDistance();
          enabledTransition=transition;
        }
      }
      iterator=nonpreemptiveEnabledTransitions.iterator();
      while (iterator.hasNext()) {
        Transition transition=(Transition)iterator.next();
        RelationList relationList=transition.getRelationList();
        double distanceToBoundary=relationList.maximumDifference();
        if (distanceToBoundary > _distanceToBoundary) {
          _distanceToBoundary=distanceToBoundary;
          _lastDistanceToBoundary=relationList.getPreviousMaximumDistance();
          enabledTransition=transition;
        }
      }
      if (preemptiveTrWithEvent != null) {
        RelationList relationList=preemptiveTrWithEvent.getRelationList();
        double distanceToBoundary=relationList.maximumDifference();
        if (distanceToBoundary > _distanceToBoundary) {
          _distanceToBoundary=distanceToBoundary;
          _lastDistanceToBoundary=relationList.getPreviousMaximumDistance();
          enabledTransition=preemptiveTrWithEvent;
        }
      }
      if (nonPreemptiveTrWithEvent != null) {
        RelationList relationList=nonPreemptiveTrWithEvent.getRelationList();
        double distanceToBoundary=relationList.maximumDifference();
        if (distanceToBoundary > _distanceToBoundary) {
          _distanceToBoundary=distanceToBoundary;
          _lastDistanceToBoundary=relationList.getPreviousMaximumDistance();
          enabledTransition=nonPreemptiveTrWithEvent;
        }
      }
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"" + enabledTransition.getGuardExpression() + ""String_Node_Str""+ _distanceToBoundary);
      }
      _outputAccurate=_distanceToBoundary < errorTolerance;
      if (!_outputAccurate) {
        _transitionHasEvent=false;
      }
 else {
        _transitionHasEvent=true;
      }
    }
    return result && _outputAccurate;
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(throwable);
  }
}"
75074,"/** 
 * Handle a class declaration or anonymous class declaration. Records and assignment methods are added to the declaration.
 * @param node The AST node of class declaration or anonymous classdeclaration.
 * @param bodyDeclarations The list of body declarations in the class.
 * @param state The current state of the type analyzer.
 */
private void _handleDeclaration(ASTNode node,List bodyDeclarations,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  List newMethods=new LinkedList();
  List newFields=new LinkedList();
  AST ast=node.getAST();
  CompilationUnit root=(CompilationUnit)node.getRoot();
  List fieldNames=new LinkedList();
  List fieldTypes=new LinkedList();
  Iterator bodyIter=bodyDeclarations.iterator();
  while (bodyIter.hasNext()) {
    Object nextDeclaration=bodyIter.next();
    if (nextDeclaration instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)nextDeclaration;
      boolean isStatic=Modifier.isStatic(fieldDecl.getModifiers());
      if (isStatic && HANDLE_STATIC_FIELDS != true)       continue;
      if (Modifier.isPrivate(fieldDecl.getModifiers())) {
        Type type=Type.getType(fieldDecl);
        Iterator fragmentIter=fieldDecl.fragments().iterator();
        while (fragmentIter.hasNext()) {
          VariableDeclarationFragment fragment=(VariableDeclarationFragment)fragmentIter.next();
          String fieldName=fragment.getName().getIdentifier();
          Hashtable[] tables=new Hashtable[]{_accessedFields,_specialAccessedFields,_backupFields};
          for (int i=0; i < tables.length; i++) {
            List indicesList=_getAccessedField(tables[i],currentClass.getName(),fieldName);
            if (indicesList == null)             continue;
            Iterator indicesIter=indicesList.iterator();
            while (indicesIter.hasNext()) {
              int indices=((Integer)indicesIter.next()).intValue();
              if (tables[i] == _backupFields)               newMethods.add(_createBackupMethod(ast,root,state,fieldName,type,indices,isStatic));
 else               newMethods.add(_createAssignMethod(ast,root,state,fieldName,type,indices,tables[i] == _specialAccessedFields,isStatic));
            }
          }
          fieldNames.add(fieldName);
          fieldTypes.add(type);
          FieldDeclaration field=_createFieldRecord(ast,root,state,fieldName,type.dimensions(),isStatic);
          if (field != null)           newFields.add(field);
        }
      }
    }
  }
  boolean isInterface=node instanceof TypeDeclaration && ((TypeDeclaration)node).isInterface();
  boolean isAnonymous=node instanceof AnonymousClassDeclaration;
  if (isAnonymous) {
    Class[] interfaces=currentClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (state.getCrossAnalyzedTypes().contains(interfaces[i].getName()))     isAnonymous=false;
  }
  if (!_isInStaticMethod.isEmpty() && _isInStaticMethod.peek() == Boolean.TRUE && isAnonymous)   return;
  if (!isInterface)   newFields.add(_createRecordArray(ast,root,state,fieldNames));
  newMethods.add(_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,isAnonymous,isInterface));
  MethodDeclaration getCheckpoint=_createGetCheckpointMethod(ast,root,state,isAnonymous,isInterface);
  if (getCheckpoint != null)   newMethods.add(getCheckpoint);
  MethodDeclaration setCheckpoint=_createSetCheckpointMethod(ast,root,state,isAnonymous,isInterface);
  if (setCheckpoint != null)   newMethods.add(setCheckpoint);
  if (isAnonymous)   bodyDeclarations.add(_createProxyClass(ast,root,state));
 else {
    if (node instanceof TypeDeclaration) {
      String rollbackType=getClassName(Rollbackable.class,state,root);
      ((TypeDeclaration)node).superInterfaces().add(createName(ast,rollbackType));
    }
    if (!isInterface) {
      FieldDeclaration checkpointField=_createCheckpointField(ast,root,state);
      if (checkpointField != null)       bodyDeclarations.add(0,checkpointField);
      FieldDeclaration record=_createCheckpointRecord(ast,root,state);
      if (record != null)       newFields.add(0,record);
    }
  }
  bodyDeclarations.addAll(newMethods);
  bodyDeclarations.addAll(newFields);
  if (isAnonymous) {
    Initializer initializer=ast.newInitializer();
    Block body=ast.newBlock();
    initializer.setBody(body);
    MethodInvocation addInvocation=ast.newMethodInvocation();
    addInvocation.setExpression(ast.newSimpleName(CHECKPOINT_NAME));
    addInvocation.setName(ast.newSimpleName(""String_Node_Str""));
    ClassInstanceCreation proxy=ast.newClassInstanceCreation();
    proxy.setName(ast.newSimpleName(_getProxyName()));
    addInvocation.arguments().add(proxy);
    body.statements().add(ast.newExpressionStatement(addInvocation));
    bodyDeclarations.add(initializer);
  }
}","/** 
 * Handle a class declaration or anonymous class declaration. Records and assignment methods are added to the declaration.
 * @param node The AST node of class declaration or anonymous classdeclaration.
 * @param bodyDeclarations The list of body declarations in the class.
 * @param state The current state of the type analyzer.
 */
private void _handleDeclaration(ASTNode node,List bodyDeclarations,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  List newMethods=new LinkedList();
  List newFields=new LinkedList();
  AST ast=node.getAST();
  CompilationUnit root=(CompilationUnit)node.getRoot();
  List fieldNames=new LinkedList();
  List fieldTypes=new LinkedList();
  Iterator bodyIter=bodyDeclarations.iterator();
  while (bodyIter.hasNext()) {
    Object nextDeclaration=bodyIter.next();
    if (nextDeclaration instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)nextDeclaration;
      boolean isStatic=Modifier.isStatic(fieldDecl.getModifiers());
      if (isStatic && HANDLE_STATIC_FIELDS != true)       continue;
      if (Modifier.isPrivate(fieldDecl.getModifiers())) {
        Type type=Type.getType(fieldDecl);
        Iterator fragmentIter=fieldDecl.fragments().iterator();
        while (fragmentIter.hasNext()) {
          VariableDeclarationFragment fragment=(VariableDeclarationFragment)fragmentIter.next();
          String fieldName=fragment.getName().getIdentifier();
          Hashtable[] tables=new Hashtable[]{_accessedFields,_specialAccessedFields,_backupFields};
          for (int i=0; i < tables.length; i++) {
            List indicesList=_getAccessedField(tables[i],currentClass.getName(),fieldName);
            if (indicesList == null)             continue;
            Iterator indicesIter=indicesList.iterator();
            while (indicesIter.hasNext()) {
              int indices=((Integer)indicesIter.next()).intValue();
              if (tables[i] == _backupFields)               newMethods.add(_createBackupMethod(ast,root,state,fieldName,type,indices,isStatic));
 else               newMethods.add(_createAssignMethod(ast,root,state,fieldName,type,indices,tables[i] == _specialAccessedFields,isStatic));
            }
          }
          fieldNames.add(fieldName);
          fieldTypes.add(type);
          FieldDeclaration field=_createFieldRecord(ast,root,state,fieldName,type.dimensions(),isStatic);
          if (field != null)           newFields.add(field);
        }
      }
    }
  }
  boolean isInterface=node instanceof TypeDeclaration && ((TypeDeclaration)node).isInterface();
  boolean isAnonymous=node instanceof AnonymousClassDeclaration;
  if (isAnonymous) {
    Class[] interfaces=currentClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (state.getCrossAnalyzedTypes().contains(interfaces[i].getName()))     isAnonymous=false;
  }
  RehandleDeclarationRecord declarationRecord=null;
  if (isAnonymous) {
    Class[] interfaces=currentClass.getInterfaces();
    if (interfaces.length == 1) {
      declarationRecord=new RehandleDeclarationRecord(bodyDeclarations);
      addToLists(_rehandleDeclaration,interfaces[0].getName(),declarationRecord);
    }
  }
  boolean ignore=!_isInStaticMethod.isEmpty() && _isInStaticMethod.peek() == Boolean.TRUE && isAnonymous;
  if (!isInterface && !ignore)   newFields.add(_createRecordArray(ast,root,state,fieldNames));
  MethodDeclaration restoreMethod=null;
  if (!ignore) {
    restoreMethod=_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,isAnonymous,isInterface);
    newMethods.add(restoreMethod);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(restoreMethod);
    MethodDeclaration fixedRestoreMethod=_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedRestoreMethod);
  }
  MethodDeclaration getCheckpoint=null;
  if (!ignore) {
    getCheckpoint=_createGetCheckpointMethod(ast,root,state,isAnonymous,isInterface);
    if (getCheckpoint != null)     newMethods.add(getCheckpoint);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(getCheckpoint);
    MethodDeclaration fixedGetCheckpoint=_createGetCheckpointMethod(ast,root,state,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedGetCheckpoint);
  }
  MethodDeclaration setCheckpoint=null;
  if (!ignore) {
    setCheckpoint=_createSetCheckpointMethod(ast,root,state,isAnonymous,isInterface);
    if (setCheckpoint != null)     newMethods.add(setCheckpoint);
  }
  if (declarationRecord != null) {
    if (!ignore)     declarationRecord._addExtendedDeclaration(setCheckpoint);
    MethodDeclaration fixedSetCheckpoint=_createSetCheckpointMethod(ast,root,state,false,isInterface);
    declarationRecord._addFixedDeclaration(fixedSetCheckpoint);
  }
  if (!ignore) {
    if (isAnonymous) {
      TypeDeclaration proxy=_createProxyClass(ast,root,state);
      bodyDeclarations.add(proxy);
      if (declarationRecord != null)       declarationRecord._addExtendedDeclaration(proxy);
    }
 else {
      if (node instanceof TypeDeclaration) {
        String rollbackType=getClassName(Rollbackable.class,state,root);
        ((TypeDeclaration)node).superInterfaces().add(createName(ast,rollbackType));
      }
      if (!isInterface) {
        FieldDeclaration checkpointField=_createCheckpointField(ast,root,state);
        if (checkpointField != null)         bodyDeclarations.add(0,checkpointField);
        FieldDeclaration record=_createCheckpointRecord(ast,root,state);
        if (record != null)         newFields.add(0,record);
      }
    }
  }
  if (!ignore) {
    bodyDeclarations.addAll(newMethods);
    bodyDeclarations.addAll(newFields);
  }
 else {
    if (declarationRecord != null) {
      declarationRecord._addFixedDeclarations(newMethods);
      declarationRecord._addFixedDeclarations(newFields);
    }
  }
  if (isAnonymous && !ignore) {
    Initializer initializer=ast.newInitializer();
    Block body=ast.newBlock();
    initializer.setBody(body);
    MethodInvocation addInvocation=ast.newMethodInvocation();
    addInvocation.setExpression(ast.newSimpleName(CHECKPOINT_NAME));
    addInvocation.setName(ast.newSimpleName(""String_Node_Str""));
    ClassInstanceCreation proxy=ast.newClassInstanceCreation();
    proxy.setName(ast.newSimpleName(_getProxyName()));
    addInvocation.arguments().add(proxy);
    body.statements().add(ast.newExpressionStatement(addInvocation));
    bodyDeclarations.add(initializer);
    if (declarationRecord != null)     declarationRecord._addExtendedDeclaration(initializer);
  }
}"
75075,"/** 
 * Fix the refactoring when the set of cross-analyzed types changes.
 * @param state The current state of the type analyzer.
 */
public void handle(TypeAnalyzerState state){
  Set crossAnalyzedTypes=state.getCrossAnalyzedTypes();
  Iterator crossAnalysisIter=crossAnalyzedTypes.iterator();
  while (crossAnalysisIter.hasNext()) {
    String nextClassName=(String)crossAnalysisIter.next();
    List list=(List)_checkParentFields.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        removeNode((ASTNode)nodesIter.next());
        nodesIter.remove();
      }
    }
    list=(List)_checkParentMethods.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        removeNode((ASTNode)nodesIter.next());
        nodesIter.remove();
      }
    }
    list=(List)_fixParentRestoreMethods.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        Block body=(Block)nodesIter.next();
        AST ast=body.getAST();
        String methodName=_getRestoreMethodName(false);
        SuperMethodInvocation superRestore=ast.newSuperMethodInvocation();
        superRestore.setName(ast.newSimpleName(methodName));
        superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
        superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
        List statements=body.statements();
        statements.remove(statements.size() - 1);
        statements.add(ast.newExpressionStatement(superRestore));
        nodesIter.remove();
      }
    }
    list=(List)_fixSetCheckpoint.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        Block body=(Block)nodesIter.next();
        AST ast=body.getAST();
        Statement invocation=_createSetCheckpointInvocation(ast);
        List statements=body.statements();
        statements.add(statements.size() - 2,invocation);
        nodesIter.remove();
      }
    }
  }
}","/** 
 * Fix the refactoring when the set of cross-analyzed types changes.
 * @param state The current state of the type analyzer.
 */
public void handle(TypeAnalyzerState state){
  Set crossAnalyzedTypes=state.getCrossAnalyzedTypes();
  Iterator crossAnalysisIter=crossAnalyzedTypes.iterator();
  while (crossAnalysisIter.hasNext()) {
    String nextClassName=(String)crossAnalysisIter.next();
    List list=(List)_checkParentFields.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        removeNode((ASTNode)nodesIter.next());
        nodesIter.remove();
      }
    }
    list=(List)_checkParentMethods.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        removeNode((ASTNode)nodesIter.next());
        nodesIter.remove();
      }
    }
    list=(List)_fixParentRestoreMethods.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        Block body=(Block)nodesIter.next();
        AST ast=body.getAST();
        String methodName=_getRestoreMethodName(false);
        SuperMethodInvocation superRestore=ast.newSuperMethodInvocation();
        superRestore.setName(ast.newSimpleName(methodName));
        superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
        superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
        List statements=body.statements();
        statements.remove(statements.size() - 1);
        statements.add(ast.newExpressionStatement(superRestore));
        nodesIter.remove();
      }
    }
    list=(List)_fixSetCheckpoint.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        Block body=(Block)nodesIter.next();
        AST ast=body.getAST();
        Statement invocation=_createSetCheckpointInvocation(ast);
        List statements=body.statements();
        statements.add(statements.size() - 2,invocation);
        nodesIter.remove();
      }
    }
    list=(List)_rehandleDeclaration.get(nextClassName);
    if (list != null) {
      Iterator recordsIter=list.iterator();
      while (recordsIter.hasNext()) {
        RehandleDeclarationRecord record=(RehandleDeclarationRecord)recordsIter.next();
        Iterator extendedIter=record._getExtendedDeclarations().iterator();
        while (extendedIter.hasNext()) {
          ASTNode declaration=(ASTNode)extendedIter.next();
          if (declaration != null)           removeNode(declaration);
        }
        Iterator fixedIter=record._getFixedDeclarations().iterator();
        while (fixedIter.hasNext()) {
          ASTNode declaration=(ASTNode)fixedIter.next();
          if (declaration != null)           record._getBodyDeclarations().add(declaration);
        }
        recordsIter.remove();
      }
    }
  }
}"
75076,"/** 
 * Initialize the execution.  Create the IconViewScreen3D frame if it hasn't been set using the place() method.
 * @exception IllegalActionException If the base class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _frameNumber=0;
  _frameWidth=_getHorizontalPixels();
  _frameHeight=_getVerticalPixels();
}","/** 
 * Initialize the execution.  Create the IconViewScreen3D frame if it hasn't been set using the place() method.
 * @exception IllegalActionException If the base class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _frameNumber=0;
  _frameWidth=((IntToken)horizontalResolution.getToken()).intValue();
  _frameHeight=((IntToken)verticalResolution.getToken()).intValue();
}"
75077,"/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method maintains a schedule cache and will attempt to return a cached version of the schedule. If the cache does not contain the schedule for the current hdf graph, then the schedule will be computed by calling the getSchedule() method of the SDFScheduler. <p> The schedule cache uses a least-recently-used replacement policy. The size of the cache is specified by the scheduleCacheSize parameter. The default cache size is 100.
 * @return The Schedule for the current hdf graph.
 * @exception IllegalActionException If there is a problem gettingthe schedule.
 */
public Schedule getSchedule() throws IllegalActionException {
  Scheduler scheduler=getScheduler();
  Schedule schedule;
  if (isScheduleValid()) {
    schedule=((SDFScheduler)scheduler).getSchedule();
  }
 else {
    if (_inputPortList == null) {
      _inputPortList=_getInputPortList();
    }
    if (_outputPortList == null) {
      _outputPortList=_getOutputPortList();
    }
    Iterator inputPorts=_inputPortList.iterator();
    String rates=new String();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      int rate=DFUtilities.getTokenConsumptionRate(inputPort);
      rates=rates + String.valueOf(rate);
    }
    Iterator outputPorts=_outputPortList.iterator();
    while (outputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      int rate=DFUtilities.getTokenProductionRate(outputPort);
      rates=rates + String.valueOf(rate);
      int initRate=DFUtilities.getTokenInitProduction(outputPort);
      rates=rates + String.valueOf(rate);
    }
    String rateKey=rates;
    int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
    if (cacheSize != _cacheSize) {
      _scheduleCache=new HashMap();
      _scheduleKeyList=new ArrayList(cacheSize);
      _cacheSize=cacheSize;
      _externalRatesCache=new TreeMap();
      _externalRatesKeyList=new ArrayList(cacheSize);
    }
    if (rateKey == _mostRecentRates) {
      schedule=((SDFScheduler)scheduler).getSchedule();
    }
 else     if (_scheduleCache.containsKey(rateKey)) {
      _mostRecentRates=rateKey;
      if (cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _externalRatesKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
        _externalRatesKeyList.add(0,rateKey);
      }
      schedule=(Schedule)_scheduleCache.get(rateKey);
      Map externalRates=(Map)_externalRatesCache.get(rateKey);
      ((SDFScheduler)scheduler).setContainerRates(externalRates);
    }
 else {
      _mostRecentRates=rateKey;
      if (cacheSize > 0) {
        while (_scheduleKeyList.size() >= cacheSize) {
          Object object=_scheduleKeyList.get(cacheSize - 1);
          _scheduleKeyList.remove(cacheSize - 1);
          _externalRatesKeyList.remove(cacheSize - 1);
          _scheduleCache.remove(object);
          _externalRatesCache.remove(object);
        }
        _scheduleKeyList.add(0,rateKey);
        _externalRatesKeyList.add(0,rateKey);
      }
      schedule=((SDFScheduler)scheduler).getSchedule();
      Map externalRates=((SDFScheduler)scheduler).getExternalRates();
      _externalRatesCache.put(rateKey,externalRates);
      _scheduleCache.put(rateKey,schedule);
    }
  }
  return schedule;
}","/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method maintains a schedule cache and will attempt to return a cached version of the schedule. If the cache does not contain the schedule for the current hdf graph, then the schedule will be computed by calling the getSchedule() method of the SDFScheduler. <p> The schedule cache uses a least-recently-used replacement policy. The size of the cache is specified by the scheduleCacheSize parameter. The default cache size is 100.
 * @return The Schedule for the current hdf graph.
 * @exception IllegalActionException If there is a problem gettingthe schedule.
 */
public Schedule getSchedule() throws IllegalActionException {
  Scheduler scheduler=getScheduler();
  Schedule schedule;
  if (isScheduleValid()) {
    schedule=((SDFScheduler)scheduler).getSchedule();
  }
 else {
    if (_inputPortList == null) {
      _inputPortList=_getInputPortList();
    }
    if (_outputPortList == null) {
      _outputPortList=_getOutputPortList();
    }
    Iterator inputPorts=_inputPortList.iterator();
    String rates=""String_Node_Str"";
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      int rate=DFUtilities.getTokenConsumptionRate(inputPort);
      rates=rates + String.valueOf(rate);
    }
    Iterator outputPorts=_outputPortList.iterator();
    while (outputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      int rate=DFUtilities.getTokenProductionRate(outputPort);
      rates=rates + String.valueOf(rate);
      int initRate=DFUtilities.getTokenInitProduction(outputPort);
      rates=rates + String.valueOf(rate);
    }
    String rateKey=rates;
    int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
    if (cacheSize != _cacheSize) {
      _scheduleCache=new HashMap();
      _scheduleKeyList=new ArrayList(cacheSize);
      _cacheSize=cacheSize;
      _externalRatesCache=new TreeMap();
      _externalRatesKeyList=new ArrayList(cacheSize);
    }
    if (rateKey == _mostRecentRates) {
      schedule=((SDFScheduler)scheduler).getSchedule();
    }
 else     if (_scheduleCache.containsKey(rateKey)) {
      _mostRecentRates=rateKey;
      if (cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _externalRatesKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
        _externalRatesKeyList.add(0,rateKey);
      }
      schedule=(Schedule)_scheduleCache.get(rateKey);
      Map externalRates=(Map)_externalRatesCache.get(rateKey);
      ((SDFScheduler)scheduler).setContainerRates(externalRates);
    }
 else {
      _mostRecentRates=rateKey;
      if (cacheSize > 0) {
        while (_scheduleKeyList.size() >= cacheSize) {
          Object object=_scheduleKeyList.get(cacheSize - 1);
          _scheduleKeyList.remove(cacheSize - 1);
          _externalRatesKeyList.remove(cacheSize - 1);
          _scheduleCache.remove(object);
          _externalRatesCache.remove(object);
        }
        _scheduleKeyList.add(0,rateKey);
        _externalRatesKeyList.add(0,rateKey);
      }
      schedule=((SDFScheduler)scheduler).getSchedule();
      Map externalRates=((SDFScheduler)scheduler).getExternalRates();
      _externalRatesCache.put(rateKey,externalRates);
      _scheduleCache.put(rateKey,schedule);
    }
  }
  return schedule;
}"
75078,"/** 
 * Initialize the execution.  Create the MovieViewScreen3D frame if it hasn't been set using the place() method.
 * @exception IllegalActionException If the base class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _frameNumber=0;
  _frameWidth=_getHorizontalPixels();
  _frameHeight=_getVerticalPixels();
  try {
    QTSession.open();
    Frame frame=new Frame(""String_Node_Str"");
    QTCanvas canv=new QTCanvas(QTCanvas.kInitialSize,0.5F,0.5F);
    frame.add(""String_Node_Str"",canv);
    Painter painter=new Painter();
    _imageDrawer=new QTImageDrawer(painter,new Dimension(_frameWidth,_frameHeight),Redrawable.kMultiFrame);
    _imageDrawer.setRedrawing(true);
    canv.setClient(_imageDrawer,true);
    frame.pack();
    _file=new QTFile(fileName.asFile());
    _movie=Movie.createMovieFile(_file,kMoviePlayer,createMovieFileDeleteCurFile | createMovieFileDontCreateResFile);
    System.out.println(""String_Node_Str"");
    int kNoVolume=0;
    int kVidTimeScale=600;
    _videoTrack=_movie.addTrack(_frameWidth,_frameHeight,kNoVolume);
    _videoMedia=new VideoMedia(_videoTrack,kVidTimeScale);
    _videoMedia.beginEdits();
    _videoSize=new QDRect(_frameWidth,_frameHeight);
    _gw=new QDGraphics(_videoSize);
    int size=QTImage.getMaxCompressionSize(_gw,_videoSize,_gw.getPixMap().getPixelSize(),codecNormalQuality,kAnimationCodecType,CodecComponent.anyCodec);
    _imageHandle=new QTHandle(size,true);
    _imageHandle.lock();
    _compressedFrame=RawEncodedImage.fromQTHandle(_imageHandle);
    _frameRateValue=((IntToken)frameRate.getToken()).intValue();
    _videoSequence=new CSequence(_gw,_videoSize,_gw.getPixMap().getPixelSize(),kAnimationCodecType,CodecComponent.bestFidelityCodec,codecNormalQuality,codecNormalQuality,_frameRateValue,null,0);
    ImageDescription desc=_videoSequence.getDescription();
    _imageDrawer.setRedrawing(true);
    _imageDrawer.redraw(null);
    _imageDrawer.setGWorld(_gw);
    _imageDrawer.setDisplayBounds(_videoSize);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","/** 
 * Initialize the execution.  Create the MovieViewScreen3D frame if it hasn't been set using the place() method.
 * @exception IllegalActionException If the base class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _frameNumber=0;
  _frameWidth=((IntToken)horizontalResolution.getToken()).intValue();
  _frameHeight=((IntToken)verticalResolution.getToken()).intValue();
  try {
    QTSession.open();
    Frame frame=new Frame(""String_Node_Str"");
    QTCanvas canv=new QTCanvas(QTCanvas.kInitialSize,0.5F,0.5F);
    frame.add(""String_Node_Str"",canv);
    Painter painter=new Painter();
    _imageDrawer=new QTImageDrawer(painter,new Dimension(_frameWidth,_frameHeight),Redrawable.kMultiFrame);
    _imageDrawer.setRedrawing(true);
    canv.setClient(_imageDrawer,true);
    frame.pack();
    _file=new QTFile(fileName.asFile());
    _movie=Movie.createMovieFile(_file,kMoviePlayer,createMovieFileDeleteCurFile | createMovieFileDontCreateResFile);
    System.out.println(""String_Node_Str"");
    int kNoVolume=0;
    int kVidTimeScale=600;
    _videoTrack=_movie.addTrack(_frameWidth,_frameHeight,kNoVolume);
    _videoMedia=new VideoMedia(_videoTrack,kVidTimeScale);
    _videoMedia.beginEdits();
    _videoSize=new QDRect(_frameWidth,_frameHeight);
    _gw=new QDGraphics(_videoSize);
    int size=QTImage.getMaxCompressionSize(_gw,_videoSize,_gw.getPixMap().getPixelSize(),codecNormalQuality,kAnimationCodecType,CodecComponent.anyCodec);
    _imageHandle=new QTHandle(size,true);
    _imageHandle.lock();
    _compressedFrame=RawEncodedImage.fromQTHandle(_imageHandle);
    _frameRateValue=((IntToken)frameRate.getToken()).intValue();
    _videoSequence=new CSequence(_gw,_videoSize,_gw.getPixMap().getPixelSize(),kAnimationCodecType,CodecComponent.bestFidelityCodec,codecNormalQuality,codecNormalQuality,_frameRateValue,null,0);
    ImageDescription desc=_videoSequence.getDescription();
    _imageDrawer.setRedrawing(true);
    _imageDrawer.redraw(null);
    _imageDrawer.setGWorld(_gw);
    _imageDrawer.setDisplayBounds(_videoSize);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}"
75079,"private static void _addInnerClasses(Set crossAnalysis,String classFileName,String packageName){
  File topFile=new File(classFileName);
  File path=topFile.getParentFile();
  String className=topFile.getName().substring(0,topFile.getName().length() - 6);
  File[] files=path.listFiles(new InnerClassFilter(className));
  for (int i=0; i < files.length; i++) {
    File file=files[i];
    className=file.getName().substring(0,file.getName().length() - 6);
    if (packageName != null)     className=packageName + ""String_Node_Str"" + className;
    crossAnalysis.add(className);
  }
}","private static void _addInnerClasses(Set crossAnalysis,String classFileName,String packageName){
  File topFile=new File(classFileName);
  File path=topFile.getParentFile();
  if (path == null)   path=new File(""String_Node_Str"");
  String className=topFile.getName().substring(0,topFile.getName().length() - 6);
  File[] files=path.listFiles(new InnerClassFilter(className));
  for (int i=0; i < files.length; i++) {
    File file=files[i];
    className=file.getName().substring(0,file.getName().length() - 6);
    if (packageName != null)     className=packageName + ""String_Node_Str"" + className;
    crossAnalysis.add(className);
  }
}"
75080,"public int compare(Object o1,Object o2){
  if (o1.getClass().isInstance(o2))   return 0;
  Class[] classes=new Class[]{FieldDeclaration.class,TypeDeclaration.class,MethodDeclaration.class};
  for (int i=0; i < classes.length; i++)   if (classes[i].isInstance(o1))   for (int j=i + 1; j < classes.length; j++)   if (classes[j].isInstance(o2))   return -1;
  return 1;
}","public int compare(Object o1,Object o2){
  if (o1.getClass().isInstance(o2))   return 0;
  Class[] classes=new Class[]{FieldDeclaration.class,TypeDeclaration.class,MethodDeclaration.class,Initializer.class};
  for (int i=0; i < classes.length; i++)   if (classes[i].isInstance(o1))   for (int j=i + 1; j < classes.length; j++)   if (classes[j].isInstance(o2))   return -1;
  return 1;
}"
75081,"/** 
 * Get the simple class name of a class (not including any ""."" or ""$""). The same function is provided in   {@link Class} class in Java 1.5.
 * @param c The class object.
 * @return The simple name of the class object.
 */
private String _getSimpleClassName(Class c){
  String name=c.getName();
  int lastSeparator1=name.lastIndexOf('.');
  int lastSeparator2=name.lastIndexOf('$');
  int lastSeparator=lastSeparator1 >= lastSeparator2 ? lastSeparator1 : lastSeparator2;
  return name.substring(lastSeparator + 1);
}","/** 
 * Get the simple class name of a class (not including any ""."" or ""$""). The same function is provided in   {@link Class} class in Java 1.5.
 * @param c The class object.
 * @return The simple name of the class object.
 */
private String _getSimpleClassName(Class c){
  String name=c.getName();
  int lastSeparator1=name.lastIndexOf('.');
  int lastSeparator2=name.lastIndexOf('$');
  int lastSeparator=lastSeparator1 >= lastSeparator2 ? lastSeparator1 : lastSeparator2;
  name=name.substring(lastSeparator + 1);
  String newName=name;
  char ch=newName.charAt(0);
  while (ch >= '0' && ch <= '9' && newName.length() > 1) {
    newName=newName.substring(1);
    ch=newName.charAt(0);
  }
  if (newName.length() == 0)   return name;
 else   return newName;
}"
75082,"/** 
 * Sort a list or body declarations according to the Java compiler convention.
 * @param bodyDeclarations The list of body declarations.
 * @see #_sortBodyDeclarations(AbstractTypeDeclaration)
 * @see #_sortBodyDeclarations(AnonymousClassDeclaration)
 */
private static void _sortBodyDeclarations(List bodyDeclarations){
  Object[] bodyArray=bodyDeclarations.toArray();
  Arrays.sort(bodyArray,new Comparator(){
    public int compare(    Object o1,    Object o2){
      if (o1.getClass().isInstance(o2))       return 0;
      Class[] classes=new Class[]{FieldDeclaration.class,TypeDeclaration.class,MethodDeclaration.class};
      for (int i=0; i < classes.length; i++)       if (classes[i].isInstance(o1))       for (int j=i + 1; j < classes.length; j++)       if (classes[j].isInstance(o2))       return -1;
      return 1;
    }
  }
);
  bodyDeclarations.clear();
  bodyDeclarations.addAll(Arrays.asList(bodyArray));
}","/** 
 * Sort a list or body declarations according to the Java compiler convention.
 * @param bodyDeclarations The list of body declarations.
 * @see #_sortBodyDeclarations(AbstractTypeDeclaration)
 * @see #_sortBodyDeclarations(AnonymousClassDeclaration)
 */
private static void _sortBodyDeclarations(List bodyDeclarations){
  Object[] bodyArray=bodyDeclarations.toArray();
  Arrays.sort(bodyArray,new Comparator(){
    public int compare(    Object o1,    Object o2){
      if (o1.getClass().isInstance(o2))       return 0;
      Class[] classes=new Class[]{FieldDeclaration.class,TypeDeclaration.class,MethodDeclaration.class,Initializer.class};
      for (int i=0; i < classes.length; i++)       if (classes[i].isInstance(o1))       for (int j=i + 1; j < classes.length; j++)       if (classes[j].isInstance(o2))       return -1;
      return 1;
    }
  }
);
  bodyDeclarations.clear();
  bodyDeclarations.addAll(Arrays.asList(bodyArray));
}"
75083,"/** 
 * Visit an type declaration and set the current class to be the  {@link Class} object loaded with the same (internal) name. Ascope is opened for field declarations in it.
 * @param node The node to be visited.
 * @return The return value of the overriden function.
 */
public boolean visit(TypeDeclaration node){
  String typeName=node.getName().getIdentifier();
  Class currentClass=_state.getCurrentClass();
  try {
    if (currentClass != null) {
      typeName=currentClass.getName() + ""String_Node_Str"" + typeName;
      currentClass=_state.getClassLoader().searchForClass(typeName);
    }
 else     currentClass=_state.getClassLoader().searchForClass(typeName);
    _state.enterClass(currentClass);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(typeName);
  }
  addCrossAnalyzedType(currentClass.getName());
  _openScope();
  _state.setClassScope();
  _recordFields();
  _sortBodyDeclarations(node);
  if (_handlers.hasClassHandler()) {
    List handlerList=_handlers.getClassHandlers();
    Iterator handlersIter=handlerList.iterator();
    while (handlersIter.hasNext()) {
      ClassHandler handler=(ClassHandler)handlersIter.next();
      handler.enter(node,_state);
    }
  }
  return super.visit(node);
}","/** 
 * Visit an type declaration and set the current class to be the  {@link Class} object loaded with the same (internal) name. Ascope is opened for field declarations in it.
 * @param node The node to be visited.
 * @return The return value of the overriden function.
 */
public boolean visit(TypeDeclaration node){
  String typeName=node.getName().getIdentifier();
  Class currentClass=_state.getCurrentClass();
  if (currentClass == null) {
    try {
      currentClass=_state.getClassLoader().searchForClass(typeName);
    }
 catch (    ClassNotFoundException e) {
      throw new ASTClassNotFoundException(typeName);
    }
  }
 else {
    if (!_eclipse_anonymous_scheme) {
      try {
        if (!(node.getParent() instanceof CompilationUnit) && !(node.getParent() instanceof TypeDeclaration))         currentClass=_state.getClassLoader().searchForClass(currentClass.getName() + ""String_Node_Str"" + typeName);
 else         currentClass=_state.getClassLoader().searchForClass(currentClass.getName() + ""String_Node_Str"" + typeName);
        typeName=currentClass.getName();
      }
 catch (      ClassNotFoundException e) {
        _eclipse_anonymous_scheme=true;
      }
    }
    if (_eclipse_anonymous_scheme) {
      try {
        typeName=currentClass.getName() + ""String_Node_Str"" + typeName;
        currentClass=_state.getClassLoader().searchForClass(typeName);
      }
 catch (      ClassNotFoundException e) {
        throw new ASTClassNotFoundException(typeName);
      }
    }
  }
  _state.enterClass(currentClass);
  addCrossAnalyzedType(currentClass.getName());
  _openScope();
  _state.setClassScope();
  _recordFields();
  _sortBodyDeclarations(node);
  if (_handlers.hasClassHandler()) {
    List handlerList=_handlers.getClassHandlers();
    Iterator handlersIter=handlerList.iterator();
    while (handlersIter.hasNext()) {
      ClassHandler handler=(ClassHandler)handlersIter.next();
      handler.enter(node,_state);
    }
  }
  return super.visit(node);
}"
75084,"/** 
 * Get the shortest possible name of the a class. If there is no conflict, the class is first imported, and only the simple class is returned; otherwise, the its full name is returned.
 * @param name The full class name. It must not be the name of an arraytype.
 * @param loader The class loader used to test importation conflicts.
 * @param root The root of the AST. If there is no conflict and the classhas not been imported yet, a new  {@link ImportDeclaration} is added toit.
 * @return The shortest possible class name.
 */
private static String _getNonarrayClassName(String name,TypeAnalyzerState state,CompilationUnit root){
  LocalClassLoader loader=state.getClassLoader();
  int lastDot=name.lastIndexOf('.');
  String packageName=lastDot == -1 ? ""String_Node_Str"" : name.substring(0,lastDot);
  String className=name.substring(lastDot + 1);
  String simpleName;
  int lastSeparator=lastIndexOf(name,new char[]{'.','$'});
  if (lastSeparator == -1)   return name;
 else   simpleName=name.substring(lastSeparator + 1);
  if (name.equals(state.getCurrentClass().getName()))   return simpleName;
  Iterator importedClasses=loader.getImportedClasses().iterator();
  while (importedClasses.hasNext()) {
    ClassImport importedClass=(ClassImport)importedClasses.next();
    if (importedClass.getPackageName().equals(packageName) && importedClass.getClassName().equals(className))     return simpleName;
 else {
      String importedName=importedClass.getClassName();
      int lastDollar=importedName.lastIndexOf('$');
      if (lastDollar == -1 && importedName.equals(simpleName))       return name;
 else       if (lastDollar >= 0 && importedName.substring(lastDollar + 1).equals(simpleName))       return name;
    }
  }
  Iterator importedPackages=loader.getImportedPackages().iterator();
  while (importedPackages.hasNext()) {
    String importedPackage=(String)importedPackages.next();
    if (importedPackage.equals(packageName))     return simpleName;
 else {
      try {
        loader.loadClass(importedPackage + ""String_Node_Str"" + simpleName);
        return name;
      }
 catch (      ClassNotFoundException e) {
      }
    }
  }
  AST ast=root.getAST();
  ImportDeclaration declaration=ast.newImportDeclaration();
  declaration.setName(createName(ast,name));
  root.imports().add(declaration);
  loader.importClass(name);
  return simpleName;
}","/** 
 * Get the shortest possible name of the a class. If there is no conflict, the class is first imported, and only the simple class is returned; otherwise, the its full name is returned.
 * @param name The full class name. It must not be the name of an arraytype.
 * @param loader The class loader used to test importation conflicts.
 * @param root The root of the AST. If there is no conflict and the classhas not been imported yet, a new  {@link ImportDeclaration} is added toit.
 * @return The shortest possible class name.
 */
private static String _getNonarrayClassName(String name,TypeAnalyzerState state,CompilationUnit root){
  LocalClassLoader loader=state.getClassLoader();
  int lastDot=name.lastIndexOf('.');
  String packageName=lastDot == -1 ? ""String_Node_Str"" : name.substring(0,lastDot);
  String className=name.substring(lastDot + 1);
  String simpleName;
  int lastSeparator=lastIndexOf(name,new char[]{'.','$'});
  if (lastSeparator == -1)   return name;
 else   simpleName=name.substring(lastSeparator + 1);
  String currentClassName=state.getCurrentClass().getName();
  if (name.equals(currentClassName))   return simpleName;
 else {
    int dollarPos=currentClassName.length();
    while (dollarPos >= 0) {
      String baseName=currentClassName.substring(0,dollarPos) + ""String_Node_Str"";
      if (name.startsWith(baseName))       return name.substring(baseName.length());
      dollarPos=currentClassName.lastIndexOf('$',dollarPos - 1);
    }
  }
  Iterator importedClasses=loader.getImportedClasses().iterator();
  while (importedClasses.hasNext()) {
    ClassImport importedClass=(ClassImport)importedClasses.next();
    if (importedClass.getPackageName().equals(packageName) && importedClass.getClassName().equals(className))     return simpleName;
 else {
      String importedName=importedClass.getClassName();
      int lastDollar=importedName.lastIndexOf('$');
      if (lastDollar == -1 && importedName.equals(simpleName))       return name;
 else       if (lastDollar >= 0 && importedName.substring(lastDollar + 1).equals(simpleName))       return name;
    }
  }
  Iterator importedPackages=loader.getImportedPackages().iterator();
  while (importedPackages.hasNext()) {
    String importedPackage=(String)importedPackages.next();
    if (importedPackage.equals(packageName))     return simpleName;
 else {
      try {
        loader.loadClass(importedPackage + ""String_Node_Str"" + simpleName);
        return name;
      }
 catch (      ClassNotFoundException e) {
      }
    }
  }
  AST ast=root.getAST();
  ImportDeclaration declaration=ast.newImportDeclaration();
  declaration.setName(createName(ast,name));
  root.imports().add(declaration);
  loader.importClass(name);
  return simpleName;
}"
75085,"/** 
 * Add a handler (@link AssignmentTransformer) to the type analyzer. The handler refactors the AST while the type analyzer traverses it.
 * @param analyzer The type analyzer.
 * @param root The root of the AST.
 */
public void beforeTraverse(TypeAnalyzer analyzer,CompilationUnit root){
  AssignmentTransformer assignmentTransformer=new AssignmentTransformer();
  ConstructorTransformer constructorTransformer=new ConstructorTransformer();
  _handlers.add(assignmentTransformer);
  _handlers.add(constructorTransformer);
  analyzer.getHandlers().addAliasHandler(assignmentTransformer);
  analyzer.getHandlers().addAssignmentHandler(assignmentTransformer);
  analyzer.getHandlers().addClassHandler(assignmentTransformer);
  analyzer.getHandlers().addCrossAnalysisHandler(assignmentTransformer);
  analyzer.getHandlers().addClassHandler(constructorTransformer);
  analyzer.getHandlers().addConstructorHandler(constructorTransformer);
  analyzer.getHandlers().addCrossAnalysisHandler(constructorTransformer);
  analyzer.getHandlers().addMethodDeclarationHandler(constructorTransformer);
}","/** 
 * Add a handler (@link AssignmentTransformer) to the type analyzer. The handler refactors the AST while the type analyzer traverses it.
 * @param analyzer The type analyzer.
 * @param root The root of the AST.
 */
public void beforeTraverse(TypeAnalyzer analyzer,CompilationUnit root){
  AssignmentTransformer assignmentTransformer=new AssignmentTransformer();
  ConstructorTransformer constructorTransformer=new ConstructorTransformer();
  _handlers.add(assignmentTransformer);
  _handlers.add(constructorTransformer);
  analyzer.getHandlers().addAliasHandler(assignmentTransformer);
  analyzer.getHandlers().addAssignmentHandler(assignmentTransformer);
  analyzer.getHandlers().addClassHandler(assignmentTransformer);
  analyzer.getHandlers().addCrossAnalysisHandler(assignmentTransformer);
  analyzer.getHandlers().addMethodDeclarationHandler(assignmentTransformer);
  analyzer.getHandlers().addClassHandler(constructorTransformer);
  analyzer.getHandlers().addConstructorHandler(constructorTransformer);
  analyzer.getHandlers().addCrossAnalysisHandler(constructorTransformer);
  analyzer.getHandlers().addMethodDeclarationHandler(constructorTransformer);
}"
75086,"/** 
 * Resolve a method in the given class with an array of arguments.
 * @param owner The class where the method belongs to. If it is null, the current class is assumed, and all the enclosing classes are searched, if necessary.
 * @param methodName The name of the method.
 * @param arguments The array of arguments.
 * @return The return type and the owner of the method, or <tt>null</tt>if the method cannot be found.
 * @see #_getMethodType(Class,String,Type[])
 */
private TypeAndOwner _resolveMethod(Class owner,String methodName,Type[] arguments){
  Set handledSet=new HashSet();
  Stack previousClasses=_state.getPreviousClasses();
  int previousNum=previousClasses.size();
  Class oldOwner=owner;
  if (owner == null)   owner=_state.getCurrentClass();
  do {
    Type type=_getMethodType(owner,methodName,arguments);
    if (type != null)     return new TypeAndOwner(type,Type.createType(owner.getName()));
    handledSet.add(owner);
    owner=null;
    if (oldOwner == null)     while (owner == null && previousNum > 0) {
      owner=(Class)previousClasses.get(--previousNum);
      if (handledSet.contains(owner))       owner=null;
    }
  }
 while (owner != null);
  return null;
}","/** 
 * Resolve a method in the given class with an array of arguments.
 * @param owner The class where the method belongs to. If it is null, the current class is assumed, and all the enclosing classes are searched, if necessary.
 * @param methodName The name of the method.
 * @param arguments The array of arguments.
 * @return The return type and the owner of the method, or <tt>null</tt>if the method cannot be found.
 * @see #_getMethodType(Class,String,Type[])
 */
private TypeAndOwner _resolveMethod(Class owner,String methodName,Type[] arguments){
  Set handledSet=new HashSet();
  Stack previousClasses=_state.getPreviousClasses();
  int previousNum=previousClasses.size();
  Class oldOwner=owner;
  if (owner == null)   owner=_state.getCurrentClass();
  do {
    Type type=_getMethodType(owner,methodName,arguments);
    if (type != null)     return new TypeAndOwner(type,Type.createType(owner.getName()));
    handledSet.add(owner);
    owner=null;
    if (oldOwner == null)     while (owner == null && previousNum > 0) {
      previousNum--;
      Object previousObject=previousClasses.get(previousNum);
      if (previousObject instanceof Class) {
        owner=(Class)previousObject;
        if (handledSet.contains(owner))         owner=null;
      }
    }
  }
 while (owner != null);
  return null;
}"
75087,"/** 
 * Resolve a simple name within the scope of the given type. The name can be a variable name, a field name, or a class relative to that type. If the name corresponds to a field of a class, its owner is encoded in the return object.
 * @param name The simple name to be resolved.
 * @param lastType The type from which the name is resolved. It is used asthe scope for the name. If it is null, the name is resolved in the current scope.
 * @return The type and owner of the name. If the name cannot be found, <tt>null</tt> is returned.
 */
private TypeAndOwner _resolveName(String name,Type lastType){
  if (_state.getCurrentClass() == null)   return null;
  if (lastType == null) {
    TypeAndOwner varTypeAndOwner=_findVariable(name);
    if (varTypeAndOwner != null)     return varTypeAndOwner;
    Class c=_lookupClass(name);
    if (c != null)     return new TypeAndOwner(Type.createType(c.getName()),null);
  }
  TypeAndOwner typeAndOwner;
  if (lastType == null)   typeAndOwner=_resolveNameFromClass(_state.getCurrentClass(),name);
 else   try {
    typeAndOwner=_resolveNameFromClass(lastType.toClass(_state.getClassLoader()),name);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(lastType);
  }
  if (typeAndOwner == null && lastType == null) {
    Stack previousClasses=_state.getPreviousClasses();
    int previousNumber=previousClasses.size() - 1;
    while (typeAndOwner == null && previousNumber >= 0) {
      Class previousClass=(Class)previousClasses.get(previousNumber--);
      if (previousClass != null)       typeAndOwner=_resolveNameFromClass(previousClass,name);
    }
  }
  return typeAndOwner;
}","/** 
 * Resolve a simple name within the scope of the given type. The name can be a variable name, a field name, or a class relative to that type. If the name corresponds to a field of a class, its owner is encoded in the return object.
 * @param name The simple name to be resolved.
 * @param lastType The type from which the name is resolved. It is used asthe scope for the name. If it is null, the name is resolved in the current scope.
 * @return The type and owner of the name. If the name cannot be found, <tt>null</tt> is returned.
 */
private TypeAndOwner _resolveName(String name,Type lastType){
  if (_state.getCurrentClass() == null)   return null;
  if (lastType == null) {
    TypeAndOwner varTypeAndOwner=_findVariable(name);
    if (varTypeAndOwner != null)     return varTypeAndOwner;
    Class c=_lookupClass(name);
    if (c != null)     return new TypeAndOwner(Type.createType(c.getName()),null);
  }
  TypeAndOwner typeAndOwner;
  if (lastType == null)   typeAndOwner=_resolveNameFromClass(_state.getCurrentClass(),name);
 else   try {
    typeAndOwner=_resolveNameFromClass(lastType.toClass(_state.getClassLoader()),name);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(lastType);
  }
  if (typeAndOwner == null && lastType == null) {
    Stack previousClasses=_state.getPreviousClasses();
    int previousNumber=previousClasses.size() - 1;
    while (typeAndOwner == null && previousNumber >= 0) {
      Object previousObject=previousClasses.get(previousNumber--);
      if (previousObject instanceof Class) {
        Class previousClass=(Class)previousObject;
        if (previousClass != null)         typeAndOwner=_resolveNameFromClass(previousClass,name);
      }
    }
  }
  return typeAndOwner;
}"
75088,"/** 
 * Lookup a class with a partially given name as may appear in Java source code. The name may be relative to the current class and its enclosing classes. It may also be a full name.
 * @param partialSimpleName The partially given classname.
 * @return The class; <tt>null</tt> is returned if theclass cannot be found.
 */
private Class _lookupClass(String partialSimpleName){
  int dotPos=partialSimpleName.indexOf('.');
  String simpleName;
  if (dotPos == -1)   simpleName=partialSimpleName;
 else   simpleName=partialSimpleName.substring(0,dotPos);
  Class result=null;
  Stack previousClasses=_state.getPreviousClasses();
  int previousNumber=previousClasses.size();
  for (int i=previousNumber; i >= 0; i--) {
    Class workingClass=i == previousNumber ? _state.getCurrentClass() : (Class)previousClasses.get(i);
    if (workingClass != null) {
      if (_getSimpleClassName(workingClass).equals(simpleName)) {
        result=workingClass;
        break;
      }
      Class[] declaredClasses=workingClass.getDeclaredClasses();
      for (int j=0; j < declaredClasses.length; j++)       if (_getSimpleClassName(declaredClasses[j]).equals(simpleName)) {
        result=declaredClasses[j];
        break;
      }
      if (result != null)       break;
    }
  }
  if (result == null && _importedClasses.containsKey(simpleName))   result=(Class)_importedClasses.get(simpleName);
  if (result != null && dotPos >= 0)   try {
    result=_state.getClassLoader().loadClass(result.getName() + partialSimpleName.substring(dotPos));
  }
 catch (  ClassNotFoundException e) {
    result=null;
  }
  if (result == null)   try {
    result=_state.getClassLoader().searchForClass(partialSimpleName);
  }
 catch (  ClassNotFoundException e) {
  }
  return result;
}","/** 
 * Lookup a class with a partially given name as may appear in Java source code. The name may be relative to the current class and its enclosing classes. It may also be a full name.
 * @param partialSimpleName The partially given classname.
 * @return The class; <tt>null</tt> is returned if theclass cannot be found.
 */
private Class _lookupClass(String partialSimpleName){
  int dotPos=partialSimpleName.indexOf('.');
  String simpleName;
  if (dotPos == -1)   simpleName=partialSimpleName;
 else   simpleName=partialSimpleName.substring(0,dotPos);
  Class result=null;
  if (result == null) {
    Stack previousClasses=_state.getPreviousClasses();
    int previousNumber=previousClasses.size();
    for (int i=previousNumber; i >= 0; i--) {
      Class workingClass=null;
      if (i == previousNumber)       workingClass=_state.getCurrentClass();
 else {
        Object previousObject=previousClasses.get(i);
        if (previousObject instanceof Class)         workingClass=(Class)previousObject;
 else         if (previousObject != null) {
          Hashtable previousTable=(Hashtable)previousObject;
          if (previousTable != null && previousTable.keySet().contains(simpleName)) {
            result=(Class)previousTable.get(simpleName);
            break;
          }
        }
      }
      if (workingClass != null) {
        if (_getSimpleClassName(workingClass).equals(simpleName)) {
          result=workingClass;
          break;
        }
        Class[] declaredClasses=workingClass.getDeclaredClasses();
        for (int j=0; j < declaredClasses.length; j++)         if (_getSimpleClassName(declaredClasses[j]).equals(simpleName)) {
          result=declaredClasses[j];
          break;
        }
        if (result != null)         break;
      }
    }
  }
  if (result == null && _importedClasses.containsKey(simpleName))   result=(Class)_importedClasses.get(simpleName);
  if (result != null && dotPos >= 0)   try {
    result=_state.getClassLoader().loadClass(result.getName() + partialSimpleName.substring(dotPos));
  }
 catch (  ClassNotFoundException e) {
    result=null;
  }
  if (result == null)   try {
    result=_state.getClassLoader().searchForClass(partialSimpleName);
  }
 catch (  ClassNotFoundException e) {
  }
  return result;
}"
75089,"/** 
 * Get the previous class stack. The previous class stack stores all the entered but not exited class definitions, not including the current class. Each element in the stack is of type   {@link Class}. The bottom element in the stack is always <tt>null</tt>.
 * @return The previous class stack.
 * @see #setPreviousClasses(Stack)
 */
public Stack getPreviousClasses(){
  return _previousClasses;
}","/** 
 * Get the previous class stack. The previous class stack stores all the entered but not exited class definitions as well as blocks, not including the current class. Each element in the stack is either of type   {@link Class} or type {@link Hashtable}. The bottom element in the stack is always <tt>null</tt>. <p> An element of type   {@link Hashtable} means the previous entity isa block, where classes can also be defined in it. In that case, simple class names are the keys of the table, and  {@link Class}objects are its values.
 * @return The previous class stack.
 * @see #setPreviousClasses(Stack)
 */
public Stack getPreviousClasses(){
  return _previousClasses;
}"
75090,"/** 
 * Create an AST name node with a name string (possibly partitioned with ""."").
 * @param ast The {@link AST} object.
 * @param name The name.
 * @return The AST name node.
 */
public static Name createName(AST ast,String name){
  int oldPos=0;
  Name fullName=null;
  while (oldPos != -1) {
    int pos=indexOf(name,new char[]{'.','$'},oldPos);
    String subname=pos == -1 ? name.substring(oldPos) : name.substring(oldPos,pos);
    if (fullName == null)     fullName=ast.newSimpleName(subname);
 else     fullName=ast.newQualifiedName(fullName,ast.newSimpleName(subname));
    if (pos == -1)     oldPos=-1;
 else     oldPos=pos + 1;
  }
  return fullName;
}","/** 
 * Create an AST name node with a name string (possibly partitioned with ""."").
 * @param ast The {@link AST} object.
 * @param name The name.
 * @return The AST name node.
 */
public static Name createName(AST ast,String name){
  int oldPos=0;
  Name fullName=null;
  while (oldPos != -1) {
    int pos=indexOf(name,new char[]{'.','$'},oldPos);
    String subname=pos == -1 ? name.substring(oldPos) : name.substring(oldPos,pos);
    char c=subname.charAt(0);
    while (c >= '0' && c <= '9') {
      subname=subname.substring(1);
      c=subname.charAt(0);
    }
    if (fullName == null)     fullName=ast.newSimpleName(subname);
 else     fullName=ast.newQualifiedName(fullName,ast.newSimpleName(subname));
    if (pos == -1)     oldPos=-1;
 else     oldPos=pos + 1;
  }
  return fullName;
}"
75091,"/** 
 * Handle an alias expression. If the expression is not aliased (e.g., an expression corresponding to an object or a primitive integer cannot be aliased), nothing is done. If it can be aliased, in the refactored result, the expression's <tt>clone</tt> method is called and the copy is used as the record.
 * @param node The node that may be aliased.
 * @param state The current state of the type analyzer.
 * @return The new node if the given node is an alias, or <tt>null</tt>otherwise.
 */
private Expression _handleAlias(Expression node,TypeAnalyzerState state){
  Type owner=Type.getOwner(node);
  if (owner == null)   return null;
  String ownerName=owner.getName();
  Type type=Type.getType(node);
  String typeName=type.getName();
  Expression array=node;
  Type arrayType=type;
  boolean needRefactor=type.isArray();
  if (node instanceof ArrayAccess) {
    ArrayAccess arrayAccess=(ArrayAccess)node;
    while (arrayAccess.getArray() instanceof ArrayAccess) {
      arrayAccess=(ArrayAccess)arrayAccess.getArray();
      arrayType=arrayType.addOneDimension();
    }
    array=arrayAccess.getArray();
    arrayType=arrayType.addOneDimension();
    if (array instanceof MethodInvocation)     needRefactor=false;
  }
  if (needRefactor)   if (state.getCurrentClass().getName().equals(ownerName))   needRefactor=true;
 else {
    Iterator previousClasses=state.getPreviousClasses().iterator();
    while (previousClasses.hasNext()) {
      Class previous=(Class)previousClasses.next();
      if (previous != null && previous.getName().equals(ownerName))       needRefactor=true;
    }
  }
  if (needRefactor) {
    AST ast=node.getAST();
    CompilationUnit root=(CompilationUnit)node.getRoot();
    String typeClassName=getClassName(typeName,state,root);
    int nIndices=0;
    Expression nodeIterator=node;
    while (nodeIterator instanceof ParenthesizedExpression)     nodeIterator=((ParenthesizedExpression)nodeIterator).getExpression();
    List indices=new LinkedList();
    while (nodeIterator instanceof ArrayAccess) {
      nIndices++;
      ArrayAccess arrayAccess=(ArrayAccess)nodeIterator;
      indices.add(0,ASTNode.copySubtree(ast,arrayAccess.getIndex()));
      nodeIterator=arrayAccess.getArray();
      while (nodeIterator instanceof ParenthesizedExpression)       nodeIterator=((ParenthesizedExpression)nodeIterator).getExpression();
    }
    Expression newObject=null;
    SimpleName name;
    if (nodeIterator instanceof FieldAccess) {
      Expression object=((FieldAccess)nodeIterator).getExpression();
      name=((FieldAccess)nodeIterator).getName();
      newObject=(Expression)ASTNode.copySubtree(ast,object);
    }
 else     if (nodeIterator instanceof QualifiedName) {
      Name object=((QualifiedName)nodeIterator).getQualifier();
      name=((QualifiedName)nodeIterator).getName();
      newObject=(Expression)ASTNode.copySubtree(ast,object);
    }
 else     if (nodeIterator instanceof SimpleName)     name=(SimpleName)nodeIterator;
 else     return null;
    Class ownerClass;
    boolean isStatic;
    try {
      ownerClass=owner.toClass(state.getClassLoader());
      Field field=ownerClass.getDeclaredField(name.getIdentifier());
      int modifiers=field.getModifiers();
      if (!java.lang.reflect.Modifier.isPrivate(modifiers))       return null;
      isStatic=java.lang.reflect.Modifier.isStatic(modifiers);
    }
 catch (    ClassNotFoundException e) {
      throw new ASTClassNotFoundException(owner.getName());
    }
catch (    NoSuchFieldException e) {
      return null;
    }
    if (isStatic && !HANDLE_STATIC_FIELDS)     return null;
    MethodInvocation backup=ast.newMethodInvocation();
    if (newObject != null)     backup.setExpression(newObject);
    SimpleName newName=ast.newSimpleName(_getBackupMethodName(name.getIdentifier()));
    backup.setName(newName);
    if (isStatic)     backup.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
    backup.arguments().addAll(indices);
    replaceNode(node,backup);
    _recordField(_backupFields,owner.getName(),name.getIdentifier(),nIndices);
    return backup;
  }
  return null;
}","/** 
 * Handle an alias expression. If the expression is not aliased (e.g., an expression corresponding to an object or a primitive integer cannot be aliased), nothing is done. If it can be aliased, in the refactored result, the expression's <tt>clone</tt> method is called and the copy is used as the record.
 * @param node The node that may be aliased.
 * @param state The current state of the type analyzer.
 * @return The new node if the given node is an alias, or <tt>null</tt>otherwise.
 */
private Expression _handleAlias(Expression node,TypeAnalyzerState state){
  Type owner=Type.getOwner(node);
  if (owner == null)   return null;
  String ownerName=owner.getName();
  Type type=Type.getType(node);
  String typeName=type.getName();
  Expression array=node;
  Type arrayType=type;
  boolean needRefactor=type.isArray();
  if (node instanceof ArrayAccess) {
    ArrayAccess arrayAccess=(ArrayAccess)node;
    while (arrayAccess.getArray() instanceof ArrayAccess) {
      arrayAccess=(ArrayAccess)arrayAccess.getArray();
      arrayType=arrayType.addOneDimension();
    }
    array=arrayAccess.getArray();
    arrayType=arrayType.addOneDimension();
    if (array instanceof MethodInvocation)     needRefactor=false;
  }
  if (needRefactor) {
    AST ast=node.getAST();
    CompilationUnit root=(CompilationUnit)node.getRoot();
    String typeClassName=getClassName(typeName,state,root);
    int nIndices=0;
    Expression nodeIterator=node;
    while (nodeIterator instanceof ParenthesizedExpression)     nodeIterator=((ParenthesizedExpression)nodeIterator).getExpression();
    List indices=new LinkedList();
    while (nodeIterator instanceof ArrayAccess) {
      nIndices++;
      ArrayAccess arrayAccess=(ArrayAccess)nodeIterator;
      indices.add(0,ASTNode.copySubtree(ast,arrayAccess.getIndex()));
      nodeIterator=arrayAccess.getArray();
      while (nodeIterator instanceof ParenthesizedExpression)       nodeIterator=((ParenthesizedExpression)nodeIterator).getExpression();
    }
    Expression newObject=null;
    SimpleName name;
    if (nodeIterator instanceof FieldAccess) {
      Expression object=((FieldAccess)nodeIterator).getExpression();
      name=((FieldAccess)nodeIterator).getName();
      newObject=(Expression)ASTNode.copySubtree(ast,object);
    }
 else     if (nodeIterator instanceof QualifiedName) {
      Name object=((QualifiedName)nodeIterator).getQualifier();
      name=((QualifiedName)nodeIterator).getName();
      newObject=(Expression)ASTNode.copySubtree(ast,object);
    }
 else     if (nodeIterator instanceof SimpleName)     name=(SimpleName)nodeIterator;
 else     return null;
    Class ownerClass;
    boolean isStatic;
    try {
      ownerClass=owner.toClass(state.getClassLoader());
      Field field=ownerClass.getDeclaredField(name.getIdentifier());
      int modifiers=field.getModifiers();
      if (!java.lang.reflect.Modifier.isPrivate(modifiers))       return null;
      isStatic=java.lang.reflect.Modifier.isStatic(modifiers);
    }
 catch (    ClassNotFoundException e) {
      throw new ASTClassNotFoundException(owner.getName());
    }
catch (    NoSuchFieldException e) {
      return null;
    }
    if (isStatic && !HANDLE_STATIC_FIELDS)     return null;
    MethodInvocation backup=ast.newMethodInvocation();
    if (newObject != null)     backup.setExpression(newObject);
    SimpleName newName=ast.newSimpleName(_getBackupMethodName(name.getIdentifier()));
    backup.setName(newName);
    if (isStatic)     backup.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
    backup.arguments().addAll(indices);
    replaceNode(node,backup);
    _recordField(_backupFields,owner.getName(),name.getIdentifier(),nIndices);
    return backup;
  }
  return null;
}"
75092,"/** 
 * Transform a set of files into backtracking-enabled ones. The set of files is given by an array of strings as their names, or the names of the directories that contain them. If a string in the array is a file name, it is refactored and the output is printed out; if it is the name of a directory, all Java files in the directory and its sub-directories are looked up and refactored in the same way.
 * @param args The array of file names or names of directories.
 * @exception Exception If any exception occues.
 */
public static void main(String[] args) throws Exception {
  boolean outputResult=true;
  if (args.length == 0)   _printUsage();
 else {
    String[] paths=PathFinder.getPtClassPaths();
    Writer standardWriter=outputResult ? new OutputStreamWriter(System.out) : null;
    int start=0;
    while (start < args.length) {
      int newPosition=_parseArguments(args,start);
      if (newPosition != start)       start=newPosition;
 else       break;
    }
    if (_extraClassPaths != null) {
      String[] morePaths=new String[paths.length + _extraClassPaths.length];
      System.arraycopy(paths,0,morePaths,0,paths.length);
      System.arraycopy(_extraClassPaths,0,morePaths,paths.length,_extraClassPaths.length);
      paths=morePaths;
    }
    List fileList=new LinkedList();
    List crossAnalysis=new LinkedList();
    for (int i=start; i < args.length; i++) {
      String pathOrFile=args[i];
      File[] files;
      if (pathOrFile.startsWith(""String_Node_Str"")) {
        String listName=pathOrFile.substring(1);
        BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(listName)));
        List strings=new LinkedList();
        String line=reader.readLine();
        while (line != null) {
          strings.add(line);
          line=reader.readLine();
        }
        files=new File[strings.size()];
        Iterator stringsIter=strings.iterator();
        for (int j=0; stringsIter.hasNext(); j++)         files[j]=new File((String)stringsIter.next());
      }
 else       files=PathFinder.getJavaFiles(pathOrFile,true);
      ClassFileLoader loader=new ClassFileLoader();
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        if (fileName.endsWith(""String_Node_Str""))         fileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
 else {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str"");
          continue;
        }
        Class c=null;
        try {
          c=loader.loadClass(new File(fileName));
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
          continue;
        }
        fileList.add(files[j]);
        crossAnalysis.add(c.getName());
      }
    }
    String[] crossAnalyzedTypes=new String[crossAnalysis.size()];
    Iterator crossAnalysisIter=crossAnalysis.iterator();
    for (int i=0; crossAnalysisIter.hasNext(); i++)     crossAnalyzedTypes[i]=(String)crossAnalysisIter.next();
    Iterator filesIter=fileList.iterator();
    while (filesIter.hasNext()) {
      File file=(File)filesIter.next();
      String fileName=file.getPath();
      System.err.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
      transform(file.getPath(),standardWriter,paths,crossAnalyzedTypes);
      if (outputResult)       standardWriter.flush();
    }
    _outputConfig();
    if (outputResult)     standardWriter.close();
  }
}","/** 
 * Transform a set of files into backtracking-enabled ones. The set of files is given by an array of strings as their names, or the names of the directories that contain them. If a string in the array is a file name, it is refactored and the output is printed out; if it is the name of a directory, all Java files in the directory and its sub-directories are looked up and refactored in the same way.
 * @param args The array of file names or names of directories.
 * @exception Exception If any exception occues.
 */
public static void main(String[] args) throws Exception {
  boolean outputResult=true;
  if (args.length == 0)   _printUsage();
 else {
    String[] paths=PathFinder.getPtClassPaths();
    Writer standardWriter=outputResult ? new OutputStreamWriter(System.out) : null;
    int start=0;
    while (start < args.length) {
      int newPosition=_parseArguments(args,start);
      if (newPosition != start)       start=newPosition;
 else       break;
    }
    if (_extraClassPaths != null) {
      String[] morePaths=new String[paths.length + _extraClassPaths.length];
      System.arraycopy(paths,0,morePaths,0,paths.length);
      System.arraycopy(_extraClassPaths,0,morePaths,paths.length,_extraClassPaths.length);
      paths=morePaths;
    }
    List fileList=new LinkedList();
    Set crossAnalysis=new HashSet();
    for (int i=start; i < args.length; i++) {
      String pathOrFile=args[i];
      File[] files;
      if (pathOrFile.startsWith(""String_Node_Str"")) {
        String listName=pathOrFile.substring(1);
        BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(listName)));
        List strings=new LinkedList();
        String line=reader.readLine();
        while (line != null) {
          strings.add(line);
          line=reader.readLine();
        }
        files=new File[strings.size()];
        Iterator stringsIter=strings.iterator();
        for (int j=0; stringsIter.hasNext(); j++)         files[j]=new File((String)stringsIter.next());
      }
 else       files=PathFinder.getJavaFiles(pathOrFile,true);
      ClassFileLoader loader=new ClassFileLoader();
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        if (fileName.endsWith(""String_Node_Str""))         fileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
 else {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str"");
          continue;
        }
        Class c=null;
        try {
          c=loader.loadClass(new File(fileName));
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + files[j] + ""String_Node_Str""+ ""String_Node_Str""+ e.getMessage());
          continue;
        }
        fileList.add(files[j]);
        crossAnalysis.add(c.getName());
        _addInnerClasses(crossAnalysis,fileName,c.getPackage() == null ? null : c.getPackage().getName());
      }
    }
    String[] crossAnalyzedTypes=new String[crossAnalysis.size()];
    Iterator crossAnalysisIter=crossAnalysis.iterator();
    for (int i=0; crossAnalysisIter.hasNext(); i++)     crossAnalyzedTypes[i]=(String)crossAnalysisIter.next();
    Iterator filesIter=fileList.iterator();
    while (filesIter.hasNext()) {
      File file=(File)filesIter.next();
      String fileName=file.getPath();
      System.err.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
      transform(file.getPath(),standardWriter,paths,crossAnalyzedTypes);
      if (outputResult)       standardWriter.flush();
    }
    _outputConfig();
    if (outputResult)     standardWriter.close();
  }
}"
75093,"private MethodDeclaration _createGetCheckpointMethod(AST ast,CompilationUnit root,TypeAnalyzerState state,boolean isAnonymous){
  String methodName=_getGetCheckpointMethodName(isAnonymous);
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  if (hasMethod(currentClass,methodName,new Class[0]))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  if (parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName())) || hasMethod(parent,methodName,new Class[]{Checkpoint.class}))   return null;
  MethodDeclaration method=ast.newMethodDeclaration();
  method.setName(ast.newSimpleName(methodName));
  String typeName=getClassName(Checkpoint.class,state,root);
  method.setReturnType(createType(ast,typeName));
  Block body=ast.newBlock();
  method.setBody(body);
  ReturnStatement returnStatement=ast.newReturnStatement();
  returnStatement.setExpression(ast.newSimpleName(CHECKPOINT_NAME));
  body.statements().add(returnStatement);
  method.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  addToLists(_checkParentMethods,parent.getName(),method);
  return method;
}","private MethodDeclaration _createGetCheckpointMethod(AST ast,CompilationUnit root,TypeAnalyzerState state,boolean isAnonymous){
  String methodName=_getGetCheckpointMethodName(isAnonymous);
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  if (hasMethod(currentClass,methodName,new Class[0]))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  if (!isAnonymous && parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName()) || hasMethod(parent,methodName,new Class[]{})))   return null;
  MethodDeclaration method=ast.newMethodDeclaration();
  method.setName(ast.newSimpleName(methodName));
  String typeName=getClassName(Checkpoint.class,state,root);
  method.setReturnType(createType(ast,typeName));
  Block body=ast.newBlock();
  method.setBody(body);
  ReturnStatement returnStatement=ast.newReturnStatement();
  returnStatement.setExpression(ast.newSimpleName(CHECKPOINT_NAME));
  body.statements().add(returnStatement);
  method.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  if (!isAnonymous)   addToLists(_checkParentMethods,parent.getName(),method);
  return method;
}"
75094,"/** 
 * Create the field declaration for the checkpoint record.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @return The field declaration, or <tt>null</tt> if the field alreadyexists in the class or its superclasses.
 */
private FieldDeclaration _createCheckpointRecord(AST ast,CompilationUnit root,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  if (parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName()) || isFieldDuplicated(parent,CHECKPOINT_NAME)))   return null;
  VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
  fragment.setName(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
  ClassInstanceCreation creation=ast.newClassInstanceCreation();
  String typeName=getClassName(CheckpointRecord.class,state,root);
  creation.setName(createName(ast,typeName));
  fragment.setInitializer(creation);
  FieldDeclaration record=ast.newFieldDeclaration(fragment);
  record.setType(createType(ast,typeName));
  record.setModifiers(Modifier.PRIVATE);
  addToLists(_checkParentFields,parent.getName(),record);
  return record;
}","/** 
 * Create the field declaration for the checkpoint record.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @return The field declaration, or <tt>null</tt> if the field alreadyexists in the class or its superclasses.
 */
private FieldDeclaration _createCheckpointRecord(AST ast,CompilationUnit root,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  if (parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName()) || isFieldDuplicated(parent,CHECKPOINT_RECORD_NAME)))   return null;
  VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
  fragment.setName(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
  ClassInstanceCreation creation=ast.newClassInstanceCreation();
  String typeName=getClassName(CheckpointRecord.class,state,root);
  creation.setName(createName(ast,typeName));
  fragment.setInitializer(creation);
  FieldDeclaration record=ast.newFieldDeclaration(fragment);
  record.setType(createType(ast,typeName));
  record.setModifiers(Modifier.PROTECTED);
  addToLists(_checkParentFields,parent.getName(),record);
  return record;
}"
75095,"/** 
 * Create a set checkpoint method for a class, which sets its checkpoint object.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @param isAnonymous Whether the current class is anonymous.
 * @return The declaration of the method that sets the checkpoint object.
 */
private MethodDeclaration _createSetCheckpointMethod(AST ast,CompilationUnit root,TypeAnalyzerState state,boolean isAnonymous){
  String methodName=_getSetCheckpointMethodName(isAnonymous);
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  if (hasMethod(currentClass,methodName,new Class[]{Checkpoint.class},true))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  if (parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName())) || hasMethod(parent,methodName,new Class[]{Checkpoint.class}))   return null;
  MethodDeclaration method=ast.newMethodDeclaration();
  method.setName(ast.newSimpleName(methodName));
  SingleVariableDeclaration checkpoint=ast.newSingleVariableDeclaration();
  String checkpointType=getClassName(Checkpoint.class,state,root);
  checkpoint.setType(createType(ast,checkpointType));
  checkpoint.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(checkpoint);
  method.setReturnType(createType(ast,getClassName(Object.class,state,root)));
  IfStatement test=ast.newIfStatement();
  InfixExpression testExpression=ast.newInfixExpression();
  testExpression.setLeftOperand(ast.newSimpleName(CHECKPOINT_NAME));
  testExpression.setOperator(InfixExpression.Operator.NOT_EQUALS);
  testExpression.setRightOperand(ast.newSimpleName(""String_Node_Str""));
  test.setExpression(testExpression);
  Block thenBranch=ast.newBlock();
  test.setThenStatement(thenBranch);
  Block body=ast.newBlock();
  body.statements().add(test);
  method.setBody(body);
  VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
  fragment.setName(ast.newSimpleName(""String_Node_Str""));
  fragment.setInitializer(ast.newSimpleName(CHECKPOINT_NAME));
  VariableDeclarationStatement tempDeclaration=ast.newVariableDeclarationStatement(fragment);
  tempDeclaration.setType(createType(ast,checkpointType));
  thenBranch.statements().add(tempDeclaration);
  IfStatement testNewCheckpoint=ast.newIfStatement();
  InfixExpression testNull=ast.newInfixExpression();
  testNull.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
  testNull.setOperator(InfixExpression.Operator.NOT_EQUALS);
  testNull.setRightOperand(ast.newNullLiteral());
  testNewCheckpoint.setExpression(testNull);
  Block testNewCheckpointBody=ast.newBlock();
  testNewCheckpoint.setThenStatement(testNewCheckpointBody);
  MethodInvocation record=ast.newMethodInvocation();
  record.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
  record.setName(ast.newSimpleName(""String_Node_Str""));
  record.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  MethodInvocation getTimestamp=ast.newMethodInvocation();
  getTimestamp.setExpression(ast.newSimpleName(""String_Node_Str""));
  getTimestamp.setName(ast.newSimpleName(""String_Node_Str""));
  record.arguments().add(getTimestamp);
  testNewCheckpointBody.statements().add(ast.newExpressionStatement(record));
  MethodInvocation pushStates=ast.newMethodInvocation();
  String recordType=getClassName(FieldRecord.class,state,root);
  pushStates.setExpression(createName(ast,recordType));
  pushStates.setName(ast.newSimpleName(""String_Node_Str""));
  pushStates.arguments().add(ast.newSimpleName(RECORDS_NAME));
  testNewCheckpointBody.statements().add(ast.newExpressionStatement(pushStates));
  thenBranch.statements().add(testNewCheckpoint);
  Assignment assignment=ast.newAssignment();
  assignment.setLeftHandSide(ast.newSimpleName(CHECKPOINT_NAME));
  assignment.setRightHandSide(ast.newSimpleName(""String_Node_Str""));
  ExpressionStatement statement=ast.newExpressionStatement(assignment);
  thenBranch.statements().add(statement);
  MethodInvocation propagate=ast.newMethodInvocation();
  propagate.setExpression(ast.newSimpleName(""String_Node_Str""));
  propagate.setName(ast.newSimpleName(""String_Node_Str""));
  propagate.arguments().add(ast.newSimpleName(""String_Node_Str""));
  thenBranch.statements().add(ast.newExpressionStatement(propagate));
  MethodInvocation addInvocation=ast.newMethodInvocation();
  addInvocation.setExpression(ast.newSimpleName(""String_Node_Str""));
  addInvocation.setName(ast.newSimpleName(""String_Node_Str""));
  addInvocation.arguments().add(_createRollbackableObject(ast,isAnonymous));
  thenBranch.statements().add(ast.newExpressionStatement(addInvocation));
  ReturnStatement returnStatement=ast.newReturnStatement();
  returnStatement.setExpression(ast.newThisExpression());
  body.statements().add(returnStatement);
  method.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  addToLists(_checkParentMethods,parent.getName(),method);
  return method;
}","/** 
 * Create a set checkpoint method for a class, which sets its checkpoint object.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @param isAnonymous Whether the current class is anonymous.
 * @return The declaration of the method that sets the checkpoint object.
 */
private MethodDeclaration _createSetCheckpointMethod(AST ast,CompilationUnit root,TypeAnalyzerState state,boolean isAnonymous){
  String methodName=_getSetCheckpointMethodName(isAnonymous);
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  if (hasMethod(currentClass,methodName,new Class[]{Checkpoint.class},true))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  if (!isAnonymous && parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName()) || hasMethod(parent,methodName,new Class[]{Checkpoint.class})))   return null;
  MethodDeclaration method=ast.newMethodDeclaration();
  method.setName(ast.newSimpleName(methodName));
  SingleVariableDeclaration checkpoint=ast.newSingleVariableDeclaration();
  String checkpointType=getClassName(Checkpoint.class,state,root);
  checkpoint.setType(createType(ast,checkpointType));
  checkpoint.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(checkpoint);
  method.setReturnType(createType(ast,getClassName(Object.class,state,root)));
  IfStatement test=ast.newIfStatement();
  InfixExpression testExpression=ast.newInfixExpression();
  testExpression.setLeftOperand(ast.newSimpleName(CHECKPOINT_NAME));
  testExpression.setOperator(InfixExpression.Operator.NOT_EQUALS);
  testExpression.setRightOperand(ast.newSimpleName(""String_Node_Str""));
  test.setExpression(testExpression);
  Block thenBranch=ast.newBlock();
  test.setThenStatement(thenBranch);
  Block body=ast.newBlock();
  body.statements().add(test);
  method.setBody(body);
  VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
  fragment.setName(ast.newSimpleName(""String_Node_Str""));
  fragment.setInitializer(ast.newSimpleName(CHECKPOINT_NAME));
  VariableDeclarationStatement tempDeclaration=ast.newVariableDeclarationStatement(fragment);
  tempDeclaration.setType(createType(ast,checkpointType));
  thenBranch.statements().add(tempDeclaration);
  IfStatement testNewCheckpoint=ast.newIfStatement();
  InfixExpression testNull=ast.newInfixExpression();
  testNull.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
  testNull.setOperator(InfixExpression.Operator.NOT_EQUALS);
  testNull.setRightOperand(ast.newNullLiteral());
  testNewCheckpoint.setExpression(testNull);
  Block testNewCheckpointBody=ast.newBlock();
  testNewCheckpoint.setThenStatement(testNewCheckpointBody);
  MethodInvocation record=ast.newMethodInvocation();
  record.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
  record.setName(ast.newSimpleName(""String_Node_Str""));
  record.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  MethodInvocation getTimestamp=ast.newMethodInvocation();
  getTimestamp.setExpression(ast.newSimpleName(""String_Node_Str""));
  getTimestamp.setName(ast.newSimpleName(""String_Node_Str""));
  record.arguments().add(getTimestamp);
  testNewCheckpointBody.statements().add(ast.newExpressionStatement(record));
  MethodInvocation pushStates=ast.newMethodInvocation();
  String recordType=getClassName(FieldRecord.class,state,root);
  pushStates.setExpression(createName(ast,recordType));
  pushStates.setName(ast.newSimpleName(""String_Node_Str""));
  pushStates.arguments().add(ast.newSimpleName(RECORDS_NAME));
  testNewCheckpointBody.statements().add(ast.newExpressionStatement(pushStates));
  thenBranch.statements().add(testNewCheckpoint);
  Assignment assignment=ast.newAssignment();
  assignment.setLeftHandSide(ast.newSimpleName(CHECKPOINT_NAME));
  assignment.setRightHandSide(ast.newSimpleName(""String_Node_Str""));
  ExpressionStatement statement=ast.newExpressionStatement(assignment);
  thenBranch.statements().add(statement);
  MethodInvocation propagate=ast.newMethodInvocation();
  propagate.setExpression(ast.newSimpleName(""String_Node_Str""));
  propagate.setName(ast.newSimpleName(""String_Node_Str""));
  propagate.arguments().add(ast.newSimpleName(""String_Node_Str""));
  thenBranch.statements().add(ast.newExpressionStatement(propagate));
  MethodInvocation addInvocation=ast.newMethodInvocation();
  addInvocation.setExpression(ast.newSimpleName(""String_Node_Str""));
  addInvocation.setName(ast.newSimpleName(""String_Node_Str""));
  addInvocation.arguments().add(_createRollbackableObject(ast,isAnonymous));
  thenBranch.statements().add(ast.newExpressionStatement(addInvocation));
  ReturnStatement returnStatement=ast.newReturnStatement();
  returnStatement.setExpression(ast.newThisExpression());
  body.statements().add(returnStatement);
  method.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  if (!isAnonymous)   addToLists(_checkParentMethods,parent.getName(),method);
  return method;
}"
75096,"/** 
 * Handle an explicit or implicit assignment node. An explicit assignment is one that uses the ""="" operator or any special assign operator (such as ""+="" and ""-=""). An implicit a prefix expression or postfix expression with the ""++"" operator or the ""--"" operator.
 * @param node The AST node of the assignment. It must be of one of thefollowing types:  {@link Assignment},   {@link PostfixExpression}, and  {@link PrefixExpression}.
 * @param state The current state of the type analyzer.
 */
private void _handleAssignment(ASTNode node,TypeAnalyzerState state){
  AST ast=node.getAST();
  boolean isSpecial;
  if (node instanceof Assignment)   isSpecial=((Assignment)node).getOperator() != Assignment.Operator.ASSIGN;
 else   isSpecial=true;
  Expression leftHand, rightHand;
  if (node instanceof Assignment) {
    leftHand=((Assignment)node).getLeftHandSide();
    rightHand=((Assignment)node).getRightHandSide();
  }
 else   if (node instanceof PrefixExpression)   leftHand=rightHand=((PrefixExpression)node).getOperand();
 else   leftHand=rightHand=((PostfixExpression)node).getOperand();
  while (leftHand instanceof ParenthesizedExpression)   leftHand=((ParenthesizedExpression)leftHand).getExpression();
  List indices=new LinkedList();
  while (leftHand instanceof ArrayAccess) {
    ArrayAccess arrayAccess=(ArrayAccess)leftHand;
    indices.add(0,ASTNode.copySubtree(ast,arrayAccess.getIndex()));
    leftHand=arrayAccess.getArray();
    while (leftHand instanceof ParenthesizedExpression)     leftHand=((ParenthesizedExpression)leftHand).getExpression();
  }
  Expression newObject=null;
  SimpleName name;
  if (leftHand instanceof FieldAccess) {
    Expression object=((FieldAccess)leftHand).getExpression();
    name=((FieldAccess)leftHand).getName();
    Type type=Type.getType(object);
    if (!type.getName().equals(state.getCurrentClass().getName()))     return;
    newObject=(Expression)ASTNode.copySubtree(ast,object);
  }
 else   if (leftHand instanceof QualifiedName) {
    Name object=((QualifiedName)leftHand).getQualifier();
    name=((QualifiedName)leftHand).getName();
    Type type=Type.getType(object);
    if (!type.getName().equals(state.getCurrentClass().getName()))     return;
    newObject=(Expression)ASTNode.copySubtree(ast,object);
  }
 else   if (leftHand instanceof SimpleName)   name=(SimpleName)leftHand;
 else   return;
  Type owner=Type.getOwner(leftHand);
  if (owner == null)   return;
  Class ownerClass;
  boolean isStatic;
  try {
    ownerClass=owner.toClass(state.getClassLoader());
    Field field=ownerClass.getDeclaredField(name.getIdentifier());
    int modifiers=field.getModifiers();
    if (!java.lang.reflect.Modifier.isPrivate(modifiers))     return;
    isStatic=java.lang.reflect.Modifier.isStatic(modifiers);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(owner.getName());
  }
catch (  NoSuchFieldException e) {
    return;
  }
  if (isStatic && !HANDLE_STATIC_FIELDS)   return;
  MethodInvocation invocation=ast.newMethodInvocation();
  if (newObject != null)   invocation.setExpression(newObject);
  SimpleName newName=ast.newSimpleName(_getAssignMethodName(name.getIdentifier(),isSpecial));
  invocation.setName(newName);
  if (isStatic)   invocation.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  Type type=Type.getType(node);
  if (isSpecial && _assignOperators.containsKey(type.getName())) {
    int i=0;
    String[] operators=(String[])_assignOperators.get(type.getName());
    String operator;
    if (node instanceof Assignment)     operator=((Assignment)node).getOperator().toString();
 else     if (node instanceof PrefixExpression)     operator=((PrefixExpression)node).getOperator().toString();
 else     operator=((PostfixExpression)node).getOperator().toString();
    for (; i < operators.length; i++)     if (operators[i].equals(operator))     break;
    if (node instanceof PrefixExpression)     i+=2;
    invocation.arguments().add(ast.newNumberLiteral(Integer.toString(i)));
  }
  invocation.arguments().addAll(indices);
  Type rightHandType=Type.getType(rightHand);
  if (!isSpecial && type.isPrimitive() && !type.equals(rightHandType)) {
    CastExpression castExpression=ast.newCastExpression();
    castExpression.setType(createType(ast,type.getName()));
    castExpression.setExpression((Expression)ASTNode.copySubtree(ast,rightHand));
    rightHand=castExpression;
  }
 else {
    rightHand=(Expression)ASTNode.copySubtree(ast,rightHand);
    if (isSpecial && type.getName().equals(String.class.getName()) && !type.equals(rightHandType)) {
      InfixExpression extraPlus=ast.newInfixExpression();
      extraPlus.setLeftOperand(ast.newStringLiteral());
      extraPlus.setOperator(InfixExpression.Operator.PLUS);
      extraPlus.setRightOperand(rightHand);
      rightHand=extraPlus;
    }
  }
  invocation.arguments().add(rightHand);
  Type.propagateType(invocation,node);
  replaceNode(node,invocation);
  Hashtable table=(node instanceof Assignment && ((Assignment)node).getOperator() == Assignment.Operator.ASSIGN) ? _accessedFields : _specialAccessedFields;
  _recordField(table,owner.getName(),name.getIdentifier(),indices.size());
}","/** 
 * Handle an explicit or implicit assignment node. An explicit assignment is one that uses the ""="" operator or any special assign operator (such as ""+="" and ""-=""). An implicit a prefix expression or postfix expression with the ""++"" operator or the ""--"" operator.
 * @param node The AST node of the assignment. It must be of one of thefollowing types:  {@link Assignment},   {@link PostfixExpression}, and  {@link PrefixExpression}.
 * @param state The current state of the type analyzer.
 */
private void _handleAssignment(ASTNode node,TypeAnalyzerState state){
  AST ast=node.getAST();
  boolean isSpecial;
  if (node instanceof Assignment)   isSpecial=((Assignment)node).getOperator() != Assignment.Operator.ASSIGN;
 else   isSpecial=true;
  Expression leftHand, rightHand;
  if (node instanceof Assignment) {
    leftHand=((Assignment)node).getLeftHandSide();
    rightHand=((Assignment)node).getRightHandSide();
  }
 else   if (node instanceof PrefixExpression)   leftHand=rightHand=((PrefixExpression)node).getOperand();
 else   leftHand=rightHand=((PostfixExpression)node).getOperand();
  while (leftHand instanceof ParenthesizedExpression)   leftHand=((ParenthesizedExpression)leftHand).getExpression();
  List indices=new LinkedList();
  while (leftHand instanceof ArrayAccess) {
    ArrayAccess arrayAccess=(ArrayAccess)leftHand;
    indices.add(0,ASTNode.copySubtree(ast,arrayAccess.getIndex()));
    leftHand=arrayAccess.getArray();
    while (leftHand instanceof ParenthesizedExpression)     leftHand=((ParenthesizedExpression)leftHand).getExpression();
  }
  Expression newObject=null;
  SimpleName name;
  if (leftHand instanceof FieldAccess) {
    Expression object=((FieldAccess)leftHand).getExpression();
    name=((FieldAccess)leftHand).getName();
    Type type=Type.getType(object);
    if (!type.getName().equals(state.getCurrentClass().getName()))     return;
    newObject=(Expression)ASTNode.copySubtree(ast,object);
  }
 else   if (leftHand instanceof QualifiedName) {
    Name object=((QualifiedName)leftHand).getQualifier();
    name=((QualifiedName)leftHand).getName();
    Type type=Type.getType(object);
    if (!type.getName().equals(state.getCurrentClass().getName()))     return;
    newObject=(Expression)ASTNode.copySubtree(ast,object);
  }
 else   if (leftHand instanceof SimpleName)   name=(SimpleName)leftHand;
 else   return;
  Type owner=Type.getOwner(leftHand);
  if (owner == null)   return;
  Class ownerClass;
  boolean isStatic;
  try {
    ownerClass=owner.toClass(state.getClassLoader());
    Field field=ownerClass.getDeclaredField(name.getIdentifier());
    int modifiers=field.getModifiers();
    if (!java.lang.reflect.Modifier.isPrivate(modifiers))     return;
    if (java.lang.reflect.Modifier.isFinal(modifiers)) {
      if (!field.getType().isArray())       return;
    }
    isStatic=java.lang.reflect.Modifier.isStatic(modifiers);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(owner.getName());
  }
catch (  NoSuchFieldException e) {
    return;
  }
  if (isStatic && !HANDLE_STATIC_FIELDS)   return;
  MethodInvocation invocation=ast.newMethodInvocation();
  if (newObject != null)   invocation.setExpression(newObject);
  SimpleName newName=ast.newSimpleName(_getAssignMethodName(name.getIdentifier(),isSpecial));
  invocation.setName(newName);
  if (isStatic)   invocation.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  Type type=Type.getType(node);
  if (isSpecial && _assignOperators.containsKey(type.getName())) {
    int i=0;
    String[] operators=(String[])_assignOperators.get(type.getName());
    String operator;
    if (node instanceof Assignment)     operator=((Assignment)node).getOperator().toString();
 else     if (node instanceof PrefixExpression)     operator=((PrefixExpression)node).getOperator().toString();
 else     operator=((PostfixExpression)node).getOperator().toString();
    for (; i < operators.length; i++)     if (operators[i].equals(operator))     break;
    if (node instanceof PrefixExpression)     i+=2;
    invocation.arguments().add(ast.newNumberLiteral(Integer.toString(i)));
  }
  invocation.arguments().addAll(indices);
  Type rightHandType=Type.getType(rightHand);
  if (!isSpecial && type.isPrimitive() && !type.equals(rightHandType)) {
    CastExpression castExpression=ast.newCastExpression();
    castExpression.setType(createType(ast,type.getName()));
    castExpression.setExpression((Expression)ASTNode.copySubtree(ast,rightHand));
    rightHand=castExpression;
  }
 else {
    rightHand=(Expression)ASTNode.copySubtree(ast,rightHand);
    if (isSpecial && type.getName().equals(String.class.getName()) && !type.equals(rightHandType)) {
      InfixExpression extraPlus=ast.newInfixExpression();
      extraPlus.setLeftOperand(ast.newStringLiteral());
      extraPlus.setOperator(InfixExpression.Operator.PLUS);
      extraPlus.setRightOperand(rightHand);
      rightHand=extraPlus;
    }
  }
  invocation.arguments().add(rightHand);
  Type.propagateType(invocation,node);
  replaceNode(node,invocation);
  Hashtable table=(node instanceof Assignment && ((Assignment)node).getOperator() == Assignment.Operator.ASSIGN) ? _accessedFields : _specialAccessedFields;
  _recordField(table,owner.getName(),name.getIdentifier(),indices.size());
}"
75097,"/** 
 * Create a proxy class for an anonymous class. The proxy class implements the   {@link Rollbackable} interface.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @return The type declaration of the proxy class.
 */
private TypeDeclaration _createProxyClass(AST ast,CompilationUnit root,TypeAnalyzerState state){
  TypeDeclaration classDeclaration=ast.newTypeDeclaration();
  classDeclaration.setName(ast.newSimpleName(_getProxyName()));
  String rollbackType=getClassName(Rollbackable.class,state,root);
  classDeclaration.superInterfaces().add(createName(ast,rollbackType));
  MethodDeclaration proxy=ast.newMethodDeclaration();
  proxy.setName(ast.newSimpleName(_getRestoreMethodName(false)));
  SingleVariableDeclaration timestamp=ast.newSingleVariableDeclaration();
  timestamp.setType(ast.newPrimitiveType(PrimitiveType.LONG));
  timestamp.setName(ast.newSimpleName(""String_Node_Str""));
  proxy.parameters().add(timestamp);
  SingleVariableDeclaration trim=ast.newSingleVariableDeclaration();
  trim.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
  trim.setName(ast.newSimpleName(""String_Node_Str""));
  proxy.parameters().add(trim);
  MethodInvocation invocation=ast.newMethodInvocation();
  invocation.setName(ast.newSimpleName(_getRestoreMethodName(true)));
  invocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  invocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  Block body=ast.newBlock();
  body.statements().add(ast.newExpressionStatement(invocation));
  proxy.setBody(body);
  proxy.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  classDeclaration.bodyDeclarations().add(proxy);
  MethodDeclaration getCheckpoint=ast.newMethodDeclaration();
  String checkpointType=getClassName(Checkpoint.class,state,root);
  getCheckpoint.setName(ast.newSimpleName(_getGetCheckpointMethodName(false)));
  getCheckpoint.setReturnType(createType(ast,checkpointType));
  invocation=ast.newMethodInvocation();
  invocation.setName(ast.newSimpleName(_getGetCheckpointMethodName(true)));
  body=ast.newBlock();
  ReturnStatement returnStatement=ast.newReturnStatement();
  returnStatement.setExpression(invocation);
  body.statements().add(returnStatement);
  getCheckpoint.setBody(body);
  getCheckpoint.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  classDeclaration.bodyDeclarations().add(getCheckpoint);
  MethodDeclaration setCheckpoint=ast.newMethodDeclaration();
  setCheckpoint.setName(ast.newSimpleName(_getSetCheckpointMethodName(false)));
  SingleVariableDeclaration checkpoint=ast.newSingleVariableDeclaration();
  checkpoint.setType(createType(ast,checkpointType));
  checkpoint.setName(ast.newSimpleName(""String_Node_Str""));
  setCheckpoint.parameters().add(checkpoint);
  invocation=ast.newMethodInvocation();
  invocation.setName(ast.newSimpleName(_getSetCheckpointMethodName(true)));
  invocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  body=ast.newBlock();
  body.statements().add(ast.newExpressionStatement(invocation));
  setCheckpoint.setBody(body);
  setCheckpoint.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  classDeclaration.bodyDeclarations().add(setCheckpoint);
  classDeclaration.setModifiers(Modifier.FINAL);
  return classDeclaration;
}","/** 
 * Create a proxy class for an anonymous class. The proxy class implements the   {@link Rollbackable} interface.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @return The type declaration of the proxy class.
 */
private TypeDeclaration _createProxyClass(AST ast,CompilationUnit root,TypeAnalyzerState state){
  TypeDeclaration classDeclaration=ast.newTypeDeclaration();
  classDeclaration.setName(ast.newSimpleName(_getProxyName()));
  String rollbackType=getClassName(Rollbackable.class,state,root);
  classDeclaration.superInterfaces().add(createName(ast,rollbackType));
  MethodDeclaration proxy=ast.newMethodDeclaration();
  proxy.setName(ast.newSimpleName(_getRestoreMethodName(false)));
  SingleVariableDeclaration timestamp=ast.newSingleVariableDeclaration();
  timestamp.setType(ast.newPrimitiveType(PrimitiveType.LONG));
  timestamp.setName(ast.newSimpleName(""String_Node_Str""));
  proxy.parameters().add(timestamp);
  SingleVariableDeclaration trim=ast.newSingleVariableDeclaration();
  trim.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
  trim.setName(ast.newSimpleName(""String_Node_Str""));
  proxy.parameters().add(trim);
  MethodInvocation invocation=ast.newMethodInvocation();
  invocation.setName(ast.newSimpleName(_getRestoreMethodName(true)));
  invocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  invocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  Block body=ast.newBlock();
  body.statements().add(ast.newExpressionStatement(invocation));
  proxy.setBody(body);
  proxy.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  classDeclaration.bodyDeclarations().add(proxy);
  MethodDeclaration getCheckpoint=ast.newMethodDeclaration();
  String checkpointType=getClassName(Checkpoint.class,state,root);
  getCheckpoint.setName(ast.newSimpleName(_getGetCheckpointMethodName(false)));
  getCheckpoint.setReturnType(createType(ast,checkpointType));
  invocation=ast.newMethodInvocation();
  invocation.setName(ast.newSimpleName(_getGetCheckpointMethodName(true)));
  body=ast.newBlock();
  ReturnStatement returnStatement=ast.newReturnStatement();
  returnStatement.setExpression(invocation);
  body.statements().add(returnStatement);
  getCheckpoint.setBody(body);
  getCheckpoint.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  classDeclaration.bodyDeclarations().add(getCheckpoint);
  MethodDeclaration setCheckpoint=ast.newMethodDeclaration();
  setCheckpoint.setName(ast.newSimpleName(_getSetCheckpointMethodName(false)));
  setCheckpoint.setReturnType(createType(ast,getClassName(Object.class,state,root)));
  SingleVariableDeclaration checkpoint=ast.newSingleVariableDeclaration();
  checkpoint.setType(createType(ast,checkpointType));
  checkpoint.setName(ast.newSimpleName(""String_Node_Str""));
  setCheckpoint.parameters().add(checkpoint);
  invocation=ast.newMethodInvocation();
  invocation.setName(ast.newSimpleName(_getSetCheckpointMethodName(true)));
  invocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  returnStatement=ast.newReturnStatement();
  returnStatement.setExpression(ast.newThisExpression());
  body=ast.newBlock();
  body.statements().add(ast.newExpressionStatement(invocation));
  body.statements().add(returnStatement);
  setCheckpoint.setBody(body);
  setCheckpoint.setModifiers(Modifier.PUBLIC | Modifier.FINAL);
  classDeclaration.bodyDeclarations().add(setCheckpoint);
  classDeclaration.setModifiers(Modifier.FINAL);
  return classDeclaration;
}"
75098,"/** 
 * Perform a deep copy from a source array to a destination array. If those arrays are multi-dimensional, sub-arrays of them are copied respectively.
 * @param source The source array.
 * @param destination The destination array.
 * @return <tt>true</tt> if successfully copied; otherwise, <tt>false</tt>.
 */
protected boolean _deepCopyArray(Object source,Object destination){
  if (source instanceof boolean[]) {
    System.arraycopy(source,0,destination,0,((boolean[])source).length);
    return true;
  }
 else   if (source instanceof byte[]) {
    System.arraycopy(source,0,destination,0,((byte[])source).length);
    return true;
  }
 else   if (source instanceof char[]) {
    System.arraycopy(source,0,destination,0,((char[])source).length);
    return true;
  }
 else   if (source instanceof double[]) {
    System.arraycopy(source,0,destination,0,((double[])source).length);
    return true;
  }
 else   if (source instanceof float[]) {
    System.arraycopy(source,0,destination,0,((float[])source).length);
    return true;
  }
 else   if (source instanceof int[]) {
    System.arraycopy(source,0,destination,0,((int[])source).length);
    return true;
  }
 else   if (source instanceof long[]) {
    System.arraycopy(source,0,destination,0,((long[])source).length);
    return true;
  }
 else   if (source instanceof short[]) {
    System.arraycopy(source,0,destination,0,((short[])source).length);
    return true;
  }
 else   if (source instanceof Object[]) {
    Object[] sourceArray=(Object[])source;
    Object[] destinationArray=(Object[])destination;
    for (int i=0; i < sourceArray.length; i++)     if (!_deepCopyArray(sourceArray[i],destinationArray[i]))     sourceArray[i]=destinationArray[i];
    return true;
  }
 else   return false;
}","/** 
 * Perform a deep copy from a source array to a destination array. If those arrays are multi-dimensional, sub-arrays of them are copied respectively.
 * @param source The source array.
 * @param destination The destination array.
 * @return <tt>true</tt> if successfully copied; otherwise, <tt>false</tt>.
 */
protected boolean _deepCopyArray(Object source,Object destination){
  if (source instanceof boolean[]) {
    System.arraycopy(source,0,destination,0,((boolean[])source).length);
    return true;
  }
 else   if (source instanceof byte[]) {
    System.arraycopy(source,0,destination,0,((byte[])source).length);
    return true;
  }
 else   if (source instanceof char[]) {
    System.arraycopy(source,0,destination,0,((char[])source).length);
    return true;
  }
 else   if (source instanceof double[]) {
    System.arraycopy(source,0,destination,0,((double[])source).length);
    return true;
  }
 else   if (source instanceof float[]) {
    System.arraycopy(source,0,destination,0,((float[])source).length);
    return true;
  }
 else   if (source instanceof int[]) {
    System.arraycopy(source,0,destination,0,((int[])source).length);
    return true;
  }
 else   if (source instanceof long[]) {
    System.arraycopy(source,0,destination,0,((long[])source).length);
    return true;
  }
 else   if (source instanceof short[]) {
    System.arraycopy(source,0,destination,0,((short[])source).length);
    return true;
  }
 else   if (source instanceof Object[]) {
    Object[] sourceArray=(Object[])source;
    Object[] destinationArray=(Object[])destination;
    for (int i=0; i < sourceArray.length; i++)     if (!_deepCopyArray(sourceArray[i],destinationArray[i]))     destinationArray[i]=sourceArray[i];
    return true;
  }
 else   return false;
}"
75099,"/** 
 * Consume a token from the <i>input</i> port and display the token as an image.  If a token is not available, do nothing.
 * @exception IllegalActionException If there is no director, orif the base class throws it.
 */
public boolean postfire() throws IllegalActionException {
  if (input.hasToken(0)) {
    Token in=input.get(0);
    if (!(in instanceof ImageToken)) {
      throw new IllegalActionException(this,""String_Node_Str"" + in);
    }
    if (_frame != null) {
      List tokens=new LinkedList();
      tokens.add(in);
      _effigy.setTokens(tokens);
    }
 else     if (_picture != null) {
      Image image=((ImageToken)in).asAWTImage();
      int xsize=image.getWidth(null);
      int ysize=image.getHeight(null);
      if ((_oldxsize != xsize) || (_oldysize != ysize)) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _oldxsize=xsize;
        _oldysize=ysize;
        Container container=_picture.getParent();
        if (_picture != null) {
          container.remove(_picture);
        }
        _picture=new Picture(xsize,ysize);
        _picture.setImage(image);
        _picture.setBackground(null);
        container.add(""String_Node_Str"",_picture);
        container.validate();
        container.invalidate();
        container.repaint();
        container.doLayout();
        Container c=container.getParent();
        while (c.getParent() != null) {
          c.invalidate();
          c.validate();
          c=c.getParent();
          if (c instanceof JFrame) {
            ((JFrame)c).pack();
          }
        }
      }
 else {
        _picture.setImage(((ImageToken)in).asAWTImage());
        _picture.displayImage();
        _picture.repaint();
      }
    }
  }
  return super.postfire();
}","/** 
 * Consume a token from the <i>input</i> port and display the token as an image.  If a token is not available, do nothing.
 * @exception IllegalActionException If there is no director, orif the base class throws it.
 */
public boolean postfire() throws IllegalActionException {
  if (input.hasToken(0)) {
    final Token in=input.get(0);
    if (!(in instanceof ImageToken)) {
      throw new IllegalActionException(this,""String_Node_Str"" + in);
    }
    Runnable doDisplay=new Runnable(){
      public void run(){
        _display(in);
      }
    }
;
    SwingUtilities.invokeLater(doDisplay);
  }
  return super.postfire();
}"
75100,"/** 
 * Construct an empty window. After constructing this, it is necessary to call setVisible(true) to make the frame appear and setTableau() to associate it with a tableau.
 */
public ImageWindow(){
  super(null,null);
  this.getContentPane().setLayout(new BorderLayout(15,15));
}","/** 
 * Construct an empty window. After constructing this, it is necessary to call setVisible(true) to make the frame appear and setTableau() to associate it with a tableau.
 */
public ImageWindow(){
  super(null,null);
}"
75101,"/** 
 * Initialize this actor. If place has not been called, then create a frame to display the image in.
 * @exception IllegalActionException If a contained method throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (_container == null) {
    if (_tableau == null) {
      Effigy containerEffigy=Configuration.findEffigy(toplevel());
      if (containerEffigy == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + toplevel().getFullName());
      }
      try {
        _effigy=new TokenEffigy(containerEffigy,containerEffigy.uniqueName(""String_Node_Str""));
        _effigy.identifier.setExpression(getFullName());
        _frame=new ImageWindow();
        _tableau=new ImageTableau(_effigy,""String_Node_Str"",_frame,_oldxsize,_oldysize);
        _tableau.setTitle(getName());
        _frame.setTableau(_tableau);
        _windowProperties.setProperties(_frame);
        Component[] components=_frame.getContentPane().getComponents();
        if (components.length > 0) {
          _pictureSize.setSize(components[0]);
        }
        _tableau.show();
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,null,ex,""String_Node_Str"");
      }
    }
 else {
      _effigy.clear();
      if (_frame != null) {
        _frame.toFront();
      }
    }
  }
  if (_frame != null) {
    _frame.setVisible(true);
    _frame.toFront();
  }
}","/** 
 * Initialize this actor. If place has not been called, then create a frame to display the image in.
 * @exception IllegalActionException If a contained method throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  Runnable doDisplay=new Runnable(){
    public void run(){
      _createOrShowWindow();
    }
  }
;
  SwingUtilities.invokeLater(doDisplay);
}"
75102,"/** 
 * Display the specified token.
 * @param token The token to append.
 * @exception If the token is not an ImageToken.
 */
public void display(ImageToken token) throws IllegalActionException {
  Image image=token.asAWTImage();
  if (image == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
 else {
    int xsize=image.getWidth(null);
    int ysize=image.getHeight(null);
    if ((_oldxsize != xsize) || (_oldysize != ysize)) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _oldxsize=xsize;
      _oldysize=ysize;
      Container container=_picture.getParent();
      if (_picture != null) {
        container.remove(_picture);
      }
      _picture=new Picture(xsize,ysize);
      _picture.setImage(image);
      _picture.setBackground(null);
      container.add(""String_Node_Str"",_picture);
      container.validate();
      container.invalidate();
      container.repaint();
      container.doLayout();
      Container c=container.getParent();
      while (c.getParent() != null) {
        c.invalidate();
        c.validate();
        c=c.getParent();
      }
      while (c.getParent() != null) {
        c=c.getParent();
      }
      if (c instanceof JFrame) {
        ((JFrame)c).pack();
      }
    }
 else {
      _picture.setImage(image);
    }
    _picture.displayImage();
    _picture.repaint();
    Thread.yield();
  }
}","/** 
 * Display the specified token.
 * @param token The token to append.
 * @exception If the token is not an ImageToken.
 */
public void display(ImageToken token) throws IllegalActionException {
  Image image=token.asAWTImage();
  if (image == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
 else {
    int xsize=image.getWidth(null);
    int ysize=image.getHeight(null);
    if ((_oldxsize != xsize) || (_oldysize != ysize)) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _oldxsize=xsize;
      _oldysize=ysize;
      Container container=_picture.getParent();
      Container top=container.getParent();
      while (top.getParent() != null) {
        top=top.getParent();
      }
      JFrame castTop=(JFrame)top;
      if (_picture != null) {
        castTop.getContentPane().remove(_picture);
      }
      _picture=new Picture(xsize,ysize);
      _picture.setImage(image);
      _picture.setBackground(null);
      castTop.getContentPane().add(_picture,BorderLayout.CENTER);
      castTop.getContentPane().validate();
      castTop.pack();
    }
 else {
      _picture.setImage(image);
    }
    _picture.displayImage();
    _picture.repaint();
    Thread.yield();
  }
}"
75103,"/** 
 * Construct an empty window. After constructing this, it is necessary to call setVisible(true) to make the frame appear and setTableau() to associate it with a tableau.
 */
public ViewWindow(){
  super(null,null);
  this.getContentPane().setLayout(new BorderLayout(15,15));
}","/** 
 * Construct an empty window. After constructing this, it is necessary to call setVisible(true) to make the frame appear and setTableau() to associate it with a tableau.
 */
public ViewWindow(){
  super(null,null);
  hideMenuBar();
  this.getContentPane().setLayout(new BorderLayout(15,15));
}"
75104,"/** 
 * Create a restore method for a class, which restores all its state variables.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @param fieldNames The list of all the accessed fields.
 * @param fieldTypes The types corresponding to the accessed fields.
 * @param isAnonymous Whether the current class is anonymous.
 * @return The declaration of the method that restores the old valueof all the private fields.
 */
private MethodDeclaration _createRestoreMethod(AST ast,CompilationUnit root,TypeAnalyzerState state,List fieldNames,List fieldTypes,boolean isAnonymous){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  String methodName=_getRestoreMethodName(isAnonymous);
  if (hasMethod(currentClass,methodName,new Class[]{int.class,boolean.class},true))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  MethodDeclaration method=ast.newMethodDeclaration();
  method.setName(ast.newSimpleName(methodName));
  SingleVariableDeclaration timestamp=ast.newSingleVariableDeclaration();
  timestamp.setType(ast.newPrimitiveType(PrimitiveType.LONG));
  timestamp.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(timestamp);
  SingleVariableDeclaration trim=ast.newSingleVariableDeclaration();
  trim.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
  trim.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(trim);
  Block body=ast.newBlock();
  method.setBody(body);
  if (parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName()) || hasMethod(parent,methodName,new Class[]{int.class,boolean.class}))) {
    SuperMethodInvocation superRestore=ast.newSuperMethodInvocation();
    superRestore.setName(ast.newSimpleName(_getRestoreMethodName(false)));
    superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
    superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
    body.statements().add(ast.newExpressionStatement(superRestore));
  }
 else   addToLists(_fixParentRestoreMethods,parent.getName(),body);
  Iterator namesIter=fieldNames.iterator();
  Iterator typesIter=fieldTypes.iterator();
  while (namesIter.hasNext()) {
    String fieldName=(String)namesIter.next();
    Type fieldType=(Type)typesIter.next();
    if (_getAccessedField(currentClass.getName(),fieldName) == null)     continue;
    MethodInvocation restoreMethodCall=ast.newMethodInvocation();
    restoreMethodCall.setExpression(ast.newSimpleName(_getRecordName(fieldName)));
    restoreMethodCall.arguments().add(ast.newSimpleName(fieldName));
    restoreMethodCall.setName(ast.newSimpleName(""String_Node_Str""));
    restoreMethodCall.arguments().add(ast.newSimpleName(""String_Node_Str""));
    restoreMethodCall.arguments().add(ast.newSimpleName(""String_Node_Str""));
    boolean isFinal=false;
    try {
      Field field=currentClass.getDeclaredField(fieldName);
      if (java.lang.reflect.Modifier.isFinal(field.getModifiers()))       isFinal=true;
    }
 catch (    NoSuchFieldException e) {
    }
    if (isFinal)     body.statements().add(ast.newExpressionStatement(restoreMethodCall));
 else {
      Expression rightHandSide;
      if (fieldType.isPrimitive())       rightHandSide=restoreMethodCall;
 else {
        CastExpression castExpression=ast.newCastExpression();
        String typeName=getClassName(fieldType.getName(),state,root);
        castExpression.setType(createType(ast,typeName));
        castExpression.setExpression(restoreMethodCall);
        rightHandSide=castExpression;
      }
      Assignment assignment=ast.newAssignment();
      assignment.setLeftHandSide(ast.newSimpleName(fieldName));
      assignment.setRightHandSide(rightHandSide);
      body.statements().add(ast.newExpressionStatement(assignment));
    }
  }
  IfStatement restoreCheckpoint=ast.newIfStatement();
  InfixExpression timestampTester=ast.newInfixExpression();
  timestampTester.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
  timestampTester.setOperator(InfixExpression.Operator.LESS_EQUALS);
  MethodInvocation topTimestamp=ast.newMethodInvocation();
  topTimestamp.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
  topTimestamp.setName(ast.newSimpleName(""String_Node_Str""));
  timestampTester.setRightOperand(topTimestamp);
  restoreCheckpoint.setExpression(timestampTester);
  Block restoreBlock=ast.newBlock();
  restoreCheckpoint.setThenStatement(restoreBlock);
  Assignment assignCheckpoint=ast.newAssignment();
  assignCheckpoint.setLeftHandSide(ast.newSimpleName(CHECKPOINT_NAME));
  MethodInvocation restoreCheckpointInvocation=ast.newMethodInvocation();
  restoreCheckpointInvocation.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
  restoreCheckpointInvocation.setName(ast.newSimpleName(""String_Node_Str""));
  restoreCheckpointInvocation.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  restoreCheckpointInvocation.arguments().add(_createRollbackableObject(ast,isAnonymous));
  restoreCheckpointInvocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  restoreCheckpointInvocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  assignCheckpoint.setRightHandSide(restoreCheckpointInvocation);
  restoreBlock.statements().add(ast.newExpressionStatement(assignCheckpoint));
  MethodInvocation popStates=ast.newMethodInvocation();
  String recordType=getClassName(FieldRecord.class,state,root);
  popStates.setExpression(createName(ast,recordType));
  popStates.setName(ast.newSimpleName(""String_Node_Str""));
  popStates.arguments().add(ast.newSimpleName(RECORDS_NAME));
  restoreBlock.statements().add(ast.newExpressionStatement(popStates));
  body.statements().add(restoreCheckpoint);
  method.setModifiers(Modifier.PUBLIC);
  return method;
}","/** 
 * Create a restore method for a class, which restores all its state variables.
 * @param ast The {@link AST} object.
 * @param root The root of the AST.
 * @param state The current state of the type analyzer.
 * @param fieldNames The list of all the accessed fields.
 * @param fieldTypes The types corresponding to the accessed fields.
 * @param isAnonymous Whether the current class is anonymous.
 * @return The declaration of the method that restores the old valueof all the private fields.
 */
private MethodDeclaration _createRestoreMethod(AST ast,CompilationUnit root,TypeAnalyzerState state,List fieldNames,List fieldTypes,boolean isAnonymous){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  String methodName=_getRestoreMethodName(isAnonymous);
  if (hasMethod(currentClass,methodName,new Class[]{int.class,boolean.class},true))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  MethodDeclaration method=ast.newMethodDeclaration();
  method.setName(ast.newSimpleName(methodName));
  SingleVariableDeclaration timestamp=ast.newSingleVariableDeclaration();
  timestamp.setType(ast.newPrimitiveType(PrimitiveType.LONG));
  timestamp.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(timestamp);
  SingleVariableDeclaration trim=ast.newSingleVariableDeclaration();
  trim.setType(ast.newPrimitiveType(PrimitiveType.BOOLEAN));
  trim.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(trim);
  Block body=ast.newBlock();
  method.setBody(body);
  Iterator namesIter=fieldNames.iterator();
  Iterator typesIter=fieldTypes.iterator();
  while (namesIter.hasNext()) {
    String fieldName=(String)namesIter.next();
    Type fieldType=(Type)typesIter.next();
    if (_getAccessedField(currentClass.getName(),fieldName) == null)     continue;
    MethodInvocation restoreMethodCall=ast.newMethodInvocation();
    restoreMethodCall.setExpression(ast.newSimpleName(_getRecordName(fieldName)));
    restoreMethodCall.arguments().add(ast.newSimpleName(fieldName));
    restoreMethodCall.setName(ast.newSimpleName(""String_Node_Str""));
    restoreMethodCall.arguments().add(ast.newSimpleName(""String_Node_Str""));
    restoreMethodCall.arguments().add(ast.newSimpleName(""String_Node_Str""));
    boolean isFinal=false;
    try {
      Field field=currentClass.getDeclaredField(fieldName);
      if (java.lang.reflect.Modifier.isFinal(field.getModifiers()))       isFinal=true;
    }
 catch (    NoSuchFieldException e) {
    }
    if (isFinal)     body.statements().add(ast.newExpressionStatement(restoreMethodCall));
 else {
      Expression rightHandSide;
      if (fieldType.isPrimitive())       rightHandSide=restoreMethodCall;
 else {
        CastExpression castExpression=ast.newCastExpression();
        String typeName=getClassName(fieldType.getName(),state,root);
        castExpression.setType(createType(ast,typeName));
        castExpression.setExpression(restoreMethodCall);
        rightHandSide=castExpression;
      }
      Assignment assignment=ast.newAssignment();
      assignment.setLeftHandSide(ast.newSimpleName(fieldName));
      assignment.setRightHandSide(rightHandSide);
      body.statements().add(ast.newExpressionStatement(assignment));
    }
  }
  if (parent != null && (state.getCrossAnalyzedTypes().contains(parent.getName()) || hasMethod(parent,methodName,new Class[]{int.class,boolean.class}))) {
    SuperMethodInvocation superRestore=ast.newSuperMethodInvocation();
    superRestore.setName(ast.newSimpleName(_getRestoreMethodName(false)));
    superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
    superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
    body.statements().add(ast.newExpressionStatement(superRestore));
  }
 else {
    IfStatement restoreCheckpoint=ast.newIfStatement();
    InfixExpression timestampTester=ast.newInfixExpression();
    timestampTester.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
    timestampTester.setOperator(InfixExpression.Operator.LESS_EQUALS);
    MethodInvocation topTimestamp=ast.newMethodInvocation();
    topTimestamp.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
    topTimestamp.setName(ast.newSimpleName(""String_Node_Str""));
    timestampTester.setRightOperand(topTimestamp);
    restoreCheckpoint.setExpression(timestampTester);
    Block restoreBlock=ast.newBlock();
    restoreCheckpoint.setThenStatement(restoreBlock);
    Assignment assignCheckpoint=ast.newAssignment();
    assignCheckpoint.setLeftHandSide(ast.newSimpleName(CHECKPOINT_NAME));
    MethodInvocation restoreCheckpointInvocation=ast.newMethodInvocation();
    restoreCheckpointInvocation.setExpression(ast.newSimpleName(CHECKPOINT_RECORD_NAME));
    restoreCheckpointInvocation.setName(ast.newSimpleName(""String_Node_Str""));
    restoreCheckpointInvocation.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
    restoreCheckpointInvocation.arguments().add(_createRollbackableObject(ast,isAnonymous));
    restoreCheckpointInvocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
    restoreCheckpointInvocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
    assignCheckpoint.setRightHandSide(restoreCheckpointInvocation);
    restoreBlock.statements().add(ast.newExpressionStatement(assignCheckpoint));
    MethodInvocation popStates=ast.newMethodInvocation();
    String recordType=getClassName(FieldRecord.class,state,root);
    popStates.setExpression(createName(ast,recordType));
    popStates.setName(ast.newSimpleName(""String_Node_Str""));
    popStates.arguments().add(ast.newSimpleName(RECORDS_NAME));
    restoreBlock.statements().add(ast.newExpressionStatement(popStates));
    body.statements().add(restoreCheckpoint);
    addToLists(_fixParentRestoreMethods,parent.getName(),body);
  }
  method.setModifiers(Modifier.PUBLIC);
  return method;
}"
75105,"/** 
 * Fix the refactoring when the set of cross-analyzed types changes.
 * @param state The current state of the type analyzer.
 */
public void handle(TypeAnalyzerState state){
  Set crossAnalyzedTypes=state.getCrossAnalyzedTypes();
  Iterator crossAnalysisIter=crossAnalyzedTypes.iterator();
  while (crossAnalysisIter.hasNext()) {
    String nextClassName=(String)crossAnalysisIter.next();
    List list=(List)_checkParentFields.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        removeNode((ASTNode)nodesIter.next());
        nodesIter.remove();
      }
    }
    list=(List)_checkParentMethods.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        removeNode((ASTNode)nodesIter.next());
        nodesIter.remove();
      }
    }
    list=(List)_fixParentRestoreMethods.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        Block body=(Block)nodesIter.next();
        AST ast=body.getAST();
        String methodName=_getRestoreMethodName(false);
        SuperMethodInvocation superRestore=ast.newSuperMethodInvocation();
        superRestore.setName(ast.newSimpleName(methodName));
        superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
        superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
        body.statements().add(0,ast.newExpressionStatement(superRestore));
        nodesIter.remove();
      }
    }
    list=(List)_fixSetCheckpoint.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        Block body=(Block)nodesIter.next();
        AST ast=body.getAST();
        Statement invocation=_createSetCheckpointInvocation(ast);
        List statements=body.statements();
        statements.add(statements.size() - 2,invocation);
        nodesIter.remove();
      }
    }
  }
}","/** 
 * Fix the refactoring when the set of cross-analyzed types changes.
 * @param state The current state of the type analyzer.
 */
public void handle(TypeAnalyzerState state){
  Set crossAnalyzedTypes=state.getCrossAnalyzedTypes();
  Iterator crossAnalysisIter=crossAnalyzedTypes.iterator();
  while (crossAnalysisIter.hasNext()) {
    String nextClassName=(String)crossAnalysisIter.next();
    List list=(List)_checkParentFields.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        removeNode((ASTNode)nodesIter.next());
        nodesIter.remove();
      }
    }
    list=(List)_checkParentMethods.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        removeNode((ASTNode)nodesIter.next());
        nodesIter.remove();
      }
    }
    list=(List)_fixParentRestoreMethods.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        Block body=(Block)nodesIter.next();
        AST ast=body.getAST();
        String methodName=_getRestoreMethodName(false);
        SuperMethodInvocation superRestore=ast.newSuperMethodInvocation();
        superRestore.setName(ast.newSimpleName(methodName));
        superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
        superRestore.arguments().add(ast.newSimpleName(""String_Node_Str""));
        List statements=body.statements();
        statements.remove(statements.size() - 1);
        statements.add(ast.newExpressionStatement(superRestore));
        nodesIter.remove();
      }
    }
    list=(List)_fixSetCheckpoint.get(nextClassName);
    if (list != null) {
      Iterator nodesIter=list.iterator();
      while (nodesIter.hasNext()) {
        Block body=(Block)nodesIter.next();
        AST ast=body.getAST();
        Statement invocation=_createSetCheckpointInvocation(ast);
        List statements=body.statements();
        statements.add(statements.size() - 2,invocation);
        nodesIter.remove();
      }
    }
  }
}"
75106,"/** 
 * Create a set checkpoint method invocation for an assignment block.
 * @param ast The {@link AST} object.
 * @return The statement that tests whether the checkpoint objects of thecurrent object and the new value are the same; if not, assign the checkpoint object of the current object to the checkpoint of the new value.
 */
private Statement _createSetCheckpointInvocation(AST ast){
  InfixExpression test=ast.newInfixExpression();
  InfixExpression condition1=ast.newInfixExpression();
  condition1.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
  condition1.setOperator(InfixExpression.Operator.NOT_EQUALS);
  condition1.setRightOperand(ast.newNullLiteral());
  InfixExpression condition2=ast.newInfixExpression();
  condition2.setLeftOperand(ast.newSimpleName(CHECKPOINT_NAME));
  condition2.setOperator(InfixExpression.Operator.NOT_EQUALS);
  FieldAccess access=ast.newFieldAccess();
  access.setExpression(ast.newSimpleName(""String_Node_Str""));
  access.setName(ast.newSimpleName(CHECKPOINT_NAME));
  condition2.setRightOperand(access);
  test.setLeftOperand(condition1);
  test.setOperator(InfixExpression.Operator.CONDITIONAL_AND);
  test.setRightOperand(condition2);
  IfStatement ifStatement=ast.newIfStatement();
  ifStatement.setExpression(test);
  Block thenBranch=ast.newBlock();
  ifStatement.setThenStatement(thenBranch);
  MethodInvocation setCheckpoint=ast.newMethodInvocation();
  setCheckpoint.setExpression(ast.newSimpleName(""String_Node_Str""));
  setCheckpoint.setName(ast.newSimpleName(SET_CHECKPOINT_NAME));
  setCheckpoint.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  thenBranch.statements().add(ast.newExpressionStatement(setCheckpoint));
  return ifStatement;
}","/** 
 * Create a set checkpoint method invocation for an assignment block.
 * @param ast The {@link AST} object.
 * @return The statement that tests whether the checkpoint objects of thecurrent object and the new value are the same; if not, assign the checkpoint object of the current object to the checkpoint of the new value.
 */
private Statement _createSetCheckpointInvocation(AST ast){
  InfixExpression test=ast.newInfixExpression();
  InfixExpression condition1=ast.newInfixExpression();
  condition1.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
  condition1.setOperator(InfixExpression.Operator.NOT_EQUALS);
  condition1.setRightOperand(ast.newNullLiteral());
  InfixExpression condition2=ast.newInfixExpression();
  condition2.setLeftOperand(ast.newSimpleName(CHECKPOINT_NAME));
  condition2.setOperator(InfixExpression.Operator.NOT_EQUALS);
  MethodInvocation getCheckpoint=ast.newMethodInvocation();
  getCheckpoint.setExpression(ast.newSimpleName(""String_Node_Str""));
  getCheckpoint.setName(ast.newSimpleName(_getGetCheckpointMethodName(false)));
  condition2.setRightOperand(getCheckpoint);
  test.setLeftOperand(condition1);
  test.setOperator(InfixExpression.Operator.CONDITIONAL_AND);
  test.setRightOperand(condition2);
  IfStatement ifStatement=ast.newIfStatement();
  ifStatement.setExpression(test);
  Block thenBranch=ast.newBlock();
  ifStatement.setThenStatement(thenBranch);
  MethodInvocation setCheckpoint=ast.newMethodInvocation();
  setCheckpoint.setExpression(ast.newSimpleName(""String_Node_Str""));
  setCheckpoint.setName(ast.newSimpleName(SET_CHECKPOINT_NAME));
  setCheckpoint.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  thenBranch.statements().add(ast.newExpressionStatement(setCheckpoint));
  return ifStatement;
}"
75107,"/** 
 * @param args
 */
public static void main(String[] args){
  ArrayTest1 test=new ArrayTest1();
  test.$GET$CHECKPOINT().createCheckpoint();
  test.modify();
  test.$GET$CHECKPOINT().rollback(1,true);
  test.dump();
}","/** 
 * @param args
 */
public static void main(String[] args){
  ArrayTest1 test=new ArrayTest1();
  long handle=test.$GET$CHECKPOINT().createCheckpoint();
  test.modify();
  test.$GET$CHECKPOINT().rollback(handle,true);
  test.dump();
}"
75108,"private boolean _addLegendIfNecessary(boolean connected){
  if ((!_sawFirstDataSet || (_currentdataset < 0)) && !_reuseDatasets) {
    _sawFirstDataSet=true;
    _currentdataset++;
  }
  if (!_sawFirstDataSet && (getLegend(_currentdataset) == null)) {
    _firstInSet=true;
    _sawFirstDataSet=true;
    addLegend(_currentdataset,new String(""String_Node_Str"" + _currentdataset));
  }
  if (_firstInSet && !_reuseDatasets) {
    connected=false;
    _firstInSet=false;
  }
  return connected;
}","private boolean _addLegendIfNecessary(boolean connected){
  if ((!_sawFirstDataSet || (_currentdataset < 0)) && !_reuseDatasets) {
    _sawFirstDataSet=true;
    _currentdataset++;
  }
  if (!_sawFirstDataSet && (getLegend(_currentdataset) == null)) {
    _firstInSet=true;
    _sawFirstDataSet=true;
    addLegend(_currentdataset,""String_Node_Str"" + _currentdataset);
  }
  if (_firstInSet && !_reuseDatasets) {
    connected=false;
    _firstInSet=false;
  }
  return connected;
}"
75109,"/** 
 * Initialize the PN actor.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _returnValue=true;
  N=((IntToken)parameter_N.getToken()).intValue();
  K=((IntToken)parameter_K.getToken()).intValue();
}","/** 
 * Initialize the PN actor.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  N=((IntToken)parameter_N.getToken()).intValue();
  K=((IntToken)parameter_K.getToken()).intValue();
}"
75110,"/** 
 * Construct an actor that is an SBF object with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ND_1(CompositeEntity aContainer,String aName) throws IllegalActionException, NameDuplicationException {
  super(aContainer,aName);
  WP_2=new TypedIOPort(this,""String_Node_Str"",false,true);
  WP_6=new TypedIOPort(this,""String_Node_Str"",false,true);
  WP_2.setTypeEquals(BaseType.DOUBLE);
  WP_6.setTypeEquals(BaseType.DOUBLE);
  parameter_N=new Parameter(this,""String_Node_Str"",new IntToken(6));
  parameter_K=new Parameter(this,""String_Node_Str"",new IntToken(6));
  x_1.ReadMatrix(""String_Node_Str"");
}","/** 
 * Construct an actor that is an SBF object with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ND_1(CompositeEntity aContainer,String aName) throws IllegalActionException, NameDuplicationException {
  super(aContainer,aName);
  WP_2=new TypedIOPort(this,""String_Node_Str"",false,true);
  WP_6=new TypedIOPort(this,""String_Node_Str"",false,true);
  WP_2.setTypeEquals(BaseType.DOUBLE);
  WP_6.setTypeEquals(BaseType.DOUBLE);
  parameter_N=new Parameter(this,""String_Node_Str"",new IntToken(6));
  parameter_K=new Parameter(this,""String_Node_Str"",new IntToken(6));
  x_1.readMatrix(""String_Node_Str"");
}"
75111,"/** 
 * Initialize the PN actor.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _returnValue=true;
  N=((IntToken)parameter_N.getToken()).intValue();
  K=((IntToken)parameter_K.getToken()).intValue();
}","/** 
 * Initialize the PN actor.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  N=((IntToken)parameter_N.getToken()).intValue();
  K=((IntToken)parameter_K.getToken()).intValue();
}"
75112,"/** 
 * Construct an actor that is an SBF object with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ND_2(CompositeEntity aContainer,String aName) throws IllegalActionException, NameDuplicationException {
  super(aContainer,aName);
  WP_4=new TypedIOPort(this,""String_Node_Str"",false,true);
  WP_8=new TypedIOPort(this,""String_Node_Str"",false,true);
  WP_4.setTypeEquals(BaseType.DOUBLE);
  WP_8.setTypeEquals(BaseType.DOUBLE);
  parameter_N=new Parameter(this,""String_Node_Str"",new IntToken(6));
  parameter_K=new Parameter(this,""String_Node_Str"",new IntToken(6));
  x_1.ReadMatrix(""String_Node_Str"");
}","/** 
 * Construct an actor that is an SBF object with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ND_2(CompositeEntity aContainer,String aName) throws IllegalActionException, NameDuplicationException {
  super(aContainer,aName);
  WP_4=new TypedIOPort(this,""String_Node_Str"",false,true);
  WP_8=new TypedIOPort(this,""String_Node_Str"",false,true);
  WP_4.setTypeEquals(BaseType.DOUBLE);
  WP_8.setTypeEquals(BaseType.DOUBLE);
  parameter_N=new Parameter(this,""String_Node_Str"",new IntToken(6));
  parameter_K=new Parameter(this,""String_Node_Str"",new IntToken(6));
  x_1.readMatrix(""String_Node_Str"");
}"
75113,"/** 
 * Get the specified property from the environment. An empty string is returned if the argument environment variable does not exist, though if certain properties are not defined, then we make various attempts to determine them and then set them. See the javadoc page for java.util.System.getProperties() for a list of system properties. <p>The following properties are handled specially <dl> <dt> ""ptolemy.ptII.dir"" <dd> vergil usually sets the ptolemy.ptII.dir property to the value of $PTII.  However, if we are running under Web Start, then this property might not be set, in which case we look for ""ptolemy/kernel/util/NamedObj.class"" and set the property accordingly. <dt> ""ptolemy.ptII.dirAsURL"" <dd> Return $PTII as a URL.  For example, if $PTII was c:\ptII, then return file:/c:/ptII/. <dt> ""user.dir"" <dd> Return the canonical path name to the current working directory. This is necessary because under JDK1.4.1 System.getProperty() returns <code><b>c</b>:/<i>foo</i></code> whereas most of the other methods that operate on path names return <code><b>C</b>:/<i>foo</i></code>. </dl>
 * @param propertyName The name of property.
 * @return A String containing the string value of the property.
 */
public static String getProperty(String propertyName){
  String property=null;
  try {
    property=System.getProperty(propertyName);
  }
 catch (  SecurityException ex) {
    if (!propertyName.equals(""String_Node_Str"")) {
      SecurityException security=new SecurityException(""String_Node_Str"" + propertyName + ""String_Node_Str"");
      security.initCause(ex);
      throw security;
    }
  }
  if (propertyName.equals(""String_Node_Str"")) {
    try {
      File userDirFile=new File(property);
      return userDirFile.getCanonicalPath();
    }
 catch (    IOException ex) {
      return property;
    }
  }
  if (property != null) {
    if (propertyName.equals(""String_Node_Str"") && (property.indexOf(""String_Node_Str"") != -1) && !_printedCygwinWarning) {
      _printedCygwinWarning=true;
      System.err.println(""String_Node_Str"" + property + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    return property;
  }
  if (propertyName.equals(""String_Node_Str"")) {
    File ptIIAsFile=new File(getProperty(""String_Node_Str""));
    try {
      URL ptIIAsURL=ptIIAsFile.toURL();
      return ptIIAsURL.toString();
    }
 catch (    java.net.MalformedURLException malformed) {
      throw new RuntimeException(""String_Node_Str"" + propertyName + ""String_Node_Str""+ ptIIAsFile+ ""String_Node_Str"",malformed);
    }
  }
  if (propertyName.equals(""String_Node_Str"")) {
    String namedObjPath=""String_Node_Str"";
    String home=null;
    URL namedObjURL=Thread.currentThread().getContextClassLoader().getResource(namedObjPath);
    if (namedObjURL != null) {
      String namedObjFileName=namedObjURL.getFile().toString();
      if (namedObjFileName.startsWith(""String_Node_Str"")) {
        if (namedObjFileName.startsWith(""String_Node_Str"") || namedObjFileName.startsWith(""String_Node_Str"")) {
          namedObjFileName=namedObjFileName.substring(6);
        }
 else {
          namedObjFileName=namedObjFileName.substring(5);
        }
      }
      String abnormalHome=namedObjFileName.substring(0,namedObjFileName.length() - namedObjPath.length());
      home=(new File(abnormalHome)).toString();
      if (home.endsWith(""String_Node_Str"")) {
        home=home.substring(0,home.length() - 1);
      }
      String ptsupportJarName=File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str"";
      if (home.endsWith(ptsupportJarName)) {
        home=home.substring(0,home.length() - ptsupportJarName.length());
      }
 else {
        ptsupportJarName=""String_Node_Str"";
        if (home.lastIndexOf(ptsupportJarName) != -1) {
          home.substring(0,home.lastIndexOf(ptsupportJarName));
        }
      }
    }
    if (home != null) {
      home=StringUtilities.substitute(home,""String_Node_Str"",""String_Node_Str"");
    }
    if (home == null) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + namedObjPath + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    try {
      System.setProperty(""String_Node_Str"",home);
    }
 catch (    SecurityException security) {
    }
    return home;
  }
  if (property == null) {
    return ""String_Node_Str"";
  }
  return property;
}","/** 
 * Get the specified property from the environment. An empty string is returned if the argument environment variable does not exist, though if certain properties are not defined, then we make various attempts to determine them and then set them. See the javadoc page for java.util.System.getProperties() for a list of system properties. <p>The following properties are handled specially <dl> <dt> ""ptolemy.ptII.dir"" <dd> vergil usually sets the ptolemy.ptII.dir property to the value of $PTII.  However, if we are running under Web Start, then this property might not be set, in which case we look for ""ptolemy/kernel/util/NamedObj.class"" and set the property accordingly. <dt> ""ptolemy.ptII.dirAsURL"" <dd> Return $PTII as a URL.  For example, if $PTII was c:\ptII, then return file:/c:/ptII/. <dt> ""user.dir"" <dd> Return the canonical path name to the current working directory. This is necessary because under JDK1.4.1 System.getProperty() returns <code><b>c</b>:/<i>foo</i></code> whereas most of the other methods that operate on path names return <code><b>C</b>:/<i>foo</i></code>. </dl>
 * @param propertyName The name of property.
 * @return A String containing the string value of the property.
 */
public static String getProperty(String propertyName){
  String property=null;
  try {
    property=System.getProperty(propertyName);
  }
 catch (  SecurityException ex) {
    if (!propertyName.equals(""String_Node_Str"")) {
      SecurityException security=new SecurityException(""String_Node_Str"" + propertyName + ""String_Node_Str"");
      security.initCause(ex);
      throw security;
    }
  }
  if (propertyName.equals(""String_Node_Str"")) {
    try {
      File userDirFile=new File(property);
      return userDirFile.getCanonicalPath();
    }
 catch (    IOException ex) {
      return property;
    }
  }
  if (property != null) {
    if (propertyName.equals(""String_Node_Str"") && (property.indexOf(""String_Node_Str"") != -1) && !_printedCygwinWarning) {
      _printedCygwinWarning=true;
      System.err.println(""String_Node_Str"" + property + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    return property;
  }
  if (propertyName.equals(""String_Node_Str"")) {
    File ptIIAsFile=new File(getProperty(""String_Node_Str""));
    try {
      URL ptIIAsURL=ptIIAsFile.toURL();
      return ptIIAsURL.toString();
    }
 catch (    java.net.MalformedURLException malformed) {
      throw new RuntimeException(""String_Node_Str"" + propertyName + ""String_Node_Str""+ ptIIAsFile+ ""String_Node_Str"",malformed);
    }
  }
  if (propertyName.equals(""String_Node_Str"")) {
    String namedObjPath=""String_Node_Str"";
    String home=null;
    URL namedObjURL=Thread.currentThread().getContextClassLoader().getResource(namedObjPath);
    if (namedObjURL != null) {
      String namedObjFileName=namedObjURL.getFile();
      if (namedObjFileName.startsWith(""String_Node_Str"")) {
        if (namedObjFileName.startsWith(""String_Node_Str"") || namedObjFileName.startsWith(""String_Node_Str"")) {
          namedObjFileName=namedObjFileName.substring(6);
        }
 else {
          namedObjFileName=namedObjFileName.substring(5);
        }
      }
      String abnormalHome=namedObjFileName.substring(0,namedObjFileName.length() - namedObjPath.length());
      home=(new File(abnormalHome)).toString();
      if (home.endsWith(""String_Node_Str"")) {
        home=home.substring(0,home.length() - 1);
      }
      String ptsupportJarName=File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str"";
      if (home.endsWith(ptsupportJarName)) {
        home=home.substring(0,home.length() - ptsupportJarName.length());
      }
 else {
        ptsupportJarName=""String_Node_Str"";
        if (home.lastIndexOf(ptsupportJarName) != -1) {
          home=home.substring(0,home.lastIndexOf(ptsupportJarName));
        }
      }
    }
    if (home != null) {
      home=StringUtilities.substitute(home,""String_Node_Str"",""String_Node_Str"");
    }
    if (home == null) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + namedObjPath + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    try {
      System.setProperty(""String_Node_Str"",home);
    }
 catch (    SecurityException security) {
    }
    return home;
  }
  if (property == null) {
    return ""String_Node_Str"";
  }
  return property;
}"
75114,"/** 
 * Restore the old value at the timestamp to the field. <p> The given timestamp refers to the time when the field still possesses its old value. If the timestamp is increased at an assignment, the old value at that timestamp refers to the value of the field before assignment.
 * @param current The current value of the field.
 * @param timestamp The timestamp.
 * @param trim If <tt>true</tt>, any values newer than the restored valueare deleted from the record.
 * @return The old value to be assigned back to the field.
 */
public double restore(short current,long timestamp,boolean trim){
  Iterator recordIter=iterator(0);
  Record record=_findRecord(recordIter,timestamp,trim);
  if (record == null)   return current;
 else   return ((Short)record.getValue()).shortValue();
}","/** 
 * Restore the old value at the timestamp to the field. <p> The given timestamp refers to the time when the field still possesses its old value. If the timestamp is increased at an assignment, the old value at that timestamp refers to the value of the field before assignment.
 * @param current The current value of the field.
 * @param timestamp The timestamp.
 * @param trim If <tt>true</tt>, any values newer than the restored valueare deleted from the record.
 * @return The old value to be assigned back to the field.
 */
public short restore(short current,long timestamp,boolean trim){
  Iterator recordIter=iterator(0);
  Record record=_findRecord(recordIter,timestamp,trim);
  if (record == null)   return current;
 else   return ((Short)record.getValue()).shortValue();
}"
75115,"/** 
 * Handle an explicit or implicit assignment node. An explicit assignment is one that uses the ""="" operator or any special assign operator (such as ""+="" and ""-=""). An implicit a prefix expression or postfix expression with the ""++"" operator or the ""--"" operator.
 * @param node The AST node of the assignment. It must be of one of thefollowing types:  {@link Assignment},   {@link PostfixExpression}, and  {@link PrefixExpression}.
 * @param state The current state of the type analyzer.
 */
private void _handleAssignment(ASTNode node,TypeAnalyzerState state){
  AST ast=node.getAST();
  boolean isSpecial;
  if (node instanceof Assignment)   isSpecial=((Assignment)node).getOperator() != Assignment.Operator.ASSIGN;
 else   isSpecial=true;
  Expression leftHand, rightHand;
  if (node instanceof Assignment) {
    leftHand=((Assignment)node).getLeftHandSide();
    rightHand=((Assignment)node).getRightHandSide();
  }
 else   if (node instanceof PrefixExpression)   leftHand=rightHand=((PrefixExpression)node).getOperand();
 else   leftHand=rightHand=((PostfixExpression)node).getOperand();
  while (leftHand instanceof ParenthesizedExpression)   leftHand=((ParenthesizedExpression)leftHand).getExpression();
  List indices=new LinkedList();
  while (leftHand instanceof ArrayAccess) {
    ArrayAccess arrayAccess=(ArrayAccess)leftHand;
    indices.add(0,ASTNode.copySubtree(ast,arrayAccess.getIndex()));
    leftHand=arrayAccess.getArray();
    while (leftHand instanceof ParenthesizedExpression)     leftHand=((ParenthesizedExpression)leftHand).getExpression();
  }
  Expression newObject=null;
  SimpleName name;
  if (leftHand instanceof FieldAccess) {
    Expression object=((FieldAccess)leftHand).getExpression();
    name=((FieldAccess)leftHand).getName();
    Type type=Type.getType(object);
    if (!type.getName().equals(state.getCurrentClass().getName()))     return;
    newObject=(Expression)ASTNode.copySubtree(ast,object);
  }
 else   if (leftHand instanceof QualifiedName) {
    Name object=((QualifiedName)leftHand).getQualifier();
    name=((QualifiedName)leftHand).getName();
    Type type=Type.getType(object);
    if (!type.getName().equals(state.getCurrentClass().getName()))     return;
    newObject=(Expression)ASTNode.copySubtree(ast,object);
  }
 else   if (leftHand instanceof SimpleName)   name=(SimpleName)leftHand;
 else   return;
  Type owner=Type.getOwner(leftHand);
  if (owner == null)   return;
  Class ownerClass;
  boolean isStatic;
  try {
    ownerClass=owner.toClass(state.getClassLoader());
    Field field=ownerClass.getDeclaredField(name.getIdentifier());
    int modifiers=field.getModifiers();
    if (!java.lang.reflect.Modifier.isPrivate(modifiers))     return;
    isStatic=java.lang.reflect.Modifier.isStatic(modifiers);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(owner.getName());
  }
catch (  NoSuchFieldException e) {
    return;
  }
  if (isStatic && !HANDLE_STATIC_FIELDS)   return;
  MethodInvocation invocation=ast.newMethodInvocation();
  if (newObject != null)   invocation.setExpression(newObject);
  SimpleName newName=ast.newSimpleName(_getAssignMethodName(name.getIdentifier(),isSpecial));
  invocation.setName(newName);
  if (isStatic)   invocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  Type type=Type.getType(node);
  if (isSpecial && _assignOperators.containsKey(type.getName())) {
    int i=0;
    String[] operators=(String[])_assignOperators.get(type.getName());
    String operator;
    if (node instanceof Assignment)     operator=((Assignment)node).getOperator().toString();
 else     if (node instanceof PrefixExpression)     operator=((PrefixExpression)node).getOperator().toString();
 else     operator=((PostfixExpression)node).getOperator().toString();
    for (; i < operators.length; i++)     if (operators[i].equals(operator))     break;
    if (node instanceof PrefixExpression)     i+=2;
    invocation.arguments().add(ast.newNumberLiteral(Integer.toString(i)));
  }
  invocation.arguments().addAll(indices);
  if (!isSpecial && type.isPrimitive() && !type.equals(Type.getType(rightHand))) {
    CastExpression castExpression=ast.newCastExpression();
    castExpression.setType(createType(ast,type.getName()));
    castExpression.setExpression((Expression)ASTNode.copySubtree(ast,rightHand));
    rightHand=castExpression;
  }
 else   rightHand=(Expression)ASTNode.copySubtree(ast,rightHand);
  invocation.arguments().add(rightHand);
  Type.propagateType(invocation,node);
  replaceNode(node,invocation);
  Hashtable table=(node instanceof Assignment && ((Assignment)node).getOperator() == Assignment.Operator.ASSIGN) ? _accessedFields : _specialAccessedFields;
  _recordAccessedField(table,owner.getName(),name.getIdentifier(),indices.size());
}","/** 
 * Handle an explicit or implicit assignment node. An explicit assignment is one that uses the ""="" operator or any special assign operator (such as ""+="" and ""-=""). An implicit a prefix expression or postfix expression with the ""++"" operator or the ""--"" operator.
 * @param node The AST node of the assignment. It must be of one of thefollowing types:  {@link Assignment},   {@link PostfixExpression}, and  {@link PrefixExpression}.
 * @param state The current state of the type analyzer.
 */
private void _handleAssignment(ASTNode node,TypeAnalyzerState state){
  AST ast=node.getAST();
  boolean isSpecial;
  if (node instanceof Assignment)   isSpecial=((Assignment)node).getOperator() != Assignment.Operator.ASSIGN;
 else   isSpecial=true;
  Expression leftHand, rightHand;
  if (node instanceof Assignment) {
    leftHand=((Assignment)node).getLeftHandSide();
    rightHand=((Assignment)node).getRightHandSide();
  }
 else   if (node instanceof PrefixExpression)   leftHand=rightHand=((PrefixExpression)node).getOperand();
 else   leftHand=rightHand=((PostfixExpression)node).getOperand();
  while (leftHand instanceof ParenthesizedExpression)   leftHand=((ParenthesizedExpression)leftHand).getExpression();
  List indices=new LinkedList();
  while (leftHand instanceof ArrayAccess) {
    ArrayAccess arrayAccess=(ArrayAccess)leftHand;
    indices.add(0,ASTNode.copySubtree(ast,arrayAccess.getIndex()));
    leftHand=arrayAccess.getArray();
    while (leftHand instanceof ParenthesizedExpression)     leftHand=((ParenthesizedExpression)leftHand).getExpression();
  }
  Expression newObject=null;
  SimpleName name;
  if (leftHand instanceof FieldAccess) {
    Expression object=((FieldAccess)leftHand).getExpression();
    name=((FieldAccess)leftHand).getName();
    Type type=Type.getType(object);
    if (!type.getName().equals(state.getCurrentClass().getName()))     return;
    newObject=(Expression)ASTNode.copySubtree(ast,object);
  }
 else   if (leftHand instanceof QualifiedName) {
    Name object=((QualifiedName)leftHand).getQualifier();
    name=((QualifiedName)leftHand).getName();
    Type type=Type.getType(object);
    if (!type.getName().equals(state.getCurrentClass().getName()))     return;
    newObject=(Expression)ASTNode.copySubtree(ast,object);
  }
 else   if (leftHand instanceof SimpleName)   name=(SimpleName)leftHand;
 else   return;
  Type owner=Type.getOwner(leftHand);
  if (owner == null)   return;
  Class ownerClass;
  boolean isStatic;
  try {
    ownerClass=owner.toClass(state.getClassLoader());
    Field field=ownerClass.getDeclaredField(name.getIdentifier());
    int modifiers=field.getModifiers();
    if (!java.lang.reflect.Modifier.isPrivate(modifiers))     return;
    isStatic=java.lang.reflect.Modifier.isStatic(modifiers);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(owner.getName());
  }
catch (  NoSuchFieldException e) {
    return;
  }
  if (isStatic && !HANDLE_STATIC_FIELDS)   return;
  MethodInvocation invocation=ast.newMethodInvocation();
  if (newObject != null)   invocation.setExpression(newObject);
  SimpleName newName=ast.newSimpleName(_getAssignMethodName(name.getIdentifier(),isSpecial));
  invocation.setName(newName);
  if (isStatic)   invocation.arguments().add(ast.newSimpleName(""String_Node_Str""));
  Type type=Type.getType(node);
  if (isSpecial && _assignOperators.containsKey(type.getName())) {
    int i=0;
    String[] operators=(String[])_assignOperators.get(type.getName());
    String operator;
    if (node instanceof Assignment)     operator=((Assignment)node).getOperator().toString();
 else     if (node instanceof PrefixExpression)     operator=((PrefixExpression)node).getOperator().toString();
 else     operator=((PostfixExpression)node).getOperator().toString();
    for (; i < operators.length; i++)     if (operators[i].equals(operator))     break;
    if (node instanceof PrefixExpression)     i+=2;
    invocation.arguments().add(ast.newNumberLiteral(Integer.toString(i)));
  }
  invocation.arguments().addAll(indices);
  Type rightHandType=Type.getType(rightHand);
  if (!isSpecial && type.isPrimitive() && !type.equals(rightHandType)) {
    CastExpression castExpression=ast.newCastExpression();
    castExpression.setType(createType(ast,type.getName()));
    castExpression.setExpression((Expression)ASTNode.copySubtree(ast,rightHand));
    rightHand=castExpression;
  }
 else {
    rightHand=(Expression)ASTNode.copySubtree(ast,rightHand);
    if (isSpecial && type.getName().equals(String.class.getName()) && !type.equals(rightHandType)) {
      InfixExpression extraPlus=ast.newInfixExpression();
      extraPlus.setLeftOperand(ast.newStringLiteral());
      extraPlus.setOperator(InfixExpression.Operator.PLUS);
      extraPlus.setRightOperand(rightHand);
      rightHand=extraPlus;
    }
  }
  invocation.arguments().add(rightHand);
  Type.propagateType(invocation,node);
  replaceNode(node,invocation);
  Hashtable table=(node instanceof Assignment && ((Assignment)node).getOperator() == Assignment.Operator.ASSIGN) ? _accessedFields : _specialAccessedFields;
  _recordAccessedField(table,owner.getName(),name.getIdentifier(),indices.size());
}"
75116,"public Test2 getT(Integer index){
  return _t[index];
}","public Test2 getT(int index){
  return _t[index];
}"
75117,"/** 
 * Transform the Java source in the file given by its name with given class paths, and output the result to the writer. <p> If a output directory is set with the <tt>-output</tt> command-line argument, the output is written to a Java source file with that directory as the root directory. The given writer is not used in that case.
 * @param fileName The Java file name.
 * @param writer The writer where output is written.
 * @param classPaths The class paths.
 * @exception IOException If IO exception occurs when reading fromthe Java file or riting to the output.
 * @exception ASTMalformedException If the Java source is illegal.
 * @see #transform(String,Writer)
 */
public static void transform(String fileName,Writer writer,String[] classPaths) throws IOException, ASTMalformedException {
  boolean needClose=false;
  Transformer transform=new Transformer(fileName,classPaths);
  transform._startTransform();
  if (_rootPath != null) {
    String packageName=transform._ast.getPackage().getName().toString();
    File file=new File(fileName);
    String outputFileName=file.getName();
    SourceOutputStream outputStream=SourceOutputStream.getStream(_rootPath,packageName,outputFileName);
    writer=new OutputStreamWriter(outputStream);
    needClose=true;
  }
  transform._outputSource(writer);
  if (needClose)   writer.close();
}","/** 
 * Transform the Java source in the file given by its name with given class paths, and output the result to the writer. <p> If a output directory is set with the <tt>-output</tt> command-line argument, the output is written to a Java source file with that directory as the root directory. The given writer is not used in that case.
 * @param fileName The Java file name.
 * @param writer The writer where output is written.
 * @param classPaths The class paths.
 * @exception IOException If IO exception occurs when reading fromthe Java file or riting to the output.
 * @exception ASTMalformedException If the Java source is illegal.
 * @see #transform(String,Writer)
 */
public static void transform(String fileName,Writer writer,String[] classPaths) throws IOException, ASTMalformedException {
  boolean needClose=false;
  Transformer transform=new Transformer(fileName,classPaths);
  transform._startTransform();
  if (_rootPath != null) {
    String packageName=transform._ast.getPackage().getName().toString();
    File file=new File(fileName);
    String outputFileName=file.getName();
    SourceOutputStream outputStream=SourceOutputStream.getStream(_rootPath,packageName,outputFileName,_overwrite);
    writer=new OutputStreamWriter(outputStream);
    needClose=true;
  }
  transform._outputSource(writer);
  if (needClose)   writer.close();
  if (_configName != null) {
    File file=new File(fileName);
    String simpleName=file.getName();
    if (simpleName.toUpperCase().endsWith(""String_Node_Str"")) {
      String baseName=simpleName.substring(0,simpleName.length() - 5);
      CompilationUnit root=(CompilationUnit)transform._ast.getRoot();
      String className;
      if (root.getPackage() != null)       className=root.getPackage().getName().toString() + ""String_Node_Str"" + baseName;
 else       className=baseName;
      if (_prefix != null && _prefix.length() > 0)       className=className.substring(_prefix.length() + 1);
      _classes.add(className);
    }
  }
}"
75118,"/** 
 * Parse the command-line arguments starting from the given position. If one or more argument corresponds to an option, proper actions are performed to record that option. The position is adjusted to the next file name or option and returned.
 * @param args The command-line arguments.
 * @param position The starting position.
 * @return The new position.
 */
protected static int _parseArguments(String[] args,int position){
  if (args[position].equals(""String_Node_Str"")) {
    position++;
    _prefix=args[position];
    for (int i=0; i < RULES.length; i++)     if (RULES[i] instanceof PackageRule) {
      ((PackageRule)RULES[i]).setPrefix(_prefix);
      break;
    }
    position++;
  }
 else   if (args[position].equals(""String_Node_Str"")) {
    position++;
    _rootPath=args[position];
    if (_rootPath.length() == 0)     _rootPath=""String_Node_Str"";
    position++;
  }
  return position;
}","/** 
 * Parse the command-line arguments starting from the given position. If one or more argument corresponds to an option, proper actions are performed to record that option. The position is adjusted to the next file name or option and returned.
 * @param args The command-line arguments.
 * @param position The starting position.
 * @return The new position.
 */
protected static int _parseArguments(String[] args,int position){
  String arg=args[position];
  if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _prefix=args[position];
    for (int i=0; i < RULES.length; i++)     if (RULES[i] instanceof PackageRule) {
      ((PackageRule)RULES[i]).setPrefix(_prefix);
      break;
    }
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _rootPath=args[position];
    if (_rootPath.length() == 0)     _rootPath=""String_Node_Str"";
    position++;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=true;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _overwrite=false;
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    position++;
    _configName=args[position];
    position++;
  }
  return position;
}"
75119,"/** 
 * Transform a set of files into backtracking-enabled ones. The set of files is given by an array of strings as their names, or the names of the directories that contain them. If a string in the array is a file name, it is refactored and the output is printed out; if it is the name of a directory, all Java files in the directory and its sub-directories are looked up and refactored in the same way.
 * @param args The array of file names or names of directories.
 * @exception Exception If any exception occues.
 */
public static void main(String[] args) throws Exception {
  boolean outputResult=true;
  if (args.length == 0)   System.err.println(""String_Node_Str"" + ""String_Node_Str"");
 else {
    String[] paths=PathFinder.getPtClassPaths();
    Writer standardWriter=outputResult ? new OutputStreamWriter(System.out) : null;
    for (int i=0; i < args.length; ) {
      int newPosition=_parseArguments(args,i);
      if (newPosition != i) {
        i=newPosition;
        continue;
      }
      String pathOrFile=args[i];
      File[] files=PathFinder.getJavaFiles(pathOrFile,true);
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        System.err.print(""String_Node_Str"" + fileName + ""String_Node_Str"");
        if (fileName.endsWith(""String_Node_Str"")) {
          String classFileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
          if (new File(classFileName).exists())           System.err.println();
 else {
            System.err.println(""String_Node_Str"");
            continue;
          }
        }
 else         continue;
        System.err.flush();
        transform(files[j].getPath(),standardWriter,paths);
        if (outputResult)         standardWriter.flush();
      }
      i++;
    }
    if (outputResult)     standardWriter.close();
  }
}","/** 
 * Transform a set of files into backtracking-enabled ones. The set of files is given by an array of strings as their names, or the names of the directories that contain them. If a string in the array is a file name, it is refactored and the output is printed out; if it is the name of a directory, all Java files in the directory and its sub-directories are looked up and refactored in the same way.
 * @param args The array of file names or names of directories.
 * @exception Exception If any exception occues.
 */
public static void main(String[] args) throws Exception {
  boolean outputResult=true;
  if (args.length == 0)   System.err.println(""String_Node_Str"" + ""String_Node_Str"");
 else {
    String[] paths=PathFinder.getPtClassPaths();
    Writer standardWriter=outputResult ? new OutputStreamWriter(System.out) : null;
    for (int i=0; i < args.length; ) {
      int newPosition=_parseArguments(args,i);
      if (newPosition != i) {
        i=newPosition;
        continue;
      }
      String pathOrFile=args[i];
      File[] files;
      if (pathOrFile.startsWith(""String_Node_Str"")) {
        String listName=pathOrFile.substring(1);
        BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(listName)));
        List strings=new LinkedList();
        String line=reader.readLine();
        while (line != null) {
          strings.add(line);
          line=reader.readLine();
        }
        files=new File[strings.size()];
        Iterator stringsIter=strings.iterator();
        for (int j=0; stringsIter.hasNext(); j++)         files[j]=new File((String)stringsIter.next());
      }
 else       files=PathFinder.getJavaFiles(pathOrFile,true);
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        System.err.print(""String_Node_Str"" + fileName + ""String_Node_Str"");
        if (fileName.endsWith(""String_Node_Str"")) {
          String classFileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
          if (new File(classFileName).exists())           System.err.println();
 else {
            System.err.println(""String_Node_Str"");
            continue;
          }
        }
 else         continue;
        System.err.flush();
        transform(files[j].getPath(),standardWriter,paths);
        if (outputResult)         standardWriter.flush();
      }
      i++;
    }
    _outputConfig();
    if (outputResult)     standardWriter.close();
  }
}"
75120,"/** 
 * Handle a class declaration or anonymous class declaration. Records and assignment methods are added to the declaration.
 * @param node The AST node of class declaration or anonymous classdeclaration.
 * @param bodyDeclarations The list of body declarations in the class.
 * @param state The current state of the type analyzer.
 */
private void _handleDeclaration(ASTNode node,List bodyDeclarations,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  List newMethods=new LinkedList();
  List newFields=new LinkedList();
  AST ast=node.getAST();
  CompilationUnit root=(CompilationUnit)node.getRoot();
  List fieldNames=new LinkedList();
  List fieldTypes=new LinkedList();
  Iterator bodyIter=bodyDeclarations.iterator();
  while (bodyIter.hasNext()) {
    Object nextDeclaration=bodyIter.next();
    if (nextDeclaration instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)nextDeclaration;
      boolean isStatic=Modifier.isStatic(fieldDecl.getModifiers());
      if (isStatic && HANDLE_STATIC_FIELDS != true)       continue;
      if (Modifier.isPrivate(fieldDecl.getModifiers())) {
        Type type=Type.getType(fieldDecl);
        Iterator fragmentIter=fieldDecl.fragments().iterator();
        while (fragmentIter.hasNext()) {
          VariableDeclarationFragment fragment=(VariableDeclarationFragment)fragmentIter.next();
          String fieldName=fragment.getName().getIdentifier();
          List indicesList=_getAccessedField(currentClass.getName(),fieldName);
          if (indicesList == null)           continue;
          Iterator indicesIter=indicesList.iterator();
          while (indicesIter.hasNext()) {
            int indices=((Integer)indicesIter.next()).intValue();
            newMethods.add(_createAssignMethod(ast,root,state,fieldName,type,indices,isStatic));
          }
          fieldNames.add(fieldName);
          fieldTypes.add(type);
          newFields.add(_createFieldRecord(ast,root,state,fieldName,type.dimensions(),isStatic));
        }
      }
    }
  }
  newFields.add(_createRecordArray(ast,root,state,fieldNames));
  newMethods.add(_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,node instanceof AnonymousClassDeclaration));
  MethodDeclaration getCheckpoint=_createGetCheckpointMethod(ast,root,state,node instanceof AnonymousClassDeclaration);
  if (getCheckpoint != null)   newMethods.add(getCheckpoint);
  MethodDeclaration setCheckpoint=_createSetCheckpointMethod(ast,root,state,node instanceof AnonymousClassDeclaration);
  if (setCheckpoint != null)   newMethods.add(setCheckpoint);
  if (!(node instanceof AnonymousClassDeclaration))   newMethods.add(_createStateSetCheckpointMethod(ast,root,state));
  if (node instanceof AnonymousClassDeclaration)   bodyDeclarations.add(_createProxyClass(ast,root,state));
 else {
    FieldDeclaration checkpointField=_createCheckpointField(ast,root,state);
    if (checkpointField != null)     bodyDeclarations.add(0,checkpointField);
    FieldDeclaration record=_createCheckpointRecord(ast,root,state);
    if (record != null)     newFields.add(0,record);
    String rollbackType=getClassName(Rollbackable.class,state,root);
    ((TypeDeclaration)node).superInterfaces().add(createName(ast,rollbackType));
  }
  bodyDeclarations.addAll(newMethods);
  bodyDeclarations.addAll(newFields);
  if (node instanceof AnonymousClassDeclaration) {
    Initializer initializer=ast.newInitializer();
    Block body=ast.newBlock();
    initializer.setBody(body);
    MethodInvocation addInvocation=ast.newMethodInvocation();
    addInvocation.setExpression(ast.newSimpleName(CHECKPOINT_NAME));
    addInvocation.setName(ast.newSimpleName(""String_Node_Str""));
    ClassInstanceCreation proxy=ast.newClassInstanceCreation();
    proxy.setName(ast.newSimpleName(_getProxyName()));
    addInvocation.arguments().add(proxy);
    body.statements().add(ast.newExpressionStatement(addInvocation));
    bodyDeclarations.add(initializer);
  }
}","/** 
 * Handle a class declaration or anonymous class declaration. Records and assignment methods are added to the declaration.
 * @param node The AST node of class declaration or anonymous classdeclaration.
 * @param bodyDeclarations The list of body declarations in the class.
 * @param state The current state of the type analyzer.
 */
private void _handleDeclaration(ASTNode node,List bodyDeclarations,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  Class parent=currentClass.getSuperclass();
  List newMethods=new LinkedList();
  List newFields=new LinkedList();
  AST ast=node.getAST();
  CompilationUnit root=(CompilationUnit)node.getRoot();
  List fieldNames=new LinkedList();
  List fieldTypes=new LinkedList();
  Iterator bodyIter=bodyDeclarations.iterator();
  while (bodyIter.hasNext()) {
    Object nextDeclaration=bodyIter.next();
    if (nextDeclaration instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)nextDeclaration;
      boolean isStatic=Modifier.isStatic(fieldDecl.getModifiers());
      if (isStatic && HANDLE_STATIC_FIELDS != true)       continue;
      if (Modifier.isPrivate(fieldDecl.getModifiers())) {
        Type type=Type.getType(fieldDecl);
        Iterator fragmentIter=fieldDecl.fragments().iterator();
        while (fragmentIter.hasNext()) {
          VariableDeclarationFragment fragment=(VariableDeclarationFragment)fragmentIter.next();
          String fieldName=fragment.getName().getIdentifier();
          List indicesList=_getAccessedField(currentClass.getName(),fieldName);
          if (indicesList == null)           continue;
          Iterator indicesIter=indicesList.iterator();
          while (indicesIter.hasNext()) {
            int indices=((Integer)indicesIter.next()).intValue();
            newMethods.add(_createAssignMethod(ast,root,state,fieldName,type,indices,isStatic));
          }
          fieldNames.add(fieldName);
          fieldTypes.add(type);
          newFields.add(_createFieldRecord(ast,root,state,fieldName,type.dimensions(),isStatic));
        }
      }
    }
  }
  newFields.add(_createRecordArray(ast,root,state,fieldNames));
  newMethods.add(_createRestoreMethod(ast,root,state,fieldNames,fieldTypes,node instanceof AnonymousClassDeclaration));
  MethodDeclaration getCheckpoint=_createGetCheckpointMethod(ast,root,state,node instanceof AnonymousClassDeclaration);
  if (getCheckpoint != null)   newMethods.add(getCheckpoint);
  MethodDeclaration setCheckpoint=_createSetCheckpointMethod(ast,root,state,node instanceof AnonymousClassDeclaration);
  if (setCheckpoint != null)   newMethods.add(setCheckpoint);
  if (!(node instanceof AnonymousClassDeclaration))   newMethods.add(_createExtraSetCheckpointMethod(ast,root,state));
  if (node instanceof AnonymousClassDeclaration)   bodyDeclarations.add(_createProxyClass(ast,root,state));
 else {
    FieldDeclaration checkpointField=_createCheckpointField(ast,root,state);
    if (checkpointField != null)     bodyDeclarations.add(0,checkpointField);
    FieldDeclaration record=_createCheckpointRecord(ast,root,state);
    if (record != null)     newFields.add(0,record);
    String rollbackType=getClassName(Rollbackable.class,state,root);
    ((TypeDeclaration)node).superInterfaces().add(createName(ast,rollbackType));
  }
  bodyDeclarations.addAll(newMethods);
  bodyDeclarations.addAll(newFields);
  if (node instanceof AnonymousClassDeclaration) {
    Initializer initializer=ast.newInitializer();
    Block body=ast.newBlock();
    initializer.setBody(body);
    MethodInvocation addInvocation=ast.newMethodInvocation();
    addInvocation.setExpression(ast.newSimpleName(CHECKPOINT_NAME));
    addInvocation.setName(ast.newSimpleName(""String_Node_Str""));
    ClassInstanceCreation proxy=ast.newClassInstanceCreation();
    proxy.setName(ast.newSimpleName(_getProxyName()));
    addInvocation.arguments().add(proxy);
    body.statements().add(ast.newExpressionStatement(addInvocation));
    bodyDeclarations.add(initializer);
  }
}"
75121,"private void _refactor(ClassInstanceCreation node,TypeAnalyzerState state){
  AST ast=node.getAST();
  CompilationUnit root=(CompilationUnit)node.getRoot();
  Type type=Type.getType(node);
  MethodInvocation staticSetCheckpoint=ast.newMethodInvocation();
  staticSetCheckpoint.setExpression(createName(ast,getClassName(type.getName(),state,root)));
  staticSetCheckpoint.setName(ast.newSimpleName(SET_CHECKPOINT_NAME));
  staticSetCheckpoint.arguments().add(ASTNode.copySubtree(ast,node));
  staticSetCheckpoint.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  replaceNode(node,staticSetCheckpoint);
}","private void _refactor(ClassInstanceCreation node,TypeAnalyzerState state){
  AST ast=node.getAST();
  CompilationUnit root=(CompilationUnit)node.getRoot();
  Type type=Type.getType(node);
  String setCheckpointName=SET_CHECKPOINT_NAME + ""String_Node_Str"" + Integer.toHexString(state.getCurrentClass().getName().hashCode());
  MethodInvocation extraSetCheckpoint=ast.newMethodInvocation();
  extraSetCheckpoint.setExpression((ClassInstanceCreation)ASTNode.copySubtree(ast,node));
  extraSetCheckpoint.setName(ast.newSimpleName(setCheckpointName));
  extraSetCheckpoint.arguments().add(ast.newSimpleName(CHECKPOINT_NAME));
  replaceNode(node,extraSetCheckpoint);
}"
75122,"private void _handleName(Name node){
  if (node.getParent() != null && !(node.getParent() instanceof Name)) {
    String id=node.toString();
    boolean convert=false;
    Type type=Type.getType(node);
    if (type != null && _crossAnalysisTypes.contains(type.getName()) && _crossAnalysisNames.contains(id))     convert=true;
 else     if (node.getParent() instanceof ImportDeclaration && _crossAnalysisNames.contains(id))     convert=true;
 else     if (node.getParent() instanceof PackageDeclaration)     convert=true;
    if (convert) {
      Name newName=_addPrefix(node.getAST(),node,_prefix);
      if (newName != null)       AbstractTransformer.replaceNode(node,newName);
    }
  }
}","private void _handleName(Name node){
  if (node.getParent() != null) {
    String id=node.toString();
    boolean convert=false;
    Type type=Type.getType(node);
    Type owner=Type.getOwner(node);
    if (type != null && owner == null && _crossAnalysisTypes.contains(type.getName()) && _crossAnalysisNames.contains(id) && type.getName().length() == id.length())     convert=true;
 else     if (node.getParent() instanceof ImportDeclaration && _crossAnalysisNames.contains(id))     convert=true;
 else     if (node.getParent() instanceof PackageDeclaration)     convert=true;
    if (convert) {
      Name newName=_addPrefix(node.getAST(),node,_prefix);
      if (newName != null)       AbstractTransformer.replaceNode(node,newName);
    }
  }
}"
75123,"public String generateInitializeCode() throws IllegalActionException {
  CodeStream tmpStream=new CodeStream(this);
  tmpStream.appendCodeBlock(""String_Node_Str"");
  return processCode(tmpStream.toString());
}","public String generateInitializeCode() throws IllegalActionException {
  super.generateInitializeCode();
  CodeStream tmpStream=new CodeStream(this);
  tmpStream.appendCodeBlock(""String_Node_Str"");
  return processCode(tmpStream.toString());
}"
75124,"/** 
 * Setup the integrator to operate with the current ODE solver. This method checks whether there are enough auxiliary variables in the integrator for the current ODE solver. If not, create more auxiliary variables. <p> This method also adjusts the history information w.r.t. the current ODE solver and the current step size.
 * @return True always.
 * @exception IllegalActionException If there's no director orthe director has no ODE solver.
 */
public boolean prefire() throws IllegalActionException {
  CTDirector dir=(CTDirector)getDirector();
  if (dir == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  ODESolver solver=(ODESolver)dir.getCurrentODESolver();
  if (solver == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  int n=solver.getIntegratorAuxVariableCount();
  if ((_auxVariables == null) || (_auxVariables.length < n)) {
    _auxVariables=new double[n];
  }
  if (getHistoryCapacity() != solver.getAmountOfHistoryInformation()) {
    setHistoryCapacity(solver.getAmountOfHistoryInformation());
  }
  if (getValidHistoryCount() >= 2) {
    _history.rebalance(dir.getCurrentStepSize());
  }
  return true;
}","/** 
 * Setup the integrator to operate with the current ODE solver. This method checks whether there are enough auxiliary variables in the integrator for the current ODE solver. If not, create more auxiliary variables. <p> This method also adjusts the history information w.r.t. the current ODE solver and the current step size.
 * @return True always.
 * @exception IllegalActionException If there's no director orthe director has no ODE solver.
 */
public boolean prefire() throws IllegalActionException {
  CTDirector dir=(CTDirector)getDirector();
  if (dir == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  ODESolver solver=(ODESolver)dir.getCurrentODESolver();
  if (solver == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  int n=solver.getIntegratorAuxVariableCount();
  if ((_auxVariables == null) || (_auxVariables.length != n)) {
    _auxVariables=new double[n];
  }
  if (getHistoryCapacity() != solver.getAmountOfHistoryInformation()) {
    setHistoryCapacity(solver.getAmountOfHistoryInformation());
  }
  if (getValidHistoryCount() >= 2) {
    _history.rebalance(dir.getCurrentStepSize());
  }
  return true;
}"
75125,"/** 
 * Resolve a simple name within the scope of the given type. The name can be a variable name, a field name, or a class relative to that type. If the name corresponds to a field of a class, its owner is encoded in the return object.
 * @param name The simple name to be resolved.
 * @param lastType The type from which the name is resolved. It is used asthe scope for the name. If it is null, the name is resolved in the current scope.
 * @return The type and owner of the name. If the name cannot be found, <tt>null</tt> is returned.
 */
private TypeAndOwner _resolveName(String name,Type lastType){
  if (name.equals(""String_Node_Str"")) {
    int i=0;
  }
  if (_state.getCurrentClass() == null)   return null;
  if (lastType == null) {
    TypeAndOwner varTypeAndOwner=_findVariable(name);
    if (varTypeAndOwner != null)     return varTypeAndOwner;
    Class c=_lookupClass(name);
    if (c != null)     return new TypeAndOwner(Type.createType(c.getName()),null);
  }
  TypeAndOwner typeAndOwner;
  if (lastType == null)   typeAndOwner=_resolveNameFromClass(_state.getCurrentClass(),name);
 else   try {
    typeAndOwner=_resolveNameFromClass(lastType.toClass(_state.getClassLoader()),name);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(lastType);
  }
  if (typeAndOwner == null && lastType == null) {
    Stack previousClasses=_state.getPreviousClasses();
    int previousNumber=previousClasses.size() - 1;
    while (typeAndOwner == null && previousNumber >= 0) {
      Class previousClass=(Class)previousClasses.get(previousNumber--);
      if (previousClass != null)       typeAndOwner=_resolveNameFromClass(previousClass,name);
    }
  }
  return typeAndOwner;
}","/** 
 * Resolve a simple name within the scope of the given type. The name can be a variable name, a field name, or a class relative to that type. If the name corresponds to a field of a class, its owner is encoded in the return object.
 * @param name The simple name to be resolved.
 * @param lastType The type from which the name is resolved. It is used asthe scope for the name. If it is null, the name is resolved in the current scope.
 * @return The type and owner of the name. If the name cannot be found, <tt>null</tt> is returned.
 */
private TypeAndOwner _resolveName(String name,Type lastType){
  if (_state.getCurrentClass() == null)   return null;
  if (lastType == null) {
    TypeAndOwner varTypeAndOwner=_findVariable(name);
    if (varTypeAndOwner != null)     return varTypeAndOwner;
    Class c=_lookupClass(name);
    if (c != null)     return new TypeAndOwner(Type.createType(c.getName()),null);
  }
  TypeAndOwner typeAndOwner;
  if (lastType == null)   typeAndOwner=_resolveNameFromClass(_state.getCurrentClass(),name);
 else   try {
    typeAndOwner=_resolveNameFromClass(lastType.toClass(_state.getClassLoader()),name);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(lastType);
  }
  if (typeAndOwner == null && lastType == null) {
    Stack previousClasses=_state.getPreviousClasses();
    int previousNumber=previousClasses.size() - 1;
    while (typeAndOwner == null && previousNumber >= 0) {
      Class previousClass=(Class)previousClasses.get(previousNumber--);
      if (previousClass != null)       typeAndOwner=_resolveNameFromClass(previousClass,name);
    }
  }
  return typeAndOwner;
}"
75126,"/** 
 * Choose one of the tokens in <i>values</i> randomly, using the <i>pmf</i> parameter to select one.  The chosen token will be sent to the output in the fire() method.
 * @exception If parameter values are incorrect.
 */
protected void _generateRandomNumber() throws IllegalActionException {
  double randomValue=_random.nextDouble();
  ArrayToken valuesToken=(ArrayToken)values.getToken();
  if (_pmf.length != valuesToken.length()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  double cdf=0.0;
  for (int i=0; i < _pmf.length; i++) {
    cdf+=_pmf[i];
    if (randomValue <= cdf) {
      _current=valuesToken.getElement(i);
    }
  }
  _current=valuesToken.getElement(_pmf.length - 1);
}","/** 
 * Choose one of the tokens in <i>values</i> randomly, using the <i>pmf</i> parameter to select one.  The chosen token will be sent to the output in the fire() method.
 * @exception If parameter values are incorrect.
 */
protected void _generateRandomNumber() throws IllegalActionException {
  double randomValue=_random.nextDouble();
  ArrayToken valuesToken=(ArrayToken)values.getToken();
  if (_pmf.length != valuesToken.length()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  double cdf=0.0;
  for (int i=0; i < _pmf.length; i++) {
    cdf+=_pmf[i];
    if (randomValue <= cdf) {
      _current=valuesToken.getElement(i);
      return;
    }
  }
  _current=valuesToken.getElement(_pmf.length - 1);
}"
75127,"public void generateFireCode(StringBuffer stream) throws IllegalActionException {
  ptolemy.actor.lib.AddSubtract actor=(ptolemy.actor.lib.AddSubtract)getComponent();
  StringBuffer tmpStream=new StringBuffer();
  tmpStream.append(""String_Node_Str"");
  for (int i=0; i < actor.plus.getWidth(); i++) {
    tmpStream.append(""String_Node_Str"" + i + ""String_Node_Str"");
    if (i < actor.plus.getWidth() - 1)     tmpStream.append(""String_Node_Str"");
 else     if (actor.minus.getWidth() > 0)     tmpStream.append(""String_Node_Str"");
  }
  for (int i=0; i < actor.minus.getWidth(); i++) {
    tmpStream.append(""String_Node_Str"" + i + ""String_Node_Str"");
    if (i < actor.minus.getWidth() - 1)     tmpStream.append(""String_Node_Str"");
 else     tmpStream.append(""String_Node_Str"");
  }
  stream.append(processCode(tmpStream.toString()));
}","public void generateFireCode(StringBuffer stream) throws IllegalActionException {
  ptolemy.actor.lib.AddSubtract actor=(ptolemy.actor.lib.AddSubtract)getComponent();
  StringBuffer tmpStream=new StringBuffer();
  tmpStream.append(""String_Node_Str"");
  for (int i=0; i < actor.plus.getWidth(); i++) {
    tmpStream.append(""String_Node_Str"" + i + ""String_Node_Str"");
    if (i < actor.plus.getWidth() - 1) {
      tmpStream.append(""String_Node_Str"");
    }
 else     if (actor.minus.getWidth() > 0) {
      tmpStream.append(""String_Node_Str"");
    }
 else {
      tmpStream.append(""String_Node_Str"");
    }
  }
  for (int i=0; i < actor.minus.getWidth(); i++) {
    tmpStream.append(""String_Node_Str"" + i + ""String_Node_Str"");
    if (i < actor.minus.getWidth() - 1) {
      tmpStream.append(""String_Node_Str"");
    }
 else {
      tmpStream.append(""String_Node_Str"");
    }
  }
  stream.append(processCode(tmpStream.toString()));
}"
75128,"/** 
 * @param args
 */
public static void main(String[] args) throws Exception {
  if (args.length == 0)   System.err.println(""String_Node_Str"");
 else {
    String[] paths=PathFinder.getPtClassPaths();
    Writer writer=new OutputStreamWriter(System.out);
    for (int i=0; i < args.length; i++) {
      String fileName=args[i];
      transform(fileName,writer,paths);
    }
    writer.close();
  }
}","/** 
 * Transform a set of files into backtracking-enabled. The set of files is given by a set of strings as their names or the names of the directories that contain them. If 
 * @param args
 */
public static void main(String[] args) throws Exception {
  boolean outputResult=false;
  if (args.length == 0)   System.err.println(""String_Node_Str"" + ""String_Node_Str"");
 else {
    String[] paths=PathFinder.getPtClassPaths();
    Writer writer=outputResult ? new OutputStreamWriter(System.out) : null;
    for (int i=0; i < args.length; i++) {
      String pathOrFile=args[i];
      File[] files=PathFinder.getJavaFiles(pathOrFile,true);
      for (int j=0; j < files.length; j++) {
        String fileName=files[j].getPath();
        System.err.print(""String_Node_Str"" + fileName + ""String_Node_Str"");
        if (fileName.endsWith(""String_Node_Str"")) {
          String classFileName=fileName.substring(0,fileName.length() - 5) + ""String_Node_Str"";
          if (new File(classFileName).exists())           System.err.println();
 else {
            System.err.println(""String_Node_Str"");
            continue;
          }
        }
 else         continue;
        System.err.flush();
        transform(files[j].getPath(),writer,paths);
        if (outputResult)         writer.flush();
      }
    }
    if (outputResult)     writer.close();
  }
}"
75129,"/** 
 * Resolve a simple name within the scope of the given type. The name can be a variable name, a field name, or a class relative to that type. If the name corresponds to a field of a class, its owner is encoded in the return object.
 * @param name The simple name to be resolved.
 * @param lastType The type from which the name is resolved. It is used asthe scope for the name. If it is null, the name is resolved in the current scope.
 * @return The type and owner of the name. If the name cannot be found,<tt>null</tt> is returned.
 */
private TypeAndOwner _resolveName(String name,Type lastType){
  if (_state.getCurrentClass() == null)   return null;
  if (lastType == null) {
    TypeAndOwner varTypeAndOwner=_findVariable(name);
    if (varTypeAndOwner != null)     return varTypeAndOwner;
    Class c=_lookupClass(name);
    if (c != null)     return new TypeAndOwner(Type.createType(c.getName()),null);
  }
  TypeAndOwner typeAndOwner;
  if (lastType == null)   typeAndOwner=_resolveNameFromClass(_state.getCurrentClass(),name);
 else   try {
    typeAndOwner=_resolveNameFromClass(lastType.toClass(_state.getClassLoader()),name);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(lastType);
  }
  if (typeAndOwner == null && lastType == null) {
    Stack previousClasses=_state.getPreviousClasses();
    int previousNumber=previousClasses.size() - 1;
    while (typeAndOwner == null && previousNumber >= 0) {
      Class previousClass=(Class)previousClasses.get(previousNumber--);
      if (previousClass != null)       typeAndOwner=_resolveNameFromClass(previousClass,name);
    }
  }
  return typeAndOwner;
}","/** 
 * Resolve a simple name within the scope of the given type. The name can be a variable name, a field name, or a class relative to that type. If the name corresponds to a field of a class, its owner is encoded in the return object.
 * @param name The simple name to be resolved.
 * @param lastType The type from which the name is resolved. It is used asthe scope for the name. If it is null, the name is resolved in the current scope.
 * @return The type and owner of the name. If the name cannot be found,<tt>null</tt> is returned.
 */
private TypeAndOwner _resolveName(String name,Type lastType){
  if (name.equals(""String_Node_Str"")) {
    int i=0;
  }
  if (_state.getCurrentClass() == null)   return null;
  if (lastType == null) {
    TypeAndOwner varTypeAndOwner=_findVariable(name);
    if (varTypeAndOwner != null)     return varTypeAndOwner;
    Class c=_lookupClass(name);
    if (c != null)     return new TypeAndOwner(Type.createType(c.getName()),null);
  }
  TypeAndOwner typeAndOwner;
  if (lastType == null)   typeAndOwner=_resolveNameFromClass(_state.getCurrentClass(),name);
 else   try {
    typeAndOwner=_resolveNameFromClass(lastType.toClass(_state.getClassLoader()),name);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(lastType);
  }
  if (typeAndOwner == null && lastType == null) {
    Stack previousClasses=_state.getPreviousClasses();
    int previousNumber=previousClasses.size() - 1;
    while (typeAndOwner == null && previousNumber >= 0) {
      Class previousClass=(Class)previousClasses.get(previousNumber--);
      if (previousClass != null)       typeAndOwner=_resolveNameFromClass(previousClass,name);
    }
  }
  return typeAndOwner;
}"
75130,"/** 
 * Execute the model for one iteration. First scan all active actors  to put all enabled and non-deferrable actors in a list and find the  minimax actors. Fire all actors once in the list. If no actor has been fired, fire the minimax actors. If still no actor has been fired, a deadlock has been detected. This concludes one basic iteration, and by default also one iteration of this director. However, if some actor has a parameter named <i>requiredFiringsPerIteration</i> defined, continue to execute basic iterations until the actor has been fired at least the number of times given in that parameter. If more than one actor has such a parameter, then the iteration will continue until all are satisfied. If the parameter  <i>runUntilDeadlockInOneIteration</i> has value true, one iteration  consists of repeatedly executing basic iterations until the actors  under control of this director have reached a deadlock.
 * @exception IllegalActionException If any actor executed by thisactor returns false in prefire().
 */
public void fire() throws IllegalActionException {
  boolean repeatBasicIteration=false;
  do {
    List minimaxActors=new LinkedList();
    int minimaxSize=Integer.MAX_VALUE;
    List toBeFiredActors=new LinkedList();
    Iterator actors=((TypedCompositeActor)getContainer()).deepEntityList().iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (_disabledActors.contains(actor)) {
        continue;
      }
      int[] flags=(int[])_actorsFlags.get(actor);
      int canFire=flags[_ENABLING_STATUS];
      if (canFire == _ENABLED_NOT_DEFERRABLE) {
        toBeFiredActors.add(actor);
      }
      if (canFire == _ENABLED_DEFERRABLE) {
        int newSize=flags[_MAX_NUMBER_OF_TOKENS];
        if (newSize < minimaxSize) {
          minimaxActors.clear();
          minimaxActors.add(actor);
          minimaxSize=newSize;
        }
 else         if (newSize == minimaxSize) {
          minimaxActors.add(actor);
        }
      }
    }
    _firedOne=false;
    Iterator enabledActors=toBeFiredActors.iterator();
    while (enabledActors.hasNext()) {
      Actor actor=(Actor)enabledActors.next();
      _firedOne=_firedOne || _fireActor(actor);
    }
    if (!_firedOne) {
      Iterator minimaxActorsIterator=minimaxActors.iterator();
      while (minimaxActorsIterator.hasNext()) {
        Actor minimaxActor=(Actor)minimaxActorsIterator.next();
        _firedOne=_firedOne || _fireActor(minimaxActor);
      }
    }
    if (_runUntilDeadlock) {
      repeatBasicIteration=_firedOne;
    }
 else     if (_firedOne) {
      actors=_actorsToCheckNumberOfFirings.iterator();
      repeatBasicIteration=false;
      while (actors.hasNext()) {
        Actor actor=(Actor)actors.next();
        if (actor.getContainer() == null) {
          actors.remove();
          continue;
        }
        int[] flags=(int[])_actorsFlags.get(actor);
        int requiredFirings=flags[_REQUIRED_FIRINGS_PER_ITERATION];
        int firingsDone=flags[_NUMBER_OF_FIRINGS];
        if (firingsDone < requiredFirings) {
          repeatBasicIteration=true;
          break;
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      repeatBasicIteration=false;
    }
  }
 while (repeatBasicIteration && !_stopRequested);
}","/** 
 * Execute the model for one iteration. First scan all active actors  to put all enabled and non-deferrable actors in a list and find the  minimax actors. Fire all actors once in the list. If no actor has been fired, fire the minimax actors. If still no actor has been fired, a deadlock has been detected. This concludes one basic iteration, and by default also one iteration of this director. However, if some actor has a parameter named <i>requiredFiringsPerIteration</i> defined, continue to execute basic iterations until the actor has been fired at least the number of times given in that parameter. If more than one actor has such a parameter, then the iteration will continue until all are satisfied. If the parameter  <i>runUntilDeadlockInOneIteration</i> has value true, one iteration  consists of repeatedly executing basic iterations until the actors  under control of this director have reached a deadlock.
 * @exception IllegalActionException If any actor executed by thisactor returns false in prefire().
 */
public void fire() throws IllegalActionException {
  boolean repeatBasicIteration=false;
  do {
    List minimaxActors=new LinkedList();
    int minimaxSize=Integer.MAX_VALUE;
    List toBeFiredActors=new LinkedList();
    Iterator actors=((TypedCompositeActor)getContainer()).deepEntityList().iterator();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (_disabledActors.contains(actor)) {
        continue;
      }
      int[] flags=(int[])_actorsFlags.get(actor);
      int canFire=flags[_ENABLING_STATUS];
      if (canFire == _ENABLED_NOT_DEFERRABLE) {
        toBeFiredActors.add(actor);
      }
      if (canFire == _ENABLED_DEFERRABLE) {
        int newSize=flags[_MAX_NUMBER_OF_TOKENS];
        if (newSize < minimaxSize) {
          minimaxActors.clear();
          minimaxActors.add(actor);
          minimaxSize=newSize;
        }
 else         if (newSize == minimaxSize) {
          minimaxActors.add(actor);
        }
      }
    }
    _firedOne=false;
    Iterator enabledActors=toBeFiredActors.iterator();
    while (enabledActors.hasNext()) {
      Actor actor=(Actor)enabledActors.next();
      boolean amIFired=_fireActor(actor);
      _firedOne=amIFired || _firedOne;
    }
    if (!_firedOne) {
      Iterator minimaxActorsIterator=minimaxActors.iterator();
      while (minimaxActorsIterator.hasNext()) {
        Actor minimaxActor=(Actor)minimaxActorsIterator.next();
        boolean amIFired=_fireActor(minimaxActor);
        _firedOne=amIFired || _firedOne;
      }
    }
    if (_runUntilDeadlock) {
      repeatBasicIteration=_firedOne;
    }
 else     if (_firedOne) {
      actors=_actorsToCheckNumberOfFirings.iterator();
      repeatBasicIteration=false;
      while (actors.hasNext()) {
        Actor actor=(Actor)actors.next();
        if (actor.getContainer() == null) {
          actors.remove();
          continue;
        }
        int[] flags=(int[])_actorsFlags.get(actor);
        int requiredFirings=flags[_REQUIRED_FIRINGS_PER_ITERATION];
        int firingsDone=flags[_NUMBER_OF_FIRINGS];
        if (firingsDone < requiredFirings) {
          repeatBasicIteration=true;
          break;
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      repeatBasicIteration=false;
    }
  }
 while (repeatBasicIteration && !_stopRequested);
}"
75131,"/** 
 * Determine actor enabling status. It must be one of the three: _NOT_ENABLED, _ENABLED_DEFERRABLE, _ENABLED_NOT_DEFERRABLE.
 * @param actor The actor to be checked.
 * @return An int indicating actor enabling status.
 * @exception IllegalActionException If any called method throwsIllegalActionException.
 */
protected int _getActorStatus(Actor actor) throws IllegalActionException {
  if (!_isEnabled(actor)) {
    return _NOT_ENABLED;
  }
  if (_isDeferrable(actor)) {
    return _ENABLED_DEFERRABLE;
  }
  return _ENABLED_NOT_DEFERRABLE;
}","/** 
 * Determine actor enabling status. It must be one of the three: _NOT_ENABLED, _ENABLED_DEFERRABLE, _ENABLED_NOT_DEFERRABLE.
 * @param actor The actor to be checked.
 * @return An int indicating actor enabling status.
 * @exception IllegalActionException If any called method throwsIllegalActionException.
 */
protected int _getActorStatus(Actor actor) throws IllegalActionException {
  if (!_isEnabled(actor)) {
    if (_debugging)     _debug(((NamedObj)actor).getName() + ""String_Node_Str"");
    return _NOT_ENABLED;
  }
  if (_isDeferrable(actor)) {
    if (_debugging)     _debug(((NamedObj)actor).getName() + ""String_Node_Str"");
    return _ENABLED_DEFERRABLE;
  }
  if (_debugging)   _debug(((NamedObj)actor).getName() + ""String_Node_Str"");
  return _ENABLED_NOT_DEFERRABLE;
}"
75132,"/** 
 * Consume at most one token from the <i>input</i> and compute the average of the input tokens so far. Send the result to the output.  If there is no input token available, no output will be produced.  If there is a true-valued token on the <i>reset</i> input, then the average is reset, and the output will be equal to the <i>input</i> token (if there is one). If the fire method is invoked multiple times in one iteration, then only the input read on the last invocation in the iteration will affect future averages.  Inputs that are read earlier in the iteration are forgotten.
 * @exception IllegalActionException If addition or division by aninteger are not supported by the supplied tokens.
 */
public void fire() throws IllegalActionException {
  _latestSum=_sum;
  _latestCount=_count + 1;
  for (int i=0; i < reset.getWidth(); i++) {
    if (reset.hasToken(i)) {
      BooleanToken r=(BooleanToken)reset.get(i);
      if (r.booleanValue()) {
        _latestSum=null;
        _latestCount=1;
      }
    }
  }
  if (input.hasToken(0)) {
    Token in=input.get(0);
    if (_latestSum == null) {
      _latestSum=in;
    }
 else {
      _latestSum=_latestSum.add(in);
    }
    Token out=_latestSum.divide(new IntToken(_latestCount));
    output.broadcast(out);
  }
}","/** 
 * Consume at most one token from the <i>input</i> and compute the average of the input tokens so far. Send the result to the output.  If there is no input token available, no output will be produced.  If there is a true-valued token on the <i>reset</i> input, then the average is reset, and the output will be equal to the <i>input</i> token (if there is one). If the fire method is invoked multiple times in one iteration, then only the input read on the last invocation in the iteration will affect future averages.  Inputs that are read earlier in the iteration are forgotten.
 * @exception IllegalActionException If addition or division by aninteger are not supported by the supplied tokens.
 */
public void fire() throws IllegalActionException {
  _latestSum=_sum;
  _latestCount=_count;
  for (int i=0; i < reset.getWidth(); i++) {
    if (reset.hasToken(i)) {
      BooleanToken r=(BooleanToken)reset.get(i);
      if (r.booleanValue()) {
        _latestSum=null;
        _latestCount=0;
      }
    }
  }
  if (input.hasToken(0)) {
    Token in=input.get(0);
    _latestCount++;
    if (_latestSum == null) {
      _latestSum=in;
    }
 else {
      _latestSum=_latestSum.add(in);
    }
    Token out=_latestSum.divide(new IntToken(_latestCount));
    output.broadcast(out);
  }
}"
75133,"/** 
 * Get the type of a field in a class by its name. If not found in the class definition, this function also searches the superclasses of that class, as well as the interfaces that the class and its superclasses implement.
 * @param c The class from which the field name is resolved.
 * @param name The name of the field.
 * @return The type of the field if found; otherwise, <tt>null</tt>.
 * @see #_getMethodType(Class,String,Type[])
 */
protected TypeAndOwner _getFieldTypeAndOwner(Class c,String name){
  if (c.isArray() && name.equals(""String_Node_Str""))   return new TypeAndOwner(Type.createType(c.getName()),Type.INT);
  Field field;
  List workList=new LinkedList();
  Set handledSet=new HashSet();
  workList.add(c);
  while (!workList.isEmpty()) {
    Class topClass=(Class)workList.remove(0);
    try {
      field=topClass.getDeclaredField(name);
      return new TypeAndOwner(Type.createType(topClass.getName()),Type.createType(field.getType().getName()));
    }
 catch (    NoSuchFieldException e1) {
    }
    handledSet.add(topClass);
    Class superClass=topClass.getSuperclass();
    if (superClass == null && !topClass.getName().equals(""String_Node_Str""))     superClass=Object.class;
    if (superClass != null)     workList.add(superClass);
    Class[] interfaces=topClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  return null;
}","/** 
 * Get the type of a field in a class by its name. If not found in the class definition, this function also searches the superclasses of that class, as well as the interfaces that the class and its superclasses implement.
 * @param c The class from which the field name is resolved.
 * @param name The name of the field.
 * @return The type of the field if found; otherwise, <tt>null</tt>.
 * @see #_getMethodType(Class,String,Type[])
 */
protected TypeAndOwner _getFieldTypeAndOwner(Class c,String name){
  if (c.isArray() && name.equals(""String_Node_Str""))   return new TypeAndOwner(Type.INT,Type.createType(c.getName()));
  Field field;
  List workList=new LinkedList();
  Set handledSet=new HashSet();
  workList.add(c);
  while (!workList.isEmpty()) {
    Class topClass=(Class)workList.remove(0);
    try {
      field=topClass.getDeclaredField(name);
      return new TypeAndOwner(Type.createType(field.getType().getName()),Type.createType(topClass.getName()));
    }
 catch (    NoSuchFieldException e1) {
    }
    handledSet.add(topClass);
    Class superClass=topClass.getSuperclass();
    if (superClass == null && !topClass.getName().equals(""String_Node_Str""))     superClass=Object.class;
    if (superClass != null)     workList.add(superClass);
    Class[] interfaces=topClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  return null;
}"
75134,"private void _handleDeclaration(ASTNode node,List bodyDeclarations,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  List newDeclarations=new LinkedList();
  Iterator bodyIter=bodyDeclarations.iterator();
  while (bodyIter.hasNext()) {
    Object nextDeclaration=bodyIter.next();
    if (nextDeclaration instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)nextDeclaration;
      boolean isStatic=Modifier.isStatic(fieldDecl.getModifiers());
      if (isStatic && HANDLE_STATIC_FIELDS != true)       continue;
      if (Modifier.isPrivate(fieldDecl.getModifiers())) {
        AST ast=fieldDecl.getAST();
        Type type=Type.getType(fieldDecl);
        Iterator fragmentIter=fieldDecl.fragments().iterator();
        while (fragmentIter.hasNext()) {
          VariableDeclarationFragment fragment=(VariableDeclarationFragment)fragmentIter.next();
          String fieldName=fragment.getName().getIdentifier();
          List indicesList=_getAccessedField(currentClass.getName(),fieldName);
          if (indicesList == null)           continue;
          Iterator indicesIter=indicesList.iterator();
          while (indicesIter.hasNext()) {
            int indices=((Integer)indicesIter.next()).intValue();
            newDeclarations.add(_createAssignMethod(currentClass,ast,fieldName,type,indices,isStatic,state.getClassLoader()));
            newDeclarations.add(_createFieldRecord(currentClass,ast,fieldName,indices,isStatic));
          }
        }
      }
    }
  }
  bodyDeclarations.addAll(newDeclarations);
  AST ast=node.getAST();
  VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
  fragment.setName(ast.newSimpleName(CHECKPOINT_NAME));
  FieldDeclaration checkpointField=ast.newFieldDeclaration(fragment);
  checkpointField.setType(_createType(ast,Checkpoint.class.getName()));
  checkpointField.setModifiers(Modifier.PRIVATE);
  bodyDeclarations.add(checkpointField);
}","private void _handleDeclaration(ASTNode node,List bodyDeclarations,TypeAnalyzerState state){
  Class currentClass=state.getCurrentClass();
  List newMethods=new LinkedList();
  List newFields=new LinkedList();
  Iterator bodyIter=bodyDeclarations.iterator();
  while (bodyIter.hasNext()) {
    Object nextDeclaration=bodyIter.next();
    if (nextDeclaration instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)nextDeclaration;
      boolean isStatic=Modifier.isStatic(fieldDecl.getModifiers());
      if (isStatic && HANDLE_STATIC_FIELDS != true)       continue;
      if (Modifier.isPrivate(fieldDecl.getModifiers())) {
        AST ast=fieldDecl.getAST();
        Type type=Type.getType(fieldDecl);
        Iterator fragmentIter=fieldDecl.fragments().iterator();
        while (fragmentIter.hasNext()) {
          VariableDeclarationFragment fragment=(VariableDeclarationFragment)fragmentIter.next();
          String fieldName=fragment.getName().getIdentifier();
          List indicesList=_getAccessedField(currentClass.getName(),fieldName);
          if (indicesList == null)           continue;
          Iterator indicesIter=indicesList.iterator();
          while (indicesIter.hasNext()) {
            int indices=((Integer)indicesIter.next()).intValue();
            newMethods.add(_createAssignMethod(currentClass,ast,fieldName,type,indices,isStatic,state.getClassLoader()));
            newFields.add(_createFieldRecord(currentClass,ast,fieldName,indices,isStatic));
          }
        }
      }
    }
  }
  bodyDeclarations.addAll(newMethods);
  bodyDeclarations.addAll(newFields);
  AST ast=node.getAST();
  VariableDeclarationFragment fragment=ast.newVariableDeclarationFragment();
  fragment.setName(ast.newSimpleName(CHECKPOINT_NAME));
  FieldDeclaration checkpointField=ast.newFieldDeclaration(fragment);
  checkpointField.setType(_createType(ast,Checkpoint.class.getName()));
  checkpointField.setModifiers(Modifier.PRIVATE);
  bodyDeclarations.add(checkpointField);
}"
75135,"private String _getAssignMethodName(String fieldName,int indices){
  return ASSIGN_PREFIX + fieldName + (indices == 0 ? ""String_Node_Str"" : ""String_Node_Str"" + indices);
}","private String _getAssignMethodName(String fieldName){
  return ASSIGN_PREFIX + fieldName;
}"
75136,"private MethodDeclaration _createAssignMethod(Class currentClass,AST ast,String fieldName,Type fieldType,int indices,boolean isStatic,ClassLoader loader){
  String methodName=_getAssignMethodName(fieldName,indices);
  if (_isMethodDuplicated(currentClass,methodName,fieldType,indices,isStatic,loader))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  MethodDeclaration method=ast.newMethodDeclaration();
  for (int i=0; i < indices; i++)   try {
    fieldType=fieldType.removeOneDimension();
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(fieldType);
  }
  SimpleName name=ast.newSimpleName(_getAssignMethodName(fieldName,indices));
  method.setName(name);
  org.eclipse.jdt.core.dom.Type type=_createType(ast,fieldType.getName());
  method.setReturnType(type);
  if (isStatic) {
    SingleVariableDeclaration checkpoint=ast.newSingleVariableDeclaration();
    checkpoint.setType(ast.newSimpleType(_createName(ast,Checkpoint.class.getName())));
    checkpoint.setName(ast.newSimpleName(CHECKPOINT_NAME));
    method.parameters().add(checkpoint);
  }
  for (int i=0; i < indices; i++) {
    SingleVariableDeclaration index=ast.newSingleVariableDeclaration();
    index.setType(ast.newPrimitiveType(PrimitiveType.INT));
    index.setName(ast.newSimpleName(""String_Node_Str"" + i));
    method.parameters().add(index);
  }
  SingleVariableDeclaration argument=ast.newSingleVariableDeclaration();
  argument.setType((org.eclipse.jdt.core.dom.Type)ASTNode.copySubtree(ast,type));
  argument.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(argument);
  Block body=_createAssignmentBlock(ast,fieldName,indices);
  method.setBody(body);
  int modifiers=Modifier.PRIVATE;
  if (isStatic)   modifiers|=Modifier.STATIC;
  method.setModifiers(modifiers);
  return method;
}","private MethodDeclaration _createAssignMethod(Class currentClass,AST ast,String fieldName,Type fieldType,int indices,boolean isStatic,ClassLoader loader){
  String methodName=_getAssignMethodName(fieldName);
  if (_isMethodDuplicated(currentClass,methodName,fieldType,indices,isStatic,loader))   throw new ASTDuplicatedMethodException(currentClass.getName(),methodName);
  MethodDeclaration method=ast.newMethodDeclaration();
  for (int i=0; i < indices; i++)   try {
    fieldType=fieldType.removeOneDimension();
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(fieldType);
  }
  SimpleName name=ast.newSimpleName(methodName);
  method.setName(name);
  org.eclipse.jdt.core.dom.Type type=_createType(ast,fieldType.getName());
  method.setReturnType(type);
  if (isStatic) {
    SingleVariableDeclaration checkpoint=ast.newSingleVariableDeclaration();
    checkpoint.setType(ast.newSimpleType(_createName(ast,Checkpoint.class.getName())));
    checkpoint.setName(ast.newSimpleName(CHECKPOINT_NAME));
    method.parameters().add(checkpoint);
  }
  for (int i=0; i < indices; i++) {
    SingleVariableDeclaration index=ast.newSingleVariableDeclaration();
    index.setType(ast.newPrimitiveType(PrimitiveType.INT));
    index.setName(ast.newSimpleName(""String_Node_Str"" + i));
    method.parameters().add(index);
  }
  SingleVariableDeclaration argument=ast.newSingleVariableDeclaration();
  argument.setType((org.eclipse.jdt.core.dom.Type)ASTNode.copySubtree(ast,type));
  argument.setName(ast.newSimpleName(""String_Node_Str""));
  method.parameters().add(argument);
  Block body=_createAssignmentBlock(ast,fieldName,indices);
  method.setBody(body);
  int modifiers=Modifier.PRIVATE | Modifier.FINAL;
  if (isStatic)   modifiers|=Modifier.STATIC;
  method.setModifiers(modifiers);
  return method;
}"
75137,"/** 
 * Summarize an AST from by traversing it from the root with a user specified visitor as the summary builder. If the file name given is not <tt>null</tt>, it is set to be the source file name of the resulting summary. <p>
 * @param root Root of an AST.
 * @param fileName The name of the source file from which theAST is built.
 * @param visitor The customized visitor, usually of a subclassof  {@link TraversalVisitor}.
 * @return The summary.
 */
public static FileSummary summarize(ASTCompilationUnit root,String fileName,JavaParserVisitor visitor){
  SummaryLoaderState state=new SummaryLoaderState();
  if (fileName != null)   state.setFile(new File(fileName));
  root.jjtAccept(visitor,state);
  return (FileSummary)state.getCurrentSummary();
}","/** 
 * Summarize an AST from by traversing it from the root with a user specified visitor as the summary builder. If the file name given is not <tt>null</tt>, it is set to be the source file name of the resulting summary. <p>
 * @param root Root of an AST.
 * @param fileName The name of the source file from which theAST is built.
 * @param visitor The customized visitor, usually of a subclassof  {@link org.acm.seguin.summary.TraversalVisitor}.
 * @return The summary.
 */
public static FileSummary summarize(ASTCompilationUnit root,String fileName,JavaParserVisitor visitor){
  SummaryLoaderState state=new SummaryLoaderState();
  if (fileName != null)   state.setFile(new File(fileName));
  root.jjtAccept(visitor,state);
  return (FileSummary)state.getCurrentSummary();
}"
75138,"/** 
 * Check if a class is explicitly imported, or is any nested class in the explicitly imported class. The class looked for can be nested, when ""$"" appears in its name.
 * @param dollarName The name of the class to be loaded. ""$"" is usedas the separator between a nested class name and the name of its enclosing class.
 * @param resolve Whether to resolve the class.
 * @param importedClass The data structure that specifies an importedclass.
 * @return The class loaded if found. If no such class is found,<tt>null</tt> is returned.
 */
private Class _checkClassNameWithImportClass(StringBuffer dollarName,boolean resolve,ClassImport importedClass){
  int dotPos=dollarName.indexOf(""String_Node_Str"");
  if (dotPos == -1)   dotPos=dollarName.length();
  if (importedClass.className.equals(dollarName.substring(0,dotPos))) {
    dollarName.insert(0,'.');
    dollarName.insert(0,importedClass.packageName);
    try {
      String className=dollarName.toString();
      Class c=super.loadClass(className,resolve);
      _loadedClasses.put(className,c);
      return c;
    }
 catch (    ClassNotFoundException e) {
      return null;
    }
 finally {
      dollarName.delete(0,importedClass.packageName.length() + 1);
    }
  }
 else   return null;
}","/** 
 * Check if a class is explicitly imported, or is any nested class in the explicitly imported class. The class looked for can be nested, when ""$"" appears in its name.
 * @param dollarName The name of the class to be loaded. ""$"" is usedas the separator between a nested class name and the name of its enclosing class.
 * @param resolve Whether to resolve the class.
 * @param importedClass The data structure that specifies an importedclass.
 * @return The class loaded if found. If no such class is found,<tt>null</tt> is returned.
 */
private Class _checkClassNameWithImportClass(StringBuffer dollarName,boolean resolve,ClassImport importedClass){
  int dotPos=dollarName.indexOf(""String_Node_Str"");
  if (dotPos == -1)   dotPos=dollarName.length();
  if (importedClass.className.equals(dollarName.substring(0,dotPos))) {
    dollarName.insert(0,'.');
    dollarName.insert(0,importedClass.packageName);
    try {
      String className=dollarName.toString();
      Class c=super.loadClass(className,resolve);
      _loadedClasses.put(className,c);
      return c;
    }
 catch (    ClassNotFoundException e) {
      return null;
    }
catch (    NoClassDefFoundError e) {
      return null;
    }
 finally {
      dollarName.delete(0,importedClass.packageName.length() + 1);
    }
  }
 else   return null;
}"
75139,"/** 
 * Check if a class with the given name can be found relative to the given package. The class can be nested, when ""$"" appears in its name.
 * @param dollarName The name of the class to be loaded. ""$"" is usedas the separator between a nested class name and the name of its enclosing class.
 * @param resolve Whether to resolve the class.
 * @param packageName The name of the package (may contain ""."") inwhich the class is searched for.
 * @return The class loaded if found. If no such class is found,<tt>null</tt> is returned.
 */
private Class _checkClassNameWithImportPackage(StringBuffer dollarName,boolean resolve,String packageName){
  dollarName.insert(0,'.');
  dollarName.insert(0,packageName);
  try {
    String className=dollarName.toString();
    Class c=super.loadClass(className,resolve);
    _loadedClasses.put(className,c);
    return c;
  }
 catch (  ClassNotFoundException e) {
    return null;
  }
 finally {
    dollarName.delete(0,packageName.length() + 1);
  }
}","/** 
 * Check if a class with the given name can be found relative to the given package. The class can be nested, when ""$"" appears in its name.
 * @param dollarName The name of the class to be loaded. ""$"" is usedas the separator between a nested class name and the name of its enclosing class.
 * @param resolve Whether to resolve the class.
 * @param packageName The name of the package (may contain ""."") inwhich the class is searched for.
 * @return The class loaded if found. If no such class is found,<tt>null</tt> is returned.
 */
private Class _checkClassNameWithImportPackage(StringBuffer dollarName,boolean resolve,String packageName){
  dollarName.insert(0,'.');
  dollarName.insert(0,packageName);
  try {
    String className=dollarName.toString();
    Class c=super.loadClass(className,resolve);
    _loadedClasses.put(className,c);
    return c;
  }
 catch (  ClassNotFoundException e) {
    return null;
  }
catch (  NoClassDefFoundError e) {
    return null;
  }
 finally {
    dollarName.delete(0,packageName.length() + 1);
  }
}"
75140,"/** 
 * Check if the given name refers to an array class. If so, load the array class.
 * @param name The name of the class to be loaded.
 * @param resolve Whether to resolve the class.
 * @return The class loaded if not <tt>null</tt>. If the name doesnot refer to an array class, the return value is <tt>null</tt>.
 * @throws ClassNotFoundException Thrown when the name refers toan array class but the class cannot be loaded.
 * @see #searchForClass(StringBuffer,boolean,Class)
 */
private Class _checkArrayClass(StringBuffer name,boolean resolve) throws ClassNotFoundException {
  boolean isPrimitiveArray;
  int nameStart=0;
  int nameEnd=name.length() - 1;
  if (name.charAt(nameStart) == '[') {
    while (name.charAt(nameStart) == '[')     nameStart++;
    if (name.charAt(nameStart) == 'L') {
      nameStart++;
      nameEnd--;
      isPrimitiveArray=false;
    }
 else     isPrimitiveArray=true;
  }
 else   if (name.charAt(nameEnd) == ']') {
    while (name.charAt(nameEnd) == ']')     nameEnd-=2;
    isPrimitiveArray=Type.isPrimitive(name.substring(nameStart,nameEnd + 1));
  }
 else   return null;
  if (isPrimitiveArray) {
    String typeName=Type.toArrayType(name.toString());
    Class c=super.loadClass(typeName,resolve);
    _loadedClasses.put(typeName,c);
    return c;
  }
 else {
    Class c=loadClass(name.substring(nameStart,nameEnd + 1));
    name.delete(nameStart,nameEnd + 1);
    name.insert(nameStart,c.getName());
    String typeName=Type.toArrayType(name.toString());
    c=Class.forName(typeName);
    _loadedClasses.put(typeName,c);
    return c;
  }
}","/** 
 * Check if the given name refers to an array class. If so, load the array class.
 * @param name The name of the class to be loaded.
 * @param resolve Whether to resolve the class.
 * @return The class loaded if not <tt>null</tt>. If the name doesnot refer to an array class, the return value is <tt>null</tt>.
 * @throws ClassNotFoundException Thrown when the name refers toan array class but the class cannot be loaded.
 * @see #searchForClass(StringBuffer,boolean,Class)
 */
private Class _checkArrayClass(StringBuffer name,boolean resolve) throws ClassNotFoundException {
  boolean isPrimitiveArray;
  int nameStart=0;
  int nameEnd=name.length() - 1;
  if (name.charAt(nameStart) == '[') {
    while (name.charAt(nameStart) == '[')     nameStart++;
    if (name.charAt(nameStart) == 'L') {
      nameStart++;
      nameEnd--;
      isPrimitiveArray=false;
    }
 else     isPrimitiveArray=true;
  }
 else   if (name.charAt(nameEnd) == ']') {
    while (name.charAt(nameEnd) == ']')     nameEnd-=2;
    isPrimitiveArray=Type.isPrimitive(name.substring(nameStart,nameEnd + 1));
  }
 else   return null;
  if (isPrimitiveArray) {
    String typeName=Type.toArrayType(name.toString());
    Class c=super.loadClass(typeName,resolve);
    _loadedClasses.put(typeName,c);
    return c;
  }
 else {
    Class c=loadClass(name.substring(nameStart,nameEnd + 1));
    name.delete(nameStart,nameEnd + 1);
    name.insert(nameStart,c.getName());
    String typeName=Type.toArrayType(name.toString());
    c=Class.forName(typeName,true,_urlClassLoader);
    _loadedClasses.put(typeName,c);
    return c;
  }
}"
75141,"/** 
 * Search for a class with a partial name in the current scope. It is called in   {@link #loadClass(String,boolean)}. <p> It takes the following steps in this name resolving: <ol> <li>Check if the name represents an array. An array type is treated as a special class in Java. The name of an array is either like ""<tt>char[]</tt>"" (source representation) or like ""<tt>[C</tt>"" (JVM internal representation). If this is the case, it recursively calls itself with the type of the elements in the array (if not primitive), and then loads the array class and return. </li> <li>Check if the name corresponds to a nested class in the current class. In JVM representation, nested class names are separated with ""$"" from their containers. If so, the nested class is returned. </li> <li>Check if the name is already a full class name, e.g., ""<tt>java.lang.Class</tt>"". If so, the class is loaded with   {@link URLClassLoader#loadClass(String,boolean)}and returned. Nested classes (case 2) take precedence over this full name resolution. </li> <li>For every class explicitly imported with   {@link #importClass(String)}, check if its simple class name (the last part) is the same as the first part of the class name to be searched for. If so, the imported class is loaded, and if necessary, its nested classes are searched. </li> <li>Check if the partial name is relative to the current package. </li> <li>Check if the partial name is relative to any package explicitly imported with   {@link #importPackage(String)}. The implicitly imported package ""<tt>java.lang</tt>"" is also searched. </li> </ol>
 * @param name The partial name of the class to be loaded.
 * @param resolve Whether {@link #resolveClass(Class)} should becalled.
 * @param currentClass The current class.
 * @return The class loaded with the given name in the scope.
 * @throws ClassNotFoundException If the class cannot be found.
 * @see #importClass(String)
 * @see #importPackage(String)
 * @see #loadClass(String,boolean)
 */
protected Class searchForClass(StringBuffer name,boolean resolve,Class currentClass) throws ClassNotFoundException {
  StringBuffer dollarName=new StringBuffer(name.toString().replace('.','$'));
  Class c=_checkArrayClass(name,resolve);
  if (c == null)   c=_checkNestedClass(dollarName,resolve,currentClass);
  if (c == null)   c=_checkFullClassName(name,resolve);
  if (c == null) {
    Iterator importedClassesIter=_importedClasses.iterator();
    while (c == null && importedClassesIter.hasNext())     c=_checkClassNameWithImportClass(dollarName,resolve,(ClassImport)importedClassesIter.next());
  }
  if (c == null && _packageName != null)   c=_checkClassNameWithImportPackage(dollarName,resolve,_packageName);
  if (c == null) {
    Iterator importedPackagesIter=_importedPackages.iterator();
    while (c == null && importedPackagesIter.hasNext())     c=_checkClassNameWithImportPackage(dollarName,resolve,(String)importedPackagesIter.next());
  }
  if (c == null)   c=_checkClassNameWithImportPackage(dollarName,resolve,""String_Node_Str"");
  if (c == null) {
    int lastDotPos=name.length();
    while (c == null && lastDotPos != -1) {
      lastDotPos=name.lastIndexOf(""String_Node_Str"",lastDotPos);
      if (lastDotPos >= 0) {
        name.setCharAt(lastDotPos,'$');
        try {
          c=super.loadClass(name.toString(),resolve);
        }
 catch (        ClassNotFoundException e) {
        }
      }
    }
  }
  if (c == null)   throw new ClassNotFoundException(name.toString());
 else   return c;
}","/** 
 * Search for a class with a partial name in the current scope. It is called in   {@link #loadClass(String,boolean)}. <p> It takes the following steps in this name resolving: <ol> <li>Check if the name represents an array. An array type is treated as a special class in Java. The name of an array is either like ""<tt>char[]</tt>"" (source representation) or like ""<tt>[C</tt>"" (JVM internal representation). If this is the case, it recursively calls itself with the type of the elements in the array (if not primitive), and then loads the array class and return. </li> <li>Check if the name corresponds to a nested class in the current class. In JVM representation, nested class names are separated with ""$"" from their containers. If so, the nested class is returned. </li> <li>Check if the name is already a full class name, e.g., ""<tt>java.lang.Class</tt>"". If so, the class is loaded with   {@link URLClassLoader#loadClass(String,boolean)}and returned. Nested classes (case 2) take precedence over this full name resolution. </li> <li>For every class explicitly imported with   {@link #importClass(String)}, check if its simple class name (the last part) is the same as the first part of the class name to be searched for. If so, the imported class is loaded, and if necessary, its nested classes are searched. </li> <li>Check if the partial name is relative to the current package. </li> <li>Check if the partial name is relative to any package explicitly imported with   {@link #importPackage(String)}. The implicitly imported package ""<tt>java.lang</tt>"" is also searched. </li> </ol>
 * @param name The partial name of the class to be loaded.
 * @param resolve Whether {@link #resolveClass(Class)} should becalled.
 * @param currentClass The current class.
 * @return The class loaded with the given name in the scope.
 * @throws ClassNotFoundException If the class cannot be found.
 * @see #importClass(String)
 * @see #importPackage(String)
 * @see #loadClass(String,boolean)
 */
protected Class searchForClass(StringBuffer name,boolean resolve,Class currentClass) throws ClassNotFoundException {
  if (name.toString().equals(""String_Node_Str"")) {
    int i=0;
  }
  StringBuffer dollarName=new StringBuffer(name.toString().replace('.','$'));
  Class c=_checkArrayClass(name,resolve);
  if (c == null)   c=_checkNestedClass(dollarName,resolve,currentClass);
  if (c == null)   c=_checkFullClassName(name,resolve);
  if (c == null) {
    Iterator importedClassesIter=_importedClasses.iterator();
    while (c == null && importedClassesIter.hasNext())     c=_checkClassNameWithImportClass(dollarName,resolve,(ClassImport)importedClassesIter.next());
  }
  if (c == null && _packageName != null)   c=_checkClassNameWithImportPackage(dollarName,resolve,_packageName);
  if (c == null) {
    Iterator importedPackagesIter=_importedPackages.iterator();
    while (c == null && importedPackagesIter.hasNext())     c=_checkClassNameWithImportPackage(dollarName,resolve,(String)importedPackagesIter.next());
  }
  if (c == null)   c=_checkClassNameWithImportPackage(dollarName,resolve,""String_Node_Str"");
  if (c == null) {
    int lastDotPos=name.length();
    while (c == null && lastDotPos != -1) {
      lastDotPos=name.lastIndexOf(""String_Node_Str"",lastDotPos);
      if (lastDotPos >= 0) {
        name.setCharAt(lastDotPos,'$');
        try {
          c=super.loadClass(name.toString(),resolve);
        }
 catch (        ClassNotFoundException e) {
        }
catch (        NoClassDefFoundError e) {
        }
      }
    }
  }
  if (c == null)   throw new ClassNotFoundException(name.toString());
 else   return c;
}"
75142,"/** 
 * Check if the name corresponds to a nested class in a specified current class. If so, load the nested class and return it. This function does not load anonymous classes with names like ""Class$1"". Users should not dynamically resolve anonymous classes, because they cannot be instantiated without knowing the enclosing method and the enclosing class.
 * @param dollarName The name of the nested class to be loaded. ""$"" isused as the separator between a nested class name and the name of its enclosing class.
 * @param resolve Whether to resolve the class.
 * @param currentClass The current class from whose scope the nested classis searched for.
 * @return The nested class loaded if found. If no such class is found orerror occurs while loading, the return value is <tt>null</tt>.
 * @see #searchForClass(StringBuffer,boolean,Class)
 */
private Class _checkNestedClass(StringBuffer dollarName,boolean resolve,Class currentClass){
  if (currentClass == null)   return null;
  Set handledSet=new HashSet();
  List workList=new LinkedList();
  workList.add(currentClass);
  while (!workList.isEmpty()) {
    Class c=(Class)workList.remove(0);
    dollarName.insert(0,""String_Node_Str"");
    dollarName.insert(0,c.getName());
    try {
      String className=dollarName.toString();
      Class classLoaded=super.loadClass(className,resolve);
      _loadedClasses.put(className,classLoaded);
      return classLoaded;
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError e) {
    }
 finally {
      dollarName.delete(0,c.getName().length() + 1);
    }
    handledSet.add(c);
    Class declaring=c.getDeclaringClass();
    if (declaring != null && !handledSet.contains(declaring))     workList.add(declaring);
    Class superClass=c.getSuperclass();
    if (superClass != null && !handledSet.contains(superClass))     workList.add(superClass);
    Class[] interfaces=c.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  return null;
}","/** 
 * Check if the name corresponds to a nested class in a specified current class. If so, load the nested class and return it. This function does not load anonymous classes with names like ""Class$1"". Users should not dynamically resolve anonymous classes, because they cannot be instantiated without knowing the enclosing method and the enclosing class.
 * @param dollarName The name of the nested class to be loaded. ""$"" isused as the separator between a nested class name and the name of its enclosing class.
 * @param resolve Whether to resolve the class.
 * @param currentClass The current class from whose scope the nested classis searched for.
 * @return The nested class loaded if found. If no such class is found orerror occurs while loading, the return value is <tt>null</tt>.
 * @see #searchForClass(StringBuffer,boolean,Class)
 */
private Class _checkNestedClass(StringBuffer dollarName,boolean resolve,Class currentClass){
  if (currentClass == null)   return null;
  Set handledSet=new HashSet();
  List workList=new LinkedList();
  workList.add(currentClass);
  while (!workList.isEmpty()) {
    Class c=(Class)workList.remove(0);
    dollarName.insert(0,""String_Node_Str"");
    dollarName.insert(0,c.getName());
    try {
      String className=dollarName.toString();
      Class classLoaded=super.loadClass(className,resolve);
      _loadedClasses.put(className,classLoaded);
      return classLoaded;
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError e) {
    }
 finally {
      dollarName.delete(0,c.getName().length() + 1);
    }
    handledSet.add(c);
    try {
      Class declaring=c.getDeclaringClass();
      if (declaring != null && !handledSet.contains(declaring))       workList.add(declaring);
    }
 catch (    ClassCircularityError e) {
    }
    if (_enclosingClasses.containsKey(c.getName()))     workList.add(_enclosingClasses.get(c.getName()));
    Class superClass=c.getSuperclass();
    if (superClass != null && !handledSet.contains(superClass))     workList.add(superClass);
    Class[] interfaces=c.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  return null;
}"
75143,"/** 
 * Check if the name is a full name corresponds to a class. A full name contains the package name as its prefix and the simple class name as its postfix, separated with a ""."".
 * @param name The name of the class to be loaded.
 * @param resolve Whether to resolve the class.
 * @return The class loaded if found. If no such class is found,<tt>null</tt> is returned.
 */
private Class _checkFullClassName(StringBuffer name,boolean resolve){
  String nameString=name.toString();
  try {
    Class c=super.loadClass(nameString,resolve);
    _loadedClasses.put(nameString,c);
    return c;
  }
 catch (  ClassNotFoundException e) {
    return null;
  }
}","/** 
 * Check if the name is a full name corresponds to a class. A full name contains the package name as its prefix and the simple class name as its postfix, separated with a ""."".
 * @param name The name of the class to be loaded.
 * @param resolve Whether to resolve the class.
 * @return The class loaded if found. If no such class is found,<tt>null</tt> is returned.
 */
private Class _checkFullClassName(StringBuffer name,boolean resolve){
  String nameString=name.toString();
  try {
    Class c=super.loadClass(nameString,resolve);
    _loadedClasses.put(nameString,c);
    return c;
  }
 catch (  ClassNotFoundException e) {
    return null;
  }
catch (  NoClassDefFoundError e) {
    return null;
  }
}"
75144,"/** 
 * Construct a class loader with a set of class paths specified as a string array. The class loader looks for classes in those paths in order.
 * @param classPaths The array of class paths to be searched inorder.
 */
public LocalClassLoader(String[] classPaths){
  super(_stringsToUrls(classPaths),null,null);
}","/** 
 * Construct a class loader with a set of class paths specified as a string array. The class loader looks for classes in those paths in order.
 * @param classPaths The array of class paths to be searched inorder.
 */
public LocalClassLoader(String[] classPaths){
  super(_stringsToUrls(classPaths),null,null);
  _urlClassLoader=new URLClassLoader(getURLs(),null,null);
}"
75145,"/** 
 * Get the type of a field in a class by its name. If not found in the class definition, this function also searches the superclasses of that class, as well as the interfaces that the class and its superclasses implement.
 * @param c The class from which the field name is resolved.
 * @param name The name of the field.
 * @return The type of the field if found; otherwise, <tt>null</tt>.
 * @see #getMethodType(Class,String,Type[])
 */
protected Type getFieldType(Class c,String name){
  Field field;
  List workList=new LinkedList();
  Set handledSet=new HashSet();
  workList.add(c);
  while (!workList.isEmpty()) {
    Class topClass=(Class)workList.remove(0);
    try {
      field=topClass.getDeclaredField(name);
      return Type.createType(field.getType().getName());
    }
 catch (    NoSuchFieldException e1) {
    }
    handledSet.add(topClass);
    Class[] interfaces=topClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  return null;
}","/** 
 * Get the type of a field in a class by its name. If not found in the class definition, this function also searches the superclasses of that class, as well as the interfaces that the class and its superclasses implement.
 * @param c The class from which the field name is resolved.
 * @param name The name of the field.
 * @return The type of the field if found; otherwise, <tt>null</tt>.
 * @see #getMethodType(Class,String,Type[])
 */
protected Type getFieldType(Class c,String name){
  Field field;
  List workList=new LinkedList();
  Set handledSet=new HashSet();
  workList.add(c);
  while (!workList.isEmpty()) {
    Class topClass=(Class)workList.remove(0);
    try {
      field=topClass.getDeclaredField(name);
      return Type.createType(field.getType().getName());
    }
 catch (    NoSuchFieldException e1) {
    }
    handledSet.add(topClass);
    Class superClass=topClass.getSuperclass();
    if (superClass == null && !topClass.getName().equals(""String_Node_Str""))     superClass=Object.class;
    if (superClass != null)     workList.add(superClass);
    Class[] interfaces=topClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  return null;
}"
75146,"/** 
 * Resolve a name within the scope of the given type. The name can be a variable name, a field name, ""this"" or ""super"", a method name, or a class relative to that type. If the name is a method name, arguments of the method must be given.
 * @param name The name to be resolved.
 * @param lastType The type from which the name is resolved.
 * @param args Not <tt>null</tt> if a method is to be resolved, inwhich case it is the arguments for the method.
 * @throws ASTClassNotFoundException A class cannot be loaded whenresolving the type of a name.
 * @throws ASTResolutionException The name cannot be resolved fromthe given type.
 */
private void resolveName(ASTName name,Type lastType,ASTArguments args) throws ASTClassNotFoundException, ASTResolutionException {
  Type[] arguments=ASTArguments2Types(args);
  Class owner;
  try {
    owner=lastType == null ? _currentClass : lastType.toClass(_loader);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(lastType.getName());
  }
  int length=name.jjtGetNumChildren();
  String remainingName=""String_Node_Str"";
  for (int i=0; i < length; i++) {
    ASTIdentifier id=(ASTIdentifier)name.jjtGetChild(i);
    String currentName=remainingName + id.getImage();
    if (currentName.equals(""String_Node_Str"")) {
      Type.setType(id,Type.createType(owner.getName()));
      continue;
    }
 else     if (currentName.equals(""String_Node_Str"")) {
      Type.setType(id,Type.createType(owner.getSuperclass().getName()));
      continue;
    }
    if (i == 0 && lastType == null) {
      Type vtype=findVariable(currentName);
      if (vtype != null) {
        Type.setType(id,vtype);
        if (vtype.isPrimitive())         owner=null;
 else         try {
          owner=vtype.toClass(_loader);
        }
 catch (        ClassNotFoundException e) {
          throw new ASTClassNotFoundException(vtype.getName());
        }
        continue;
      }
    }
    Type idType;
    if (i < length - 1)     idType=resolveNameFromClass(owner,currentName,null);
 else     idType=resolveNameFromClass(owner,currentName,arguments);
    Type.setType(id,idType);
    if (idType != null) {
      remainingName=""String_Node_Str"";
      if (idType.isPrimitive())       owner=null;
 else       try {
        owner=idType.toClass(_loader);
      }
 catch (      ClassNotFoundException e) {
        throw new ASTClassNotFoundException(idType.getName());
      }
    }
 else     if (i < length - 1)     remainingName=currentName + ""String_Node_Str"";
 else     throw new ASTResolutionException(owner.getName(),currentName);
  }
  Type.propagateType(name,name.jjtGetChild(length - 1));
}","/** 
 * Resolve a name within the scope of the given type. The name can be a variable name, a field name, ""this"" or ""super"", a method name, or a class relative to that type. If the name is a method name, arguments of the method must be given.
 * @param name The name to be resolved.
 * @param lastType The type from which the name is resolved.
 * @param args Not <tt>null</tt> if a method is to be resolved, inwhich case it is the arguments for the method.
 * @throws ASTClassNotFoundException A class cannot be loaded whenresolving the type of a name.
 * @throws ASTResolutionException The name cannot be resolved fromthe given type.
 */
private void resolveName(ASTName name,Type lastType,ASTArguments args) throws ASTClassNotFoundException, ASTResolutionException {
  Type[] arguments=ASTArguments2Types(args);
  Class owner;
  try {
    owner=lastType == null ? _currentClass : lastType.toClass(_loader);
  }
 catch (  ClassNotFoundException e) {
    throw new ASTClassNotFoundException(lastType.getName());
  }
  int length=name.jjtGetNumChildren();
  String remainingName=""String_Node_Str"";
  for (int i=0; i < length; i++) {
    ASTIdentifier id=(ASTIdentifier)name.jjtGetChild(i);
    String currentName=remainingName + id.getImage();
    if (currentName.equals(""String_Node_Str"")) {
      int x=0;
    }
    if (currentName.equals(""String_Node_Str"")) {
      Type.setType(id,Type.createType(owner.getName()));
      continue;
    }
 else     if (currentName.equals(""String_Node_Str"")) {
      Type.setType(id,Type.createType(owner.getSuperclass().getName()));
      continue;
    }
    if (i == 0 && lastType == null) {
      Type vtype=findVariable(currentName);
      if (vtype != null) {
        Type.setType(id,vtype);
        if (vtype.isPrimitive())         owner=null;
 else         try {
          owner=vtype.toClass(_loader);
        }
 catch (        ClassNotFoundException e) {
          throw new ASTClassNotFoundException(vtype.getName());
        }
        continue;
      }
    }
    Type idType;
    Type[] argumentsForResolution=i < length - 1 ? null : arguments;
    idType=resolveNameFromClass(owner,currentName,argumentsForResolution);
    if (idType == null && lastType == null && i == 0) {
      int previousClassNum=_previousClasses.size() - 1;
      while (idType == null && previousClassNum >= 0) {
        Class previousClass=(Class)_previousClasses.get(previousClassNum);
        if (previousClass != null)         idType=resolveNameFromClass(previousClass,currentName,argumentsForResolution);
        previousClassNum--;
      }
    }
    Type.setType(id,idType);
    if (idType != null) {
      remainingName=""String_Node_Str"";
      if (idType.isPrimitive())       owner=null;
 else       try {
        owner=idType.toClass(_loader);
      }
 catch (      ClassNotFoundException e) {
        throw new ASTClassNotFoundException(idType.getName());
      }
    }
 else     if (i < length - 1)     remainingName=currentName + ""String_Node_Str"";
 else     throw new ASTResolutionException(owner.getName(),currentName);
  }
  Type.propagateType(name,name.jjtGetChild(length - 1));
}"
75147,"/** 
 * Get the type of a method in a class by its name and types of actural arguments. If not found in the class definition, this function also searches the superclasses of that class, as well as the interfaces that the class and its superclasses implement. <p> This function always tries to find the best match if multiple methods with the same name and the same number of arguments are defined in the class and interface hierarchy. This is accomplished by computing the compatibility rating between each pair of formal argument and actural argument, and sum those numbers together.
 * @param c The class from which the method is resolved.
 * @param name The name of the field.
 * @param args The types of actural arguments for a call.
 * @return The return type of the method if found; otherwise,<tt>null</tt>.
 * @see #getFieldType(Class,String)
 * @see Type#compatibility(Type,ClassLoader)
 */
protected Type getMethodType(Class c,String name,Type[] args) throws ASTClassNotFoundException {
  Method[] methods=null;
  int best_compatibility=-1;
  Method best_method=null;
  List workList=new LinkedList();
  Set handledSet=new HashSet();
  workList.add(c);
  while (!workList.isEmpty()) {
    Class topClass=(Class)workList.remove(0);
    methods=topClass.getDeclaredMethods();
    for (int i=0; i < methods.length; i++) {
      Method method=methods[i];
      if (method.getName().equals(name)) {
        Class[] formalParams=method.getParameterTypes();
        if (formalParams.length == args.length) {
          int compatibility=0;
          for (int j=0; j < formalParams.length; j++)           try {
            Type formalType=Type.createType(formalParams[j].getName());
            int comp=args[j].compatibility(formalType,_loader);
            if (comp == -1) {
              compatibility=-1;
              break;
            }
 else             compatibility+=comp;
          }
 catch (          ClassNotFoundException e) {
            throw new ASTClassNotFoundException(args[j].getName());
          }
          if (compatibility == -1)           continue;
 else           if (best_compatibility == -1 || best_compatibility > compatibility) {
            best_compatibility=compatibility;
            best_method=method;
            if (best_compatibility == 0)             break;
          }
        }
      }
    }
    if (best_compatibility == 0)     break;
    handledSet.add(topClass);
    Class[] interfaces=topClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  if (best_compatibility != -1)   return Type.createType(best_method.getReturnType().getName());
 else   return null;
}","/** 
 * Get the type of a method in a class by its name and types of actural arguments. If not found in the class definition, this function also searches the superclasses of that class, as well as the interfaces that the class and its superclasses implement. <p> This function always tries to find the best match if multiple methods with the same name and the same number of arguments are defined in the class and interface hierarchy. This is accomplished by computing the compatibility rating between each pair of formal argument and actural argument, and sum those numbers together.
 * @param c The class from which the method is resolved.
 * @param name The name of the field.
 * @param args The types of actural arguments for a call.
 * @return The return type of the method if found; otherwise,<tt>null</tt>.
 * @see #getFieldType(Class,String)
 * @see Type#compatibility(Type,ClassLoader)
 */
protected Type getMethodType(Class c,String name,Type[] args) throws ASTClassNotFoundException {
  Method[] methods=null;
  int best_compatibility=-1;
  Method best_method=null;
  List workList=new LinkedList();
  Set handledSet=new HashSet();
  workList.add(c);
  while (!workList.isEmpty()) {
    Class topClass=(Class)workList.remove(0);
    methods=topClass.getDeclaredMethods();
    for (int i=0; i < methods.length; i++) {
      Method method=methods[i];
      if (method.getName().equals(name)) {
        Class[] formalParams=method.getParameterTypes();
        if (formalParams.length == args.length) {
          int compatibility=0;
          for (int j=0; j < formalParams.length; j++)           try {
            Type formalType=Type.createType(formalParams[j].getName());
            int comp=args[j].compatibility(formalType,_loader);
            if (comp == -1) {
              compatibility=-1;
              break;
            }
 else             compatibility+=comp;
          }
 catch (          ClassNotFoundException e) {
            throw new ASTClassNotFoundException(args[j].getName());
          }
          if (compatibility == -1)           continue;
 else           if (best_compatibility == -1 || best_compatibility > compatibility) {
            best_compatibility=compatibility;
            best_method=method;
            if (best_compatibility == 0)             break;
          }
        }
      }
    }
    if (best_compatibility == 0)     break;
    handledSet.add(topClass);
    Class superClass=topClass.getSuperclass();
    if (superClass == null && !topClass.getName().equals(""String_Node_Str""))     superClass=Object.class;
    if (superClass != null)     workList.add(superClass);
    Class[] interfaces=topClass.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  if (best_compatibility != -1)   return Type.createType(best_method.getReturnType().getName());
 else   return null;
}"
75148,"/** 
 * Resolve a name within the scope of the given class. The name can be a field name, a method name, or a class relative to that class. If the name is a method name, arguments of the method must be given.
 * @param owner The class from which the name is resolved.
 * @param name The name to be resolved.
 * @param args Not <tt>null</tt> if a method is to be resolved, inwhich case it is the array of formal argument types for that method.
 * @return The type of that name if found.
 * @see #resolveName(ASTName,Type,ASTArguments)
 */
private Type resolveNameFromClass(Class owner,String name,Type[] args){
  if (owner.isArray()) {
    if (name.equals(""String_Node_Str"") && args == null)     return Type.INT;
 else     if (name.equals(""String_Node_Str"") && args != null && args.length == 0)     return Type.createType(""String_Node_Str"");
  }
  if (args == null) {
    Type fieldType=getFieldType(owner,name);
    if (fieldType != null)     return fieldType;
  }
 else {
    Type methodType=getMethodType(owner,name,args);
    if (methodType != null)     return methodType;
  }
  try {
    Class c=_loader.loadClass(name,owner);
    return Type.createType(c.getName());
  }
 catch (  ClassNotFoundException e) {
  }
  Class superclass=owner.getSuperclass();
  if (superclass == null && !owner.getName().equals(""String_Node_Str""))   superclass=Object.class;
  if (superclass != null) {
    Type result=resolveNameFromClass(superclass,name,args);
    if (result != null)     return result;
  }
  Type t=null;
  if (previousClassCount < 0) {
    previousClassCount=_previousClasses.size() - 1;
    Class previous=(Class)_previousClasses.get(previousClassCount);
    if (previous != null)     t=resolveNameFromClass(previous,name,args);
  }
 else   if (previousClassCount > 0) {
    previousClassCount--;
    Class previous=(Class)_previousClasses.get(previousClassCount);
    if (previous != null)     t=resolveNameFromClass(previous,name,args);
  }
  previousClassCount=-1;
  return t;
}","/** 
 * Resolve a name within the scope of the given class. The name can be a field name, a method name, or a class relative to that class. If the name is a method name, arguments of the method must be given.
 * @param owner The class from which the name is resolved.
 * @param name The name to be resolved.
 * @param args Not <tt>null</tt> if a method is to be resolved, inwhich case it is the array of formal argument types for that method.
 * @return The type of that name if found.
 * @see #resolveName(ASTName,Type,ASTArguments)
 */
private Type resolveNameFromClass(Class owner,String name,Type[] args){
  if (owner.isArray()) {
    if (name.equals(""String_Node_Str"") && args == null)     return Type.INT;
 else     if (name.equals(""String_Node_Str"") && args != null && args.length == 0)     return Type.createType(""String_Node_Str"");
  }
  if (args == null) {
    Type fieldType=getFieldType(owner,name);
    if (fieldType != null)     return fieldType;
  }
 else {
    Type methodType=getMethodType(owner,name,args);
    if (methodType != null)     return methodType;
  }
  try {
    Class c=_loader.loadClass(name,owner);
    return Type.createType(c.getName());
  }
 catch (  ClassNotFoundException e) {
  }
  Class superclass=owner.getSuperclass();
  if (superclass == null && !owner.getName().equals(""String_Node_Str""))   superclass=Object.class;
  if (superclass != null) {
    Type result=resolveNameFromClass(superclass,name,args);
    if (result != null)     return result;
  }
  return null;
}"
75149,"/** 
 * Get the common type of two types when they appear in an expression. The following rules are followed: <ol> <li>Two object types cannot be computed in an expression, unless one of them is   {@link String}, in which case the result type is   {@link String}. </li> <li>Primitive types can be computed (+) with only one object type, which is   {@link String}. The result is also  {@link String}. </li> <li>When two different primitive types are computed, one of them must be coerced to the other one, which can store more information. </li> </ol>
 * @param type1 One of the types to be evaluated.
 * @param type2 The other of the types to be evaluated.
 * @return The common type of the two if any, or <tt>null</tt>(not the <tt>null</tt> primitive type) if none.
 */
public static Type getCommonType(Type type1,Type type2){
  try {
    if (type1.getName().equals(""String_Node_Str""))     return type1;
 else     if (type2.getName().equals(""String_Node_Str""))     return type2;
 else     if (type1.isPrimitive() && type2.isPrimitive())     if (type1.compatibility(type2,ClassLoader.getSystemClassLoader()) >= 0)     return type2;
 else     if (type2.compatibility(type1,ClassLoader.getSystemClassLoader()) >= 0)     return type1;
  }
 catch (  ClassNotFoundException e) {
  }
  return null;
}","/** 
 * Get the common type of two types when they appear in an expression. The following rules are followed: <ol> <li> <li>Two object types cannot be computed in an expression, unless one of them is   {@link String}, in which case the result type is   {@link String}, or they are the same type. </li> <li>Primitive types can be computed (+) with only one object type, which is   {@link String}. The result is also  {@link String}. </li> <li>When two different primitive types are computed, one of them must be coerced to the other one, which can store more information. </li> </ol>
 * @param type1 One of the types to be evaluated.
 * @param type2 The other of the types to be evaluated.
 * @return The common type of the two if any, or <tt>null</tt>(not the <tt>null</tt> primitive type) if none.
 */
public static Type getCommonType(Type type1,Type type2){
  try {
    if (type1.equals(type2))     return type1;
 else     if (type1.getName().equals(""String_Node_Str""))     return type1;
 else     if (type2.getName().equals(""String_Node_Str""))     return type2;
 else     if (type1.isPrimitive() && type2.isPrimitive())     if (type1.compatibility(type2,ClassLoader.getSystemClassLoader()) >= 0)     return type2;
 else     if (type2.compatibility(type1,ClassLoader.getSystemClassLoader()) >= 0)     return type1;
  }
 catch (  ClassNotFoundException e) {
  }
  return null;
}"
75150,"/** 
 * Compute the compatibility rating between this type and another formal type. If the result is larger than or equal to 0, the two types are compatible. An object of this type can be assigned to the given formal type only when the two types are compatible. <p> The compatibility rating is an integer number. When it is -1, the two types are not compatible. When it is 0, the two types are the same. When it is a natural number, it denotes how compatible the two types are. The smaller this natural number is, the more compatible this type is with the given formal type.
 * @param formalType The formal type to be evaluated.
 * @param loader The {@link ClassLoader} object to be used when theclasses of types are resolved. This functioon uses this loader to resolve both types if they are classes, and also their superclasses and the interfaces that they implement, if necessary.
 * @return The compatibility rating as an integer larger than or equal to-1.
 * @throws ClassNotFoundException Thrown when a class cannot be loaded.
 */
public int compatibility(Type formalType,ClassLoader loader) throws ClassNotFoundException {
  if (equals(formalType))   return 0;
  if (_primitiveNum == NULL_NUM && !formalType.isPrimitive())   return 0;
  if (isPrimitive() != formalType.isPrimitive())   return -1;
  if (isPrimitive())   if (formalType.isPrimitive())   if (_primitiveNum == CHAR_NUM)   if (formalType._primitiveNum == INT_NUM)   return 1;
 else   if (formalType._primitiveNum == LONG_NUM)   return 2;
 else   if (formalType._primitiveNum == FLOAT_NUM)   return 3;
 else   if (formalType._primitiveNum == DOUBLE_NUM)   return 4;
 else   return -1;
 else   if (_primitiveNum == INT_NUM)   if (formalType._primitiveNum == LONG_NUM)   return 1;
 else   if (formalType._primitiveNum == FLOAT_NUM)   return 2;
 else   if (formalType._primitiveNum == DOUBLE_NUM)   return 3;
 else   return -1;
 else   if (_primitiveNum == LONG_NUM)   if (formalType._primitiveNum == DOUBLE_NUM)   return 1;
 else   return -1;
 else   if (_primitiveNum == SHORT_NUM)   if (formalType._primitiveNum == INT_NUM)   return 1;
 else   if (formalType._primitiveNum == LONG_NUM)   return 2;
 else   if (formalType._primitiveNum == FLOAT_NUM)   return 3;
 else   if (formalType._primitiveNum == DOUBLE_NUM)   return 4;
 else   return -1;
 else   if (_primitiveNum == BYTE_NUM)   if (formalType._primitiveNum == SHORT_NUM)   return 1;
 else   if (formalType._primitiveNum == INT_NUM)   return 2;
 else   if (formalType._primitiveNum == LONG_NUM)   return 3;
 else   if (formalType._primitiveNum == FLOAT_NUM)   return 4;
 else   if (formalType._primitiveNum == DOUBLE_NUM)   return 5;
 else   return -1;
 else   if (_fullName.equals(""String_Node_Str""))   if (formalType._fullName.equals(""String_Node_Str""))   return 1;
 else   return -1;
 else   return -1;
 else   return -1;
 else {
    Type selfType=this;
    while (selfType.isArray() && formalType.isArray()) {
      selfType=selfType.removeOneDimension();
      formalType=formalType.removeOneDimension();
    }
    Class class1=selfType.toClass(loader);
    Class class2=formalType.toClass(loader);
    int i=0;
    while (class1 != null) {
      if (class1.getName().equals(class2.getName()))       return i;
      Class[] interfaces=class1.getInterfaces();
      for (int j=0; j < interfaces.length; j++) {
        Class superInterface=interfaces[j];
        Class[] superInterfaces=superInterface.getInterfaces();
        for (int k=0; k <= superInterfaces.length; k++) {
          Class currentInterface;
          if (k == 0)           currentInterface=superInterface;
 else           currentInterface=superInterfaces[k - 1];
          if (currentInterface.getName().equals(class2.getName()))           return i;
        }
      }
      i++;
      class1=class1.getSuperclass();
    }
    if (class2.getName().equals(""String_Node_Str""))     return i;
 else     return -1;
  }
}","/** 
 * Compute the compatibility rating between this type and another formal type. If the result is larger than or equal to 0, the two types are compatible. An object of this type can be assigned to the given formal type only when the two types are compatible. <p> The compatibility rating is an integer number. When it is -1, the two types are not compatible. When it is 0, the two types are the same. When it is a natural number, it denotes how compatible the two types are. The smaller this natural number is, the more compatible this type is with the given formal type.
 * @param formalType The formal type to be evaluated.
 * @param loader The {@link ClassLoader} object to be used when theclasses of types are resolved. This functioon uses this loader to resolve both types if they are classes, and also their superclasses and the interfaces that they implement, if necessary.
 * @return The compatibility rating as an integer larger than or equal to-1.
 * @throws ClassNotFoundException Thrown when a class cannot be loaded.
 */
public int compatibility(Type formalType,ClassLoader loader) throws ClassNotFoundException {
  if (equals(formalType))   return 0;
  if (_primitiveNum == NULL_NUM && !formalType.isPrimitive())   return 0;
  if (isPrimitive() != formalType.isPrimitive())   return -1;
  if (isPrimitive())   if (formalType.isPrimitive())   if (_primitiveNum == CHAR_NUM)   if (formalType._primitiveNum == INT_NUM)   return 1;
 else   if (formalType._primitiveNum == LONG_NUM)   return 2;
 else   if (formalType._primitiveNum == FLOAT_NUM)   return 3;
 else   if (formalType._primitiveNum == DOUBLE_NUM)   return 4;
 else   return -1;
 else   if (_primitiveNum == INT_NUM)   if (formalType._primitiveNum == LONG_NUM)   return 1;
 else   if (formalType._primitiveNum == FLOAT_NUM)   return 2;
 else   if (formalType._primitiveNum == DOUBLE_NUM)   return 3;
 else   if (formalType._primitiveNum == BYTE_NUM)   return 4;
 else   if (formalType._primitiveNum == SHORT_NUM)   return 4;
 else   return -1;
 else   if (_primitiveNum == LONG_NUM)   if (formalType._primitiveNum == DOUBLE_NUM)   return 1;
 else   return -1;
 else   if (_primitiveNum == SHORT_NUM)   if (formalType._primitiveNum == INT_NUM)   return 1;
 else   if (formalType._primitiveNum == LONG_NUM)   return 2;
 else   if (formalType._primitiveNum == FLOAT_NUM)   return 3;
 else   if (formalType._primitiveNum == DOUBLE_NUM)   return 4;
 else   return -1;
 else   if (_primitiveNum == BYTE_NUM)   if (formalType._primitiveNum == SHORT_NUM)   return 1;
 else   if (formalType._primitiveNum == INT_NUM)   return 2;
 else   if (formalType._primitiveNum == LONG_NUM)   return 3;
 else   if (formalType._primitiveNum == FLOAT_NUM)   return 4;
 else   if (formalType._primitiveNum == DOUBLE_NUM)   return 5;
 else   return -1;
 else   if (_fullName.equals(""String_Node_Str""))   if (formalType._fullName.equals(""String_Node_Str""))   return 1;
 else   return -1;
 else   return -1;
 else   return -1;
 else {
    Type selfType=this;
    while (selfType.isArray() && formalType.isArray()) {
      selfType=selfType.removeOneDimension();
      formalType=formalType.removeOneDimension();
    }
    Class class1=selfType.toClass(loader);
    Class class2=formalType.toClass(loader);
    int i=0;
    while (class1 != null) {
      List workList=new LinkedList();
      Set handledSet=new HashSet();
      workList.add(class1);
      while (!workList.isEmpty()) {
        Class c=(Class)workList.remove(0);
        if (c.getName().equals(class2.getName()))         return i;
        handledSet.add(c);
        Class[] interfaces=c.getInterfaces();
        for (int k=0; k < interfaces.length; k++)         if (!handledSet.contains(interfaces[k]))         workList.add(interfaces[k]);
      }
      i++;
      class1=class1.getSuperclass();
    }
    if (class2.getName().equals(""String_Node_Str""))     return i;
 else     return -1;
  }
}"
75151,"/** 
 * Check if the name corresponds to a nested class in a specified current class. If so, load the nested class and return it. This function does not load anonymous classes with names like ""Class$1"". Users should not dynamically resolve anonymous classes, because they cannot be instantiated without knowing the enclosing method and the enclosing class.
 * @param dollarName The name of the nested class to be loaded. ""$"" isused as the separator between a nested class name and the name of its enclosing class.
 * @param resolve Whether to resolve the class.
 * @param currentClass The current class from whose scope the nested classis searched for.
 * @return The nested class loaded if found. If no such class is found orerror occurs while loading, the return value is <tt>null</tt>.
 * @see #searchForClass(StringBuffer,boolean,Class)
 */
private Class _checkNestedClass(StringBuffer dollarName,boolean resolve,Class currentClass){
  if (currentClass == null)   return null;
  Set handledSet=new HashSet();
  List workList=new LinkedList();
  workList.add(currentClass);
  while (!workList.isEmpty()) {
    Class c=(Class)workList.remove(0);
    dollarName.insert(0,""String_Node_Str"");
    dollarName.insert(0,c.getName());
    try {
      String className=dollarName.toString();
      Class classLoaded=super.loadClass(className,resolve);
      _loadedClasses.put(className,classLoaded);
      return classLoaded;
    }
 catch (    ClassNotFoundException e) {
    }
 finally {
      dollarName.delete(0,c.getName().length() + 1);
    }
    handledSet.add(c);
    Class declaring=c.getDeclaringClass();
    if (declaring != null && !handledSet.contains(declaring))     workList.add(declaring);
    Class superClass=c.getSuperclass();
    if (superClass != null && !handledSet.contains(superClass))     workList.add(superClass);
    Class[] interfaces=c.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  return null;
}","/** 
 * Check if the name corresponds to a nested class in a specified current class. If so, load the nested class and return it. This function does not load anonymous classes with names like ""Class$1"". Users should not dynamically resolve anonymous classes, because they cannot be instantiated without knowing the enclosing method and the enclosing class.
 * @param dollarName The name of the nested class to be loaded. ""$"" isused as the separator between a nested class name and the name of its enclosing class.
 * @param resolve Whether to resolve the class.
 * @param currentClass The current class from whose scope the nested classis searched for.
 * @return The nested class loaded if found. If no such class is found orerror occurs while loading, the return value is <tt>null</tt>.
 * @see #searchForClass(StringBuffer,boolean,Class)
 */
private Class _checkNestedClass(StringBuffer dollarName,boolean resolve,Class currentClass){
  if (currentClass == null)   return null;
  Set handledSet=new HashSet();
  List workList=new LinkedList();
  workList.add(currentClass);
  while (!workList.isEmpty()) {
    Class c=(Class)workList.remove(0);
    dollarName.insert(0,""String_Node_Str"");
    dollarName.insert(0,c.getName());
    try {
      String className=dollarName.toString();
      Class classLoaded=super.loadClass(className,resolve);
      _loadedClasses.put(className,classLoaded);
      return classLoaded;
    }
 catch (    ClassNotFoundException e) {
    }
catch (    NoClassDefFoundError e) {
    }
 finally {
      dollarName.delete(0,c.getName().length() + 1);
    }
    handledSet.add(c);
    Class declaring=c.getDeclaringClass();
    if (declaring != null && !handledSet.contains(declaring))     workList.add(declaring);
    Class superClass=c.getSuperclass();
    if (superClass != null && !handledSet.contains(superClass))     workList.add(superClass);
    Class[] interfaces=c.getInterfaces();
    for (int i=0; i < interfaces.length; i++)     if (!handledSet.contains(interfaces[i]))     workList.add(interfaces[i]);
  }
  return null;
}"
75152,"/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is iterated repeatedly (prefire(), fire(), postfire()), until either it has no more input tokens, or its prefire() method returns false. <p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
public void fire() throws IllegalActionException {
  _mutationEnabled=false;
  while (true) {
    Actor actorToFire=_getNextActorToFire();
    if (actorToFire == null) {
      if (_isTopLevel()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _noMoreActorsToFire=true;
      }
 else {
        if (_debugging) {
          _debug(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _microstep=0;
      return;
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ _microstep);
    }
    if (actorToFire == getContainer()) {
      return;
    }
    boolean refire;
    do {
      refire=false;
      if (_debugging) {
        if (((Nameable)actorToFire).getContainer() == null) {
          _debug(""String_Node_Str"");
          _disableActor(actorToFire);
          break;
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
        if (!actorToFire.prefire()) {
          _debug(""String_Node_Str"");
          break;
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
        actorToFire.fire();
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
        if (!actorToFire.postfire()) {
          _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
          _disableActor(actorToFire);
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
      }
 else {
        if (((Nameable)actorToFire).getContainer() == null) {
          _disableActor(actorToFire);
          break;
        }
        if (!actorToFire.prefire()) {
          break;
        }
        actorToFire.fire();
        if (!actorToFire.postfire()) {
          _disableActor(actorToFire);
          break;
        }
      }
      Iterator inputPorts=actorToFire.inputPortList().iterator();
      while (inputPorts.hasNext() && !refire) {
        IOPort port=(IOPort)inputPorts.next();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.hasToken(i)) {
            refire=true;
            break;
          }
        }
      }
    }
 while (refire);
synchronized (_eventQueue) {
      if (!_eventQueue.isEmpty()) {
        DEEvent next=_eventQueue.get();
        if ((next.timeStamp().compareTo(getModelTime()) > 0) || next.microstep() > _microstep) {
          break;
        }
 else         if ((next.timeStamp().compareTo(getModelTime()) < 0) || next.microstep() < _microstep) {
          throw new IllegalActionException(""String_Node_Str"" + next.timeStamp() + ""String_Node_Str""+ next.microstep()+ ""String_Node_Str""+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
 else {
        }
      }
    }
  }
  _mutationEnabled=true;
  _validateSchedule();
  _mutationEnabled=false;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is iterated repeatedly (prefire(), fire(), postfire()), until either it has no more input tokens, or its prefire() method returns false. <p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
public void fire() throws IllegalActionException {
  _mutationEnabled=false;
  while (true) {
    Actor actorToFire=_getNextActorToFire();
    if (actorToFire == null) {
      if (_isTopLevel()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _noMoreActorsToFire=true;
      }
 else {
        if (_debugging) {
          _debug(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      return;
    }
    if (actorToFire == getContainer()) {
      return;
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ _microstep);
    }
    boolean refire;
    do {
      refire=false;
      if (_debugging) {
        if (((Nameable)actorToFire).getContainer() == null) {
          _debug(""String_Node_Str"");
          _disableActor(actorToFire);
          break;
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
        if (!actorToFire.prefire()) {
          _debug(""String_Node_Str"");
          break;
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
        actorToFire.fire();
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
        if (!actorToFire.postfire()) {
          _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
          _disableActor(actorToFire);
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
      }
 else {
        if (((Nameable)actorToFire).getContainer() == null) {
          _disableActor(actorToFire);
          break;
        }
        if (!actorToFire.prefire()) {
          break;
        }
        actorToFire.fire();
        if (!actorToFire.postfire()) {
          _disableActor(actorToFire);
          break;
        }
      }
      Iterator inputPorts=actorToFire.inputPortList().iterator();
      while (inputPorts.hasNext() && !refire) {
        IOPort port=(IOPort)inputPorts.next();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.hasToken(i)) {
            refire=true;
            break;
          }
        }
      }
    }
 while (refire);
synchronized (_eventQueue) {
      if (!_eventQueue.isEmpty()) {
        DEEvent next=_eventQueue.get();
        if ((next.timeStamp().compareTo(getModelTime()) > 0)) {
          _microstep=0;
          break;
        }
 else         if (next.microstep() > _microstep) {
          break;
        }
 else         if ((next.timeStamp().compareTo(getModelTime()) < 0) || next.microstep() < _microstep) {
          throw new IllegalActionException(""String_Node_Str"" + next.timeStamp() + ""String_Node_Str""+ next.microstep()+ ""String_Node_Str""+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
 else {
        }
      }
    }
  }
  _mutationEnabled=true;
  _validateSchedule();
  _mutationEnabled=false;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
75153,"/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
private Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null, nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (!_isTopLevel()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
        if (nextEvent.timeStamp().compareTo(getModelTime()) < 0) {
          nextEvent=null;
          throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
        if ((nextEvent.timeStamp().compareTo(getModelTime()) > 0)) {
          nextEvent=null;
          break;
        }
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if (actorToFire != null || (getModelTime() == getModelStopTime())) {
          break;
        }
      }
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Thread.yield();
synchronized (_eventQueue) {
          if (_eventQueue.isEmpty()) {
            try {
              workspace().wait(_eventQueue);
            }
 catch (            InterruptedException e) {
              break;
            }
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (nextEvent == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (actorToFire == null) {
      Time currentTime;
      if (_synchronizeToRealTime) {
synchronized (_eventQueue) {
          while (true) {
            lastFoundEvent=(DEEvent)_eventQueue.get();
            currentTime=lastFoundEvent.timeStamp();
            long elapsedTime=System.currentTimeMillis() - _realStartTime;
            double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
            if (currentTime.getDoubleValue() <= elapsedTimeInSeconds) {
              break;
            }
            long timeToWait=(long)(currentTime.subtract(elapsedTimeInSeconds).getDoubleValue() * 1000.0);
            if (timeToWait > 0) {
              if (_debugging) {
                _debug(""String_Node_Str"" + timeToWait);
              }
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=(DEEvent)_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAndDepthAs(lastFoundEvent)) {
        _eventQueue.take();
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}","/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
private Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null, nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (!_isTopLevel()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
        if (nextEvent.timeStamp().compareTo(getModelTime()) < 0 || (nextEvent.timeStamp().equals(getModelTime()) && (nextEvent.microstep() < _microstep))) {
          throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
        if ((nextEvent.timeStamp().compareTo(getModelTime()) > 0)) {
          nextEvent=null;
          break;
        }
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if (actorToFire != null || (getModelTime() == getModelStopTime())) {
          break;
        }
      }
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Thread.yield();
synchronized (_eventQueue) {
          if (_eventQueue.isEmpty()) {
            try {
              workspace().wait(_eventQueue);
            }
 catch (            InterruptedException e) {
              break;
            }
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (nextEvent == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (actorToFire == null) {
      Time currentTime;
      if (_synchronizeToRealTime) {
synchronized (_eventQueue) {
          while (true) {
            lastFoundEvent=(DEEvent)_eventQueue.get();
            currentTime=lastFoundEvent.timeStamp();
            long elapsedTime=System.currentTimeMillis() - _realStartTime;
            double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
            if (currentTime.getDoubleValue() <= elapsedTimeInSeconds) {
              break;
            }
            long timeToWait=(long)(currentTime.subtract(elapsedTimeInSeconds).getDoubleValue() * 1000.0);
            if (timeToWait > 0) {
              if (_debugging) {
                _debug(""String_Node_Str"" + timeToWait);
              }
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=(DEEvent)_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAndDepthAs(lastFoundEvent)) {
        _eventQueue.take();
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}"
75154,"/** 
 * Return the buffer capacity of the given port. This method always return the receiver length, or 1 if the port does not have a receiver.
 * @param port The given port.
 * @return The buffer capacity of the given port.
 * @exception IllegalActionException Subclasses may throw it.
 */
public int getBufferCapacity(TypedIOPort port) throws IllegalActionException {
  int bufferCapacity=port.getReceivers()[0].length;
  if (bufferCapacity == 0) {
    bufferCapacity=1;
  }
  return bufferCapacity;
}","/** 
 * Return the buffer capacity of the given port. This method always return 1. Subclasses may override this method.
 * @param port The given port.
 * @return The buffer capacity of the given port.
 * @exception IllegalActionException Subclasses may throw it.
 */
public int getBufferCapacity(TypedIOPort port) throws IllegalActionException {
  return DFUtilities.getRate(port);
}"
75155,"/** 
 * Get the size of a parameter or port. The size of a parameter is the length of its array if the parameter's type is array, and 1 otherwise. The size of a port is its receiver length.
 * @param name The name of the port or parameter.
 * @return The size of a parameter or port.
 * @throws IllegalActionException If no port or parameter ofthe given name is found.
 */
public int getSize(String name) throws IllegalActionException {
  int size=1;
  Attribute attribute=_component.getAttribute(name);
  if (attribute != null) {
    if (attribute instanceof Variable) {
      Token token=((Variable)attribute).getToken();
      if (token instanceof ArrayToken) {
        return ((ArrayToken)token).length();
      }
      return 1;
    }
  }
  Actor actor=(Actor)_component;
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)inputPorts.next();
    if (port.getName().equals(name)) {
      return port.getReceivers()[0].length;
    }
  }
  Iterator outputPorts=actor.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort port=(IOPort)inputPorts.next();
    if (port.getName().equals(name)) {
      return port.getRemoteReceivers()[0].length;
    }
  }
  throw new IllegalActionException(_component,""String_Node_Str"" + name);
}","/** 
 * Get the size of a parameter. The size of a parameter is the length of its array if the parameter's type is array, and 1 otherwise.
 * @param name The name of the parameter.
 * @return The size of a parameter.
 * @throws IllegalActionException If no port or parameter ofthe given name is found.
 */
public int getSize(String name) throws IllegalActionException {
  int size=1;
  Attribute attribute=_component.getAttribute(name);
  if (attribute != null) {
    if (attribute instanceof Variable) {
      Token token=((Variable)attribute).getToken();
      if (token instanceof ArrayToken) {
        return ((ArrayToken)token).length();
      }
      return 1;
    }
  }
  throw new IllegalActionException(_component,""String_Node_Str"" + name);
}"
75156,"/** 
 * Return the reference to the specified parameter or port of the associated actor. For a parameter, the returned string is in the form ""fullName_parameterName"". For a port, the returned string is in the form ""fullName_portName[channelNumber][offset]"", if any channel number or offset is given.
 * @param name The name of the parameter or port
 * @return The reference to that parameter or port (a variable name,for example).
 * @exception IllegalActionException If the parameter or port does notexist or does not have a value.
 */
public String getReference(String name) throws IllegalActionException {
  StringBuffer result=new StringBuffer();
  Actor actor=(Actor)_component;
  StringTokenizer tokenizer=new StringTokenizer(name,""String_Node_Str"",true);
  if (tokenizer.countTokens() != 1 && tokenizer.countTokens() != 3 && tokenizer.countTokens() != 5) {
    throw new IllegalActionException(_component,""String_Node_Str"" + name);
  }
  String refName=tokenizer.nextToken().trim();
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)inputPorts.next();
    if (port.getName().equals(refName)) {
      result.append(port.getFullName().replace('.','_'));
      int[] channelAndOffset=_getChannelAndOffset(name);
      if (channelAndOffset[0] >= 0) {
        result.append(""String_Node_Str"" + channelAndOffset[0] + ""String_Node_Str"");
      }
      if (channelAndOffset[1] >= 0) {
        int offset=channelAndOffset[1] + _firingCount * port.getReceivers()[0].length;
        result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
      }
 else       if (_firingsPerIteration > 1) {
        result.append(""String_Node_Str"" + _firingCount + ""String_Node_Str"");
      }
      return result.toString();
    }
  }
  Iterator outputPorts=actor.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort port=(IOPort)outputPorts.next();
    if (port.getName().equals(refName)) {
      Receiver[][] remoteReceivers=(port.getRemoteReceivers());
      if (remoteReceivers.length == 0) {
        result.append(_component.getFullName().replace('.','_'));
        result.append(""String_Node_Str"");
        result.append(port.getName());
        return result.toString();
      }
      int[] channelAndOffset=_getChannelAndOffset(name);
      if (channelAndOffset[0] < 0) {
        result.append(getSinkChannels(port,0));
      }
 else {
        result.append(getSinkChannels(port,channelAndOffset[0]));
      }
      if (channelAndOffset[1] >= 0) {
        result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
      }
 else       if (_firingsPerIteration > 1) {
        result.append(""String_Node_Str"" + _firingCount + ""String_Node_Str"");
      }
      return result.toString();
    }
  }
  Attribute attribute=_component.getAttribute(refName);
  if (attribute != null) {
    if (attribute instanceof Parameter) {
      _referencedParameters.add(attribute);
    }
    result.append(attribute.getFullName().replace('.','_'));
    int[] channelAndOffset=_getChannelAndOffset(name);
    if (channelAndOffset[0] != -1) {
      throw new IllegalActionException(_component,""String_Node_Str"");
    }
    if (channelAndOffset[1] >= 0) {
      result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
    }
    return result.toString();
  }
  throw new IllegalActionException(_component,""String_Node_Str"" + name);
}","/** 
 * Return the reference to the specified parameter or port of the associated actor. For a parameter, the returned string is in the form ""fullName_parameterName"". For a port, the returned string is in the form ""fullName_portName[channelNumber][offset]"", if any channel number or offset is given.
 * @param name The name of the parameter or port
 * @return The reference to that parameter or port (a variable name,for example).
 * @exception IllegalActionException If the parameter or port does notexist or does not have a value.
 */
public String getReference(String name) throws IllegalActionException {
  StringBuffer result=new StringBuffer();
  Actor actor=(Actor)_component;
  StringTokenizer tokenizer=new StringTokenizer(name,""String_Node_Str"",true);
  if (tokenizer.countTokens() != 1 && tokenizer.countTokens() != 3 && tokenizer.countTokens() != 5) {
    throw new IllegalActionException(_component,""String_Node_Str"" + name);
  }
  String refName=tokenizer.nextToken().trim();
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)inputPorts.next();
    if (port.getName().equals(refName)) {
      result.append(port.getFullName().replace('.','_'));
      int[] channelAndOffset=_getChannelAndOffset(name);
      if (channelAndOffset[0] >= 0) {
        result.append(""String_Node_Str"" + channelAndOffset[0] + ""String_Node_Str"");
      }
      if (channelAndOffset[1] >= 0) {
        int offset=channelAndOffset[1] + _firingCount * DFUtilities.getRate(port);
        result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
      }
 else       if (_firingsPerIteration > 1) {
        result.append(""String_Node_Str"" + _firingCount + ""String_Node_Str"");
      }
      return result.toString();
    }
  }
  Iterator outputPorts=actor.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort port=(IOPort)outputPorts.next();
    if (port.getName().equals(refName)) {
      Receiver[][] remoteReceivers=(port.getRemoteReceivers());
      if (remoteReceivers.length == 0) {
        result.append(_component.getFullName().replace('.','_'));
        result.append(""String_Node_Str"");
        result.append(port.getName());
        return result.toString();
      }
      int[] channelAndOffset=_getChannelAndOffset(name);
      if (channelAndOffset[0] < 0) {
        result.append(getSinkChannels(port,0));
      }
 else {
        result.append(getSinkChannels(port,channelAndOffset[0]));
      }
      if (channelAndOffset[1] >= 0) {
        result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
      }
 else       if (_firingsPerIteration > 1) {
        result.append(""String_Node_Str"" + _firingCount + ""String_Node_Str"");
      }
      return result.toString();
    }
  }
  Attribute attribute=_component.getAttribute(refName);
  if (attribute != null) {
    if (attribute instanceof Parameter) {
      _referencedParameters.add(attribute);
    }
    result.append(attribute.getFullName().replace('.','_'));
    int[] channelAndOffset=_getChannelAndOffset(name);
    if (channelAndOffset[0] != -1) {
      throw new IllegalActionException(_component,""String_Node_Str"");
    }
    if (channelAndOffset[1] >= 0) {
      result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
    }
    return result.toString();
  }
  throw new IllegalActionException(_component,""String_Node_Str"" + name);
}"
75157,"/** 
 * Return the buffer capacity associated with the given port, This method overides the base class by computing the total number of tokens transferred in one iteration.
 * @param port The given port.
 * @return the buffer capacity associated with the given port.
 */
public int getBufferCapacity(TypedIOPort port) throws IllegalActionException {
  int bufferCapacity=1;
  Variable firings=(Variable)port.getContainer().getAttribute(""String_Node_Str"");
  int firingsPerIteration=((IntToken)firings.getToken()).intValue();
  if (port.isInput()) {
    bufferCapacity=firingsPerIteration * DFUtilities.getTokenConsumptionRate(port);
  }
  return bufferCapacity;
}","/** 
 * Return the buffer capacity associated with the given port, This method overides the base class by computing the total number of tokens transferred in one iteration.
 * @param port The given port.
 * @return the buffer capacity associated with the given port.
 */
public int getBufferCapacity(TypedIOPort port) throws IllegalActionException {
  int bufferCapacity=1;
  Variable firings=(Variable)port.getContainer().getAttribute(""String_Node_Str"");
  int firingsPerIteration=1;
  if (firings != null) {
    firingsPerIteration=((IntToken)firings.getToken()).intValue();
  }
  if (port.isInput()) {
    bufferCapacity=firingsPerIteration * DFUtilities.getTokenConsumptionRate(port);
  }
  return bufferCapacity;
}"
75158,"/** 
 * React to a change of the _director or other property. 
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == directorClass) {
    final String newDirectorClassName=directorClass.stringValue();
    final Director director=getDirector();
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
      protected void _execute() throws Exception {
        Class newDirectorClass=Class.forName(newDirectorClassName);
        Constructor newDirectorConstructor=newDirectorClass.getConstructor(new Class[]{CompositeEntity.class,String.class});
        FSMDirector newDirector=(FSMDirector)newDirectorConstructor.newInstance(new Object[]{ModalModel.this,uniqueName(""String_Node_Str"")});
        newDirector.setPersistent(false);
        newDirector.controllerName.setExpression(""String_Node_Str"");
        if (director != null && director.getContainer() == ModalModel.this) {
          director.setContainer(null);
        }
      }
    }
;
    requestChange(request);
  }
}","/** 
 * React to a change of the director or other property. 
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == directorClass) {
    Director director=getDirector();
    String className=directorClass.stringValue();
    if (director == null || !director.getClass().getName().equals(className)) {
      try {
        Class.forName(className);
      }
 catch (      ClassNotFoundException e) {
        throw new IllegalActionException(this,null,e,""String_Node_Str"");
      }
      ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
        protected void _execute() throws Exception {
          Director director=getDirector();
          Class newDirectorClass=Class.forName(directorClass.stringValue());
          Constructor newDirectorConstructor=newDirectorClass.getConstructor(new Class[]{CompositeEntity.class,String.class});
          FSMDirector newDirector=(FSMDirector)newDirectorConstructor.newInstance(new Object[]{ModalModel.this,uniqueName(""String_Node_Str"")});
          newDirector.setPersistent(false);
          newDirector.controllerName.setExpression(""String_Node_Str"");
          if (director != null && director.getContainer() == ModalModel.this) {
            director.setContainer(null);
          }
        }
      }
;
      requestChange(request);
    }
  }
}"
75159,"/** 
 * Override the base class to ensure that the _controller private variable is reset to the controller of the cloned object.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return The new Entity.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ModalModel newModel=(ModalModel)super.clone(workspace);
  newModel._controller=(FSMActor)newModel.getEntity(""String_Node_Str"");
  return newModel;
}","/** 
 * Override the base class to ensure that the _controller private variable is reset to the controller of the cloned object.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return The new Entity.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ModalModel newModel=(ModalModel)super.clone(workspace);
  newModel._controller=(FSMActor)newModel.getEntity(""String_Node_Str"");
  try {
    newModel.directorClass.validate();
    newModel.executeChangeRequests();
  }
 catch (  IllegalActionException e) {
    throw new CloneNotSupportedException(""String_Node_Str"" + getFullName());
  }
  return newModel;
}"
75160,"protected void _execute() throws Exception {
  Class newDirectorClass=Class.forName(newDirectorClassName);
  Constructor newDirectorConstructor=newDirectorClass.getConstructor(new Class[]{CompositeEntity.class,String.class});
  FSMDirector newDirector=(FSMDirector)newDirectorConstructor.newInstance(new Object[]{ModalModel.this,uniqueName(""String_Node_Str"")});
  newDirector.setPersistent(false);
  newDirector.controllerName.setExpression(""String_Node_Str"");
  if (director != null && director.getContainer() == ModalModel.this) {
    director.setContainer(null);
  }
}","protected void _execute() throws Exception {
  Director director=getDirector();
  Class newDirectorClass=Class.forName(directorClass.stringValue());
  Constructor newDirectorConstructor=newDirectorClass.getConstructor(new Class[]{CompositeEntity.class,String.class});
  FSMDirector newDirector=(FSMDirector)newDirectorConstructor.newInstance(new Object[]{ModalModel.this,uniqueName(""String_Node_Str"")});
  newDirector.setPersistent(false);
  newDirector.controllerName.setExpression(""String_Node_Str"");
  if (director != null && director.getContainer() == ModalModel.this) {
    director.setContainer(null);
  }
}"
75161,"private void _init() throws IllegalActionException, NameDuplicationException {
  new Attribute(this,""String_Node_Str"");
  setClassName(""String_Node_Str"");
  FSMDirector director=new FSMDirector(this,""String_Node_Str"");
  _controller=new ModalController(this,""String_Node_Str"");
  director.controllerName.setExpression(""String_Node_Str"");
  directorClass=new StringParameter(this,""String_Node_Str"");
  Director executiveDirector=getExecutiveDirector();
  if (executiveDirector != null) {
    String[] suggestions=executiveDirector.suggestedModalModelDirectors();
    for (int i=0; i < suggestions.length; i++) {
      directorClass.addChoice(suggestions[i]);
      if (i == 0) {
        directorClass.setExpression(suggestions[i]);
      }
    }
  }
 else {
    directorClass.setExpression(""String_Node_Str"");
  }
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private void _init() throws IllegalActionException, NameDuplicationException {
  new Attribute(this,""String_Node_Str"");
  setClassName(""String_Node_Str"");
  _controller=new ModalController(this,""String_Node_Str"");
  directorClass=new StringParameter(this,""String_Node_Str"");
  Director executiveDirector=getExecutiveDirector();
  if (executiveDirector != null) {
    String[] suggestions=executiveDirector.suggestedModalModelDirectors();
    for (int i=0; i < suggestions.length; i++) {
      directorClass.addChoice(suggestions[i]);
      if (i == 0) {
        directorClass.setExpression(suggestions[i]);
      }
    }
  }
 else {
    directorClass.setExpression(""String_Node_Str"");
  }
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
75162,"/** 
 * React to a change of the _director or other property. 
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == directorClass) {
    FSMDirector director=(FSMDirector)getDirector();
    Class newDirectorClass=null;
    String newDirectorClassName=directorClass.stringValue();
    try {
      if (director != null && director.getContainer() == this) {
        director.setContainer(null);
      }
      newDirectorClass=Class.forName(newDirectorClassName);
      Constructor newDirectorConstructor=newDirectorClass.getConstructor(new Class[]{CompositeEntity.class,String.class});
      director=(FSMDirector)newDirectorConstructor.newInstance(new Object[]{this,""String_Node_Str""});
    }
 catch (    NameDuplicationException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    ClassNotFoundException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    NoSuchMethodException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    InstantiationException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    IllegalAccessException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    InvocationTargetException ex) {
      throw new IllegalActionException(ex.toString());
    }
    director.controllerName.setExpression(""String_Node_Str"");
  }
}","/** 
 * React to a change of the _director or other property. 
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == directorClass) {
    Class newDirectorClass=null;
    String newDirectorClassName=directorClass.stringValue();
    try {
      Director director=getDirector();
      if (director != null && director.getContainer() == this) {
        director.setContainer(null);
      }
      newDirectorClass=Class.forName(newDirectorClassName);
      Constructor newDirectorConstructor=newDirectorClass.getConstructor(new Class[]{CompositeEntity.class,String.class});
      director=(FSMDirector)newDirectorConstructor.newInstance(new Object[]{this,""String_Node_Str""});
      ((FSMDirector)director).controllerName.setExpression(""String_Node_Str"");
    }
 catch (    NameDuplicationException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    ClassNotFoundException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    NoSuchMethodException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    InstantiationException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    IllegalAccessException ex) {
      throw new IllegalActionException(ex.toString());
    }
catch (    InvocationTargetException ex) {
      throw new IllegalActionException(ex.toString());
    }
  }
}"
75163,"/** 
 * Send tokens to the designated outputs.  Each token is determined by evaluating the expression portion of the action.
 * @exception IllegalActionException If expression evaluation fails,or the specified port is not found, or sending to one of the channels of the port throws a NoRoomException.
 */
public void execute() throws IllegalActionException {
  super.execute();
  if (_destinations != null) {
    Iterator destinations=_destinations.iterator();
    Iterator channels=_numbers.iterator();
    Iterator parseTrees=_parseTrees.iterator();
    while (destinations.hasNext()) {
      NamedObj nextDestination=(NamedObj)destinations.next();
      if (!(nextDestination instanceof IOPort)) {
        throw new IllegalActionException(this,""String_Node_Str"" + nextDestination.getFullName());
      }
      IOPort destination=(IOPort)nextDestination;
      boolean isInput=destination.isInput();
      Integer channel=(Integer)channels.next();
      ASTPtRootNode parseTree=(ASTPtRootNode)parseTrees.next();
      Token token;
      try {
        token=_parseTreeEvaluator.evaluateParseTree(parseTree,_scope);
      }
 catch (      IllegalActionException ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"");
      }
      try {
        if (token != null) {
          Receiver[][] localReceivers=destination.getReceivers();
          if (channel != null) {
            destination.send(channel.intValue(),token);
            if (_debugging) {
              _debug(getFullName() + ""String_Node_Str"" + destination.getName()+ ""String_Node_Str""+ channel.intValue()+ ""String_Node_Str""+ token);
            }
          }
 else {
            destination.broadcast(token);
            if (_debugging) {
              _debug(getFullName() + ""String_Node_Str"" + destination.getName()+ ""String_Node_Str""+ token);
            }
          }
        }
      }
 catch (      NoRoomException ex) {
        throw new IllegalActionException(this,""String_Node_Str"" + ex.getMessage());
      }
catch (      UnknownResultException ex) {
      }
    }
  }
}","/** 
 * Send tokens to the designated outputs.  Each token is determined by evaluating the expression portion of the action.
 * @exception IllegalActionException If expression evaluation fails,or the specified port is not found, or sending to one of the channels of the port throws a NoRoomException.
 */
public void execute() throws IllegalActionException {
  super.execute();
  if (_destinations != null) {
    Iterator destinations=_destinations.iterator();
    Iterator channels=_numbers.iterator();
    Iterator parseTrees=_parseTrees.iterator();
    while (destinations.hasNext()) {
      NamedObj nextDestination=(NamedObj)destinations.next();
      if (!(nextDestination instanceof IOPort)) {
        throw new IllegalActionException(this,""String_Node_Str"" + nextDestination.getFullName());
      }
      IOPort destination=(IOPort)nextDestination;
      boolean isInput=destination.isInput();
      Integer channel=(Integer)channels.next();
      ASTPtRootNode parseTree=(ASTPtRootNode)parseTrees.next();
      Token token;
      try {
        token=_parseTreeEvaluator.evaluateParseTree(parseTree,_scope);
      }
 catch (      IllegalActionException ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"");
      }
      try {
        if (token != null) {
          Receiver[][] localReceivers=destination.getReceivers();
          if (channel != null) {
            int chanelValue=channel.intValue();
            destination.send(chanelValue,token);
            if (isInput) {
              localReceivers[chanelValue][0].put(token);
            }
            if (_debugging) {
              _debug(getFullName() + ""String_Node_Str"" + destination.getName()+ ""String_Node_Str""+ chanelValue+ ""String_Node_Str""+ token);
            }
          }
 else {
            destination.broadcast(token);
            if (isInput) {
              for (int i=0; i < localReceivers.length; i++) {
                localReceivers[i][0].put(token);
              }
            }
            if (_debugging) {
              _debug(getFullName() + ""String_Node_Str"" + destination.getName()+ ""String_Node_Str""+ token);
            }
          }
        }
      }
 catch (      NoRoomException ex) {
        throw new IllegalActionException(this,""String_Node_Str"" + ex.getMessage());
      }
catch (      UnknownResultException ex) {
      }
    }
  }
}"
75164,"/** 
 * Preinitialize() methods of all actors deeply contained by the container of this director. The HDF/SDF preinitialize method will compute the initial schedule. Propagate the consumption and production rates of the current state out to the corresponding ports of the container of this director.
 * @exception IllegalActionException If the preinitialize()method of one of the associated actors throws it, or there is no controller.
 */
public void preinitialize() throws IllegalActionException {
  _sendRequest=true;
  _reinitialize=false;
  _getEnclosingDomainActor();
  FSMActor controller=getController();
  State initialState=controller.getInitialState();
  _setCurrentState(initialState);
  _nextIntransientState=transientStateTransition();
  super.preinitialize();
  _setCurrentState(_nextIntransientState);
  TypedActor[] currentRefinements=_nextIntransientState.getRefinement();
  TypedCompositeActor curRefinement=(TypedCompositeActor)(currentRefinements[0]);
  Director refinementDir=curRefinement.getDirector();
  if (!(refinementDir instanceof HDFFSMDirector) && !(refinementDir instanceof SDFDirector)) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  _updateInputTokenConsumptionRates(curRefinement);
  _updateOutputTokenProductionRates(curRefinement);
  ConstVariableModelAnalysis analysis=ConstVariableModelAnalysis.getAnalysis(this);
  CompositeActor model=(CompositeActor)getContainer();
  for (Iterator ports=model.portList().iterator(); ports.hasNext(); ) {
    IOPort port=(IOPort)ports.next();
    if (!(port instanceof ParameterPort)) {
      if (port.isInput()) {
        _declareReconfigurationDependencyForRefinementRateVariables(analysis,port,""String_Node_Str"");
      }
      if (port.isOutput()) {
        _declareReconfigurationDependencyForRefinementRateVariables(analysis,port,""String_Node_Str"");
        _declareReconfigurationDependencyForRefinementRateVariables(analysis,port,""String_Node_Str"");
      }
    }
  }
}","/** 
 * Preinitialize() methods of all actors deeply contained by the container of this director. The HDF/SDF preinitialize method will compute the initial schedule. Propagate the consumption and production rates of the current state out to the corresponding ports of the container of this director.
 * @exception IllegalActionException If the preinitialize()method of one of the associated actors throws it, or there is no controller.
 */
public void preinitialize() throws IllegalActionException {
  _sendRequest=true;
  _reinitialize=false;
  _getEnclosingDomainActor();
  FSMActor controller=getController();
  State initialState=controller.getInitialState();
  _setCurrentState(initialState);
  _nextIntransientState=transientStateTransition();
  super.preinitialize();
  _setCurrentState(_nextIntransientState);
  TypedActor[] currentRefinements=_nextIntransientState.getRefinement();
  if (currentRefinements.length != 1) {
    throw new IllegalActionException(this,""String_Node_Str"" + controller.currentState().getName());
  }
  TypedCompositeActor curRefinement=(TypedCompositeActor)(currentRefinements[0]);
  Director refinementDir=curRefinement.getDirector();
  _updateInputTokenConsumptionRates(curRefinement);
  _updateOutputTokenProductionRates(curRefinement);
  ConstVariableModelAnalysis analysis=ConstVariableModelAnalysis.getAnalysis(this);
  CompositeActor model=(CompositeActor)getContainer();
  for (Iterator ports=model.portList().iterator(); ports.hasNext(); ) {
    IOPort port=(IOPort)ports.next();
    if (!(port instanceof ParameterPort)) {
      if (port.isInput()) {
        _declareReconfigurationDependencyForRefinementRateVariables(analysis,port,""String_Node_Str"");
      }
      if (port.isOutput()) {
        _declareReconfigurationDependencyForRefinementRateVariables(analysis,port,""String_Node_Str"");
        _declareReconfigurationDependencyForRefinementRateVariables(analysis,port,""String_Node_Str"");
      }
    }
  }
}"
75165,"/** 
 * Set up new state and connection map if exactly one transition is enabled. Get the schedule of the current refinement and propagate its port rates to the outside.
 * @return True if the super class method returns true.
 * @exception IllegalActionException If a refinement throws it,if there is no controller, or if an inconsistency in port rates is detected between refinement actors.
 */
public boolean makeStateTransition() throws IllegalActionException {
  FSMActor controller=getController();
  State currentState=controller.currentState();
  Transition lastChosenTransition=_getLastChosenTransition();
  TypedCompositeActor actor;
  Director refinementDir;
  boolean superPostfire;
  if (lastChosenTransition == null) {
    TypedActor[] actors=currentState.getRefinement();
    actor=(TypedCompositeActor)(actors[0]);
    superPostfire=super.postfire();
  }
 else {
    State newState=lastChosenTransition.destinationState();
    _setCurrentState(newState);
    superPostfire=super.postfire();
    currentState=newState;
    TypedActor[] actors=currentState.getRefinement();
    actor=(TypedCompositeActor)(actors[0]);
    refinementDir=actor.getDirector();
    if (refinementDir instanceof HDFFSMDirector) {
      refinementDir.postfire();
    }
 else     if (refinementDir instanceof HDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(false);
      ((HDFDirector)refinementDir).getSchedule();
    }
 else     if (refinementDir instanceof SDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(true);
      ((SDFScheduler)refinmentSched).getSchedule();
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _updateInputTokenConsumptionRates(actor);
  _updateOutputTokenProductionRates(actor);
  CompositeActor hdfActor=_getEnclosingDomainActor();
  Director director=hdfActor.getExecutiveDirector();
  if (director instanceof HDFDirector) {
    ((HDFDirector)director).invalidateSchedule();
  }
  return superPostfire;
}","/** 
 * Set up new state and connection map if exactly one transition is enabled. Get the schedule of the current refinement and propagate its port rates to the outside.
 * @return True if the super class method returns true.
 * @exception IllegalActionException If a refinement throws it,if there is no controller, or if an inconsistency in port rates is detected between refinement actors.
 */
public boolean makeStateTransition() throws IllegalActionException {
  FSMActor controller=getController();
  State currentState=controller.currentState();
  Transition lastChosenTransition=_getLastChosenTransition();
  TypedCompositeActor actor;
  Director refinementDir;
  boolean superPostfire;
  if (lastChosenTransition == null) {
    TypedActor[] actors=currentState.getRefinement();
    if (actors.length != 1) {
      throw new IllegalActionException(this,""String_Node_Str"" + currentState.getName());
    }
    actor=(TypedCompositeActor)(actors[0]);
    superPostfire=super.postfire();
  }
 else {
    State newState=lastChosenTransition.destinationState();
    _setCurrentState(newState);
    superPostfire=super.postfire();
    currentState=newState;
    TypedActor[] actors=currentState.getRefinement();
    if (actors.length != 1) {
      throw new IllegalActionException(this,""String_Node_Str"" + currentState.getName());
    }
    actor=(TypedCompositeActor)(actors[0]);
    refinementDir=actor.getDirector();
    if (refinementDir instanceof HDFFSMDirector) {
      refinementDir.postfire();
    }
 else     if (refinementDir instanceof StaticSchedulingDirector) {
      refinementDir.invalidateSchedule();
      ((StaticSchedulingDirector)refinementDir).getScheduler().getSchedule();
    }
  }
  _updateInputTokenConsumptionRates(actor);
  _updateOutputTokenProductionRates(actor);
  CompositeActor hdfActor=_getEnclosingDomainActor();
  Director director=hdfActor.getExecutiveDirector();
  director.invalidateSchedule();
  return superPostfire;
}"
75166,"/** 
 * If this method is called immediately after preinitialize(), initialize the mode controller and all the refinements. If this is a reinitialization, it typically means this is a sub-layer HDFFSMDirector and a ""reset"" has been called at the upper-level HDFFSMDirector. This method will then reinitialize all the refinements in the sub-layer, recompute the schedule of the initial state in the sub-layer, and notify update of port rates to the upper level director.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  State currentState;
  FSMActor controller=getController();
  currentState=controller.currentState();
  State initialState=controller.getInitialState();
  if (!_reinitialize) {
    super.initialize();
    _reinitialize=true;
    if (initialState != _nextIntransientState) {
      _setCurrentState(_nextIntransientState);
      _setCurrentConnectionMap();
      _currentLocalReceiverMap=(Map)_localReceiverMaps.get(_nextIntransientState);
    }
  }
 else {
    super.initialize();
    _sendRequest=true;
    controller.setNewIteration(_sendRequest);
    currentState=transientStateTransition();
    TypedActor[] curRefinements=currentState.getRefinement();
    if (curRefinements.length > 1) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + currentState.getName());
    }
    TypedCompositeActor curRefinement=(TypedCompositeActor)(curRefinements[0]);
    Director refinementDir=curRefinement.getDirector();
    if (refinementDir instanceof HDFFSMDirector) {
      refinementDir.initialize();
    }
 else     if (refinementDir instanceof HDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(false);
      ((HDFDirector)refinementDir).getSchedule();
    }
 else     if (refinementDir instanceof SDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(true);
      ((SDFScheduler)refinmentSched).getSchedule();
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
    CompositeActor hdfActor=_getEnclosingDomainActor();
    Director director=hdfActor.getExecutiveDirector();
    ((StaticSchedulingDirector)director).invalidateSchedule();
  }
}","/** 
 * If this method is called immediately after preinitialize(), initialize the mode controller and all the refinements. If this is a reinitialization, it typically means this is a sub-layer HDFFSMDirector and a ""reset"" has been called at the upper-level HDFFSMDirector. This method will then reinitialize all the refinements in the sub-layer, recompute the schedule of the initial state in the sub-layer, and notify update of port rates to the upper level director.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  State currentState;
  FSMActor controller=getController();
  currentState=controller.currentState();
  State initialState=controller.getInitialState();
  if (!_reinitialize) {
    super.initialize();
    _reinitialize=true;
    if (initialState != _nextIntransientState) {
      _setCurrentState(_nextIntransientState);
      _setCurrentConnectionMap();
      _currentLocalReceiverMap=(Map)_localReceiverMaps.get(_nextIntransientState);
    }
  }
 else {
    super.initialize();
    _sendRequest=true;
    controller.setNewIteration(_sendRequest);
    currentState=transientStateTransition();
    TypedActor[] curRefinements=currentState.getRefinement();
    if (curRefinements.length > 1) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + currentState.getName());
    }
    TypedCompositeActor curRefinement=(TypedCompositeActor)(curRefinements[0]);
    Director refinementDir=curRefinement.getDirector();
    if (refinementDir instanceof HDFFSMDirector) {
      refinementDir.initialize();
    }
 else     if (refinementDir instanceof StaticSchedulingDirector) {
      refinementDir.invalidateSchedule();
      ((StaticSchedulingDirector)refinementDir).getScheduler().getSchedule();
    }
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
    CompositeActor hdfActor=_getEnclosingDomainActor();
    Director director=hdfActor.getExecutiveDirector();
    ((StaticSchedulingDirector)director).invalidateSchedule();
  }
}"
75167,"public void generateInitializeCode(StringBuffer stream) throws IllegalActionException {
  stream.append(processCode(_initBlock));
}","public String generateInitializeCode() throws IllegalActionException {
  return processCode(_initBlock);
}"
75168,"/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @param code The given string buffer.
 */
public void generateVariableDeclarations(StringBuffer code) throws IllegalActionException {
  code.append(comment(""String_Node_Str"" + getContainer().getFullName()));
  Iterator actors=((CompositeActor)getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    CodeGeneratorHelper helper=(CodeGeneratorHelper)_getHelper((NamedObj)actor);
    HashSet parameterSet=helper.getReferencedParameter();
    if (parameterSet != null) {
      Iterator parameters=parameterSet.iterator();
      while (parameters.hasNext()) {
        Parameter parameter=(Parameter)parameters.next();
        String type=parameter.getType().toString();
        boolean isArrayType=false;
        if (type.equals(""String_Node_Str"")) {
          type=""String_Node_Str"";
        }
 else         if (type.charAt(0) == '{') {
          StringTokenizer tokenizer=new StringTokenizer(""String_Node_Str"");
          type=tokenizer.nextToken();
        }
        code.append(""String_Node_Str"");
        code.append(type);
        code.append(""String_Node_Str"");
        code.append(parameter.getFullName().replace('.','_'));
        if (isArrayType) {
          code.append(""String_Node_Str"");
        }
        code.append(""String_Node_Str"");
        code.append(parameter.getToken().toString());
        code.append(""String_Node_Str"");
      }
    }
    Iterator inputPorts=actor.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      if (inputPort.getWidth() == 0) {
        break;
      }
      code.append(""String_Node_Str"");
      code.append(inputPort.getType().toString());
      code.append(""String_Node_Str"");
      code.append(inputPort.getFullName().replace('.','_'));
      if (inputPort.isMultiport()) {
        code.append(""String_Node_Str"" + inputPort.getWidth() + ""String_Node_Str"");
      }
      int bufferCapacity=getBufferCapacity(inputPort);
      if (bufferCapacity > 1) {
        code.append(""String_Node_Str"" + bufferCapacity + ""String_Node_Str"");
      }
      code.append(""String_Node_Str"");
    }
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
      if (outputPort.getWidth() == 0) {
        code.append(""String_Node_Str"");
        code.append(outputPort.getType().toString());
        code.append(""String_Node_Str"");
        code.append(outputPort.getFullName().replace('.','_'));
        code.append(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Generate variable declarations for inputs and outputs and parameters. Append the declarations to the given string buffer.
 * @param code The given string buffer.
 */
public void generateVariableDeclarations(StringBuffer code) throws IllegalActionException {
  code.append(comment(""String_Node_Str"" + getContainer().getFullName()));
  Iterator actors=((CompositeActor)getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    CodeGeneratorHelper helper=(CodeGeneratorHelper)_getHelper((NamedObj)actor);
    HashSet parameterSet=helper.getReferencedParameter();
    if (parameterSet != null) {
      Iterator parameters=parameterSet.iterator();
      while (parameters.hasNext()) {
        Parameter parameter=(Parameter)parameters.next();
        String type=parameter.getType().toString();
        boolean isArrayType=false;
        if (type.charAt(0) == '{') {
          StringTokenizer tokenizer=new StringTokenizer(type,""String_Node_Str"");
          type=tokenizer.nextToken();
          isArrayType=true;
        }
        if (type.equals(""String_Node_Str"")) {
          type=""String_Node_Str"";
        }
        code.append(""String_Node_Str"");
        code.append(type);
        code.append(""String_Node_Str"");
        code.append(parameter.getFullName().replace('.','_'));
        if (isArrayType) {
          code.append(""String_Node_Str"");
        }
        code.append(""String_Node_Str"");
        code.append(parameter.getToken().toString());
        code.append(""String_Node_Str"");
      }
    }
    Iterator inputPorts=actor.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      if (inputPort.getWidth() == 0) {
        break;
      }
      String type=inputPort.getType().toString();
      boolean isArrayType=false;
      if (type.charAt(0) == '{') {
        StringTokenizer tokenizer=new StringTokenizer(type,""String_Node_Str"");
        type=tokenizer.nextToken();
        isArrayType=true;
      }
      if (type.equals(""String_Node_Str"")) {
        type=""String_Node_Str"";
      }
      code.append(""String_Node_Str"");
      code.append(type);
      code.append(""String_Node_Str"");
      code.append(inputPort.getFullName().replace('.','_'));
      if (inputPort.isMultiport()) {
        code.append(""String_Node_Str"" + inputPort.getWidth() + ""String_Node_Str"");
      }
      int bufferCapacity=getBufferCapacity(inputPort);
      if (bufferCapacity > 1) {
        code.append(""String_Node_Str"" + bufferCapacity + ""String_Node_Str"");
      }
      code.append(""String_Node_Str"");
    }
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
      if (outputPort.getWidth() == 0) {
        String type=outputPort.getType().toString();
        boolean isArrayType=false;
        if (type.charAt(0) == '{') {
          StringTokenizer tokenizer=new StringTokenizer(type,""String_Node_Str"");
          type=tokenizer.nextToken();
          isArrayType=true;
        }
        if (type.equals(""String_Node_Str"")) {
          type=""String_Node_Str"";
        }
        code.append(""String_Node_Str"");
        code.append(type);
        code.append(""String_Node_Str"");
        code.append(outputPort.getFullName().replace('.','_'));
        code.append(""String_Node_Str"");
      }
    }
  }
}"
75169,"/** 
 * Return the reference to the specified parameter or port of the associated actor. For a parameter, the returned string is in the form ""fullName_parameterName"". For a port, the returned string is in the form ""fullName_portName[channelNumber][offset]"", if any channel number or offset is given.
 * @param name The name of the parameter or port
 * @return The reference to that parameter or port (a variable name,for example).
 * @exception IllegalActionException If the parameter or port does notexist or does not have a value.
 */
public String getReference(String name) throws IllegalActionException {
  StringBuffer result=new StringBuffer();
  Actor actor=(Actor)_component;
  StringTokenizer tokenizer=new StringTokenizer(name,""String_Node_Str"",true);
  if (tokenizer.countTokens() != 1 && tokenizer.countTokens() != 3 && tokenizer.countTokens() != 5) {
    throw new IllegalActionException(_component,""String_Node_Str"" + name);
  }
  String refName=tokenizer.nextToken().trim();
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)inputPorts.next();
    if (port.getName().equals(refName)) {
      result.append(port.getFullName().replace('.','_'));
      int[] channelAndOffset=_getChannelAndOffset(name);
      if (channelAndOffset[0] >= 0) {
        result.append(""String_Node_Str"" + channelAndOffset[0] + ""String_Node_Str"");
      }
      if (channelAndOffset[1] >= 0) {
        int offset=channelAndOffset[1] + _firingCount * port.getReceivers()[0].length;
        result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
      }
 else       if (_firingsPerIteration > 1) {
        result.append(""String_Node_Str"" + _firingCount + ""String_Node_Str"");
      }
      return result.toString();
    }
  }
  Iterator outputPorts=actor.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort port=(IOPort)outputPorts.next();
    if (port.getName().equals(refName)) {
      Receiver[][] remoteReceivers=(port.getRemoteReceivers());
      if (remoteReceivers.length == 0) {
        result.append(_component.getFullName().replace('.','_'));
        result.append(""String_Node_Str"");
        result.append(port.getName());
        return result.toString();
      }
      int[] channelAndOffset=_getChannelAndOffset(name);
      if (channelAndOffset[0] < 0) {
        result.append(getSinkChannels(port,0));
      }
 else {
        result.append(getSinkChannels(port,channelAndOffset[0]));
      }
      if (channelAndOffset[1] >= 0) {
        result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
      }
 else       if (_firingsPerIteration > 1) {
        result.append(""String_Node_Str"" + _firingCount + ""String_Node_Str"");
      }
      return result.toString();
    }
  }
  Attribute attribute=_component.getAttribute(refName);
  if (attribute != null) {
    if (attribute instanceof Parameter) {
      _referencedParameters.add(attribute);
    }
    result.append(_component.getFullName().replace('.','_'));
    result.append(""String_Node_Str"");
    result.append(refName);
    return result.toString();
  }
  throw new IllegalActionException(_component,""String_Node_Str"" + name);
}","/** 
 * Return the reference to the specified parameter or port of the associated actor. For a parameter, the returned string is in the form ""fullName_parameterName"". For a port, the returned string is in the form ""fullName_portName[channelNumber][offset]"", if any channel number or offset is given.
 * @param name The name of the parameter or port
 * @return The reference to that parameter or port (a variable name,for example).
 * @exception IllegalActionException If the parameter or port does notexist or does not have a value.
 */
public String getReference(String name) throws IllegalActionException {
  StringBuffer result=new StringBuffer();
  Actor actor=(Actor)_component;
  StringTokenizer tokenizer=new StringTokenizer(name,""String_Node_Str"",true);
  if (tokenizer.countTokens() != 1 && tokenizer.countTokens() != 3 && tokenizer.countTokens() != 5) {
    throw new IllegalActionException(_component,""String_Node_Str"" + name);
  }
  String refName=tokenizer.nextToken().trim();
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)inputPorts.next();
    if (port.getName().equals(refName)) {
      result.append(port.getFullName().replace('.','_'));
      int[] channelAndOffset=_getChannelAndOffset(name);
      if (channelAndOffset[0] >= 0) {
        result.append(""String_Node_Str"" + channelAndOffset[0] + ""String_Node_Str"");
      }
      if (channelAndOffset[1] >= 0) {
        int offset=channelAndOffset[1] + _firingCount * port.getReceivers()[0].length;
        result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
      }
 else       if (_firingsPerIteration > 1) {
        result.append(""String_Node_Str"" + _firingCount + ""String_Node_Str"");
      }
      return result.toString();
    }
  }
  Iterator outputPorts=actor.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort port=(IOPort)outputPorts.next();
    if (port.getName().equals(refName)) {
      Receiver[][] remoteReceivers=(port.getRemoteReceivers());
      if (remoteReceivers.length == 0) {
        result.append(_component.getFullName().replace('.','_'));
        result.append(""String_Node_Str"");
        result.append(port.getName());
        return result.toString();
      }
      int[] channelAndOffset=_getChannelAndOffset(name);
      if (channelAndOffset[0] < 0) {
        result.append(getSinkChannels(port,0));
      }
 else {
        result.append(getSinkChannels(port,channelAndOffset[0]));
      }
      if (channelAndOffset[1] >= 0) {
        result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
      }
 else       if (_firingsPerIteration > 1) {
        result.append(""String_Node_Str"" + _firingCount + ""String_Node_Str"");
      }
      return result.toString();
    }
  }
  Attribute attribute=_component.getAttribute(refName);
  if (attribute != null) {
    if (attribute instanceof Parameter) {
      _referencedParameters.add(attribute);
    }
    result.append(_component.getFullName().replace('.','_'));
    result.append(""String_Node_Str"");
    result.append(refName);
    int[] channelAndOffset=_getChannelAndOffset(name);
    if (channelAndOffset[0] != -1) {
      throw new IllegalActionException(_component,""String_Node_Str"");
    }
    if (channelAndOffset[1] >= 0) {
      result.append(""String_Node_Str"" + channelAndOffset[1] + ""String_Node_Str"");
    }
    return result.toString();
  }
  throw new IllegalActionException(_component,""String_Node_Str"" + name);
}"
75170,"/** 
 * Override the base class to open the model specified if the attribute is modelFileOrURL, or for other parameters, to cache their values.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == modelFileOrURL) {
    if (_debugging) {
      _debug(""String_Node_Str"" + modelFileOrURL.getExpression());
    }
    URL url=modelFileOrURL.asURL();
    if (url != null) {
      File asFile=modelFileOrURL.asFile();
      if (!asFile.isFile()) {
        throw new IllegalActionException(this,""String_Node_Str"" + url);
      }
      MoMLParser parser=new MoMLParser();
      try {
        _model=parser.parse(null,url);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"" + url);
      }
      if (_model instanceof CompositeActor) {
        _manager=new Manager(_model.workspace(),""String_Node_Str"");
        ((CompositeActor)_model).setManager(_manager);
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
 else {
      _model=null;
      _manager=null;
      _throwable=null;
    }
  }
 else   if (attribute == executionOnFiring) {
    String executionOnFiringValue=executionOnFiring.stringValue();
    if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_RUN_IN_CALLING_THREAD;
    }
 else     if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_RUN_IN_A_NEW_THREAD;
    }
 else     if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_DO_NOTHING;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + executionOnFiringValue);
    }
  }
 else   if (attribute == postfireAction) {
    String postfireActionValue=postfireAction.stringValue();
    if (postfireActionValue.equals(""String_Node_Str"")) {
      _postfireActionValue=_DO_NOTHING;
    }
 else     if (postfireActionValue.equals(""String_Node_Str"")) {
      _postfireActionValue=_STOP_EXECUTING;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + postfireActionValue);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Override the base class to open the model specified if the attribute is modelFileOrURL, or for other parameters, to cache their values.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == modelFileOrURL) {
    if (_debugging) {
      _debug(""String_Node_Str"" + modelFileOrURL.getExpression());
    }
    URL url=modelFileOrURL.asURL();
    if (url != null) {
      if (url.getProtocol().equals(""String_Node_Str"")) {
        File asFile=modelFileOrURL.asFile();
        if (!asFile.isFile()) {
          throw new IllegalActionException(this,""String_Node_Str"" + url);
        }
      }
      MoMLParser parser=new MoMLParser();
      try {
        _model=parser.parse(null,url);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"" + url);
      }
      if (_model instanceof CompositeActor) {
        _manager=new Manager(_model.workspace(),""String_Node_Str"");
        ((CompositeActor)_model).setManager(_manager);
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
 else {
      _model=null;
      _manager=null;
      _throwable=null;
    }
  }
 else   if (attribute == executionOnFiring) {
    String executionOnFiringValue=executionOnFiring.stringValue();
    if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_RUN_IN_CALLING_THREAD;
    }
 else     if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_RUN_IN_A_NEW_THREAD;
    }
 else     if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_DO_NOTHING;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + executionOnFiringValue);
    }
  }
 else   if (attribute == postfireAction) {
    String postfireActionValue=postfireAction.stringValue();
    if (postfireActionValue.equals(""String_Node_Str"")) {
      _postfireActionValue=_DO_NOTHING;
    }
 else     if (postfireActionValue.equals(""String_Node_Str"")) {
      _postfireActionValue=_STOP_EXECUTING;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + postfireActionValue);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75171,"/** 
 * Read the URL and produce output.
 * @param sourceURL The source URL.
 */
private void _readURL(URL sourceURL) throws IOException, IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + sourceURL);
  }
  URLConnection urlConnection=sourceURL.openConnection();
  String contentType=urlConnection.getContentType();
  if (!contentType.startsWith(""String_Node_Str"") && !contentType.startsWith(""String_Node_Str"")) {
    throw new IllegalActionException(this,""String_Node_Str"" + directoryOrURL + ""String_Node_Str""+ ""String_Node_Str""+ urlConnection.getContentType());
  }
  BufferedReader in=new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
  if (!contentType.startsWith(""String_Node_Str"") && !urlConnection.getURL().toString().endsWith(""String_Node_Str"")) {
    throw new IllegalActionException(this,""String_Node_Str"" + directoryOrURL + ""String_Node_Str"");
  }
  List resultsList=new LinkedList();
  String line;
  String target=null;
  boolean sawBody=false, sawHREF=false;
  while ((line=in.readLine()) != null) {
    line=line.trim();
    if (_debugging) {
      _debug(line);
    }
    if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
      sawBody=true;
    }
 else {
      if (sawBody) {
        StringTokenizer tokenizer=new StringTokenizer(line,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String token=tokenizer.nextToken();
          if (token.compareToIgnoreCase(""String_Node_Str"") == 0) {
            sawHREF=true;
            target=null;
          }
 else {
            if (sawHREF) {
              if (target == null) {
                target=token;
              }
 else {
                String reference=target;
                if (reference.length() > 20) {
                  reference=target.substring(0,20);
                }
                if (!token.startsWith(reference)) {
                  sawHREF=false;
                }
 else {
                  if (accept(null,target)) {
                    String base=directoryOrURL.getExpression();
                    if (!base.endsWith(""String_Node_Str"")) {
                      base=base + ""String_Node_Str"";
                    }
                    resultsList.add(new StringToken(base + target));
                  }
                  sawHREF=false;
                }
              }
            }
          }
        }
      }
    }
  }
  in.close();
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(""String_Node_Str"");
    Iterator results=resultsList.iterator();
    while (results.hasNext()) {
      _debug(((StringToken)results.next()).stringValue());
    }
  }
  StringToken[] results=new StringToken[resultsList.size()];
  output.broadcast(new ArrayToken((StringToken[])(resultsList.toArray(results))));
}","/** 
 * Read the URL and produce output.
 * @param sourceURL The source URL.
 */
private void _readURL(URL sourceURL) throws IOException, IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + sourceURL);
  }
  URLConnection urlConnection=sourceURL.openConnection();
  String contentType=urlConnection.getContentType();
  if (!contentType.startsWith(""String_Node_Str"") && !contentType.startsWith(""String_Node_Str"")) {
    throw new IllegalActionException(this,""String_Node_Str"" + directoryOrURL + ""String_Node_Str""+ ""String_Node_Str""+ urlConnection.getContentType());
  }
  BufferedReader in=new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
  if (!contentType.startsWith(""String_Node_Str"") && !urlConnection.getURL().toString().endsWith(""String_Node_Str"")) {
    throw new IllegalActionException(this,""String_Node_Str"" + directoryOrURL + ""String_Node_Str"");
  }
  List resultsList=new LinkedList();
  String line;
  String target=null;
  boolean sawBody=false, sawHREF=false;
  while ((line=in.readLine()) != null) {
    line=line.trim();
    if (_debugging) {
      _debug(line);
    }
    if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
      sawBody=true;
    }
 else {
      if (sawBody) {
        StringTokenizer tokenizer=new StringTokenizer(line,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String token=tokenizer.nextToken();
          if (token.compareToIgnoreCase(""String_Node_Str"") == 0) {
            sawHREF=true;
            target=null;
          }
 else {
            if (sawHREF) {
              if (target == null) {
                target=token;
              }
 else {
                String reference=target;
                if (reference.length() > 20) {
                  reference=target.substring(0,20);
                }
                if (!token.startsWith(reference)) {
                  sawHREF=false;
                }
 else {
                  if (accept(null,target)) {
                    String base=directoryOrURL.stringValue();
                    if (!base.endsWith(""String_Node_Str"")) {
                      base=base + ""String_Node_Str"";
                    }
                    resultsList.add(new StringToken(base + target));
                  }
                  sawHREF=false;
                }
              }
            }
          }
        }
      }
    }
  }
  in.close();
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(""String_Node_Str"");
    Iterator results=resultsList.iterator();
    while (results.hasNext()) {
      _debug(((StringToken)results.next()).stringValue());
    }
  }
  StringToken[] results=new StringToken[resultsList.size()];
  output.broadcast(new ArrayToken((StringToken[])(resultsList.toArray(results))));
}"
75172,"private void _placePortFigures(CompositeFigure figure,List portList,int direction){
  Iterator ports=portList.iterator();
  int number=0;
  int count=portList.size();
  while (ports.hasNext()) {
    Port port=(Port)ports.next();
    Figure portFigure=getController().getFigure(port);
    if (portFigure == null)     continue;
    Rectangle2D portBounds=portFigure.getShape().getBounds2D();
    PortSite site=new PortSite(figure.getBackgroundFigure(),port,number,count);
    number++;
    double x=site.getX() - portBounds.getCenterX();
    double y=site.getY() - portBounds.getCenterY();
    portFigure.translate(x,y);
    Attribute showRateAttribute=port.getAttribute(""String_Node_Str"");
    if (port instanceof IOPort && showRateAttribute instanceof Variable && ((Variable)showRateAttribute).getToken().equals(BooleanToken.TRUE)) {
      String rateString=""String_Node_Str"";
      Variable rateParameter=null;
      if (((IOPort)port).isInput()) {
        rateParameter=(Variable)port.getAttribute(""String_Node_Str"");
        if (rateParameter == null) {
          String altName=""String_Node_Str"";
          rateParameter=(Variable)port.getAttribute(altName);
        }
      }
 else       if (((IOPort)port).isOutput()) {
        rateParameter=(Variable)port.getAttribute(""String_Node_Str"");
        if (rateParameter == null) {
          String altName=""String_Node_Str"";
          rateParameter=(Variable)port.getAttribute(altName);
        }
      }
      if (rateParameter != null) {
        try {
          rateString=rateParameter.getToken().toString();
        }
 catch (        KernelException ex) {
        }
      }
      LabelFigure labelFigure=_createPortLabelFigure(rateString,_portLabelFont,x,y,direction);
      labelFigure.setFillPaint(Color.BLUE);
      figure.add(labelFigure);
    }
    Attribute showAttribute=port.getAttribute(""String_Node_Str"");
    if (showAttribute != null) {
      boolean show=true;
      if (showAttribute instanceof Parameter) {
        try {
          Token token=((Parameter)showAttribute).getToken();
          if (token instanceof BooleanToken) {
            show=((BooleanToken)token).booleanValue();
          }
        }
 catch (        IllegalActionException e) {
        }
      }
      if (show) {
        LabelFigure labelFigure=_createPortLabelFigure(port.getName(),_portLabelFont,x,y,direction);
        figure.add(labelFigure);
      }
    }
  }
}","private void _placePortFigures(CompositeFigure figure,List portList,int direction){
  Iterator ports=portList.iterator();
  int number=0;
  int count=portList.size();
  while (ports.hasNext()) {
    Port port=(Port)ports.next();
    Figure portFigure=getController().getFigure(port);
    if (portFigure == null)     continue;
    Rectangle2D portBounds=portFigure.getShape().getBounds2D();
    PortSite site=new PortSite(figure.getBackgroundFigure(),port,number,count);
    number++;
    double x=site.getX() - portBounds.getCenterX();
    double y=site.getY() - portBounds.getCenterY();
    portFigure.translate(x,y);
    Attribute showRateAttribute=port.getAttribute(""String_Node_Str"");
    if (port instanceof IOPort && showRateAttribute instanceof Variable) {
      boolean showRate=false;
      try {
        showRate=((Variable)showRateAttribute).getToken().equals(BooleanToken.TRUE);
      }
 catch (      Exception ex) {
      }
      if (showRate) {
        String rateString=""String_Node_Str"";
        Variable rateParameter=null;
        if (((IOPort)port).isInput()) {
          rateParameter=(Variable)port.getAttribute(""String_Node_Str"");
          if (rateParameter == null) {
            String altName=""String_Node_Str"";
            rateParameter=(Variable)port.getAttribute(altName);
          }
        }
 else         if (((IOPort)port).isOutput()) {
          rateParameter=(Variable)port.getAttribute(""String_Node_Str"");
          if (rateParameter == null) {
            String altName=""String_Node_Str"";
            rateParameter=(Variable)port.getAttribute(altName);
          }
        }
        if (rateParameter != null) {
          try {
            rateString=rateParameter.getToken().toString();
          }
 catch (          KernelException ex) {
          }
        }
        LabelFigure labelFigure=_createPortLabelFigure(rateString,_portLabelFont,x,y,direction);
        labelFigure.setFillPaint(Color.BLUE);
        figure.add(labelFigure);
      }
    }
    Attribute showAttribute=port.getAttribute(""String_Node_Str"");
    if (showAttribute != null) {
      boolean show=true;
      if (showAttribute instanceof Parameter) {
        try {
          Token token=((Parameter)showAttribute).getToken();
          if (token instanceof BooleanToken) {
            show=((BooleanToken)token).booleanValue();
          }
        }
 catch (        IllegalActionException e) {
        }
      }
      if (show) {
        LabelFigure labelFigure=_createPortLabelFigure(port.getName(),_portLabelFont,x,y,direction);
        figure.add(labelFigure);
      }
    }
  }
}"
75173,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Exec(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  command=new PortParameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  command.setStringMode(true);
  directory=new FileParameter(this,""String_Node_Str"");
  directory.setExpression(""String_Node_Str"");
  directory.setVisibility(Settable.EXPERT);
  environment=new Parameter(this,""String_Node_Str"");
  String[] labels=new String[]{""String_Node_Str"",""String_Node_Str""};
  Type[] values=new Type[]{BaseType.STRING,BaseType.STRING};
  environment.setTypeEquals(new ArrayType(new RecordType(labels,values)));
  environment.setExpression(""String_Node_Str"");
  environment.setVisibility(Settable.EXPERT);
  error=new TypedIOPort(this,""String_Node_Str"",false,true);
  error.setTypeEquals(BaseType.STRING);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setTypeEquals(BaseType.STRING);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.STRING);
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Exec(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  command=new PortParameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  command.setStringMode(true);
  new Parameter(command.getPort(),""String_Node_Str"",BooleanToken.TRUE);
  directory=new FileParameter(this,""String_Node_Str"");
  directory.setExpression(""String_Node_Str"");
  environment=new Parameter(this,""String_Node_Str"");
  String[] labels=new String[]{""String_Node_Str"",""String_Node_Str""};
  Type[] values=new Type[]{BaseType.STRING,BaseType.STRING};
  environment.setTypeEquals(new ArrayType(new RecordType(labels,values)));
  environment.setExpression(""String_Node_Str"");
  error=new TypedIOPort(this,""String_Node_Str"",false,true);
  error.setTypeEquals(BaseType.STRING);
  new Parameter(error,""String_Node_Str"",BooleanToken.TRUE);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setTypeEquals(BaseType.STRING);
  new Parameter(input,""String_Node_Str"",BooleanToken.TRUE);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.STRING);
  new Parameter(output,""String_Node_Str"",BooleanToken.TRUE);
}"
75174,"/** 
 * Override the base class and terminate the process.
 */
public synchronized void stop(){
  super.stop();
  try {
    _terminateProcess();
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex);
  }
}","/** 
 * Override the base class and terminate the process.
 */
public void stop(){
  super.stop();
  try {
    _terminateProcess();
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex);
  }
}"
75175,"private void _read(){
  char[] chars=new char[80];
  int length;
  try {
    while ((length=_inputStreamReader.read(chars,0,80)) != -1 && !_stopRequested && !_stopFireRequested) {
      if (_debugging) {
        _debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ _inputStreamReader.ready()+ ""String_Node_Str""+ String.valueOf(chars,0,length)+ ""String_Node_Str"");
      }
      _stringBuffer.append(chars,0,length);
    }
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(_actor,throwable,getName() + ""String_Node_Str"" + _inputStream);
  }
}","private synchronized void _read(){
  char[] chars=new char[80];
  int length;
  try {
    while ((length=_inputStreamReader.read(chars,0,80)) != -1 && !_stopRequested && !_stopFireRequested) {
      if (_debugging) {
        _debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ _inputStreamReader.ready()+ ""String_Node_Str""+ String.valueOf(chars,0,length)+ ""String_Node_Str"");
      }
      _stringBuffer.append(chars,0,length);
    }
  }
 catch (  Throwable throwable) {
    throw new InternalErrorException(_actor,throwable,getName() + ""String_Node_Str"" + _inputStream);
  }
}"
75176,"/** 
 * Override the base class to stop waiting for input data.
 */
public synchronized void stopFire(){
  super.stopFire();
  _stopFireRequested=true;
  try {
    _terminateProcess();
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex);
  }
}","/** 
 * Override the base class to stop waiting for input data.
 */
public void stopFire(){
  super.stopFire();
  _stopFireRequested=true;
  try {
    _terminateProcess();
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex);
  }
}"
75177,"/** 
 * Invoke a subprocess, read the <i>input</i> data (if any) and wait for the subprocess to terminate before sending any output or error data to the appropriate ports. <p>If there is no data on the <i>input</i> port, then the subprocess executes without reading any input. If there is no output or error data from the subprocess, then the empty string is sent to the appropriate port(s).
 * @exception IllegalActionException If the subprocess cannot bestarted, if the input of the subprocess cannot be written, if the subprocess gets interrupted, or if the return value of the process is non-zero.
 */
public synchronized void fire() throws IllegalActionException {
  super.fire();
  String line=null;
  _exec();
  if (input.numberOfSources() > 0 && input.hasToken(0)) {
    if ((line=((StringToken)input.get(0)).stringValue()) != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + line + ""String_Node_Str"");
      }
      if (_inputBufferedWriter != null) {
        try {
          _inputBufferedWriter.write(line);
          _inputBufferedWriter.flush();
        }
 catch (        IOException ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + command + ""String_Node_Str"");
        }
      }
    }
  }
  try {
    int processReturnCode=_process.waitFor();
    if (processReturnCode != 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ((StringToken)command.getToken()).stringValue() + ""String_Node_Str""+ processReturnCode);
    }
  }
 catch (  InterruptedException interrupted) {
    throw new InternalErrorException(this,interrupted,""String_Node_Str"");
  }
  String outputString=_outputGobbler.getAndReset();
  String errorString=_errorGobbler.getAndReset();
  if (_debugging) {
    _debug(""String_Node_Str"" + errorString + ""String_Node_Str"");
    _debug(""String_Node_Str"" + outputString + ""String_Node_Str"");
  }
  error.send(0,new StringToken(errorString));
  output.send(0,new StringToken(outputString));
}","/** 
 * Invoke a subprocess, read the <i>input</i> data (if any) and wait for the subprocess to terminate before sending any output or error data to the appropriate ports. <p>If there is no data on the <i>input</i> port, then the subprocess executes without reading any input. If there is no output or error data from the subprocess, then the empty string is sent to the appropriate port(s).
 * @exception IllegalActionException If the subprocess cannot bestarted, if the input of the subprocess cannot be written, if the subprocess gets interrupted, or if the return value of the process is non-zero.
 */
public void fire() throws IllegalActionException {
  super.fire();
  String line=null;
  _exec();
  if (input.numberOfSources() > 0 && input.hasToken(0)) {
    if ((line=((StringToken)input.get(0)).stringValue()) != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + line + ""String_Node_Str"");
      }
      if (_inputBufferedWriter != null) {
        try {
          _inputBufferedWriter.write(line);
          _inputBufferedWriter.flush();
        }
 catch (        IOException ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + command + ""String_Node_Str"");
        }
      }
    }
  }
  try {
    int processReturnCode=_process.waitFor();
    if (processReturnCode != 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ((StringToken)command.getToken()).stringValue() + ""String_Node_Str""+ processReturnCode);
    }
  }
 catch (  InterruptedException interrupted) {
    throw new InternalErrorException(this,interrupted,""String_Node_Str"");
  }
  String outputString=_outputGobbler.getAndReset();
  String errorString=_errorGobbler.getAndReset();
  if (_debugging) {
    _debug(""String_Node_Str"" + errorString + ""String_Node_Str"");
    _debug(""String_Node_Str"" + outputString + ""String_Node_Str"");
  }
  error.send(0,new StringToken(errorString));
  output.send(0,new StringToken(outputString));
}"
75178,"private void _exec() throws IllegalActionException {
  try {
    _stopFireRequested=false;
    if (_process != null) {
      _terminateProcess();
    }
    Runtime runtime=Runtime.getRuntime();
    command.update();
    String[] commandArray=StringUtilities.tokenizeForExec(((StringToken)command.getToken()).stringValue());
    File directoryAsFile=directory.asFile();
    if (_debugging) {
      _debug(""String_Node_Str"" + ((StringToken)command.getToken()).stringValue() + ""String_Node_Str""+ ""String_Node_Str""+ directoryAsFile+ ""String_Node_Str"");
    }
    ArrayToken environmentTokens=(ArrayToken)environment.getToken();
    if (_debugging) {
      _debug(""String_Node_Str"" + environmentTokens);
    }
    String[] environmentArray=null;
    if (environmentTokens.length() >= 1) {
      environmentArray=new String[environmentTokens.length()];
      for (int i=0; i < environmentTokens.length(); i++) {
        StringToken nameToken=(StringToken)(((RecordToken)environmentTokens.getElement(i)).get(""String_Node_Str""));
        StringToken valueToken=(StringToken)(((RecordToken)environmentTokens.getElement(i)).get(""String_Node_Str""));
        environmentArray[i]=nameToken.stringValue() + ""String_Node_Str"" + valueToken.stringValue();
        if (_debugging) {
          _debug(""String_Node_Str"" + i + ""String_Node_Str""+ environmentArray[i]+ ""String_Node_Str"");
        }
        if (i == 0 && environmentTokens.length() == 1 && environmentArray[0].equals(""String_Node_Str"")) {
          if (_debugging) {
            _debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          environmentArray=null;
        }
      }
    }
    _process=runtime.exec(commandArray,environmentArray,directoryAsFile);
    _outputGobbler=new _StreamReaderThread(_process.getInputStream(),""String_Node_Str"" + _streamReaderThreadCount++,this);
    _errorGobbler=new _StreamReaderThread(_process.getErrorStream(),""String_Node_Str"" + _streamReaderThreadCount++,this);
    _errorGobbler.start();
    _outputGobbler.start();
    if (_streamReaderThreadCount > 1000) {
      _streamReaderThreadCount=0;
    }
    OutputStreamWriter inputStreamWriter=new OutputStreamWriter(_process.getOutputStream());
    _inputBufferedWriter=new BufferedWriter(inputStreamWriter);
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + command + ""String_Node_Str"");
  }
}","private void _exec() throws IllegalActionException {
  try {
    _stopFireRequested=false;
    if (_process != null) {
      _terminateProcess();
    }
    Runtime runtime=Runtime.getRuntime();
    command.update();
    String[] commandArray=StringUtilities.tokenizeForExec(((StringToken)command.getToken()).stringValue());
    File directoryAsFile=directory.asFile();
    if (_debugging) {
      _debug(""String_Node_Str"" + ((StringToken)command.getToken()).stringValue() + ""String_Node_Str""+ ""String_Node_Str""+ directoryAsFile+ ""String_Node_Str"");
    }
    ArrayToken environmentTokens=(ArrayToken)environment.getToken();
    if (_debugging) {
      _debug(""String_Node_Str"" + environmentTokens);
    }
    String[] environmentArray=null;
    if (environmentTokens.length() >= 1) {
      environmentArray=new String[environmentTokens.length()];
      for (int i=0; i < environmentTokens.length(); i++) {
        StringToken nameToken=(StringToken)(((RecordToken)environmentTokens.getElement(i)).get(""String_Node_Str""));
        StringToken valueToken=(StringToken)(((RecordToken)environmentTokens.getElement(i)).get(""String_Node_Str""));
        environmentArray[i]=nameToken.stringValue() + ""String_Node_Str"" + valueToken.stringValue();
        if (_debugging) {
          _debug(""String_Node_Str"" + i + ""String_Node_Str""+ environmentArray[i]+ ""String_Node_Str"");
        }
        if (i == 0 && environmentTokens.length() == 1 && environmentArray[0].equals(""String_Node_Str"")) {
          if (_debugging) {
            _debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
          environmentArray=null;
        }
      }
    }
    _process=runtime.exec(commandArray,environmentArray,directoryAsFile);
    _outputGobbler=new _StreamReaderThread(_process.getInputStream(),""String_Node_Str"" + _streamReaderThreadCount++,this);
    _errorGobbler=new _StreamReaderThread(_process.getErrorStream(),""String_Node_Str"" + _streamReaderThreadCount++,this);
    _errorGobbler.start();
    _outputGobbler.start();
    if (_streamReaderThreadCount > 1000) {
      _streamReaderThreadCount=0;
    }
    OutputStreamWriter inputStreamWriter=new OutputStreamWriter(_process.getOutputStream());
    _inputBufferedWriter=new BufferedWriter(inputStreamWriter);
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + command.getExpression() + ""String_Node_Str"");
  }
}"
75179,"/** 
 * Read lines from the inputStream and append them to the stringBuffer.
 */
public void run(){
  _read();
}","/** 
 * Read lines from the inputStream and append them to the stringBuffer.
 */
public synchronized void run(){
  if (!_inputStreamReaderClosed) {
    _read();
  }
}"
75180,"/** 
 * Read any remaining data in the input stream and return the data read thus far.  Calling this method resets the cache of data read thus far.
 */
public String getAndReset(){
  if (_debugging) {
    try {
      _debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ _inputStreamReader.ready()+ ""String_Node_Str""+ _inputStream.available());
    }
 catch (    Exception ex) {
      throw new InternalErrorException(ex);
    }
  }
  try {
    _read();
  }
 catch (  Throwable throwable) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + throwable.getMessage());
    }
  }
  String results=_stringBuffer.toString();
  _stringBuffer=new StringBuffer();
  try {
    _inputStreamReader.close();
  }
 catch (  Exception ex) {
    throw new InternalErrorException(null,ex,getName() + ""String_Node_Str"");
  }
  return results;
}","/** 
 * Read any remaining data in the input stream and return the data read thus far.  Calling this method resets the cache of data read thus far.
 */
public String getAndReset(){
  if (_debugging) {
    try {
      _debug(""String_Node_Str"" + getName() + ""String_Node_Str""+ _inputStreamReader.ready()+ ""String_Node_Str""+ _inputStream.available());
    }
 catch (    Exception ex) {
      throw new InternalErrorException(ex);
    }
  }
  try {
    _read();
  }
 catch (  Throwable throwable) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + throwable.getMessage());
    }
  }
  String results=_stringBuffer.toString();
  _stringBuffer=new StringBuffer();
  try {
    _inputStreamReader.close();
    _inputStreamReaderClosed=true;
  }
 catch (  Exception ex) {
    throw new InternalErrorException(null,ex,getName() + ""String_Node_Str"");
  }
  return results;
}"
75181,"private void _computeActorDepth() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  LinkedList actors=(LinkedList)container.deepEntityList();
  _actorToDepth=new Hashtable(actors.size());
  Iterator actorsIterator=actors.iterator();
  while (actorsIterator.hasNext()) {
    Actor actor=(Actor)actorsIterator.next();
    int depth=-1;
    Iterator inputs=actor.inputPortList().iterator();
    while (inputs.hasNext()) {
      IOPort inputPort=(IOPort)inputs.next();
      int inputDepth=_getDepthOfIOPort(inputPort);
      if (inputDepth < depth || depth == -1) {
        depth=inputDepth;
      }
    }
    Iterator outputs=actor.outputPortList().iterator();
    while (outputs.hasNext()) {
      IOPort outputPort=(IOPort)outputs.next();
      int outputDepth=_getDepthOfIOPort(outputPort);
      if (outputDepth < depth) {
        depth=outputDepth;
      }
    }
    _actorToDepth.put(actor,new Integer(depth));
  }
  if (!_eventQueue.isEmpty()) {
    LinkedList updatedEventList=new LinkedList();
    while (!_eventQueue.isEmpty()) {
      DEEvent event=_eventQueue.take();
      IOPort ioPort=event.ioPort();
      Actor actor=event.actor();
      if (ioPort != null) {
        event._updateDepth(_getDepthOfIOPort(ioPort));
      }
 else       if (actor != null) {
        event._updateDepth(_getDepthOfActor(actor));
      }
 else {
      }
      updatedEventList.add(event);
    }
    Iterator updatedEvents=updatedEventList.iterator();
    while (updatedEvents.hasNext()) {
      DEEvent updatedEvent=(DEEvent)updatedEvents.next();
      _eventQueue.put(updatedEvent);
    }
  }
}","private void _computeActorDepth() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  LinkedList actors=(LinkedList)container.deepEntityList();
  _actorToDepth=new Hashtable(actors.size());
  Iterator actorsIterator=actors.iterator();
  while (actorsIterator.hasNext()) {
    Actor actor=(Actor)actorsIterator.next();
    int depth=-1;
    Iterator inputs=actor.inputPortList().iterator();
    while (inputs.hasNext()) {
      IOPort inputPort=(IOPort)inputs.next();
      int inputDepth=_getDepthOfIOPort(inputPort);
      if (inputDepth < depth || depth == -1) {
        depth=inputDepth;
      }
    }
    Iterator outputs=actor.outputPortList().iterator();
    while (outputs.hasNext()) {
      IOPort outputPort=(IOPort)outputs.next();
      int outputDepth=_getDepthOfIOPort(outputPort);
      if (outputDepth < depth || depth == -1) {
        depth=outputDepth;
      }
    }
    _actorToDepth.put(actor,new Integer(depth));
  }
  if (!_eventQueue.isEmpty()) {
    LinkedList updatedEventList=new LinkedList();
    while (!_eventQueue.isEmpty()) {
      DEEvent event=_eventQueue.take();
      IOPort ioPort=event.ioPort();
      Actor actor=event.actor();
      if (ioPort != null) {
        event._updateDepth(_getDepthOfIOPort(ioPort));
      }
 else       if (actor != null) {
        event._updateDepth(_getDepthOfActor(actor));
      }
 else {
      }
      updatedEventList.add(event);
    }
    Iterator updatedEvents=updatedEventList.iterator();
    while (updatedEvents.hasNext()) {
      DEEvent updatedEvent=(DEEvent)updatedEvents.next();
      _eventQueue.put(updatedEvent);
    }
  }
}"
75182,"/** 
 * Create the first tableau for the given effigy, using the tableau factory.  This is called after an effigy is first opened, or when a new effigy is created.  If the method fails to create a tableau, then it removes the effigy from the directory. This prevents us from having lingering effigies that have no user interface.
 * @param effigy The effigy for which to create a tableau.
 */
public Tableau createPrimaryTableau(final Effigy effigy){
  TableauFactory factory=null;
  if (effigy instanceof PtolemyEffigy) {
    NamedObj model=((PtolemyEffigy)effigy).getModel();
    if (model != null) {
      Iterator factories=model.attributeList(TableauFactory.class).iterator();
      while (factories.hasNext() && factory == null) {
        factory=(TableauFactory)factories.next();
        try {
          Tableau tableau=factory.createTableau(effigy);
          if (tableau != null) {
            if (effigy.getContainer() instanceof ModelDirectory) {
              tableau.setMaster(true);
            }
            tableau.setEditable(effigy.isModifiable());
            catchTableau(tableau);
            tableau.show();
            return tableau;
          }
        }
 catch (        Exception ex) {
          factory=null;
        }
      }
    }
  }
  factory=(TableauFactory)getAttribute(""String_Node_Str"");
  if (factory != null) {
    try {
      Tableau tableau=factory.createTableau(effigy);
      if (tableau == null) {
        throw new Exception(""String_Node_Str"");
      }
      if (effigy.getContainer() instanceof ModelDirectory) {
        tableau.setMaster(true);
      }
      tableau.setEditable(effigy.isModifiable());
      catchTableau(tableau);
      tableau.show();
      return tableau;
    }
 catch (    Exception ex) {
      MessageHandler.error(""String_Node_Str"" + effigy.identifier.getExpression(),ex);
      try {
        effigy.setContainer(null);
      }
 catch (      KernelException kernelException) {
        throw new InternalErrorException(this,kernelException,null);
      }
    }
  }
  return null;
}","/** 
 * Create the first tableau for the given effigy, using the tableau factory.  This is called after an effigy is first opened, or when a new effigy is created.  If the method fails to create a tableau, then it removes the effigy from the directory. This prevents us from having lingering effigies that have no user interface.
 * @param effigy The effigy for which to create a tableau.
 */
public Tableau createPrimaryTableau(final Effigy effigy){
  TableauFactory factory=null;
  if (effigy instanceof PtolemyEffigy) {
    NamedObj model=((PtolemyEffigy)effigy).getModel();
    if (model != null) {
      Iterator factories=model.attributeList(TableauFactory.class).iterator();
      while (factories.hasNext() && factory == null) {
        factory=(TableauFactory)factories.next();
        try {
          Tableau tableau=factory.createTableau(effigy);
          if (tableau != null) {
            if (effigy.masterEffigy() == effigy) {
              tableau.setMaster(true);
            }
            tableau.setEditable(effigy.isModifiable());
            catchTableau(tableau);
            tableau.show();
            return tableau;
          }
        }
 catch (        Exception ex) {
          factory=null;
        }
      }
    }
  }
  factory=(TableauFactory)getAttribute(""String_Node_Str"");
  if (factory != null) {
    try {
      Tableau tableau=factory.createTableau(effigy);
      if (tableau == null) {
        throw new Exception(""String_Node_Str"");
      }
      if (effigy.getContainer() instanceof ModelDirectory) {
        tableau.setMaster(true);
      }
      tableau.setEditable(effigy.isModifiable());
      catchTableau(tableau);
      tableau.show();
      return tableau;
    }
 catch (    Exception ex) {
      MessageHandler.error(""String_Node_Str"" + effigy.identifier.getExpression(),ex);
      try {
        effigy.setContainer(null);
      }
 catch (      KernelException kernelException) {
        throw new InternalErrorException(this,kernelException,null);
      }
    }
  }
  return null;
}"
75183,"/** 
 * Create the first tableau for the given effigy, using the tableau factory.  This is called after an effigy is first opened, or when a new effigy is created.  If the method fails to create a tableau, then it removes the effigy from the directory. This prevents us from having lingering effigies that have no user interface.
 * @return A tableau for the specified effigy, or null if nonecan be opened.
 * @param effigy The effigy for which to create a tableau.
 */
public Tableau createPrimaryTableau(final Effigy effigy){
  TableauFactory factory=null;
  if (effigy instanceof PtolemyEffigy) {
    NamedObj model=((PtolemyEffigy)effigy).getModel();
    if (model != null) {
      Iterator factories=model.attributeList(TableauFactory.class).iterator();
      while (factories.hasNext() && factory == null) {
        factory=(TableauFactory)factories.next();
        try {
          Tableau tableau=factory.createTableau(effigy);
          if (tableau != null) {
            if (effigy.getContainer() instanceof ModelDirectory) {
              tableau.setMaster(true);
            }
            tableau.setEditable(effigy.isModifiable());
            tableau.show();
            return tableau;
          }
        }
 catch (        Exception ex) {
          factory=null;
        }
      }
    }
  }
  factory=(TableauFactory)getAttribute(""String_Node_Str"");
  if (factory != null) {
    try {
      Tableau tableau=factory.createTableau(effigy);
      if (tableau == null) {
        throw new Exception(""String_Node_Str"");
      }
      if (effigy.getContainer() instanceof ModelDirectory) {
        tableau.setMaster(true);
      }
      tableau.setEditable(effigy.isModifiable());
      tableau.show();
      return tableau;
    }
 catch (    Exception ex) {
      try {
        effigy.setContainer(null);
      }
 catch (      KernelException kernelException) {
        throw new InternalErrorException(this,kernelException,null);
      }
      if (effigy instanceof PtolemyEffigy) {
        NamedObj object=((PtolemyEffigy)effigy).getModel();
        String filename=StringUtilities.objectToSourceFileName(object);
        try {
          URL toRead=getClass().getClassLoader().getResource(filename);
          if (toRead != null) {
            return openModel(null,toRead,toRead.toExternalForm());
          }
 else {
            MessageHandler.error(""String_Node_Str"" + object.getFullName());
          }
        }
 catch (        Exception exception) {
          MessageHandler.error(""String_Node_Str"" + object.getFullName(),exception);
        }
      }
      MessageHandler.error(""String_Node_Str"" + effigy.identifier.getExpression(),ex);
    }
  }
  return null;
}","/** 
 * Create the first tableau for the given effigy, using the tableau factory.  This is called after an effigy is first opened, or when a new effigy is created.  If the method fails to create a tableau, then it removes the effigy from the directory. This prevents us from having lingering effigies that have no user interface.
 * @return A tableau for the specified effigy, or null if nonecan be opened.
 * @param effigy The effigy for which to create a tableau.
 */
public Tableau createPrimaryTableau(final Effigy effigy){
  TableauFactory factory=null;
  if (effigy instanceof PtolemyEffigy) {
    NamedObj model=((PtolemyEffigy)effigy).getModel();
    if (model != null) {
      Iterator factories=model.attributeList(TableauFactory.class).iterator();
      while (factories.hasNext() && factory == null) {
        factory=(TableauFactory)factories.next();
        try {
          Tableau tableau=factory.createTableau(effigy);
          if (tableau != null) {
            if (effigy.masterEffigy() == effigy) {
              tableau.setMaster(true);
            }
            tableau.setEditable(effigy.isModifiable());
            tableau.show();
            return tableau;
          }
        }
 catch (        Exception ex) {
          factory=null;
        }
      }
    }
  }
  factory=(TableauFactory)getAttribute(""String_Node_Str"");
  if (factory != null) {
    try {
      Tableau tableau=factory.createTableau(effigy);
      if (tableau == null) {
        throw new Exception(""String_Node_Str"");
      }
      if (effigy.getContainer() instanceof ModelDirectory) {
        tableau.setMaster(true);
      }
      tableau.setEditable(effigy.isModifiable());
      tableau.show();
      return tableau;
    }
 catch (    Exception ex) {
      try {
        effigy.setContainer(null);
      }
 catch (      KernelException kernelException) {
        throw new InternalErrorException(this,kernelException,null);
      }
      if (effigy instanceof PtolemyEffigy) {
        NamedObj object=((PtolemyEffigy)effigy).getModel();
        String filename=StringUtilities.objectToSourceFileName(object);
        try {
          URL toRead=getClass().getClassLoader().getResource(filename);
          if (toRead != null) {
            return openModel(null,toRead,toRead.toExternalForm());
          }
 else {
            MessageHandler.error(""String_Node_Str"" + object.getFullName());
          }
        }
 catch (        Exception exception) {
          MessageHandler.error(""String_Node_Str"" + object.getFullName(),exception);
        }
      }
      MessageHandler.error(""String_Node_Str"" + effigy.identifier.getExpression(),ex);
    }
  }
  return null;
}"
75184,"/** 
 * Record whether the data associated with this effigy has been modified since it was first read or last saved.  If you call this with a true argument, then subsequent calls to isModified() will return true.  This is used by instances of TableauFrame. This is recorded in the entity returned by topEntity(), which is the one associated with a file.
 * @param modified True if the data has been modified.
 */
public void setModified(boolean modified){
  topEffigy()._modified=modified;
}","/** 
 * Record whether the data associated with this effigy has been modified since it was first read or last saved.  If you call this with a true argument, then subsequent calls to isModified() will return true.  This is used by instances of TableauFrame. This is recorded in the entity returned by topEntity(), which is the one associated with a file. This always sets a flag in the master effigy (as returned by masterEffigy()).
 * @see #masterEffigy()
 * @see #isModifiable()
 * @see #isModified()
 * @see #setModifiable()
 * @param modified True if the data has been modified.
 */
public void setModified(boolean modified){
  masterEffigy()._modified=modified;
}"
75185,"/** 
 * Return whether the model data is modifiable.  In this case, this is determined by checking whether the URI associated with this effigy can be written to.  This will return false if either there is no URI associated with this effigy, or the URI is not a file, or the file is not writable or does not exist, or setModifiable() has been called with a false argument.
 * @return False to indicate that the model is not modifiable.
 */
public boolean isModifiable(){
  if (!_modifiable)   return false;
 else   return _modifiableURI;
}","/** 
 * Return whether the model data is modifiable.  This is delegated to the effigy returned by masterEffigy().  If this is the master effigy, then whether the data is modifiable depends on whether setModifiable() has been called, and if not, on whether there is a URI associated with this effigy and whether that URI is writable.
 * @see #masterEffigy()
 * @return False to indicate that the model is not modifiable.
 */
public boolean isModifiable(){
  Effigy master=masterEffigy();
  if (!master._modifiable)   return false;
 else   return master._modifiableURI;
}"
75186,"/** 
 * Return the value set by setModified(), or false if setModified() has not been called on this effigy or any effigy contained by the same top effigy (returned by topEffigy()). This method is intended to be used to keep track of whether the data in the file or URI associated with this data has been modified.  The method is called by an instance of TableauFrame to determine whether it is safe to close.
 * @see #setModifiable(boolean)
 * @return True if the data has been modified.
 */
public boolean isModified(){
  return topEffigy()._modified;
}","/** 
 * Return the data associated with the master effigy (as returned by masterEffigy()) has been modified. This method is intended to be used to keep track of whether the data in the file or URI associated with this data has been modified.  The method is called by an instance of TableauFrame to determine whether it is safe to close.
 * @see #masterEffigy()
 * @see #setModifiable(boolean)
 * @return True if the data has been modified.
 */
public boolean isModified(){
  return masterEffigy()._modified;
}"
75187,"/** 
 * If the argument is false, the specify that that the model is not modifiable, even if the URI associated with this effigy is writable. If the argument is true, or if this method is never called, then whether the model is modifiable is determined by whether the URI can be written to. Notice that this does not automatically result in any tableaux that are contained switching to being uneditable.  But it will prevent them from writing to the URI.
 * @see #isModifiable()
 * @param flag False to prevent writing to the URI.
 */
public void setModifiable(boolean flag){
  _modifiable=flag;
}","/** 
 * If the argument is false, the specify that that the model is not modifiable, even if the URI associated with this effigy is writable. This always sets a flag in the master effigy (as returned by masterEffigy()). If the argument is true, or if this method is never called, then whether the model is modifiable is determined by whether the URI can be written to. Notice that this does not automatically result in any tableaux that are contained switching to being uneditable.  But it will prevent them from writing to the URI.
 * @see #masterEffigy()
 * @see #isModifiable()
 * @see #isModified()
 * @see #setModified(boolean)
 * @param flag False to prevent writing to the URI.
 */
public void setModifiable(boolean flag){
  masterEffigy()._modifiable=flag;
}"
75188,"/** 
 * Construct a dialog that presents the ports as a table. Each row of the table corresponds to one port. The user modifies the table to specify changes in the ports. When the apply button is pressed the contents of the table is used to update the ports. When Commit is pressed an apply is done before exiting. <p> This dialog is is not modal. In particular, changes can be undone by clicking Edit->Undo, and the help screen can be manipulated while this dialog exists. The dialog is placed relative to the owner.
 * @param tableau The DialogTableau.
 * @param owner The object that, per the user, appears to be generating thedialog.
 * @param target The object whose ports are being configured.
 * @param configuration The configuration to use to open the help screen(or null if help is not supported).
 */
public PortConfigurerDialog(DialogTableau tableau,Frame owner,Entity target,Configuration configuration){
  super(""String_Node_Str"" + target.getName(),tableau,owner,target,configuration);
  getTarget().addChangeListener(this);
  _portLocationComboBox=new JComboBox();
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portTable=new JTable();
  _portTable.setPreferredScrollableViewportSize(new Dimension(600,70));
  _portTable.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent mouseEvent){
      if ((VergilUtilities.macOSLookAndFeel() && (mouseEvent.isPopupTrigger() || (mouseEvent.getButton() == MouseEvent.BUTTON1 && ((mouseEvent.getModifiersEx() | java.awt.event.InputEvent.CTRL_DOWN_MASK) == java.awt.event.InputEvent.CTRL_DOWN_MASK)))) || (!VergilUtilities.macOSLookAndFeel() && mouseEvent.getButton() == MouseEvent.BUTTON3)) {
        Point point=mouseEvent.getPoint();
        int row=_portTable.rowAtPoint(point);
        _setSelectedRow(row);
      }
    }
  }
);
  _portTable.addKeyListener(new KeyAdapter(){
    public void keyTyped(    KeyEvent ke){
      if (ke.getKeyChar() == '\n') {
        _apply();
        _cancel();
      }
    }
  }
);
  _initColumnNames();
  _setupTableModel();
  _initColumnSizes();
  setScrollableContents(_portTable);
  _jth=_portTable.getTableHeader();
  if (_columnNames.contains(ColumnNames.COL_SHOW_NAME) || _columnNames.contains(ColumnNames.COL_HIDE)) {
    _jth.addMouseListener(new MouseAdapter(){
      public void mouseClicked(      MouseEvent me){
        int showName=_columnNames.indexOf(ColumnNames.COL_SHOW_NAME);
        if (showName != -1) {
          Rectangle headerShowNameRect=_jth.getHeaderRect(showName);
          if (headerShowNameRect.contains(me.getPoint())) {
            _portTableModel.toggleShowAllNames();
          }
        }
        int hide=_columnNames.indexOf(ColumnNames.COL_HIDE);
        if (hide != 1) {
          Rectangle headerHidePortRect=_jth.getHeaderRect(hide);
          if (headerHidePortRect.contains(me.getPoint())) {
            _portTableModel.toggleHidePorts();
          }
        }
      }
    }
);
  }
  pack();
  setVisible(true);
}","/** 
 * Construct a dialog that presents the ports as a table. Each row of the table corresponds to one port. The user modifies the table to specify changes in the ports. When the apply button is pressed the contents of the table is used to update the ports. When Commit is pressed an apply is done before exiting. <p> This dialog is is not modal. In particular, changes can be undone by clicking Edit->Undo, and the help screen can be manipulated while this dialog exists. The dialog is placed relative to the owner.
 * @param tableau The DialogTableau.
 * @param owner The object that, per the user, appears to be generating thedialog.
 * @param target The object whose ports are being configured.
 * @param configuration The configuration to use to open the help screen(or null if help is not supported).
 */
public PortConfigurerDialog(DialogTableau tableau,Frame owner,Entity target,Configuration configuration){
  super(""String_Node_Str"" + target.getName(),tableau,owner,target,configuration);
  getTarget().addChangeListener(this);
  _portLocationComboBox=new JComboBox();
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portTable=new JTable();
  _portTable.setPreferredScrollableViewportSize(new Dimension(600,70));
  _portTable.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent mouseEvent){
      if ((VergilUtilities.macOSLookAndFeel() && (mouseEvent.isPopupTrigger() || (mouseEvent.getButton() == MouseEvent.BUTTON1 && ((mouseEvent.getModifiersEx() | java.awt.event.InputEvent.CTRL_MASK) == java.awt.event.InputEvent.CTRL_MASK)))) || (!VergilUtilities.macOSLookAndFeel() && mouseEvent.getButton() == MouseEvent.BUTTON3)) {
        Point point=mouseEvent.getPoint();
        int row=_portTable.rowAtPoint(point);
        _setSelectedRow(row);
      }
    }
  }
);
  _portTable.addKeyListener(new KeyAdapter(){
    public void keyTyped(    KeyEvent ke){
      if (ke.getKeyChar() == '\n') {
        _apply();
        _cancel();
      }
    }
  }
);
  _initColumnNames();
  _setupTableModel();
  _initColumnSizes();
  setScrollableContents(_portTable);
  _jth=_portTable.getTableHeader();
  if (_columnNames.contains(ColumnNames.COL_SHOW_NAME) || _columnNames.contains(ColumnNames.COL_HIDE)) {
    _jth.addMouseListener(new MouseAdapter(){
      public void mouseClicked(      MouseEvent me){
        int showName=_columnNames.indexOf(ColumnNames.COL_SHOW_NAME);
        if (showName != -1) {
          Rectangle headerShowNameRect=_jth.getHeaderRect(showName);
          if (headerShowNameRect.contains(me.getPoint())) {
            _portTableModel.toggleShowAllNames();
          }
        }
        int hide=_columnNames.indexOf(ColumnNames.COL_HIDE);
        if (hide != 1) {
          Rectangle headerHidePortRect=_jth.getHeaderRect(hide);
          if (headerHidePortRect.contains(me.getPoint())) {
            _portTableModel.toggleHidePorts();
          }
        }
      }
    }
);
  }
  pack();
  setVisible(true);
}"
75189,"/** 
 * Write the model to the specified file.  This method delegates to the top effigy containing the associated Tableau, if there is one, and otherwise throws an exception. This ensures that the data written is the description of the entire model, not just the portion within some composite actor.   It also adjusts the URIAttribute in the model to match the specified file, if necessary, and creates one otherwise.  It also overrides the base class to update the attributes if they need to update their content.
 * @param file The file to write to.
 * @exception IOException If the write fails.
 */
protected void _writeFile(File file) throws IOException {
  Tableau tableau=getTableau();
  if (tableau != null) {
    Effigy effigy=(Effigy)tableau.getContainer();
    if (effigy != null) {
      if (_model != null) {
        Iterator attributes=_model.attributeList(Attribute.class).iterator();
        while (attributes.hasNext()) {
          Attribute attribute=(Attribute)attributes.next();
          attribute.updateContent();
        }
      }
      if (_model == null) {
        effigy=effigy.topEffigy();
      }
 else       if (_query == null || (_model.getContainer() != null && !_query.getBooleanValue(""String_Node_Str""))) {
        NamedObj toplevel=_model.toplevel();
        Effigy effigyForToplevel=Configuration.findEffigy(toplevel);
        if (effigyForToplevel != null) {
          effigy=effigyForToplevel;
        }
      }
      effigy.writeFile(file);
      return;
    }
  }
  throw new IOException(""String_Node_Str"");
}","/** 
 * Write the model to the specified file.  This method delegates to the top effigy containing the associated Tableau, if there is one, and otherwise throws an exception. This ensures that the data written is the description of the entire model, not just the portion within some composite actor.   It also adjusts the URIAttribute in the model to match the specified file, if necessary, and creates one otherwise.  It also overrides the base class to update the attributes if they need to update their content.
 * @param file The file to write to.
 * @exception IOException If the write fails.
 */
protected void _writeFile(File file) throws IOException {
  Tableau tableau=getTableau();
  if (tableau != null) {
    Effigy effigy=(Effigy)tableau.getContainer();
    if (effigy != null) {
      if (_model != null) {
        Iterator attributes=_model.attributeList(Attribute.class).iterator();
        while (attributes.hasNext()) {
          Attribute attribute=(Attribute)attributes.next();
          attribute.updateContent();
        }
      }
      if (_model == null) {
        effigy=effigy.topEffigy();
      }
 else       if (_query == null || (_model.getContainer() != null && !_query.getBooleanValue(""String_Node_Str""))) {
        effigy=effigy.masterEffigy();
      }
      effigy.writeFile(file);
      return;
    }
  }
  throw new IOException(""String_Node_Str"");
}"
75190,"/** 
 * Create a tableau to run the model associated with the specified effigy.  The top-level effigy, as returned by  {@link Effigy#topEffigy()}, is the one that is run. If that effigy already contains a tableau named ""runTableau"", then return that tableau; otherwise, create a new instance of RunTableau for the top effigy, and name it ""runTableau"".  If the specified effigy is not an instance of PtolemyEffigy, then do not create a tableau and return null. It is the responsibility of callers of this method to check the return value and call show().
 * @param effigy The model effigy.
 * @return A new run tableau if the effigy is a PtolemyEffigy,or null otherwise.
 * @exception Exception If the factory should be able to create atableau for the effigy, but something goes wrong.
 */
public Tableau createTableau(Effigy effigy) throws Exception {
  return super.createTableau(effigy.topEffigy());
}","/** 
 * Create a tableau to run the model associated with the specified effigy.  The top-level effigy, as returned by  {@link Effigy#masterEffigy()}, is the one that is run. If that effigy already contains a tableau named ""runTableau"", then return that tableau; otherwise, create a new instance of RunTableau for the top effigy, and name it ""runTableau"".  If the specified effigy is not an instance of PtolemyEffigy, then do not create a tableau and return null. It is the responsibility of callers of this method to check the return value and call show().
 * @param effigy The model effigy.
 * @return A new run tableau if the effigy is a PtolemyEffigy,or null otherwise.
 * @exception Exception If the factory should be able to create atableau for the effigy, but something goes wrong.
 */
public Tableau createTableau(Effigy effigy) throws Exception {
  return super.createTableau(effigy.masterEffigy());
}"
75191,"/** 
 * Return true if this tableau is a master, which means that if that if its window is closed, then all other windows associated with the model are also closed.
 * @return True if the tableau is a master.
 */
public boolean isMaster(){
  return _master;
}","/** 
 * Return true if this tableau is a master, which means that if that if its window is closed, then all other windows associated with the model are also closed. A tableau is a master if its container effigy is a master (its masterEffigy() method returns itself).
 * @return True if the tableau is a master.
 */
public boolean isMaster(){
  return _master;
}"
75192,"/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, and there are no other tableaux in the parent effigy or any effigy that contains it, then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (getEffigy() == null) {
    return super._close();
  }
  Effigy topEffigy=getEffigy().topEffigy();
  if (!_tableau.isMaster()) {
    List tableaux=topEffigy.entityList(Tableau.class);
    Iterator tableauxIterator=tableaux.iterator();
    while (tableauxIterator.hasNext()) {
      Tableau tableau=(Tableau)tableauxIterator.next();
      if (!(tableau instanceof DialogTableau) && (tableau != _tableau)) {
        dispose();
        return true;
      }
    }
  }
  if (isModified()) {
    int reply=_queryForSave();
    if (reply == _DISCARDED || reply == _FAILED) {
      if (!_checkForDerivedObjects()) {
        return false;
      }
    }
    if (reply == _SAVED || reply == _DISCARDED) {
      dispose();
      return true;
    }
    return false;
  }
 else {
    dispose();
    return true;
  }
}","/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window have been modified, and there are no other tableaux in the parent effigy or any effigy that contains it, then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (getEffigy() == null) {
    return super._close();
  }
  Effigy masterEffigy=getEffigy().masterEffigy();
  if (!_tableau.isMaster()) {
    List tableaux=masterEffigy.entityList(Tableau.class);
    Iterator tableauxIterator=tableaux.iterator();
    while (tableauxIterator.hasNext()) {
      Tableau tableau=(Tableau)tableauxIterator.next();
      if (!(tableau instanceof DialogTableau) && (tableau != _tableau)) {
        dispose();
        return true;
      }
    }
  }
  if (isModified()) {
    int reply=_queryForSave();
    if (reply == _DISCARDED || reply == _FAILED) {
      if (!_checkForDerivedObjects()) {
        return false;
      }
    }
    if (reply == _SAVED) {
      dispose();
      return true;
    }
 else     if (reply == _DISCARDED) {
      dispose();
      setModified(false);
      try {
        MoMLParser.purgeModelRecord(masterEffigy.uri.getURL());
      }
 catch (      MalformedURLException e) {
      }
      return true;
    }
    return false;
  }
 else {
    dispose();
    return true;
  }
}"
75193,"/** 
 * Report an exception if it occurred in a background run.
 * @exception IllegalActionException If there is no director, or ifa background run threw an exception.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  if (_throwable != null) {
    Throwable throwable=_throwable;
    _throwable=null;
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
}","/** 
 * Report an exception if it occurred in a background run.
 * @exception IllegalActionException If there is no director, or ifa background run threw an exception.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  _alreadyReadInputs=false;
  if (_throwable != null) {
    Throwable throwable=_throwable;
    _throwable=null;
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
}"
75194,"/** 
 * Construct a ModelReference with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.  This actor will have no local director initially, and its executive director will be simply the director of the container.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ModelReference(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  modelFileOrURL=new FileParameter(this,""String_Node_Str"");
  executionOnFiring=new StringParameter(this,""String_Node_Str"");
  executionOnFiring.setExpression(""String_Node_Str"");
  executionOnFiring.addChoice(""String_Node_Str"");
  executionOnFiring.addChoice(""String_Node_Str"");
  executionOnFiring.addChoice(""String_Node_Str"");
  lingerTime=new Parameter(this,""String_Node_Str"");
  lingerTime.setTypeEquals(BaseType.LONG);
  lingerTime.setExpression(""String_Node_Str"");
  postfireAction=new StringParameter(this,""String_Node_Str"");
  postfireAction.setExpression(""String_Node_Str"");
  postfireAction.addChoice(""String_Node_Str"");
  postfireAction.addChoice(""String_Node_Str"");
}","/** 
 * Construct a ModelReference with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.  This actor will have no local director initially, and its executive director will be simply the director of the container.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ModelReference(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  modelFileOrURL=new FilePortParameter(this,""String_Node_Str"");
  executionOnFiring=new StringParameter(this,""String_Node_Str"");
  executionOnFiring.setExpression(""String_Node_Str"");
  executionOnFiring.addChoice(""String_Node_Str"");
  executionOnFiring.addChoice(""String_Node_Str"");
  executionOnFiring.addChoice(""String_Node_Str"");
  lingerTime=new Parameter(this,""String_Node_Str"");
  lingerTime.setTypeEquals(BaseType.LONG);
  lingerTime.setExpression(""String_Node_Str"");
  postfireAction=new StringParameter(this,""String_Node_Str"");
  postfireAction.setExpression(""String_Node_Str"");
  postfireAction.addChoice(""String_Node_Str"");
  postfireAction.addChoice(""String_Node_Str"");
}"
75195,"/** 
 * Iterate over input ports and read any available values into the referenced model parameters.
 * @exception IllegalActionException If reading the ports orsetting the parameters causes it.
 */
private void _readInputs() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Iterator ports=inputPortList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    if (port instanceof ParameterPort) {
      PortParameter parameter=((ParameterPort)port).getParameter();
      if (_debugging) {
        _debug(""String_Node_Str"" + port.getName());
      }
      parameter.update();
      continue;
    }
    if (port.getWidth() > 0 && port.hasToken(0)) {
      Token token=port.get(0);
      Attribute attribute=_model.getAttribute(port.getName());
      if (attribute instanceof Variable) {
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getName());
        }
        ((Variable)attribute).setToken(token);
      }
 else       if (attribute instanceof Settable) {
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getName());
        }
        ((Settable)attribute).setExpression(token.toString());
      }
    }
  }
}","/** 
 * Iterate over input ports and read any available values into the referenced model parameters.
 * @exception IllegalActionException If reading the ports orsetting the parameters causes it.
 */
protected void _readInputs() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Iterator ports=inputPortList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    if (port instanceof ParameterPort) {
      PortParameter parameter=((ParameterPort)port).getParameter();
      if (_debugging) {
        _debug(""String_Node_Str"" + port.getName());
      }
      parameter.update();
      continue;
    }
    if (port.getWidth() > 0 && port.hasToken(0)) {
      Token token=port.get(0);
      Attribute attribute=_model.getAttribute(port.getName());
      if (attribute instanceof Variable) {
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getName());
        }
        ((Variable)attribute).setToken(token);
      }
 else       if (attribute instanceof Settable) {
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getName());
        }
        ((Settable)attribute).setExpression(token.toString());
      }
    }
  }
}"
75196,"/** 
 * Override the base class to open the model specified if the attribute is modelFileOrURL, or for other parameters, to cache their values.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == modelFileOrURL) {
    URL url=modelFileOrURL.asURL();
    if (url != null) {
      MoMLParser parser=new MoMLParser();
      try {
        _model=parser.parse(null,url);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"");
      }
      if (_model instanceof CompositeActor) {
        _manager=new Manager(_model.workspace(),""String_Node_Str"");
        ((CompositeActor)_model).setManager(_manager);
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
 else {
      _model=null;
      _manager=null;
      _throwable=null;
    }
  }
 else   if (attribute == executionOnFiring) {
    String executionOnFiringValue=executionOnFiring.stringValue();
    if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_RUN_IN_CALLING_THREAD;
    }
 else     if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_RUN_IN_A_NEW_THREAD;
    }
 else     if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_DO_NOTHING;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + executionOnFiringValue);
    }
  }
 else   if (attribute == postfireAction) {
    String postfireActionValue=postfireAction.stringValue();
    if (postfireActionValue.equals(""String_Node_Str"")) {
      _postfireActionValue=_DO_NOTHING;
    }
 else     if (postfireActionValue.equals(""String_Node_Str"")) {
      _postfireActionValue=_STOP_EXECUTING;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + postfireActionValue);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Override the base class to open the model specified if the attribute is modelFileOrURL, or for other parameters, to cache their values.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == modelFileOrURL) {
    if (_debugging) {
      _debug(""String_Node_Str"" + modelFileOrURL.getExpression());
    }
    URL url=modelFileOrURL.asURL();
    if (url != null) {
      MoMLParser parser=new MoMLParser();
      try {
        _model=parser.parse(null,url);
      }
 catch (      Exception ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"");
      }
      if (_model instanceof CompositeActor) {
        _manager=new Manager(_model.workspace(),""String_Node_Str"");
        ((CompositeActor)_model).setManager(_manager);
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
 else {
      _model=null;
      _manager=null;
      _throwable=null;
    }
  }
 else   if (attribute == executionOnFiring) {
    String executionOnFiringValue=executionOnFiring.stringValue();
    if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_RUN_IN_CALLING_THREAD;
    }
 else     if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_RUN_IN_A_NEW_THREAD;
    }
 else     if (executionOnFiringValue.equals(""String_Node_Str"")) {
      _executionOnFiringValue=_DO_NOTHING;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + executionOnFiringValue);
    }
  }
 else   if (attribute == postfireAction) {
    String postfireActionValue=postfireAction.stringValue();
    if (postfireActionValue.equals(""String_Node_Str"")) {
      _postfireActionValue=_DO_NOTHING;
    }
 else     if (postfireActionValue.equals(""String_Node_Str"")) {
      _postfireActionValue=_STOP_EXECUTING;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + postfireActionValue);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75197,"/** 
 * Run a complete execution of the referenced model.  A complete execution consists of invocation of super.initialize(), repeated invocations of super.prefire(), super.fire(), and super.postfire(), followed by super.wrapup().  The invocations of prefire(), fire(), and postfire() are repeated until either the model indicates it is not ready to execute (prefire() returns false), or it requests a stop (postfire() returns false or stop() is called). Before running the complete execution, this method examines input ports, and if they are connected, have data, and if the referenced model has a top-level parameter with the same name, then one token is read from the input port and used to set the value of the parameter in the referenced model. After running the complete execution, if there are any output ports, then this method looks for top-level parameters in the referenced model with the same name as the output ports, and if there are any, reads their values and produces them on the output. If no model has been specified, then this method does nothing.
 * @exception IllegalActionException If there is no director, or ifthe director's action methods throw it.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (_throwable != null) {
    Throwable throwable=_throwable;
    _throwable=null;
    throw new IllegalActionException(this,throwable,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_model instanceof CompositeActor) {
    CompositeActor executable=(CompositeActor)_model;
    _manager=executable.getManager();
    if (_manager == null) {
      throw new InternalErrorException(""String_Node_Str"");
    }
    if (_debugging) {
      _manager.addDebugListener(this);
      Director director=executable.getDirector();
      if (director != null) {
        director.addDebugListener(this);
      }
    }
 else {
      _manager.removeDebugListener(this);
      Director director=executable.getDirector();
      if (director != null) {
        director.removeDebugListener(this);
      }
    }
    if (_executing) {
synchronized (this) {
        while (_executing) {
          try {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            workspace().wait(this);
          }
 catch (          InterruptedException ex) {
            getManager().finish();
            return;
          }
        }
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
    _readInputs();
    if (_executionOnFiringValue == _RUN_IN_CALLING_THREAD) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      try {
        _manager.execute();
      }
 catch (      KernelException ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"");
      }
      _writeOutputs();
    }
 else     if (_executionOnFiringValue == _RUN_IN_A_NEW_THREAD) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _manager.addExecutionListener(this);
      if (_manager.getState() != Manager.IDLE) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _manager.getState().getDescription());
      }
      Thread thread=new Thread(){
        public void run(){
          try {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            _manager.execute();
            _writeOutputs();
          }
 catch (          Throwable throwable) {
            _manager.notifyListenersOfThrowable(throwable);
          }
        }
      }
;
      thread.setPriority(Thread.MIN_PRIORITY);
      thread.start();
    }
    long lingerTimeValue=((LongToken)lingerTime.getToken()).longValue();
    if (lingerTimeValue > 0L) {
      try {
        if (_debugging) {
          _debug(""String_Node_Str"" + lingerTimeValue + ""String_Node_Str"");
        }
        _lingeringThread=Thread.currentThread();
        Thread.sleep(lingerTimeValue);
      }
 catch (      InterruptedException ex) {
      }
 finally {
        _lingeringThread=null;
      }
    }
  }
}","/** 
 * Run a complete execution of the referenced model.  A complete execution consists of invocation of super.initialize(), repeated invocations of super.prefire(), super.fire(), and super.postfire(), followed by super.wrapup().  The invocations of prefire(), fire(), and postfire() are repeated until either the model indicates it is not ready to execute (prefire() returns false), or it requests a stop (postfire() returns false or stop() is called). Before running the complete execution, this method examines input ports, and if they are connected, have data, and if the referenced model has a top-level parameter with the same name, then one token is read from the input port and used to set the value of the parameter in the referenced model. After running the complete execution, if there are any output ports, then this method looks for top-level parameters in the referenced model with the same name as the output ports, and if there are any, reads their values and produces them on the output. If no model has been specified, then this method does nothing.
 * @exception IllegalActionException If there is no director, or ifthe director's action methods throw it.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (_throwable != null) {
    Throwable throwable=_throwable;
    _throwable=null;
    throw new IllegalActionException(this,throwable,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_model instanceof CompositeActor) {
    CompositeActor executable=(CompositeActor)_model;
    _manager=executable.getManager();
    if (_manager == null) {
      throw new InternalErrorException(""String_Node_Str"");
    }
    if (_debugging) {
      _manager.addDebugListener(this);
      Director director=executable.getDirector();
      if (director != null) {
        director.addDebugListener(this);
      }
    }
 else {
      _manager.removeDebugListener(this);
      Director director=executable.getDirector();
      if (director != null) {
        director.removeDebugListener(this);
      }
    }
    if (_executing) {
synchronized (this) {
        while (_executing) {
          try {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            workspace().wait(this);
          }
 catch (          InterruptedException ex) {
            getManager().finish();
            return;
          }
        }
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
    if (!_alreadyReadInputs) {
      _readInputs();
    }
    _alreadyReadInputs=false;
    if (_executionOnFiringValue == _RUN_IN_CALLING_THREAD) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      try {
        _manager.execute();
      }
 catch (      KernelException ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"");
      }
      _writeOutputs();
    }
 else     if (_executionOnFiringValue == _RUN_IN_A_NEW_THREAD) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _manager.addExecutionListener(this);
      if (_manager.getState() != Manager.IDLE) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _manager.getState().getDescription());
      }
      Thread thread=new Thread(){
        public void run(){
          try {
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
            _manager.execute();
            _writeOutputs();
          }
 catch (          Throwable throwable) {
            _manager.notifyListenersOfThrowable(throwable);
          }
        }
      }
;
      thread.setPriority(Thread.MIN_PRIORITY);
      thread.start();
    }
    long lingerTimeValue=((LongToken)lingerTime.getToken()).longValue();
    if (lingerTimeValue > 0L) {
      try {
        if (_debugging) {
          _debug(""String_Node_Str"" + lingerTimeValue + ""String_Node_Str"");
        }
        _lingeringThread=Thread.currentThread();
        Thread.sleep(lingerTimeValue);
      }
 catch (      InterruptedException ex) {
      }
 finally {
        _lingeringThread=null;
      }
    }
  }
}"
75198,"/** 
 * Override the base class to perform requested close on postfire actions. Note that if a close is requested, then this method waits until the AWT event thread completes the close.  This creates the possibility of a deadlock.
 * @return Whatever the superclass returns (probably true).
 * @exception IllegalActionException Thrown if a parent class throws it.
 */
public boolean postfire() throws IllegalActionException {
  boolean result=super.postfire();
  if (_tableau != null) {
    final JFrame frame=_tableau.getFrame();
    if (_closeOnPostfireValue == _CLOSE_VERGIL_GRAPH) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (frame instanceof ExtendedGraphFrame) {
        ((ExtendedGraphFrame)frame).cancelFullScreen();
      }
      if (frame instanceof TableauFrame) {
        Runnable doClose=new Runnable(){
          public void run(){
            ((TableauFrame)frame).close();
          }
        }
;
        try {
          SwingUtilities.invokeAndWait(doClose);
        }
 catch (        Exception ex) {
        }
      }
 else       if (frame != null) {
        Runnable doClose=new Runnable(){
          public void run(){
            frame.hide();
          }
        }
;
        Top.deferIfNecessary(doClose);
      }
    }
  }
  return result;
}","/** 
 * Override the base class to perform requested close on postfire actions. Note that if a close is requested, then this method waits until the AWT event thread completes the close.  This creates the possibility of a deadlock.
 * @return Whatever the superclass returns (probably true).
 * @exception IllegalActionException Thrown if a parent class throws it.
 */
public boolean postfire() throws IllegalActionException {
  boolean result=super.postfire();
  if (_tableau != null) {
    final JFrame frame=_tableau.getFrame();
    if (_closeOnPostfireValue == _CLOSE_VERGIL_GRAPH) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (frame instanceof TableauFrame) {
        Runnable doClose=new Runnable(){
          public void run(){
            if (frame instanceof ExtendedGraphFrame) {
              ((ExtendedGraphFrame)frame).cancelFullScreen();
            }
            ((TableauFrame)frame).close();
          }
        }
;
        Top.deferIfNecessary(doClose);
      }
 else       if (frame != null) {
        Runnable doClose=new Runnable(){
          public void run(){
            if (frame instanceof ExtendedGraphFrame) {
              ((ExtendedGraphFrame)frame).cancelFullScreen();
            }
            frame.hide();
          }
        }
;
        Top.deferIfNecessary(doClose);
      }
    }
  }
  return result;
}"
75199,"/** 
 * Run a complete execution of the referenced model.  A complete execution consists of invocation of super.initialize(), repeated invocations of super.prefire(), super.fire(), and super.postfire(), followed by super.wrapup().  The invocations of prefire(), fire(), and postfire() are repeated until either the model indicates it is not ready to execute (prefire() returns false), or it requests a stop (postfire() returns false or stop() is called). Before running the complete execution, this method examines input ports, and if they are connected, have data, and if the referenced model has a top-level parameter with the same name, then one token is read from the input port and used to set the value of the parameter in the referenced model. After running the complete execution, if there are any output ports, then this method looks for top-level parameters in the referenced model with the same name as the output ports, and if there are any, reads their values and produces them on the output. If no model has been specified, then this method does nothing.
 * @exception IllegalActionException If there is no director, or ifthe director's action methods throw it.
 */
public void fire() throws IllegalActionException {
  if (_model instanceof CompositeActor) {
    CompositeActor executable=(CompositeActor)_model;
    NamedObj toplevel=toplevel();
    Effigy myEffigy=Configuration.findEffigy(toplevel);
    if (myEffigy != null) {
      try {
        if (_openOnFiringValue == _OPEN_IN_VERGIL || _openOnFiringValue == _OPEN_IN_VERGIL_FULL_SCREEN) {
          Configuration configuration=(Configuration)myEffigy.toplevel();
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _tableau=configuration.openModel(_model,myEffigy);
          _tableau.setEditable(false);
          _tableau.show();
        }
 else {
          PtolemyEffigy newEffigy=new PtolemyEffigy(myEffigy,myEffigy.uniqueName(_model.getName()));
          newEffigy.setModel(_model);
          newEffigy.setModifiable(false);
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
        }
      }
 catch (      NameDuplicationException ex) {
        throw new InternalErrorException(ex);
      }
    }
    if (_tableau != null) {
      JFrame frame=_tableau.getFrame();
      if (frame != null) {
        if (_openOnFiringValue == _OPEN_IN_VERGIL) {
          frame.toFront();
        }
 else         if (_openOnFiringValue == _OPEN_IN_VERGIL_FULL_SCREEN) {
          if (frame instanceof ExtendedGraphFrame) {
            ((ExtendedGraphFrame)frame).fullScreen();
          }
 else {
            frame.toFront();
          }
        }
      }
    }
  }
  super.fire();
}","/** 
 * Run a complete execution of the referenced model.  A complete execution consists of invocation of super.initialize(), repeated invocations of super.prefire(), super.fire(), and super.postfire(), followed by super.wrapup().  The invocations of prefire(), fire(), and postfire() are repeated until either the model indicates it is not ready to execute (prefire() returns false), or it requests a stop (postfire() returns false or stop() is called). Before running the complete execution, this method examines input ports, and if they are connected, have data, and if the referenced model has a top-level parameter with the same name, then one token is read from the input port and used to set the value of the parameter in the referenced model. After running the complete execution, if there are any output ports, then this method looks for top-level parameters in the referenced model with the same name as the output ports, and if there are any, reads their values and produces them on the output. If no model has been specified, then this method does nothing.
 * @exception IllegalActionException If there is no director, or ifthe director's action methods throw it.
 */
public void fire() throws IllegalActionException {
  _readInputs();
  _alreadyReadInputs=true;
  if (_model instanceof CompositeActor) {
    CompositeActor executable=(CompositeActor)_model;
    NamedObj toplevel=toplevel();
    final Effigy myEffigy=Configuration.findEffigy(toplevel);
    if (myEffigy != null) {
      try {
        if (_openOnFiringValue == _OPEN_IN_VERGIL || _openOnFiringValue == _OPEN_IN_VERGIL_FULL_SCREEN) {
          Runnable doOpen=new Runnable(){
            public void run(){
              Configuration configuration=(Configuration)myEffigy.toplevel();
              if (_debugging) {
                _debug(""String_Node_Str"");
              }
              try {
                _exception=null;
                _tableau=configuration.openModel(_model,myEffigy);
                _tableau.setMaster(true);
              }
 catch (              KernelException e) {
                _exception=e;
              }
              _tableau.show();
              JFrame frame=_tableau.getFrame();
              if (frame != null) {
                frame.toFront();
                if (_openOnFiringValue == _OPEN_IN_VERGIL_FULL_SCREEN) {
                  if (frame instanceof ExtendedGraphFrame) {
                    ((ExtendedGraphFrame)frame).fullScreen();
                  }
                }
              }
            }
          }
;
          try {
            SwingUtilities.invokeAndWait(doOpen);
          }
 catch (          Exception ex) {
            throw new IllegalActionException(this,null,ex,""String_Node_Str"");
          }
          if (_exception != null) {
            throw new IllegalActionException(this,null,_exception,""String_Node_Str"");
          }
        }
 else {
          PtolemyEffigy newEffigy=new PtolemyEffigy(myEffigy,myEffigy.uniqueName(_model.getName()));
          newEffigy.setModel(_model);
          newEffigy.setModifiable(false);
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
        }
      }
 catch (      NameDuplicationException ex) {
        throw new InternalErrorException(ex);
      }
    }
  }
  super.fire();
}"
75200,"public void run(){
  frame.hide();
}","public void run(){
  if (frame instanceof ExtendedGraphFrame) {
    ((ExtendedGraphFrame)frame).cancelFullScreen();
  }
  frame.hide();
}"
75201,"/** 
 * Always returns true, indicating that the (sub)system is always ready for one iteration. <P> If this is not a top-level director, some additional work is done to synchronize time with the executive director. In particular, it will compare its local time, say t, with the current time of the executive director, say t0. If t == t0, do nothing. <BR> If t > t0, then rollback to the ""known good"" time (which should be less than the outside time) and catch up with the outside time. <BR> If t < t0, then throw an exception because the CT subsystem should always run ahead of time. <BR> <P> If this director is not a top-level director, the iteration end time is resolved from the current time of the outside domains, say t1, the next iteration time of the outside domain, say t2, and the runAheadLength parameter of this director, say t3. The iteration end time is set to be <code>t5 = t1 + min(t2, t3)</code>.  The iteration end time may be further refined in the fire() method  due to possible event generated during the iteration.  In particular, when the first event is detected, say at t5 and t5 < t4, then the iteration ends at t5.
 * @return true Always.
 * @exception IllegalActionException If the local time isless than the current time of the executive director, or thrown by a directed actor.
 */
public boolean prefire() throws IllegalActionException {
  if (_debugging) {
    _debug(getName(),""String_Node_Str"");
  }
  if (!_isTopLevel()) {
    CompositeActor container=(CompositeActor)getContainer();
    Director executiveDirector=container.getExecutiveDirector();
    _outsideTime=executiveDirector.getModelTime();
    Time localTime=getModelTime();
    double timeResolution=getTimeResolution();
    Time outsideNextIterationTime=executiveDirector.getModelNextIterationTime();
    if (_debugging) {
      _debug(""String_Node_Str"" + _outsideTime,""String_Node_Str"" + outsideNextIterationTime,""String_Node_Str"" + localTime);
    }
    if (outsideNextIterationTime.compareTo(_outsideTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + _outsideTime + ""String_Node_Str""+ outsideNextIterationTime);
    }
    if (_outsideTime.compareTo(localTime) > 0) {
      throw new IllegalActionException(this,executiveDirector,""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (_outsideTime.compareTo(localTime) < 0) {
      if (_debugging) {
        _debug(getName() + ""String_Node_Str"" + localTime+ ""String_Node_Str""+ _knownGoodTime+ ""String_Node_Str""+ _outsideTime);
      }
      _rollback();
      _catchUp();
      if (_debugging) {
        _debug(""String_Node_Str"" + localTime);
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    double aheadLength=outsideNextIterationTime.subtract(_outsideTime).getDoubleValue();
    if (_debugging) {
      _debug(getName(),""String_Node_Str"" + localTime,""String_Node_Str"" + _outsideTime,""String_Node_Str"" + outsideNextIterationTime + ""String_Node_Str""+ aheadLength);
    }
    if (aheadLength < timeResolution) {
      _setIterationEndTime(_outsideTime);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
 else     if (aheadLength < _runAheadLength) {
      _setIterationEndTime(outsideNextIterationTime);
    }
 else {
      _setIterationEndTime(_outsideTime.add(_runAheadLength));
    }
    if (_debugging) {
      _debug(getName(),""String_Node_Str"" + getIterationEndTime(),""String_Node_Str"");
    }
    return true;
  }
 else {
    return super.prefire();
  }
}","/** 
 * Always returns true, indicating that the (sub)system is always ready for one iteration. <P> If this is not a top-level director, some additional work is done to synchronize time with the executive director. In particular, it will compare its local time, say t, with the current time of the executive director, say t0. If t == t0, do nothing. <BR> If t > t0, then rollback to the ""known good"" time (which should be less than the outside time) and catch up with the outside time. <BR> If t < t0, then throw an exception because the CT subsystem should always run ahead of time. <BR> <P> If this director is not a top-level director, the iteration end time is resolved from the current time of the outside domains, say t1, the next iteration time of the outside domain, say t2, and the runAheadLength parameter of this director, say t3. The iteration end time is set to be <code>t5 = t1 + min(t2, t3)</code>.  The iteration end time may be further refined in the fire() method  due to possible event generated during the iteration.  In particular, when the first event is detected, say at t5 and t5 < t4, then the iteration ends at t5.
 * @return true Always.
 * @exception IllegalActionException If the local time isless than the current time of the executive director, or thrown by a directed actor.
 */
public boolean prefire() throws IllegalActionException {
  if (_debugging) {
    _debug(getName(),""String_Node_Str"");
  }
  if (!_isTopLevel()) {
    CompositeActor container=(CompositeActor)getContainer();
    Director executiveDirector=container.getExecutiveDirector();
    _outsideTime=executiveDirector.getModelTime();
    Time localTime=getModelTime();
    double timeResolution=getTimeResolution();
    Time outsideNextIterationTime=executiveDirector.getModelNextIterationTime();
    if (_debugging) {
      _debug(""String_Node_Str"" + _outsideTime,""String_Node_Str"" + outsideNextIterationTime,""String_Node_Str"" + localTime);
    }
    if (outsideNextIterationTime.compareTo(_outsideTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + _outsideTime + ""String_Node_Str""+ outsideNextIterationTime);
    }
    if (_outsideTime.compareTo(localTime) > 0) {
      throw new IllegalActionException(this,executiveDirector,""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (_outsideTime.compareTo(localTime) < 0) {
      if (_debugging) {
        _debug(getName() + ""String_Node_Str"" + localTime+ ""String_Node_Str""+ _knownGoodTime+ ""String_Node_Str""+ _outsideTime);
      }
      _rollback();
      _catchUp();
      if (_debugging) {
        _debug(""String_Node_Str"" + localTime);
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    _setIterationBeginTime(getModelTime());
    double aheadLength=outsideNextIterationTime.subtract(_outsideTime).getDoubleValue();
    if (_debugging) {
      _debug(getName(),""String_Node_Str"" + localTime,""String_Node_Str"" + _outsideTime,""String_Node_Str"" + outsideNextIterationTime + ""String_Node_Str""+ aheadLength);
    }
    if (aheadLength < timeResolution) {
      _setIterationEndTime(_outsideTime);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
 else     if (aheadLength < _runAheadLength) {
      _setIterationEndTime(outsideNextIterationTime);
    }
 else {
      _setIterationEndTime(_outsideTime.add(_runAheadLength));
    }
    if (_debugging) {
      _debug(getName(),""String_Node_Str"" + getIterationEndTime(),""String_Node_Str"");
    }
    return true;
  }
 else {
    return super.prefire();
  }
}"
75202,"/** 
 * Resolve the initial states with a normal ODE solver at a futhre time.  The future time is the current time puls the step size used by the  solver. Return immediately if any actor returns false in their  prefire() method. After this method is called, time advances to the  future time.
 * @exception IllegalActionException If one the actors throws itin its execution methods.
 */
protected void _resolveInitialStates() throws IllegalActionException {
  if (_debugging && _verbose) {
    _debug(""String_Node_Str"" + getModelTime(),""String_Node_Str"" + getCurrentStepSize());
  }
  ODESolver solver=getCurrentODESolver();
  if (_debugging && _verbose) {
    _debug(""String_Node_Str"" + solver.getName());
  }
  prefireClear();
  prefireDynamicActors();
  while (!_stopRequested) {
    while (!_stopRequested) {
      solver.resetRoundCount();
      solver._setConverged(false);
      while (!solver.isConverged() && solver.resolveStates()) {
        _setExecutionPhase(CTExecutionPhase.FIRING_DYNAMIC_ACTORS_PHASE);
        solver.fireDynamicActors();
        _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
        _setExecutionPhase(CTExecutionPhase.FIRING_STATE_TRANSITION_ACTORS_PHASE);
        solver.fireStateTransitionActors();
        _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
      }
      if (solver.resolveStates()) {
        if (_debugging && _verbose)         _debug(""String_Node_Str"");
        if (!_isStateAccurate()) {
          setCurrentStepSize(_refinedStepWRTState());
        }
 else {
          break;
        }
      }
 else {
        if (getCurrentStepSize() < 0.5 * getMinStepSize()) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + getModelTime());
        }
        setCurrentStepSize(0.5 * getCurrentStepSize());
      }
      setModelTime(getIterationBeginTime());
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ getCurrentStepSize());
      }
    }
    if (_stopRequested) {
      break;
    }
    produceOutput();
    fireEventGenerators();
    if (!_isOutputAccurate()) {
      setModelTime(getIterationBeginTime());
      setCurrentStepSize(_refinedStepWRTOutput());
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"" + ""String_Node_Str"" + getCurrentStepSize());
      }
    }
 else {
      break;
    }
    CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
    Iterator actors=schedule.get(CTSchedule.STATEFUL_ACTORS).actorIterator();
    while (actors.hasNext()) {
      CTStatefulActor actor=(CTStatefulActor)actors.next();
      if (_debugging) {
        _debug(""String_Node_Str"" + (Nameable)actor);
      }
      actor.goToMarkedState();
    }
  }
  updateContinuousStates();
  setSuggestedNextStepSize(_predictNextStepSize());
}","/** 
 * Resolve the initial states with a normal ODE solver at a futhre time.  The future time is the current time puls the step size used by the  solver. Return immediately if any actor returns false in their  prefire() method. After this method is called, time advances to the  future time.
 * @exception IllegalActionException If one the actors throws itin its execution methods.
 */
protected void _resolveInitialStates() throws IllegalActionException {
  if (_debugging && _verbose) {
    _debug(""String_Node_Str"" + getModelTime(),""String_Node_Str"" + getCurrentStepSize());
  }
  ODESolver solver=getCurrentODESolver();
  if (_debugging && _verbose) {
    _debug(""String_Node_Str"" + solver.getName());
  }
  prefireClear();
  prefireDynamicActors();
  while (!_stopRequested) {
    while (!_stopRequested) {
      CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
      Iterator actors=schedule.get(CTSchedule.STATEFUL_ACTORS).actorIterator();
      while (actors.hasNext()) {
        CTStatefulActor actor=(CTStatefulActor)actors.next();
        if (_debugging) {
          _debug(""String_Node_Str"" + (Nameable)actor);
        }
        actor.goToMarkedState();
      }
      solver._resetRoundCount();
      solver._setConverged(false);
      while (!solver._isConverged() && solver.resolveStates()) {
        _setExecutionPhase(CTExecutionPhase.FIRING_DYNAMIC_ACTORS_PHASE);
        solver.fireDynamicActors();
        _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
        _setExecutionPhase(CTExecutionPhase.FIRING_STATE_TRANSITION_ACTORS_PHASE);
        solver.fireStateTransitionActors();
        _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
      }
      if (solver.resolveStates()) {
        if (_debugging && _verbose)         _debug(""String_Node_Str"");
        if (!_isStateAccurate()) {
          setCurrentStepSize(_refinedStepWRTState());
        }
 else {
          break;
        }
      }
 else {
        if (getCurrentStepSize() < 0.5 * getMinStepSize()) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + getModelTime());
        }
        setCurrentStepSize(0.5 * getCurrentStepSize());
      }
      setModelTime(getIterationBeginTime());
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"" + getModelTime() + ""String_Node_Str""+ getCurrentStepSize());
      }
    }
    if (_stopRequested) {
      break;
    }
    produceOutput();
    fireEventGenerators();
    if (!_isOutputAccurate()) {
      setModelTime(getIterationBeginTime());
      setCurrentStepSize(_refinedStepWRTOutput());
      if (_debugging && _verbose) {
        _debug(""String_Node_Str"" + ""String_Node_Str"" + getCurrentStepSize());
      }
    }
 else {
      break;
    }
  }
  updateContinuousStates();
  setSuggestedNextStepSize(_predictNextStepSize());
}"
75203,"/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ContinuousClock(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  defaultValue=new Parameter(this,""String_Node_Str"");
  defaultValue.setExpression(""String_Node_Str"");
  ((Parameter)output.getAttribute(""String_Node_Str"")).setToken(new StringToken(""String_Node_Str""));
}","/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ContinuousClock(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  defaultValue=new Parameter(this,""String_Node_Str"");
  defaultValue.setExpression(""String_Node_Str"");
  ((Parameter)output.getAttribute(""String_Node_Str"")).setToken(new StringToken(""String_Node_Str""));
  ((Parameter)trigger.getAttribute(""String_Node_Str"")).setToken(new StringToken(""String_Node_Str""));
}"
75204,"/** 
 * Initialize the execution.
 * @exception IllegalActionException If thrown by the super class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _eventMissed=false;
  _eventNow=false;
  _lastTrigger=((DoubleToken)initialState.getToken()).doubleValue();
  _thisTrigger=0.0;
  _level=0.0;
}","/** 
 * Initialize the execution.
 * @exception IllegalActionException If thrown by the super class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _eventMissed=false;
  _eventNow=false;
  _lastTrigger=((DoubleToken)initialState.getToken()).doubleValue();
  _thisTrigger=0.0;
  _level=((DoubleToken)level.getToken()).doubleValue();
  ;
}"
75205,"/** 
 * Assuming the contents of the clipboard is MoML code, paste it into the current model by issuing a change request.
 */
public void paste(){
  Clipboard clipboard=java.awt.Toolkit.getDefaultToolkit().getSystemClipboard();
  Transferable transferable=clipboard.getContents(this);
  GraphModel model=_getGraphModel();
  if (transferable == null)   return;
  try {
    NamedObj container=(NamedObj)model.getRoot();
    StringBuffer moml=new StringBuffer();
    moml.append(""String_Node_Str"");
    moml.append((String)transferable.getTransferData(DataFlavor.stringFlavor));
    moml.append(""String_Node_Str"");
    MoMLChangeRequest change=new MoMLChangeRequest(this,container,moml.toString());
    change.setUndoable(true);
    container.requestChange(change);
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
  }
}","/** 
 * Assuming the contents of the clipboard is MoML code, paste it into the current model by issuing a change request.
 */
public void paste(){
  Clipboard clipboard=java.awt.Toolkit.getDefaultToolkit().getSystemClipboard();
  Transferable transferable=clipboard.getContents(this);
  GraphModel model=_getGraphModel();
  if (transferable == null)   return;
  try {
    NamedObj container=(NamedObj)model.getRoot();
    StringBuffer moml=new StringBuffer();
    moml.append(""String_Node_Str"");
    moml.append(offsetPastedMomlLocation((String)transferable.getTransferData(DataFlavor.stringFlavor),10,10));
    moml.append(""String_Node_Str"");
    MoMLChangeRequest change=new MoMLChangeRequest(this,container,moml.toString());
    change.setUndoable(true);
    container.requestChange(change);
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
  }
}"
75206,"/** 
 * Consume the inputs and produce the output ArrayToken.
 * @exception IllegalActionException If not enough tokens are available.
 */
public void fire() throws IllegalActionException {
  super.fire();
  arrayLength.update();
  int length=((IntToken)arrayLength.getToken()).intValue();
  Token[] valueArray=input.get(0,length);
  output.send(0,new ArrayToken(valueArray));
}","/** 
 * Consume the inputs and produce the output ArrayToken.
 * @exception IllegalActionException If not enough tokens are available.
 */
public void fire() throws IllegalActionException {
  super.fire();
  arrayLength.update();
  int length=((IntToken)arrayLength.getToken()).intValue();
  Token[] valueArray=new Token[length];
  System.arraycopy(input.get(0,length),0,valueArray,0,length);
  output.send(0,new ArrayToken(valueArray));
}"
75207,"/** 
 * Create a new port with the specified name in the container of this controller, which in turn creates a port in this controller and all the refinements. This method is write-synchronized on the workspace.
 * @param name The name to assign to the newly created port.
 * @return The new port.
 * @exception NameDuplicationException If the entity already has a portwith the specified name.
 */
public Port newPort(String name) throws NameDuplicationException {
  try {
    _workspace.getWriteAccess();
    if (_mirrorDisable || getContainer() == null) {
      RefinementPort port=new RefinementPort(this,name);
      port._mirrorDisable=false;
      ModalModel container=(ModalModel)getContainer();
      if (container != null) {
        String relationName=name + ""String_Node_Str"";
        Relation relation=container.getRelation(relationName);
        if (relation == null) {
          relation=container.newRelation(relationName);
          Port containerPort=container.getPort(name);
          containerPort.link(relation);
        }
        port.link(relation);
      }
      return port;
    }
 else {
      _mirrorDisable=true;
      ((ModalModel)getContainer()).newPort(name);
      return getPort(name);
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _mirrorDisable=false;
    _workspace.doneWriting();
  }
}","/** 
 * Create a new port with the specified name in the container of this controller, which in turn creates a port in this controller and all the refinements. This method is write-synchronized on the workspace.
 * @param name The name to assign to the newly created port.
 * @return The new port.
 * @exception NameDuplicationException If the entity already has a portwith the specified name.
 */
public Port newPort(String name) throws NameDuplicationException {
  try {
    _workspace.getWriteAccess();
    if (_mirrorDisable || getContainer() == null) {
      RefinementPort port=new RefinementPort(this,name);
      ModalModel container=(ModalModel)getContainer();
      if (container != null) {
        String relationName=name + ""String_Node_Str"";
        Relation relation=container.getRelation(relationName);
        if (relation == null) {
          relation=container.newRelation(relationName);
          Port containerPort=container.getPort(name);
          containerPort.link(relation);
        }
        port.link(relation);
      }
      return port;
    }
 else {
      _mirrorDisable=true;
      ((ModalModel)getContainer()).newPort(name);
      return getPort(name);
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _mirrorDisable=false;
    _workspace.doneWriting();
  }
}"
75208,"/** 
 * If the argument is true, make the port an output port. If the argument is false, make the port not an output port. This method overrides the base class to make the same change on the mirror ports in the controller and state refinments. This method invalidates the schedule and resolved types of the director of the container, if there is one. It is write-synchronized on the workspace, and increments the version of the workspace.
 * @param isOutput True to make the port an output.
 * @exception IllegalActionException If changing the port status isnot permitted.
 */
public void setOutput(boolean isOutput) throws IllegalActionException {
  try {
    _workspace.getWriteAccess();
    super.setOutput(isOutput);
    ModalModel container=(ModalModel)getContainer();
    Iterator entities=container.entityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      Port mirrorPort=entity.getPort(getName());
      if (mirrorPort instanceof RefinementPort) {
        RefinementPort castPort=(RefinementPort)mirrorPort;
        boolean disableStatus=castPort._mirrorDisable;
        try {
          castPort._mirrorDisable=true;
          castPort.setOutput(isOutput);
        }
  finally {
          castPort._mirrorDisable=disableStatus;
        }
        if (entity.getName().equals(""String_Node_Str"")) {
          boolean controlPortStatus=castPort._mirrorDisable;
          try {
            castPort._mirrorDisable=true;
            castPort.setInput(true);
          }
  finally {
            castPort._mirrorDisable=controlPortStatus;
          }
        }
      }
    }
  }
  finally {
    _workspace.doneWriting();
  }
}","/** 
 * If the argument is true, make the port an output port. If the argument is false, make the port not an output port. This method overrides the base class to make the same change on the mirror ports in the controller and state refinments. This method invalidates the schedule and resolved types of the director of the container, if there is one. It is write-synchronized on the workspace, and increments the version of the workspace.
 * @param isOutput True to make the port an output.
 * @exception IllegalActionException If changing the port status isnot permitted.
 */
public void setOutput(boolean isOutput) throws IllegalActionException {
  try {
    _workspace.getWriteAccess();
    super.setOutput(isOutput);
    ModalModel container=(ModalModel)getContainer();
    Iterator entities=container.entityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      Port mirrorPort=entity.getPort(getName());
      if (mirrorPort instanceof RefinementPort) {
        RefinementPort castPort=(RefinementPort)mirrorPort;
        boolean disableStatus=castPort._mirrorDisable;
        try {
          castPort._mirrorDisable=true;
          castPort.setOutput(isOutput);
        }
  finally {
          castPort._mirrorDisable=disableStatus;
        }
        if (entity.getName().equals(""String_Node_Str"")) {
          boolean controlPortStatus=castPort._mirrorDisable;
          try {
            castPort._mirrorDisable=true;
            castPort.setInput(true);
            if (!isInput()) {
              castPort._automaticallyInput=true;
            }
          }
  finally {
            castPort._mirrorDisable=controlPortStatus;
          }
        }
      }
    }
  }
  finally {
    _workspace.doneWriting();
  }
}"
75209,"/** 
 * Create a new port with the specified name in the container of this refinement, which in turn creates a port in this refinement all other refinements, and the controller. This method is write-synchronized on the workspace.
 * @param name The name to assign to the newly created port.
 * @return The new port.
 * @exception NameDuplicationException If the entity already has a portwith the specified name.
 */
public Port newPort(String name) throws NameDuplicationException {
  try {
    _workspace.getWriteAccess();
    if (_mirrorDisable || getContainer() == null) {
      RefinementPort port=new RefinementPort(this,name);
      port._mirrorDisable=false;
      ModalModel container=(ModalModel)getContainer();
      if (container != null) {
        String relationName=name + ""String_Node_Str"";
        Relation relation=container.getRelation(relationName);
        if (relation == null) {
          relation=container.newRelation(relationName);
          Port containerPort=container.getPort(name);
          containerPort.link(relation);
        }
        port.link(relation);
      }
      return port;
    }
 else {
      _mirrorDisable=true;
      ((ModalModel)getContainer()).newPort(name);
      return getPort(name);
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _mirrorDisable=false;
    _workspace.doneWriting();
  }
}","/** 
 * Create a new port with the specified name in the container of this refinement, which in turn creates a port in this refinement all other refinements, and the controller. This method is write-synchronized on the workspace.
 * @param name The name to assign to the newly created port.
 * @return The new port.
 * @exception NameDuplicationException If the entity already has a portwith the specified name.
 */
public Port newPort(String name) throws NameDuplicationException {
  try {
    _workspace.getWriteAccess();
    if (_mirrorDisable || getContainer() == null) {
      RefinementPort port=new RefinementPort(this,name);
      ModalModel container=(ModalModel)getContainer();
      if (container != null) {
        String relationName=name + ""String_Node_Str"";
        Relation relation=container.getRelation(relationName);
        if (relation == null) {
          relation=container.newRelation(relationName);
          Port containerPort=container.getPort(name);
          containerPort.link(relation);
        }
        port.link(relation);
      }
      return port;
    }
 else {
      _mirrorDisable=true;
      ((ModalModel)getContainer()).newPort(name);
      return getPort(name);
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _mirrorDisable=false;
    _workspace.doneWriting();
  }
}"
75210,"/** 
 * Predict the next step size. This method should be called if the current integration step is accurate to estimate the step size for the next step. The predicted step size is the minimum of all predictions from step size control actors, and it never exceeds 10 times this step size. If there are no step-size control actors at all, then return the current step size.  This results in leaving the step size at its initial value.
 * @return the prediced next step size.
 * @exception IllegalActionException If the scheduler throws it.
 */
protected double _predictNextStepSize() throws IllegalActionException {
  if (!isDiscretePhase()) {
    double predictedStep=10.0 * getCurrentStepSize();
    boolean foundOne=false;
    CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
    Iterator actors=schedule.get(CTSchedule.STATE_STEP_SIZE_CONTROL_ACTORS).actorIterator();
    while (actors.hasNext()) {
      CTStepSizeControlActor actor=(CTStepSizeControlActor)actors.next();
      predictedStep=Math.min(predictedStep,actor.predictedStepSize());
      foundOne=true;
    }
    actors=schedule.get(CTSchedule.OUTPUT_STEP_SIZE_CONTROL_ACTORS).actorIterator();
    while (actors.hasNext()) {
      CTStepSizeControlActor actor=(CTStepSizeControlActor)actors.next();
      predictedStep=Math.min(predictedStep,actor.predictedStepSize());
      foundOne=true;
    }
    if (foundOne) {
      return predictedStep;
    }
 else {
      return getCurrentStepSize();
    }
  }
 else {
    return getInitialStepSize();
  }
}","/** 
 * Predict the next step size. This method should be called if the current integration step is accurate to estimate the step size for the next step. The predicted step size is the minimum of all predictions from step size control actors, and it never exceeds 10 times this step size. If there are no step-size control actors at all, then return the current step size.  This results in leaving the step size at its initial value.
 * @return the prediced next step size.
 * @exception IllegalActionException If the scheduler throws it.
 */
protected double _predictNextStepSize() throws IllegalActionException {
  if (!isDiscretePhase()) {
    double predictedStep=10.0 * getCurrentStepSize();
    boolean foundOne=false;
    CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
    Iterator actors=schedule.get(CTSchedule.STATE_STEP_SIZE_CONTROL_ACTORS).actorIterator();
    while (actors.hasNext()) {
      CTStepSizeControlActor actor=(CTStepSizeControlActor)actors.next();
      predictedStep=Math.min(predictedStep,actor.predictedStepSize());
      foundOne=true;
    }
    actors=schedule.get(CTSchedule.OUTPUT_STEP_SIZE_CONTROL_ACTORS).actorIterator();
    while (actors.hasNext()) {
      CTStepSizeControlActor actor=(CTStepSizeControlActor)actors.next();
      predictedStep=Math.min(predictedStep,actor.predictedStepSize());
      foundOne=true;
    }
    if (foundOne) {
      return predictedStep;
    }
 else {
      predictedStep=getCurrentStepSize() * 1.5;
      if (predictedStep <= getMaxStepSize()) {
        return predictedStep;
      }
      return getCurrentStepSize();
    }
  }
 else {
    return getInitialStepSize();
  }
}"
75211,"/** 
 * Get the input ports on which the given output port is dependent.
 * @param outputPort The given output port.
 * @return A set of input ports on which the output port is dependent.The elements of the set are all instances of IOPort.
 */
public Set getInputPortsDependentOn(IOPort outputPort){
  _validate();
  if (!outputPort.getContainer().equals(_container)) {
    throw new InternalErrorException(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ ""String_Node_Str""+ _container.getName());
  }
  Collection backwardReachableInputs=_dependencyGraph.backwardReachableNodes(_dependencyGraph.node(outputPort));
  Set dependentInputPorts=new HashSet();
  Iterator inputs=backwardReachableInputs.iterator();
  while (inputs.hasNext()) {
    Node node=(Node)inputs.next();
    dependentInputPorts.add(node.getWeight());
  }
  return dependentInputPorts;
}","/** 
 * Get the input ports on which the given output port is dependent.
 * @param outputPort The given output port.
 * @return A set of input ports on which the output port is dependent.The elements of the set are all instances of IOPort.
 */
public Set getInputPortsDependentOn(IOPort outputPort){
  _validate();
  if (!outputPort.getContainer().equals(getContainer())) {
    throw new InternalErrorException(""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ ""String_Node_Str""+ getContainer().getName());
  }
  Collection backwardReachableInputs=_dependencyGraph.backwardReachableNodes(_dependencyGraph.node(outputPort));
  Set dependentInputPorts=new HashSet();
  Iterator inputs=backwardReachableInputs.iterator();
  while (inputs.hasNext()) {
    Node node=(Node)inputs.next();
    dependentInputPorts.add(node.getWeight());
  }
  return dependentInputPorts;
}"
75212,"/** 
 * Construct a FunctionDependency object for the given actor.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the name has a period in it, orthe attribute is not compatible with the specified container.
 * @exception NameDuplicationException If the container already containsan entity with the specified name.
 */
public FunctionDependency(Entity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setPersistent(false);
  _container=container;
}","/** 
 * Construct a FunctionDependency object for the given actor.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the name has a period in it, orthe attribute is not compatible with the specified container.
 * @exception NameDuplicationException If the container already containsan entity with the specified name.
 */
public FunctionDependency(Entity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setPersistent(false);
}"
75213,"/** 
 * Construct a complete dependency graph with all the ports of the associated actor as nodes and edges going from  each input port node to each output port node. This is provided as a convenience for subclasses that override _constructDependencyGraph() to build a starting point.
 * @return A complete dependency graph. 
 */
protected final DirectedGraph _constructConnectedDependencyGraph(){
  DirectedGraph dependencyGraph=_constructDisconnectedDependencyGraph();
  Iterator inputs=((Actor)_container).inputPortList().listIterator();
  while (inputs.hasNext()) {
    IOPort inputPort=(IOPort)inputs.next();
    Iterator outputs=((Actor)_container).outputPortList().listIterator();
    while (outputs.hasNext()) {
      dependencyGraph.addEdge(inputPort,outputs.next());
    }
  }
  return dependencyGraph;
}","/** 
 * Construct a complete dependency graph with all the ports of the associated actor as nodes and edges going from  each input port node to each output port node. This is provided as a convenience for subclasses that override _constructDependencyGraph() to build a starting point.
 * @return A complete dependency graph. 
 */
protected final DirectedGraph _constructConnectedDependencyGraph(){
  DirectedGraph dependencyGraph=_constructDisconnectedDependencyGraph();
  Iterator inputs=((Actor)getContainer()).inputPortList().listIterator();
  while (inputs.hasNext()) {
    IOPort inputPort=(IOPort)inputs.next();
    Iterator outputs=((Actor)getContainer()).outputPortList().listIterator();
    while (outputs.hasNext()) {
      dependencyGraph.addEdge(inputPort,outputs.next());
    }
  }
  return dependencyGraph;
}"
75214,"/** 
 * Get the output ports that depend on the given input port.
 * @param inputPort The given input port.
 * @return A set of output ports that depend on the input port.The elements of the set are all instances of IOPort.
 */
public Set getDependentOutputPorts(IOPort inputPort){
  _validate();
  if (!inputPort.getContainer().equals(_container)) {
    throw new InternalErrorException(""String_Node_Str"" + inputPort.getName() + ""String_Node_Str""+ ""String_Node_Str""+ _container.getName());
  }
  Collection reachableOutputs=_dependencyGraph.reachableNodes(_dependencyGraph.node(inputPort));
  Set dependentOutputPorts=new HashSet();
  Iterator outputs=reachableOutputs.iterator();
  while (outputs.hasNext()) {
    Node node=(Node)outputs.next();
    dependentOutputPorts.add(node.getWeight());
  }
  return dependentOutputPorts;
}","/** 
 * Get the output ports that depend on the given input port.
 * @param inputPort The given input port.
 * @return A set of output ports that depend on the input port.The elements of the set are all instances of IOPort.
 */
public Set getDependentOutputPorts(IOPort inputPort){
  _validate();
  if (!inputPort.getContainer().equals(getContainer())) {
    throw new InternalErrorException(""String_Node_Str"" + inputPort.getName() + ""String_Node_Str""+ ""String_Node_Str""+ getContainer().getName());
  }
  Collection reachableOutputs=_dependencyGraph.reachableNodes(_dependencyGraph.node(inputPort));
  Set dependentOutputPorts=new HashSet();
  Iterator outputs=reachableOutputs.iterator();
  while (outputs.hasNext()) {
    Node node=(Node)outputs.next();
    dependentOutputPorts.add(node.getWeight());
  }
  return dependentOutputPorts;
}"
75215,"/** 
 * Update the FunctionDependency object. If it has not been previously constructed, then construct it. If the topology has been changed since it was last constructed (as indicated by the getVersion() method of the workspace of the associated actor), then reconstruct it. Otherwise, do nothing.
 * @see ptolemy.kernel.util.Workspace#getVersion()
 */
protected final void _validate(){
  Workspace workspace=_container.workspace();
  long workspaceVersion=workspace.getVersion();
  if (_functionDependencyVersion != workspaceVersion) {
    try {
      workspace.getReadAccess();
      _constructDependencyGraph();
      _functionDependencyVersion=workspaceVersion;
    }
  finally {
      workspace.doneReading();
    }
  }
}","/** 
 * Update the FunctionDependency object. If it has not been previously constructed, then construct it. If the topology has been changed since it was last constructed (as indicated by the getVersion() method of the workspace of the associated actor), then reconstruct it. Otherwise, do nothing.
 * @see ptolemy.kernel.util.Workspace#getVersion()
 */
protected final void _validate(){
  Workspace workspace=getContainer().workspace();
  long workspaceVersion=workspace.getVersion();
  if (_functionDependencyVersion != workspaceVersion) {
    try {
      workspace.getReadAccess();
      _constructDependencyGraph();
      _functionDependencyVersion=workspaceVersion;
    }
  finally {
      workspace.doneReading();
    }
  }
}"
75216,"/** 
 * Construct and return a dependency graph containing all the ports of the associated actor as nodes and no edges. This is provided as a convenience for subclasses that override _constructDependencyGraph() to build a starting point.
 * @return A dependency graph with nodes for ports but no edges.
 */
protected final DirectedGraph _constructDisconnectedDependencyGraph(){
  DirectedGraph dependencyGraph=new DirectedGraph();
  Iterator inputs=((Actor)_container).inputPortList().listIterator();
  while (inputs.hasNext()) {
    IOPort input=(IOPort)inputs.next();
    dependencyGraph.addNodeWeight(input);
  }
  Iterator outputs=((Actor)_container).outputPortList().listIterator();
  while (outputs.hasNext()) {
    IOPort output=(IOPort)outputs.next();
    dependencyGraph.addNodeWeight(output);
  }
  return dependencyGraph;
}","/** 
 * Construct and return a dependency graph containing all the ports of the associated actor as nodes and no edges. This is provided as a convenience for subclasses that override _constructDependencyGraph() to build a starting point.
 * @return A dependency graph with nodes for ports but no edges.
 */
protected final DirectedGraph _constructDisconnectedDependencyGraph(){
  DirectedGraph dependencyGraph=new DirectedGraph();
  Iterator inputs=((Actor)getContainer()).inputPortList().listIterator();
  while (inputs.hasNext()) {
    IOPort input=(IOPort)inputs.next();
    dependencyGraph.addNodeWeight(input);
  }
  Iterator outputs=((Actor)getContainer()).outputPortList().listIterator();
  while (outputs.hasNext()) {
    IOPort output=(IOPort)outputs.next();
    dependencyGraph.addNodeWeight(output);
  }
  return dependencyGraph;
}"
75217,"/** 
 * Generate Giotto code for the given model.
 * @return The Giotto code.
 */
public void compileTypedCompositeActor(TypedCompositeActor compositeActor) throws IllegalActionException {
  try {
    List opaqueCompositeActors=_containedOpaqueCompositeActors(compositeActor);
    Iterator opaqueCompositeActorsIterator=opaqueCompositeActors.iterator();
    while (opaqueCompositeActorsIterator.hasNext()) {
      TypedCompositeActor containedCompositeActor=(TypedCompositeActor)opaqueCompositeActorsIterator.next();
      compileTypedCompositeActor(containedCompositeActor);
    }
    CompositeEntity container=(CompositeEntity)compositeActor.getContainer();
    if (container == null) {
      return;
    }
    FunctionDependencyOfCompositeActor functionDependency=((FunctionDependencyOfCompositeActor)compositeActor.getFunctionDependency());
    DirectedGraph detailedDependencyGraph=functionDependency.getDetailedDependencyGraph();
    List listOfSubgraphs=detailedDependencyGraph.subgraphs();
    Object[] arrayOfSubgraphs=listOfSubgraphs.toArray();
    Collection[] inputPortsInSubgraphs=new Collection[listOfSubgraphs.size()];
    if (listOfSubgraphs.size() == 1) {
      return;
    }
    Iterator inputPorts=compositeActor.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      for (int i=0; i < arrayOfSubgraphs.length; i++) {
        DirectedGraph subgraph=(DirectedGraph)arrayOfSubgraphs[i];
        if (subgraph.containsNodeWeight(inputPort)) {
          if (inputPortsInSubgraphs[i] == null) {
            inputPortsInSubgraphs[i]=new LinkedList();
          }
          inputPortsInSubgraphs[i].add(inputPort);
          break;
        }
      }
    }
    for (int i=0; i < inputPortsInSubgraphs.length; i++) {
      Collection inputs=inputPortsInSubgraphs[i];
      if (inputs == null) {
        continue;
      }
      TypedCompositeActor clone=(TypedCompositeActor)compositeActor.clone();
      clone.setName(""String_Node_Str"" + compositeActor.getName() + ""String_Node_Str""+ i);
      clone.setContainer(container);
      Collection inputNodes=detailedDependencyGraph.nodes(inputs);
      DirectedGraph subgraph=new DirectedGraph();
      detailedDependencyGraph.connectedSubGraph(inputNodes,subgraph);
      List entitiesOfClone=clone.deepEntityList();
      List entitiesOfOrigin=compositeActor.deepEntityList();
      for (int j=entitiesOfClone.size() - 1; j >= 0; j--) {
        ComponentEntity cloneEntity=(ComponentEntity)entitiesOfClone.get(j);
        ComponentEntity originalEntity=(ComponentEntity)entitiesOfOrigin.get(j);
        Iterator portsOfOriginalEntity=originalEntity.portList().listIterator();
        boolean originalEntityInSubgraph=false;
        while (portsOfOriginalEntity.hasNext() && !originalEntityInSubgraph) {
          IOPort portOfOriginalEntity=(IOPort)portsOfOriginalEntity.next();
          if (subgraph.containsNodeWeight(portOfOriginalEntity)) {
            originalEntityInSubgraph=true;
          }
        }
        if (!originalEntityInSubgraph) {
          Iterator relations=cloneEntity.linkedRelationList().listIterator();
          while (relations.hasNext()) {
            IORelation relation=(IORelation)relations.next();
            relation.setContainer(null);
          }
          cloneEntity.setContainer(null);
        }
      }
      List portsOfClone=clone.portList();
      List portsOfOrigin=compositeActor.portList();
      for (int j=portsOfClone.size() - 1; j >= 0; j--) {
        IOPort portOfClone=(IOPort)portsOfClone.get(j);
        IOPort portOfOrigin=(IOPort)portsOfOrigin.get(j);
        if (!subgraph.containsNodeWeight(portOfOrigin)) {
          portOfClone.setContainer(null);
        }
 else {
          Iterator relations=portOfOrigin.linkedRelationList().iterator();
          while (relations.hasNext()) {
            IORelation relation=(IORelation)relations.next();
            portOfClone.link(relation);
          }
        }
      }
    }
    compositeActor.setContainer(null);
  }
 catch (  KernelException ex) {
    System.out.println(ex.getMessage());
    throw new IllegalActionException(ex.getMessage());
  }
catch (  CloneNotSupportedException e) {
    e.printStackTrace();
  }
}","/** 
 * Generate Giotto code for the given model.
 * @return The Giotto code.
 */
public void compileTypedCompositeActor(TypedCompositeActor compositeActor) throws IllegalActionException {
  try {
    List opaqueCompositeActors=_containedOpaqueCompositeActors(compositeActor);
    Iterator opaqueCompositeActorsIterator=opaqueCompositeActors.iterator();
    while (opaqueCompositeActorsIterator.hasNext()) {
      TypedCompositeActor containedCompositeActor=(TypedCompositeActor)opaqueCompositeActorsIterator.next();
      compileTypedCompositeActor(containedCompositeActor);
    }
    CompositeEntity container=(CompositeEntity)compositeActor.getContainer();
    if (container == null) {
      return;
    }
    FunctionDependencyOfCompositeActor functionDependency=((FunctionDependencyOfCompositeActor)compositeActor.getFunctionDependency());
    DirectedGraph detailedDependencyGraph=functionDependency.getDetailedDependencyGraph();
    List listOfSubgraphs=detailedDependencyGraph.subgraphs();
    Object[] arrayOfSubgraphs=listOfSubgraphs.toArray();
    Collection[] inputPortsInSubgraphs=new Collection[listOfSubgraphs.size()];
    if (listOfSubgraphs.size() == 1) {
      return;
    }
    Iterator inputPorts=compositeActor.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      for (int i=0; i < arrayOfSubgraphs.length; i++) {
        DirectedGraph subgraph=(DirectedGraph)arrayOfSubgraphs[i];
        if (subgraph.containsNodeWeight(inputPort)) {
          if (inputPortsInSubgraphs[i] == null) {
            inputPortsInSubgraphs[i]=new LinkedList();
          }
          inputPortsInSubgraphs[i].add(inputPort);
          break;
        }
      }
    }
    for (int i=0; i < inputPortsInSubgraphs.length; i++) {
      Collection inputs=inputPortsInSubgraphs[i];
      if (inputs == null) {
        continue;
      }
      TypedCompositeActor clone=(TypedCompositeActor)compositeActor.clone();
      clone.setName(""String_Node_Str"" + compositeActor.getName() + ""String_Node_Str""+ i);
      clone.setContainer(container);
      Collection inputNodes=detailedDependencyGraph.nodes(inputs);
      DirectedGraph subgraph=detailedDependencyGraph.connectedSubGraph(inputNodes);
      List entitiesOfClone=clone.deepEntityList();
      List entitiesOfOrigin=compositeActor.deepEntityList();
      for (int j=entitiesOfClone.size() - 1; j >= 0; j--) {
        ComponentEntity cloneEntity=(ComponentEntity)entitiesOfClone.get(j);
        ComponentEntity originalEntity=(ComponentEntity)entitiesOfOrigin.get(j);
        Iterator portsOfOriginalEntity=originalEntity.portList().listIterator();
        boolean originalEntityInSubgraph=false;
        while (portsOfOriginalEntity.hasNext() && !originalEntityInSubgraph) {
          IOPort portOfOriginalEntity=(IOPort)portsOfOriginalEntity.next();
          if (subgraph.containsNodeWeight(portOfOriginalEntity)) {
            originalEntityInSubgraph=true;
          }
        }
        if (!originalEntityInSubgraph) {
          Iterator relations=cloneEntity.linkedRelationList().listIterator();
          while (relations.hasNext()) {
            IORelation relation=(IORelation)relations.next();
            relation.setContainer(null);
          }
          cloneEntity.setContainer(null);
        }
      }
      List portsOfClone=clone.portList();
      List portsOfOrigin=compositeActor.portList();
      for (int j=portsOfClone.size() - 1; j >= 0; j--) {
        IOPort portOfClone=(IOPort)portsOfClone.get(j);
        IOPort portOfOrigin=(IOPort)portsOfOrigin.get(j);
        if (!subgraph.containsNodeWeight(portOfOrigin)) {
          portOfClone.setContainer(null);
        }
 else {
          Iterator relations=portOfOrigin.linkedRelationList().iterator();
          while (relations.hasNext()) {
            IORelation relation=(IORelation)relations.next();
            portOfClone.link(relation);
          }
        }
      }
    }
    compositeActor.setContainer(null);
    functionDependency=(FunctionDependencyOfCompositeActor)((CompositeActor)container).getFunctionDependency();
    functionDependency.getDetailedDependencyGraph();
  }
 catch (  KernelException ex) {
    System.out.println(ex.getMessage());
    throw new IllegalActionException(ex.getMessage());
  }
catch (  CloneNotSupportedException e) {
    e.printStackTrace();
  }
}"
75218,"/** 
 * Given a collection of nodes, get the connected subgraph.
 * @return A 
 * @param nodes
 * @param graph
 */
public void connectedSubGraph(Collection nodes,DirectedGraph graph){
  Collection dummyCollection=new LinkedList();
  Iterator nodesIterator=nodes.iterator();
  while (nodesIterator.hasNext()) {
    Node node=(Node)nodesIterator.next();
    _connectedSubGraph(node,graph,dummyCollection);
  }
}","/** 
 * Given a collection of nodes, get the connected subgraph.
 * @return A 
 * @param nodes
 * @param graph
 */
public DirectedGraph connectedSubGraph(Collection nodes){
  DirectedGraph graph=new DirectedGraph();
  Collection dummyCollection=new LinkedList();
  Iterator nodesIterator=nodes.iterator();
  while (nodesIterator.hasNext()) {
    Node node=(Node)nodesIterator.next();
    _connectedSubGraph(node,graph,dummyCollection);
  }
  return graph;
}"
75219,"/** 
 * Close the file. If it has not been opened using openForReading() or openForWriting(), then do nothing.  Also, if the file is System.in or System.out, then do not close it (it does not make sense to close these files).
 * @exception IllegalActionException If the file or URL cannot beclosed.
 */
public void close() throws IllegalActionException {
  if (_reader != null) {
    if (_reader != _stdIn) {
      try {
        _reader.close();
      }
 catch (      IOException ex) {
      }
    }
  }
  if (_writer != null) {
    try {
      _writer.flush();
      if (_writer != _stdOut) {
        _writer.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}","/** 
 * Close the file. If it has not been opened using openForReading() or openForWriting(), then do nothing.  Also, if the file is System.in or System.out, then do not close it (it does not make sense to close these files).
 * @exception IllegalActionException If the file or URL cannot beclosed.
 */
public void close() throws IllegalActionException {
  if (_reader != null) {
    if (_reader != FileUtilities.STD_IN) {
      try {
        _reader.close();
      }
 catch (      IOException ex) {
      }
    }
  }
  if (_writer != null) {
    try {
      _writer.flush();
      if (_writer != FileUtilities.STD_OUT) {
        _writer.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}"
75220,"/** 
 * Close the file. If it has not been opened using openForReading() or openForWriting(), then do nothing.  Also, if the file is System.in or System.out, then do not close it (it does not make sense to close these files).
 * @exception IllegalActionException If the file or URL cannot beclosed.
 */
public void close() throws IllegalActionException {
  if (_reader != null) {
    if (_reader != _stdIn) {
      try {
        _reader.close();
      }
 catch (      IOException ex) {
      }
    }
  }
  if (_writer != null) {
    try {
      _writer.flush();
      if (_writer != _stdOut) {
        _writer.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}","/** 
 * Close the file. If it has not been opened using openForReading() or openForWriting(), then do nothing.  Also, if the file is System.in or System.out, then do not close it (it does not make sense to close these files).
 * @exception IllegalActionException If the file or URL cannot beclosed.
 */
public void close() throws IllegalActionException {
  if (_reader != null) {
    if (_reader != FileUtilities.STD_IN) {
      try {
        _reader.close();
      }
 catch (      IOException ex) {
      }
    }
  }
  if (_writer != null) {
    try {
      _writer.flush();
      if (_writer != FileUtilities.STD_OUT) {
        _writer.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}"
75221,"/** 
 * Return a list of disconnected subgraphs of this subgraph. 
 */
public LinkedList subgraphs(){
  LinkedList subgraphList=new LinkedList();
  LinkedList remainingNodes=(LinkedList)nodes();
  while (!remainingNodes.isEmpty()) {
    DirectedGraph subgraph=new DirectedGraph();
    Node node=(Node)remainingNodes.getFirst();
    _connectedSubGraph(node,subgraph,remainingNodes);
    subgraphList.add(subgraph);
  }
  return subgraphList;
}","/** 
 * Return a list of disconnected subgraphs of this subgraph. 
 */
public LinkedList subgraphs(){
  LinkedList subgraphList=new LinkedList();
  LinkedList remainingNodes=new LinkedList(nodes());
  while (!remainingNodes.isEmpty()) {
    DirectedGraph subgraph=new DirectedGraph();
    Node node=(Node)remainingNodes.remove(0);
    _connectedSubGraph(node,subgraph,remainingNodes);
    subgraphList.add(subgraph);
  }
  return subgraphList;
}"
75222,"/** 
 * Given a node, get all the edges and nodes that are connected to it directly and/or indirectly. Add them in the given graph. Remove the nodes from the remainning nodes. FIXME: Hidden edges not considered.
 * @param node The given node.
 * @param graph The given graph.
 * @param remainingNodes Set of nodes that haven't been reached.
 */
protected void _connectedSubGraph(Node node,DirectedGraph graph,Collection remainingNodes){
  if (!graph.containsNode(node)) {
    graph.addNode(node);
    remainingNodes.remove(node);
  }
  Iterator inputEdges=inputEdges(node).iterator();
  while (inputEdges.hasNext()) {
    Edge inputEdge=(Edge)inputEdges.next();
    if (!graph.containsEdge(inputEdge)) {
      Node sourceNode=inputEdge.source();
      if (!graph.containsNode(sourceNode)) {
        graph.addNode(sourceNode);
        _connectedSubGraph(sourceNode,graph,remainingNodes);
        remainingNodes.remove(sourceNode);
      }
      if (!graph.containsEdge(inputEdge)) {
        graph.addEdge(sourceNode,node);
      }
    }
  }
  Iterator outputEdges=outputEdges(node).iterator();
  while (outputEdges.hasNext()) {
    Edge outputEdge=(Edge)outputEdges.next();
    if (!graph.containsEdge(outputEdge)) {
      Node sinkNode=outputEdge.source();
      if (!graph.containsNode(sinkNode)) {
        graph.addNode(sinkNode);
        _connectedSubGraph(sinkNode,graph,remainingNodes);
        remainingNodes.remove(sinkNode);
      }
      if (!graph.containsEdge(outputEdge)) {
        graph.addEdge(node,sinkNode);
      }
    }
  }
}","/** 
 * Given a node, get all the edges and nodes that are connected to it directly and/or indirectly. Add them in the given graph. Remove the nodes from the remainning nodes. FIXME: Hidden edges not considered.
 * @param node The given node.
 * @param graph The given graph.
 * @param remainingNodes Set of nodes that haven't been reached.
 */
protected void _connectedSubGraph(Node node,DirectedGraph graph,Collection remainingNodes){
  if (!graph.containsNode(node)) {
    graph.addNode(node);
    remainingNodes.remove(node);
  }
  Iterator inputEdges=inputEdges(node).iterator();
  while (inputEdges.hasNext()) {
    Edge inputEdge=(Edge)inputEdges.next();
    if (!graph.containsEdge(inputEdge)) {
      Node sourceNode=inputEdge.source();
      if (!graph.containsNode(sourceNode)) {
        graph.addNode(sourceNode);
        _connectedSubGraph(sourceNode,graph,remainingNodes);
        remainingNodes.remove(sourceNode);
      }
      if (!graph.containsEdge(inputEdge)) {
        graph.addEdge(sourceNode,node);
      }
    }
  }
  Iterator outputEdges=outputEdges(node).iterator();
  while (outputEdges.hasNext()) {
    Edge outputEdge=(Edge)outputEdges.next();
    if (!graph.containsEdge(outputEdge)) {
      Node sinkNode=outputEdge.sink();
      if (!graph.containsNode(sinkNode)) {
        graph.addNode(sinkNode);
        _connectedSubGraph(sinkNode,graph,remainingNodes);
        remainingNodes.remove(sinkNode);
      }
      if (!graph.containsEdge(outputEdge)) {
        graph.addEdge(node,sinkNode);
      }
    }
  }
}"
75223,"/** 
 * If there are delayed inputs that are not processed and the timer  is not busy. Begin processing the earliest input and schedule  a future firing to produce it.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedTokens.remove(currentTime);
  }
  if (_delayedInputTokensList.size() != 0 && _delayedTokens.isEmpty()) {
    DoubleToken delayToken=(DoubleToken)_delayedInputTokensList.removeFirst();
    double delay=delayToken.doubleValue();
    _nextTimeFree=currentTime.add(delay);
    _delayedTokens.put(_nextTimeFree,delayToken);
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}","/** 
 * If there are delayed inputs that are not processed and the timer  is not busy. Begin processing the earliest input and schedule  a future firing to produce it.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedOutputTokens.take();
  }
  if (_delayedInputTokensList.size() != 0 && _delayedOutputTokens.isEmpty()) {
    DoubleToken delayToken=(DoubleToken)_delayedInputTokensList.removeFirst();
    double delay=delayToken.doubleValue();
    _nextTimeFree=currentTime.add(delay);
    _delayedOutputTokens.put(new TimedEvent(_nextTimeFree,delayToken));
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}"
75224,"/** 
 * Read one token from the input. If the value of the input is bigger than 0.0, save the input to be processed in the postfire method. Otherwise,  check whether there is any output scheduled to be produced at the  current time. If there is one, send out that output and save the  current input for future processing in the postfire method. If there  is no output to produce, the timer is not processing other inputs, and the input value is 0.0, send an output immediately and reset the  current input to null, indicating no further processing of the current  input is necessary.
 * @exception IllegalActionException If there is no director, or can notsend or get tokens from ports.
 */
public void fire() throws IllegalActionException {
  _delay=-1.0;
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
    _delayedInputTokensList.addLast(_currentInput);
    double delayValue=((DoubleToken)_currentInput).doubleValue();
    if (delayValue < 0) {
      throw new IllegalActionException(""String_Node_Str"");
    }
 else {
      _delay=delayValue;
    }
  }
 else {
    _currentInput=null;
  }
  Time currentTime=getDirector().getModelTime();
  _currentOutput=null;
  if (_delayedTokens.size() > 0) {
    _currentOutput=(Token)_delayedTokens.get(currentTime);
    if (_currentOutput != null) {
      output.send(0,value.getToken());
      return;
    }
 else {
    }
  }
 else   if (_delay == 0.0 && _delayedInputTokensList.size() > 0) {
    _delayedInputTokensList.removeFirst();
    output.send(0,value.getToken());
    _currentInput=null;
  }
}","/** 
 * Read one token from the input. If the value of the input is bigger than 0.0, save the input to be processed in the postfire method. Otherwise,  check whether there is any output scheduled to be produced at the  current time. If there is one, send out that output and save the  current input for future processing in the postfire method. If there  is no output to produce, the timer is not processing other inputs, and the input value is 0.0, send an output immediately and reset the  current input to null, indicating no further processing of the current  input is necessary.
 * @exception IllegalActionException If there is no director, or can notsend or get tokens from ports.
 */
public void fire() throws IllegalActionException {
  _delay=-1.0;
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
    _delayedInputTokensList.addLast(_currentInput);
    double delayValue=((DoubleToken)_currentInput).doubleValue();
    if (delayValue < 0) {
      throw new IllegalActionException(""String_Node_Str"");
    }
 else {
      _delay=delayValue;
    }
  }
 else {
    _currentInput=null;
  }
  Time currentTime=getDirector().getModelTime();
  _currentOutput=null;
  if (_delayedOutputTokens.size() > 0) {
    if (currentTime.compareTo(_nextTimeFree) == 0) {
      TimedEvent earliestEvent=(TimedEvent)_delayedOutputTokens.get();
      Time eventTime=earliestEvent.timeStamp;
      if (!eventTime.equals(currentTime)) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      _currentOutput=(Token)earliestEvent.contents;
      output.send(0,_currentOutput);
      return;
    }
 else {
    }
  }
 else   if (_delay == 0.0 && _delayedInputTokensList.size() > 0) {
    _delayedInputTokensList.removeFirst();
    output.send(0,value.getToken());
    _currentInput=null;
  }
}"
75225,"/** 
 * If there are delayed input events that are not processed and the server is ready, begin process the earliest input event and schedule  future firings to produce them.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedTokens.remove(currentTime);
  }
  if (_delayedInputTokensList.size() != 0 && _delayedTokens.isEmpty()) {
    _nextTimeFree=currentTime.add(_delay);
    _delayedTokens.put(_nextTimeFree,_delayedInputTokensList.removeFirst());
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}","/** 
 * If there are delayed input events that are not processed and the server is ready, begin process the earliest input event and schedule  future firings to produce them.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 * @return True if the stop is not requested.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedOutputTokens.take();
  }
  if (_delayedInputTokensList.size() != 0 && _delayedOutputTokens.isEmpty()) {
    _nextTimeFree=currentTime.add(_delay);
    _delayedOutputTokens.put(new TimedEvent(_nextTimeFree,_delayedInputTokensList.removeFirst()));
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}"
75226,"/** 
 * Read the available input token. If the server is not busy,  begin servicing it. If the delay is 0, output is immediately availabe. Otherwise, the output available time is delayed by the amount of the  <i>newServiceTime></i> parameter. If the server is busy, check whether the current service finishes. If so, generate output. Otherwise, do nothing. 
 * @exception IllegalActionException If can not update the serviceTimeparameter, read inputs, or send outputs.
 */
public void fire() throws IllegalActionException {
  delay.update();
  _delay=((DoubleToken)delay.getToken()).doubleValue();
  Time currentTime=getDirector().getModelTime();
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
    _delayedInputTokensList.addLast(_currentInput);
  }
 else {
    _currentInput=null;
  }
  if (_delayedTokens.size() > 0) {
    if (currentTime.compareTo(_nextTimeFree) == 0) {
      _currentOutput=(Token)_delayedTokens.get(currentTime);
      if (_currentOutput == null) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      output.send(0,_currentOutput);
    }
 else {
    }
  }
 else   if (_delay == 0 && _delayedInputTokensList.size() > 0) {
    output.send(0,(Token)_delayedInputTokensList.removeFirst());
  }
}","/** 
 * Read the available input token. If the server is not busy,  begin servicing it. If the delay is 0, output is immediately availabe. Otherwise, the output available time is delayed by the amount of the  <i>newServiceTime></i> parameter. If the server is busy, check whether the current service finishes. If so, generate output. Otherwise, do nothing. 
 * @exception IllegalActionException If can not update the serviceTimeparameter, read inputs, or send outputs.
 */
public void fire() throws IllegalActionException {
  delay.update();
  _delay=((DoubleToken)delay.getToken()).doubleValue();
  Time currentTime=getDirector().getModelTime();
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
    _delayedInputTokensList.addLast(_currentInput);
  }
 else {
    _currentInput=null;
  }
  _currentOutput=null;
  if (_delayedOutputTokens.size() > 0) {
    if (currentTime.compareTo(_nextTimeFree) == 0) {
      TimedEvent earliestEvent=(TimedEvent)_delayedOutputTokens.get();
      Time eventTime=earliestEvent.timeStamp;
      if (!eventTime.equals(currentTime)) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      _currentOutput=(Token)earliestEvent.contents;
      output.send(0,_currentOutput);
    }
 else {
    }
  }
 else   if (_delay == 0 && _delayedInputTokensList.size() > 0) {
    output.send(0,(Token)_delayedInputTokensList.removeFirst());
  }
}"
75227,"/** 
 * If the current input is scheduled to produce in a future time, schedule a refiring of this actor at that time.
 * @exception IllegalActionException If scheduling to refire cannotbe performed or the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time delayToTime=currentTime.add(_delay);
  if (_delayedTokens.size() > 0 && _currentOutput != null) {
    _delayedTokens.remove(currentTime);
  }
  if (_currentInput != null) {
    _delayedTokens.put(delayToTime,_currentInput);
    getDirector().fireAt(this,delayToTime);
  }
  return super.postfire();
}","/** 
 * If the current input is scheduled to produce in a future time, schedule a refiring of this actor at that time.
 * @exception IllegalActionException If scheduling to refire cannotbe performed or the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time delayToTime=currentTime.add(_delay);
  if (_delayedOutputTokens.size() > 0) {
    if (_currentOutput != null) {
      _delayedOutputTokens.take();
    }
  }
  if (_delayedOutputTokens.size() > 0) {
    TimedEvent earliestEvent=(TimedEvent)_delayedOutputTokens.get();
    Time eventTime=earliestEvent.timeStamp;
    if (eventTime.equals(currentTime)) {
      getDirector().fireAt(this,currentTime);
    }
  }
  if (_currentInput != null) {
    _delayedOutputTokens.put(new TimedEvent(delayToTime,_currentInput));
    getDirector().fireAt(this,delayToTime);
  }
  return super.postfire();
}"
75228,"/** 
 * Read one token from the input and send one output that is scheduled to produce at the current time. 
 * @exception IllegalActionException If there is no director, or theinput can not be read, or the output can not be sent.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
  }
 else {
    _currentInput=null;
  }
  Time currentTime=getDirector().getModelTime();
  _currentOutput=null;
  if (_delayedTokens.size() > 0) {
    _currentOutput=(Token)_delayedTokens.get(currentTime);
    if (_currentOutput != null) {
      output.send(0,_currentOutput);
      return;
    }
 else {
    }
  }
  if (_delay == 0 && _currentInput != null) {
    output.send(0,_currentInput);
    _currentInput=null;
  }
}","/** 
 * Read one token from the input and send one output that is scheduled to produce at the current time. 
 * @exception IllegalActionException If there is no director, or theinput can not be read, or the output can not be sent.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
  }
 else {
    _currentInput=null;
  }
  Time currentTime=getDirector().getModelTime();
  _currentOutput=null;
  if (_delayedOutputTokens.size() > 0) {
    TimedEvent earliestEvent=(TimedEvent)_delayedOutputTokens.get();
    Time eventTime=earliestEvent.timeStamp;
    if (eventTime.equals(currentTime)) {
      _currentOutput=(Token)earliestEvent.contents;
      output.send(0,_currentOutput);
      return;
    }
 else {
    }
  }
  if (_delay == 0 && _currentInput != null) {
    output.send(0,_currentInput);
    _currentInput=null;
  }
}"
75229,"/** 
 * Initialize the states of this actor.
 * @exception IllegalActionException If a derived class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _currentInput=null;
  _currentOutput=null;
  _delayedTokens=new HashMap();
}","/** 
 * Initialize the states of this actor.
 * @exception IllegalActionException If a derived class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _currentInput=null;
  _currentOutput=null;
  _delayedOutputTokens=new CalendarQueue(new TimedEvent.TimeComparator(this.getDirector()));
}"
75230,"/** 
 * Update the internal states of this actor. If the current input  is not processed in the fire method, schedule a refiring of this actor to produce an output in a future time,  (the current model time + delay specified by the input value).  
 * @exception IllegalActionException If scheduling to refire cannotbe performed or the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time delayToTime=currentTime.add(_delay);
  if (_delayedTokens.size() > 0 && _currentOutput != null) {
    _delayedTokens.remove(currentTime);
  }
  if (_currentInput != null) {
    _delayedTokens.put(delayToTime,_currentInput);
    getDirector().fireAt(this,delayToTime);
  }
  return super.postfire();
}","/** 
 * Update the internal states of this actor. If the current input  is not processed in the fire method, schedule a refiring of this actor to produce an output in a future time,  (the current model time + delay specified by the input value).  
 * @exception IllegalActionException If scheduling to refire cannotbe performed or the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time delayToTime=currentTime.add(_delay);
  if (_delayedOutputTokens.size() > 0) {
    if (_currentOutput != null) {
      _delayedOutputTokens.take();
    }
  }
  if (_delayedOutputTokens.size() > 0) {
    TimedEvent earliestEvent=(TimedEvent)_delayedOutputTokens.get();
    Time eventTime=earliestEvent.timeStamp;
    if (eventTime.equals(currentTime)) {
      getDirector().fireAt(this,currentTime);
    }
  }
  if (_currentInput != null) {
    _delayedOutputTokens.put(new TimedEvent(delayToTime,_currentInput));
    getDirector().fireAt(this,delayToTime);
  }
  return super.postfire();
}"
75231,"/** 
 * Read one token from the input. If the value of the input is bigger than 0.0, save the input to be processed in the postfire method. Otherwise,  check whether there is any output scheduled to be produced at the  current time. If there is one, send out that output and save the  current input for future processing in the postfire method. If there  is no output to produce and the input value is 0.0, send an output  immediately and reset the current input to null, indicating no further  processing of the current input is necessary.
 * @exception IllegalActionException If there is no director, or can notsend or get tokens from ports.
 */
public void fire() throws IllegalActionException {
  _delay=-1.0;
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
    double delayValue=((DoubleToken)_currentInput).doubleValue();
    if (delayValue < 0) {
      throw new IllegalActionException(""String_Node_Str"");
    }
 else {
      _delay=delayValue;
    }
  }
 else {
    _currentInput=null;
  }
  Time currentTime=getDirector().getModelTime();
  _currentOutput=null;
  if (_delayedTokens.size() > 0) {
    _currentOutput=(Token)_delayedTokens.get(currentTime);
    if (_currentOutput != null) {
      output.send(0,value.getToken());
      return;
    }
 else {
    }
  }
  if (_delay == 0.0) {
    output.send(0,value.getToken());
    _currentInput=null;
  }
}","/** 
 * Read one token from the input. If the value of the input is bigger than 0.0, save the input to be processed in the postfire method. Otherwise,  check whether there is any output scheduled to be produced at the  current time. If there is one, send out that output and save the  current input for future processing in the postfire method. If there  is no output to produce and the input value is 0.0, send an output  immediately and reset the current input to null, indicating no further  processing of the current input is necessary.
 * @exception IllegalActionException If there is no director, or can notsend or get tokens from ports.
 */
public void fire() throws IllegalActionException {
  _delay=-1.0;
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
    double delayValue=((DoubleToken)_currentInput).doubleValue();
    if (delayValue < 0) {
      throw new IllegalActionException(""String_Node_Str"");
    }
 else {
      _delay=delayValue;
    }
  }
 else {
    _currentInput=null;
  }
  Time currentTime=getDirector().getModelTime();
  _currentOutput=null;
  if (_delayedOutputTokens.size() > 0) {
    TimedEvent earliestEvent=(TimedEvent)_delayedOutputTokens.get();
    Time eventTime=earliestEvent.timeStamp;
    if (eventTime.equals(currentTime)) {
      _currentOutput=(Token)earliestEvent.contents;
      output.send(0,value.getToken());
      return;
    }
 else {
    }
  }
  if (_delay == 0.0) {
    output.send(0,value.getToken());
    _currentInput=null;
  }
}"
75232,"/** 
 * Initialize the internal states of this actor.
 * @exception IllegalActionException If a derived class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _currentInput=null;
  _currentOutput=null;
  _delayedTokens=new HashMap();
}","/** 
 * Initialize the internal states of this actor.
 * @exception IllegalActionException If a derived class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _currentInput=null;
  _currentOutput=null;
  _delayedOutputTokens=new CalendarQueue(new TimedEvent.TimeComparator(this.getDirector()));
}"
75233,"/** 
 * If there are delayed inputs that are not processed and the timer  is not busy. Begin processing the earliest input and schedule  a future firing to produce it.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedOutputTokens.take();
  }
  if (_delayedInputTokensList.size() != 0 && _delayedOutputTokens.isEmpty()) {
    DoubleToken delayToken=(DoubleToken)_delayedInputTokensList.removeFirst();
    double delay=delayToken.doubleValue();
    _nextTimeFree=currentTime.add(delay);
    _delayedOutputTokens.put(new TimedEvent(_nextTimeFree,delayToken));
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}","/** 
 * If there are delayed inputs that are not processed and the timer  is not busy. Begin processing the earliest input and schedule  a future firing to produce it.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedOutputTokens.take();
  }
  if (_delayedInputTokensList.size() != 0 && _delayedOutputTokens.isEmpty()) {
    DoubleToken delayToken=(DoubleToken)_delayedInputTokensList.removeFirst();
    double delay=delayToken.doubleValue();
    _nextTimeFree=currentTime.add(delay);
    _delayedOutputTokens.put(new TimedEvent(_nextTimeFree,value.getToken()));
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}"
75234,"/** 
 * Update the internal states of this actor. If the current input  is not processed in the fire method, schedule a refiring of this actor to produce an output in a future time,  (the current model time + delay specified by the input value).  
 * @exception IllegalActionException If scheduling to refire cannotbe performed or the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time delayToTime=currentTime.add(_delay);
  if (_delayedOutputTokens.size() > 0) {
    if (_currentOutput != null) {
      _delayedOutputTokens.take();
    }
  }
  if (_delayedOutputTokens.size() > 0) {
    TimedEvent earliestEvent=(TimedEvent)_delayedOutputTokens.get();
    Time eventTime=earliestEvent.timeStamp;
    if (eventTime.equals(currentTime)) {
      getDirector().fireAt(this,currentTime);
    }
  }
  if (_currentInput != null) {
    _delayedOutputTokens.put(new TimedEvent(delayToTime,_currentInput));
    getDirector().fireAt(this,delayToTime);
  }
  return super.postfire();
}","/** 
 * Update the internal states of this actor. If the current input  is not processed in the fire method, schedule a refiring of this actor to produce an output in a future time,  (the current model time + delay specified by the input value).  
 * @exception IllegalActionException If scheduling to refire cannotbe performed or the superclass throws it.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time delayToTime=currentTime.add(_delay);
  if (_delayedOutputTokens.size() > 0) {
    if (_currentOutput != null) {
      _delayedOutputTokens.take();
    }
  }
  if (_delayedOutputTokens.size() > 0) {
    TimedEvent earliestEvent=(TimedEvent)_delayedOutputTokens.get();
    Time eventTime=earliestEvent.timeStamp;
    if (eventTime.equals(currentTime)) {
      getDirector().fireAt(this,currentTime);
    }
  }
  if (_currentInput != null) {
    _delayedOutputTokens.put(new TimedEvent(delayToTime,value.getToken()));
    getDirector().fireAt(this,delayToTime);
  }
  return super.postfire();
}"
75235,"/** 
 * If there are delayed input events that are not processed and the timer is ready, begin process the earliest input event and schedule  future firings to produce them.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedTokens.remove(currentTime);
  }
  if (_delayedInputTokensList.size() != 0 && _delayedTokens.isEmpty()) {
    DoubleToken delayToken=(DoubleToken)_delayedInputTokensList.removeFirst();
    double delay=delayToken.doubleValue();
    _nextTimeFree=currentTime.add(delay);
    _delayedTokens.put(_nextTimeFree,delayToken);
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}","/** 
 * If there are delayed input events that are not processed and the timer is ready, begin processing the earliest input event and schedule  a future firing to produce it.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedTokens.remove(currentTime);
  }
  if (_delayedInputTokensList.size() != 0 && _delayedTokens.isEmpty()) {
    DoubleToken delayToken=(DoubleToken)_delayedInputTokensList.removeFirst();
    double delay=delayToken.doubleValue();
    _nextTimeFree=currentTime.add(delay);
    _delayedTokens.put(_nextTimeFree,delayToken);
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}"
75236,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then links the type of the <i>value</i> parameter to the output.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class hashas an attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Timer newObject=(Timer)super.clone(workspace);
  newObject.output.setTypeSameAs(value);
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then links the type of the <i>value</i> parameter to the output.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class hashas an attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  NonInterruptibleTimer newObject=(NonInterruptibleTimer)super.clone(workspace);
  newObject.output.setTypeSameAs(value);
  return newObject;
}"
75237,"/** 
 * Examine the non-preemptive transitions from the given state. If there is more than one transition enabled, an exception is thrown. If there is exactly one non-preemptive transition enabled, then it is chosen and the choice actions contained by transition are executed. Return the destination state. If no transition is enabled, return the current state.
 * @return The destination state, or the current state if notransition is enabled.
 */
public State chooseStateTransition(State state) throws IllegalActionException {
  FSMActor controller=getController();
  State destinationState;
  Transition transition=_chooseTransition(state.nonpreemptiveTransitionList());
  if (transition != null) {
    destinationState=transition.destinationState();
    TypedActor[] trRefinements=(transition.getRefinement());
    Actor[] actors=transition.getRefinement();
    if (actors != null) {
      for (int i=0; i < actors.length; ++i) {
        if (_stopRequested)         break;
        if (actors[i].prefire()) {
          if (_debugging) {
            _debug(getFullName(),""String_Node_Str"",((ptolemy.kernel.util.NamedObj)actors[i]).getName());
          }
          actors[i].fire();
          actors[i].postfire();
        }
      }
    }
    _readOutputsFromRefinement();
    Iterator actions=transition.choiceActionList().iterator();
    while (actions.hasNext()) {
      Action action=(Action)actions.next();
      action.execute();
    }
    _readOutputsFromRefinement();
  }
 else {
    destinationState=state;
  }
  return destinationState;
}","/** 
 * Examine the non-preemptive transitions from the given state. If there is more than one transition enabled, an exception is thrown. If there is exactly one non-preemptive transition enabled, then it is chosen and the choice actions contained by transition are executed. Return the destination state. If no transition is enabled, return the current state.
 * @return The destination state, or the current state if notransition is enabled.
 */
public State chooseStateTransition(State state) throws IllegalActionException {
  FSMActor controller=getController();
  State destinationState;
  Transition transition=_chooseTransition(state.nonpreemptiveTransitionList());
  if (transition != null) {
    destinationState=transition.destinationState();
    TypedActor[] trRefinements=(transition.getRefinement());
    Actor[] actors=transition.getRefinement();
    if (actors != null) {
      for (int i=0; i < actors.length; ++i) {
        if (_stopRequested)         break;
        if (actors[i].prefire()) {
          if (_debugging) {
            _debug(getFullName(),""String_Node_Str"",((ptolemy.kernel.util.NamedObj)actors[i]).getName());
          }
          actors[i].fire();
          actors[i].postfire();
        }
      }
      _readOutputsFromRefinement();
      Iterator actions=transition.choiceActionList().iterator();
      while (actions.hasNext()) {
        Action action=(Action)actions.next();
        action.execute();
      }
      _readOutputsFromRefinement();
    }
  }
 else {
    destinationState=state;
  }
  return destinationState;
}"
75238,"public void fireDynamicActors() throws IllegalActionException {
  _debug(getFullName() + ""String_Node_Str"");
  CTDirector dir=(CTDirector)getContainer();
  if (dir == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  CTScheduler scheduler=(CTScheduler)dir.getScheduler();
  if (scheduler == null) {
    throw new IllegalActionException(dir,""String_Node_Str"");
  }
  CTSchedule schedule=(CTSchedule)scheduler.getSchedule();
  Iterator actors=schedule.get(CTSchedule.DYNAMIC_ACTORS).actorIterator();
  while (actors.hasNext()) {
    CTDynamicActor next=(CTDynamicActor)actors.next();
    _debug(getFullName(),""String_Node_Str"",((Nameable)next).getName());
    next.fire();
  }
  if (getRoundCount() == 0) {
    dir.setModelTime(dir.getModelTime().add(dir.getCurrentStepSize()));
  }
}","public void fireDynamicActors() throws IllegalActionException {
  _setConverged(true);
  _debug(getFullName() + ""String_Node_Str"");
  CTDirector dir=(CTDirector)getContainer();
  if (dir == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  CTScheduler scheduler=(CTScheduler)dir.getScheduler();
  if (scheduler == null) {
    throw new IllegalActionException(dir,""String_Node_Str"");
  }
  CTSchedule schedule=(CTSchedule)scheduler.getSchedule();
  Iterator actors=schedule.get(CTSchedule.DYNAMIC_ACTORS).actorIterator();
  while (actors.hasNext()) {
    CTDynamicActor next=(CTDynamicActor)actors.next();
    _debug(getFullName(),""String_Node_Str"",((Nameable)next).getName());
    next.fire();
  }
  if (getRoundCount() == 0) {
    dir.setModelTime(dir.getModelTime().add(dir.getCurrentStepSize()));
  }
}"
75239,"/** 
 * If a token was read in the fire() method, then produce it on the output and schedule a firing to occur when the service time elapses. The output is produced with a time offset equal to the value of the <i>newServiceTime</i> parameter.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedTokens.remove(new Double(currentTime.getDoubleValue()));
  }
  if (_delayedTokensList.size() != 0 && _delayedTokens.isEmpty()) {
    _nextTimeFree=currentTime.add(_delay);
    _delayedTokens.put(new Double(_nextTimeFree.getDoubleValue()),_delayedTokensList.removeFirst());
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}","/** 
 * If there are delayed input events that are not processed and the server is not busy, schedule future firings to process them.
 * @exception IllegalActionException If there is no director or can notschedule future firings to handle delayed input events.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  if (_currentOutput != null) {
    _delayedTokens.remove(currentTime);
  }
  if (_delayedInputTokensList.size() != 0 && _delayedTokens.isEmpty()) {
    _nextTimeFree=currentTime.add(_delay);
    _delayedTokens.put(_nextTimeFree,_delayedInputTokensList.removeFirst());
    getDirector().fireAt(this,_nextTimeFree);
  }
  return !_stopRequested;
}"
75240,"/** 
 * If there is an input token, read it to begin servicing it. Note that service actually begins in the postfire() method, which will produce the token that is read on the output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  delay.update();
  _delay=((DoubleToken)delay.getToken()).doubleValue();
  Time currentTime=getDirector().getModelTime();
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
    _delayedTokensList.addLast(_currentInput);
  }
 else {
    _currentInput=null;
  }
  if (currentTime.compareTo(_nextTimeFree) == 0) {
    _currentOutput=(Token)_delayedTokens.get(new Double(currentTime.getDoubleValue()));
    if (_currentOutput == null) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    output.send(0,_currentOutput);
  }
}","/** 
 * Read the available input token. If the server is not busy,  begin servicing it. If the delay is 0, output is immediately availabe. Otherwise, the output available time is delayed by the amount of the  <i>newServiceTime></i> parameter. If the server is busy, check whether the current service finishes. If so, generate output. Otherwise, do nothing. 
 * @exception IllegalActionException If can not update the serviceTimeparameter, read inputs, or send outputs.
 */
public void fire() throws IllegalActionException {
  delay.update();
  _delay=((DoubleToken)delay.getToken()).doubleValue();
  Time currentTime=getDirector().getModelTime();
  if (input.hasToken(0)) {
    _currentInput=input.get(0);
    _delayedInputTokensList.addLast(_currentInput);
  }
 else {
    _currentInput=null;
  }
  if (_delayedTokens.size() > 0) {
    if (currentTime.compareTo(_nextTimeFree) == 0) {
      _currentOutput=(Token)_delayedTokens.get(currentTime);
      if (_currentOutput == null) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      output.send(0,_currentOutput);
    }
 else {
    }
  }
 else {
    if (_delay == 0 && _delayedInputTokensList.size() > 0) {
      output.send(0,(Token)_delayedInputTokensList.removeFirst());
    }
  }
}"
75241,"/** 
 * Indicate that the server is not busy.
 * @exception IllegalActionException If the base class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _nextTimeFree=Time.NEGATIVE_INFINITY;
  _delayedTokensList=new LinkedList();
}","/** 
 * Reset the states of the server to indicate that the server is ready to serve.
 * @exception IllegalActionException If the base class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _nextTimeFree=Time.NEGATIVE_INFINITY;
  _delayedInputTokensList=new LinkedList();
}"
75242,"/** 
 * Set up the production constant.
 * @exception IllegalActionException If the length of the table is nota power of two.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _wordLength=((IntToken)(wordLength.getToken())).intValue();
  _outputRate.setToken(new IntToken(_wordLength));
  ArrayToken tableToken=(ArrayToken)table.getToken();
  _size=1 << _wordLength;
  if (tableToken.length() < _size) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _size + ""String_Node_Str""+ tableToken.length());
  }
  _table=new Complex[_size];
  for (int i=0; i < _size; i++)   _table[i]=((ComplexToken)tableToken.getElement(i)).complexValue();
}","/** 
 * Set up the production constant.
 * @exception IllegalActionException If the length of the table is nota power of two.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _wordLength=((IntToken)(wordLength.getToken())).intValue();
  _outputRate.setToken(new IntToken(_wordLength));
  ArrayToken tableToken=(ArrayToken)table.getToken();
  _size=1 << _wordLength;
  if (tableToken.length() < _size) {
    _size=tableToken.length();
  }
  _table=new Complex[_size];
  for (int i=0; i < _size; i++)   _table[i]=((ComplexToken)tableToken.getElement(i)).complexValue();
}"
75243,"/** 
 * Return false if any input channel does not have a token. Otherwise, return whatever the superclass returns.
 * @return False if there are not enough tokens to fire.
 * @exception IllegalActionException If there is no director.
 */
public boolean prefire() throws IllegalActionException {
  if (control.hasToken(0)) {
    _control=((BooleanToken)control.get(0)).booleanValue();
  }
  if (_control) {
    if (!trueInput.hasToken(0)) {
      return false;
    }
  }
 else {
    if (!falseInput.hasToken(0)) {
      return false;
    }
  }
  return super.prefire();
}","/** 
 * Return false if any input channel does not have a token. Otherwise, return whatever the superclass returns.
 * @return False if there are not enough tokens to fire.
 * @exception IllegalActionException If there is no director.
 */
public boolean prefire() throws IllegalActionException {
  if (control.hasToken(0)) {
    _control=((BooleanToken)control.get(0)).booleanValue();
    if (_control) {
      if (!trueInput.hasToken(0)) {
        return false;
      }
    }
 else {
      if (!falseInput.hasToken(0)) {
        return false;
      }
    }
  }
 else {
    return false;
  }
  return super.prefire();
}"
75244,"private void _fireExactlyOneIteration() throws IllegalActionException {
  if (_debugging && _verbose)   _debug(""String_Node_Str"" + getModelTime(),""String_Node_Str"" + getCurrentStepSize());
  ODESolver solver=getCurrentODESolver();
  if (_debugging && _verbose)   _debug(""String_Node_Str"" + solver.getName());
  prefireClear();
  _prefireDynamicActors();
  solver.fireStateTransitionActors();
  solver.fireDynamicActors();
  produceOutput();
  updateContinuousStates();
  setSuggestedNextStepSize(_predictNextStepSize());
}","private void _fireExactlyOneIteration() throws IllegalActionException {
  if (_debugging && _verbose)   _debug(""String_Node_Str"" + getModelTime(),""String_Node_Str"" + getCurrentStepSize());
  ODESolver solver=getCurrentODESolver();
  if (_debugging && _verbose)   _debug(""String_Node_Str"" + solver.getName());
  prefireClear();
  _setExecutionPhase(CTExecutionPhase.PREFIRINGDYNAMICACTORS_PHASE);
  _prefireDynamicActors();
  _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
  _setExecutionPhase(CTExecutionPhase.FIRINGSTATETRANSITIONACTORS_PHASE);
  solver.fireStateTransitionActors();
  _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
  _setExecutionPhase(CTExecutionPhase.FIRINGDYNAMICACTORS_PHASE);
  solver.fireDynamicActors();
  _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
  _setExecutionPhase(CTExecutionPhase.PRODUCINGOUTPUTS_PHASE);
  produceOutput();
  _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
  _setExecutionPhase(CTExecutionPhase.UPDATINGCONTINUOUSSTATES_PHASE);
  updateContinuousStates();
  _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
  setSuggestedNextStepSize(_predictNextStepSize());
}"
75245,"/** 
 * Process discrete event actors in the system.  The execution repeats executing the discrete actors,  wavefore generators, and event generators until the execution  reachs a fix point, where no more events happen at the current time. 
 * @exception IllegalActionException If one of the actors throws it.
 */
private void _discretePhaseExecution() throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + getName(),""String_Node_Str"" + getModelTime());
  _setDiscretePhase(true);
  setCurrentStepSize(getSuggestedNextStepSize());
  boolean discreteFixPointReached=false;
  CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
  if (!hasCurrentEvent()) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    discreteFixPointReached=true;
    _setDiscretePhase(false);
    return;
  }
  while ((!discreteFixPointReached || hasCurrentEvent()) && _postfireReturns) {
    _processBreakpoints();
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    if (_debugging)     _debug(""String_Node_Str"" + getName(),""String_Node_Str"");
    _iterateDiscreteActors(schedule);
    if (_debugging)     _debug(""String_Node_Str"" + getName(),""String_Node_Str"");
    _iterateWaveformGenerators(schedule);
    if (_debugging)     _debug(""String_Node_Str"" + getName(),""String_Node_Str"");
    _createIterationStartingStates();
    if (_debugging)     _debug(""String_Node_Str"" + getName(),""String_Node_Str"");
    _iterateEventGenerators(schedule);
    discreteFixPointReached=!_processBreakpoints();
    if (discreteFixPointReached && _debugging) {
      _debug(""String_Node_Str"" + getBreakPoints().first() + ""String_Node_Str"");
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _setDiscretePhase(false);
}","/** 
 * Process discrete event actors in the system.  The execution repeats executing the discrete actors,  wavefore generators, and event generators until the execution  reachs a fix point, where no more events happen at the current time. 
 * @exception IllegalActionException If one of the actors throws it.
 */
private void _discretePhaseExecution() throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + getName(),""String_Node_Str"" + getModelTime());
  _setDiscretePhase(true);
  setCurrentStepSize(getSuggestedNextStepSize());
  boolean discreteFixPointReached=false;
  CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
  while (hasCurrentEvent() && _postfireReturns) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    if (_debugging)     _debug(""String_Node_Str"" + getName(),""String_Node_Str"");
    _iteratePurelyDiscreteActors(schedule);
    if (_debugging)     _debug(""String_Node_Str"" + getName(),""String_Node_Str"");
    _iterateWaveformGenerators(schedule);
    if (_debugging)     _debug(""String_Node_Str"" + getName(),""String_Node_Str"");
    _createIterationStartingStates();
    if (_debugging)     _debug(""String_Node_Str"" + getName(),""String_Node_Str"");
    _iterateEventGenerators(schedule);
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getBreakPoints().first() + ""String_Node_Str"");
    _debug(""String_Node_Str"" + ""String_Node_Str"");
  }
  discreteFixPointReached=true;
  _setDiscretePhase(false);
}"
75246,"/** 
 * Return true if there is an event at current time.
 * @return True if there is an event at current time.
 */
public boolean hasCurrentEvent(){
  try {
    CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
    Iterator eventGenerators=schedule.get(CTSchedule.EVENT_GENERATORS).actorIterator();
    boolean hasDiscreteEvents=false;
    while (eventGenerators.hasNext()) {
      CTEventGenerator generator=(CTEventGenerator)eventGenerators.next();
      if (generator.hasCurrentEvent()) {
        hasDiscreteEvents=true;
      }
    }
    if (hasDiscreteEvents)     return true;
    if (getBreakPoints().contains(getModelTime())) {
      if (_debugging) {
        _debug(""String_Node_Str"" + getBreakPoints().first());
      }
      hasDiscreteEvents=true;
    }
    return hasDiscreteEvents;
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Return true if there is an event at current time.
 * @return True if there is an event at current time.
 */
public boolean hasCurrentEvent(){
  try {
    CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
    Iterator eventGenerators=schedule.get(CTSchedule.EVENT_GENERATORS).actorIterator();
    boolean hasDiscreteEvents=false;
    while (eventGenerators.hasNext()) {
      CTEventGenerator generator=(CTEventGenerator)eventGenerators.next();
      if (generator.hasCurrentEvent()) {
        hasDiscreteEvents=true;
      }
    }
    hasDiscreteEvents|=_processBreakpoints();
    return hasDiscreteEvents;
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
75247,"/** 
 * Invoke prefire() on all DYNAMIC_ACTORS, such as integrators, and emit their tentative outputs. Return true if all the prefire() methods return true and stop() is not called. Otherwise, return false.  Note that prefire() is called on all actors even if one returns false.
 * @return The logical AND of the prefire() of dynamic actors, orfalse if stop() is called.
 */
protected boolean _prefireDynamicActors() throws IllegalActionException {
  CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
  boolean result=true;
  Iterator actors=schedule.get(CTSchedule.DYNAMIC_ACTORS).actorIterator();
  _setExecutionPhase(CTExecutionPhase.PREFIRINGDYNAMICACTORS_PHASE);
  while (actors.hasNext() && !_stopRequested) {
    Actor actor=(Actor)actors.next();
    if (_debugging)     _debug(""String_Node_Str"" + ((Nameable)actor).getName());
    boolean ready=actor.prefire();
    if (!ready) {
      _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
      throw new IllegalActionException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (_debugging)     _debug(""String_Node_Str"" + ((Nameable)actor).getName() + ""String_Node_Str""+ ready);
    result=result && ready;
  }
  Iterator integrators=schedule.get(CTSchedule.DYNAMIC_ACTORS).actorIterator();
  while (integrators.hasNext() && !_stopRequested) {
    CTDynamicActor dynamic=(CTDynamicActor)integrators.next();
    if (_debugging)     _debug(""String_Node_Str"" + ((Nameable)dynamic).getName());
    dynamic.emitTentativeOutputs();
  }
  _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
  return result && !_stopRequested;
}","/** 
 * Invoke prefire() on all DYNAMIC_ACTORS, such as integrators, and emit their tentative outputs. Return true if all the prefire() methods return true and stop() is not called. Otherwise, return false.  Note that prefire() is called on all actors even if one returns false.
 * @return The logical AND of the prefire() of dynamic actors, orfalse if stop() is called.
 */
protected boolean _prefireDynamicActors() throws IllegalActionException {
  CTSchedule schedule=(CTSchedule)getScheduler().getSchedule();
  boolean result=true;
  Iterator actors=schedule.get(CTSchedule.DYNAMIC_ACTORS).actorIterator();
  _setExecutionPhase(CTExecutionPhase.PREFIRINGDYNAMICACTORS_PHASE);
  while (actors.hasNext() && !_stopRequested) {
    Actor actor=(Actor)actors.next();
    if (_debugging)     _debug(""String_Node_Str"" + ((Nameable)actor).getName());
    boolean ready;
    if (actor instanceof AtomicActor) {
      ready=actor.prefire();
    }
 else {
      actor.fire();
      ready=true;
    }
    if (!ready) {
      _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
      throw new IllegalActionException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (_debugging)     _debug(""String_Node_Str"" + ((Nameable)actor).getName() + ""String_Node_Str""+ ready);
    result=result && ready;
  }
  Iterator integrators=schedule.get(CTSchedule.DYNAMIC_ACTORS).actorIterator();
  while (integrators.hasNext() && !_stopRequested) {
    CTDynamicActor dynamic=(CTDynamicActor)integrators.next();
    if (_debugging)     _debug(""String_Node_Str"" + ((Nameable)dynamic).getName());
    dynamic.emitTentativeOutputs();
  }
  _setExecutionPhase(CTExecutionPhase.UNKNOWN_PHASE);
  return result && !_stopRequested;
}"
75248,"/** 
 * Return true if this director is embedded inside an opaque composite actor contained by another composite actor.
 */
protected boolean _isEmbedded(){
  return (getContainer() != null && getContainer().getContainer() != null);
}","/** 
 * Return true if this director is embedded inside an opaque composite actor contained by another composite actor.
 */
protected boolean _isEmbedded(){
  return !_isTopLevel();
}"
75249,"/** 
 * Return true if this is a top-level director. Parts of this method is read synchronized on the workspace.
 * @return True if this director is at the top-level.
 */
protected boolean _isTopLevel(){
  CompositeActor container=(CompositeActor)getContainer();
  if (container.getExecutiveDirector() == null) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Return true if this is a top-level director. Parts of this method is read synchronized on the workspace.
 * @return True if this director is at the top-level.
 */
protected boolean _isTopLevel(){
  NamedObj container=getContainer();
  if (container instanceof CompositeActor) {
    if (((CompositeActor)container).getExecutiveDirector() == null) {
      return true;
    }
 else {
      return false;
    }
  }
  return true;
}"
75250,"/** 
 * If the container of this director does not have an HDFFSMDirector as its executive director, then return it. Otherwise, move up the hierarchy until we reach a container actor that does not have an HDFFSMDirector director for its executive director.
 * @exception IllegalActionException If the top-level directoris an HDFFSMDirector.
 */
private CompositeActor _getHighestFSM() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  Director director=container.getExecutiveDirector();
  boolean foundValidDirector=false;
  while (foundValidDirector == false) {
    if (director == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (director instanceof HDFDirector) {
      foundValidDirector=true;
    }
 else     if (director instanceof SDFDirector || director instanceof DDFDirector) {
      foundValidDirector=true;
      _embeddedInSDF=true;
    }
 else {
      container=(CompositeActor)(container.getContainer());
      director=container.getExecutiveDirector();
    }
  }
  return container;
}","/** 
 * If the container of this director does not have an HDFFSMDirector as its executive director, then return it. Otherwise, move up the hierarchy until we reach a container actor that does not have an HDFFSMDirector director for its executive director.
 * @exception IllegalActionException If the top-level directoris an HDFFSMDirector.
 */
private CompositeActor _getHighestFSM() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  Director director=container.getExecutiveDirector();
  boolean foundValidDirector=false;
  while (foundValidDirector == false) {
    if (director == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (director instanceof HDFDirector) {
      foundValidDirector=true;
    }
 else     if (director instanceof SDFDirector || director instanceof DDFDirector || director instanceof GiottoDirector) {
      foundValidDirector=true;
      _embeddedInSDF=true;
    }
 else {
      container=(CompositeActor)(container.getContainer());
      director=container.getExecutiveDirector();
    }
  }
  return container;
}"
75251,"/** 
 * Return true if data are transferred from the input port of the container to the connected ports of the controller and of the current refinement actor. <p> This method will transfer all of the available tokens on each input channel. The port argument must be an opaque input port. If any channel of the input port has no data, then that channel is ignored. Any token left not consumed in the ports to which data are transferred is discarded.
 * @param port The input port to transfer tokens from.
 * @return True if data are transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean transferred=false;
  Receiver[][] insideReceivers=_currentLocalReceivers(port);
  for (int i=0; i < port.getWidth(); i++) {
    int rate=SDFUtilities.getTokenConsumptionRate(port);
    try {
      if (insideReceivers != null && insideReceivers[i] != null) {
        for (int j=0; j < insideReceivers[i].length; j++) {
          while (insideReceivers[i][j].hasToken()) {
            insideReceivers[i][j].get();
          }
        }
      }
      for (int k=0; k < rate; k++) {
        ptolemy.data.Token t=port.get(i);
        if (insideReceivers != null && insideReceivers[i] != null) {
          for (int j=0; j < insideReceivers[i].length; j++) {
            insideReceivers[i][j].put(t);
          }
          transferred=true;
        }
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex);
    }
  }
  return transferred;
}","/** 
 * Return true if data are transferred from the input port of the container to the connected ports of the controller and of the current refinement actor. <p> This method will transfer all of the available tokens on each input channel. The port argument must be an opaque input port. If any channel of the input port has no data, then that channel is ignored. Any token left not consumed in the ports to which data are transferred is discarded.
 * @param port The input port to transfer tokens from.
 * @return True if data are transferred.
 * @exception IllegalActionException If the port is not an opaqueinput port.
 */
public boolean transferInputs(IOPort port) throws IllegalActionException {
  if (!port.isInput() || !port.isOpaque()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean transferred=false;
  Receiver[][] insideReceivers=_currentLocalReceivers(port);
  for (int i=0; i < port.getWidth(); i++) {
    int rate=SDFUtilities.getTokenConsumptionRate(port);
    try {
      if (insideReceivers != null && insideReceivers[i] != null) {
        for (int j=0; j < insideReceivers[i].length; j++) {
          while (insideReceivers[i][j].hasToken()) {
            insideReceivers[i][j].get();
          }
        }
      }
      for (int k=0; k < rate; k++) {
        if (port.hasToken(i)) {
          ptolemy.data.Token t=port.get(i);
          if (insideReceivers != null && insideReceivers[i] != null) {
            for (int j=0; j < insideReceivers[i].length; j++) {
              insideReceivers[i][j].put(t);
            }
            transferred=true;
          }
        }
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex);
    }
  }
  return transferred;
}"
75252,"/** 
 * Given a double value, return a new double with precision as  given.
 * @param value The double value.
 * @param precision The precision.
 * @return A double value with the given precision.
 */
public static double round(double value,double precision){
  precision=-Math.log(precision) / Math.log(10);
  value=Math.round(value * Math.pow(10,precision)) / Math.pow(10,precision);
  return value;
}","/** 
 * Given a double value, return a new double with precision as  given.
 * @param value The double value.
 * @param precision The precision.
 * @return A double value with the given precision.
 */
public static double round(double value,double precision){
  long numberOfDigits=-Math.round((float)Math.log(precision) / Math.log(10));
  double newValue=Math.round(value * Math.pow(10,numberOfDigits)) / Math.pow(10,numberOfDigits);
  return newValue;
}"
75253,"/** 
 * Create a new entity from the specified class name, give it the specified entity name, and specify that its container is the current container object.  If the current container already contains an entity with the specified name and class, then return that entity.  If the class name matches a class that has been previously defined in the scope (or with an absolute name), then that class is instantiated. Otherwise, the class name is interpreted as a Java class name and we attempt to construct the entity.  If instantiating a Java class doesn't work, then we look for a MoML file on the classpath that defines a class by this name.  The file is assumed to be named ""foo.xml"", where ""foo"" is the name of the class.  Moreover, the classname is assumed to have no periods (since a MoML name does not allow periods, this is reasonable). If _current is not an instance of CompositeEntity, then an XML exception is thrown. If an object is created and we are propagating, then that object is marked as a derived object. The third argument, if non-null, gives a URL to import to create a reference class from which to instantiate this entity.
 * @param className
 * @param entityName
 * @param source
 * @return
 * @exception Exception
 */
private NamedObj _createEntity(String className,String entityName,String source) throws Exception {
  if (_current != null && !(_current instanceof CompositeEntity)) {
    throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + _current + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  CompositeEntity container=(CompositeEntity)_current;
  ComponentEntity previous=_searchForEntity(entityName,_current);
  Class newClass=null;
  ComponentEntity reference=null;
  if (className != null) {
    reference=searchForClass(className,source);
    if (reference == null) {
      reference=_searchForClassInContext(className,source);
    }
    if (reference == null) {
      try {
        newClass=Class.forName(className,true,_classLoader);
      }
 catch (      Exception ex) {
        try {
          reference=_attemptToFindMoMLClass(className,source);
        }
 catch (        Exception ex2) {
          throw new IllegalActionException(null,ex2,""String_Node_Str"" + className);
        }
      }
catch (      Error error) {
        StringBuffer errorMessage=new StringBuffer();
        if (error instanceof ExceptionInInitializerError) {
          Throwable staticThrowable=((ExceptionInInitializerError)error).getCause();
          errorMessage.append(""String_Node_Str"" + ""String_Node_Str"" + KernelException.stackTraceToString(staticThrowable));
        }
 else {
          errorMessage.append(className + ""String_Node_Str"" + error.toString()+ ""String_Node_Str"");
        }
        try {
          reference=_attemptToFindMoMLClass(className,source);
        }
 catch (        XmlException ex2) {
          throw new Exception(""String_Node_Str"" + errorMessage.toString() + className+ ""String_Node_Str""+ ex2.getMessage());
        }
catch (        ClassFormatError ex3) {
          throw new Exception(""String_Node_Str"" + errorMessage.toString() + className+ ""String_Node_Str""+ ""String_Node_Str""+ ex3.getMessage());
        }
catch (        Exception ex4) {
          throw new Exception(""String_Node_Str"" + errorMessage.toString() + className+ ""String_Node_Str""+ ex4.getMessage());
        }
      }
    }
  }
  if (previous != null) {
    if (newClass != null) {
      _checkClass(previous,newClass,""String_Node_Str"" + entityName + ""String_Node_Str""+ className);
    }
    return previous;
  }
  _checkForNull(className,""String_Node_Str"");
  if (reference == null) {
    if (_current != null) {
      List derivedList=container.getDerivedList();
      Iterator derivedObjects=derivedList.iterator();
      while (derivedObjects.hasNext()) {
        CompositeEntity derived=(CompositeEntity)derivedObjects.next();
        if (derived.getEntity(entityName) != null) {
          throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + derived.getEntity(entityName).getFullName());
        }
      }
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=entityName;
      NamedObj newEntity=_createInstance(newClass,arguments);
      newEntity.propagateExistence();
      _loadIconForClass(className,newEntity);
      _addParamsToParamsToParse(newEntity);
      return newEntity;
    }
 else {
      Object[] arguments=new Object[1];
      arguments[0]=_workspace;
      NamedObj result=_createInstance(newClass,arguments);
      result.setName(entityName);
      _loadIconForClass(className,result);
      return result;
    }
  }
 else {
    if (!reference.isClassDefinition()) {
      throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + reference.getFullName(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
    }
    List derivedList=null;
    if (container != null) {
      derivedList=container.getDerivedList();
      Iterator derivedObjects=derivedList.iterator();
      while (derivedObjects.hasNext()) {
        CompositeEntity derived=(CompositeEntity)derivedObjects.next();
        if (derived.getEntity(entityName) != null) {
          throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + derived.getEntity(entityName).getFullName());
        }
      }
    }
    ComponentEntity newEntity=(ComponentEntity)reference.instantiate(container,entityName);
    if (_topObjectsCreated != null && container == _originalContext) {
      _topObjectsCreated.add(newEntity);
    }
    URIAttribute modelURI=(URIAttribute)newEntity.getAttribute(""String_Node_Str"",URIAttribute.class);
    if (modelURI != null) {
      modelURI.setContainer(null);
    }
    _markParametersToParse(newEntity);
    newEntity.setClassName(className);
    Iterator propagatedInstances=newEntity.propagateExistence().iterator();
    while (propagatedInstances.hasNext()) {
      ComponentEntity propagatedEntity=(ComponentEntity)propagatedInstances.next();
      URIAttribute propagatedURI=(URIAttribute)propagatedEntity.getAttribute(""String_Node_Str"",URIAttribute.class);
      if (propagatedURI != null) {
        propagatedURI.setContainer(null);
      }
    }
    return newEntity;
  }
}","/** 
 * Create a new entity from the specified class name, give it the specified entity name, and specify that its container is the current container object.  If the current container already contains an entity with the specified name and class, then return that entity.  If the class name matches a class that has been previously defined in the scope (or with an absolute name), then that class is instantiated. Otherwise, the class name is interpreted as a Java class name and we attempt to construct the entity.  If instantiating a Java class doesn't work, then we look for a MoML file on the classpath that defines a class by this name.  The file is assumed to be named ""foo.xml"", where ""foo"" is the name of the class.  Moreover, the classname is assumed to have no periods (since a MoML name does not allow periods, this is reasonable). If _current is not an instance of CompositeEntity, then an XML exception is thrown. If an object is created and we are propagating, then that object is marked as a derived object. The third argument, if non-null, gives a URL to import to create a reference class from which to instantiate this entity.
 * @param className
 * @param entityName
 * @param source
 * @return
 * @exception Exception
 */
private NamedObj _createEntity(String className,String entityName,String source) throws Exception {
  if (_current != null && !(_current instanceof CompositeEntity)) {
    throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + _current + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  CompositeEntity container=(CompositeEntity)_current;
  ComponentEntity previous=_searchForEntity(entityName,_current);
  Class newClass=null;
  ComponentEntity reference=null;
  if (className != null) {
    reference=searchForClass(className,source);
    if (reference == null && source == null) {
      reference=_searchForClassInContext(className,source);
    }
    if (reference == null) {
      try {
        newClass=Class.forName(className,true,_classLoader);
      }
 catch (      Exception ex) {
        try {
          reference=_attemptToFindMoMLClass(className,source);
        }
 catch (        Exception ex2) {
          throw new IllegalActionException(null,ex2,""String_Node_Str"" + className);
        }
      }
catch (      Error error) {
        StringBuffer errorMessage=new StringBuffer();
        if (error instanceof ExceptionInInitializerError) {
          Throwable staticThrowable=((ExceptionInInitializerError)error).getCause();
          errorMessage.append(""String_Node_Str"" + ""String_Node_Str"" + KernelException.stackTraceToString(staticThrowable));
        }
 else {
          errorMessage.append(className + ""String_Node_Str"" + error.toString()+ ""String_Node_Str"");
        }
        try {
          reference=_attemptToFindMoMLClass(className,source);
        }
 catch (        XmlException ex2) {
          throw new Exception(""String_Node_Str"" + errorMessage.toString() + className+ ""String_Node_Str""+ ex2.getMessage());
        }
catch (        ClassFormatError ex3) {
          throw new Exception(""String_Node_Str"" + errorMessage.toString() + className+ ""String_Node_Str""+ ""String_Node_Str""+ ex3.getMessage());
        }
catch (        Exception ex4) {
          throw new Exception(""String_Node_Str"" + errorMessage.toString() + className+ ""String_Node_Str""+ ex4.getMessage());
        }
      }
    }
  }
  if (previous != null) {
    if (newClass != null) {
      _checkClass(previous,newClass,""String_Node_Str"" + entityName + ""String_Node_Str""+ className);
    }
    return previous;
  }
  _checkForNull(className,""String_Node_Str"");
  if (reference == null) {
    if (_current != null) {
      List derivedList=container.getDerivedList();
      Iterator derivedObjects=derivedList.iterator();
      while (derivedObjects.hasNext()) {
        CompositeEntity derived=(CompositeEntity)derivedObjects.next();
        if (derived.getEntity(entityName) != null) {
          throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + derived.getEntity(entityName).getFullName());
        }
      }
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=entityName;
      NamedObj newEntity=_createInstance(newClass,arguments);
      newEntity.propagateExistence();
      _loadIconForClass(className,newEntity);
      _addParamsToParamsToParse(newEntity);
      return newEntity;
    }
 else {
      Object[] arguments=new Object[1];
      arguments[0]=_workspace;
      NamedObj result=_createInstance(newClass,arguments);
      result.setName(entityName);
      _loadIconForClass(className,result);
      return result;
    }
  }
 else {
    if (!reference.isClassDefinition()) {
      throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + reference.getFullName(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
    }
    List derivedList=null;
    if (container != null) {
      derivedList=container.getDerivedList();
      Iterator derivedObjects=derivedList.iterator();
      while (derivedObjects.hasNext()) {
        CompositeEntity derived=(CompositeEntity)derivedObjects.next();
        if (derived.getEntity(entityName) != null) {
          throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + derived.getEntity(entityName).getFullName());
        }
      }
    }
    ComponentEntity newEntity=(ComponentEntity)reference.instantiate(container,entityName);
    if (_topObjectsCreated != null && container == _originalContext) {
      _topObjectsCreated.add(newEntity);
    }
    URIAttribute modelURI=(URIAttribute)newEntity.getAttribute(""String_Node_Str"",URIAttribute.class);
    if (modelURI != null) {
      modelURI.setContainer(null);
    }
    _markParametersToParse(newEntity);
    newEntity.setClassName(className);
    Iterator propagatedInstances=newEntity.propagateExistence().iterator();
    while (propagatedInstances.hasNext()) {
      ComponentEntity propagatedEntity=(ComponentEntity)propagatedInstances.next();
      URIAttribute propagatedURI=(URIAttribute)propagatedEntity.getAttribute(""String_Node_Str"",URIAttribute.class);
      if (propagatedURI != null) {
        propagatedURI.setContainer(null);
      }
    }
    return newEntity;
  }
}"
75254,"/** 
 * Move the specified element to the specified position in the list. If the specified element is not in the list, then throw an exception.
 * @param element Element to move.
 * @param index The position to which to move it.
 * @return The index of the specified object prior to moving it,or -1 if it was not moved (it is already at the specified position).
 * @exception IllegalActionException If the argument is noton the list, or if the specified position is out of range.
 */
public int moveToIndex(Nameable element,int index) throws IllegalActionException {
  int priorIndex=_namedList.indexOf(element);
  if (priorIndex < 0) {
    throw new IllegalActionException(element,""String_Node_Str"");
  }
 else   if (index < 0 || index >= _namedList.size()) {
    throw new IllegalActionException(element,""String_Node_Str"");
  }
 else   if (priorIndex != index) {
    _namedList.remove(element);
    _namedList.add(index,element);
    return index;
  }
 else {
    return -1;
  }
}","/** 
 * Move the specified element to the specified position in the list. If the specified element is not in the list, then throw an exception.
 * @param element Element to move.
 * @param index The position to which to move it.
 * @return The index of the specified object prior to moving it,or -1 if it was not moved (it is already at the specified position).
 * @exception IllegalActionException If the argument is noton the list, or if the specified position is out of range.
 */
public int moveToIndex(Nameable element,int index) throws IllegalActionException {
  int priorIndex=_namedList.indexOf(element);
  if (priorIndex < 0) {
    throw new IllegalActionException(element,""String_Node_Str"");
  }
 else   if (index < 0 || index >= _namedList.size()) {
    throw new IllegalActionException(element,""String_Node_Str"");
  }
 else   if (priorIndex != index) {
    _namedList.remove(element);
    _namedList.add(index,element);
    return priorIndex;
  }
 else {
    return -1;
  }
}"
75255,"/** 
 * Override the base class to set type constraints.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new instance of Sleep.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Sleep newObject=(Sleep)super.clone(workspace);
  newObject.output.setTypeAtLeast(input);
  return newObject;
}","/** 
 * Override the base class to set type constraints.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new instance of Sleep.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Sleep newObject=(Sleep)super.clone(workspace);
  newObject.output.setTypeAtLeast(newObject.input);
  return newObject;
}"
75256,"/** 
 * Make a state transition if this FSM is embedded in SDF. Otherwise, request a change of state transition to the manager. <p>
 * @return True if the FSM is inside SDF and the super classmethod returns true; otherwise return true if the postfire of the current state refinement returns true.
 * @exception IllegalActionException If a refinement throws it,if there is no controller.
 */
public boolean postfire() throws IllegalActionException {
  FSMActor controller=getController();
  State currentState=controller.currentState();
  CompositeActor container=(CompositeActor)getContainer();
  TypedActor[] currentRefinement=currentState.getRefinement();
  if (currentRefinement == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  boolean postfireReturn=currentRefinement[0].postfire();
  if (_sendRequest && !_embeddedInSDF) {
    _sendRequest=false;
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
      protected void _execute() throws KernelException {
        _sendRequest=true;
        makeStateTransition();
      }
    }
;
    request.setPersistent(false);
    container.requestChange(request);
  }
  if (_embeddedInSDF) {
    makeStateTransition();
  }
  return postfireReturn;
}","/** 
 * Make a state transition if this FSM is embedded in SDF. Otherwise, request a change of state transition to the manager. <p>
 * @return True if the FSM is inside SDF and the super classmethod returns true; otherwise return true if the postfire of the current state refinement returns true.
 * @exception IllegalActionException If a refinement throws it,if there is no controller.
 */
public boolean postfire() throws IllegalActionException {
  FSMActor controller=getController();
  State currentState=_previousIntransientState;
  CompositeActor container=(CompositeActor)getContainer();
  TypedActor[] currentRefinement=currentState.getRefinement();
  if (currentRefinement == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  boolean postfireReturn=currentRefinement[0].postfire();
  if (_sendRequest && !_embeddedInSDF) {
    _sendRequest=false;
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
      protected void _execute() throws KernelException {
        _sendRequest=true;
        makeStateTransition();
      }
    }
;
    request.setPersistent(false);
    container.requestChange(request);
  }
  if (_embeddedInSDF) {
    makeStateTransition();
  }
  return postfireReturn;
}"
75257,"/** 
 * Set the values of input variables in the mode controller. If the refinement of the current state of the mode controller is ready to fire, then fire the current refinement. Choose a transition if this FSM is embedded in SDF, otherwise request to choose a transition to the manager.
 * @exception IllegalActionException If there is no controller.
 */
public void fire() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  FSMActor controller=getController();
  controller.setNewIteration(_sendRequest);
  _readInputs();
  Transition transition;
  State state=controller.currentState();
  Actor[] actors=controller.currentState().getRefinement();
  _fireRefinement=false;
  if (actors != null) {
    for (int i=0; i < actors.length; ++i) {
      if (_stopRequested)       break;
      if (actors[i].prefire()) {
        actors[i].fire();
        actors[i].postfire();
      }
    }
  }
  _readOutputsFromRefinement();
  if (_embeddedInSDF) {
    state=chooseStateTransition(state);
    actors=state.getRefinement();
    while (actors == null) {
      super.postfire();
      state=chooseStateTransition(state);
      transition=_getLastChosenTransition();
      if (transition == null)       throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
      actors=(transition.destinationState()).getRefinement();
    }
  }
  if (_sendRequest && !_embeddedInSDF) {
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
      protected void _execute() throws KernelException, IllegalActionException {
        FSMActor controller=getController();
        State state=controller.currentState();
        TypedActor[] actors;
        Transition transition;
        state=chooseStateTransition(state);
        actors=state.getRefinement();
        while (actors == null) {
          superPostfire();
          state=chooseStateTransition(state);
          transition=_getLastChosenTransition();
          if (transition == null) {
            throwTransientException();
          }
 else {
            actors=(transition.destinationState()).getRefinement();
          }
        }
      }
    }
;
    request.setPersistent(false);
    container.requestChange(request);
  }
  return;
}","/** 
 * Set the values of input variables in the mode controller. If the refinement of the current state of the mode controller is ready to fire, then fire the current refinement. Choose a transition if this FSM is embedded in SDF, otherwise request to choose a transition to the manager.
 * @exception IllegalActionException If there is no controller.
 */
public void fire() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  FSMActor controller=getController();
  controller.setNewIteration(_sendRequest);
  _readInputs();
  Transition transition;
  State state=controller.currentState();
  _previousIntransientState=state;
  Actor[] actors=controller.currentState().getRefinement();
  _fireRefinement=false;
  if (actors != null) {
    for (int i=0; i < actors.length; ++i) {
      if (_stopRequested)       break;
      if (actors[i].prefire()) {
        actors[i].fire();
        actors[i].postfire();
      }
    }
  }
  _readOutputsFromRefinement();
  if (_embeddedInSDF) {
    state=chooseStateTransition(state);
    actors=state.getRefinement();
    while (actors == null) {
      super.postfire();
      state=chooseStateTransition(state);
      transition=_getLastChosenTransition();
      if (transition == null)       throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
      actors=(transition.destinationState()).getRefinement();
    }
  }
  if (_sendRequest && !_embeddedInSDF) {
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
      protected void _execute() throws KernelException, IllegalActionException {
        FSMActor controller=getController();
        State state=controller.currentState();
        TypedActor[] actors;
        Transition transition;
        state=chooseStateTransition(state);
        actors=state.getRefinement();
        while (actors == null) {
          superPostfire();
          state=chooseStateTransition(state);
          transition=_getLastChosenTransition();
          if (transition == null) {
            throwTransientException();
          }
 else {
            actors=(transition.destinationState()).getRefinement();
          }
        }
      }
    }
;
    request.setPersistent(false);
    container.requestChange(request);
  }
  return;
}"
75258,"private boolean _inlineMethodCalls(SootClass entityClass,ComponentEntity entity,SootMethod method,JimpleBody body,PortInliner inliner,boolean debug){
  if (debug)   System.out.println(""String_Node_Str"" + method);
  boolean doneSomething=false;
  NamedObjAnalysis analysis=new NamedObjAnalysis(method,entity);
  for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
    Stmt stmt=(Stmt)units.next();
    if (!stmt.containsInvokeExpr()) {
      continue;
    }
    ValueBox box=stmt.getInvokeExprBox();
    Value value=stmt.getInvokeExpr();
    if (value instanceof InstanceInvokeExpr) {
      InstanceInvokeExpr r=(InstanceInvokeExpr)value;
      if (r.getBase().getType() instanceof RefType) {
        RefType type=(RefType)r.getBase().getType();
        if (r.getMethod().equals(PtolemyUtilities.connectionsChangedMethod)) {
          if (type.getSootClass().isApplicationClass()) {
            SootMethod inlinee=null;
            if (r instanceof VirtualInvokeExpr) {
              List methodList=Scene.v().getActiveHierarchy().resolveAbstractDispatch(type.getSootClass(),PtolemyUtilities.connectionsChangedMethod);
              if (methodList.size() == 1) {
                inlinee=(SootMethod)methodList.get(0);
              }
 else {
                String string=""String_Node_Str"" + stmt + ""String_Node_Str""+ method+ ""String_Node_Str"";
                for (int i=0; i < methodList.size(); i++) {
                  string+=""String_Node_Str"" + methodList.get(i) + ""String_Node_Str"";
                }
                System.out.println(string);
              }
            }
 else             if (r instanceof SpecialInvokeExpr) {
              inlinee=Scene.v().getActiveHierarchy().resolveSpecialDispatch((SpecialInvokeExpr)r,method);
            }
            if (!inlinee.getDeclaringClass().isApplicationClass()) {
              inlinee.getDeclaringClass().setLibraryClass();
            }
            inlinee.retrieveActiveBody();
            if (debug)             System.out.println(""String_Node_Str"" + r);
            SiteInliner.inlineSite(inlinee,stmt,method);
            doneSomething=true;
          }
 else {
            body.getUnits().remove(stmt);
            doneSomething=true;
          }
        }
        Value argValues[]=new Value[r.getArgCount()];
        int constantArgCount=0;
        for (Iterator args=r.getArgs().iterator(); args.hasNext(); ) {
          Value arg=(Value)args.next();
          if (Evaluator.isValueConstantValued(arg)) {
            argValues[constantArgCount++]=Evaluator.getConstantValueOf(arg);
          }
 else {
            break;
          }
        }
        boolean allArgsAreConstant=(r.getArgCount() == constantArgCount);
        if (SootUtilities.derivesFrom(type.getSootClass(),PtolemyUtilities.componentPortClass)) {
          TypedIOPort port=(TypedIOPort)analysis.getObject((Local)r.getBase());
          if (port == null) {
            continue;
          }
          if (port instanceof Typeable) {
            PtolemyUtilities.inlineTypeableMethods(body,stmt,box,r,(Typeable)port);
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getFullNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getFullName()));
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getName()));
          }
          String methodName=r.getMethod().getName();
          if (port.getWidth() == 0 && (methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"")|| methodName.equals(""String_Node_Str""))) {
            Local local=SootUtilities.createRuntimeException(body,stmt,methodName + ""String_Node_Str"" + port.getFullName()+ ""String_Node_Str"");
            body.getUnits().insertBefore(Jimple.v().newThrowStmt(local),stmt);
            if (stmt instanceof DefinitionStmt) {
              if (methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"")) {
                box.setValue(IntConstant.v(0));
              }
 else {
                box.setValue(NullConstant.v());
              }
            }
 else {
              body.getUnits().remove(stmt);
            }
            continue;
          }
          if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            if (port.isInput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            if (port.isOutput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            if (port.isMultiport()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            Object object=SootUtilities.reflectAndInvokeMethod(port,r.getMethod(),argValues);
            Constant constant=SootUtilities.convertArgumentToConstantValue(object);
            box.setValue(constant);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            inliner.inlineGet(body,stmt,box,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            inliner.inlineSend(body,stmt,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.getWidth() == 0) {
              if (debug) {
                System.out.println(""String_Node_Str"" + stmt);
              }
              body.getUnits().remove(stmt);
            }
 else {
              if (debug) {
                System.out.println(""String_Node_Str"" + stmt);
              }
              inliner.inlineBroadcast(body,stmt,r,port);
            }
          }
        }
      }
    }
  }
  return doneSomething;
}","private boolean _inlineMethodCalls(SootClass entityClass,ComponentEntity entity,SootMethod method,JimpleBody body,PortInliner inliner,boolean debug){
  if (debug)   System.out.println(""String_Node_Str"" + method);
  boolean doneSomething=false;
  NamedObjAnalysis analysis=new NamedObjAnalysis(method,entity);
  for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
    Stmt stmt=(Stmt)units.next();
    if (!stmt.containsInvokeExpr()) {
      continue;
    }
    ValueBox box=stmt.getInvokeExprBox();
    Value value=stmt.getInvokeExpr();
    if (value instanceof InstanceInvokeExpr) {
      InstanceInvokeExpr r=(InstanceInvokeExpr)value;
      if (r.getBase().getType() instanceof RefType) {
        RefType type=(RefType)r.getBase().getType();
        if (r.getMethod().equals(PtolemyUtilities.connectionsChangedMethod)) {
          if (type.getSootClass().isApplicationClass()) {
            SootMethod inlinee=null;
            if (r instanceof VirtualInvokeExpr) {
              List methodList=Scene.v().getActiveHierarchy().resolveAbstractDispatch(type.getSootClass(),PtolemyUtilities.connectionsChangedMethod);
              if (methodList.size() == 1) {
                inlinee=(SootMethod)methodList.get(0);
              }
 else {
                String string=""String_Node_Str"" + stmt + ""String_Node_Str""+ method+ ""String_Node_Str"";
                for (int i=0; i < methodList.size(); i++) {
                  string+=""String_Node_Str"" + methodList.get(i) + ""String_Node_Str"";
                }
                System.out.println(string);
              }
            }
 else             if (r instanceof SpecialInvokeExpr) {
              inlinee=Scene.v().getActiveHierarchy().resolveSpecialDispatch((SpecialInvokeExpr)r,method);
            }
            if (!inlinee.getDeclaringClass().isApplicationClass()) {
              inlinee.getDeclaringClass().setLibraryClass();
            }
            inlinee.retrieveActiveBody();
            if (debug)             System.out.println(""String_Node_Str"" + r);
            SiteInliner.inlineSite(inlinee,stmt,method);
            doneSomething=true;
          }
 else {
            body.getUnits().remove(stmt);
            doneSomething=true;
          }
        }
        Value argValues[]=new Value[r.getArgCount()];
        int constantArgCount=0;
        for (Iterator args=r.getArgs().iterator(); args.hasNext(); ) {
          Value arg=(Value)args.next();
          if (Evaluator.isValueConstantValued(arg)) {
            argValues[constantArgCount++]=Evaluator.getConstantValueOf(arg);
          }
 else {
            break;
          }
        }
        boolean allArgsAreConstant=(r.getArgCount() == constantArgCount);
        if (SootUtilities.derivesFrom(type.getSootClass(),PtolemyUtilities.componentPortClass)) {
          TypedIOPort port=(TypedIOPort)analysis.getObject((Local)r.getBase());
          if (port == null) {
            continue;
          }
          if (port instanceof Typeable) {
            PtolemyUtilities.inlineTypeableMethods(body,stmt,box,r,(Typeable)port);
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getFullNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getFullName()));
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getName()));
          }
          String methodName=r.getMethod().getName();
          if (port.getWidth() == 0 && (methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"")|| methodName.equals(""String_Node_Str""))) {
            Local local=SootUtilities.createRuntimeException(body,stmt,methodName + ""String_Node_Str"" + port.getFullName()+ ""String_Node_Str"");
            body.getUnits().insertBefore(Jimple.v().newThrowStmt(local),stmt);
            if (stmt instanceof DefinitionStmt) {
              if (methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"")) {
                box.setValue(IntConstant.v(0));
              }
 else {
                box.setValue(NullConstant.v());
              }
            }
 else {
              body.getUnits().remove(stmt);
            }
            continue;
          }
          if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            if (port.isInput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            if (port.isOutput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            if (port.isMultiport()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"") || r.getMethod().getName().equals(""String_Node_Str"") || r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            Object object=SootUtilities.reflectAndInvokeMethod(port,r.getMethod(),argValues);
            Constant constant=SootUtilities.convertArgumentToConstantValue(object);
            box.setValue(constant);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            inliner.inlineGet(body,stmt,box,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (debug) {
              System.out.println(""String_Node_Str"" + stmt);
            }
            inliner.inlineSend(body,stmt,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.getWidth() == 0) {
              if (debug) {
                System.out.println(""String_Node_Str"" + stmt);
              }
              body.getUnits().remove(stmt);
            }
 else {
              if (debug) {
                System.out.println(""String_Node_Str"" + stmt);
              }
              inliner.inlineBroadcast(body,stmt,r,port);
            }
          }
        }
      }
    }
  }
  return doneSomething;
}"
75259,"protected void internalTransform(String phaseName,Map options){
  int localCount=0;
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    for (Iterator methods=theClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt unit=(Stmt)units.next();
        if (unit.containsFieldRef()) {
          ValueBox box=unit.getFieldRefBox();
          Value value=box.getValue();
          if (value instanceof InstanceFieldRef) {
            InstanceFieldRef fieldRef=(InstanceFieldRef)value;
            SootField field=fieldRef.getField();
            if (field.getSubSignature().equals(PtolemyUtilities.debuggingField.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(((AssignStmt)unit).getLeftOp(),IntConstant.v(0)),unit);
              }
              body.getUnits().remove(unit);
            }
          }
        }
 else         if (unit.containsInvokeExpr()) {
          ValueBox box=unit.getInvokeExprBox();
          Value value=box.getValue();
          if ((value instanceof InvokeExpr) && !(value instanceof SpecialInvokeExpr)) {
            InvokeExpr expr=(InvokeExpr)value;
            if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.attachTextMethod.getSubSignature())) {
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.setNameMethod.getSubSignature())) {
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getName().equals(""String_Node_Str"")) {
              body.getUnits().remove(unit);
            }
            if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.getFullNameMethod.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(((AssignStmt)unit).getLeftOp(),StringConstant.v(_model.getFullName())),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.getNameMethod.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(((AssignStmt)unit).getLeftOp(),StringConstant.v(_model.getName())),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.findEffigyMethod.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(((AssignStmt)unit).getLeftOp(),NullConstant.v()),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.getModelURIMethod.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                SootClass uriClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
                RefType type=RefType.v(uriClass);
                SootMethod initMethod=uriClass.getMethod(""String_Node_Str"");
                Local local=(Local)((AssignStmt)unit).getLeftOp();
                String uriString=URIAttribute.getModelURI(_model).toString();
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(local,Jimple.v().newNewExpr(type)),unit);
                body.getUnits().insertBefore(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(local,initMethod,StringConstant.v(uriString))),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.handleModelErrorMethod.getSubSignature())) {
              body.getUnits().insertBefore(Jimple.v().newThrowStmt(expr.getArg(1)),unit);
              body.getUnits().remove(unit);
            }
          }
        }
      }
    }
  }
  List modifiedConstructorClassList=new LinkedList();
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    if (SootUtilities.derivesFrom(theClass,PtolemyUtilities.actorClass) || SootUtilities.derivesFrom(theClass,PtolemyUtilities.compositeActorClass) || SootUtilities.derivesFrom(theClass,PtolemyUtilities.attributeClass)) {
      theClass.setSuperclass(PtolemyUtilities.objectClass);
      SootMethod method=null;
      try {
        method=theClass.getMethodByName(""String_Node_Str"");
      }
 catch (      RuntimeException ex) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + theClass);
        System.out.println(""String_Node_Str"" + theClass.getMethods());
        throw ex;
      }
      if (method.getParameterCount() == 2) {
        SootField containerField=theClass.getFieldByName(ModelTransformer.getContainerFieldName());
        RefType containerType=(RefType)containerField.getType();
        List typeList=new LinkedList();
        typeList.add(containerType);
        method.setParameterTypes(typeList);
      }
 else {
        method.setParameterTypes(Collections.EMPTY_LIST);
      }
      modifiedConstructorClassList.add(theClass);
      theClass.removeMethod(method);
      theClass.addMethod(method);
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt unit=(Stmt)units.next();
        if (unit.containsInvokeExpr()) {
          ValueBox box=unit.getInvokeExprBox();
          Value value=box.getValue();
          if (value instanceof SpecialInvokeExpr) {
            SpecialInvokeExpr expr=(SpecialInvokeExpr)value;
            if (expr.getBase().equals(body.getThisLocal()) && expr.getMethod().getName().equals(""String_Node_Str"")) {
              box.setValue(Jimple.v().newSpecialInvokeExpr((Local)expr.getBase(),PtolemyUtilities.objectConstructor,Collections.EMPTY_LIST));
            }
          }
        }
 else         if (unit instanceof IdentityStmt) {
          IdentityStmt identityStmt=(IdentityStmt)unit;
          Value value=identityStmt.getRightOp();
          if (value instanceof ParameterRef) {
            ParameterRef parameterRef=(ParameterRef)value;
            if (parameterRef.getIndex() == 0 && method.getParameterCount() == 1) {
              ValueBox box=identityStmt.getRightOpBox();
              box.setValue(Jimple.v().newParameterRef(method.getParameterType(0),0));
            }
 else {
              body.getUnits().remove(identityStmt);
              body.getUnits().insertBefore(Jimple.v().newAssignStmt(identityStmt.getLeftOp(),NullConstant.v()),body.getFirstNonIdentityStmt());
            }
          }
        }
      }
    }
  }
  Scene.v().setActiveHierarchy(new Hierarchy());
  Scene.v().setFastHierarchy(new FastHierarchy());
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    for (Iterator methods=theClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt unit=(Stmt)units.next();
        if (unit.containsInvokeExpr()) {
          ValueBox box=unit.getInvokeExprBox();
          Value value=box.getValue();
          if (value instanceof SpecialInvokeExpr) {
            SpecialInvokeExpr expr=(SpecialInvokeExpr)value;
            SootClass declaringClass=expr.getMethod().getDeclaringClass();
            if (expr.getMethod().getName().equals(""String_Node_Str"") && modifiedConstructorClassList.contains(declaringClass)) {
              SootMethod newConstructor=declaringClass.getMethodByName(""String_Node_Str"");
              if (newConstructor.getParameterCount() == 1) {
                List args=new LinkedList();
                args.add(expr.getArg(0));
                box.setValue(Jimple.v().newSpecialInvokeExpr((Local)expr.getBase(),newConstructor,args));
              }
 else {
                box.setValue(Jimple.v().newSpecialInvokeExpr((Local)expr.getBase(),newConstructor,Collections.EMPTY_LIST));
              }
            }
          }
        }
      }
    }
  }
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    for (Iterator methods=theClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      LocalSplitter.v().transform(body,""String_Node_Str"");
      TypeAssigner.v().transform(body,""String_Node_Str"");
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt unit=(Stmt)units.next();
        for (Iterator boxes=unit.getUseAndDefBoxes().iterator(); boxes.hasNext(); ) {
          ValueBox box=(ValueBox)boxes.next();
          Value value=box.getValue();
          Type type=value.getType();
          if (_isRemovableType(type)) {
            body.getUnits().remove(unit);
            break;
          }
        }
        for (Iterator locals=body.getLocals().snapshotIterator(); locals.hasNext(); ) {
          Local local=(Local)locals.next();
          Type type=local.getType();
          if (_isRemovableType(type)) {
            body.getLocals().remove(local);
          }
        }
      }
      for (Iterator fields=theClass.getFields().snapshotIterator(); fields.hasNext(); ) {
        SootField field=(SootField)fields.next();
        Type type=field.getType();
        if (_isRemovableType(type)) {
          theClass.getFields().remove(field);
        }
      }
    }
  }
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    for (Iterator interfaces=theClass.getInterfaces().snapshotIterator(); interfaces.hasNext(); ) {
      SootClass theInterface=(SootClass)interfaces.next();
      if (theInterface.equals(PtolemyUtilities.inequalityTermClass)) {
        theClass.getInterfaces().remove(theInterface);
      }
      if (theInterface.equals(PtolemyUtilities.explicitChangeContextClass)) {
        theClass.getInterfaces().remove(theInterface);
      }
    }
  }
}","protected void internalTransform(String phaseName,Map options){
  int localCount=0;
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    for (Iterator methods=theClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt unit=(Stmt)units.next();
        if (unit.containsFieldRef()) {
          ValueBox box=unit.getFieldRefBox();
          Value value=box.getValue();
          if (value instanceof InstanceFieldRef) {
            InstanceFieldRef fieldRef=(InstanceFieldRef)value;
            SootField field=fieldRef.getField();
            if (field.getSubSignature().equals(PtolemyUtilities.debuggingField.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(((AssignStmt)unit).getLeftOp(),IntConstant.v(0)),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (field.getSubSignature().equals(PtolemyUtilities.stopRequestedField.getSubSignature())) {
              if (unit instanceof AssignStmt && box == ((AssignStmt)unit).getLeftOpBox()) {
                body.getUnits().remove(unit);
              }
 else {
                box.setValue(IntConstant.v(0));
              }
            }
          }
        }
 else         if (unit.containsInvokeExpr()) {
          ValueBox box=unit.getInvokeExprBox();
          Value value=box.getValue();
          if ((value instanceof InvokeExpr) && !(value instanceof SpecialInvokeExpr)) {
            InvokeExpr expr=(InvokeExpr)value;
            if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.attachTextMethod.getSubSignature())) {
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.setNameMethod.getSubSignature())) {
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getName().equals(""String_Node_Str"")) {
              body.getUnits().remove(unit);
            }
            if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.getFullNameMethod.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(((AssignStmt)unit).getLeftOp(),StringConstant.v(_model.getFullName())),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.getNameMethod.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(((AssignStmt)unit).getLeftOp(),StringConstant.v(_model.getName())),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.findEffigyMethod.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(((AssignStmt)unit).getLeftOp(),NullConstant.v()),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.getModelURIMethod.getSubSignature())) {
              if (unit instanceof AssignStmt) {
                SootClass uriClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
                RefType type=RefType.v(uriClass);
                SootMethod initMethod=uriClass.getMethod(""String_Node_Str"");
                Local local=(Local)((AssignStmt)unit).getLeftOp();
                String uriString=URIAttribute.getModelURI(_model).toString();
                body.getUnits().insertBefore(Jimple.v().newAssignStmt(local,Jimple.v().newNewExpr(type)),unit);
                body.getUnits().insertBefore(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(local,initMethod,StringConstant.v(uriString))),unit);
              }
              body.getUnits().remove(unit);
            }
 else             if (expr.getMethod().getSubSignature().equals(PtolemyUtilities.handleModelErrorMethod.getSubSignature())) {
              body.getUnits().insertBefore(Jimple.v().newThrowStmt(expr.getArg(1)),unit);
              body.getUnits().remove(unit);
            }
          }
        }
      }
    }
  }
  List modifiedConstructorClassList=new LinkedList();
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    if (SootUtilities.derivesFrom(theClass,PtolemyUtilities.actorClass) || SootUtilities.derivesFrom(theClass,PtolemyUtilities.compositeActorClass) || SootUtilities.derivesFrom(theClass,PtolemyUtilities.attributeClass)) {
      theClass.setSuperclass(PtolemyUtilities.objectClass);
      SootMethod method=null;
      try {
        method=theClass.getMethodByName(""String_Node_Str"");
      }
 catch (      RuntimeException ex) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + theClass);
        System.out.println(""String_Node_Str"" + theClass.getMethods());
        throw ex;
      }
      if (method.getParameterCount() == 2) {
        SootField containerField=theClass.getFieldByName(ModelTransformer.getContainerFieldName());
        RefType containerType=(RefType)containerField.getType();
        List typeList=new LinkedList();
        typeList.add(containerType);
        method.setParameterTypes(typeList);
      }
 else {
        method.setParameterTypes(Collections.EMPTY_LIST);
      }
      modifiedConstructorClassList.add(theClass);
      theClass.removeMethod(method);
      theClass.addMethod(method);
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt unit=(Stmt)units.next();
        if (unit.containsInvokeExpr()) {
          ValueBox box=unit.getInvokeExprBox();
          Value value=box.getValue();
          if (value instanceof SpecialInvokeExpr) {
            SpecialInvokeExpr expr=(SpecialInvokeExpr)value;
            if (expr.getBase().equals(body.getThisLocal()) && expr.getMethod().getName().equals(""String_Node_Str"")) {
              box.setValue(Jimple.v().newSpecialInvokeExpr((Local)expr.getBase(),PtolemyUtilities.objectConstructor,Collections.EMPTY_LIST));
            }
          }
        }
 else         if (unit instanceof IdentityStmt) {
          IdentityStmt identityStmt=(IdentityStmt)unit;
          Value value=identityStmt.getRightOp();
          if (value instanceof ParameterRef) {
            ParameterRef parameterRef=(ParameterRef)value;
            if (parameterRef.getIndex() == 0 && method.getParameterCount() == 1) {
              ValueBox box=identityStmt.getRightOpBox();
              box.setValue(Jimple.v().newParameterRef(method.getParameterType(0),0));
            }
 else {
              body.getUnits().remove(identityStmt);
              body.getUnits().insertBefore(Jimple.v().newAssignStmt(identityStmt.getLeftOp(),NullConstant.v()),body.getFirstNonIdentityStmt());
            }
          }
        }
      }
    }
  }
  Scene.v().setActiveHierarchy(new Hierarchy());
  Scene.v().setFastHierarchy(new FastHierarchy());
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    for (Iterator methods=theClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt unit=(Stmt)units.next();
        if (unit.containsInvokeExpr()) {
          ValueBox box=unit.getInvokeExprBox();
          Value value=box.getValue();
          if (value instanceof SpecialInvokeExpr) {
            SpecialInvokeExpr expr=(SpecialInvokeExpr)value;
            SootClass declaringClass=expr.getMethod().getDeclaringClass();
            if (expr.getMethod().getName().equals(""String_Node_Str"") && modifiedConstructorClassList.contains(declaringClass)) {
              SootMethod newConstructor=declaringClass.getMethodByName(""String_Node_Str"");
              if (newConstructor.getParameterCount() == 1) {
                List args=new LinkedList();
                args.add(expr.getArg(0));
                box.setValue(Jimple.v().newSpecialInvokeExpr((Local)expr.getBase(),newConstructor,args));
              }
 else {
                box.setValue(Jimple.v().newSpecialInvokeExpr((Local)expr.getBase(),newConstructor,Collections.EMPTY_LIST));
              }
            }
          }
        }
      }
    }
  }
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    for (Iterator methods=theClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      LocalSplitter.v().transform(body,""String_Node_Str"");
      TypeAssigner.v().transform(body,""String_Node_Str"");
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt unit=(Stmt)units.next();
        for (Iterator boxes=unit.getUseAndDefBoxes().iterator(); boxes.hasNext(); ) {
          ValueBox box=(ValueBox)boxes.next();
          Value value=box.getValue();
          Type type=value.getType();
          if (_isRemovableType(type)) {
            body.getUnits().remove(unit);
            break;
          }
        }
        for (Iterator locals=body.getLocals().snapshotIterator(); locals.hasNext(); ) {
          Local local=(Local)locals.next();
          Type type=local.getType();
          if (_isRemovableType(type)) {
            body.getLocals().remove(local);
          }
        }
      }
      for (Iterator fields=theClass.getFields().snapshotIterator(); fields.hasNext(); ) {
        SootField field=(SootField)fields.next();
        Type type=field.getType();
        if (_isRemovableType(type)) {
          theClass.getFields().remove(field);
        }
      }
    }
  }
  for (Iterator i=Scene.v().getApplicationClasses().iterator(); i.hasNext(); ) {
    SootClass theClass=(SootClass)i.next();
    for (Iterator interfaces=theClass.getInterfaces().snapshotIterator(); interfaces.hasNext(); ) {
      SootClass theInterface=(SootClass)interfaces.next();
      if (theInterface.equals(PtolemyUtilities.inequalityTermClass)) {
        theClass.getInterfaces().remove(theInterface);
      }
      if (theInterface.equals(PtolemyUtilities.explicitChangeContextClass)) {
        theClass.getInterfaces().remove(theInterface);
      }
    }
  }
}"
75260,"/** 
 * Initialize the fields of this class to point to classes in the current soot tree.
 */
public static void loadSootReferences(){
  objectClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  classClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  toStringMethod=objectClass.getMethod(""String_Node_Str"");
  getClassMethod=objectClass.getMethod(""String_Node_Str"");
  objectConstructor=objectClass.getMethod(""String_Node_Str"");
  stringClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  systemClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  arraycopyMethod=systemClass.getMethodByName(""String_Node_Str"");
  namedObjClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  debuggingField=namedObjClass.getField(""String_Node_Str"");
  getAttributeMethod=namedObjClass.getMethod(""String_Node_Str"" + ""String_Node_Str"");
  attributeChangedMethod=namedObjClass.getMethod(""String_Node_Str"");
  attachTextMethod=namedObjClass.getMethod(""String_Node_Str"");
  getFullNameMethod=namedObjClass.getMethod(""String_Node_Str"");
  setNameMethod=namedObjClass.getMethod(""String_Node_Str"");
  getNameMethod=namedObjClass.getMethod(""String_Node_Str"");
  toplevelMethod=namedObjClass.getMethod(""String_Node_Str"");
  handleModelErrorMethod=namedObjClass.getMethod(""String_Node_Str"");
  getContainerMethod=Scene.v().getMethod(""String_Node_Str"");
  getModelURIMethod=Scene.v().loadClassAndSupport(""String_Node_Str"").getMethod(""String_Node_Str"");
  attributeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  attributeType=RefType.v(attributeClass);
  settableClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  settableType=RefType.v(settableClass);
  setExpressionMethod=settableClass.getMethodByName(""String_Node_Str"");
  getExpressionMethod=settableClass.getMethod(""String_Node_Str"");
  validateMethod=settableClass.getMethod(""String_Node_Str"");
  stringAttributeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  parameterClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  variableClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  variableConstructorWithoutToken=variableClass.getMethod(""String_Node_Str"");
  variableConstructorWithToken=variableClass.getMethod(""String_Node_Str"");
  variableSetTokenMethod=variableClass.getMethod(""String_Node_Str"");
  variableGetTokenMethod=variableClass.getMethod(""String_Node_Str"");
  entityClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  entityType=RefType.v(PtolemyUtilities.entityClass);
  connectionsChangedMethod=entityClass.getMethod(""String_Node_Str"");
  getPortMethod=entityClass.getMethod(""String_Node_Str"");
  componentEntityClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  componentEntityType=RefType.v(PtolemyUtilities.componentEntityClass);
  compositeEntityClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  getEntityMethod=compositeEntityClass.getMethod(""String_Node_Str"");
  executableInterface=Scene.v().loadClassAndSupport(""String_Node_Str"");
  executablePrefireMethod=executableInterface.getMethodByName(""String_Node_Str"");
  executableFireMethod=executableInterface.getMethodByName(""String_Node_Str"");
  executablePostfireMethod=executableInterface.getMethodByName(""String_Node_Str"");
  actorClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  actorType=RefType.v(actorClass);
  getDirectorMethod=Scene.v().getMethod(""String_Node_Str"");
  invalidateResolvedTypesMethod=Scene.v().getMethod(""String_Node_Str"");
  compositeActorClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  portClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  componentPortClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  componentPortType=RefType.v(componentPortClass);
  relationClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  relationType=RefType.v(relationClass);
  ioportClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  ioportType=RefType.v(ioportClass);
  portParameterClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  portParameterGetPortMethod=Scene.v().getMethod(""String_Node_Str"");
  portParameterUpdateMethod=Scene.v().getMethod(""String_Node_Str"");
  portSetTypeMethod=Scene.v().getMethod(""String_Node_Str"");
  insertLinkMethod=SootUtilities.searchForMethodByName(componentPortClass,""String_Node_Str"");
  setInputMethod=Scene.v().getMethod(""String_Node_Str"");
  setOutputMethod=Scene.v().getMethod(""String_Node_Str"");
  setMultiportMethod=Scene.v().getMethod(""String_Node_Str"");
  getMethod=Scene.v().getMethod(""String_Node_Str"");
  getInsideMethod=Scene.v().getMethod(""String_Node_Str"");
  hasTokenMethod=Scene.v().getMethod(""String_Node_Str"");
  sendMethod=Scene.v().getMethod(""String_Node_Str"");
  sendInsideMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  tokenType=RefType.v(tokenClass);
  tokenGetTypeMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenZeroMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenAddMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenSubtractMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenModuloMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenMultiplyMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenDivideMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenEqualsMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenIsLessThanMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenNotMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenBitwiseAndMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenBitwiseOrMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenBitwiseXorMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenBitwiseNotMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenLeftShiftMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenRightShiftMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenLogicalRightShiftMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenIntValueMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenPowMethod=Scene.v().getMethod(""String_Node_Str"");
  arrayTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  arrayTokenConstructor=arrayTokenClass.getMethod(""String_Node_Str"");
  arrayValueMethod=arrayTokenClass.getMethod(""String_Node_Str"");
  arrayGetElementMethod=arrayTokenClass.getMethod(""String_Node_Str"");
  recordTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  recordTokenConstructor=recordTokenClass.getMethod(""String_Node_Str"");
  recordGetMethod=recordTokenClass.getMethod(""String_Node_Str"");
  scalarTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  matrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  matrixTokenCreateMethod=matrixTokenClass.getMethod(""String_Node_Str"");
  matrixGetElementAsTokenMethod=matrixTokenClass.getMethod(""String_Node_Str"");
  doubleTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  doubleTokenConstructor=doubleTokenClass.getMethod(""String_Node_Str"");
  doubleValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  doubleMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  doubleMatrixTokenConstructor=doubleMatrixTokenClass.getMethod(""String_Node_Str"");
  doubleMatrixTokenArrayConstructor=doubleMatrixTokenClass.getMethod(""String_Node_Str"");
  doubleMatrixMethod=doubleMatrixTokenClass.getMethod(""String_Node_Str"");
  booleanTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  booleanTokenConstructor=booleanTokenClass.getMethod(""String_Node_Str"");
  booleanValueMethod=booleanTokenClass.getMethod(""String_Node_Str"");
  booleanMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  booleanMatrixTokenConstructor=booleanMatrixTokenClass.getMethod(""String_Node_Str"");
  booleanMatrixTokenArrayConstructor=booleanMatrixTokenClass.getMethod(""String_Node_Str"");
  booleanMatrixMethod=booleanMatrixTokenClass.getMethod(""String_Node_Str"");
  unsignedByteTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  unsignedByteTokenConstructor=unsignedByteTokenClass.getMethod(""String_Node_Str"");
  unsignedByteValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  intTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  intTokenConstructor=intTokenClass.getMethod(""String_Node_Str"");
  intValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  intMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  intMatrixTokenConstructor=intMatrixTokenClass.getMethod(""String_Node_Str"");
  intMatrixTokenArrayConstructor=intMatrixTokenClass.getMethod(""String_Node_Str"");
  intMatrixMethod=intMatrixTokenClass.getMethod(""String_Node_Str"");
  fixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  fixTokenConstructor=fixTokenClass.getMethod(""String_Node_Str"");
  fixTokenThreeArgConstructor=fixTokenClass.getMethod(""String_Node_Str"");
  fixValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  fixMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  fixMatrixTokenConstructor=fixMatrixTokenClass.getMethod(""String_Node_Str"");
  fixMatrixTokenArrayConstructor=fixMatrixTokenClass.getMethod(""String_Node_Str"");
  fixMatrixMethod=fixMatrixTokenClass.getMethod(""String_Node_Str"");
  complexTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  complexTokenConstructor=complexTokenClass.getMethod(""String_Node_Str"");
  complexValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  complexMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  complexMatrixTokenArrayConstructor=complexMatrixTokenClass.getMethod(""String_Node_Str"");
  complexMatrixMethod=matrixTokenClass.getMethod(""String_Node_Str"");
  longTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  longTokenConstructor=longTokenClass.getMethod(""String_Node_Str"");
  longValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  longMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  longMatrixTokenConstructor=longMatrixTokenClass.getMethod(""String_Node_Str"");
  longMatrixTokenArrayConstructor=longMatrixTokenClass.getMethod(""String_Node_Str"");
  longMatrixMethod=longMatrixTokenClass.getMethod(""String_Node_Str"");
  stringTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  stringTokenConstructor=stringTokenClass.getMethod(""String_Node_Str"");
  stringValueMethod=stringTokenClass.getMethod(""String_Node_Str"");
  typeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  typeConvertMethod=typeClass.getMethod(""String_Node_Str"");
  arrayTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  fixTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  recordTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  baseTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  matrixTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  unknownTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  generalTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  booleanTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  booleanMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  byteTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  complexTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  complexMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  doubleTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  doubleMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  fixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  fixMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  intTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  intMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  longTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  longMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  objectTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  stringTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  typeLatticeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  kernelExceptionClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  kernelRuntimeExceptionClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  runtimeExceptionClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  exceptionClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  runtimeExceptionConstructor=runtimeExceptionClass.getMethod(""String_Node_Str"");
  runtimeExceptionStringConstructor=runtimeExceptionClass.getMethod(""String_Node_Str"");
  managerClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  findEffigyMethod=Scene.v().getMethod(""String_Node_Str"");
  inequalityTermClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  explicitChangeContextClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  functionTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  functionTokenApplyMethod=functionTokenClass.getMethod(""String_Node_Str"");
  functionTokenConstructor=functionTokenClass.getMethod(""String_Node_Str"");
  functionInterface=Scene.v().loadClassAndSupport(""String_Node_Str"");
  functionTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
}","/** 
 * Initialize the fields of this class to point to classes in the current soot tree.
 */
public static void loadSootReferences(){
  objectClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  classClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  toStringMethod=objectClass.getMethod(""String_Node_Str"");
  getClassMethod=objectClass.getMethod(""String_Node_Str"");
  objectConstructor=objectClass.getMethod(""String_Node_Str"");
  stringClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  systemClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  arraycopyMethod=systemClass.getMethodByName(""String_Node_Str"");
  namedObjClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  debuggingField=namedObjClass.getField(""String_Node_Str"");
  atomicActorClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  stopRequestedField=atomicActorClass.getField(""String_Node_Str"");
  getAttributeMethod=namedObjClass.getMethod(""String_Node_Str"" + ""String_Node_Str"");
  attributeChangedMethod=namedObjClass.getMethod(""String_Node_Str"");
  attachTextMethod=namedObjClass.getMethod(""String_Node_Str"");
  getFullNameMethod=namedObjClass.getMethod(""String_Node_Str"");
  setNameMethod=namedObjClass.getMethod(""String_Node_Str"");
  getNameMethod=namedObjClass.getMethod(""String_Node_Str"");
  toplevelMethod=namedObjClass.getMethod(""String_Node_Str"");
  handleModelErrorMethod=namedObjClass.getMethod(""String_Node_Str"");
  getContainerMethod=Scene.v().getMethod(""String_Node_Str"");
  getModelURIMethod=Scene.v().loadClassAndSupport(""String_Node_Str"").getMethod(""String_Node_Str"");
  attributeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  attributeType=RefType.v(attributeClass);
  settableClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  settableType=RefType.v(settableClass);
  setExpressionMethod=settableClass.getMethodByName(""String_Node_Str"");
  getExpressionMethod=settableClass.getMethod(""String_Node_Str"");
  validateMethod=settableClass.getMethod(""String_Node_Str"");
  stringAttributeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  parameterClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  variableClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  variableConstructorWithoutToken=variableClass.getMethod(""String_Node_Str"");
  variableConstructorWithToken=variableClass.getMethod(""String_Node_Str"");
  variableSetTokenMethod=variableClass.getMethod(""String_Node_Str"");
  variableGetTokenMethod=variableClass.getMethod(""String_Node_Str"");
  entityClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  entityType=RefType.v(PtolemyUtilities.entityClass);
  connectionsChangedMethod=entityClass.getMethod(""String_Node_Str"");
  getPortMethod=entityClass.getMethod(""String_Node_Str"");
  componentEntityClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  componentEntityType=RefType.v(PtolemyUtilities.componentEntityClass);
  compositeEntityClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  getEntityMethod=compositeEntityClass.getMethod(""String_Node_Str"");
  executableInterface=Scene.v().loadClassAndSupport(""String_Node_Str"");
  executablePrefireMethod=executableInterface.getMethodByName(""String_Node_Str"");
  executableFireMethod=executableInterface.getMethodByName(""String_Node_Str"");
  executablePostfireMethod=executableInterface.getMethodByName(""String_Node_Str"");
  actorClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  actorType=RefType.v(actorClass);
  getDirectorMethod=Scene.v().getMethod(""String_Node_Str"");
  invalidateResolvedTypesMethod=Scene.v().getMethod(""String_Node_Str"");
  compositeActorClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  portClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  componentPortClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  componentPortType=RefType.v(componentPortClass);
  relationClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  relationType=RefType.v(relationClass);
  ioportClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  ioportType=RefType.v(ioportClass);
  portParameterClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  portParameterGetPortMethod=Scene.v().getMethod(""String_Node_Str"");
  portParameterUpdateMethod=Scene.v().getMethod(""String_Node_Str"");
  portSetTypeMethod=Scene.v().getMethod(""String_Node_Str"");
  insertLinkMethod=SootUtilities.searchForMethodByName(componentPortClass,""String_Node_Str"");
  setInputMethod=Scene.v().getMethod(""String_Node_Str"");
  setOutputMethod=Scene.v().getMethod(""String_Node_Str"");
  setMultiportMethod=Scene.v().getMethod(""String_Node_Str"");
  getMethod=Scene.v().getMethod(""String_Node_Str"");
  getInsideMethod=Scene.v().getMethod(""String_Node_Str"");
  hasTokenMethod=Scene.v().getMethod(""String_Node_Str"");
  sendMethod=Scene.v().getMethod(""String_Node_Str"");
  sendInsideMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  tokenType=RefType.v(tokenClass);
  tokenGetTypeMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenZeroMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenAddMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenSubtractMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenModuloMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenMultiplyMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenDivideMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenEqualsMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenIsLessThanMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenNotMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenBitwiseAndMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenBitwiseOrMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenBitwiseXorMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenBitwiseNotMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenLeftShiftMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenRightShiftMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenLogicalRightShiftMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenIntValueMethod=Scene.v().getMethod(""String_Node_Str"");
  tokenPowMethod=Scene.v().getMethod(""String_Node_Str"");
  arrayTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  arrayTokenConstructor=arrayTokenClass.getMethod(""String_Node_Str"");
  arrayValueMethod=arrayTokenClass.getMethod(""String_Node_Str"");
  arrayGetElementMethod=arrayTokenClass.getMethod(""String_Node_Str"");
  recordTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  recordTokenConstructor=recordTokenClass.getMethod(""String_Node_Str"");
  recordGetMethod=recordTokenClass.getMethod(""String_Node_Str"");
  scalarTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  matrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  matrixTokenCreateMethod=matrixTokenClass.getMethod(""String_Node_Str"");
  matrixGetElementAsTokenMethod=matrixTokenClass.getMethod(""String_Node_Str"");
  doubleTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  doubleTokenConstructor=doubleTokenClass.getMethod(""String_Node_Str"");
  doubleValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  doubleMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  doubleMatrixTokenConstructor=doubleMatrixTokenClass.getMethod(""String_Node_Str"");
  doubleMatrixTokenArrayConstructor=doubleMatrixTokenClass.getMethod(""String_Node_Str"");
  doubleMatrixMethod=doubleMatrixTokenClass.getMethod(""String_Node_Str"");
  booleanTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  booleanTokenConstructor=booleanTokenClass.getMethod(""String_Node_Str"");
  booleanValueMethod=booleanTokenClass.getMethod(""String_Node_Str"");
  booleanMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  booleanMatrixTokenConstructor=booleanMatrixTokenClass.getMethod(""String_Node_Str"");
  booleanMatrixTokenArrayConstructor=booleanMatrixTokenClass.getMethod(""String_Node_Str"");
  booleanMatrixMethod=booleanMatrixTokenClass.getMethod(""String_Node_Str"");
  unsignedByteTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  unsignedByteTokenConstructor=unsignedByteTokenClass.getMethod(""String_Node_Str"");
  unsignedByteValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  intTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  intTokenConstructor=intTokenClass.getMethod(""String_Node_Str"");
  intValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  intMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  intMatrixTokenConstructor=intMatrixTokenClass.getMethod(""String_Node_Str"");
  intMatrixTokenArrayConstructor=intMatrixTokenClass.getMethod(""String_Node_Str"");
  intMatrixMethod=intMatrixTokenClass.getMethod(""String_Node_Str"");
  fixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  fixTokenConstructor=fixTokenClass.getMethod(""String_Node_Str"");
  fixTokenThreeArgConstructor=fixTokenClass.getMethod(""String_Node_Str"");
  fixValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  fixMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  fixMatrixTokenConstructor=fixMatrixTokenClass.getMethod(""String_Node_Str"");
  fixMatrixTokenArrayConstructor=fixMatrixTokenClass.getMethod(""String_Node_Str"");
  fixMatrixMethod=fixMatrixTokenClass.getMethod(""String_Node_Str"");
  complexTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  complexTokenConstructor=complexTokenClass.getMethod(""String_Node_Str"");
  complexValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  complexMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  complexMatrixTokenArrayConstructor=complexMatrixTokenClass.getMethod(""String_Node_Str"");
  complexMatrixMethod=matrixTokenClass.getMethod(""String_Node_Str"");
  longTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  longTokenConstructor=longTokenClass.getMethod(""String_Node_Str"");
  longValueMethod=scalarTokenClass.getMethod(""String_Node_Str"");
  longMatrixTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  longMatrixTokenConstructor=longMatrixTokenClass.getMethod(""String_Node_Str"");
  longMatrixTokenArrayConstructor=longMatrixTokenClass.getMethod(""String_Node_Str"");
  longMatrixMethod=longMatrixTokenClass.getMethod(""String_Node_Str"");
  stringTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  stringTokenConstructor=stringTokenClass.getMethod(""String_Node_Str"");
  stringValueMethod=stringTokenClass.getMethod(""String_Node_Str"");
  typeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  typeConvertMethod=typeClass.getMethod(""String_Node_Str"");
  arrayTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  fixTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  recordTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  baseTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  matrixTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  unknownTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  generalTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  booleanTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  booleanMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  byteTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  complexTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  complexMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  doubleTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  doubleMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  fixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  fixMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  intTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  intMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  longTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  longMatrixTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  objectTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  stringTypeField=baseTypeClass.getFieldByName(""String_Node_Str"");
  typeLatticeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  kernelExceptionClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  kernelRuntimeExceptionClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  runtimeExceptionClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  exceptionClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  runtimeExceptionConstructor=runtimeExceptionClass.getMethod(""String_Node_Str"");
  runtimeExceptionStringConstructor=runtimeExceptionClass.getMethod(""String_Node_Str"");
  managerClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  findEffigyMethod=Scene.v().getMethod(""String_Node_Str"");
  inequalityTermClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  explicitChangeContextClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  functionTokenClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
  functionTokenApplyMethod=functionTokenClass.getMethod(""String_Node_Str"");
  functionTokenConstructor=functionTokenClass.getMethod(""String_Node_Str"");
  functionInterface=Scene.v().loadClassAndSupport(""String_Node_Str"");
  functionTypeClass=Scene.v().loadClassAndSupport(""String_Node_Str"");
}"
75261,"/** 
 * Return the depth of the given type.  Most simple types have depth one, while structured types have depth greater than one.
 */
public static int getTypeDepth(ptolemy.data.type.Type type){
  if (type instanceof ptolemy.data.type.ArrayType) {
    return 1 + getTypeDepth(((ptolemy.data.type.ArrayType)type).getElementType());
  }
 else   if (type instanceof ptolemy.data.type.RecordType) {
    ptolemy.data.type.RecordType recordType=(ptolemy.data.type.RecordType)type;
    Iterator labels=recordType.labelSet().iterator();
    int maxDepth=0;
    while (labels.hasNext()) {
      ptolemy.data.type.Type elementType=recordType.get((String)labels.next());
      int depth=getTypeDepth(elementType);
      if (depth > maxDepth)       maxDepth=depth;
    }
    return maxDepth + 1;
  }
 else   if (type.equals(BaseType.UNKNOWN) || type.equals(BaseType.GENERAL) || !type.isInstantiable()) {
    return Integer.MIN_VALUE;
  }
 else {
    return 1;
  }
}","/** 
 * Return the depth of the given type.  Most simple types have depth one, while structured types have depth greater than one.
 */
public static int getTypeDepth(ptolemy.data.type.Type type){
  if (type instanceof ptolemy.data.type.ArrayType) {
    return 1 + getTypeDepth(((ptolemy.data.type.ArrayType)type).getElementType());
  }
 else   if (type instanceof ptolemy.data.type.RecordType) {
    ptolemy.data.type.RecordType recordType=(ptolemy.data.type.RecordType)type;
    Iterator labels=recordType.labelSet().iterator();
    int maxDepth=0;
    while (labels.hasNext()) {
      ptolemy.data.type.Type elementType=recordType.get((String)labels.next());
      int depth=getTypeDepth(elementType);
      if (depth > maxDepth)       maxDepth=depth;
    }
    return maxDepth + 1;
  }
 else   if (!isExactTokenType(type)) {
    return Integer.MIN_VALUE;
  }
 else {
    return 1;
  }
}"
75262,"/** 
 * Attempt to determine the constant value of the given local, which is assumed to have a variable type.  Walk backwards through all the possible places that the local may have been defined and try to symbolically evaluate the value of the variable. If the value can be determined, then return it, otherwise throw an exception
 */
public static ptolemy.data.type.Type getTypeValue(SootMethod method,Local local,Unit location,LocalDefs localDefs,LocalUses localUses){
  List definitionList=localDefs.getDefsOfAt(local,location);
  if (definitionList.size() == 1) {
    DefinitionStmt stmt=(DefinitionStmt)definitionList.get(0);
    Value value=(Value)stmt.getRightOp();
    if (value instanceof Local) {
      return getTypeValue(method,(Local)value,stmt,localDefs,localUses);
    }
 else     if (value instanceof CastExpr) {
      return getTypeValue(method,(Local)((CastExpr)value).getOp(),stmt,localDefs,localUses);
    }
 else     if (value instanceof FieldRef) {
      SootField field=((FieldRef)value).getField();
      if (field.equals(unknownTypeField)) {
        return ptolemy.data.type.BaseType.UNKNOWN;
      }
 else       if (field.equals(booleanTypeField)) {
        return ptolemy.data.type.BaseType.BOOLEAN;
      }
 else       if (field.equals(booleanMatrixTypeField)) {
        return ptolemy.data.type.BaseType.BOOLEAN_MATRIX;
      }
 else       if (field.equals(byteTypeField)) {
        return ptolemy.data.type.BaseType.UNSIGNED_BYTE;
      }
 else       if (field.equals(complexTypeField)) {
        return ptolemy.data.type.BaseType.COMPLEX;
      }
 else       if (field.equals(complexMatrixTypeField)) {
        return ptolemy.data.type.BaseType.COMPLEX_MATRIX;
      }
 else       if (field.equals(doubleTypeField)) {
        return ptolemy.data.type.BaseType.DOUBLE;
      }
 else       if (field.equals(doubleMatrixTypeField)) {
        return ptolemy.data.type.BaseType.DOUBLE_MATRIX;
      }
 else       if (field.equals(fixTypeField)) {
        return ptolemy.data.type.BaseType.FIX;
      }
 else       if (field.equals(fixMatrixTypeField)) {
        return ptolemy.data.type.BaseType.FIX_MATRIX;
      }
 else       if (field.equals(intTypeField)) {
        return ptolemy.data.type.BaseType.INT;
      }
 else       if (field.equals(intMatrixTypeField)) {
        return ptolemy.data.type.BaseType.INT_MATRIX;
      }
 else       if (field.equals(longTypeField)) {
        return ptolemy.data.type.BaseType.LONG;
      }
 else       if (field.equals(longMatrixTypeField)) {
        return ptolemy.data.type.BaseType.LONG_MATRIX;
      }
 else       if (field.equals(objectTypeField)) {
        return ptolemy.data.type.BaseType.OBJECT;
      }
 else       if (field.equals(stringTypeField)) {
        return ptolemy.data.type.BaseType.STRING;
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + field);
      }
    }
 else     if (value instanceof NewExpr) {
      Iterator pairs=localUses.getUsesOf(stmt).iterator();
      while (pairs.hasNext()) {
        UnitValueBoxPair pair=(UnitValueBoxPair)pairs.next();
        if (pair.getUnit() instanceof InvokeStmt) {
          InvokeStmt useStmt=(InvokeStmt)pair.getUnit();
          if (useStmt.getInvokeExpr() instanceof SpecialInvokeExpr) {
            SpecialInvokeExpr constructorExpr=(SpecialInvokeExpr)useStmt.getInvokeExpr();
            if (constructorExpr.getMethod().getSignature().equals(""String_Node_Str"")) {
              Local arg1Local=(Local)constructorExpr.getArg(0);
              ptolemy.data.type.Type elementType=getTypeValue(method,arg1Local,useStmt,localDefs,localUses);
              return new ptolemy.data.type.ArrayType(elementType);
            }
 else {
              throw new RuntimeException(""String_Node_Str"" + stmt);
            }
          }
        }
      }
      throw new RuntimeException(""String_Node_Str"");
    }
 else     if (value instanceof NullConstant) {
      return null;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ method);
    }
  }
 else {
    String string=""String_Node_Str"" + local + ""String_Node_Str"";
    for (Iterator i=definitionList.iterator(); i.hasNext(); ) {
      string+=""String_Node_Str"" + i.next().toString();
    }
    throw new RuntimeException(string);
  }
}","/** 
 * Attempt to determine the constant value of the given local, which is assumed to have a variable type.  Walk backwards through all the possible places that the local may have been defined and try to symbolically evaluate the value of the variable. If the value can be determined, then return it, otherwise throw an exception
 */
public static ptolemy.data.type.Type getTypeValue(SootMethod method,Local local,Unit location,LocalDefs localDefs,LocalUses localUses){
  List definitionList=localDefs.getDefsOfAt(local,location);
  if (definitionList.size() == 1) {
    DefinitionStmt stmt=(DefinitionStmt)definitionList.get(0);
    Value value=(Value)stmt.getRightOp();
    if (value instanceof Local) {
      return getTypeValue(method,(Local)value,stmt,localDefs,localUses);
    }
 else     if (value instanceof CastExpr) {
      return getTypeValue(method,(Local)((CastExpr)value).getOp(),stmt,localDefs,localUses);
    }
 else     if (value instanceof FieldRef) {
      SootField field=((FieldRef)value).getField();
      if (field.equals(unknownTypeField)) {
        return ptolemy.data.type.BaseType.UNKNOWN;
      }
 else       if (field.equals(booleanTypeField)) {
        return ptolemy.data.type.BaseType.BOOLEAN;
      }
 else       if (field.equals(booleanMatrixTypeField)) {
        return ptolemy.data.type.BaseType.BOOLEAN_MATRIX;
      }
 else       if (field.equals(byteTypeField)) {
        return ptolemy.data.type.BaseType.UNSIGNED_BYTE;
      }
 else       if (field.equals(complexTypeField)) {
        return ptolemy.data.type.BaseType.COMPLEX;
      }
 else       if (field.equals(complexMatrixTypeField)) {
        return ptolemy.data.type.BaseType.COMPLEX_MATRIX;
      }
 else       if (field.equals(doubleTypeField)) {
        return ptolemy.data.type.BaseType.DOUBLE;
      }
 else       if (field.equals(doubleMatrixTypeField)) {
        return ptolemy.data.type.BaseType.DOUBLE_MATRIX;
      }
 else       if (field.equals(fixTypeField)) {
        return ptolemy.data.type.BaseType.FIX;
      }
 else       if (field.equals(fixMatrixTypeField)) {
        return ptolemy.data.type.BaseType.FIX_MATRIX;
      }
 else       if (field.equals(intTypeField)) {
        return ptolemy.data.type.BaseType.INT;
      }
 else       if (field.equals(intMatrixTypeField)) {
        return ptolemy.data.type.BaseType.INT_MATRIX;
      }
 else       if (field.equals(longTypeField)) {
        return ptolemy.data.type.BaseType.LONG;
      }
 else       if (field.equals(longMatrixTypeField)) {
        return ptolemy.data.type.BaseType.LONG_MATRIX;
      }
 else       if (field.equals(objectTypeField)) {
        return ptolemy.data.type.BaseType.OBJECT;
      }
 else       if (field.equals(stringTypeField)) {
        return ptolemy.data.type.BaseType.STRING;
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + field);
      }
    }
 else     if (value instanceof InstanceInvokeExpr) {
      InstanceInvokeExpr r=(InstanceInvokeExpr)value;
      if (r.getMethod().getName().equals(""String_Node_Str"")) {
        ptolemy.data.type.ArrayType arrayType=(ptolemy.data.type.ArrayType)getTypeValue(method,(Local)r.getBase(),stmt,localDefs,localUses);
        return arrayType.getElementType();
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + r);
      }
    }
 else     if (value instanceof NewExpr) {
      Iterator pairs=localUses.getUsesOf(stmt).iterator();
      while (pairs.hasNext()) {
        UnitValueBoxPair pair=(UnitValueBoxPair)pairs.next();
        if (pair.getUnit() instanceof InvokeStmt) {
          InvokeStmt useStmt=(InvokeStmt)pair.getUnit();
          if (useStmt.getInvokeExpr() instanceof SpecialInvokeExpr) {
            SpecialInvokeExpr constructorExpr=(SpecialInvokeExpr)useStmt.getInvokeExpr();
            if (constructorExpr.getMethod().getSignature().equals(""String_Node_Str"")) {
              Local arg1Local=(Local)constructorExpr.getArg(0);
              ptolemy.data.type.Type elementType=getTypeValue(method,arg1Local,useStmt,localDefs,localUses);
              return new ptolemy.data.type.ArrayType(elementType);
            }
 else {
              throw new RuntimeException(""String_Node_Str"" + constructorExpr);
            }
          }
        }
      }
      throw new RuntimeException(""String_Node_Str"");
    }
 else     if (value instanceof NullConstant) {
      return null;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ method);
    }
  }
 else {
    String string=""String_Node_Str"" + local + ""String_Node_Str"";
    for (Iterator i=definitionList.iterator(); i.hasNext(); ) {
      string+=""String_Node_Str"" + i.next().toString();
    }
    throw new RuntimeException(string);
  }
}"
75263,"/** 
 * Specialize all token types that appear in the given list of classes.  Return a map from locals and fields in the class to their new specific Ptolemy type.  Exclude locals in the given set from the typing algorithm.
 * @param list A list of SootClass.
 */
public TypeSpecializerAnalysis(List list,Set unsafeLocals){
  _unsafeLocals=unsafeLocals;
  _solver=new InequalitySolver(new JavaTypeLattice());
  _objectToInequalityTerm=new HashMap();
  for (Iterator classes=list.iterator(); classes.hasNext(); ) {
    SootClass theClass=(SootClass)classes.next();
    _collectConstraints(theClass,_debug);
  }
  boolean succeeded;
  try {
    succeeded=_solver.solveLeast();
  }
 catch (  Exception ex) {
    _printSolverVariables();
    throw new RuntimeException(ex.getMessage());
  }
  if (_debug) {
    _printSolverVariables();
  }
  if (succeeded) {
    if (_debug)     System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
    try {
      Iterator inequalities=_solver.unsatisfiedInequalities();
      while (inequalities.hasNext()) {
        System.out.println(""String_Node_Str"" + inequalities.next().toString());
      }
      System.err.println(""String_Node_Str"");
      inequalities=_solver.unsatisfiedInequalities();
      while (inequalities.hasNext()) {
        System.err.println(""String_Node_Str"" + inequalities.next().toString());
      }
    }
 catch (    IllegalActionException ex) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
}","/** 
 * Specialize all token types that appear in the given list of classes.  Return a map from locals and fields in the class to their new specific Ptolemy type.  Exclude locals in the given set from the typing algorithm.
 * @param list A list of SootClass.
 */
public TypeSpecializerAnalysis(List list,Set unsafeLocals){
  if (_debug)   System.out.println(""String_Node_Str"");
  _unsafeLocals=unsafeLocals;
  _solver=new InequalitySolver(new JavaTypeLattice());
  _objectToInequalityTerm=new HashMap();
  for (Iterator classes=list.iterator(); classes.hasNext(); ) {
    SootClass theClass=(SootClass)classes.next();
    _collectVariables(theClass,_debug);
  }
  for (Iterator classes=list.iterator(); classes.hasNext(); ) {
    SootClass theClass=(SootClass)classes.next();
    _collectConstraints(theClass,_debug);
  }
  boolean succeeded;
  try {
    succeeded=_solver.solveLeast();
  }
 catch (  Exception ex) {
    _printSolverVariables();
    throw new RuntimeException(ex.getMessage());
  }
  if (_debug) {
    _printSolverVariables();
  }
  if (succeeded) {
    if (_debug)     System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
    try {
      Iterator inequalities=_solver.unsatisfiedInequalities();
      while (inequalities.hasNext()) {
        System.out.println(""String_Node_Str"" + inequalities.next().toString());
      }
      System.err.println(""String_Node_Str"");
      inequalities=_solver.unsatisfiedInequalities();
      while (inequalities.hasNext()) {
        System.err.println(""String_Node_Str"" + inequalities.next().toString());
      }
    }
 catch (    IllegalActionException ex) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
}"
75264,"private void _collectConstraints(SootClass entityClass,boolean debug){
  if (debug)   System.out.println(""String_Node_Str"" + entityClass);
  for (Iterator fields=entityClass.getFields().iterator(); fields.hasNext(); ) {
    SootField field=(SootField)fields.next();
    Type type=field.getType();
    _createInequalityTerm(debug,field,type,_objectToInequalityTerm);
    TypeTag tag=(TypeTag)field.getTag(""String_Node_Str"");
    if (tag != null) {
      _addInequality(debug,_solver,new ConstantTerm(tag.getType(),field),(InequalityTerm)_objectToInequalityTerm.get(field));
    }
  }
  SootClass modelClass=ModelTransformer.getModelClass();
  if (modelClass != null) {
    for (Iterator fields=modelClass.getFields().iterator(); fields.hasNext(); ) {
      SootField field=(SootField)fields.next();
      Type type=field.getType();
      _createInequalityTerm(debug,field,type,_objectToInequalityTerm);
      TypeTag tag=(TypeTag)field.getTag(""String_Node_Str"");
      if (tag != null) {
        _addInequality(debug,_solver,new ConstantTerm(tag.getType(),field),(InequalityTerm)_objectToInequalityTerm.get(field));
      }
    }
  }
  for (Iterator methods=entityClass.getMethods().iterator(); methods.hasNext(); ) {
    SootMethod method=(SootMethod)methods.next();
    Body body=method.retrieveActiveBody();
    if (debug)     System.out.println(""String_Node_Str"" + method);
    CompleteUnitGraph unitGraph=new CompleteUnitGraph(body);
    SimpleLocalDefs localDefs=new SimpleLocalDefs(unitGraph);
    SimpleLocalUses localUses=new SimpleLocalUses(unitGraph,localDefs);
    for (Iterator locals=body.getLocals().iterator(); locals.hasNext(); ) {
      Local local=(Local)locals.next();
      if (_unsafeLocals.contains(local)) {
        continue;
      }
      Type type=local.getType();
      _createInequalityTerm(debug,local,type,_objectToInequalityTerm);
    }
    for (Iterator units=body.getUnits().iterator(); units.hasNext(); ) {
      Stmt stmt=(Stmt)units.next();
      if (debug)       System.out.println(""String_Node_Str"" + stmt);
      if (stmt instanceof AssignStmt) {
        Value leftOp=((AssignStmt)stmt).getLeftOp();
        Value rightOp=((AssignStmt)stmt).getRightOp();
        InequalityTerm leftOpTerm=_getInequalityTerm(method,debug,leftOp,_solver,_objectToInequalityTerm,stmt,localDefs,localUses);
        InequalityTerm rightOpTerm=_getInequalityTerm(method,debug,rightOp,_solver,_objectToInequalityTerm,stmt,localDefs,localUses);
        _addInequality(debug,_solver,rightOpTerm,leftOpTerm);
        if (SootUtilities.isAliasableValue(leftOp) && SootUtilities.isAliasableValue(rightOp)) {
          _addInequality(debug,_solver,leftOpTerm,rightOpTerm);
        }
      }
 else       if (stmt instanceof InvokeStmt) {
        _getInequalityTerm(method,debug,((InvokeStmt)stmt).getInvokeExpr(),_solver,_objectToInequalityTerm,stmt,localDefs,localUses);
      }
    }
  }
}","private void _collectConstraints(SootClass entityClass,boolean debug){
  if (debug)   System.out.println(""String_Node_Str"" + entityClass);
  for (Iterator methods=entityClass.getMethods().iterator(); methods.hasNext(); ) {
    SootMethod method=(SootMethod)methods.next();
    Body body=method.retrieveActiveBody();
    if (debug)     System.out.println(""String_Node_Str"" + method);
    CompleteUnitGraph unitGraph=new CompleteUnitGraph(body);
    SimpleLocalDefs localDefs=new SimpleLocalDefs(unitGraph);
    SimpleLocalUses localUses=new SimpleLocalUses(unitGraph,localDefs);
    for (Iterator locals=body.getLocals().iterator(); locals.hasNext(); ) {
      Local local=(Local)locals.next();
      if (_unsafeLocals.contains(local)) {
        continue;
      }
      Type type=local.getType();
      _createInequalityTerm(debug,local,type,_objectToInequalityTerm);
    }
    for (Iterator units=body.getUnits().iterator(); units.hasNext(); ) {
      Stmt stmt=(Stmt)units.next();
      if (debug)       System.out.println(""String_Node_Str"" + stmt);
      if (stmt instanceof AssignStmt) {
        Value leftOp=((AssignStmt)stmt).getLeftOp();
        Value rightOp=((AssignStmt)stmt).getRightOp();
        InequalityTerm leftOpTerm=_getInequalityTerm(method,debug,leftOp,_solver,_objectToInequalityTerm,stmt,localDefs,localUses);
        InequalityTerm rightOpTerm=_getInequalityTerm(method,debug,rightOp,_solver,_objectToInequalityTerm,stmt,localDefs,localUses);
        _addInequality(debug,_solver,rightOpTerm,leftOpTerm);
        if (SootUtilities.isAliasableValue(leftOp) && SootUtilities.isAliasableValue(rightOp)) {
          _addInequality(debug,_solver,leftOpTerm,rightOpTerm);
        }
      }
 else       if (stmt instanceof InvokeStmt) {
        _getInequalityTerm(method,debug,((InvokeStmt)stmt).getInvokeExpr(),_solver,_objectToInequalityTerm,stmt,localDefs,localUses);
      }
    }
  }
}"
75265,"/** 
 * Propagate the number of fractional firings decided for this actor through the specified port.  Compute the fractional firing ratio for each actor that is connected to the given port. If we have not previously computed the ratio for an actor, then store the value in the given map of firing ratios and move the actor from the remainingActors list to the pendingActors list. If the value has been previously computed and is not the same, then the model is not schedulable and an exception will be thrown. Note that ports directly contained by the given container are handled slightly differently from other ports.  Most importantly, their rates are propagated to ports they are connected to on the inside, as opposed to ports they are connected to on the outside.
 * @param container The actor that is being scheduled.
 * @param currentPort The port that we are propagating from.
 * @param entityToFiringsPerIteration The current Map offractional firing ratios for each actor.  This map will be updated if the ratio for any actor has not been previously computed.
 * @param externalRates A map from external ports of container tothe fractional rates of that port.  This will be updated during this method.
 * @param remainingActors The set of actors that have not had theirfractional firing set.  This will be updated during this method.
 * @param pendingActors The set of actors that have had their rateset, but have not been propagated onwards.  This will be updated during this method.
 * @exception NotSchedulableException If the model is notschedulable.
 * @exception IllegalActionException If the expression for arate parameter is not valid.
 */
private void _propagatePort(CompositeActor container,IOPort currentPort,Map entityToFiringsPerIteration,Map externalRates,LinkedList remainingActors,LinkedList pendingActors) throws NotSchedulableException, IllegalActionException {
  ComponentEntity currentActor=(ComponentEntity)currentPort.getContainer();
  if (currentPort.isOutput() && currentPort.getContainer() != container) {
    Iterator connectedPorts=currentPort.deepConnectedPortList().iterator();
    while (connectedPorts.hasNext()) {
      IOPort connectedPort=(IOPort)connectedPorts.next();
      if (connectedPort.isOutput() && connectedPort.getContainer() != container) {
        throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"");
      }
 else       if (connectedPort.isInput() && connectedPort.getContainer() == container) {
        throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  if (currentPort.isInput() && currentPort.getContainer() == container) {
    Iterator connectedPorts=currentPort.deepInsidePortList().iterator();
    while (connectedPorts.hasNext()) {
      IOPort connectedPort=(IOPort)connectedPorts.next();
      if (connectedPort.isOutput() && connectedPort.getContainer() != container) {
        throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
 else       if (connectedPort.isInput() && connectedPort.getContainer() == container) {
        throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  int currentRate=SDFUtilities._getRate(currentPort);
  if (currentRate < 0) {
    throw new NotSchedulableException(currentPort,""String_Node_Str"" + currentRate);
  }
  Iterator connectedPorts;
  if (currentPort.getContainer() == container) {
    connectedPorts=currentPort.deepInsidePortList().iterator();
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"" + currentPort);
      while (connectedPorts.hasNext()) {
        _debug(connectedPorts.next().toString());
      }
    }
    connectedPorts=currentPort.deepInsidePortList().iterator();
  }
 else {
    connectedPorts=currentPort.deepConnectedPortList().iterator();
  }
  while (connectedPorts.hasNext()) {
    IOPort connectedPort=(IOPort)connectedPorts.next();
    ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"" + currentPort + ""String_Node_Str""+ connectedActor.getName());
    }
    int connectedRate=SDFUtilities._getRate(connectedPort);
    Fraction currentFiring=(Fraction)entityToFiringsPerIteration.get(currentActor);
    Fraction desiredFiring;
    if ((currentRate == 0) && (connectedRate > 0)) {
      desiredFiring=Fraction.ZERO;
    }
 else     if ((currentRate > 0) && (connectedRate == 0)) {
      currentFiring=Fraction.ZERO;
      entityToFiringsPerIteration.put(currentActor,currentFiring);
      desiredFiring=new Fraction(1);
    }
 else     if ((currentRate == 0) && (connectedRate == 0)) {
      desiredFiring=currentFiring;
    }
 else {
      desiredFiring=currentFiring.multiply(new Fraction(currentRate,connectedRate));
    }
    Fraction presentFiring=(Fraction)entityToFiringsPerIteration.get(connectedActor);
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"" + connectedActor + ""String_Node_Str""+ presentFiring);
    }
    if (presentFiring == null) {
      entityToFiringsPerIteration.put(connectedActor,desiredFiring);
      Fraction rate=currentFiring.multiply(new Fraction(currentRate,1));
      Fraction previousRate=(Fraction)externalRates.get(connectedPort);
      if (previousRate.equals(Fraction.ZERO)) {
        externalRates.put(connectedPort,rate);
      }
 else       if (!rate.equals(previousRate)) {
        throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ connectedPort.getFullName());
      }
      _propagatePort(container,connectedPort,entityToFiringsPerIteration,externalRates,remainingActors,pendingActors);
      entityToFiringsPerIteration.remove(connectedActor);
    }
 else     if (presentFiring.equals(_minusOne)) {
      entityToFiringsPerIteration.put(connectedActor,desiredFiring);
      remainingActors.remove(connectedActor);
      pendingActors.addLast(connectedActor);
    }
 else     if (!presentFiring.equals(desiredFiring)) {
      throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ connectedPort.getFullName());
    }
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"");
      _debug(entityToFiringsPerIteration.toString());
    }
  }
}","/** 
 * Propagate the number of fractional firings decided for this actor through the specified port.  Compute the fractional firing ratio for each actor that is connected to the given port. If we have not previously computed the ratio for an actor, then store the value in the given map of firing ratios and move the actor from the remainingActors list to the pendingActors list. If the value has been previously computed and is not the same, then the model is not schedulable and an exception will be thrown. Note that ports directly contained by the given container are handled slightly differently from other ports.  Most importantly, their rates are propagated to ports they are connected to on the inside, as opposed to ports they are connected to on the outside.
 * @param container The actor that is being scheduled.
 * @param currentPort The port that we are propagating from.
 * @param entityToFiringsPerIteration The current Map offractional firing ratios for each actor.  This map will be updated if the ratio for any actor has not been previously computed.
 * @param externalRates A map from external ports of container tothe fractional rates of that port.  This will be updated during this method.
 * @param remainingActors The set of actors that have not had theirfractional firing set.  This will be updated during this method.
 * @param pendingActors The set of actors that have had their rateset, but have not been propagated onwards.  This will be updated during this method.
 * @exception NotSchedulableException If the model is notschedulable.
 * @exception IllegalActionException If the expression for arate parameter is not valid.
 */
private void _propagatePort(CompositeActor container,IOPort currentPort,Map entityToFiringsPerIteration,Map externalRates,LinkedList remainingActors,LinkedList pendingActors) throws NotSchedulableException, IllegalActionException {
  ComponentEntity currentActor=(ComponentEntity)currentPort.getContainer();
  if (currentPort.isOutput() && currentPort.getContainer() != container) {
    Iterator connectedPorts=currentPort.deepConnectedPortList().iterator();
    while (connectedPorts.hasNext()) {
      IOPort connectedPort=(IOPort)connectedPorts.next();
      if (connectedPort.isOutput() && connectedPort.getContainer() != container) {
        throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"");
      }
 else       if (connectedPort.isInput() && connectedPort.getContainer() == container) {
        throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  if (currentPort.isInput() && currentPort.getContainer() == container) {
    Iterator connectedPorts=currentPort.deepInsidePortList().iterator();
    while (connectedPorts.hasNext()) {
      IOPort connectedPort=(IOPort)connectedPorts.next();
      if (connectedPort.isOutput() && connectedPort.getContainer() != container) {
        throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
 else       if (connectedPort.isInput() && connectedPort.getContainer() == container) {
        throw new NotSchedulableException(currentPort,connectedPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  Director director=(Director)getContainer();
  CompositeActor model=(CompositeActor)director.getContainer();
  int currentRate;
  if (currentActor == model) {
    currentRate=1;
  }
 else {
    currentRate=SDFUtilities._getRate(currentPort);
  }
  if (currentRate < 0) {
    throw new NotSchedulableException(currentPort,""String_Node_Str"" + currentRate);
  }
  Iterator connectedPorts;
  if (currentPort.getContainer() == container) {
    connectedPorts=currentPort.deepInsidePortList().iterator();
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"" + currentPort);
      while (connectedPorts.hasNext()) {
        _debug(connectedPorts.next().toString());
      }
    }
    connectedPorts=currentPort.deepInsidePortList().iterator();
  }
 else {
    connectedPorts=currentPort.deepConnectedPortList().iterator();
  }
  while (connectedPorts.hasNext()) {
    IOPort connectedPort=(IOPort)connectedPorts.next();
    ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"" + currentPort + ""String_Node_Str""+ connectedActor.getName());
    }
    int connectedRate;
    if (connectedActor == model) {
      connectedRate=1;
    }
 else {
      connectedRate=SDFUtilities._getRate(connectedPort);
    }
    Fraction currentFiring=(Fraction)entityToFiringsPerIteration.get(currentActor);
    Fraction desiredFiring;
    if ((currentRate == 0) && (connectedRate > 0)) {
      desiredFiring=Fraction.ZERO;
    }
 else     if ((currentRate > 0) && (connectedRate == 0)) {
      currentFiring=Fraction.ZERO;
      entityToFiringsPerIteration.put(currentActor,currentFiring);
      desiredFiring=new Fraction(1);
    }
 else     if ((currentRate == 0) && (connectedRate == 0)) {
      desiredFiring=currentFiring;
    }
 else {
      desiredFiring=currentFiring.multiply(new Fraction(currentRate,connectedRate));
    }
    Fraction presentFiring=(Fraction)entityToFiringsPerIteration.get(connectedActor);
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"" + connectedActor + ""String_Node_Str""+ presentFiring);
    }
    if (presentFiring == null) {
      entityToFiringsPerIteration.put(connectedActor,desiredFiring);
      Fraction rate=currentFiring.multiply(new Fraction(currentRate,1));
      Fraction previousRate=(Fraction)externalRates.get(connectedPort);
      if (previousRate.equals(Fraction.ZERO)) {
        externalRates.put(connectedPort,rate);
      }
 else       if (!rate.equals(previousRate)) {
        throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ connectedPort.getFullName());
      }
      _propagatePort(container,connectedPort,entityToFiringsPerIteration,externalRates,remainingActors,pendingActors);
      entityToFiringsPerIteration.remove(connectedActor);
    }
 else     if (presentFiring.equals(_minusOne)) {
      entityToFiringsPerIteration.put(connectedActor,desiredFiring);
      remainingActors.remove(connectedActor);
      pendingActors.addLast(connectedActor);
    }
 else     if (!presentFiring.equals(desiredFiring)) {
      throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ connectedPort.getFullName());
    }
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"");
      _debug(entityToFiringsPerIteration.toString());
    }
  }
}"
75266,"/** 
 * Output the current value of the clock.
 * @exception IllegalActionException Ifthe value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  double currentTime=getDirector().getCurrentTime();
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  if (_debugging)   _debug(""String_Node_Str"" + currentTime + ""String_Node_Str"");
  _updateTentativeValues();
  _tentativeNextFiringTime=Double.NEGATIVE_INFINITY;
  _tentativeCycleCountIncrement=0;
  if (_tentativeCycleCount > 0) {
    while (_tentativeCycleStartTime + periodValue <= currentTime) {
      _tentativeCycleStartTime+=periodValue;
    }
    _tentativeCycleStartTime=Utilities.round(_tentativeCycleStartTime,getDirector().getTimeResolution());
    double currentPhaseTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
    currentPhaseTime=Utilities.round(currentPhaseTime,getDirector().getTimeResolution());
    if (currentTime == currentPhaseTime) {
      _tentativeCurrentValue=_getValue(_tentativePhase);
      _tentativePhase++;
      if (_tentativePhase >= _offsets.length) {
        _tentativePhase=0;
        _tentativeCycleStartTime+=periodValue;
        _tentativeCycleStartTime=Utilities.round(_tentativeCycleStartTime,getDirector().getTimeResolution());
        _tentativeCycleCountIncrement++;
      }
      if (_offsets[_tentativePhase] >= periodValue) {
        throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ _offsets[_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
      }
      _tentativeNextFiringTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
      _tentativeNextFiringTime=Utilities.round(_tentativeNextFiringTime,getDirector().getTimeResolution());
      if (_debugging) {
        _debug(""String_Node_Str"" + _tentativeNextFiringTime);
      }
      int cycleLimit=((IntToken)numberOfCycles.getToken()).intValue();
      double stopTime=Utilities.round(_tentativeStartTime + cycleLimit * periodValue,getDirector().getTimeResolution());
      if (cycleLimit > 0 && currentTime >= stopTime) {
        _tentativeCurrentValue=_tentativeCurrentValue.zero();
      }
      output.send(0,_tentativeCurrentValue);
      if (_debugging)       _debug(""String_Node_Str"" + _tentativeCurrentValue + ""String_Node_Str"");
    }
  }
}","/** 
 * Output the current value of the clock.
 * @exception IllegalActionException Ifthe value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  double currentTime=getDirector().getCurrentTime();
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  if (_debugging)   _debug(""String_Node_Str"" + currentTime + ""String_Node_Str"");
  _updateTentativeValues();
  _tentativeNextFiringTime=Double.NEGATIVE_INFINITY;
  _tentativeCycleCountIncrement=0;
  if (_tentativeCycleCount > 0) {
    while (_tentativeCycleStartTime + periodValue <= currentTime) {
      _tentativeCycleStartTime+=periodValue;
    }
    _tentativeCycleStartTime=Utilities.round(_tentativeCycleStartTime,getDirector().getTimeResolution());
    double currentPhaseTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
    currentPhaseTime=Utilities.round(currentPhaseTime,getDirector().getTimeResolution());
    if (currentTime == currentPhaseTime) {
      _tentativeCurrentValue=_getValue(_tentativePhase);
      _tentativePhase++;
      if (_tentativePhase >= _offsets.length) {
        _tentativePhase=0;
        _tentativeCycleStartTime+=periodValue;
        _tentativeCycleStartTime=Utilities.round(_tentativeCycleStartTime,getDirector().getTimeResolution());
        _tentativeCycleCountIncrement++;
      }
      if (_offsets[_tentativePhase] >= periodValue) {
        throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ _offsets[_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
      }
      _tentativeNextFiringTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
      _tentativeNextFiringTime=Utilities.round(_tentativeNextFiringTime,getDirector().getTimeResolution());
      if (_debugging) {
        _debug(""String_Node_Str"" + _tentativeNextFiringTime);
      }
    }
  }
  int cycleLimit=((IntToken)numberOfCycles.getToken()).intValue();
  double stopTime=Utilities.round(_tentativeStartTime + cycleLimit * periodValue,getDirector().getTimeResolution());
  if (cycleLimit > 0 && currentTime >= stopTime) {
    _tentativeCurrentValue=_tentativeCurrentValue.zero();
  }
  output.send(0,_tentativeCurrentValue);
  if (_debugging)   _debug(""String_Node_Str"" + _tentativeCurrentValue + ""String_Node_Str"");
}"
75267,"/** 
 * Return true if the argument has the same time value.
 * @param object An instance of Time.
 * @return True if the argument has the same time value.
 */
public boolean equals(Time time){
  return (time.getTimeValue() == _time);
}","/** 
 * Return true if the argument has the same time value.
 * @param time An instance of Time.
 * @return True if the argument has the same time value.
 */
public boolean equals(Time time){
  return (time.getTimeValue() == _time);
}"
75268,"/** 
 * Output the current value of the clock.
 * @exception IllegalActionException Ifthe value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  double currentTime=getDirector().getCurrentTime();
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  if (_debugging)   _debug(""String_Node_Str"" + currentTime + ""String_Node_Str"");
  _updateTentativeValues();
  _tentativeNextFiringTime=Double.NEGATIVE_INFINITY;
  _tentativeCycleCountIncrement=0;
  if (_tentativeCycleCount > 0) {
    while (_tentativeCycleStartTime + periodValue <= currentTime) {
      _tentativeCycleStartTime+=periodValue;
    }
    _tentativeCycleStartTime=Utilities.round(_tentativeCycleStartTime,getDirector().getTimeResolution());
    if (currentTime == _tentativeCycleStartTime + _offsets[_tentativePhase]) {
      _tentativeCurrentValue=_getValue(_tentativePhase);
      _tentativePhase++;
      if (_tentativePhase >= _offsets.length) {
        _tentativePhase=0;
        _tentativeCycleStartTime+=periodValue;
        _tentativeCycleStartTime=Utilities.round(_tentativeCycleStartTime,getDirector().getTimeResolution());
        _tentativeCycleCountIncrement++;
      }
      if (_offsets[_tentativePhase] >= periodValue) {
        throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ _offsets[_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
      }
      _tentativeNextFiringTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
      _tentativeNextFiringTime=Utilities.round(_tentativeNextFiringTime,getDirector().getTimeResolution());
      if (_debugging) {
        _debug(""String_Node_Str"" + _tentativeNextFiringTime);
      }
      int cycleLimit=((IntToken)numberOfCycles.getToken()).intValue();
      if (cycleLimit > 0 && currentTime >= _tentativeStartTime + cycleLimit * periodValue) {
        _tentativeCurrentValue=_tentativeCurrentValue.zero();
      }
      output.send(0,_tentativeCurrentValue);
      if (_debugging)       _debug(""String_Node_Str"" + _tentativeCurrentValue + ""String_Node_Str"");
    }
  }
}","/** 
 * Output the current value of the clock.
 * @exception IllegalActionException Ifthe value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  double currentTime=getDirector().getCurrentTime();
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  if (_debugging)   _debug(""String_Node_Str"" + currentTime + ""String_Node_Str"");
  _updateTentativeValues();
  _tentativeNextFiringTime=Double.NEGATIVE_INFINITY;
  _tentativeCycleCountIncrement=0;
  if (_tentativeCycleCount > 0) {
    while (_tentativeCycleStartTime + periodValue <= currentTime) {
      _tentativeCycleStartTime+=periodValue;
    }
    _tentativeCycleStartTime=Utilities.round(_tentativeCycleStartTime,getDirector().getTimeResolution());
    double currentPhaseTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
    currentPhaseTime=Utilities.round(currentPhaseTime,getDirector().getTimeResolution());
    if (currentTime == currentPhaseTime) {
      _tentativeCurrentValue=_getValue(_tentativePhase);
      _tentativePhase++;
      if (_tentativePhase >= _offsets.length) {
        _tentativePhase=0;
        _tentativeCycleStartTime+=periodValue;
        _tentativeCycleStartTime=Utilities.round(_tentativeCycleStartTime,getDirector().getTimeResolution());
        _tentativeCycleCountIncrement++;
      }
      if (_offsets[_tentativePhase] >= periodValue) {
        throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ _offsets[_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
      }
      _tentativeNextFiringTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
      _tentativeNextFiringTime=Utilities.round(_tentativeNextFiringTime,getDirector().getTimeResolution());
      if (_debugging) {
        _debug(""String_Node_Str"" + _tentativeNextFiringTime);
      }
      int cycleLimit=((IntToken)numberOfCycles.getToken()).intValue();
      double stopTime=Utilities.round(_tentativeStartTime + cycleLimit * periodValue,getDirector().getTimeResolution());
      if (cycleLimit > 0 && currentTime >= _tentativeStartTime + cycleLimit * periodValue) {
        _tentativeCurrentValue=_tentativeCurrentValue.zero();
      }
      output.send(0,_tentativeCurrentValue);
      if (_debugging)       _debug(""String_Node_Str"" + _tentativeCurrentValue + ""String_Node_Str"");
    }
  }
}"
75269,"/** 
 * Execute previously requested changes. If there is a container, then delegate the request to the container.  Otherwise, this method will execute all pending changes (even if  {@link #isDeferringChangeRequests()} returns true. Listeners will be notified of success or failure.
 * @see #addChangeListener(ChangeListener)
 * @see #requestChange(ChangeRequest)
 * @see #isDeferringChangeRequests()
 * @see Changeable
 */
public void executeChangeRequests(){
  NamedObj container=(NamedObj)getContainer();
  if (container != null) {
    container.executeChangeRequests();
    return;
  }
  List copy=null;
synchronized (_changeLock) {
    if (_changeRequests != null && _changeRequests.size() > 0) {
      copy=new LinkedList(_changeRequests);
      _changeRequests.clear();
    }
  }
  if (copy != null) {
    Iterator requests=copy.iterator();
    boolean previousDeferStatus=isDeferringChangeRequests();
    try {
      setDeferringChangeRequests(true);
      while (requests.hasNext()) {
        ChangeRequest change=(ChangeRequest)requests.next();
        change.setListeners(_changeListeners);
        if (_debugging) {
          _debug(""String_Node_Str"" + ""String_Node_Str"" + change.getDescription());
        }
        change.execute();
      }
    }
  finally {
      setDeferringChangeRequests(previousDeferStatus);
    }
    executeChangeRequests();
  }
}","/** 
 * Execute previously requested changes. If there is a container, then delegate the request to the container.  Otherwise, this method will execute all pending changes (even if  {@link #isDeferringChangeRequests()} returns true. Listeners will be notified of success or failure.
 * @see #addChangeListener(ChangeListener)
 * @see #requestChange(ChangeRequest)
 * @see #isDeferringChangeRequests()
 * @see Changeable
 */
public void executeChangeRequests(){
  NamedObj container=(NamedObj)getContainer();
  if (container != null) {
    container.executeChangeRequests();
    return;
  }
  List copy=null;
synchronized (_changeLock) {
    if (_changeRequests != null && _changeRequests.size() > 0) {
      copy=new LinkedList(_changeRequests);
      _changeRequests.clear();
    }
  }
  if (copy != null) {
    Iterator requests=copy.iterator();
    boolean previousDeferStatus=isDeferringChangeRequests();
    try {
      previousDeferStatus=setDeferringChangeRequests(true);
      while (requests.hasNext()) {
        ChangeRequest change=(ChangeRequest)requests.next();
        change.setListeners(_changeListeners);
        if (_debugging) {
          _debug(""String_Node_Str"" + ""String_Node_Str"" + change.getDescription());
        }
        change.execute();
      }
    }
  finally {
      setDeferringChangeRequests(previousDeferStatus);
    }
    executeChangeRequests();
  }
}"
75270,"/** 
 * Return true if describing this class in MoML is redundant. This will return true if setPersistent() has been called with argument false, irrespective of other conditions. If setPersistent() has not been called, or has been called with argument true, then things are more complicated. If the <i>depth</i> argument is 0 or if this object is not derived, then this method returns false, indicating that MoML should be exported. Otherwise, whether to export MoML depends on whether the MoML specifies information that should be created by propagation rather than explicitly represented in MoML.  If this is a derived object, then whether its information can be created by propagation depends on whether the object from which that propagation would occur is included in the MoML, which depends on the <i>depth</i> argument. This method uses the <i>depth</i> argument to determine whether the exported MoML both contains an object that implies the existence of this object and contains an object that implies the value of this object.  If both conditions are satisfied, then it returns false.  Finally, if we haven't already returned false, then check all the contained objects, and if any of them requires a MoML description, then return false. Otherwise, return true.
 * @param depth The depth of the requested MoML.
 * @return Return true to suppress MoML export.
 */
protected boolean _isMoMLSuppressed(int depth){
  if (_isPersistent != null) {
    return !_isPersistent.booleanValue();
  }
  if (_derivedLevel > depth) {
    return false;
  }
  if (_override != null && _override.size() > depth + 1) {
    return false;
  }
  Iterator objects=containedObjectsIterator();
  while (objects.hasNext()) {
    NamedObj object=(NamedObj)objects.next();
    if (!object._isMoMLSuppressed(depth + 1)) {
      return false;
    }
  }
  return true;
}","/** 
 * Return true if describing this class in MoML is redundant. This will return true if setPersistent() has been called with argument false, irrespective of other conditions. If setPersistent() has not been called, or has been called with argument true, then things are more complicated. If the <i>depth</i> argument is 0 or if this object is not derived, then this method returns false, indicating that MoML should be exported. Otherwise, whether to export MoML depends on whether the MoML specifies information that should be created by propagation rather than explicitly represented in MoML.  If this is a derived object, then whether its information can be created by propagation depends on whether the object from which that propagation would occur is included in the MoML, which depends on the <i>depth</i> argument. This method uses the <i>depth</i> argument to determine whether the exported MoML both contains an object that implies the existence of this object and contains an object that implies the value of this object.  If both conditions are satisfied, then it returns false.  Finally, if we haven't already returned false, then check all the contained objects, and if any of them requires a MoML description, then return false. Otherwise, return true.
 * @param depth The depth of the requested MoML.
 * @return Return true to suppress MoML export.
 */
protected boolean _isMoMLSuppressed(int depth){
  if (_isPersistent != null) {
    return !_isPersistent.booleanValue();
  }
  if (_derivedLevel > depth) {
    return false;
  }
  if (_override != null) {
    if (_override.size() > depth + 1) {
      return false;
    }
    if (_override.size() == 1 && ((Integer)_override.get(0)).intValue() == 0) {
      return false;
    }
  }
  Iterator objects=containedObjectsIterator();
  while (objects.hasNext()) {
    NamedObj object=(NamedObj)objects.next();
    if (!object._isMoMLSuppressed(depth + 1)) {
      return false;
    }
  }
  return true;
}"
75271,"/** 
 * Specify whether change requests made by calls to requestChange() should be executed immediately. If there is a container, then this request is delegated to the container. Otherwise, if the argument is true, then requests are simply queued until either this method is called again with argument false, or until executeChangeRequests() is called. If the argument is false, then execute any pending change requests and set a flag requesting that future requests be executed immediately.
 * @param isDeferring If true, defer change requests.
 * @see #addChangeListener(ChangeListener)
 * @see #executeChangeRequests()
 * @see #isDeferringChangeRequests()
 * @see #requestChange(ChangeRequest)
 * @see Changeable
 */
public void setDeferringChangeRequests(boolean isDeferring){
  NamedObj container=(NamedObj)getContainer();
  if (container != null) {
    container.setDeferringChangeRequests(isDeferring);
    return;
  }
synchronized (_changeLock) {
    _deferChangeRequests=isDeferring;
    if (isDeferring == false) {
      executeChangeRequests();
    }
  }
}","/** 
 * Specify whether change requests made by calls to requestChange() should be executed immediately. If there is a container, then this request is delegated to the container. Otherwise, if the argument is true, then requests are simply queued until either this method is called again with argument false, or until executeChangeRequests() is called. If the argument is false, then execute any pending change requests and set a flag requesting that future requests be executed immediately.
 * @param isDeferring If true, defer change requests.
 * @return True if this object was previously deferring changerequests.
 * @see #addChangeListener(ChangeListener)
 * @see #executeChangeRequests()
 * @see #isDeferringChangeRequests()
 * @see #requestChange(ChangeRequest)
 * @see Changeable
 */
public boolean setDeferringChangeRequests(boolean isDeferring){
  NamedObj container=(NamedObj)getContainer();
  if (container != null) {
    return container.setDeferringChangeRequests(isDeferring);
  }
synchronized (_changeLock) {
    boolean result=_deferChangeRequests;
    _deferChangeRequests=isDeferring;
    if (isDeferring == false) {
      executeChangeRequests();
    }
    return result;
  }
}"
75272,"/** 
 * End the document. The MoMLParser calls this method once, when it has finished parsing the complete XML document. It is guaranteed that this will be the last method called in the XML parsing process. As a consequence, it is guaranteed that all dependencies between parameters used in the XML description are resolved. This method executes any change requests that may have been made during the parsing process.
 * @exception CancelException If an error occurs parsing one of theparameter values, and the user clicks on ""cancel"" to cancel the parse.
 */
public void endDocument() throws Exception {
  _processPendingRequests();
  if (_handler != null) {
    _handler.enableErrorSkipping(false);
  }
  if (_undoEnabled && _undoContext != null && _undoContext.hasUndoMoML()) {
    String undoMoML=_undoContext.getUndoMoML();
    if (_undoDebug) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.print(undoMoML);
      System.out.println(""String_Node_Str"");
    }
    NamedObj context=_current;
    if (context == null) {
      context=_toplevel;
    }
    MoMLUndoEntry newEntry=new MoMLUndoEntry(context,undoMoML);
    UndoStackAttribute undoInfo=UndoStackAttribute.getUndoInfo(context);
    undoInfo.push(newEntry);
    _resetUndo();
  }
  if (_unrecognized != null) {
    StringBuffer warning=new StringBuffer(""String_Node_Str"");
    Iterator elements=_unrecognized.iterator();
    while (elements.hasNext()) {
      warning.append(""String_Node_Str"" + elements.next().toString());
    }
    try {
      MessageHandler.warning(warning.toString());
    }
 catch (    CancelException ex) {
    }
  }
  if (_toplevel != null) {
    _toplevel.setDeferringChangeRequests(_previousDeferStatus);
    _toplevel.executeChangeRequests();
  }
  Iterator parameters=_paramsToParse.iterator();
  while (parameters.hasNext()) {
    Settable param=(Settable)parameters.next();
    try {
      param.validate();
      Iterator derivedParams=((NamedObj)param).getDerivedList().iterator();
      while (derivedParams.hasNext()) {
        Settable derivedParam=(Settable)derivedParams.next();
        derivedParam.validate();
      }
    }
 catch (    Exception ex) {
      if (_handler != null) {
        int reply=_handler.handleError(""String_Node_Str"" + param.getName() + ""String_Node_Str""+ param.getExpression()+ ""String_Node_Str"",(NamedObj)param.getContainer(),ex);
        if (reply == ErrorHandler.CONTINUE) {
          continue;
        }
      }
      throw ex;
    }
  }
}","/** 
 * End the document. The MoMLParser calls this method once, when it has finished parsing the complete XML document. It is guaranteed that this will be the last method called in the XML parsing process. As a consequence, it is guaranteed that all dependencies between parameters used in the XML description are resolved. This method executes any change requests that may have been made during the parsing process.
 * @exception CancelException If an error occurs parsing one of theparameter values, and the user clicks on ""cancel"" to cancel the parse.
 */
public void endDocument() throws Exception {
  _processPendingRequests();
  if (_undoEnabled && _undoContext != null && _undoContext.hasUndoMoML()) {
    String undoMoML=_undoContext.getUndoMoML();
    if (_undoDebug) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.print(undoMoML);
      System.out.println(""String_Node_Str"");
    }
    NamedObj context=_current;
    if (context == null) {
      context=_toplevel;
    }
    MoMLUndoEntry newEntry=new MoMLUndoEntry(context,undoMoML);
    UndoStackAttribute undoInfo=UndoStackAttribute.getUndoInfo(context);
    undoInfo.push(newEntry);
    _resetUndo();
  }
  if (_unrecognized != null) {
    StringBuffer warning=new StringBuffer(""String_Node_Str"");
    Iterator elements=_unrecognized.iterator();
    while (elements.hasNext()) {
      warning.append(""String_Node_Str"" + elements.next().toString());
    }
    try {
      MessageHandler.warning(warning.toString());
    }
 catch (    CancelException ex) {
    }
  }
  try {
    if (_toplevel != null) {
      _toplevel.setDeferringChangeRequests(_previousDeferStatus);
      _toplevel.executeChangeRequests();
    }
    Iterator parameters=_paramsToParse.iterator();
    while (parameters.hasNext()) {
      Settable param=(Settable)parameters.next();
      try {
        param.validate();
        Iterator derivedParams=((NamedObj)param).getDerivedList().iterator();
        while (derivedParams.hasNext()) {
          Settable derivedParam=(Settable)derivedParams.next();
          derivedParam.validate();
        }
      }
 catch (      Exception ex) {
        if (_handler != null) {
          int reply=_handler.handleError(""String_Node_Str"" + param.getName() + ""String_Node_Str""+ param.getExpression()+ ""String_Node_Str"",(NamedObj)param.getContainer(),ex);
          if (reply == ErrorHandler.CONTINUE) {
            continue;
          }
        }
        throw ex;
      }
    }
  }
  finally {
    if (_handler != null) {
      _handler.enableErrorSkipping(false);
    }
  }
}"
75273,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new port with no connections and no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return A new Port.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Port newObject=(Port)super.clone(workspace);
  newObject._relationsList=new CrossRefList(newObject);
  newObject._container=null;
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new port with no connections and no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return A new Port.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Port newObject=(Port)super.clone(workspace);
  newObject._relationsList=new CrossRefList(newObject);
  newObject._insideLinks=new CrossRefList(newObject);
  newObject._container=null;
  return newObject;
}"
75274,"/** 
 * Check each remote receiver to see if the number of tokens in the receiver is greater than or equal to the tokenConsumptionRate of the containing port. The actor is deferrable if the above test is true for any receiver. At the same time, find the maximum number of tokens in all receivers, which is used to find minimax actor later on.
 * @param actor The actor to be checked.
 * @return true if the actor is deferrable, false if not.
 * @throws IllegalActionException If any called method throwsIllegalActionException.
 */
protected boolean _isDeferrable(Actor actor) throws IllegalActionException {
  boolean deferrable=false;
  int maxSize=0;
  Iterator outputPorts=actor.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    Receiver[][] farReceivers=outputPort.getRemoteReceivers();
    for (int i=0; i < farReceivers.length; i++)     for (int j=0; j < farReceivers[i].length; j++) {
      SDFReceiver farReceiver=(SDFReceiver)farReceivers[i][j];
      IOPort port=farReceiver.getContainer();
      if (port == outputPort)       continue;
      int tokenConsumptionRate=1;
      Parameter rate=null;
      if (port.isInput()) {
        rate=(Parameter)port.getAttribute(""String_Node_Str"");
        if (rate == null) {
          rate=(Parameter)port.getAttribute(""String_Node_Str"");
        }
      }
      if (port.isOutput()) {
        rate=(Parameter)port.getAttribute(""String_Node_Str"");
        if (rate == null) {
          rate=(Parameter)port.getAttribute(""String_Node_Str"");
        }
      }
      if (rate != null) {
        Token token=rate.getToken();
        if (token instanceof ArrayToken) {
          Token[] tokens=((ArrayToken)token).arrayValue();
          Receiver[][] portReceivers=port.getReceivers();
          int channelIndex=0;
          foundChannelIndex:           for (int m=0; m < portReceivers.length; m++)           for (int n=0; n < portReceivers[m].length; n++)           if (farReceiver == portReceivers[m][n]) {
            channelIndex=m;
            break foundChannelIndex;
          }
          tokenConsumptionRate=((IntToken)tokens[channelIndex]).intValue();
        }
 else {
          tokenConsumptionRate=((IntToken)token).intValue();
        }
      }
      if (farReceiver.size() >= tokenConsumptionRate) {
        deferrable=true;
      }
      if (farReceiver.size() > maxSize) {
        maxSize=farReceiver.size();
      }
    }
  }
  if (deferrable) {
    int[] flags=(int[])_actorsFlags.get(actor);
    flags[_maxNumberOfTokens]=maxSize;
  }
  return deferrable;
}","/** 
 * Check each remote receiver to see if the number of tokens in the receiver is greater than or equal to the tokenConsumptionRate of the containing port. The actor is deferrable if the above test is true for any receiver. At the same time, find the maximum number of tokens in all receivers, which is used to find minimax actor later on.
 * @param actor The actor to be checked.
 * @return true if the actor is deferrable, false if not.
 * @throws IllegalActionException If any called method throwsIllegalActionException.
 */
protected boolean _isDeferrable(Actor actor) throws IllegalActionException {
  boolean deferrable=false;
  int maxSize=0;
  Iterator outputPorts=actor.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort outputPort=(IOPort)outputPorts.next();
    Receiver[][] farReceivers=outputPort.getRemoteReceivers();
    for (int i=0; i < farReceivers.length; i++)     for (int j=0; j < farReceivers[i].length; j++) {
      SDFReceiver farReceiver=(SDFReceiver)farReceivers[i][j];
      IOPort port=farReceiver.getContainer();
      if (port == outputPort)       continue;
      int tokenConsumptionRate=1;
      Variable rate=null;
      if (port.isInput()) {
        rate=SDFUtilities.getRateVariable(port,""String_Node_Str"");
      }
      if (port.isOutput()) {
        rate=SDFUtilities.getRateVariable(port,""String_Node_Str"");
      }
      if (rate != null) {
        Token token=rate.getToken();
        if (token instanceof ArrayToken) {
          Token[] tokens=((ArrayToken)token).arrayValue();
          Receiver[][] portReceivers=port.getReceivers();
          int channelIndex=0;
          foundChannelIndex:           for (int m=0; m < portReceivers.length; m++)           for (int n=0; n < portReceivers[m].length; n++)           if (farReceiver == portReceivers[m][n]) {
            channelIndex=m;
            break foundChannelIndex;
          }
          tokenConsumptionRate=((IntToken)tokens[channelIndex]).intValue();
        }
 else {
          tokenConsumptionRate=((IntToken)token).intValue();
        }
      }
      if (farReceiver.size() >= tokenConsumptionRate) {
        deferrable=true;
      }
      if (farReceiver.size() > maxSize) {
        maxSize=farReceiver.size();
      }
    }
  }
  if (deferrable) {
    int[] flags=(int[])_actorsFlags.get(actor);
    flags[_maxNumberOfTokens]=maxSize;
  }
  return deferrable;
}"
75275,"/** 
 * The actor is enabled if the tokenConsumptionRate on each input port is satisfied by all receivers contained by this port.
 * @param actor The actor to be checked.
 * @return true if the actor is enabled, false if not.
 * @throws IllegalActionException If any called method throwsIllegalActionException.
 */
protected boolean _isEnabled(Actor actor) throws IllegalActionException {
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    int tokenConsumptionRate=1;
    Parameter parameter=(Parameter)inputPort.getAttribute(""String_Node_Str"");
    if (parameter == null) {
      parameter=(Parameter)inputPort.getAttribute(""String_Node_Str"");
    }
    if (parameter != null) {
      Token token=parameter.getToken();
      if (token instanceof ArrayToken) {
        Token[] tokens=((ArrayToken)token).arrayValue();
        if (tokens.length < inputPort.getWidth())         throw new IllegalActionException(this,(ComponentEntity)actor,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        for (int i=0; i < inputPort.getWidth(); i++) {
          int channelRate=((IntToken)tokens[i]).intValue();
          if (!inputPort.hasToken(i,channelRate)) {
            return false;
          }
        }
        return true;
      }
 else {
        tokenConsumptionRate=((IntToken)token).intValue();
      }
    }
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (!inputPort.hasToken(i,tokenConsumptionRate)) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * The actor is enabled if the tokenConsumptionRate on each input port is satisfied by all receivers contained by this port.
 * @param actor The actor to be checked.
 * @return true if the actor is enabled, false if not.
 * @throws IllegalActionException If any called method throwsIllegalActionException.
 */
protected boolean _isEnabled(Actor actor) throws IllegalActionException {
  Iterator inputPorts=actor.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    int tokenConsumptionRate=1;
    Variable parameter=SDFUtilities.getRateVariable(inputPort,""String_Node_Str"");
    if (parameter != null) {
      Token token=parameter.getToken();
      if (token instanceof ArrayToken) {
        Token[] tokens=((ArrayToken)token).arrayValue();
        if (tokens.length < inputPort.getWidth())         throw new IllegalActionException(this,(ComponentEntity)actor,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        for (int i=0; i < inputPort.getWidth(); i++) {
          int channelRate=((IntToken)tokens[i]).intValue();
          if (!inputPort.hasToken(i,channelRate)) {
            return false;
          }
        }
        return true;
      }
 else {
        tokenConsumptionRate=((IntToken)token).intValue();
      }
    }
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (!inputPort.hasToken(i,tokenConsumptionRate)) {
        return false;
      }
    }
  }
  return true;
}"
75276,"/** 
 * Get token production rate for the given port.
 * @param port The port to get token production rate.
 * @return An int array of token production rate.
 * @throws IllegalActionException If parameter throws itor the length of tokenProductionRate array is less  than port inside width.
 */
private int[] _getTokenProductionRate(IOPort port) throws IllegalActionException {
  int[] rate=new int[port.getWidthInside()];
  Arrays.fill(rate,1);
  Parameter parameter=(Parameter)port.getAttribute(""String_Node_Str"");
  if (parameter == null)   parameter=(Parameter)port.getAttribute(""String_Node_Str"");
  if (parameter != null) {
    Token token=parameter.getToken();
    if (token instanceof ArrayToken) {
      Token[] tokens=((ArrayToken)token).arrayValue();
      if (tokens.length < port.getWidthInside())       throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      for (int i=0; i < port.getWidthInside(); i++)       rate[i]=((IntToken)tokens[i]).intValue();
    }
 else {
      Arrays.fill(rate,((IntToken)token).intValue());
    }
  }
  return rate;
}","/** 
 * Get token production rate for the given port.
 * @param port The port to get token production rate.
 * @return An int array of token production rate.
 * @throws IllegalActionException If parameter throws itor the length of tokenProductionRate array is less  than port inside width.
 */
private int[] _getTokenProductionRate(IOPort port) throws IllegalActionException {
  int[] rate=new int[port.getWidthInside()];
  Arrays.fill(rate,1);
  Variable parameter=SDFUtilities.getRateVariable(port,""String_Node_Str"");
  if (parameter != null) {
    Token token=parameter.getToken();
    if (token instanceof ArrayToken) {
      Token[] tokens=((ArrayToken)token).arrayValue();
      if (tokens.length < port.getWidthInside())       throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      for (int i=0; i < port.getWidthInside(); i++)       rate[i]=((IntToken)tokens[i]).intValue();
    }
 else {
      Arrays.fill(rate,((IntToken)token).intValue());
    }
  }
  return rate;
}"
75277,"/** 
 * Get token consumption rate for the given port.
 * @param port The port to get token consumption rate.
 * @return An int array of token consumption rate.
 * @throws IllegalActionException If parameter throws it or the length of tokenConsumptionRate array is less than port width.
 */
private int[] _getTokenConsumptionRate(IOPort port) throws IllegalActionException {
  int[] rate=new int[port.getWidth()];
  Arrays.fill(rate,1);
  Parameter parameter=(Parameter)port.getAttribute(""String_Node_Str"");
  if (parameter == null)   parameter=(Parameter)port.getAttribute(""String_Node_Str"");
  if (parameter != null) {
    Token token=parameter.getToken();
    if (token instanceof ArrayToken) {
      Token[] tokens=((ArrayToken)token).arrayValue();
      if (tokens.length < port.getWidth())       throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      for (int i=0; i < port.getWidth(); i++)       rate[i]=((IntToken)tokens[i]).intValue();
    }
 else {
      Arrays.fill(rate,((IntToken)token).intValue());
    }
  }
  return rate;
}","/** 
 * Get token consumption rate for the given port.
 * @param port The port to get token consumption rate.
 * @return An int array of token consumption rate.
 * @throws IllegalActionException If parameter throws it or the length of tokenConsumptionRate array is less than port width.
 */
private int[] _getTokenConsumptionRate(IOPort port) throws IllegalActionException {
  int[] rate=new int[port.getWidth()];
  Arrays.fill(rate,1);
  Variable parameter=SDFUtilities.getRateVariable(port,""String_Node_Str"");
  if (parameter != null) {
    Token token=parameter.getToken();
    if (token instanceof ArrayToken) {
      Token[] tokens=((ArrayToken)token).arrayValue();
      if (tokens.length < port.getWidth())       throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      for (int i=0; i < port.getWidth(); i++)       rate[i]=((IntToken)tokens[i]).intValue();
    }
 else {
      Arrays.fill(rate,((IntToken)token).intValue());
    }
  }
  return rate;
}"
75278,"/** 
 * Adjust the deferrals in this object. Specifically, if this object has a class name that refers to a class in scope, then replace the current parent with that object.
 * @exception IllegalActionException If the class found in scopecannot be set.
 */
protected void _adjustDeferrals() throws IllegalActionException {
  String className=getClassName();
  NamedObj context=this;
  ComponentEntity candidate=null;
  while ((candidate == null || !candidate.isClassDefinition()) && context != null) {
    context=(NamedObj)context.getContainer();
    if (context instanceof CompositeEntity) {
      candidate=((CompositeEntity)context).getEntity(className);
    }
  }
  if (candidate != null) {
    _setParent(candidate);
    _markContentsDerived(0);
    candidate.propagateValues();
  }
}","/** 
 * Adjust the deferrals in this object. This method should be called on any newly created object that is created by cloning. While cloning, parent relations are set to null. That is, no object in the clone has a parent. This method identifies the correct parent for any object in the clone. To do this, it uses the class name. Specifically, if this object has a class name that refers to a class in scope, then it replaces the current parent with that object. To look for a class in scope, we go up the hierarchy, but no more times than the return value of getDerivedLevel(). The reason for this is that if the class from which this object is defined is above that level, then we do not want to establish a parent relationship with that class. This object is implied, and the parent relationship of the object from which it is implied is sufficient. <p> Derived classes that contain other objects should recursively call this method on contained objects.
 * @exception IllegalActionException If the class found in scopecannot be set.
 */
protected void _adjustDeferrals() throws IllegalActionException {
  String className=getClassName();
  NamedObj context=this;
  int levelsToSearch=getDerivedLevel();
  int aboveLevel=0;
  ComponentEntity candidate=null;
  while (aboveLevel < levelsToSearch && (candidate == null || !candidate.isClassDefinition()) && context != null) {
    context=(NamedObj)context.getContainer();
    if (context instanceof CompositeEntity) {
      candidate=((CompositeEntity)context).getEntity(className);
    }
    aboveLevel+=1;
  }
  if (candidate != null) {
    _setParent(candidate);
    _markContentsDerived(0);
    candidate.propagateValues();
  }
}"
75279,"/** 
 * Adjust the deferrals in this object. Specifically, if this object has a class name that refers to a class in scope, then replace the current parent with that object. Override the base class to also call the same method on all contained class definitions and ordinary entities.
 * @exception IllegalActionException If the class found in scopecannot be set.
 */
protected void _adjustDeferrals() throws IllegalActionException {
  super._adjustDeferrals();
  Iterator containedClasses=classDefinitionList().iterator();
  while (containedClasses.hasNext()) {
    NamedObj containedObject=(NamedObj)containedClasses.next();
    if (containedObject instanceof ComponentEntity) {
      ((ComponentEntity)containedObject)._adjustDeferrals();
    }
  }
  Iterator containedEntities=entityList().iterator();
  while (containedEntities.hasNext()) {
    NamedObj containedObject=(NamedObj)containedEntities.next();
    if (containedObject instanceof ComponentEntity) {
      ((ComponentEntity)containedObject)._adjustDeferrals();
    }
  }
}","/** 
 * Adjust the deferrals in this object. This method should be called on any newly created object that is created by cloning. While cloning, parent relations are set to null. That is, no object in the clone has a parent. This method identifies the correct parent for any object in the clone. To do this, it uses the class name. Specifically, if this object has a class name that refers to a class in scope, then it replaces the current parent with that object. To look for a class in scope, we go up the hierarchy, but no more times than the return value of getDerivedLevel(). The reason for this is that if the class from which this object is defined is above that level, then we do not want to establish a parent relationship with that class. This object is implied, and the parent relationship of the object from which it is implied is sufficient. <p> Derived classes that contain other objects should recursively call this method on contained objects.
 * @exception IllegalActionException If the class found in scopecannot be set.
 */
protected void _adjustDeferrals() throws IllegalActionException {
  super._adjustDeferrals();
  Iterator containedClasses=classDefinitionList().iterator();
  while (containedClasses.hasNext()) {
    NamedObj containedObject=(NamedObj)containedClasses.next();
    if (containedObject instanceof ComponentEntity) {
      ((ComponentEntity)containedObject)._adjustDeferrals();
    }
  }
  Iterator containedEntities=entityList().iterator();
  while (containedEntities.hasNext()) {
    NamedObj containedObject=(NamedObj)containedEntities.next();
    if (containedObject instanceof ComponentEntity) {
      ((ComponentEntity)containedObject)._adjustDeferrals();
    }
  }
}"
75280,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new instance of InstantiableNamedObj that is a child of the parent of this object, if this object has a parent. The new instance has no children. This method gets read access on the workspace associated with this object.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return A new instance of InstantiableNamedObj.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  try {
    workspace().getReadAccess();
    InstantiableNamedObj newObject=(InstantiableNamedObj)super.clone(workspace);
    newObject._children=null;
    newObject._parent=null;
    if (_parent != null) {
      try {
        newObject._setParent(_parent);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex);
      }
    }
    return newObject;
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new instance of InstantiableNamedObj that is a child of the parent of this object, if this object has a parent. The new instance has no children. This method gets read access on the workspace associated with this object.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If one of the attributescannot be cloned.
 * @return A new instance of InstantiableNamedObj.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  try {
    workspace().getReadAccess();
    InstantiableNamedObj newObject=(InstantiableNamedObj)super.clone(workspace);
    newObject._children=null;
    newObject._parent=null;
    return newObject;
  }
  finally {
    workspace().doneReading();
  }
}"
75281,"/** 
 * Output the data read in the prefire.
 * @exception IllegalActionException If there's no director orif the directory or URL is invalid.
 */
public void fire() throws IllegalActionException {
  super.fire();
  URL sourceURL=directoryOrURL.asURL();
  if (sourceURL == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (sourceURL.getProtocol().equals(""String_Node_Str"")) {
    File sourceFile=directoryOrURL.asFile();
    if (sourceFile.isDirectory()) {
      File[] files=sourceFile.listFiles(this);
      StringToken[] result=new StringToken[files.length];
      for (int i=0; i < files.length; i++) {
        result[i]=new StringToken(files[i].getAbsolutePath());
      }
      output.broadcast(new ArrayToken(result));
      return;
    }
 else     if (sourceFile.isFile()) {
      StringToken[] result=new StringToken[1];
      result[0]=new StringToken(sourceFile.toString());
      output.broadcast(new ArrayToken(result));
      return;
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + directoryOrURL + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 else {
    try {
      _readURL(sourceURL);
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + directoryOrURL + ""String_Node_Str"");
    }
  }
}","/** 
 * Output the data read in the prefire.
 * @exception IllegalActionException If there's no director orif the directory or URL is invalid.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (directoryOrURLPort.getWidth() > 0 && directoryOrURLPort.hasToken(0)) {
    String newValue=((StringToken)directoryOrURLPort.get(0)).stringValue();
    directoryOrURL.setExpression(newValue);
  }
  URL sourceURL=directoryOrURL.asURL();
  if (sourceURL == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (sourceURL.getProtocol().equals(""String_Node_Str"")) {
    File sourceFile=directoryOrURL.asFile();
    if (sourceFile.isDirectory()) {
      File[] files=sourceFile.listFiles(this);
      StringToken[] result=new StringToken[files.length];
      for (int i=0; i < files.length; i++) {
        result[i]=new StringToken(files[i].getAbsolutePath());
      }
      output.broadcast(new ArrayToken(result));
      return;
    }
 else     if (sourceFile.isFile()) {
      StringToken[] result=new StringToken[1];
      result[0]=new StringToken(sourceFile.toString());
      output.broadcast(new ArrayToken(result));
      return;
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + directoryOrURL + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 else {
    try {
      _readURL(sourceURL);
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + directoryOrURL + ""String_Node_Str"");
    }
  }
}"
75282,"/** 
 * Return true if there are input to this composite actor, and the current time of the outside domain is greater than or equal to the current time. Return false if there are no inputs and the outside time is less than the current time. Throw an exception if there are inputs and the outside time is less than the current time.
 * @return True if the composite actor is ready to run for oneiteration.
 * @exception IllegalActionException If there are input eventsin the past, or the outside time is larger than the time stamp of the first event in the event queue.
 */
public boolean prefire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (!_isEmbedded()) {
    return true;
  }
  CompositeActor container=(CompositeActor)getContainer();
  double outsideCurrentTime=((Actor)container).getExecutiveDirector().getCurrentTime();
  double nextEventTime=Double.MAX_VALUE;
  if (!_eventQueue.isEmpty()) {
    nextEventTime=_eventQueue.get().timeStamp();
  }
  if (nextEventTime == Double.NEGATIVE_INFINITY) {
    nextEventTime=outsideCurrentTime;
  }
  if (outsideCurrentTime > nextEventTime + 1e-10) {
    throw new IllegalActionException(this,""String_Node_Str"" + nextEventTime + ""String_Node_Str""+ ""String_Node_Str""+ +outsideCurrentTime+ ""String_Node_Str"");
  }
  Iterator inputPorts=container.inputPortList().iterator();
  boolean hasInput=false;
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)inputPorts.next();
    for (int i=0; i < port.getWidth(); i++) {
      if (port.hasToken(i)) {
        hasInput=true;
        break;
      }
    }
  }
  if (hasInput) {
    if (outsideCurrentTime < (getCurrentTime() - 1e-10)) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + outsideCurrentTime + ""String_Node_Str""+ getCurrentTime()+ ""String_Node_Str"");
    }
    if (Math.abs(nextEventTime - outsideCurrentTime) < 1e-10) {
      setCurrentTime(nextEventTime);
    }
 else {
      setCurrentTime(outsideCurrentTime);
    }
    return true;
  }
 else {
    if (Math.abs(nextEventTime - outsideCurrentTime) < 1e-10) {
      setCurrentTime(nextEventTime);
      return true;
    }
 else {
      return false;
    }
  }
}","/** 
 * Return true if there are input to this composite actor, and the current time of the outside domain is greater than or equal to the current time. Return false if there are no inputs and the outside time is less than the current time. Throw an exception if there are inputs and the outside time is less than the current time.
 * @return True if the composite actor is ready to run for oneiteration.
 * @exception IllegalActionException If there are input eventsin the past, or the outside time is larger than the time stamp of the first event in the event queue.
 */
public boolean prefire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (!_isEmbedded()) {
    return true;
  }
  CompositeActor container=(CompositeActor)getContainer();
  double outsideCurrentTime=((Actor)container).getExecutiveDirector().getCurrentTime();
  double nextEventTime=Double.MAX_VALUE;
  if (!_eventQueue.isEmpty()) {
    nextEventTime=_eventQueue.get().timeStamp();
  }
  if (nextEventTime == Double.NEGATIVE_INFINITY) {
    nextEventTime=outsideCurrentTime;
    return true;
  }
  if (outsideCurrentTime > nextEventTime) {
    throw new IllegalActionException(this,""String_Node_Str"" + nextEventTime + ""String_Node_Str""+ ""String_Node_Str""+ +outsideCurrentTime+ ""String_Node_Str"");
  }
  Iterator inputPorts=container.inputPortList().iterator();
  boolean hasInput=false;
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)inputPorts.next();
    for (int i=0; i < port.getWidth(); i++) {
      if (port.hasToken(i)) {
        hasInput=true;
        break;
      }
    }
  }
  if (hasInput) {
    setCurrentTime(outsideCurrentTime);
    return true;
  }
 else {
    if (nextEventTime == outsideCurrentTime) {
      setCurrentTime(nextEventTime);
      return true;
    }
 else {
      return false;
    }
  }
}"
75283,"/** 
 * This method, which is required by the ImageObserver interface, is called if something has changed in a background loading of the image.
 * @param image The image being observed.
 * @param infoflags The bitwise inclusive OR of the following flags:WIDTH, HEIGHT, PROPERTIES, SOMEBITS, FRAMEBITS, ALLBITS, ERROR, ABORT.
 * @param x The x coordinate of the image.
 * @param y The y coordinate of the image.
 * @param width The width of the image.
 * @param height The height of the image.
 * @return False if the infoflags indicate that the image iscompletely loaded; true otherwise.
 */
public boolean imageUpdate(Image image,int infoflags,int x,int y,int width,int height){
  if (((infoflags | ImageObserver.WIDTH) != 0) || ((infoflags | ImageObserver.HEIGHT) != 0)) {
    scaleImage(_scalePercentage);
    return false;
  }
  if (((infoflags | ImageObserver.ERROR) != 0) || ((infoflags | ImageObserver.ABORT) != 0)) {
    return false;
  }
  Runnable doRepaint=new Runnable(){
    public void run(){
      Iterator figures=_liveFigureIterator();
      while (figures.hasNext()) {
        Object figure=figures.next();
        ((ImageFigure)figure).repaint();
      }
    }
  }
;
  SwingUtilities.invokeLater(doRepaint);
  return true;
}","/** 
 * This method, which is required by the ImageObserver interface, is called if something has changed in a background loading of the image.
 * @param image The image being observed.
 * @param infoflags The bitwise inclusive OR of the following flags:WIDTH, HEIGHT, PROPERTIES, SOMEBITS, FRAMEBITS, ALLBITS, ERROR, ABORT.
 * @param x The x coordinate of the image.
 * @param y The y coordinate of the image.
 * @param width The width of the image.
 * @param height The height of the image.
 * @return False if the infoflags indicate that the image iscompletely loaded; true otherwise.
 */
public boolean imageUpdate(Image image,int infoflags,int x,int y,int width,int height){
  if ((infoflags & (ImageObserver.HEIGHT | ImageObserver.WIDTH)) != 0) {
    _height=height;
    _width=width;
    _image.getWidth(this);
    _image.getHeight(this);
    return true;
  }
  if ((infoflags & ImageObserver.ALLBITS) != 0) {
    scaleImage(_scalePercentage);
    requestChange(new MoMLChangeRequest(this,this,""String_Node_Str""));
    Runnable doRepaint=new Runnable(){
      public void run(){
        Iterator figures=_liveFigureIterator();
        while (figures.hasNext()) {
          Object figure=figures.next();
          ((ImageFigure)figure).repaint();
        }
      }
    }
;
    SwingUtilities.invokeLater(doRepaint);
    return false;
  }
  if ((infoflags & (ImageObserver.ERROR | ImageObserver.ABORT)) != 0) {
    return false;
  }
  _image.getWidth(this);
  _image.getHeight(this);
  return true;
}"
75284,"/** 
 * Specify a scaling for the image as a percentage.
 * @param percentage The scaling percentage.
 */
public void scaleImage(double percentage){
  _scalePercentage=percentage;
  Runnable doScale=new Runnable(){
    public void run(){
      if (_image == null) {
        return;
      }
      int width=_image.getWidth(ImageIcon.this);
      int height=_image.getHeight(ImageIcon.this);
      if (width > 0 && height > 0) {
        int newWidth=(int)Math.round(width * _scalePercentage / 100.0);
        int newHeight=(int)Math.round(height * _scalePercentage / 100.0);
        _scaledImage=_image.getScaledInstance(newWidth,newHeight,Image.SCALE_SMOOTH);
        Iterator figures=_liveFigureIterator();
        while (figures.hasNext()) {
          Object figure=figures.next();
          ((ImageFigure)figure).setCentered(false);
          ((ImageFigure)figure).setImage(_scaledImage);
        }
      }
    }
  }
;
  SwingUtilities.invokeLater(doScale);
}","/** 
 * Specify a scaling for the image as a percentage.
 * @param percentage The scaling percentage.
 */
public void scaleImage(double percentage){
  if (percentage == _scalePercentage) {
    return;
  }
  _scalePercentage=percentage;
  Runnable doScale=new Runnable(){
    public void run(){
      if (_image == null) {
        return;
      }
      int width=_image.getWidth(ImageIcon.this);
      int height=_image.getHeight(ImageIcon.this);
      if (width < 0 || height < 0) {
        width=_width;
        height=_height;
      }
      if (width > 0 && height > 0) {
        int newWidth=(int)Math.round(width * _scalePercentage / 100.0);
        int newHeight=(int)Math.round(height * _scalePercentage / 100.0);
        _scaledImage=_image.getScaledInstance(newWidth,newHeight,Image.SCALE_SMOOTH);
        _scaledImage.getWidth(ImageIcon.this);
        _scaledImage.getHeight(ImageIcon.this);
        Iterator figures=_liveFigureIterator();
        while (figures.hasNext()) {
          Object figure=figures.next();
          ((ImageFigure)figure).setCentered(false);
          ((ImageFigure)figure).setImage(_scaledImage);
        }
      }
    }
  }
;
  SwingUtilities.invokeLater(doScale);
}"
75285,"/** 
 * Specify an image to display.  This is deferred and executed in the Swing thread.
 * @param image The image to display.
 */
public void setImage(Image image){
  _image=image;
  _scaledImage=image;
  Runnable doSet=new Runnable(){
    public void run(){
      Iterator figures=_liveFigureIterator();
      while (figures.hasNext()) {
        Object figure=figures.next();
        ((ImageFigure)figure).setImage(_scaledImage);
        if (_scalePercentage != 100.0) {
          scaleImage(_scalePercentage);
        }
      }
    }
  }
;
  SwingUtilities.invokeLater(doSet);
}","/** 
 * Specify an image to display.  This is deferred and executed in the Swing thread.
 * @param image The image to display.
 */
public void setImage(Image image){
  _image=image;
  _scaledImage=image;
  _image.getWidth(this);
  _image.getHeight(this);
  Runnable doSet=new Runnable(){
    public void run(){
      Iterator figures=_liveFigureIterator();
      while (figures.hasNext()) {
        Object figure=figures.next();
        ((ImageFigure)figure).setImage(_scaledImage);
        if (_scalePercentage != 100.0) {
          scaleImage(_scalePercentage);
        }
      }
    }
  }
;
  SwingUtilities.invokeLater(doSet);
}"
75286,"/** 
 * Return a string representation of the UnitSystem.
 * @return A string representation of the UnitSystem
 */
public static String summarizeUnitCategories(){
synchronized (_indexTable) {
    return ""String_Node_Str"" + categories + _categoryList.toString();
  }
}","/** 
 * Return a string representation of the UnitSystem.
 * @return A string representation of the UnitSystem
 */
public static String summarizeUnitCategories(){
synchronized (_indexTable) {
    return ""String_Node_Str"" + _categories + ""String_Node_Str""+ _categoryList.toString();
  }
}"
75287,"/** 
 * Override the base class to queue a change request to remove any previously contained entity and its mirrored ports, and to mirror the ports of the added entity.
 * @param entity Entity to contain.
 * @exception IllegalActionException If the entity has no name, or theaction would result in a recursive containment structure, or the argument does not implement the TypedActor interface.
 * @exception NameDuplicationException If the name collides with a namealready on the actor contents list, or if the added element is a class definition.
 */
protected void _addEntity(ComponentEntity entity) throws IllegalActionException, NameDuplicationException {
  if (entity.isClassDefinition()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super._addEntity(entity);
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
    protected void _execute() throws Exception {
synchronized (this) {
        ComponentEntity entity=null;
        Iterator priors=entityList().iterator();
        while (priors.hasNext()) {
          ComponentEntity prior=(ComponentEntity)priors.next();
          if (priors.hasNext() && getDerivedLevel() < Integer.MAX_VALUE) {
            prior.setContainer(null);
          }
 else {
            entity=prior;
          }
        }
        if (entity == null) {
          return;
        }
        int count=1;
        Iterator entityPorts=entity.portList().iterator();
        while (entityPorts.hasNext()) {
          ComponentPort insidePort=(ComponentPort)entityPorts.next();
          String name=insidePort.getName();
          IteratePort newPort=(IteratePort)getPort(name);
          if (newPort == null) {
            newPort=(IteratePort)newPort(name);
          }
          if (insidePort instanceof IOPort) {
            IOPort castPort=(IOPort)insidePort;
            newPort.setMultiport(castPort.isMultiport());
            newPort.setInput(castPort.isInput());
            newPort.setOutput(castPort.isOutput());
          }
          List connectedPorts=insidePort.connectedPortList();
          if (!connectedPorts.contains(newPort)) {
            ComponentRelation relation=newRelation(uniqueName(""String_Node_Str""));
            newPort.link(relation);
            insidePort.link(relation);
          }
        }
      }
    }
  }
;
  requestChange(request);
}","/** 
 * Override the base class to queue a change request to remove any previously contained entity and its mirrored ports, and to mirror the ports of the added entity.
 * @param entity Entity to contain.
 * @exception IllegalActionException If the entity has no name, or theaction would result in a recursive containment structure, or the argument does not implement the TypedActor interface.
 * @exception NameDuplicationException If the name collides with a namealready on the actor contents list, or if the added element is a class definition.
 */
protected void _addEntity(ComponentEntity entity) throws IllegalActionException, NameDuplicationException {
  if (entity.isClassDefinition()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super._addEntity(entity);
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
    protected void _execute() throws Exception {
synchronized (this) {
        ComponentEntity entity=null;
        List priorEntities=entityList();
        Iterator priors=priorEntities.iterator();
        while (priors.hasNext()) {
          ComponentEntity prior=(ComponentEntity)priors.next();
          if (priors.hasNext()) {
            prior.setContainer(null);
          }
 else {
            entity=prior;
          }
        }
        if (entity == null) {
          return;
        }
        int count=1;
        Iterator entityPorts=entity.portList().iterator();
        while (entityPorts.hasNext()) {
          ComponentPort insidePort=(ComponentPort)entityPorts.next();
          String name=insidePort.getName();
          IteratePort newPort=(IteratePort)getPort(name);
          if (newPort == null) {
            newPort=(IteratePort)newPort(name);
          }
          if (insidePort instanceof IOPort) {
            IOPort castPort=(IOPort)insidePort;
            newPort.setMultiport(castPort.isMultiport());
            newPort.setInput(castPort.isInput());
            newPort.setOutput(castPort.isOutput());
          }
          List connectedPorts=insidePort.connectedPortList();
          if (!connectedPorts.contains(newPort)) {
            ComponentRelation relation=newRelation(uniqueName(""String_Node_Str""));
            newPort.link(relation);
            insidePort.link(relation);
          }
        }
      }
    }
  }
;
  requestChange(request);
}"
75288,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ImageAttribute newObject=(ImageAttribute)super.clone(workspace);
  try {
    newObject._icon=new ImageIcon(this,""String_Node_Str"");
    newObject._icon.setPersistent(false);
  }
 catch (  KernelException e) {
    throw new InternalErrorException(e);
  }
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ImageAttribute newObject=(ImageAttribute)super.clone(workspace);
  newObject._icon=(ImageIcon)newObject.getAttribute(""String_Node_Str"");
  return newObject;
}"
75289,"/** 
 * Construct an attribute with the given name contained by the specified container. The container argument must not be null, or a NullPointerException will be thrown.  This attribute will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container, or if the name contains a period.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public ImageAttribute(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  new SingletonAttribute(this,""String_Node_Str"");
  _icon=new ImageIcon(this,""String_Node_Str"");
  _icon.setPersistent(false);
  source=new FileParameter(this,""String_Node_Str"");
  source.setExpression(""String_Node_Str"");
  scale=new Parameter(this,""String_Node_Str"");
  scale.setTypeEquals(BaseType.DOUBLE);
  scale.setExpression(""String_Node_Str"");
  new ResizableAttributeControllerFactory(this,""String_Node_Str"");
}","/** 
 * Construct an attribute with the given name contained by the specified container. The container argument must not be null, or a NullPointerException will be thrown.  This attribute will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container, or if the name contains a period.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public ImageAttribute(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  new SingletonAttribute(this,""String_Node_Str"");
  _icon=new ImageIcon(this,""String_Node_Str"");
  _icon.setPersistent(false);
  source=new FileParameter(this,""String_Node_Str"");
  source.setExpression(""String_Node_Str"");
  scale=new Parameter(this,""String_Node_Str"");
  scale.setTypeEquals(BaseType.DOUBLE);
  scale.setExpression(""String_Node_Str"");
}"
75290,"/** 
 * Override the base class to also set the associated port, if there is one.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  super.setName(name);
  if (_associatedPort != null && !_associatedPort.getName().equals(name)) {
    MoMLChangeRequest request=new MoMLChangeRequest(this,_associatedPort.getContainer(),""String_Node_Str"" + name + ""String_Node_Str"");
    _associatedPort.getContainer().requestChange(request);
  }
}","/** 
 * Override the base class to also set the associated port, if there is one.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  super.setName(name);
  if (_associatedPort != null && !_associatedPort.getName().equals(name)) {
    MoMLChangeRequest request=new MoMLChangeRequest(this,_associatedPort,""String_Node_Str"" + name + ""String_Node_Str"");
    _associatedPort.requestChange(request);
  }
}"
75291,"/** 
 * Override the base class to invalidate the schedule and resolved types of the director of the container, if there is one, in addition to what the base class does.
 * @param index The index at which to insert the link.
 * @param relation The relation to link to this port.
 * @exception IllegalActionException If the link would cross levels ofthe hierarchy, or the relation is incompatible, or the port has no container, or the port is not in the same workspace as the relation, or if this port is not a multiport and the index is greater than zero or if another link already exists.
 */
public void insertLink(int index,Relation relation) throws IllegalActionException {
  if (!isMultiport()) {
    if (index > 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (numLinks() > 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  super.insertLink(index,relation);
  _invalidate();
}","/** 
 * Override the base class to invalidate the schedule and resolved types of the director of the container, if there is one, in addition to what the base class does.
 * @param index The index at which to insert the link.
 * @param relation The relation to link to this port.
 * @exception IllegalActionException If the link would cross levels ofthe hierarchy, or the relation is incompatible, or the port has no container, or the port is not in the same workspace as the relation, or if this port is not a multiport and the index is greater than zero or if another link already exists.
 */
public void insertLink(int index,Relation relation) throws IllegalActionException {
  if (!isMultiport()) {
    if (index > 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (_isInsideLinkable(relation)) {
      if (numInsideLinks() > 0) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 else     if (numLinks() > 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  super.insertLink(index,relation);
  _invalidate();
}"
75292,"private final AccessRecord _getAccessRecord(Thread current,boolean createNew){
  AccessRecord record=(AccessRecord)_readerRecords.get(current);
  if (record == null) {
    Iterator records=_readerRecords.values().iterator();
    while (records.hasNext()) {
      AccessRecord aRecord=(AccessRecord)records.next();
      if (aRecord.failedReadAttempts == 0 && aRecord.failedWriteAttempts == 0 && aRecord.readDepth == 0 && aRecord != _lastReaderRecord) {
        records.remove();
      }
    }
    if (createNew) {
      record=new AccessRecord();
      _readerRecords.put(current,record);
    }
  }
  if (record != null) {
    _lastReader=current;
    _lastReaderRecord=record;
  }
  return record;
}","private final AccessRecord _getAccessRecord(Thread current,boolean createNew){
  if (_readerRecords == null) {
    _readerRecords=new HashMap();
  }
  AccessRecord record=(AccessRecord)_readerRecords.get(current);
  if (record == null) {
    Iterator records=_readerRecords.values().iterator();
    while (records.hasNext()) {
      AccessRecord aRecord=(AccessRecord)records.next();
      if (aRecord.failedReadAttempts == 0 && aRecord.failedWriteAttempts == 0 && aRecord.readDepth == 0 && aRecord != _lastReaderRecord) {
        records.remove();
      }
    }
    if (createNew) {
      record=new AccessRecord();
      _readerRecords.put(current,record);
    }
  }
  if (record != null) {
    _lastReader=current;
    _lastReaderRecord=record;
  }
  return record;
}"
75293,"/** 
 * Read at most one token from each channel of each input port and plot it. This is done in postfire to ensure that data has settled. The width of the inputs should be the same, otherwise a exception will be thrown. The channels from the two input ports are matched to give the X and Y position of a single data point.  Each matched channel pair must have at least one token, or a token will be consumed from the input channel that has a token, but nothing will be plotted.
 * @exception IllegalActionException If there is no director,the width of the ports are not the same, or if the base class throws it.
 * @return True if it is OK to continue.
 */
public boolean postfire() throws IllegalActionException {
  boolean hasX=false, hasY=false;
  double xValue=0.0;
  double yValue=0.0;
  int widthX=inputX.getWidth();
  int widthY=inputY.getWidth();
  if (widthX != widthY) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  int offset=((IntToken)startingDataset.getToken()).intValue();
  for (int i=widthX - 1; i >= 0; i--) {
    if (inputX.hasToken(i)) {
      xValue=((DoubleToken)inputX.get(i)).doubleValue();
      hasX=true;
    }
    if (inputY.hasToken(i)) {
      yValue=((DoubleToken)inputY.get(i)).doubleValue();
      hasY=true;
    }
    if (hasX && hasY) {
      ((Plot)plot).addPoint(i + offset,xValue,yValue,true);
    }
  }
  return super.postfire();
}","/** 
 * Read at most one token from each channel of each input port and plot it. This is done in postfire to ensure that data has settled. The width of the inputs should be the same, otherwise a exception will be thrown. The channels from the two input ports are matched to give the X and Y position of a single data point.  Each matched channel pair must have at least one token, or a token will be consumed from the input channel that has a token, but nothing will be plotted.
 * @exception IllegalActionException If there is no director,the width of the ports are not the same, or if the base class throws it.
 * @return True if it is OK to continue.
 */
public boolean postfire() throws IllegalActionException {
  int widthX=inputX.getWidth();
  int widthY=inputY.getWidth();
  if (widthX != widthY) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  int offset=((IntToken)startingDataset.getToken()).intValue();
  for (int i=widthX - 1; i >= 0; i--) {
    boolean hasX=false, hasY=false;
    double xValue=0.0;
    double yValue=0.0;
    if (inputX.hasToken(i)) {
      xValue=((DoubleToken)inputX.get(i)).doubleValue();
      hasX=true;
    }
    if (inputY.hasToken(i)) {
      yValue=((DoubleToken)inputY.get(i)).doubleValue();
      hasY=true;
    }
    if (hasX && hasY) {
      ((Plot)plot).addPoint(i + offset,xValue,yValue,true);
    }
  }
  return super.postfire();
}"
75294,"/** 
 * Add a port to this actor. This overrides the base class to add a corresponding port to the container using a change request.
 * @param port The TypedIOPort to add to this actor.
 * @exception IllegalActionException If the port is not an instance ofMirrorPort, or the port has no name.
 * @exception NameDuplicationException If the port name collides with aname already in the actor.
 */
protected void _addPort(final Port port) throws IllegalActionException, NameDuplicationException {
  if (!(port instanceof MirrorPort)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  super._addPort(port);
  final IterateOverArray container=(IterateOverArray)getContainer();
  if (container._inAddPort) {
    return;
  }
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
    protected void _execute() throws Exception {
      IteratePort newPort=(IteratePort)container.getPort(port.getName());
      if (newPort == null) {
        newPort=(IteratePort)container.newPort(port.getName());
      }
      if (port instanceof IOPort) {
        newPort.setInput(((IOPort)port).isInput());
        newPort.setOutput(((IOPort)port).isOutput());
        newPort.setMultiport(((IOPort)port).isMultiport());
      }
    }
  }
;
  container.requestChange(request);
}","/** 
 * Add a port to this actor. This overrides the base class to add a corresponding port to the container using a change request, if that port does not already exist.
 * @param port The TypedIOPort to add to this actor.
 * @exception IllegalActionException If the port is not an instance ofMirrorPort, or the port has no name.
 * @exception NameDuplicationException If the port name collides with aname already in the actor.
 */
protected void _addPort(final Port port) throws IllegalActionException, NameDuplicationException {
  if (!(port instanceof MirrorPort)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  super._addPort(port);
  final IterateOverArray container=(IterateOverArray)getContainer();
  if (container._inAddPort) {
    return;
  }
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
    protected void _execute() throws Exception {
      IteratePort newPort=(IteratePort)container.getPort(port.getName());
      if (newPort == null) {
        newPort=(IteratePort)container.newPort(port.getName());
      }
      if (port instanceof IOPort) {
        newPort.setInput(((IOPort)port).isInput());
        newPort.setOutput(((IOPort)port).isOutput());
        newPort.setMultiport(((IOPort)port).isMultiport());
      }
    }
  }
;
  container.requestChange(request);
}"
75295,"/** 
 * Override the base class to queue a change request to remove any previously contained entity and its mirrored ports, and to mirror the ports of the added entity.
 * @param entity Entity to contain.
 * @exception IllegalActionException If the entity has no name, or theaction would result in a recursive containment structure, or the argument does not implement the TypedActor interface.
 * @exception NameDuplicationException If the name collides with a namealready on the actor contents list, or if the added element is a class definition.
 */
protected void _addEntity(ComponentEntity entity) throws IllegalActionException, NameDuplicationException {
  if (entity.isClassDefinition()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super._addEntity(entity);
  if (isDerived() || _cloning) {
    return;
  }
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
    protected void _execute() throws Exception {
synchronized (this) {
        ComponentEntity entity=null;
        Iterator priors=entityList().iterator();
        while (priors.hasNext()) {
          ComponentEntity prior=(ComponentEntity)priors.next();
          if (priors.hasNext()) {
            prior.setContainer(null);
          }
 else {
            entity=prior;
          }
        }
        if (entity == null) {
          return;
        }
        int count=1;
        Iterator entityPorts=entity.portList().iterator();
        while (entityPorts.hasNext()) {
          ComponentPort insidePort=(ComponentPort)entityPorts.next();
          String name=insidePort.getName();
          IteratePort newPort=(IteratePort)getPort(name);
          if (newPort == null) {
            newPort=(IteratePort)newPort(name);
          }
          if (insidePort instanceof IOPort) {
            IOPort castPort=(IOPort)insidePort;
            newPort.setMultiport(castPort.isMultiport());
            newPort.setInput(castPort.isInput());
            newPort.setOutput(castPort.isOutput());
          }
          List connectedPorts=insidePort.connectedPortList();
          if (!connectedPorts.contains(newPort)) {
            ComponentRelation relation=newRelation(uniqueName(""String_Node_Str""));
            newPort.link(relation);
            insidePort.liberalLink(relation);
          }
        }
      }
    }
  }
;
  requestChange(request);
}","/** 
 * Override the base class to queue a change request to remove any previously contained entity and its mirrored ports, and to mirror the ports of the added entity.
 * @param entity Entity to contain.
 * @exception IllegalActionException If the entity has no name, or theaction would result in a recursive containment structure, or the argument does not implement the TypedActor interface.
 * @exception NameDuplicationException If the name collides with a namealready on the actor contents list, or if the added element is a class definition.
 */
protected void _addEntity(ComponentEntity entity) throws IllegalActionException, NameDuplicationException {
  if (entity.isClassDefinition()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super._addEntity(entity);
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
    protected void _execute() throws Exception {
synchronized (this) {
        ComponentEntity entity=null;
        Iterator priors=entityList().iterator();
        while (priors.hasNext()) {
          ComponentEntity prior=(ComponentEntity)priors.next();
          if (priors.hasNext() && !isDerived()) {
            prior.setContainer(null);
          }
 else {
            entity=prior;
          }
        }
        if (entity == null) {
          return;
        }
        int count=1;
        Iterator entityPorts=entity.portList().iterator();
        while (entityPorts.hasNext()) {
          ComponentPort insidePort=(ComponentPort)entityPorts.next();
          String name=insidePort.getName();
          IteratePort newPort=(IteratePort)getPort(name);
          if (newPort == null) {
            newPort=(IteratePort)newPort(name);
          }
          if (insidePort instanceof IOPort) {
            IOPort castPort=(IOPort)insidePort;
            newPort.setMultiport(castPort.isMultiport());
            newPort.setInput(castPort.isInput());
            newPort.setOutput(castPort.isOutput());
          }
          List connectedPorts=insidePort.connectedPortList();
          if (!connectedPorts.contains(newPort)) {
            ComponentRelation relation=newRelation(uniqueName(""String_Node_Str""));
            newPort.link(relation);
            insidePort.link(relation);
          }
        }
      }
    }
  }
;
  requestChange(request);
}"
75296,"/** 
 * Clone the object into the specified workspace. This overrides the base class to set a flag indicating that cloning is complete. While this flag is false and isDerived() returns true an instance of this class is being cloned from another instance. Methods of this object use this to test whether to construct the automatically constructed contents. These should not be constructed in a clone, since they will be copied from the original.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  IterateOverArray result=(IterateOverArray)super.clone(workspace);
  result._cloning=false;
  return result;
}","/** 
 * Clone the object into the specified workspace. This overrides the base class to set up the associations in the mirror ports and to set a flag indicating that cloning is complete.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  IterateOverArray result=(IterateOverArray)super.clone(workspace);
  result._iterationCount=(Variable)result.getAttribute(""String_Node_Str"");
  Iterator entities=result.entityList().iterator();
  while (entities.hasNext()) {
    Entity insideEntity=(Entity)entities.next();
    Iterator ports=result.portList().iterator();
    while (ports.hasNext()) {
      MirrorPort port=(MirrorPort)ports.next();
      Port insidePort=insideEntity.getPort(port.getName());
      if (insidePort instanceof MirrorPort) {
        port.setAssociatedPort((MirrorPort)insidePort);
      }
    }
  }
  result._cloning=false;
  return result;
}"
75297,"/** 
 * Apply the changes by renaming the object.
 */
public void apply(){
  if (_changed) {
    String newName=getStringValue(""String_Node_Str"");
    NamedObj parent=(NamedObj)_object.getContainer();
    String oldName=_object.getName();
    StringBuffer moml=new StringBuffer(""String_Node_Str"");
    String elementName=_object.getElementName();
    moml.append(elementName);
    moml.append(""String_Node_Str"");
    moml.append(oldName);
    moml.append(""String_Node_Str"");
    moml.append(newName);
    moml.append(""String_Node_Str"");
    boolean showName=getBooleanValue(""String_Node_Str"");
    if (_object instanceof Port) {
      if (showName) {
        moml.append(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        if (_object.getAttribute(""String_Node_Str"") != null) {
          moml.append(""String_Node_Str"");
        }
      }
    }
 else {
      if (showName) {
        if (_object.getAttribute(""String_Node_Str"") != null) {
          moml.append(""String_Node_Str"");
        }
      }
 else {
        moml.append(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    moml.append(""String_Node_Str"");
    moml.append(elementName);
    moml.append(""String_Node_Str"");
    MoMLChangeRequest request=new MoMLChangeRequest(this,parent,moml.toString(),null);
    request.addChangeListener(this);
    request.setUndoable(true);
    parent.requestChange(request);
  }
}","/** 
 * Apply the changes by renaming the object.
 */
public void apply(){
  if (_changed) {
    String newName=getStringValue(""String_Node_Str"");
    NamedObj parent=(NamedObj)_object.getContainer();
    String oldName=_object.getName();
    StringBuffer moml=new StringBuffer(""String_Node_Str"");
    String elementName=_object.getElementName();
    moml.append(elementName);
    moml.append(""String_Node_Str"");
    moml.append(oldName);
    moml.append(""String_Node_Str"");
    moml.append(newName);
    moml.append(""String_Node_Str"");
    boolean showName=getBooleanValue(""String_Node_Str"");
    if (_object instanceof Port) {
      if (showName) {
        if (_object.getAttribute(""String_Node_Str"") == null) {
          moml.append(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        if (_object.getAttribute(""String_Node_Str"") != null) {
          moml.append(""String_Node_Str"");
        }
      }
    }
 else {
      if (showName) {
        if (_object.getAttribute(""String_Node_Str"") != null) {
          moml.append(""String_Node_Str"");
        }
      }
 else {
        if (_object.getAttribute(""String_Node_Str"") == null) {
          moml.append(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
    moml.append(""String_Node_Str"");
    moml.append(elementName);
    moml.append(""String_Node_Str"");
    MoMLChangeRequest request=new MoMLChangeRequest(this,parent,moml.toString(),null);
    request.addChangeListener(this);
    request.setUndoable(true);
    parent.requestChange(request);
  }
}"
75298,"/** 
 * Generate the memory allocation code for the output ports that are of type array. The order of ports in model has effect on the order of driver input parameters
 */
private static void _arrayVariablesAllocationCode(TypedCompositeActor model) throws IllegalActionException {
  FHfuncVarDeclString+=""String_Node_Str"" + _endLine;
  FCVarInitString+=""String_Node_Str"" + _endLine + ""String_Node_Str""+ _endLine;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    String actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    FHfuncVarDeclString+=""String_Node_Str"" + actorName + _endLine;
    FCVarInitString+=_tabChar + ""String_Node_Str"" + actorName+ _endLine;
    for (Iterator ports=actor.outputPortList().iterator(); ports.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)ports.next();
      String portType=_getTypeString(port);
      if (portType.endsWith(""String_Node_Str"")) {
        String sanitizedPortName=StringUtilities.sanitizeName(port.getName(model));
        String arrayLength=_getArrayLength(port);
        FHfuncVarDeclString+=portType.substring(0,portType.length() - 5) + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=portType.substring(0,portType.length() - 5) + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=_endLine;
        FCVarInitString+=_tabChar + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
        FCVarInitString+=_tabChar + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
      }
    }
    for (Iterator ports=actor.inputPortList().iterator(); ports.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)ports.next();
      String portType=_getTypeString(port);
      if (portType.endsWith(""String_Node_Str"")) {
        String sanitizedPortName=StringUtilities.sanitizeName(port.getName(model));
        List sourcePortList=port.sourcePortList();
        if (sourcePortList.size() > 1) {
          throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
        }
        TypedIOPort sport=(TypedIOPort)port.sourcePortList().get(0);
        String arrayLength=_getArrayLength(sport);
        FHfuncVarDeclString+=portType.substring(0,portType.length() - 5) + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=_endLine;
        FCVarInitString+=_tabChar + sanitizedPortName + ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
      }
    }
  }
  FCVarInitString+=""String_Node_Str"" + _endLine;
}","/** 
 * Generate the memory allocation code for the output ports that are of type array. The order of ports in model has effect on the order of driver input parameters
 */
private static void _arrayVariablesAllocationCode(TypedCompositeActor model) throws IllegalActionException {
  FHfuncVarDeclString+=""String_Node_Str"" + _endLine;
  FCVarInitString+=""String_Node_Str"" + _endLine + ""String_Node_Str""+ _endLine;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    String actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    FHfuncVarDeclString+=""String_Node_Str"" + actorName + _endLine;
    FCVarInitString+=_tabChar + ""String_Node_Str"" + actorName+ _endLine;
    for (Iterator ports=actor.outputPortList().iterator(); ports.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)ports.next();
      String portType=_getTypeString(port);
      if (portType.endsWith(""String_Node_Str"")) {
        String sanitizedPortName=StringUtilities.sanitizeName(port.getName(model));
        String arrayLength=_getArrayLength(port);
        FHfuncVarDeclString+=portType.substring(0,portType.length() - 5) + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=portType.substring(0,portType.length() - 5) + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=_endLine;
        FHfuncVarDeclString+=""String_Node_Str"" + portType + ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=""String_Node_Str"" + portType + ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=_endLine;
        FCVarInitString+=_tabChar + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
        FCVarInitString+=_tabChar + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
      }
    }
    for (Iterator ports=actor.inputPortList().iterator(); ports.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)ports.next();
      String portType=_getTypeString(port);
      if (portType.endsWith(""String_Node_Str"")) {
        String sanitizedPortName=StringUtilities.sanitizeName(port.getName(model));
        List sourcePortList=port.sourcePortList();
        if (sourcePortList.size() > 1) {
          throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
        }
        TypedIOPort sport=(TypedIOPort)port.sourcePortList().get(0);
        String arrayLength=_getArrayLength(sport);
        FHfuncVarDeclString+=portType.substring(0,portType.length() - 5) + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=_endLine;
        FHfuncVarDeclString+=""String_Node_Str"" + portType + ""String_Node_Str""+ actorName+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
        FHfuncVarDeclString+=_endLine;
        FCVarInitString+=_tabChar + actorName + ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ _endLine;
      }
    }
  }
  FCVarInitString+=""String_Node_Str"" + _endLine;
}"
75299,"/** 
 * Return true if setDeferringChangeRequests() has been called to specify that change requests should be deferred.
 * @return True if change requests are being deferred.
 * @see #setDeferringChangeRequests(boolean)
 */
public boolean isDeferringChangeRequests(){
  return _deferChangeRequests;
}","/** 
 * Return true if setDeferringChangeRequests() has been called to specify that change requests should be deferred. If there is a container, this delegates to the container.
 * @return True if change requests are being deferred.
 * @see #setDeferringChangeRequests(boolean)
 */
public boolean isDeferringChangeRequests(){
  NamedObj container=(NamedObj)getContainer();
  if (container != null) {
    return container.isDeferringChangeRequests();
  }
  return _deferChangeRequests;
}"
75300,"/** 
 * Return the associated port, or null if there is none.
 * @param port The associated port.
 * @see #setAssociatedPort(TypedIOPort)
 */
public MirrorPort getAssociatedPort(){
  return _associatedPort;
}","/** 
 * Return the associated port, or null if there is none.
 * @return The associated port, or null if there is none.
 * @see #setAssociatedPort(MirrorPort)
 */
public MirrorPort getAssociatedPort(){
  return _associatedPort;
}"
75301,"/** 
 * Initialize the _registeredWithChannel.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _terrain.width.setToken(new IntToken(10));
  _number=10;
  _offset=new double[2];
  Locatable location=(Locatable)getAttribute(LOCATION_ATTRIBUTE_NAME,Locatable.class);
  if (location == null) {
    throw new IllegalActionException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  _offset=location.getLocation();
  CompositeEntity container=(CompositeEntity)getContainer();
  _channelName=channelName.stringValue();
  Entity channel=container.getEntity(_channelName);
  if (channel instanceof WirelessChannel) {
    _channel=(WirelessChannel)channel;
    ((WirelessChannel)channel).registerPropertyTransformer(this,null);
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Initialize the _registeredWithChannel.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _terrain.width.setToken(new IntToken(10));
  _number=10;
  _offset=new double[2];
  Locatable location=(Locatable)getAttribute(LOCATION_ATTRIBUTE_NAME,Locatable.class);
  if (location == null) {
    throw new IllegalActionException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  double[] center=_polygonCenter();
  _offset[0]=location.getLocation()[0] + center[0];
  _offset[1]=location.getLocation()[1] + center[1];
  CompositeEntity container=(CompositeEntity)getContainer();
  _channelName=channelName.stringValue();
  Entity channel=container.getEntity(_channelName);
  if (channel instanceof WirelessChannel) {
    _channel=(WirelessChannel)channel;
    ((WirelessChannel)channel).registerPropertyTransformer(this,null);
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
75302,"/** 
 * End an element. This method pops the current container from the stack, if appropriate, and also adds specialized properties to the container, such as <i>_doc</i>, if appropriate. &AElig;lfred will call this method at the end of each element (including EMPTY elements).
 * @param elementName The element type name.
 */
public void endElement(String elementName) throws Exception {
  if (_filterList != null) {
    Iterator filters=_filterList.iterator();
    String filteredElementName=elementName;
    while (filters.hasNext()) {
      MoMLFilter filter=(MoMLFilter)filters.next();
      filteredElementName=filter.filterEndElement(_current,filteredElementName);
    }
    elementName=filteredElementName;
    if (elementName == null) {
      return;
    }
  }
  if (_skipElement <= 0) {
    if (elementName.equals(""String_Node_Str"")) {
      _configureNesting--;
      if (_configureNesting < 0) {
        throw new XmlException(""String_Node_Str"" + _configureNesting + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _docNesting--;
      if (_docNesting < 0) {
        throw new XmlException(""String_Node_Str"" + _docNesting + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (_configureNesting > 0 || _docNesting > 0) {
      _currentCharData.append(""String_Node_Str"");
      _currentCharData.append(elementName);
      _currentCharData.append(""String_Node_Str"");
      return;
    }
  }
  if (_skipRendition) {
    if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=false;
    }
  }
 else   if (_skipElement > 0) {
    if (elementName.equals(_skipElementName)) {
      _skipElement--;
    }
  }
 else   if (elementName.equals(""String_Node_Str"")) {
    try {
      ((Configurable)_current).configure(_base,_configureSource,_currentCharData.toString());
      _current.setOverrideDepth(0);
      List depthList=new LinkedList();
      Iterator heritage=_current.getShadowedDerivedList(depthList).iterator();
      Iterator depths=depthList.iterator();
      while (heritage.hasNext()) {
        Configurable inherited=(Configurable)heritage.next();
        int depth=((Integer)depths.next()).intValue();
        inherited.configure(_base,_configureSource,_currentCharData.toString());
        ((NamedObj)inherited).setOverrideDepth(depth);
      }
    }
 catch (    NoClassDefFoundError e) {
    }
  }
 else {
    if (elementName.equals(""String_Node_Str"")) {
      if (_currentDocName == null && _docNesting == 0) {
        _currentDocName=""String_Node_Str"";
      }
      Documentation previous=(Documentation)_current.getAttribute(_currentDocName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getValue();
      }
      if (_currentCharData.length() > 0 && !_currentCharData.equals(previousValue)) {
        if (previous != null) {
          previous.setExpression(_currentCharData.toString());
          previous.setOverrideDepth(0);
          List depthList=new LinkedList();
          Iterator heritage=previous.getShadowedDerivedList(depthList).iterator();
          Iterator depths=depthList.iterator();
          while (heritage.hasNext()) {
            int depth=((Integer)depths.next()).intValue();
            Documentation inherited=(Documentation)heritage.next();
            inherited.setExpression(_currentCharData.toString());
            inherited.setOverrideDepth(depth);
          }
        }
 else {
          Documentation doc=new Documentation(_current,_currentDocName);
          doc.setValue(_currentCharData.toString());
          doc.setOverrideDepth(0);
          List depthList=new LinkedList();
          Iterator heritage=_current.getShadowedDerivedList(depthList).iterator();
          Iterator depths=depthList.iterator();
          while (heritage.hasNext()) {
            int depth=((Integer)depths.next()).intValue();
            NamedObj inherited=(NamedObj)heritage.next();
            Documentation newDoc=new Documentation(inherited,_currentDocName);
            newDoc.setValue(_currentCharData.toString());
            newDoc.setDerived(true);
            newDoc.setOverrideDepth(depth);
          }
        }
      }
 else {
        if (previous != null) {
          Iterator heritage=previous.getShadowedDerivedList(null).iterator();
          while (heritage.hasNext()) {
            Documentation inherited=(Documentation)heritage.next();
            inherited.setContainer(null);
          }
          previous.setContainer(null);
        }
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + _currentDocName + ""String_Node_Str"");
        if (previous != null) {
          _undoContext.appendUndoMoML(previousValue);
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
      }
      _currentDocName=null;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      try {
        _namespace=(String)_namespaces.pop();
      }
 catch (      EmptyStackException ex) {
        _namespace=_DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      if (_linkRequests != null) {
        Iterator requests=_linkRequests.iterator();
        while (requests.hasNext()) {
          LinkRequest request=(LinkRequest)requests.next();
          try {
            request.execute();
          }
 catch (          Exception ex) {
            if (_handler != null) {
              int reply=_handler.handleError(request.toString(),_current,ex);
              if (reply == ErrorHandler.CONTINUE) {
                continue;
              }
 else               if (reply == ErrorHandler.CANCEL) {
                throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
              }
            }
 else {
              throw ex;
            }
          }
        }
      }
      try {
        _current=(NamedObj)_containers.pop();
        _namespace=(String)_namespaces.pop();
      }
 catch (      EmptyStackException ex) {
        _current=null;
        _namespace=_DEFAULT_NAMESPACE;
      }
      try {
        _linkRequests=(List)_linkRequestStack.pop();
      }
 catch (      EmptyStackException ex) {
        _linkRequests=null;
      }
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")) {
      try {
        _current=(NamedObj)_containers.pop();
        _namespace=(String)_namespaces.pop();
      }
 catch (      EmptyStackException ex) {
        _current=null;
        _namespace=_DEFAULT_NAMESPACE;
      }
    }
  }
  if (_undoEnabled && _isUndoableElement(elementName)) {
    try {
      String undoMoML=_undoContext.generateUndoEntry();
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName + ""String_Node_Str""+ _undoContext.getUndoMoML());
      }
      _undoContext=(UndoContext)_undoContexts.pop();
      _undoContext.pushUndoEntry(undoMoML);
    }
 catch (    EmptyStackException ex) {
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}","/** 
 * End an element. This method pops the current container from the stack, if appropriate, and also adds specialized properties to the container, such as <i>_doc</i>, if appropriate. &AElig;lfred will call this method at the end of each element (including EMPTY elements).
 * @param elementName The element type name.
 */
public void endElement(String elementName) throws Exception {
  if (_filterList != null) {
    Iterator filters=_filterList.iterator();
    String filteredElementName=elementName;
    while (filters.hasNext()) {
      MoMLFilter filter=(MoMLFilter)filters.next();
      filteredElementName=filter.filterEndElement(_current,filteredElementName);
    }
    elementName=filteredElementName;
    if (elementName == null) {
      return;
    }
  }
  if (_skipElement <= 0) {
    if (elementName.equals(""String_Node_Str"")) {
      _configureNesting--;
      if (_configureNesting < 0) {
        throw new XmlException(""String_Node_Str"" + _configureNesting + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _docNesting--;
      if (_docNesting < 0) {
        throw new XmlException(""String_Node_Str"" + _docNesting + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (_configureNesting > 0 || _docNesting > 0) {
      _currentCharData.append(""String_Node_Str"");
      _currentCharData.append(elementName);
      _currentCharData.append(""String_Node_Str"");
      return;
    }
  }
  if (_skipRendition) {
    if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=false;
    }
  }
 else   if (_skipElement > 0) {
    if (elementName.equals(_skipElementName)) {
      _skipElement--;
    }
  }
 else   if (elementName.equals(""String_Node_Str"")) {
    try {
      ((Configurable)_current).configure(_base,_configureSource,_currentCharData.toString());
      _current.setOverrideDepth(0);
      List depthList=new LinkedList();
      Iterator heritage=_current.getShadowedDerivedList(depthList).iterator();
      Iterator depths=depthList.iterator();
      while (heritage.hasNext()) {
        Configurable inherited=(Configurable)heritage.next();
        int depth=((Integer)depths.next()).intValue();
        inherited.configure(_base,_configureSource,_currentCharData.toString());
        ((NamedObj)inherited).setOverrideDepth(depth);
      }
    }
 catch (    NoClassDefFoundError e) {
    }
  }
 else {
    if (elementName.equals(""String_Node_Str"")) {
      if (_currentDocName == null && _docNesting == 0) {
        _currentDocName=""String_Node_Str"";
      }
      Documentation previous=(Documentation)_current.getAttribute(_currentDocName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getValue();
      }
      if (_currentCharData.length() > 0 && !_currentCharData.equals(previousValue)) {
        if (previous != null) {
          previous.setExpression(_currentCharData.toString());
          previous.setOverrideDepth(0);
          List depthList=new LinkedList();
          Iterator heritage=previous.getShadowedDerivedList(depthList).iterator();
          Iterator depths=depthList.iterator();
          while (heritage.hasNext()) {
            int depth=((Integer)depths.next()).intValue();
            Documentation inherited=(Documentation)heritage.next();
            inherited.setExpression(_currentCharData.toString());
            inherited.setOverrideDepth(depth);
          }
        }
 else {
          Documentation doc=new Documentation(_current,_currentDocName);
          doc.setValue(_currentCharData.toString());
          doc.setOverrideDepth(0);
          List depthList=new LinkedList();
          Iterator heritage=_current.getShadowedDerivedList(depthList).iterator();
          Iterator depths=depthList.iterator();
          while (heritage.hasNext()) {
            int depth=((Integer)depths.next()).intValue();
            NamedObj inherited=(NamedObj)heritage.next();
            Documentation newDoc=new Documentation(inherited,_currentDocName);
            newDoc.setValue(_currentCharData.toString());
            newDoc.setDerived(true);
            newDoc.setOverrideDepth(depth);
          }
        }
      }
 else {
        if (previous != null) {
          Iterator heritage=previous.getShadowedDerivedList(null).iterator();
          while (heritage.hasNext()) {
            Documentation inherited=(Documentation)heritage.next();
            inherited.setContainer(null);
          }
          previous.setContainer(null);
        }
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + _currentDocName + ""String_Node_Str"");
        if (previous != null) {
          _undoContext.appendUndoMoML(previousValue);
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
      }
      _currentDocName=null;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      try {
        _namespace=(String)_namespaces.pop();
      }
 catch (      EmptyStackException ex) {
        _namespace=_DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      if (_linkRequests != null) {
        Iterator requests=_linkRequests.iterator();
        while (requests.hasNext()) {
          LinkRequest request=(LinkRequest)requests.next();
          try {
            request.execute();
          }
 catch (          Exception ex) {
            if (_handler != null) {
              int reply=_handler.handleError(request.toString(),_current,ex);
              if (reply == ErrorHandler.CONTINUE) {
                continue;
              }
 else               if (reply == ErrorHandler.CANCEL) {
                throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
              }
            }
 else {
              throw ex;
            }
          }
        }
      }
      try {
        _current=(NamedObj)_containers.pop();
        _namespace=(String)_namespaces.pop();
      }
 catch (      EmptyStackException ex) {
        _current=null;
        _namespace=_DEFAULT_NAMESPACE;
      }
      try {
        _linkRequests=(List)_linkRequestStack.pop();
      }
 catch (      EmptyStackException ex) {
        _linkRequests=null;
      }
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")) {
      try {
        _current=(NamedObj)_containers.pop();
        _namespace=(String)_namespaces.pop();
      }
 catch (      EmptyStackException ex) {
        _current=null;
        _namespace=_DEFAULT_NAMESPACE;
      }
    }
  }
  if (_undoEnabled && _isUndoableElement(elementName)) {
    try {
      String undoMoML=_undoContext.generateUndoEntry();
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName + ""String_Node_Str""+ _undoContext.getUndoMoML());
      }
      _undoContext=(UndoContext)_undoContexts.pop();
      _undoContext.pushUndoEntry(undoMoML);
    }
 catch (    EmptyStackException ex) {
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}"
75303,"/** 
 * Delete the entity after verifying that it is contained (deeply) by the current environment.
 * @param entityName The relative or absolute name of theentity to delete.
 * @return The deleted object.
 * @exception Exception If there is no such entity or if the entityis defined in the class definition.
 */
private NamedObj _deleteEntity(String entityName) throws Exception {
  ComponentEntity toDelete=_searchForEntity(entityName,_current);
  if (toDelete == null) {
    throw new XmlException(""String_Node_Str"" + entityName,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  if (toDelete.isDerived()) {
    throw new IllegalActionException(toDelete,""String_Node_Str"");
  }
  StringBuffer undoMoML=new StringBuffer();
  try {
    Iterator heritage=toDelete.getDerivedList().iterator();
    List reverse=new LinkedList();
    while (heritage.hasNext()) {
      reverse.add(0,heritage.next());
    }
    heritage=reverse.iterator();
    while (heritage.hasNext()) {
      ComponentEntity inherited=(ComponentEntity)heritage.next();
      String toUndo=_getUndoForDeleteEntity(inherited);
      inherited.setContainer(null);
      undoMoML.insert(0,toUndo);
    }
    String toUndo=_getUndoForDeleteEntity(toDelete);
    toDelete.setContainer(null);
    undoMoML.insert(0,toUndo);
  }
  finally {
    if (_undoEnabled && _undoContext.isUndoable()) {
      undoMoML.insert(0,""String_Node_Str"");
      undoMoML.append(""String_Node_Str"");
      _undoContext.appendUndoMoML(undoMoML.toString());
    }
  }
  return toDelete;
}","/** 
 * Delete the entity after verifying that it is contained (deeply) by the current environment.  If no object is found, then do nothing and return null.  This is because deletion of a class may result in deletion of other objects that make this particular delete call redundant.
 * @param entityName The relative or absolute name of theentity to delete.
 * @return The deleted object, or null if none was found.
 * @exception Exception If there is no such entity or if the entityis defined in the class definition.
 */
private NamedObj _deleteEntity(String entityName) throws Exception {
  ComponentEntity toDelete=_searchForEntity(entityName,_current);
  if (toDelete == null) {
    return null;
  }
  if (toDelete.isDerived()) {
    throw new IllegalActionException(toDelete,""String_Node_Str"");
  }
  StringBuffer undoMoML=new StringBuffer();
  try {
    Iterator heritage=toDelete.getDerivedList().iterator();
    List reverse=new LinkedList();
    while (heritage.hasNext()) {
      reverse.add(0,heritage.next());
    }
    heritage=reverse.iterator();
    while (heritage.hasNext()) {
      ComponentEntity inherited=(ComponentEntity)heritage.next();
      String toUndo=_getUndoForDeleteEntity(inherited);
      inherited.setContainer(null);
      undoMoML.insert(0,toUndo);
    }
    String toUndo=_getUndoForDeleteEntity(toDelete);
    toDelete.setContainer(null);
    undoMoML.insert(0,toUndo);
  }
  finally {
    if (_undoEnabled && _undoContext.isUndoable()) {
      undoMoML.insert(0,""String_Node_Str"");
      undoMoML.append(""String_Node_Str"");
      _undoContext.appendUndoMoML(undoMoML.toString());
    }
  }
  return toDelete;
}"
75304,"/** 
 * Delete the port after verifying that it is contained (deeply) by the current environment.
 * @param portName The relative or absolute name of theport to delete.
 * @param entityName Optional name of the entity that containsthe port (or null to use the current context).
 * @return The deleted object.
 * @exception Exception If there is no such port or if the portis defined in the class definition.
 */
private Port _deletePort(String portName,String entityName) throws Exception {
  Port toDelete=null;
  Entity portContainer=null;
  if (entityName == null) {
    toDelete=_searchForPort(portName);
    if (toDelete != null) {
      portContainer=(Entity)toDelete.getContainer();
    }
  }
 else {
    portContainer=_searchForEntity(entityName,_current);
    if (portContainer != null) {
      toDelete=portContainer.getPort(portName);
    }
  }
  if (toDelete == null) {
    throw new XmlException(""String_Node_Str"" + portName,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  if (portContainer == null) {
    throw new XmlException(""String_Node_Str"" + portName,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  if (toDelete.isDerived()) {
    throw new IllegalActionException(toDelete,""String_Node_Str"");
  }
  StringBuffer undoMoML=new StringBuffer();
  try {
    Iterator heritage=toDelete.getDerivedList().iterator();
    List reverse=new LinkedList();
    while (heritage.hasNext()) {
      reverse.add(0,heritage.next());
    }
    heritage=reverse.iterator();
    while (heritage.hasNext()) {
      Port inherited=(Port)heritage.next();
      String toUndo=_getUndoForDeletePort(inherited);
      inherited.setContainer(null);
      undoMoML.insert(0,toUndo);
    }
    String toUndo=_getUndoForDeletePort(toDelete);
    toDelete.setContainer(null);
    undoMoML.insert(0,toUndo);
  }
  finally {
    if (_undoEnabled && _undoContext.isUndoable()) {
      undoMoML.insert(0,""String_Node_Str"");
      undoMoML.append(""String_Node_Str"");
      _undoContext.appendUndoMoML(undoMoML.toString());
    }
  }
  return toDelete;
}","/** 
 * Delete the port after verifying that it is contained (deeply) by the current environment. If no object is found, then do nothing and return null.  This is because deletion of a class may result in deletion of other objects that make this particular delete call redundant.
 * @param portName The relative or absolute name of theport to delete.
 * @param entityName Optional name of the entity that containsthe port (or null to use the current context).
 * @return The deleted object, or null if none is found.
 * @exception Exception If there is no such port or if the portis defined in the class definition.
 */
private Port _deletePort(String portName,String entityName) throws Exception {
  Port toDelete=null;
  Entity portContainer=null;
  if (entityName == null) {
    toDelete=_searchForPort(portName);
    if (toDelete != null) {
      portContainer=(Entity)toDelete.getContainer();
    }
  }
 else {
    portContainer=_searchForEntity(entityName,_current);
    if (portContainer != null) {
      toDelete=portContainer.getPort(portName);
    }
  }
  if (toDelete == null) {
    return null;
  }
  if (portContainer == null) {
    throw new XmlException(""String_Node_Str"" + portName,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  if (toDelete.isDerived()) {
    throw new IllegalActionException(toDelete,""String_Node_Str"");
  }
  StringBuffer undoMoML=new StringBuffer();
  try {
    Iterator heritage=toDelete.getDerivedList().iterator();
    List reverse=new LinkedList();
    while (heritage.hasNext()) {
      reverse.add(0,heritage.next());
    }
    heritage=reverse.iterator();
    while (heritage.hasNext()) {
      Port inherited=(Port)heritage.next();
      String toUndo=_getUndoForDeletePort(inherited);
      inherited.setContainer(null);
      undoMoML.insert(0,toUndo);
    }
    String toUndo=_getUndoForDeletePort(toDelete);
    toDelete.setContainer(null);
    undoMoML.insert(0,toUndo);
  }
  finally {
    if (_undoEnabled && _undoContext.isUndoable()) {
      undoMoML.insert(0,""String_Node_Str"");
      undoMoML.append(""String_Node_Str"");
      _undoContext.appendUndoMoML(undoMoML.toString());
    }
  }
  return toDelete;
}"
75305,"/** 
 * Delete an attribute after verifying that it is contained (deeply) by the current environment.
 * @param attributeName The relative or absolute name of theattribute to delete.
 * @return The deleted object.
 * @exception Exception If there is no such attribute or if the attributeis defined in the class definition.
 */
private Attribute _deleteProperty(String attributeName) throws Exception {
  Attribute toDelete=_searchForAttribute(attributeName);
  if (toDelete == null) {
    throw new XmlException(""String_Node_Str"" + attributeName,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  if (toDelete.isDerived()) {
    throw new IllegalActionException(toDelete,""String_Node_Str"");
  }
  StringBuffer undoMoML=new StringBuffer();
  try {
    Iterator heritage=toDelete.getDerivedList().iterator();
    String toUndo=_getUndoForDeleteAttribute(toDelete);
    toDelete.setContainer(null);
    undoMoML.append(toUndo);
    while (heritage.hasNext()) {
      Attribute inherited=(Attribute)heritage.next();
      toUndo=_getUndoForDeleteAttribute(inherited);
      inherited.setContainer(null);
      undoMoML.append(toUndo);
    }
  }
  finally {
    if (_undoEnabled && _undoContext.isUndoable()) {
      undoMoML.insert(0,""String_Node_Str"");
      undoMoML.append(""String_Node_Str"");
      _undoContext.appendUndoMoML(undoMoML.toString());
    }
  }
  return toDelete;
}","/** 
 * Delete an attribute after verifying that it is contained (deeply) by the current environment. If no object is found, then do nothing and return null.  This is because deletion of a class may result in deletion of other objects that make this particular delete call redundant.
 * @param attributeName The relative or absolute name of theattribute to delete.
 * @return The deleted object, or null if none is found.
 * @exception Exception If there is no such attribute or if the attributeis defined in the class definition.
 */
private Attribute _deleteProperty(String attributeName) throws Exception {
  Attribute toDelete=_searchForAttribute(attributeName);
  if (toDelete == null) {
    return null;
  }
  if (toDelete.isDerived()) {
    throw new IllegalActionException(toDelete,""String_Node_Str"");
  }
  StringBuffer undoMoML=new StringBuffer();
  try {
    Iterator heritage=toDelete.getDerivedList().iterator();
    String toUndo=_getUndoForDeleteAttribute(toDelete);
    toDelete.setContainer(null);
    undoMoML.append(toUndo);
    while (heritage.hasNext()) {
      Attribute inherited=(Attribute)heritage.next();
      toUndo=_getUndoForDeleteAttribute(inherited);
      inherited.setContainer(null);
      undoMoML.append(toUndo);
    }
  }
  finally {
    if (_undoEnabled && _undoContext.isUndoable()) {
      undoMoML.insert(0,""String_Node_Str"");
      undoMoML.append(""String_Node_Str"");
      _undoContext.appendUndoMoML(undoMoML.toString());
    }
  }
  return toDelete;
}"
75306,"/** 
 * Delete the relation after verifying that it is contained (deeply) by the current environment.
 * @param relationName The relative or absolute name of therelation to delete.
 * @return The deleted object.
 * @exception Exception If there is no such relation or if the relationis defined in the class definition.
 */
private Relation _deleteRelation(String relationName) throws Exception {
  ComponentRelation toDelete=_searchForRelation(relationName);
  if (toDelete == null) {
    throw new XmlException(""String_Node_Str"" + relationName,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
  if (toDelete.isDerived()) {
    throw new IllegalActionException(toDelete,""String_Node_Str"");
  }
  StringBuffer undoMoML=new StringBuffer();
  try {
    Iterator heritage=toDelete.getDerivedList().iterator();
    List reverse=new LinkedList();
    while (heritage.hasNext()) {
      reverse.add(0,heritage.next());
    }
    heritage=reverse.iterator();
    while (heritage.hasNext()) {
      ComponentRelation inherited=(ComponentRelation)heritage.next();
      inherited.setContainer(null);
    }
    String toUndo=_getUndoForDeleteRelation(toDelete);
    toDelete.setContainer(null);
    undoMoML.insert(0,toUndo);
  }
  finally {
    if (_undoEnabled && _undoContext.isUndoable()) {
      undoMoML.insert(0,""String_Node_Str"");
      undoMoML.append(""String_Node_Str"");
      _undoContext.appendUndoMoML(undoMoML.toString());
    }
  }
  return toDelete;
}","/** 
 * Delete the relation after verifying that it is contained (deeply) by the current environment. If no object is found, then do nothing and return null.  This is because deletion of a class may result in deletion of other objects that make this particular delete call redundant.
 * @param relationName The relative or absolute name of therelation to delete.
 * @return The deleted object, or null if none is found.
 * @exception Exception If there is no such relation or if the relationis defined in the class definition.
 */
private Relation _deleteRelation(String relationName) throws Exception {
  ComponentRelation toDelete=_searchForRelation(relationName);
  if (toDelete == null) {
    return null;
  }
  if (toDelete.isDerived()) {
    throw new IllegalActionException(toDelete,""String_Node_Str"");
  }
  StringBuffer undoMoML=new StringBuffer();
  try {
    Iterator heritage=toDelete.getDerivedList().iterator();
    List reverse=new LinkedList();
    while (heritage.hasNext()) {
      reverse.add(0,heritage.next());
    }
    heritage=reverse.iterator();
    while (heritage.hasNext()) {
      ComponentRelation inherited=(ComponentRelation)heritage.next();
      inherited.setContainer(null);
    }
    String toUndo=_getUndoForDeleteRelation(toDelete);
    toDelete.setContainer(null);
    undoMoML.insert(0,toUndo);
  }
  finally {
    if (_undoEnabled && _undoContext.isUndoable()) {
      undoMoML.insert(0,""String_Node_Str"");
      undoMoML.append(""String_Node_Str"");
      _undoContext.appendUndoMoML(undoMoML.toString());
    }
  }
  return toDelete;
}"
75307,"/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_skipElement <= 0) {
      if (_configureNesting > 0 || _docNesting > 0) {
        if (elementName.equals(""String_Node_Str"")) {
          _configureNesting++;
        }
 else         if (elementName.equals(""String_Node_Str"")) {
          _docNesting++;
        }
        _currentCharData.append(_getCurrentElement(elementName));
        _attributes.clear();
        _attributeNameList.clear();
        return;
      }
    }
    if (_skipRendition) {
      return;
    }
    boolean undoEnabled=_undoEnabled && _isUndoableElement(elementName);
    if (undoEnabled) {
      boolean childNodesUndoable=true;
      if (_undoContext != null) {
        _undoContexts.push(_undoContext);
        childNodesUndoable=_undoContext.hasUndoableChildren();
      }
      _undoContext=new UndoContext(childNodesUndoable);
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName);
      }
    }
    if (_skipElement > 0) {
      if (elementName.equals(_skipElementName)) {
        if (_skipElementIsNew) {
          _skipElementIsNew=false;
        }
 else {
          _skipElement++;
        }
      }
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      Entity entity=_searchForEntity(entityName,_current);
      boolean existedAlready=(entity != null);
      if (!existedAlready) {
        NamedObj candidate=_createEntity(className,entityName,source);
        if (candidate instanceof Entity) {
          entity=(Entity)candidate;
        }
 else {
          throw new IllegalActionException(_current,""String_Node_Str"" + entityName + ""String_Node_Str""+ ""String_Node_Str""+ className);
        }
      }
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=entity.toplevel();
        _toplevel.setDeferringChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      boolean converted=false;
      if (!existedAlready) {
        entity.setClassDefinition(true);
        entity.setClassName(className);
      }
 else {
        if (!entity.isClassDefinition()) {
          entity.setClassDefinition(true);
          converted=true;
        }
      }
      _current=entity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (!converted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName,entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedPort;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedProp;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedRelation;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      _pushContext();
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      Entity entity=_searchForEntity(entityName,_current);
      boolean existedAlready=(entity != null);
      boolean converted=false;
      if (existedAlready) {
        if (entity.isClassDefinition()) {
          entity.setClassDefinition(false);
          converted=true;
        }
      }
 else {
        NamedObj candidate=_createEntity(className,entityName,source);
        if (candidate instanceof Entity) {
          entity=(Entity)candidate;
          entity.setClassName(className);
        }
 else {
          throw new IllegalActionException(_current,""String_Node_Str"" + entityName + ""String_Node_Str""+ ""String_Node_Str""+ className);
        }
      }
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=entity.toplevel();
        _toplevel.setDeferringChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      _current=entity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (!converted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespaceTranslations.push(_namespaceTranslationTable);
        if (groupName.equals(""String_Node_Str"")) {
          _namespace=_AUTO_NAMESPACE;
          _namespaceTranslationTable=new HashMap();
        }
 else {
          _namespace=groupName;
        }
      }
 else {
        _namespaces.push(_DEFAULT_NAMESPACE);
        _namespaceTranslations.push(_namespaceTranslationTable);
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      boolean skip=false;
      if (inputFileNamesToSkip != null) {
        Iterator inputFileNames=inputFileNamesToSkip.iterator();
        while (inputFileNames.hasNext()) {
          String inputFileName=(String)inputFileNames.next();
          if (source.endsWith(inputFileName)) {
            skip=true;
            break;
          }
        }
      }
      if (!skip) {
        MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
        newParser.setContext(_current);
        _parse(newParser,_base,source);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      String insertInsideAtSpec=(String)_attributes.get(""String_Node_Str"");
      LinkRequest request=new LinkRequest(portName,relationName,insertAtSpec,insertInsideAtSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null && !className.trim().equals(""String_Node_Str"")) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      boolean alreadyExisted=(port != null);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        List heritageList=container.getDerivedList();
        Iterator heritage=heritageList.iterator();
        while (heritage.hasNext()) {
          Entity inherited=(Entity)heritage.next();
          if (inherited.getPort(portName) != null) {
            throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + inherited.getPort(portName).getFullName());
          }
        }
        if (newClass == null) {
          port=container.newPort(portName);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            Entity inherited=(Entity)heritage.next();
            Port newPort=inherited.newPort(portName);
            newPort.setDerived(true);
          }
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            Entity inherited=(Entity)heritage.next();
            arguments[0]=inherited;
            NamedObj propagatedPort=_createInstance(newClass,arguments);
            propagatedPort.setDerived(true);
          }
        }
      }
      _pushContext();
      _current=port;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          boolean isOutput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          boolean isInput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          if (alreadyExisted && ioport.isDerived()) {
            if (ioport.isInput() != isInput || ioport.isOutput() != isOutput) {
              throw new IllegalActionException(ioport,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
            }
          }
          ioport.setOutput(isOutput);
          ioport.setInput(isInput);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      _handlePropertyElement(className,propertyName,value);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      boolean alreadyExisted=(relation != null);
      if (relation == null) {
        List heritageList=container.getDerivedList();
        Iterator heritage=heritageList.iterator();
        while (heritage.hasNext()) {
          CompositeEntity inherited=(CompositeEntity)heritage.next();
          if (inherited.getRelation(relationName) != null) {
            throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + inherited.getRelation(relationName).getFullName());
          }
        }
        NamedObj newRelation=null;
        _pushContext();
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            CompositeEntity inherited=(CompositeEntity)heritage.next();
            Relation propagatedRelation=inherited.newRelation(relationName);
            propagatedRelation.setDerived(true);
          }
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            CompositeEntity inherited=(CompositeEntity)heritage.next();
            arguments[0]=inherited;
            NamedObj propagatedRelation=_createInstance(newClass,arguments);
            propagatedRelation.setDerived(true);
          }
        }
        _namespace=_DEFAULT_NAMESPACE;
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _pushContext();
        _current=relation;
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        String oldName=_current.getName();
        if (!oldName.equals(newName) && _current.isDerived()) {
          throw new IllegalActionException(_current,""String_Node_Str"" + newName + ""String_Node_Str"");
        }
        Iterator heritage=_current.getDerivedList().iterator();
        Set changedName=new HashSet();
        HashMap changedClassName=new HashMap();
        NamedObj inherited=null;
        try {
          while (heritage.hasNext()) {
            inherited=(NamedObj)heritage.next();
            if (inherited.getName().equals(oldName)) {
              inherited.setName(newName);
              changedName.add(inherited);
            }
            if (inherited instanceof Instantiable) {
              Instantiable parent=((Instantiable)inherited).getParent();
              if (parent != null && (parent == _current || changedName.contains(parent))) {
                String previousClassName=inherited.getClassName();
                int last=previousClassName.lastIndexOf(oldName);
                if (last < 0) {
                  throw new InternalErrorException(""String_Node_Str"" + inherited.getFullName() + ""String_Node_Str""+ oldName+ ""String_Node_Str""+ previousClassName);
                }
                String newClassName=newName;
                if (last > 0) {
                  newClassName=previousClassName.substring(0,last) + newName;
                }
                inherited.setClassName(newClassName);
                changedClassName.put(inherited,previousClassName);
              }
            }
          }
        }
 catch (        NameDuplicationException ex) {
          Iterator toUndo=changedName.iterator();
          while (toUndo.hasNext()) {
            NamedObj revert=(NamedObj)toUndo.next();
            revert.setName(oldName);
          }
          Iterator classNameFixes=changedClassName.entrySet().iterator();
          while (classNameFixes.hasNext()) {
            Map.Entry revert=(Map.Entry)classNameFixes.next();
            NamedObj toFix=(NamedObj)revert.getKey();
            String previousClassName=(String)revert.getValue();
            toFix.setClassName(previousClassName);
          }
          throw new IllegalActionException(_current,ex,""String_Node_Str"" + ""String_Node_Str"" + inherited.getFullName());
        }
        _current.setName(newName);
        if (undoEnabled && _undoContext.isUndoable()) {
          UndoContext parentContext=(UndoContext)_undoContexts.peek();
          parentContext.applyRename(newName);
          _undoContext.appendUndoMoML(""String_Node_Str"" + oldName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
        if ((_current instanceof Instantiable) && ((Instantiable)_current).isClassDefinition()) {
          List deferredFrom=((Instantiable)_current).getChildren();
          if (deferredFrom != null) {
            Iterator deferrers=deferredFrom.iterator();
            while (deferrers.hasNext()) {
              WeakReference reference=(WeakReference)deferrers.next();
              Prototype deferrer=(Prototype)reference.get();
              if (deferrer != null) {
                String replacementName=newName;
                if (deferrer.getClassName().startsWith(""String_Node_Str"")) {
                  replacementName=_current.getFullName();
                }
                deferrer.setClassName(replacementName);
              }
            }
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      UnlinkRequest request=new UnlinkRequest(portName,relationName,indexSpec,insideIndexSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex previous=(Vertex)_current.getAttribute(vertexName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getExpression();
      }
      Vertex vertex=previous;
      if (vertex == null) {
        vertex=new Vertex((Relation)_current,vertexName);
        Iterator heritage=_current.getDerivedList().iterator();
        while (heritage.hasNext()) {
          Relation inherited=(Relation)heritage.next();
          Vertex propagatedVertex=new Vertex(inherited,vertexName);
          propagatedVertex.setDerived(true);
        }
      }
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null && !value.equals(previousValue)) {
        vertex.setExpression(value);
        vertex.setOverrideDepth(0);
        _paramsToParse.add(vertex);
        List depthList=new LinkedList();
        Iterator heritage=vertex.getShadowedDerivedList(depthList).iterator();
        Iterator depths=depthList.iterator();
        while (heritage.hasNext()) {
          int depth=((Integer)depths.next()).intValue();
          Vertex inherited=(Vertex)heritage.next();
          inherited.setExpression(value);
          inherited.setOverrideDepth(depth);
          _paramsToParse.add(inherited);
        }
      }
      _pushContext();
      _current=vertex;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + vertexName + ""String_Node_Str"");
        if (previousValue != null) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + previousValue + ""String_Node_Str"");
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
      }
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex.getTargetException());
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex.getTargetException());
  }
catch (  Exception ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex);
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex);
    }
  }
  _attributes.clear();
  _attributeNameList.clear();
}","/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_skipElement <= 0) {
      if (_configureNesting > 0 || _docNesting > 0) {
        if (elementName.equals(""String_Node_Str"")) {
          _configureNesting++;
        }
 else         if (elementName.equals(""String_Node_Str"")) {
          _docNesting++;
        }
        _currentCharData.append(_getCurrentElement(elementName));
        _attributes.clear();
        _attributeNameList.clear();
        return;
      }
    }
    if (_skipRendition) {
      return;
    }
    boolean undoEnabled=_undoEnabled && _isUndoableElement(elementName);
    if (undoEnabled) {
      boolean childNodesUndoable=true;
      if (_undoContext != null) {
        _undoContexts.push(_undoContext);
        childNodesUndoable=_undoContext.hasUndoableChildren();
      }
      _undoContext=new UndoContext(childNodesUndoable);
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName);
      }
    }
    if (_skipElement > 0) {
      if (elementName.equals(_skipElementName)) {
        if (_skipElementIsNew) {
          _skipElementIsNew=false;
        }
 else {
          _skipElement++;
        }
      }
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      Entity entity=_searchForEntity(entityName,_current);
      boolean existedAlready=(entity != null);
      if (!existedAlready) {
        NamedObj candidate=_createEntity(className,entityName,source);
        if (candidate instanceof Entity) {
          entity=(Entity)candidate;
        }
 else {
          throw new IllegalActionException(_current,""String_Node_Str"" + entityName + ""String_Node_Str""+ ""String_Node_Str""+ className);
        }
      }
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=entity.toplevel();
        _toplevel.setDeferringChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      boolean converted=false;
      if (!existedAlready) {
        entity.setClassDefinition(true);
        entity.setClassName(className);
      }
 else {
        if (!entity.isClassDefinition()) {
          entity.setClassDefinition(true);
          converted=true;
        }
      }
      _current=entity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (!converted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      _deleteEntity(entityName);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _deletePort(portName,entityName);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      _deleteProperty(propName);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _deleteRelation(relationName);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      _pushContext();
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      Entity entity=_searchForEntity(entityName,_current);
      boolean existedAlready=(entity != null);
      boolean converted=false;
      if (existedAlready) {
        if (entity.isClassDefinition()) {
          entity.setClassDefinition(false);
          converted=true;
        }
      }
 else {
        NamedObj candidate=_createEntity(className,entityName,source);
        if (candidate instanceof Entity) {
          entity=(Entity)candidate;
          entity.setClassName(className);
        }
 else {
          throw new IllegalActionException(_current,""String_Node_Str"" + entityName + ""String_Node_Str""+ ""String_Node_Str""+ className);
        }
      }
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=entity.toplevel();
        _toplevel.setDeferringChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      _current=entity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (!converted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespaceTranslations.push(_namespaceTranslationTable);
        if (groupName.equals(""String_Node_Str"")) {
          _namespace=_AUTO_NAMESPACE;
          _namespaceTranslationTable=new HashMap();
        }
 else {
          _namespace=groupName;
        }
      }
 else {
        _namespaces.push(_DEFAULT_NAMESPACE);
        _namespaceTranslations.push(_namespaceTranslationTable);
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      boolean skip=false;
      if (inputFileNamesToSkip != null) {
        Iterator inputFileNames=inputFileNamesToSkip.iterator();
        while (inputFileNames.hasNext()) {
          String inputFileName=(String)inputFileNames.next();
          if (source.endsWith(inputFileName)) {
            skip=true;
            break;
          }
        }
      }
      if (!skip) {
        MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
        newParser.setContext(_current);
        _parse(newParser,_base,source);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      String insertInsideAtSpec=(String)_attributes.get(""String_Node_Str"");
      LinkRequest request=new LinkRequest(portName,relationName,insertAtSpec,insertInsideAtSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null && !className.trim().equals(""String_Node_Str"")) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      boolean alreadyExisted=(port != null);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        List heritageList=container.getDerivedList();
        Iterator heritage=heritageList.iterator();
        while (heritage.hasNext()) {
          Entity inherited=(Entity)heritage.next();
          if (inherited.getPort(portName) != null) {
            throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + inherited.getPort(portName).getFullName());
          }
        }
        if (newClass == null) {
          port=container.newPort(portName);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            Entity inherited=(Entity)heritage.next();
            Port newPort=inherited.newPort(portName);
            newPort.setDerived(true);
          }
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            Entity inherited=(Entity)heritage.next();
            arguments[0]=inherited;
            NamedObj propagatedPort=_createInstance(newClass,arguments);
            propagatedPort.setDerived(true);
          }
        }
      }
      _pushContext();
      _current=port;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          boolean isOutput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          boolean isInput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          if (alreadyExisted && ioport.isDerived()) {
            if (ioport.isInput() != isInput || ioport.isOutput() != isOutput) {
              throw new IllegalActionException(ioport,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
            }
          }
          ioport.setOutput(isOutput);
          ioport.setInput(isInput);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      _handlePropertyElement(className,propertyName,value);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      boolean alreadyExisted=(relation != null);
      if (relation == null) {
        List heritageList=container.getDerivedList();
        Iterator heritage=heritageList.iterator();
        while (heritage.hasNext()) {
          CompositeEntity inherited=(CompositeEntity)heritage.next();
          if (inherited.getRelation(relationName) != null) {
            throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + inherited.getRelation(relationName).getFullName());
          }
        }
        NamedObj newRelation=null;
        _pushContext();
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            CompositeEntity inherited=(CompositeEntity)heritage.next();
            Relation propagatedRelation=inherited.newRelation(relationName);
            propagatedRelation.setDerived(true);
          }
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            CompositeEntity inherited=(CompositeEntity)heritage.next();
            arguments[0]=inherited;
            NamedObj propagatedRelation=_createInstance(newClass,arguments);
            propagatedRelation.setDerived(true);
          }
        }
        _namespace=_DEFAULT_NAMESPACE;
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _pushContext();
        _current=relation;
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        String oldName=_current.getName();
        if (!oldName.equals(newName) && _current.isDerived()) {
          throw new IllegalActionException(_current,""String_Node_Str"" + newName + ""String_Node_Str"");
        }
        Iterator heritage=_current.getDerivedList().iterator();
        Set changedName=new HashSet();
        HashMap changedClassName=new HashMap();
        NamedObj inherited=null;
        try {
          while (heritage.hasNext()) {
            inherited=(NamedObj)heritage.next();
            if (inherited.getName().equals(oldName)) {
              inherited.setName(newName);
              changedName.add(inherited);
            }
            if (inherited instanceof Instantiable) {
              Instantiable parent=((Instantiable)inherited).getParent();
              if (parent != null && (parent == _current || changedName.contains(parent))) {
                String previousClassName=inherited.getClassName();
                int last=previousClassName.lastIndexOf(oldName);
                if (last < 0) {
                  throw new InternalErrorException(""String_Node_Str"" + inherited.getFullName() + ""String_Node_Str""+ oldName+ ""String_Node_Str""+ previousClassName);
                }
                String newClassName=newName;
                if (last > 0) {
                  newClassName=previousClassName.substring(0,last) + newName;
                }
                inherited.setClassName(newClassName);
                changedClassName.put(inherited,previousClassName);
              }
            }
          }
        }
 catch (        NameDuplicationException ex) {
          Iterator toUndo=changedName.iterator();
          while (toUndo.hasNext()) {
            NamedObj revert=(NamedObj)toUndo.next();
            revert.setName(oldName);
          }
          Iterator classNameFixes=changedClassName.entrySet().iterator();
          while (classNameFixes.hasNext()) {
            Map.Entry revert=(Map.Entry)classNameFixes.next();
            NamedObj toFix=(NamedObj)revert.getKey();
            String previousClassName=(String)revert.getValue();
            toFix.setClassName(previousClassName);
          }
          throw new IllegalActionException(_current,ex,""String_Node_Str"" + ""String_Node_Str"" + inherited.getFullName());
        }
        _current.setName(newName);
        if (undoEnabled && _undoContext.isUndoable()) {
          UndoContext parentContext=(UndoContext)_undoContexts.peek();
          parentContext.applyRename(newName);
          _undoContext.appendUndoMoML(""String_Node_Str"" + oldName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
        if ((_current instanceof Instantiable) && ((Instantiable)_current).isClassDefinition()) {
          List deferredFrom=((Instantiable)_current).getChildren();
          if (deferredFrom != null) {
            Iterator deferrers=deferredFrom.iterator();
            while (deferrers.hasNext()) {
              WeakReference reference=(WeakReference)deferrers.next();
              Prototype deferrer=(Prototype)reference.get();
              if (deferrer != null) {
                String replacementName=newName;
                if (deferrer.getClassName().startsWith(""String_Node_Str"")) {
                  replacementName=_current.getFullName();
                }
                deferrer.setClassName(replacementName);
              }
            }
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      UnlinkRequest request=new UnlinkRequest(portName,relationName,indexSpec,insideIndexSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex previous=(Vertex)_current.getAttribute(vertexName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getExpression();
      }
      Vertex vertex=previous;
      if (vertex == null) {
        vertex=new Vertex((Relation)_current,vertexName);
        Iterator heritage=_current.getDerivedList().iterator();
        while (heritage.hasNext()) {
          Relation inherited=(Relation)heritage.next();
          Vertex propagatedVertex=new Vertex(inherited,vertexName);
          propagatedVertex.setDerived(true);
        }
      }
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null && !value.equals(previousValue)) {
        vertex.setExpression(value);
        vertex.setOverrideDepth(0);
        _paramsToParse.add(vertex);
        List depthList=new LinkedList();
        Iterator heritage=vertex.getShadowedDerivedList(depthList).iterator();
        Iterator depths=depthList.iterator();
        while (heritage.hasNext()) {
          int depth=((Integer)depths.next()).intValue();
          Vertex inherited=(Vertex)heritage.next();
          inherited.setExpression(value);
          inherited.setOverrideDepth(depth);
          _paramsToParse.add(inherited);
        }
      }
      _pushContext();
      _current=vertex;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + vertexName + ""String_Node_Str"");
        if (previousValue != null) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + previousValue + ""String_Node_Str"");
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
      }
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex.getTargetException());
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex.getTargetException());
  }
catch (  Exception ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex);
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex);
    }
  }
  _attributes.clear();
  _attributeNameList.clear();
}"
75308,"/** 
 * Return the node controller appropriate for the given object. If the object is an instance of Vertex, then return the local relation controller.  If it implements Locatable, then determine whether it is an Entity, Attribute, or Port, and return the appropriate default controller. If the argument is an instance of Port, then return the local port controller.
 * @param object A Vertex, Locatable, or Port.
 */
public NodeController getNodeController(Object object){
  NodeController result=super.getNodeController(object);
  if (result != null) {
    return result;
  }
  if (object instanceof Vertex) {
    return _relationController;
  }
 else   if (object instanceof Locatable) {
    Object semanticObject=getGraphModel().getSemanticObject(object);
    if (semanticObject instanceof Entity) {
      if (_classDefinitionController != null && ((Entity)semanticObject).isClassDefinition()) {
        return _classDefinitionController;
      }
 else {
        return _entityController;
      }
    }
 else     if (semanticObject instanceof Attribute) {
      return _attributeController;
    }
 else     if (semanticObject instanceof Port) {
      return _portController;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + semanticObject);
    }
  }
 else   if (object instanceof Port) {
    return _entityPortController;
  }
  throw new RuntimeException(""String_Node_Str"" + object);
}","/** 
 * Return the node controller appropriate for the given object. If the object is an instance of Vertex, then return the local relation controller.  If it implements Locatable, then determine whether it is an Entity, Attribute, or Port, and return the appropriate default controller. If the argument is an instance of Port, then return the local port controller.
 * @param object A Vertex, Locatable, or Port.
 */
public NodeController getNodeController(Object object){
  NodeController result=super.getNodeController(object);
  if (result != null) {
    return result;
  }
  if (object instanceof Vertex) {
    return _relationController;
  }
 else   if (object instanceof Locatable) {
    Object semanticObject=getGraphModel().getSemanticObject(object);
    if (semanticObject instanceof Entity) {
      if (_classDefinitionController != null && ((Entity)semanticObject).isClassDefinition()) {
        return _classDefinitionController;
      }
 else {
        return _entityController;
      }
    }
 else     if (semanticObject instanceof Attribute) {
      return _attributeController;
    }
 else     if (semanticObject instanceof Port) {
      return _portController;
    }
 else {
      return _locatableController;
    }
  }
 else   if (object instanceof Port) {
    return _entityPortController;
  }
  throw new RuntimeException(""String_Node_Str"" + object);
}"
75309,"/** 
 * Create a new basic controller with default terminal and edge interactors and default context menus.
 */
public ActorViewerGraphController(){
  _createControllers();
}","/** 
 * Create a new basic controller with default terminal and edge interactors and default context menus.
 */
public ActorViewerGraphController(){
  _createControllers();
  _locatableController=new LocatableNodeController(this);
}"
75310,"/** 
 * Update the graph model.  This is called whenever a change request is executed.  Subclasses will override this to update internal data structures that may be cached.
 * @return True if the graph model changes (always true in thisbase class).
 */
protected boolean _update(){
  return true;
}","/** 
 * Update the graph model.  This is called whenever a change request is executed.  This base class checks each of the contained nodes, and if any has a semantic object with no container, then that node is removed. Subclasses will override this to update internal data structures that may be cached.
 * @return True if the graph model changes (always true in thisbase class).
 */
protected boolean _update(){
  return true;
}"
75311,"/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  try {
    Configuration configuration=((TableauFrame)parent).getConfiguration();
    TypedCompositeActor model=(TypedCompositeActor)GiottoCEmachineFrameworkGenerator.this.getContainer();
    CompositeActor toplevel=(CompositeActor)model.toplevel();
    Manager manager=toplevel.getManager();
    if (manager == null) {
      manager=new Manager(toplevel.workspace(),""String_Node_Str"");
      toplevel.setManager(manager);
    }
    manager.preinitializeAndResolveTypes();
    writeFrameworkCode(model);
    TextEffigy codeEffigy=TextEffigy.newTextEffigy(configuration.getDirectory(),generateCode(model));
    codeEffigy.setModified(true);
    configuration.createPrimaryTableau(codeEffigy);
  }
 catch (  Exception ex) {
    throw new InternalErrorException(object,ex,""String_Node_Str"");
  }
}","/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  try {
    Configuration configuration=((TableauFrame)parent).getConfiguration();
    TypedCompositeActor model=(TypedCompositeActor)GiottoCEmachineFrameworkGenerator.this.getContainer();
    CompositeActor toplevel=(CompositeActor)model.toplevel();
    Manager manager=toplevel.getManager();
    if (manager == null) {
      manager=new Manager(toplevel.workspace(),""String_Node_Str"");
      toplevel.setManager(manager);
    }
    manager.preinitializeAndResolveTypes();
    writeFrameworkCode(model);
    TextEffigy codeEffigy=TextEffigy.newTextEffigy(configuration.getDirectory(),generateCode(model));
    codeEffigy.setModified(true);
    configuration.createPrimaryTableau(codeEffigy);
    manager.stop();
    manager.wrapup();
  }
 catch (  Exception ex) {
    throw new InternalErrorException(object,ex,""String_Node_Str"");
  }
}"
75312,"/** 
 * Generate code for the H file f_code.h. This function generates the function and variable declarations for the implementation in f_code.c
 * @return The output code.
 */
private static String _generateFrameworkHeaderCode(TypedCompositeActor model) throws IllegalActionException {
  String codeString=""String_Node_Str"";
  codeString+=copyrightString;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    String actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    int actorFreq=0;
    Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
    if (actorFreqPara == null) {
      actorFreq=1;
    }
 else {
      actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
    }
    codeString+=""String_Node_Str"" + actorName + ""String_Node_Str""+ _tabChar+ _tabChar+ ""String_Node_Str""+ actorFreq+ ""String_Node_Str""+ _endLine;
  }
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  Iterator dataType=dataTypes.iterator();
  while (dataType.hasNext()) {
    String type=(String)dataType.next();
    if (type.endsWith(""String_Node_Str"")) {
      codeString+=""String_Node_Str"" + type.substring(0,type.length() - 5) + ""String_Node_Str""+ type+ ""String_Node_Str""+ _endLine+ _endLine;
    }
  }
  codeString+=""String_Node_Str"" + _endLine + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=FHfuncDeclString;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  return codeString;
}","/** 
 * Generate code for the H file f_code.h. This function generates the function and variable declarations for the implementation in f_code.c
 * @return The output code.
 */
private static String _generateFrameworkHeaderCode(TypedCompositeActor model) throws IllegalActionException {
  String codeString=""String_Node_Str"";
  codeString+=copyrightString;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _tabChar + _tabChar+ ""String_Node_Str""+ ((GiottoDirector)model.getDirector()).getIntPeriod()+ ""String_Node_Str""+ _endLine;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    String actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    int actorFreq=0;
    Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
    if (actorFreqPara == null) {
      actorFreq=1;
    }
 else {
      actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
    }
    codeString+=""String_Node_Str"" + actorName + ""String_Node_Str""+ _tabChar+ _tabChar+ ""String_Node_Str""+ actorFreq+ ""String_Node_Str""+ _endLine;
  }
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  Iterator dataType=dataTypes.iterator();
  while (dataType.hasNext()) {
    String type=(String)dataType.next();
    if (type.endsWith(""String_Node_Str"")) {
      codeString+=""String_Node_Str"" + type.substring(0,type.length() - 5) + ""String_Node_Str""+ type+ ""String_Node_Str""+ _endLine+ _endLine;
    }
  }
  codeString+=""String_Node_Str"" + _endLine + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=FHfuncDeclString;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  return codeString;
}"
75313,"/** 
 * Generate code for the task.
 * @return The task code.
 */
private static void _taskCodeSkeleton(TypedCompositeActor model) throws IllegalActionException {
  boolean first;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    TypedActor actor=(TypedActor)actors.next();
    String taskName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    first=true;
    String inputPorts=""String_Node_Str"";
    for (Iterator inPorts=actor.inputPortList().iterator(); inPorts.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)inPorts.next();
      if (port.getWidth() > 0) {
        if (first) {
          first=false;
        }
 else {
          inputPorts+=""String_Node_Str"";
        }
        String portID=StringUtilities.sanitizeName(port.getName(model));
        String portTypeID=_getTypeString(port);
        inputPorts+=portID;
      }
    }
    first=true;
    String outputPorts=""String_Node_Str"";
    for (Iterator outPorts=actor.outputPortList().iterator(); outPorts.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)outPorts.next();
      if (port.getWidth() > 0) {
        if (first) {
          first=false;
        }
 else {
          outputPorts+=""String_Node_Str"";
        }
        String portID=StringUtilities.sanitizeName(port.getName(model));
        outputPorts+=portID;
      }
    }
    String portSeparator=""String_Node_Str"";
    if (inputPorts.equals(""String_Node_Str"") || outputPorts.equals(""String_Node_Str"")) {
      portSeparator=""String_Node_Str"";
    }
    TCfuncImplString+=""String_Node_Str"" + taskName + ""String_Node_Str""+ inputPorts+ portSeparator+ outputPorts+ ""String_Node_Str""+ _endLine;
    TCfuncImplString+=""String_Node_Str"" + _endLine + _endLine;
    THfuncDeclString+=""String_Node_Str"" + taskName + ""String_Node_Str""+ inputPorts+ portSeparator+ outputPorts+ ""String_Node_Str""+ _endLine+ _endLine;
  }
}","/** 
 * Generate code for the task.
 * @return The task code.
 */
private static void _taskCodeSkeleton(TypedCompositeActor model) throws IllegalActionException {
  boolean first;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    TypedActor actor=(TypedActor)actors.next();
    String taskName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    first=true;
    String inputPorts=""String_Node_Str"";
    for (Iterator inPorts=actor.inputPortList().iterator(); inPorts.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)inPorts.next();
      if (port.getWidth() > 0) {
        if (first) {
          first=false;
        }
 else {
          inputPorts+=""String_Node_Str"";
        }
        String portID=StringUtilities.sanitizeName(port.getName());
        String portTypeID=_getTypeString(port);
        List sourcePortList=port.sourcePortList();
        if (sourcePortList.size() > 1) {
          throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
        }
        TypedIOPort sport=(TypedIOPort)port.sourcePortList().get(0);
        String sanitizedSourceActorName=StringUtilities.sanitizeName(sport.getContainer().getName());
        inputPorts+=portTypeID + ""String_Node_Str"" + sanitizedSourceActorName+ ""String_Node_Str""+ portID;
      }
    }
    first=true;
    String outputPorts=""String_Node_Str"";
    for (Iterator outPorts=actor.outputPortList().iterator(); outPorts.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)outPorts.next();
      if (port.getWidth() > 0) {
        if (first) {
          first=false;
        }
 else {
          outputPorts+=""String_Node_Str"";
        }
        String portID=StringUtilities.sanitizeName(port.getName());
        String portTypeID=_getTypeString(port);
        outputPorts+=portTypeID + ""String_Node_Str"" + portID;
      }
    }
    String portSeparator=""String_Node_Str"";
    if (inputPorts.equals(""String_Node_Str"") || outputPorts.equals(""String_Node_Str"")) {
      portSeparator=""String_Node_Str"";
    }
    TCfuncImplString+=""String_Node_Str"" + taskName + ""String_Node_Str""+ inputPorts+ portSeparator+ outputPorts+ ""String_Node_Str""+ _endLine;
    TCfuncImplString+=""String_Node_Str"" + _endLine + _endLine;
    THfuncDeclString+=""String_Node_Str"" + taskName + ""String_Node_Str""+ inputPorts+ portSeparator+ outputPorts+ ""String_Node_Str""+ _endLine+ _endLine;
  }
}"
75314,"/** 
 * Generate the Framework code. Presently this functionality is hard coded to generate the files in $PTII/domains/giotto/kernel It creates the directory c_functionality/fcode with the files f_code.c and f_code.h in it.
 */
public static void writeFrameworkCode(TypedCompositeActor model) throws IllegalActionException, NameDuplicationException {
  dataTypes=new HashSet();
  FHfuncDeclString=""String_Node_Str"";
  FCoutDriversImplString=""String_Node_Str"";
  FCinDriversImplString=""String_Node_Str"";
  THfuncDeclString=""String_Node_Str"";
  TCfuncImplString=""String_Node_Str"";
  _generateCodeStrings(model);
  String directoryName=""String_Node_Str"" + StringUtilities.sanitizeName(model.getName()) + ""String_Node_Str"";
  File directory;
  File outDirFile=new File(directoryName);
  if (!outDirFile.isDirectory()) {
    outDirFile.mkdirs();
  }
  File writeFCFile=new File(directoryName,""String_Node_Str"");
  File writeFHFile=new File(directoryName,""String_Node_Str"");
  File writeTCFile=new File(directoryName,""String_Node_Str"");
  File writeTHFile=new File(directoryName,""String_Node_Str"");
  try {
    FileWriter FCwriter=new FileWriter(writeFCFile);
    FCwriter.write(_generateFrameworkImplementationCode(model));
    FCwriter.close();
    FileWriter FHwriter=new FileWriter(writeFHFile);
    FHwriter.write(_generateFrameworkHeaderCode(model));
    FHwriter.close();
    FileWriter TCwriter=new FileWriter(writeTCFile);
    TCwriter.write(_generateTaskImplementationCode(model));
    TCwriter.close();
    FileWriter THwriter=new FileWriter(writeTHFile);
    THwriter.write(_generateTaskHeaderCode(model));
    THwriter.close();
  }
 catch (  IOException e) {
    throw new IllegalActionException(model,e,""String_Node_Str"");
  }
}","/** 
 * Generate the Framework code. Presently this functionality is hard coded to generate the files in $PTII/domains/giotto/kernel It creates the directory c_functionality/fcode with the files f_code.c and f_code.h in it.
 */
public static void writeFrameworkCode(TypedCompositeActor model) throws IllegalActionException, NameDuplicationException {
  dataTypes=new HashSet();
  FHfuncDeclString=""String_Node_Str"";
  FCoutDriversImplString=""String_Node_Str"";
  FCinDriversImplString=""String_Node_Str"";
  THfuncDeclString=""String_Node_Str"";
  TCfuncImplString=""String_Node_Str"";
  _generateCodeStrings(model);
  String directoryName=""String_Node_Str"" + StringUtilities.sanitizeName(model.getName()) + ""String_Node_Str"";
  File directory;
  File outDirFile=new File(directoryName);
  if (!outDirFile.isDirectory()) {
    outDirFile.mkdirs();
  }
  File writeFCFile=new File(directoryName,""String_Node_Str"");
  File writeFHFile=new File(directoryName,""String_Node_Str"");
  File writeTHFile=new File(directoryName,""String_Node_Str"");
  try {
    FileWriter FCwriter=new FileWriter(writeFCFile);
    FCwriter.write(_generateFrameworkImplementationCode(model));
    FCwriter.close();
    FileWriter FHwriter=new FileWriter(writeFHFile);
    FHwriter.write(_generateFrameworkHeaderCode(model));
    FHwriter.close();
    FileWriter THwriter=new FileWriter(writeTHFile);
    THwriter.write(_generateTaskHeaderCode(model));
    THwriter.close();
  }
 catch (  IOException e) {
    throw new IllegalActionException(model,e,""String_Node_Str"");
  }
}"
75315,"/** 
 * Get the timer with expiration time that matches the current time. Remove the timer from the timers set and return the <i>kind<i> parameter of the timer to the caller method. If there are multiple timers with expiration time matching the current time, return the first one from the iterator list.
 * @return return the i>kind<i> parameter of the timeout timer.
 * @exception IllegalActionException If thrown bygetDirector().getCurrentTime().
 */
protected int whoTimeout() throws IllegalActionException {
  Iterator timers=_timersSet.iterator();
  while (timers.hasNext()) {
    Timer timer=(Timer)timers.next();
    if (timer.expirationTime == getDirector().getCurrentTime()) {
      timers.remove();
      return timer.kind;
    }
  }
  return -1;
}","/** 
 * Get the timer with expiration time that matches the current time. Remove the timer from the timers set and return the <i>kind<i> parameter of the timer to the caller method. If there are multiple timers with expiration time matching the current time, return the first one from the iterator list.
 * @return return the i>kind<i> parameter of the timeout timer.
 * @exception IllegalActionException If thrown bygetDirector().getCurrentTime().
 */
protected int whoTimeout() throws IllegalActionException {
  Iterator timers=_timersSet.iterator();
  while (timers.hasNext()) {
    Timer timer=(Timer)timers.next();
    if (timer.expirationTime == getDirector().getCurrentTime()) {
      timers.remove();
      return timer.kind;
    }
  }
  return UNKNOWN;
}"
75316,"/** 
 * If the specified attribute is changed, check that a positive number is given. Otherwise, defer to the base class.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  int temp=0;
  if (attribute == aPreambleLength) {
    temp=((IntToken)aPreambleLength.getToken()).intValue();
    if (temp < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + temp);
    }
 else {
      _aPreambleLength=temp;
    }
  }
 else   if (attribute == aPlcpHeaderLength) {
    temp=((IntToken)aPlcpHeaderLength.getToken()).intValue();
    if (temp < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + temp);
    }
 else {
      _aPlcpHeaderLength=temp;
    }
  }
 else   if (attribute == SNRThresholdInDB) {
    double SNRThresholdInDBValue=((DoubleToken)SNRThresholdInDB.getToken()).doubleValue();
    if (SNRThresholdInDBValue <= 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + SNRThresholdInDBValue);
    }
 else {
      _SNRThresholdInDB=Math.pow(10,SNRThresholdInDBValue / 10);
    }
  }
 else   if (attribute == sensitivity) {
    _sensitivity=((DoubleToken)sensitivity.getToken()).doubleValue();
    if (_sensitivity < 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _sensitivity);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the specified attribute is changed, check that a positive number is given. Otherwise, defer to the base class.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  int temp=0;
  if (attribute == aPreambleLength) {
    temp=((IntToken)aPreambleLength.getToken()).intValue();
    if (temp < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + temp);
    }
 else {
      _aPreambleLength=temp;
    }
  }
 else   if (attribute == aPlcpHeaderLength) {
    temp=((IntToken)aPlcpHeaderLength.getToken()).intValue();
    if (temp < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + temp);
    }
 else {
      _aPlcpHeaderLength=temp;
    }
  }
 else   if (attribute == SNRThresholdInDB) {
    double SNRThresholdInDBValue=((DoubleToken)SNRThresholdInDB.getToken()).doubleValue();
    _SNRThresholdInDB=Math.pow(10,SNRThresholdInDBValue / 10);
  }
 else   if (attribute == sensitivity) {
    _sensitivity=((DoubleToken)sensitivity.getToken()).doubleValue();
    if (_sensitivity < 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _sensitivity);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75317,"public void fire() throws IllegalActionException {
  super.fire();
  int oldnum=_numBusyTimers;
  int kind=whoTimeout2();
  double currentTime=getDirector().getCurrentTime();
  if (oldnum > 0 && _numBusyTimers == 0) {
    RecordToken ChannelStatusMsg=new RecordToken(SignalMsgFields,new Token[]{new IntToken(Idle)});
    channelStatus.send(0,ChannelStatusMsg);
  }
  double power, duration;
  RecordToken msg;
switch (_currentState) {
case Idle:
    if (fromChannel.hasToken(0)) {
      _data=(RecordToken)fromChannel.get(0);
      RecordToken properties=(RecordToken)((WirelessIOPort)fromChannel).getProperties(0);
      power=((DoubleToken)properties.get(""String_Node_Str"")).doubleValue();
      duration=((DoubleToken)properties.get(""String_Node_Str"")).doubleValue();
      if (power > _sensitivity && ((_interference == 0.0) || (power / _interference > _SNRThresholdInDB))) {
        setTimer2(RxDone,currentTime + duration,power);
        _numBusyTimers++;
        if (_numBusyTimers == 1) {
          RecordToken ChannelStatusMsg=new RecordToken(SignalMsgFields,new Token[]{new IntToken(Busy)});
          channelStatus.send(0,ChannelStatusMsg);
        }
        Token[] RxStartValues={new IntToken(RxStart),_data.get(""String_Node_Str"")};
        RecordToken RxStartMsg=new RecordToken(RxStartMsgFields,RxStartValues);
        toMAC.send(0,RxStartMsg);
        _receivedPower=power;
        _currentState=Receive;
      }
 else {
        setTimer2(InterferenceDone,currentTime + duration,power);
        _interference=_interference + power;
      }
    }
 else     if (fromMAC.hasToken(0)) {
      msg=(RecordToken)fromMAC.get(0);
      if (((IntToken)msg.get(""String_Node_Str"")).intValue() == TxStart)       _startTransmission(msg);
    }
  break;
case Receive:
if (kind == RxDone) {
  Token[] RxDataValues={new IntToken(RxData),_data.get(""String_Node_Str"")};
  RecordToken RxDataMsg=new RecordToken(RxDataMsgFields,RxDataValues);
  toMAC.send(0,RxDataMsg);
  Token[] RxEndValues={new IntToken(RxEnd),new IntToken(_rxStatus)};
  RecordToken RxEndMsg=new RecordToken(RxStartMsgFields,RxEndValues);
  toMAC.send(0,RxEndMsg);
  _currentState=Idle;
}
 else if (fromChannel.hasToken(0)) {
  _handleInterference();
  if (_receivedPower / _interference <= _SNRThresholdInDB)   _rxStatus=Error;
}
 else if (fromMAC.hasToken(0)) {
  msg=(RecordToken)fromMAC.get(0);
  if (((IntToken)msg.get(""String_Node_Str"")).intValue() == TxStart) {
    _startTransmission(msg);
    Token[] RxEndValues={new IntToken(RxEnd),new IntToken(Error)};
    RecordToken RxEndMsg=new RecordToken(RxEndMsgFields,RxEndValues);
    toMAC.send(0,RxEndMsg);
  }
}
break;
case Transmit:
if (kind == TxDone) {
RecordToken TxEndMsg=new RecordToken(SignalMsgFields,new Token[]{new IntToken(TxEnd)});
PHYConfirm.send(0,TxEndMsg);
_currentState=Idle;
}
 else if (fromChannel.hasToken(0)) {
_handleInterference();
}
 else if (fromMAC.hasToken(0)) {
msg=(RecordToken)fromMAC.get(0);
if (((IntToken)msg.get(""String_Node_Str"")).intValue() == TxData) {
Token[] ChMsgValues={new IntToken(_txRate),msg.get(""String_Node_Str"")};
RecordToken ChMsg=new RecordToken(ChMsgFields,ChMsgValues);
toChannel.send(0,ChMsg);
_setAttribute(_duration,new DoubleToken(_txDuration));
setTimer2(TxDone,currentTime + _txDuration,0.0);
}
}
break;
}
}","public void fire() throws IllegalActionException {
  super.fire();
  int oldnum=_numBusyTimers;
  int kind=whoTimeout2();
  double currentTime=getDirector().getCurrentTime();
  if (oldnum > 0 && _numBusyTimers == 0) {
    RecordToken ChannelStatusMsg=new RecordToken(SignalMsgFields,new Token[]{new IntToken(Idle)});
    channelStatus.send(0,ChannelStatusMsg);
  }
  double power=0, duration=-1;
  RecordToken msg;
switch (_currentState) {
case PHY_Idle:
    if (fromChannel.hasToken(0)) {
      _data=(RecordToken)fromChannel.get(0);
      Iterator connectedPorts=fromChannel.sourcePortList().iterator();
      while (connectedPorts.hasNext()) {
        IOPort port=(IOPort)connectedPorts.next();
        if (port.isInput() && port instanceof WirelessIOPort) {
          RecordToken properties=(RecordToken)((WirelessIOPort)port).getProperties(0);
          power=((DoubleToken)properties.get(""String_Node_Str"")).doubleValue();
          duration=((DoubleToken)properties.get(""String_Node_Str"")).doubleValue();
          break;
        }
      }
      if (power > 0) {
        setTimer2(RxDone,currentTime + duration,power);
        _numBusyTimers++;
        if (_numBusyTimers == 1) {
          RecordToken ChannelStatusMsg=new RecordToken(SignalMsgFields,new Token[]{new IntToken(Busy)});
          channelStatus.send(0,ChannelStatusMsg);
        }
        Token[] RxStartValues={new IntToken(RxStart),_data.get(""String_Node_Str"")};
        RecordToken RxStartMsg=new RecordToken(RxStartMsgFields,RxStartValues);
        toMAC.send(0,RxStartMsg);
        _receivedPower=power;
        _currentState=Receive;
      }
 else {
        setTimer2(InterferenceDone,currentTime + duration,power);
        _interference=_interference + power;
      }
    }
 else     if (fromMAC.hasToken(0)) {
      msg=(RecordToken)fromMAC.get(0);
      if (((IntToken)msg.get(""String_Node_Str"")).intValue() == TxStart) {
        _startTransmission(msg);
      }
    }
  break;
case Receive:
if (kind == RxDone) {
  Token[] RxDataValues={new IntToken(RxData),_data.get(""String_Node_Str"")};
  RecordToken RxDataMsg=new RecordToken(RxDataMsgFields,RxDataValues);
  toMAC.send(0,RxDataMsg);
  Token[] RxEndValues={new IntToken(RxEnd),new IntToken(_rxStatus)};
  RecordToken RxEndMsg=new RecordToken(RxEndMsgFields,RxEndValues);
  toMAC.send(0,RxEndMsg);
  _currentState=PHY_Idle;
}
 else if (fromChannel.hasToken(0)) {
  _handleInterference();
  if (_receivedPower / _interference <= _SNRThresholdInDB) {
    _rxStatus=Error;
  }
}
 else if (fromMAC.hasToken(0)) {
  msg=(RecordToken)fromMAC.get(0);
  if (((IntToken)msg.get(""String_Node_Str"")).intValue() == TxStart) {
    _startTransmission(msg);
    Token[] RxEndValues={new IntToken(RxEnd),new IntToken(Error)};
    RecordToken RxEndMsg=new RecordToken(RxEndMsgFields,RxEndValues);
    toMAC.send(0,RxEndMsg);
  }
}
break;
case Transmit:
if (kind == TxDone) {
RecordToken TxEndMsg=new RecordToken(SignalMsgFields,new Token[]{new IntToken(TxEnd)});
PHYConfirm.send(0,TxEndMsg);
_currentState=PHY_Idle;
}
 else if (fromChannel.hasToken(0)) {
_handleInterference();
}
 else if (fromMAC.hasToken(0)) {
msg=(RecordToken)fromMAC.get(0);
if (((IntToken)msg.get(""String_Node_Str"")).intValue() == TxData) {
Token[] ChMsgValues={new IntToken(_txRate),msg.get(""String_Node_Str"")};
RecordToken ChMsg=new RecordToken(ChMsgFields,ChMsgValues);
toChannel.send(0,ChMsg);
setTimer2(TxDone,currentTime + _txDuration,0.0);
}
}
break;
}
}"
75318,"/** 
 * Get the timer with expiration time that matches the current time. Remove the timer from the timers set and return the <i>kind<i> parameter of the timer to the caller method. If there are multiple timers with expiration time matching the current time, return the first one from the iterator list.
 * @return return the i>kind<i> parameter of the timeout timer.
 * @exception IllegalActionException If thrown bygetDirector().getCurrentTime().
 */
protected int whoTimeout2() throws IllegalActionException {
  Iterator timers=_timersSet.iterator();
  while (timers.hasNext()) {
    ExtendedTimer timer=(ExtendedTimer)timers.next();
    if (timer.expirationTime == getDirector().getCurrentTime()) {
      if (timer.kind == InterferenceDone) {
        _interference=_interference - timer.power;
        if (_interference < 0.0)         _interference=0.0;
      }
      if (((timer.kind == InterferenceDone) || (timer.kind == RxDone)) && timer.power > _sensitivity)       _numBusyTimers--;
      timers.remove();
      return timer.kind;
    }
  }
  return -1;
}","/** 
 * Get the timer with expiration time that matches the current time. Remove the timer from the timers set and return the <i>kind<i> parameter of the timer to the caller method. If there are multiple timers with expiration time matching the current time, return the first one from the iterator list.
 * @return return the i>kind<i> parameter of the timeout timer.
 * @exception IllegalActionException If thrown bygetDirector().getCurrentTime().
 */
protected int whoTimeout2() throws IllegalActionException {
  Iterator timers=_timersSet.iterator();
  while (timers.hasNext()) {
    ExtendedTimer timer=(ExtendedTimer)timers.next();
    if (timer.expirationTime == getDirector().getCurrentTime()) {
      if (timer.kind == InterferenceDone) {
        _interference=_interference - timer.power;
        if (_interference < 0.0) {
          _interference=0.0;
        }
      }
      if (((timer.kind == InterferenceDone) || (timer.kind == RxDone)) && timer.power > _sensitivity) {
        _numBusyTimers--;
      }
      timers.remove();
      return timer.kind;
    }
  }
  return -1;
}"
75319,"/** 
 * Initialize the private variables.
 * @exception IllegalActionException If thrown by the base class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _currentState=Idle;
  _interference=0.0;
  _numBusyTimers=0;
}","/** 
 * Initialize the private variables.
 * @exception IllegalActionException If thrown by the base class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _currentState=PHY_Idle;
  _interference=0.0;
  _numBusyTimers=0;
}"
75320,"private void _handleInterference() throws IllegalActionException {
  fromChannel.get(0);
  RecordToken properties=(RecordToken)((WirelessIOPort)fromChannel).getProperties(0);
  double power=((DoubleToken)properties.get(""String_Node_Str"")).doubleValue();
  double duration=((DoubleToken)properties.get(""String_Node_Str"")).doubleValue();
  double currentTime=getDirector().getCurrentTime();
  setTimer2(InterferenceDone,currentTime + duration,power);
  _interference=_interference + power;
  if (power > _sensitivity)   _numBusyTimers++;
  if (_numBusyTimers == 1) {
    Token[] value={new IntToken(Busy)};
    RecordToken ChannelStatusMsg=new RecordToken(SignalMsgFields,value);
    channelStatus.send(0,ChannelStatusMsg);
  }
}","private void _handleInterference() throws IllegalActionException {
  double power=0.5, duration=-1;
  ;
  fromChannel.get(0);
  Iterator connectedPorts=fromChannel.sourcePortList().iterator();
  while (connectedPorts.hasNext()) {
    IOPort port=(IOPort)connectedPorts.next();
    if (port.isInput() && port instanceof WirelessIOPort) {
      RecordToken properties=(RecordToken)((WirelessIOPort)port).getProperties(0);
      power=((DoubleToken)properties.get(""String_Node_Str"")).doubleValue();
      duration=((DoubleToken)properties.get(""String_Node_Str"")).doubleValue();
      break;
    }
  }
  double currentTime=getDirector().getCurrentTime();
  setTimer2(InterferenceDone,currentTime + duration,power);
  _interference=_interference + power;
  if (power > _sensitivity) {
    _numBusyTimers++;
  }
  if (_numBusyTimers == 1) {
    Token[] value={new IntToken(Busy)};
    RecordToken ChannelStatusMsg=new RecordToken(SignalMsgFields,value);
    channelStatus.send(0,ChannelStatusMsg);
  }
}"
75321,"/** 
 * Process input packets.
 * @exception IllegalActionException If an error occurs readingor writing inputs or outputs.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (!fromValidateMpdu.hasToken(0))   return;
  int dAck=0;
  RecordToken msg=(RecordToken)fromValidateMpdu.get(0);
  int msgKind=((IntToken)msg.get(""String_Node_Str"")).intValue();
  if (msgKind == RxMpdu) {
    if (_debugging)     _debug(""String_Node_Str"");
    RecordToken pdu=(RecordToken)msg.get(""String_Node_Str"");
    if (intFieldValue(pdu,""String_Node_Str"") == 1)     dAck=intFieldValue(pdu,""String_Node_Str"");
    int dNav=intFieldValue(pdu,""String_Node_Str"");
    int src=misc;
    if (intFieldValue(pdu,""String_Node_Str"") == mac_broadcast_addr) {
      RecordToken msgout=new RecordToken(RxIndicateMessageFields,new Token[]{new IntToken(RxIndicate),pdu,msg.get(""String_Node_Str""),msg.get(""String_Node_Str"")});
      toProtocolControl.send(0,msgout);
      if (_debugging)       _debug(""String_Node_Str"");
    }
 else     if (intFieldValue(pdu,""String_Node_Str"") == getID()) {
      boolean dup=false;
      if (intFieldValue(pdu,""String_Node_Str"") == 1)       dup=_searchTupleCache(pdu);
      if (intFieldValue(pdu,""String_Node_Str"") == 0 || !dup) {
        RecordToken msgout=new RecordToken(RxIndicateMessageFields,new Token[]{new IntToken(RxIndicate),pdu,msg.get(""String_Node_Str""),msg.get(""String_Node_Str"")});
        toProtocolControl.send(0,msgout);
        if (_debugging)         _debug(""String_Node_Str"");
      }
      if (intFieldValue(pdu,""String_Node_Str"") == DataType) {
        RecordToken msgout=new RecordToken(NeedAckMessageFields,new Token[]{new IntToken(NeedAck),pdu.get(""String_Node_Str""),msg.get(""String_Node_Str""),msg.get(""String_Node_Str""),new IntToken(dAck)});
        toProtocolControl.send(0,msgout);
        if (_debugging)         _debug(""String_Node_Str"");
        _updateTupleCache(pdu);
      }
    }
 else {
      if (intFieldValue(pdu,""String_Node_Str"") == ControlType && intFieldValue(pdu,""String_Node_Str"") == Rts)       src=Rts;
      if (intFieldValue(pdu,""String_Node_Str"") <= 32767) {
        RecordToken msgout=new RecordToken(SetNavMessageFields,new Token[]{new IntToken(SetNav),msg.get(""String_Node_Str""),new IntToken(dNav),new IntToken(src)});
        toChannelState.send(0,msgout);
      }
    }
  }
}","/** 
 * Process input packets.
 * @exception IllegalActionException If an error occurs readingor writing inputs or outputs.
 */
public void fire() throws IllegalActionException {
  super.fire();
  if (!fromValidateMpdu.hasToken(0))   return;
  int dAck=0;
  RecordToken msg=(RecordToken)fromValidateMpdu.get(0);
  int msgKind=((IntToken)msg.get(""String_Node_Str"")).intValue();
  if (msgKind == RxMpdu) {
    if (_debugging)     _debug(""String_Node_Str"");
    RecordToken pdu=(RecordToken)msg.get(""String_Node_Str"");
    if (intFieldValue(pdu,""String_Node_Str"") == 1)     dAck=intFieldValue(pdu,""String_Node_Str"");
    int dNav=intFieldValue(pdu,""String_Node_Str"");
    int src=misc;
    if (intFieldValue(pdu,""String_Node_Str"") == mac_broadcast_addr) {
      RecordToken msgout=new RecordToken(RxIndicateMessageFields,new Token[]{new IntToken(RxIndicate),pdu,msg.get(""String_Node_Str""),msg.get(""String_Node_Str"")});
      toProtocolControl.send(0,msgout);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
 else     if (intFieldValue(pdu,""String_Node_Str"") == getID()) {
      boolean dup=false;
      if (intFieldValue(pdu,""String_Node_Str"") == 1)       dup=_searchTupleCache(pdu);
      if (intFieldValue(pdu,""String_Node_Str"") == 0 || !dup) {
        RecordToken msgout=new RecordToken(RxIndicateMessageFields,new Token[]{new IntToken(RxIndicate),pdu,msg.get(""String_Node_Str""),msg.get(""String_Node_Str"")});
        toProtocolControl.send(0,msgout);
        if (_debugging)         _debug(""String_Node_Str"");
      }
      if (intFieldValue(pdu,""String_Node_Str"") == DataType) {
        RecordToken msgout=new RecordToken(NeedAckMessageFields,new Token[]{new IntToken(NeedAck),pdu.get(""String_Node_Str""),msg.get(""String_Node_Str""),msg.get(""String_Node_Str""),new IntToken(dAck)});
        toProtocolControl.send(0,msgout);
        if (_debugging)         _debug(""String_Node_Str"");
        _updateTupleCache(pdu);
      }
    }
 else {
      if (intFieldValue(pdu,""String_Node_Str"") == ControlType && intFieldValue(pdu,""String_Node_Str"") == Rts)       src=Rts;
      if (intFieldValue(pdu,""String_Node_Str"") <= 32767) {
        RecordToken msgout=new RecordToken(SetNavMessageFields,new Token[]{new IntToken(SetNav),msg.get(""String_Node_Str""),new IntToken(dNav),new IntToken(src)});
        toChannelState.send(0,msgout);
      }
    }
  }
}"
75322,"/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, and there are no other tableaux in the parent effigy or any effigy that contains it, then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (getEffigy() == null) {
    return super._close();
  }
  Effigy topEffigy=getEffigy().topEffigy();
  if (!_tableau.isMaster()) {
    List tableaux=topEffigy.entityList(Tableau.class);
    Iterator tableauxIterator=tableaux.iterator();
    while (tableauxIterator.hasNext()) {
      Tableau tableau=(Tableau)tableauxIterator.next();
      if (!(tableau instanceof DialogTableau) && (tableau != _tableau)) {
        dispose();
        return true;
      }
    }
  }
  if (isModified()) {
    int reply=_queryForSave();
    if (reply == _DISCARDED || reply == _FAILED) {
      if (!_checkForDerivedObjects()) {
        return false;
      }
      dispose();
      return true;
    }
    return false;
  }
 else {
    dispose();
    return true;
  }
}","/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, and there are no other tableaux in the parent effigy or any effigy that contains it, then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (getEffigy() == null) {
    return super._close();
  }
  Effigy topEffigy=getEffigy().topEffigy();
  if (!_tableau.isMaster()) {
    List tableaux=topEffigy.entityList(Tableau.class);
    Iterator tableauxIterator=tableaux.iterator();
    while (tableauxIterator.hasNext()) {
      Tableau tableau=(Tableau)tableauxIterator.next();
      if (!(tableau instanceof DialogTableau) && (tableau != _tableau)) {
        dispose();
        return true;
      }
    }
  }
  if (isModified()) {
    int reply=_queryForSave();
    if (reply == _DISCARDED || reply == _FAILED) {
      if (!_checkForDerivedObjects()) {
        return false;
      }
    }
    if (reply == _SAVED || reply == _DISCARDED) {
      dispose();
      return true;
    }
    return false;
  }
 else {
    dispose();
    return true;
  }
}"
75323,"/** 
 * Generate code for the H file f_code.h. This function generates the function and variable declarations for the implementation in f_code.c
 * @return The output code.
 */
private static String _generateFrameworkHeaderCode(TypedCompositeActor model) throws IllegalActionException {
  String codeString=""String_Node_Str"";
  codeString+=copyrightString;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  Iterator dataType=dataTypes.iterator();
  while (dataType.hasNext()) {
    String type=(String)dataType.next();
    if (type.endsWith(""String_Node_Str"")) {
      codeString+=""String_Node_Str"" + type.substring(0,type.length() - 5) + ""String_Node_Str""+ type+ ""String_Node_Str""+ _endLine+ _endLine;
    }
  }
  codeString+=""String_Node_Str"" + _endLine + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=funcDeclString;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  return codeString;
}","/** 
 * Generate code for the H file f_code.h. This function generates the function and variable declarations for the implementation in f_code.c
 * @return The output code.
 */
private static String _generateFrameworkHeaderCode(TypedCompositeActor model) throws IllegalActionException {
  String codeString=""String_Node_Str"";
  codeString+=copyrightString;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    String actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    int actorFreq=0;
    Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
    if (actorFreqPara == null) {
      actorFreq=1;
    }
 else {
      actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
    }
    codeString+=""String_Node_Str"" + actorName + ""String_Node_Str""+ _tabChar+ _tabChar+ ""String_Node_Str""+ actorFreq+ ""String_Node_Str""+ _endLine;
  }
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  Iterator dataType=dataTypes.iterator();
  while (dataType.hasNext()) {
    String type=(String)dataType.next();
    if (type.endsWith(""String_Node_Str"")) {
      codeString+=""String_Node_Str"" + type.substring(0,type.length() - 5) + ""String_Node_Str""+ type+ ""String_Node_Str""+ _endLine+ _endLine;
    }
  }
  codeString+=""String_Node_Str"" + _endLine + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  codeString+=_endLine;
  codeString+=funcDeclString;
  codeString+=_endLine;
  codeString+=""String_Node_Str"" + _endLine;
  return codeString;
}"
75324,"private static String _inputDriversImplementationCode(TypedCompositeActor model) throws IllegalActionException {
  String codeString;
  String varDeclString=""String_Node_Str"";
  String arrayInitString=""String_Node_Str"";
  String assgtStmtString=""String_Node_Str"";
  Actor actor;
  String actorName;
  codeString=""String_Node_Str"" + _endLine + ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ _endLine;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    actor=(Actor)actors.next();
    if (!_needsInputDriver(actor)) {
      continue;
    }
    actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    boolean firstParameter=true;
    codeString+=""String_Node_Str"" + actorName + ""String_Node_Str"";
    funcDeclString+=""String_Node_Str"" + actorName + ""String_Node_Str"";
    Map driverIOMap=new LinkedHashMap();
    for (Iterator inPorts=actor.inputPortList().iterator(); inPorts.hasNext(); ) {
      TypedIOPort inPort=(TypedIOPort)inPorts.next();
      String sanitizedPortName=StringUtilities.sanitizeName(inPort.getName(model));
      String inPortType=_getTypeString(inPort);
      List sourcePortList=inPort.sourcePortList();
      if (sourcePortList.size() > 1) {
        throw new IllegalActionException(inPort,""String_Node_Str"" + ""String_Node_Str"");
      }
      TypedIOPort port=(TypedIOPort)inPort.sourcePortList().get(0);
      String sanitizedPortName2=StringUtilities.sanitizeName(port.getName(model));
      String portType=_getTypeString(port);
      if (firstParameter) {
        firstParameter=false;
      }
 else {
        codeString+=""String_Node_Str"";
        funcDeclString+=""String_Node_Str"";
      }
      codeString+=portType + ""String_Node_Str"" + sanitizedPortName2+ ""String_Node_Str""+ _getTypeString(inPort)+ ""String_Node_Str""+ sanitizedPortName;
      funcDeclString+=portType + ""String_Node_Str"" + sanitizedPortName2+ ""String_Node_Str""+ _getTypeString(inPort)+ ""String_Node_Str""+ sanitizedPortName;
      if (portType.endsWith(""String_Node_Str"")) {
        if (varDeclString.length() == 0) {
          varDeclString+=_tabChar + ""String_Node_Str"" + _endLine;
        }
        String arrayLength=_getArrayLength(port);
        varDeclString+=_tabChar + ""String_Node_Str"" + portType.substring(0,portType.length() - 5)+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ ""String_Node_Str""+ sanitizedPortName2+ ""String_Node_Str""+ _endLine;
        arrayInitString+=_tabChar + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ ""String_Node_Str""+ sanitizedPortName2+ ""String_Node_Str""+ _endLine;
        assgtStmtString+=_tabChar + ""String_Node_Str"" + arrayLength+ ""String_Node_Str""+ _endLine+ _tabChar+ _tabChar+ sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName2+ ""String_Node_Str""+ _endLine+ _tabChar+ ""String_Node_Str""+ _endLine;
      }
 else {
        assgtStmtString+=_tabChar + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName2+ ""String_Node_Str""+ _endLine;
      }
    }
    codeString+=""String_Node_Str"" + _endLine;
    funcDeclString+=""String_Node_Str"" + _endLine + _endLine;
    codeString+=varDeclString + _endLine + arrayInitString+ _endLine+ assgtStmtString;
    codeString+=""String_Node_Str"" + _endLine;
  }
  return codeString;
}","private static String _inputDriversImplementationCode(TypedCompositeActor model) throws IllegalActionException {
  String codeString;
  String varDeclString=""String_Node_Str"";
  String arrayInitString=""String_Node_Str"";
  String assgtStmtString=""String_Node_Str"";
  Actor actor;
  String actorName;
  codeString=""String_Node_Str"" + _endLine + ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ _endLine;
  Iterator actors=model.entityList().iterator();
  while (actors.hasNext()) {
    actor=(Actor)actors.next();
    if (!_needsInputDriver(actor)) {
      continue;
    }
    actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName());
    codeString+=""String_Node_Str"" + actorName + ""String_Node_Str"";
    funcDeclString+=""String_Node_Str"" + actorName + ""String_Node_Str"";
    varDeclString=_tabChar + ""String_Node_Str"" + _endLine;
    varDeclString+=_tabChar + ""String_Node_Str"" + _endLine;
    arrayInitString=""String_Node_Str"";
    assgtStmtString=_tabChar + ""String_Node_Str"" + _endLine;
    Map driverIOMap=new LinkedHashMap();
    boolean firstParameter=true;
    boolean firstArray=true;
    for (Iterator inPorts=actor.inputPortList().iterator(); inPorts.hasNext(); ) {
      TypedIOPort inPort=(TypedIOPort)inPorts.next();
      String sanitizedPortName=StringUtilities.sanitizeName(inPort.getName(model));
      String inPortType=_getTypeString(inPort);
      List sourcePortList=inPort.sourcePortList();
      if (sourcePortList.size() > 1) {
        throw new IllegalActionException(inPort,""String_Node_Str"" + ""String_Node_Str"");
      }
      TypedIOPort port=(TypedIOPort)inPort.sourcePortList().get(0);
      String sanitizedPortName2=StringUtilities.sanitizeName(port.getName(model));
      String portType=_getTypeString(port);
      if (firstParameter) {
        firstParameter=false;
      }
 else {
        codeString+=""String_Node_Str"";
        funcDeclString+=""String_Node_Str"";
      }
      codeString+=portType + ""String_Node_Str"" + sanitizedPortName2+ ""String_Node_Str""+ _getTypeString(inPort)+ ""String_Node_Str""+ sanitizedPortName;
      funcDeclString+=portType + ""String_Node_Str"" + sanitizedPortName2+ ""String_Node_Str""+ _getTypeString(inPort)+ ""String_Node_Str""+ sanitizedPortName;
      if (portType.endsWith(""String_Node_Str"")) {
        if (firstArray) {
          firstArray=false;
          varDeclString+=_tabChar + ""String_Node_Str"" + _endLine;
        }
        String arrayLength=_getArrayLength(port);
        varDeclString+=_tabChar + ""String_Node_Str"" + portType.substring(0,portType.length() - 5)+ ""String_Node_Str""+ sanitizedPortName2+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ ""String_Node_Str""+ _endLine;
        arrayInitString+=_tabChar + ""String_Node_Str"" + sanitizedPortName+ ""String_Node_Str""+ ""String_Node_Str""+ sanitizedPortName2+ ""String_Node_Str""+ _endLine;
        String sourceActorName=StringUtilities.sanitizeName(port.getContainer().getName());
        assgtStmtString+=_tabChar + _tabChar + ""String_Node_Str""+ ""String_Node_Str""+ actorName+ ""String_Node_Str""+ sourceActorName+ ""String_Node_Str""+ _endLine+ _tabChar+ _tabChar+ _tabChar+ ""String_Node_Str""+ arrayLength+ ""String_Node_Str""+ _endLine+ _tabChar+ _tabChar+ _tabChar+ _tabChar+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName2+ ""String_Node_Str""+ _endLine+ _tabChar+ _tabChar+ _tabChar+ ""String_Node_Str""+ _endLine+ _tabChar+ _tabChar+ ""String_Node_Str""+ _endLine;
      }
 else {
        assgtStmtString+=_tabChar + _tabChar + ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName2+ ""String_Node_Str""+ _endLine;
      }
    }
    assgtStmtString+=_tabChar + ""String_Node_Str"" + _endLine+ _tabChar+ ""String_Node_Str""+ actorName+ ""String_Node_Str""+ _endLine;
    codeString+=""String_Node_Str"" + _endLine;
    funcDeclString+=""String_Node_Str"" + _endLine + _endLine;
    codeString+=varDeclString + _endLine + arrayInitString+ _endLine+ assgtStmtString;
    codeString+=""String_Node_Str"" + _endLine;
  }
  return codeString;
}"
75325,"/** 
 * apply any changes that may have been made in the table.
 */
protected void _apply(){
  Iterator portIterator;
  TypedIOPort actualPort;
  String portNameInTable[]=new String[_portTableModel.getRowCount()];
  for (int i=0; i < _portTableModel.getRowCount(); i++) {
    portNameInTable[i]=(String)(_portTableModel.getValueAt(i,PortTableModel.COL_NAME));
  }
  for (int i=0; i < _portTableModel.getRowCount(); i++) {
    if (portNameInTable[i].equals(""String_Node_Str"")) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"");
      return;
    }
  }
  for (int i=0; i < _portTableModel.getRowCount(); i++) {
    for (int j=i + 1; j < _portTableModel.getRowCount(); j++) {
      if (portNameInTable[i].equals(portNameInTable[j])) {
        JOptionPane.showMessageDialog(this,portNameInTable[i] + ""String_Node_Str"" + ""String_Node_Str"");
        return;
      }
    }
  }
  Vector portsToBeRemoved=new Vector();
  portIterator=getTarget().portList().iterator();
  actualPort=null;
  while (portIterator.hasNext()) {
    Object candidate=portIterator.next();
    if (candidate instanceof TypedIOPort) {
      boolean foundPort=false;
      actualPort=((TypedIOPort)candidate);
      for (int i=0; i < _ports.size(); i++) {
        Object portInfo[]=(Object[])(_ports.elementAt(i));
        if (actualPort == ((TypedIOPort)portInfo[PortTableModel.COL_ACTUAL_PORT])) {
          foundPort=true;
          break;
        }
      }
      if (!foundPort) {
        portsToBeRemoved.add(actualPort);
      }
    }
  }
  Iterator actualPorts=portsToBeRemoved.iterator();
  while (actualPorts.hasNext()) {
    StringBuffer moml=new StringBuffer();
    actualPort=(TypedIOPort)(actualPorts.next());
    NamedObj container=(NamedObj)actualPort.getContainer();
    NamedObj composite=(NamedObj)container.getContainer();
    if (composite != null) {
      moml.append(""String_Node_Str"" + actualPort.getName() + ""String_Node_Str""+ container.getName()+ ""String_Node_Str"");
    }
 else {
      moml.append(""String_Node_Str"" + actualPort.getName(container) + ""String_Node_Str"");
    }
    MoMLChangeRequest request=null;
    if (composite != null) {
      request=new MoMLChangeRequest(this,composite,moml.toString());
    }
 else {
      request=new MoMLChangeRequest(this,container,moml.toString());
    }
    request.setUndoable(true);
    container.addChangeListener(this);
    if (_debug)     System.out.println(""String_Node_Str"" + container.toString() + ""String_Node_Str""+ moml);
    container.requestChange(request);
  }
  StringBuffer moml=new StringBuffer(""String_Node_Str"");
  boolean haveSomeUpdate=false;
  for (int i=0; i < _ports.size(); i++) {
    Object portInfo[]=(Object[])(_ports.elementAt(i));
    portIterator=getTarget().portList().iterator();
    actualPort=(TypedIOPort)(portInfo[PortTableModel.COL_ACTUAL_PORT]);
    boolean updates[]=new boolean[_portTableModel.getColumnCount()];
    if (actualPort != null) {
      for (int updateNum=0; updateNum < 7; updateNum++) {
        updates[updateNum]=false;
      }
      boolean havePortUpdate=false;
      if (!(actualPort.getName().equals((String)(portInfo[PortTableModel.COL_NAME])))) {
        havePortUpdate=true;
        updates[PortTableModel.COL_NAME]=true;
      }
      if (actualPort.isInput() != (((Boolean)(portInfo[PortTableModel.COL_INPUT])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_INPUT]=true;
      }
      if (actualPort.isOutput() != (((Boolean)(portInfo[PortTableModel.COL_OUTPUT])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_OUTPUT]=true;
      }
      if (actualPort.isMultiport() != (((Boolean)(portInfo[PortTableModel.COL_MULTIPORT])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_MULTIPORT]=true;
      }
      Attribute _show=(Attribute)(actualPort.getAttribute(""String_Node_Str""));
      if ((_show == null) == (((Boolean)(portInfo[PortTableModel.COL_SHOW_NAME])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_SHOW_NAME]=true;
      }
      Attribute hide=actualPort.getAttribute(""String_Node_Str"");
      if ((hide == null) == (((Boolean)(portInfo[PortTableModel.COL_HIDE])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_HIDE]=true;
      }
      String _type=null;
      UnitAttribute _typeAttribute=(UnitAttribute)actualPort.getAttribute(""String_Node_Str"");
      if (_typeAttribute != null) {
        _type=_typeAttribute.getExpression();
      }
      if ((_type == null && (!((String)(portInfo[PortTableModel.COL_TYPE])).equals(""String_Node_Str""))) || ((_type != null) && (!((String)(portInfo[PortTableModel.COL_TYPE])).equals(_type)))) {
        havePortUpdate=true;
        updates[PortTableModel.COL_TYPE]=true;
      }
      String _direction=null;
      String direction=(String)(portInfo[PortTableModel.COL_DIRECTION]);
      StringAttribute _cardinal=(StringAttribute)(actualPort.getAttribute(""String_Node_Str""));
      if (_cardinal != null)       _direction=_cardinal.getExpression().toUpperCase();
      if (((_direction == null) && !direction.equals(""String_Node_Str"")) || ((_direction != null) && (!direction.equals(_direction)))) {
        havePortUpdate=true;
        updates[PortTableModel.COL_DIRECTION]=true;
      }
      String _units=null;
      UnitAttribute _unitsAttribute=(UnitAttribute)actualPort.getAttribute(""String_Node_Str"");
      if (_unitsAttribute != null) {
        _units=_unitsAttribute.getExpression();
      }
      if ((_units == null && (!((String)(portInfo[PortTableModel.COL_UNITS])).equals(""String_Node_Str""))) || ((_units != null) && (!((String)(portInfo[PortTableModel.COL_UNITS])).equals(_units)))) {
        havePortUpdate=true;
        updates[PortTableModel.COL_UNITS]=true;
      }
      if (havePortUpdate) {
        NamedObj parent=(NamedObj)actualPort.getContainer();
        moml.append(_createMoMLUpdate(updates,portInfo,(String)(((TypedIOPort)(portInfo[PortTableModel.COL_ACTUAL_PORT])).getName()),(String)(portInfo[PortTableModel.COL_NAME])));
        haveSomeUpdate=true;
      }
    }
 else {
      for (int updateNum=0; updateNum < 7; updateNum++) {
        updates[updateNum]=true;
      }
      updates[PortTableModel.COL_NAME]=false;
      updates[PortTableModel.COL_SHOW_NAME]=((Boolean)(portInfo[PortTableModel.COL_SHOW_NAME])).booleanValue();
      updates[PortTableModel.COL_HIDE]=((Boolean)(portInfo[PortTableModel.COL_HIDE])).booleanValue();
      String _type=(String)(portInfo[PortTableModel.COL_TYPE]);
      if (!_type.equals(""String_Node_Str"")) {
        updates[PortTableModel.COL_TYPE]=true;
        _portTableModel.fireTableDataChanged();
      }
 else {
        updates[PortTableModel.COL_TYPE]=false;
      }
      String direction=(String)(portInfo[PortTableModel.COL_DIRECTION]);
      if (!direction.equals(""String_Node_Str"")) {
        updates[PortTableModel.COL_DIRECTION]=true;
        _portTableModel.fireTableDataChanged();
      }
 else {
        updates[PortTableModel.COL_DIRECTION]=false;
      }
      moml.append(_createMoMLUpdate(updates,portInfo,(String)(portInfo[PortTableModel.COL_NAME]),null));
      haveSomeUpdate=true;
    }
  }
  if (haveSomeUpdate) {
    moml.append(""String_Node_Str"");
    if (_debug)     System.out.println(""String_Node_Str"" + getTarget().toString() + ""String_Node_Str""+ moml);
    MoMLChangeRequest request=new MoMLChangeRequest(this,getTarget(),moml.toString(),null);
    request.setUndoable(true);
    getTarget().requestChange(request);
    _populateActualPorts();
  }
  _setDirty(false);
  _enableApplyButton(false);
}","/** 
 * apply any changes that may have been made in the table.
 */
protected void _apply(){
  Iterator portIterator;
  TypedIOPort actualPort;
  String portNameInTable[]=new String[_portTableModel.getRowCount()];
  for (int i=0; i < _portTableModel.getRowCount(); i++) {
    portNameInTable[i]=(String)(_portTableModel.getValueAt(i,PortTableModel.COL_NAME));
  }
  for (int i=0; i < _portTableModel.getRowCount(); i++) {
    if (portNameInTable[i].equals(""String_Node_Str"")) {
      JOptionPane.showMessageDialog(this,""String_Node_Str"");
      return;
    }
  }
  for (int i=0; i < _portTableModel.getRowCount(); i++) {
    for (int j=i + 1; j < _portTableModel.getRowCount(); j++) {
      if (portNameInTable[i].equals(portNameInTable[j])) {
        JOptionPane.showMessageDialog(this,portNameInTable[i] + ""String_Node_Str"" + ""String_Node_Str"");
        return;
      }
    }
  }
  Vector portsToBeRemoved=new Vector();
  portIterator=getTarget().portList().iterator();
  actualPort=null;
  while (portIterator.hasNext()) {
    Object candidate=portIterator.next();
    if (candidate instanceof TypedIOPort) {
      boolean foundPort=false;
      actualPort=((TypedIOPort)candidate);
      for (int i=0; i < _ports.size(); i++) {
        Object portInfo[]=(Object[])(_ports.elementAt(i));
        if (actualPort == ((TypedIOPort)portInfo[PortTableModel.COL_ACTUAL_PORT])) {
          foundPort=true;
          break;
        }
      }
      if (!foundPort) {
        portsToBeRemoved.add(actualPort);
      }
    }
  }
  Iterator actualPorts=portsToBeRemoved.iterator();
  while (actualPorts.hasNext()) {
    StringBuffer moml=new StringBuffer();
    actualPort=(TypedIOPort)(actualPorts.next());
    NamedObj container=(NamedObj)actualPort.getContainer();
    NamedObj composite=(NamedObj)container.getContainer();
    if (composite != null) {
      moml.append(""String_Node_Str"" + actualPort.getName() + ""String_Node_Str""+ container.getName()+ ""String_Node_Str"");
    }
 else {
      moml.append(""String_Node_Str"" + actualPort.getName(container) + ""String_Node_Str"");
    }
    MoMLChangeRequest request=null;
    if (composite != null) {
      request=new MoMLChangeRequest(this,composite,moml.toString());
    }
 else {
      request=new MoMLChangeRequest(this,container,moml.toString());
    }
    request.setUndoable(true);
    container.addChangeListener(this);
    if (_debug)     System.out.println(""String_Node_Str"" + container.toString() + ""String_Node_Str""+ moml);
    container.requestChange(request);
  }
  StringBuffer moml=new StringBuffer(""String_Node_Str"");
  boolean haveSomeUpdate=false;
  for (int i=0; i < _ports.size(); i++) {
    Object portInfo[]=(Object[])(_ports.elementAt(i));
    portIterator=getTarget().portList().iterator();
    actualPort=(TypedIOPort)(portInfo[PortTableModel.COL_ACTUAL_PORT]);
    boolean updates[]=new boolean[_portTableModel.getColumnCount()];
    if (actualPort != null) {
      for (int updateNum=0; updateNum < 7; updateNum++) {
        updates[updateNum]=false;
      }
      boolean havePortUpdate=false;
      if (!(actualPort.getName().equals((String)(portInfo[PortTableModel.COL_NAME])))) {
        havePortUpdate=true;
        updates[PortTableModel.COL_NAME]=true;
      }
      if (actualPort.isInput() != (((Boolean)(portInfo[PortTableModel.COL_INPUT])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_INPUT]=true;
      }
      if (actualPort.isOutput() != (((Boolean)(portInfo[PortTableModel.COL_OUTPUT])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_OUTPUT]=true;
      }
      if (actualPort.isMultiport() != (((Boolean)(portInfo[PortTableModel.COL_MULTIPORT])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_MULTIPORT]=true;
      }
      Attribute _show=(Attribute)(actualPort.getAttribute(""String_Node_Str""));
      if ((_show == null) == (((Boolean)(portInfo[PortTableModel.COL_SHOW_NAME])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_SHOW_NAME]=true;
      }
      Attribute hide=actualPort.getAttribute(""String_Node_Str"");
      if ((hide == null) == (((Boolean)(portInfo[PortTableModel.COL_HIDE])).booleanValue())) {
        havePortUpdate=true;
        updates[PortTableModel.COL_HIDE]=true;
      }
      String _type=null;
      TypeAttribute _typeAttribute=(TypeAttribute)actualPort.getAttribute(""String_Node_Str"");
      if (_typeAttribute != null) {
        _type=_typeAttribute.getExpression();
      }
      if ((_type == null && (!((String)(portInfo[PortTableModel.COL_TYPE])).equals(""String_Node_Str""))) || ((_type != null) && (!((String)(portInfo[PortTableModel.COL_TYPE])).equals(_type)))) {
        havePortUpdate=true;
        updates[PortTableModel.COL_TYPE]=true;
      }
      String _direction=null;
      String direction=(String)(portInfo[PortTableModel.COL_DIRECTION]);
      StringAttribute _cardinal=(StringAttribute)(actualPort.getAttribute(""String_Node_Str""));
      if (_cardinal != null)       _direction=_cardinal.getExpression().toUpperCase();
      if (((_direction == null) && !direction.equals(""String_Node_Str"")) || ((_direction != null) && (!direction.equals(_direction)))) {
        havePortUpdate=true;
        updates[PortTableModel.COL_DIRECTION]=true;
      }
      String _units=null;
      UnitAttribute _unitsAttribute=(UnitAttribute)actualPort.getAttribute(""String_Node_Str"");
      if (_unitsAttribute != null) {
        _units=_unitsAttribute.getExpression();
      }
      if ((_units == null && (!((String)(portInfo[PortTableModel.COL_UNITS])).equals(""String_Node_Str""))) || ((_units != null) && (!((String)(portInfo[PortTableModel.COL_UNITS])).equals(_units)))) {
        havePortUpdate=true;
        updates[PortTableModel.COL_UNITS]=true;
      }
      if (havePortUpdate) {
        NamedObj parent=(NamedObj)actualPort.getContainer();
        moml.append(_createMoMLUpdate(updates,portInfo,(String)(((TypedIOPort)(portInfo[PortTableModel.COL_ACTUAL_PORT])).getName()),(String)(portInfo[PortTableModel.COL_NAME])));
        haveSomeUpdate=true;
      }
    }
 else {
      for (int updateNum=0; updateNum < 7; updateNum++) {
        updates[updateNum]=true;
      }
      updates[PortTableModel.COL_NAME]=false;
      updates[PortTableModel.COL_SHOW_NAME]=((Boolean)(portInfo[PortTableModel.COL_SHOW_NAME])).booleanValue();
      updates[PortTableModel.COL_HIDE]=((Boolean)(portInfo[PortTableModel.COL_HIDE])).booleanValue();
      String _type=(String)(portInfo[PortTableModel.COL_TYPE]);
      if (!_type.equals(""String_Node_Str"")) {
        updates[PortTableModel.COL_TYPE]=true;
        _portTableModel.fireTableDataChanged();
      }
 else {
        updates[PortTableModel.COL_TYPE]=false;
      }
      String direction=(String)(portInfo[PortTableModel.COL_DIRECTION]);
      if (!direction.equals(""String_Node_Str"")) {
        updates[PortTableModel.COL_DIRECTION]=true;
        _portTableModel.fireTableDataChanged();
      }
 else {
        updates[PortTableModel.COL_DIRECTION]=false;
      }
      moml.append(_createMoMLUpdate(updates,portInfo,(String)(portInfo[PortTableModel.COL_NAME]),null));
      haveSomeUpdate=true;
    }
  }
  if (haveSomeUpdate) {
    moml.append(""String_Node_Str"");
    if (_debug)     System.out.println(""String_Node_Str"" + getTarget().toString() + ""String_Node_Str""+ moml);
    MoMLChangeRequest request=new MoMLChangeRequest(this,getTarget(),moml.toString(),null);
    request.setUndoable(true);
    getTarget().requestChange(request);
    _populateActualPorts();
  }
  _setDirty(false);
  _enableApplyButton(false);
}"
75326,"private void _backoffDone(int cnt) throws IllegalActionException {
  Token[] value={new IntToken(BkDone),new IntToken(_cnt)};
  BKDone.send(0,new RecordToken(BackoffDoneMsgFields,value));
  mBkIP=false;
  _state=No_Backoff;
}","private void _backoffDone(int cnt) throws IllegalActionException {
  Token[] value={new IntToken(BkDone),new IntToken(cnt)};
  BKDone.send(0,new RecordToken(BackoffDoneMsgFields,value));
  mBkIP=false;
  _state=No_Backoff;
}"
75327,"private boolean _setNav() throws IllegalActionException {
  double expirationTime=((DoubleToken)_inputMessage.get(""String_Node_Str"")).doubleValue() + ((IntToken)_inputMessage.get(""String_Node_Str"")).intValue() * 1e-6;
  tNavEnd=expirationTime;
  if (expirationTime > _currentTime) {
    _NavTimer=setTimer(NavTimeOut,expirationTime);
    return true;
  }
 else {
    return false;
  }
}","private boolean _setNav() throws IllegalActionException {
  double expirationTime=((DoubleToken)_inputMessage.get(""String_Node_Str"")).doubleValue() + ((IntToken)_inputMessage.get(""String_Node_Str"")).intValue() * 1e-6;
  tNavEnd=expirationTime;
  if (expirationTime > _currentTime) {
    if (_NavTimer != null)     cancelTimer(_NavTimer);
    _NavTimer=setTimer(NavTimeOut,expirationTime);
    return true;
  }
 else {
    return false;
  }
}"
75328,"/** 
 * The main function
 * @exception IllegalActionException If an error occurs readingor writing inputs or outputs.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  _currentTime=director.getCurrentTime();
  int kind=whoTimeout();
  if (kind == -1) {
    if (fromValidateMpdu.hasToken(0)) {
      _inputMessage=(RecordToken)fromValidateMpdu.get(0);
      _messageType=((IntToken)_inputMessage.get(""String_Node_Str"")).intValue();
      if (_messageType == UseDifs || _messageType == UseEifs) {
        if (_messageType == UseDifs) {
          _dIfs=_dDIfs - _aRxTxTurnaroundTime;
        }
 else         if (_messageType == UseEifs) {
          _dIfs=_dEIfs - _aRxTxTurnaroundTime;
        }
        if (_debugging) {
          _debug(""String_Node_Str"" + _inputMessage.toString());
        }
        DoubleToken t=(DoubleToken)_inputMessage.get(""String_Node_Str"");
        double tRxEnd=t.doubleValue();
        _IfsTimer=setTimer(IfsTimeOut,_currentTime + tRxEnd + _dIfs * 1e-6);
      }
    }
 else     if (channelStatus.hasToken(0)) {
      _inputMessage=(RecordToken)channelStatus.get(0);
    }
 else     if (fromFilterMpdu.hasToken(0)) {
      _inputMessage=(RecordToken)fromFilterMpdu.get(0);
    }
    if (_inputMessage != null) {
      _messageType=((IntToken)_inputMessage.get(""String_Node_Str"")).intValue();
    }
  }
switch (_state) {
case Cs_noNav:
switch (_messageType) {
case Idle:
      _IfsTimer=setTimer(IfsTimeOut,_currentTime + _dIfs * 1e-6);
    _state=Wait_Ifs;
  break;
case SetNav:
if (_setNav()) {
  _state=Cs_Nav;
}
break;
}
break;
case Wait_Ifs:
if (kind == IfsTimeOut) {
_changeStatus(Idle);
_state=noCs_noNav;
}
 else {
switch (_messageType) {
case Busy:
_state=Cs_noNav;
break;
case SetNav:
if (_setNav()) {
_state=noCs_Nav;
}
break;
}
}
break;
case noCs_noNav:
switch (_messageType) {
case Busy:
_changeStatus(Busy);
_state=Cs_noNav;
break;
case SetNav:
if (_setNav()) {
_changeStatus(Busy);
_state=noCs_Nav;
}
break;
}
break;
case Cs_Nav:
if (kind == NavTimeOut) {
_state=Cs_noNav;
}
 else {
if (_messageType == Idle) _state=noCs_Nav;
 else _updateNav();
}
break;
case noCs_Nav:
if (kind == NavTimeOut) {
_IfsTimer=setTimer(IfsTimeOut,_currentTime + _dIfs * 1e-6);
_state=Wait_Ifs;
}
 else {
if (_messageType == Busy) _state=Cs_Nav;
 else _updateNav();
}
break;
}
_inputMessage=null;
_messageType=UNKNOWN;
kind=-1;
}","/** 
 * The main function
 * @exception IllegalActionException If an error occurs readingor writing inputs or outputs.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  _currentTime=director.getCurrentTime();
  int kind=whoTimeout();
  if (kind == -1) {
    if (fromValidateMpdu.hasToken(0)) {
      _inputMessage=(RecordToken)fromValidateMpdu.get(0);
      _messageType=((IntToken)_inputMessage.get(""String_Node_Str"")).intValue();
      if (_messageType == UseDifs || _messageType == UseEifs) {
        if (_messageType == UseDifs) {
          _dIfs=_dDIfs - _aRxTxTurnaroundTime;
        }
 else         if (_messageType == UseEifs) {
          _dIfs=_dEIfs - _aRxTxTurnaroundTime;
        }
        if (_debugging) {
          _debug(""String_Node_Str"" + _inputMessage.toString());
        }
        DoubleToken t=(DoubleToken)_inputMessage.get(""String_Node_Str"");
        double tRxEnd=t.doubleValue();
        if (_IfsTimer != null)         cancelTimer(_IfsTimer);
        _IfsTimer=setTimer(IfsTimeOut,_currentTime + tRxEnd + _dIfs * 1e-6);
      }
    }
 else     if (channelStatus.hasToken(0)) {
      _inputMessage=(RecordToken)channelStatus.get(0);
    }
 else     if (fromFilterMpdu.hasToken(0)) {
      _inputMessage=(RecordToken)fromFilterMpdu.get(0);
    }
    if (_inputMessage != null) {
      _messageType=((IntToken)_inputMessage.get(""String_Node_Str"")).intValue();
    }
  }
switch (_state) {
case Cs_noNav:
switch (_messageType) {
case Idle:
      if (_IfsTimer != null)       cancelTimer(_IfsTimer);
    _IfsTimer=setTimer(IfsTimeOut,_currentTime + _dIfs * 1e-6);
  _state=Wait_Ifs;
break;
case SetNav:
if (_setNav()) {
_state=Cs_Nav;
}
break;
}
break;
case Wait_Ifs:
if (kind == IfsTimeOut) {
_changeStatus(Idle);
_state=noCs_noNav;
}
 else {
switch (_messageType) {
case Busy:
_state=Cs_noNav;
break;
case SetNav:
if (_setNav()) {
_state=noCs_Nav;
}
break;
}
}
break;
case noCs_noNav:
switch (_messageType) {
case Busy:
_changeStatus(Busy);
_state=Cs_noNav;
break;
case SetNav:
if (_setNav()) {
_changeStatus(Busy);
_state=noCs_Nav;
}
break;
}
break;
case Cs_Nav:
if (kind == NavTimeOut) {
_state=Cs_noNav;
}
 else {
if (_messageType == Idle) _state=noCs_Nav;
 else _updateNav();
}
break;
case noCs_Nav:
if (kind == NavTimeOut) {
if (_IfsTimer != null) cancelTimer(_IfsTimer);
_IfsTimer=setTimer(IfsTimeOut,_currentTime + _dIfs * 1e-6);
_state=Wait_Ifs;
}
 else {
if (_messageType == Busy) _state=Cs_Nav;
 else _updateNav();
}
break;
}
_inputMessage=null;
_messageType=UNKNOWN;
kind=-1;
}"
75329,"/** 
 * Initialize the private variables.
 * @exception IllegalActionException If thrown by the base class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _dDIfs=_aSifsTime + 2 * _aSlotTime;
  _dEIfs=_aSifsTime + _sAckCtsLng / _mBrate + _aPreambleLength + _aPlcpHeaderLength + _dDIfs;
  _dIfs=_dEIfs;
  _state=0;
  _curSrc=nosrc;
  _inputMessage=null;
  _messageType=UNKNOWN;
  _changeStatus(Busy);
}","/** 
 * Initialize the private variables.
 * @exception IllegalActionException If thrown by the base class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _dDIfs=_aSifsTime + 2 * _aSlotTime;
  _dEIfs=_aSifsTime + _sAckCtsLng / _mBrate + _aPreambleLength + _aPlcpHeaderLength + _dDIfs;
  _dIfs=_dEIfs;
  _state=0;
  _curSrc=nosrc;
  _inputMessage=null;
  _messageType=UNKNOWN;
  _IfsTimer=null;
  _NavTimer=null;
  _changeStatus(Busy);
}"
75330,"/** 
 * Given the elementName, perform any filter operations that are appropriate for the MOMLParser.endElement() method.
 * @param container  The container for this attribute.in this method.
 * @param elementName The element type name.
 * @return the filtered element name, or null ifMoMLParser.endElement() should immediately return.
 */
public String filterEndElement(NamedObj container,String elementName) throws Exception {
  return elementName;
}","/** 
 * Given the elementName, perform any filter operations that are appropriate for the MOMLParser.endElement() method.
 * @param container  The container for this attribute.in this method.
 * @param elementName The element type name.
 * @return the filtered element name, or null ifMoMLParser.endElement() should immediately return.
 */
public String filterEndElement(NamedObj container,String elementName) throws Exception {
  _foundPort=false;
  return elementName;
}"
75331,"/** 
 * If the attributeName is ""class"" and attributeValue names a class that has had its port classes changed between releases, then substitute in the new port classes.
 * @param container  The container for this attribute.in this method.
 * @param attributeName The name of the attribute.
 * @param attributeValue The value of the attribute.
 * @return the value of the attributeValue argument.
 */
public String filterAttributeValue(NamedObj container,String attributeName,String attributeValue){
  if (attributeValue == null) {
    return null;
  }
  if (attributeName.equals(""String_Node_Str"")) {
    _lastNameSeen=attributeValue;
    if (_currentlyProcessingActorWithPortClassChanges && _portMap != null && _portMap.containsKey(attributeValue)) {
      _classMap=(HashMap)_portMap.get(attributeValue);
      _portName=attributeValue;
      _foundPort=true;
    }
  }
  if (attributeName.equals(""String_Node_Str"")) {
    if (_actorsWithPortClassChanges.containsKey(attributeValue)) {
      _currentlyProcessingActorWithPortClassChanges=true;
      _doneProcessingActorWithPortClassChanges=false;
      _portMap=(HashMap)_actorsWithPortClassChanges.get(attributeValue);
    }
 else     if (_foundPort && _lastNameSeen.equals(_portName) && _classMap.containsKey(attributeValue)) {
      String newClass=(String)_classMap.get(attributeValue);
      _currentlyProcessingActorWithPortClassChanges=false;
      _doneProcessingActorWithPortClassChanges=true;
      _foundPort=false;
      MoMLParser.setModified(true);
      return newClass;
    }
  }
  return attributeValue;
}","/** 
 * If the attributeName is ""class"" and attributeValue names a class that has had its port classes changed between releases, then substitute in the new port classes.
 * @param container  The container for this attribute.in this method.
 * @param attributeName The name of the attribute.
 * @param attributeValue The value of the attribute.
 * @return the value of the attributeValue argument.
 */
public String filterAttributeValue(NamedObj container,String attributeName,String attributeValue){
  if (attributeValue == null) {
    return null;
  }
  if (attributeName.equals(""String_Node_Str"")) {
    _lastNameSeen=attributeValue;
    if (_currentlyProcessingActorWithPortClassChanges && _portMap != null && _portMap.containsKey(attributeValue)) {
      _classMap=(HashMap)_portMap.get(attributeValue);
      _portName=attributeValue;
      _foundPort=true;
    }
  }
  if (attributeName.equals(""String_Node_Str"")) {
    if (_actorsWithPortClassChanges.containsKey(attributeValue)) {
      _currentlyProcessingActorWithPortClassChanges=true;
      _portMap=(HashMap)_actorsWithPortClassChanges.get(attributeValue);
    }
 else     if (_foundPort && _lastNameSeen.equals(_portName) && _classMap.containsKey(attributeValue)) {
      String newClass=(String)_classMap.get(attributeValue);
      _currentlyProcessingActorWithPortClassChanges=false;
      _foundPort=false;
      MoMLParser.setModified(true);
      return newClass;
    }
  }
  return attributeValue;
}"
75332,"/** 
 * Given the elementName, perform any filter operations that are appropriate for the MOMLParser.endElement() method.
 * @param container  The container for this attribute.in this method.
 * @param elementName The element type name.
 * @return the filtered element name, or null ifMoMLParser.endElement() should immediately return.
 */
public String filterEndElement(NamedObj container,String elementName) throws Exception {
  return elementName;
}","/** 
 * Given the elementName, perform any filter operations that are appropriate for the MOMLParser.endElement() method.
 * @param container  The container for this attribute.in this method.
 * @param elementName The element type name.
 * @return the filtered element name, or null ifMoMLParser.endElement() should immediately return.
 */
public String filterEndElement(NamedObj container,String elementName) throws Exception {
  _foundChange=false;
  return elementName;
}"
75333,"protected void _processButtonPress(String button){
  if (button.equals(""String_Node_Str"")) {
    _apply();
  }
 else   if (button.equals(""String_Node_Str"")) {
    _apply();
    _cancel();
  }
 else   if (button.equals(""String_Node_Str"")) {
    _portTableModel.addNewPort();
  }
 else   if ((button.length() > 5) && (button.substring(0,6).equals(""String_Node_Str""))) {
    _portTableModel.removePort();
  }
 else {
    super._processButtonPress(button);
  }
}","protected void _processButtonPress(String button){
  if (button.equals(""String_Node_Str"")) {
    _apply();
  }
 else   if (button.equals(""String_Node_Str"")) {
    _apply();
    _cancel();
  }
 else   if (button.equals(""String_Node_Str"")) {
    _portTableModel.addNewPort();
  }
 else   if ((button.length() > 5) && (button.substring(0,6).equals(""String_Node_Str""))) {
    _portTableModel.removePort();
    _setSelectedRow(-1);
  }
 else {
    super._processButtonPress(button);
  }
}"
75334,"/** 
 * Construct a dialog that presents the ports as a table. Each row of the table corresponds to one port. The user modifies the table to specify changes in the ports. When the apply button is pressed the contents of the table is used to update the ports. When Commit is pressed an apply is done before exiting. <p> This dialog is is not modal. In particular, changes can be undone by clicking Edit->Undo, and the help screen can be manipulated while this dialog exists. The dialog is placed relative to the owner.
 * @param tableau The DialogTableau.
 * @param owner The object that, per the user, appears to be generating thedialog.
 * @param target The object whose ports are being configured.
 * @param configuration The configuration to use to open the help screen(or null if help is not supported).
 */
public PortConfigurerDialog(DialogTableau tableau,Frame owner,Entity target,Configuration configuration){
  super(""String_Node_Str"" + target.getName(),tableau,owner,target,configuration);
  getTarget().addChangeListener(this);
  _portLocationComboBox=new JComboBox();
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portTable=new JTable();
  _portTable.setPreferredScrollableViewportSize(new Dimension(600,70));
  ListSelectionModel rowSM=_portTable.getSelectionModel();
  rowSM.addListSelectionListener(_rowSelectionListener);
  _setupTableModel();
  _initColumnSizes();
  setScrollableContents(_portTable);
  _jth=_portTable.getTableHeader();
  _jth.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent me){
      Rectangle headerShowNameRect=_jth.getHeaderRect(PortTableModel.COL_SHOW_NAME);
      Rectangle headerHidePortRect=_jth.getHeaderRect(PortTableModel.COL_HIDE);
      if (headerShowNameRect.contains(me.getPoint())) {
        _portTableModel.toggleShowAllNames();
      }
      if (headerHidePortRect.contains(me.getPoint())) {
        _portTableModel.toggleHidePorts();
      }
    }
  }
);
  pack();
  setVisible(true);
}","/** 
 * Construct a dialog that presents the ports as a table. Each row of the table corresponds to one port. The user modifies the table to specify changes in the ports. When the apply button is pressed the contents of the table is used to update the ports. When Commit is pressed an apply is done before exiting. <p> This dialog is is not modal. In particular, changes can be undone by clicking Edit->Undo, and the help screen can be manipulated while this dialog exists. The dialog is placed relative to the owner.
 * @param tableau The DialogTableau.
 * @param owner The object that, per the user, appears to be generating thedialog.
 * @param target The object whose ports are being configured.
 * @param configuration The configuration to use to open the help screen(or null if help is not supported).
 */
public PortConfigurerDialog(DialogTableau tableau,Frame owner,Entity target,Configuration configuration){
  super(""String_Node_Str"" + target.getName(),tableau,owner,target,configuration);
  getTarget().addChangeListener(this);
  _portLocationComboBox=new JComboBox();
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portLocationComboBox.addItem(""String_Node_Str"");
  _portTable=new JTable();
  _portTable.setPreferredScrollableViewportSize(new Dimension(600,70));
  ListSelectionModel rowSM=_portTable.getSelectionModel();
  rowSM.addListSelectionListener(_rowSelectionListener);
  _portTable.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent me){
      if (me.getButton() == MouseEvent.BUTTON3) {
        Point point=me.getPoint();
        int row=_portTable.rowAtPoint(point);
        _setSelectedRow(row);
      }
    }
  }
);
  _setupTableModel();
  _initColumnSizes();
  setScrollableContents(_portTable);
  _jth=_portTable.getTableHeader();
  _jth.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent me){
      Rectangle headerShowNameRect=_jth.getHeaderRect(PortTableModel.COL_SHOW_NAME);
      Rectangle headerHidePortRect=_jth.getHeaderRect(PortTableModel.COL_HIDE);
      if (headerShowNameRect.contains(me.getPoint())) {
        _portTableModel.toggleShowAllNames();
      }
      if (headerHidePortRect.contains(me.getPoint())) {
        _portTableModel.toggleHidePorts();
      }
    }
  }
);
  pack();
  setVisible(true);
}"
75335,"/** 
 * Removes a port.
 */
public void removePort(){
  _ports.remove(_selectedRow);
  fireTableRowsDeleted(_selectedRow,_selectedRow);
}","/** 
 * Removes a port.
 */
public void removePort(){
  _ports.remove(_selectedRow);
  fireTableRowsDeleted(_selectedRow,_selectedRow);
  _enableApplyButton(true);
  _setDirty(true);
}"
75336,"public void valueChanged(ListSelectionEvent e){
  if (e.getValueIsAdjusting())   return;
  ListSelectionModel lsm=(ListSelectionModel)e.getSource();
  if (lsm.isSelectionEmpty()) {
    _removeButton.setText(""String_Node_Str"");
    _removeButton.setEnabled(false);
    _selectedRow=-1;
  }
 else {
    _selectedRow=lsm.getMinSelectionIndex();
    String portName=((String)((Object[])(_ports.elementAt(_selectedRow)))[0]);
    if (portName.length() < 10) {
      portName+=""String_Node_Str"";
      portName=portName.substring(0,9);
    }
 else     if (portName.length() > 10) {
      portName=portName.substring(0,7) + ""String_Node_Str"";
    }
    _removeButton.setText(""String_Node_Str"" + portName);
    _removeButton.setEnabled(true);
  }
}","public void valueChanged(ListSelectionEvent e){
  if (e.getValueIsAdjusting())   return;
  ListSelectionModel lsm=(ListSelectionModel)e.getSource();
  if (lsm.isSelectionEmpty()) {
    _setSelectedRow(-1);
  }
 else {
    _selectedRow=lsm.getMinSelectionIndex();
    _setSelectedRow(_selectedRow);
  }
}"
75337,"public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int col){
  setOpaque(true);
  setText((String)value);
  if (!table.isCellEditable(row,col))   setBackground(_CLASS_ELEMENT_HIGHLIGHT_COLOR);
 else   setBackground(Color.white);
  return this;
}","public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int col){
  setOpaque(true);
  setText((String)value);
  if (!table.isCellEditable(row,col))   setBackground(LocatableNodeController.CLASS_ELEMENT_HIGHLIGHT_COLOR);
 else   setBackground(Color.white);
  return this;
}"
75338,"/** 
 * Override the base class so that tableaux contained by this object are removed before this effigy is removed from the ModelDirectory. This causes the frames associated with those tableaux to be closed.
 * @param container The directory in which to list this effigy.
 * @exception IllegalActionException If the proposed container is notan instance of ModelDirectory, or if the superclass throws it.
 * @exception NameDuplicationException If the container already hasan entity with the specified name.
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  if (container == null) {
    Iterator tableaux=entityList(Tableau.class).iterator();
    while (tableaux.hasNext()) {
      ComponentEntity tableau=(ComponentEntity)tableaux.next();
      tableau.setContainer(null);
    }
    Iterator effigies=entityList(Effigy.class).iterator();
    while (effigies.hasNext()) {
      ComponentEntity effigy=(ComponentEntity)effigies.next();
      effigy.setContainer(null);
    }
  }
  super.setContainer(container);
}","/** 
 * Override the base class so that tableaux contained by this object are removed before this effigy is removed from the ModelDirectory. This causes the frames associated with those tableaux to be closed.  Also, if the argument is null and there is a URI associated with this model, then purge any record of the model that the MoMLParser class is keeping so that future efforts to open the model result in re-parsing.
 * @param container The directory in which to list this effigy.
 * @exception IllegalActionException If the proposed container is notan instance of ModelDirectory, or if the superclass throws it.
 * @exception NameDuplicationException If the container already hasan entity with the specified name.
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  if (container == null) {
    Iterator tableaux=entityList(Tableau.class).iterator();
    while (tableaux.hasNext()) {
      ComponentEntity tableau=(ComponentEntity)tableaux.next();
      tableau.setContainer(null);
    }
    Iterator effigies=entityList(Effigy.class).iterator();
    while (effigies.hasNext()) {
      ComponentEntity effigy=(ComponentEntity)effigies.next();
      effigy.setContainer(null);
    }
    if (uri != null) {
      try {
        URL url=uri.getURL();
        MoMLParser.purgeModelRecord(url);
      }
 catch (      MalformedURLException e) {
      }
    }
  }
  super.setContainer(container);
}"
75339,"/** 
 * Parse a command-line argument.
 * @return True if the argument is understood, false otherwise.
 * @exception Exception If something goes wrong.
 */
protected boolean _parseArg(String arg) throws Exception {
  if (arg.equals(""String_Node_Str"")) {
    _expectingClass=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(_usage());
    System.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _test=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + VersionAttribute.CURRENT_VERSION + ""String_Node_Str"");
    System.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
  }
 else {
    if (_expectingClass) {
      _expectingClass=false;
      Class newClass=Class.forName(arg);
      Workspace workspace=new Workspace();
      Class[] argTypes=new Class[1];
      argTypes[0]=workspace.getClass();
      Constructor constructor=newClass.getConstructor(argTypes);
      Object args[]=new Object[1];
      args[0]=workspace;
      NamedObj newModel=(NamedObj)constructor.newInstance(args);
      if (_config != null) {
        PtolemyEffigy effigy=new PtolemyEffigy(_config.workspace());
        effigy.setModel(newModel);
        ModelDirectory directory=(ModelDirectory)_config.getEntity(""String_Node_Str"");
        effigy.setName(arg);
        if (directory != null) {
          if (directory.getEntity(arg) != null) {
            int count=2;
            String newName=arg + ""String_Node_Str"" + count;
            while (directory.getEntity(newName) != null) {
              count++;
            }
            effigy.setName(newName);
          }
        }
        effigy.setContainer(directory);
      }
    }
 else {
      if (!arg.startsWith(""String_Node_Str"")) {
        URL inURL=specToURL(arg);
        URL base=inURL;
        if (_config != null) {
          ModelDirectory directory=(ModelDirectory)_config.getEntity(""String_Node_Str"");
          if (directory == null) {
            throw new InternalErrorException(""String_Node_Str"");
          }
          String key=inURL.toExternalForm();
          _config.openModel(base,inURL,key);
        }
 else {
          _parser.reset();
          try {
            NamedObj toplevel=_parser.parse(base,inURL.openStream());
            if (toplevel instanceof Configuration) {
              _config=(Configuration)toplevel;
            }
          }
 catch (          Exception ex) {
            String detailMessage=""String_Node_Str"";
            try {
              if (inURL.toString().indexOf(""String_Node_Str"") != -1 && inURL.toString().indexOf(""String_Node_Str"") != -1) {
                detailMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
              }
            }
 catch (            Exception ex2) {
            }
            throw new Exception(""String_Node_Str"" + inURL + ""String_Node_Str""+ detailMessage,ex);
          }
        }
      }
 else {
        return false;
      }
    }
  }
  return true;
}","/** 
 * Parse a command-line argument.
 * @return True if the argument is understood, false otherwise.
 * @exception Exception If something goes wrong.
 */
protected boolean _parseArg(String arg) throws Exception {
  if (arg.equals(""String_Node_Str"")) {
    _expectingClass=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(_usage());
    System.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _test=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + VersionAttribute.CURRENT_VERSION + ""String_Node_Str"");
    System.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
  }
 else {
    if (_expectingClass) {
      _expectingClass=false;
      Class newClass=Class.forName(arg);
      Workspace workspace=new Workspace();
      Class[] argTypes=new Class[1];
      argTypes[0]=workspace.getClass();
      Constructor constructor=newClass.getConstructor(argTypes);
      Object args[]=new Object[1];
      args[0]=workspace;
      NamedObj newModel=(NamedObj)constructor.newInstance(args);
      if (_config != null) {
        PtolemyEffigy effigy=new PtolemyEffigy(_config.workspace());
        effigy.setModel(newModel);
        ModelDirectory directory=(ModelDirectory)_config.getEntity(""String_Node_Str"");
        effigy.setName(arg);
        if (directory != null) {
          if (directory.getEntity(arg) != null) {
            int count=2;
            String newName=arg + ""String_Node_Str"" + count;
            while (directory.getEntity(newName) != null) {
              count++;
            }
            effigy.setName(newName);
          }
        }
        effigy.setContainer(directory);
      }
    }
 else {
      if (!arg.startsWith(""String_Node_Str"")) {
        URL inURL=specToURL(arg);
        URL base=inURL;
        if (_config != null) {
          ModelDirectory directory=(ModelDirectory)_config.getEntity(""String_Node_Str"");
          if (directory == null) {
            throw new InternalErrorException(""String_Node_Str"");
          }
          String key=inURL.toExternalForm();
          _config.openModel(base,inURL,key);
        }
 else {
          _parser.reset();
          try {
            NamedObj toplevel=_parser.parse(base,inURL);
            if (toplevel instanceof Configuration) {
              _config=(Configuration)toplevel;
            }
          }
 catch (          Exception ex) {
            String detailMessage=""String_Node_Str"";
            try {
              if (inURL.toString().indexOf(""String_Node_Str"") != -1 && inURL.toString().indexOf(""String_Node_Str"") != -1) {
                detailMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
              }
            }
 catch (            Exception ex2) {
            }
            throw new Exception(""String_Node_Str"" + inURL + ""String_Node_Str""+ detailMessage,ex);
          }
        }
      }
 else {
        return false;
      }
    }
  }
  return true;
}"
75340,"/** 
 * Read a Configuration from the URL given by the specified string. The URL may absolute, or relative to the Ptolemy II tree root, or in the classpath.  To convert a String to a URL suitable for use by this method, call specToURL(String).
 * @param specificationURL A string describing a URL.
 * @return A configuration.
 * @exception Exception If the configuration cannot be opened, orif the contents of the URL is not a configuration.
 */
protected Configuration _readConfiguration(URL specificationURL) throws Exception {
  _parser.reset();
  Configuration toplevel=(Configuration)_parser.parse(specificationURL,specificationURL.openStream());
  ComponentEntity directory=((Configuration)toplevel).getEntity(""String_Node_Str"");
  if (directory instanceof ModelDirectory) {
    PtolemyEffigy effigy=new PtolemyEffigy((ModelDirectory)directory,toplevel.getName());
    effigy.setModel(toplevel);
    effigy.identifier.setExpression(specificationURL.toExternalForm());
  }
  return toplevel;
}","/** 
 * Read a Configuration from the URL given by the specified string. The URL may absolute, or relative to the Ptolemy II tree root, or in the classpath.  To convert a String to a URL suitable for use by this method, call specToURL(String).
 * @param specificationURL A string describing a URL.
 * @return A configuration.
 * @exception Exception If the configuration cannot be opened, orif the contents of the URL is not a configuration.
 */
protected Configuration _readConfiguration(URL specificationURL) throws Exception {
  _parser.reset();
  Configuration toplevel=(Configuration)_parser.parse(specificationURL,specificationURL);
  ComponentEntity directory=((Configuration)toplevel).getEntity(""String_Node_Str"");
  if (directory instanceof ModelDirectory) {
    PtolemyEffigy effigy=new PtolemyEffigy((ModelDirectory)directory,toplevel.getName());
    effigy.setModel(toplevel);
    effigy.identifier.setExpression(specificationURL.toExternalForm());
  }
  return toplevel;
}"
75341,"/** 
 * Parse a command-line argument.
 * @return True if the argument is understood, false otherwise.
 * @exception Exception If something goes wrong.
 */
protected boolean _parseArg(String arg) throws Exception {
  if (arg.equals(""String_Node_Str"")) {
    _expectingClass=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(_usage());
    System.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _test=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + VersionAttribute.CURRENT_VERSION + ""String_Node_Str"");
    System.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
  }
 else {
    if (_expectingClass) {
      _expectingClass=false;
      Class newClass=Class.forName(arg);
      Workspace workspace=new Workspace();
      Class[] argTypes=new Class[1];
      argTypes[0]=workspace.getClass();
      Constructor constructor=newClass.getConstructor(argTypes);
      Object args[]=new Object[1];
      args[0]=workspace;
      constructor.newInstance(args);
    }
 else {
      if (!arg.startsWith(""String_Node_Str"")) {
        URL inURL=MoMLApplication.specToURL(arg);
        URL base=inURL;
        _parser.reset();
        _toplevel=(CompositeActor)_parser.parse(base,inURL.openStream());
      }
 else {
        return false;
      }
    }
  }
  return true;
}","/** 
 * Parse a command-line argument.
 * @return True if the argument is understood, false otherwise.
 * @exception Exception If something goes wrong.
 */
protected boolean _parseArg(String arg) throws Exception {
  if (arg.equals(""String_Node_Str"")) {
    _expectingClass=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(_usage());
    System.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    _test=true;
  }
 else   if (arg.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + VersionAttribute.CURRENT_VERSION + ""String_Node_Str"");
    System.exit(0);
  }
 else   if (arg.equals(""String_Node_Str"")) {
  }
 else {
    if (_expectingClass) {
      _expectingClass=false;
      Class newClass=Class.forName(arg);
      Workspace workspace=new Workspace();
      Class[] argTypes=new Class[1];
      argTypes[0]=workspace.getClass();
      Constructor constructor=newClass.getConstructor(argTypes);
      Object args[]=new Object[1];
      args[0]=workspace;
      constructor.newInstance(args);
    }
 else {
      if (!arg.startsWith(""String_Node_Str"")) {
        URL inURL=MoMLApplication.specToURL(arg);
        URL base=inURL;
        _parser.reset();
        _toplevel=(CompositeActor)_parser.parse(base,inURL);
      }
 else {
        return false;
      }
    }
  }
  return true;
}"
75342,"/** 
 * Return a default Configuration, which in this case is given by the MoML file ptolemy/configuration/runPanelConfiguration.xml. That configuration supports executing, but not editing, Ptolemy models.
 * @return A default configuration.
 * @exception Exception If the configuration cannot be opened.
 */
protected Configuration _createDefaultConfiguration() throws Exception {
  if (_configurationURL == null) {
    _configurationURL=specToURL(""String_Node_Str"");
  }
  MoMLParser parser=new MoMLParser();
  _configuration=(Configuration)parser.parse(_configurationURL,_configurationURL.openStream());
  return _configuration;
}","/** 
 * Return a default Configuration, which in this case is given by the MoML file ptolemy/configuration/runPanelConfiguration.xml. That configuration supports executing, but not editing, Ptolemy models.
 * @return A default configuration.
 * @exception Exception If the configuration cannot be opened.
 */
protected Configuration _createDefaultConfiguration() throws Exception {
  if (_configurationURL == null) {
    _configurationURL=specToURL(""String_Node_Str"");
  }
  MoMLParser parser=new MoMLParser();
  _configuration=(Configuration)parser.parse(_configurationURL,_configurationURL);
  return _configuration;
}"
75343,"/** 
 * Return a default Configuration to use when there are no command-line arguments, which in this case is the same as the default configuration given by _createDefaultConfiguration, but with the additional contents of the file ptolemy/configs/runWelcomeWindow.xml.
 * @return A configuration for when there no command-line arguments.
 * @exception Exception If the configuration cannot be opened.
 */
protected Configuration _createEmptyConfiguration() throws Exception {
  Configuration configuration=_createDefaultConfiguration();
  URL inURL=specToURL(""String_Node_Str"");
  _parser.reset();
  _parser.setContext(configuration);
  _parser.parse(inURL,inURL.openStream());
  Effigy doc=(Effigy)configuration.getEntity(""String_Node_Str"");
  URL idURL=specToURL(""String_Node_Str"");
  doc.identifier.setExpression(idURL.toExternalForm());
  return configuration;
}","/** 
 * Return a default Configuration to use when there are no command-line arguments, which in this case is the same as the default configuration given by _createDefaultConfiguration, but with the additional contents of the file ptolemy/configs/runWelcomeWindow.xml.
 * @return A configuration for when there no command-line arguments.
 * @exception Exception If the configuration cannot be opened.
 */
protected Configuration _createEmptyConfiguration() throws Exception {
  Configuration configuration=_createDefaultConfiguration();
  URL inURL=specToURL(""String_Node_Str"");
  _parser.reset();
  _parser.setContext(configuration);
  _parser.parse(inURL,inURL);
  Effigy doc=(Effigy)configuration.getEntity(""String_Node_Str"");
  URL idURL=specToURL(""String_Node_Str"");
  doc.identifier.setExpression(idURL.toExternalForm());
  return configuration;
}"
75344,"/** 
 * Create a new effigy in the given container by reading the <i>input</i> URL. If the <i>input</i> URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param input The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL input) throws Exception {
  if (input == null) {
    PtolemyEffigy effigy=_newEffigy(container,container.uniqueName(""String_Node_Str""));
    NamedObj entity=getEntity(""String_Node_Str"");
    NamedObj newModel;
    if (entity != null) {
      newModel=(NamedObj)entity.clone(new Workspace());
    }
 else {
      newModel=new TypedCompositeActor(new Workspace());
    }
    ParserAttribute.getParser(newModel);
    newModel.setName(""String_Node_Str"");
    effigy.setModel(newModel);
    return effigy;
  }
 else {
    String extension=getExtension(input);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      if (extension.equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + input + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ input);
      }
      return null;
    }
    PtolemyEffigy effigy=_newEffigy(container,container.uniqueName(""String_Node_Str""));
    MoMLParser parser=new MoMLParser();
    parser.reset();
    NamedObj toplevel=null;
    try {
      try {
        try {
          toplevel=parser.parse(base,input);
        }
 catch (        IOException io) {
          URL anotherURL=JNLPUtilities.jarURLEntryResource(input.toString());
          if (anotherURL != null) {
            toplevel=parser.parse(base,anotherURL.openStream());
          }
 else {
            throw io;
          }
        }
        if (toplevel != null) {
          effigy.setModel(toplevel);
          effigy.setModified(MoMLParser.isModified());
          MoMLParser.setModified(false);
          URIAttribute uriAttribute=new URIAttribute(toplevel,""String_Node_Str"");
          URI inputURI=null;
          try {
            inputURI=new URI(input.toExternalForm());
          }
 catch (          java.net.URISyntaxException ex) {
            String inputExternalFormFixed=StringUtilities.substitute(input.toExternalForm(),""String_Node_Str"",""String_Node_Str"");
            try {
              inputURI=new URI(inputExternalFormFixed);
            }
 catch (            Exception ex2) {
              throw new Exception(""String_Node_Str"" + ""String_Node_Str"" + input.toExternalForm() + ""String_Node_Str""+ inputExternalFormFixed+ ""String_Node_Str"",ex);
            }
          }
          uriAttribute.setURI(inputURI);
          effigy.uri.setURI(inputURI);
          return effigy;
        }
 else {
          effigy.setContainer(null);
        }
      }
 catch (      Throwable throwable) {
        if (throwable instanceof StackOverflowError) {
          Throwable newThrowable=new StackOverflowError(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          newThrowable.initCause(throwable);
          throwable=newThrowable;
        }
        throwable.printStackTrace();
        ModelDirectory dir=(ModelDirectory)effigy.topEffigy().getContainer();
        List effigies=dir.entityList(Effigy.class);
        if (effigies.size() <= 3) {
          String errorMessage=""String_Node_Str"" + input;
          System.err.println(errorMessage);
          throwable.printStackTrace();
          MessageHandler.error(errorMessage,throwable);
        }
 else {
          if (throwable instanceof Exception) {
            throw (Exception)throwable;
          }
 else {
            throw new Exception(throwable);
          }
        }
      }
    }
  finally {
      if (toplevel == null) {
        effigy.setContainer(null);
      }
    }
    return null;
  }
}","/** 
 * Create a new effigy in the given container by reading the <i>input</i> URL. If the <i>input</i> URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param input The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL input) throws Exception {
  if (input == null) {
    PtolemyEffigy effigy=_newEffigy(container,container.uniqueName(""String_Node_Str""));
    NamedObj entity=getEntity(""String_Node_Str"");
    NamedObj newModel;
    if (entity != null) {
      newModel=(NamedObj)entity.clone(new Workspace());
    }
 else {
      newModel=new TypedCompositeActor(new Workspace());
    }
    ParserAttribute.getParser(newModel);
    newModel.setName(""String_Node_Str"");
    effigy.setModel(newModel);
    return effigy;
  }
 else {
    String extension=getExtension(input);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      if (extension.equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + input + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ input);
      }
      return null;
    }
    PtolemyEffigy effigy=_newEffigy(container,container.uniqueName(""String_Node_Str""));
    MoMLParser parser=new MoMLParser();
    parser.reset();
    NamedObj toplevel=null;
    try {
      try {
        try {
          toplevel=parser.parse(base,input);
        }
 catch (        IOException io) {
          URL anotherURL=JNLPUtilities.jarURLEntryResource(input.toString());
          if (anotherURL != null) {
            toplevel=parser.parse(base,anotherURL);
          }
 else {
            throw io;
          }
        }
        if (toplevel != null) {
          effigy.setModel(toplevel);
          effigy.setModified(MoMLParser.isModified());
          MoMLParser.setModified(false);
          URIAttribute uriAttribute=new URIAttribute(toplevel,""String_Node_Str"");
          URI inputURI=null;
          try {
            inputURI=new URI(input.toExternalForm());
          }
 catch (          java.net.URISyntaxException ex) {
            String inputExternalFormFixed=StringUtilities.substitute(input.toExternalForm(),""String_Node_Str"",""String_Node_Str"");
            try {
              inputURI=new URI(inputExternalFormFixed);
            }
 catch (            Exception ex2) {
              throw new Exception(""String_Node_Str"" + ""String_Node_Str"" + input.toExternalForm() + ""String_Node_Str""+ inputExternalFormFixed+ ""String_Node_Str"",ex);
            }
          }
          uriAttribute.setURI(inputURI);
          effigy.uri.setURI(inputURI);
          return effigy;
        }
 else {
          effigy.setContainer(null);
        }
      }
 catch (      Throwable throwable) {
        if (throwable instanceof StackOverflowError) {
          Throwable newThrowable=new StackOverflowError(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          newThrowable.initCause(throwable);
          throwable=newThrowable;
        }
        throwable.printStackTrace();
        ModelDirectory dir=(ModelDirectory)effigy.topEffigy().getContainer();
        List effigies=dir.entityList(Effigy.class);
        if (effigies.size() <= 3) {
          String errorMessage=""String_Node_Str"" + input;
          System.err.println(errorMessage);
          throwable.printStackTrace();
          MessageHandler.error(errorMessage,throwable);
        }
 else {
          if (throwable instanceof Exception) {
            throw (Exception)throwable;
          }
 else {
            throw new Exception(throwable);
          }
        }
      }
    }
  finally {
      if (toplevel == null) {
        effigy.setContainer(null);
      }
    }
    return null;
  }
}"
75345,"/** 
 * Query the user for a filename, save the model to that file, and open a new window to view the model. This overrides the base class to update the entry in the ModelDirectory and to rename the model to match the file name.
 * @return True if the save succeeds.
 */
protected boolean _saveAs(){
  if (_tableau == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
  JFileChooser fileDialog=new JFileChooser();
  if (_fileFilter != null) {
    fileDialog.addChoosableFileFilter(_fileFilter);
  }
  fileDialog.setDialogTitle(""String_Node_Str"");
  if (_directory != null) {
    fileDialog.setCurrentDirectory(_directory);
  }
 else {
    String currentWorkingDirectory=StringUtilities.getProperty(""String_Node_Str"");
    if (currentWorkingDirectory != null) {
      fileDialog.setCurrentDirectory(new File(currentWorkingDirectory));
    }
  }
  if (_initialSaveAsFileName != null) {
    fileDialog.setSelectedFile(new File(fileDialog.getCurrentDirectory(),_initialSaveAsFileName));
  }
  int returnVal=fileDialog.showSaveDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    File file=fileDialog.getSelectedFile();
    try {
      URL newURL=file.toURL();
      String newKey=newURL.toExternalForm();
      Effigy previousOpen=getDirectory().getEffigy(newKey);
      if (previousOpen != null && previousOpen != getEffigy()) {
        if (previousOpen.isModified()) {
          previousOpen.showTableaux();
          String confirm=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
          int selected=JOptionPane.showOptionDialog(this,confirm,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
          if (selected == 1) {
            return false;
          }
          previousOpen.setModified(false);
        }
        previousOpen.closeTableaux();
      }
      if (file.exists()) {
        String query=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
        int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
        if (selected == 1) {
          return false;
        }
      }
      _directory=fileDialog.getCurrentDirectory();
      _writeFile(file);
      getConfiguration().openModel(newURL,newURL,newKey);
      Effigy effigy=getEffigy();
      if (effigy != null) {
        String id=effigy.identifier.getExpression();
        if (id.equals(""String_Node_Str"")) {
          effigy.setContainer(null);
        }
      }
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
      return false;
    }
  }
  return true;
}","/** 
 * Query the user for a filename, save the model to that file, and open a new window to view the model. This overrides the base class to update the entry in the ModelDirectory and to rename the model to match the file name.
 * @return True if the save succeeds.
 */
protected boolean _saveAs(){
  if (_tableau == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
  JFileChooser fileDialog=new JFileChooser();
  if (_fileFilter != null) {
    fileDialog.addChoosableFileFilter(_fileFilter);
  }
  fileDialog.setDialogTitle(""String_Node_Str"");
  if (_directory != null) {
    fileDialog.setCurrentDirectory(_directory);
  }
 else {
    String currentWorkingDirectory=StringUtilities.getProperty(""String_Node_Str"");
    if (currentWorkingDirectory != null) {
      fileDialog.setCurrentDirectory(new File(currentWorkingDirectory));
    }
  }
  if (_initialSaveAsFileName != null) {
    fileDialog.setSelectedFile(new File(fileDialog.getCurrentDirectory(),_initialSaveAsFileName));
  }
  int returnVal=fileDialog.showSaveDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    File file=fileDialog.getSelectedFile();
    try {
      URL newURL=file.toURL();
      String newKey=newURL.toExternalForm();
      Effigy previousOpen=getDirectory().getEffigy(newKey);
      if (previousOpen != null && previousOpen != getEffigy()) {
        if (previousOpen.isModified()) {
          previousOpen.showTableaux();
          String confirm=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
          int selected=JOptionPane.showOptionDialog(this,confirm,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
          if (selected == 1) {
            return false;
          }
          if (!_checkForDerivedObjects()) {
            return false;
          }
          previousOpen.setModified(false);
        }
        previousOpen.closeTableaux();
      }
      if (file.exists()) {
        String query=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
        int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
        if (selected == 1) {
          return false;
        }
      }
      _directory=fileDialog.getCurrentDirectory();
      _writeFile(file);
      getConfiguration().openModel(newURL,newURL,newKey);
      Effigy effigy=getEffigy();
      if (effigy != null) {
        String id=effigy.identifier.getExpression();
        if (id.equals(""String_Node_Str"")) {
          effigy.setContainer(null);
        }
      }
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
      return false;
    }
  }
  return true;
}"
75346,"/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, and there are no other tableaux in the parent effigy or any effigy that contains it, then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (getEffigy() == null) {
    return super._close();
  }
  Effigy topEffigy=getEffigy().topEffigy();
  if (!_tableau.isMaster()) {
    List tableaux=topEffigy.entityList(Tableau.class);
    Iterator tableauxIterator=tableaux.iterator();
    while (tableauxIterator.hasNext()) {
      Tableau tableau=(Tableau)tableauxIterator.next();
      if (!(tableau instanceof DialogTableau) && (tableau != _tableau)) {
        dispose();
        return true;
      }
    }
  }
  return super._close();
}","/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, and there are no other tableaux in the parent effigy or any effigy that contains it, then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (getEffigy() == null) {
    return super._close();
  }
  Effigy topEffigy=getEffigy().topEffigy();
  if (!_tableau.isMaster()) {
    List tableaux=topEffigy.entityList(Tableau.class);
    Iterator tableauxIterator=tableaux.iterator();
    while (tableauxIterator.hasNext()) {
      Tableau tableau=(Tableau)tableauxIterator.next();
      if (!(tableau instanceof DialogTableau) && (tableau != _tableau)) {
        dispose();
        return true;
      }
    }
  }
  if (isModified()) {
    int reply=_queryForSave();
    if (reply == _DISCARDED || reply == _FAILED) {
      if (!_checkForDerivedObjects()) {
        return false;
      }
      dispose();
      return true;
    }
    return false;
  }
 else {
    dispose();
    return true;
  }
}"
75347,"/** 
 * Clear the current contents.  This base class checks to see whether the contents have been modified, and if so, then prompts the user to save them.  Derived classes should override this method to first call this parent class method, then clear the data, unless the return value is false.  A return value of false indicates that the user has canceled the action.
 * @return False if the user cancels the clear.
 */
protected boolean _clear(){
  return _queryForSave();
}","/** 
 * Clear the current contents.  This base class checks to see whether the contents have been modified, and if so, then prompts the user to save them.  Derived classes should override this method to first call this parent class method, then clear the data, unless the return value is false.  A return value of false indicates that the user has canceled the action.
 * @return True if the current contents are either saved or discardedwith permission from the user.
 */
protected boolean _clear(){
  int result=_queryForSave();
  return (result == _SAVED || result == _DISCARDED);
}"
75348,"/** 
 * Exit the application after querying the user to save data. Derived classes should override this to do something more reasonable, so that user data is not discarded.
 */
protected void _exit(){
  if (isModified()) {
    if (_queryForSave()) {
      System.exit(0);
    }
  }
 else {
    System.exit(0);
  }
}","/** 
 * Exit the application after querying the user to save data. Derived classes should override this to do something more reasonable, so that user data is not discarded.
 */
protected void _exit(){
  if (isModified()) {
    int result=_queryForSave();
    if (result == _SAVED || result == _DISCARDED) {
      System.exit(0);
    }
  }
 else {
    System.exit(0);
  }
}"
75349,"private boolean _queryForSave(){
  Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String query=""String_Node_Str"" + StringUtilities.split(_getName()) + ""String_Node_Str"";
  int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[0]);
  if (selected == 0) {
    return _save();
  }
 else   if (selected == 1) {
    return true;
  }
  return false;
}","/** 
 * Open a dialog to prompt the user to save the data. Return false if the user clicks ""cancel"", and otherwise return true. If the user clicks ""Save"", this also saves the data.
 * @return _SAVED if the file is saved, _DISCARDED if the modifications arediscarded, _CANCELED if the operation is canceled by the user, and _FAILED if the user selects save and the save fails.
 */
protected int _queryForSave(){
  Object[] options={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String query=""String_Node_Str"" + StringUtilities.split(_getName()) + ""String_Node_Str"";
  int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[0]);
  if (selected == 0) {
    if (_save()) {
      return _SAVED;
    }
 else {
      return _FAILED;
    }
  }
  if (selected == 1) {
    return _DISCARDED;
  }
  return _CANCELED;
}"
75350,"/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, as indicated by isModified(), then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (isModified()) {
    if (_queryForSave()) {
      dispose();
      return true;
    }
    return false;
  }
 else {
    dispose();
    return true;
  }
}","/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, as indicated by isModified(), then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (isModified()) {
    int result=_queryForSave();
    if (result == _SAVED || result == _DISCARDED) {
      dispose();
      return true;
    }
    return false;
  }
 else {
    dispose();
    return true;
  }
}"
75351,"/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_skipElement <= 0) {
      if (_configureNesting > 0 || _docNesting > 0) {
        if (elementName.equals(""String_Node_Str"")) {
          _configureNesting++;
        }
 else         if (elementName.equals(""String_Node_Str"")) {
          _docNesting++;
        }
        _currentCharData.append(_getCurrentElement(elementName));
        _attributes.clear();
        _attributeNameList.clear();
        return;
      }
    }
    if (_skipRendition) {
      return;
    }
    boolean undoEnabled=_undoEnabled && _isUndoableElement(elementName);
    if (undoEnabled) {
      boolean childNodesUndoable=true;
      if (_undoContext != null) {
        _undoContexts.push(_undoContext);
        childNodesUndoable=_undoContext.hasUndoableChildren();
      }
      _undoContext=new UndoContext(childNodesUndoable);
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName);
      }
    }
    if (_skipElement > 0) {
      if (elementName.equals(_skipElementName)) {
        if (_skipElementIsNew) {
          _skipElementIsNew=false;
        }
 else {
          _skipElement++;
        }
      }
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      Entity entity=_searchForEntity(entityName,_current);
      boolean existedAlready=(entity != null);
      if (!existedAlready) {
        NamedObj candidate=_createEntity(className,entityName,source);
        if (candidate instanceof Entity) {
          entity=(Entity)candidate;
        }
 else {
          throw new IllegalActionException(_current,""String_Node_Str"" + entityName + ""String_Node_Str""+ ""String_Node_Str""+ className);
        }
      }
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=entity.toplevel();
        _toplevel.setDeferringChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      boolean converted=false;
      if (!existedAlready) {
        entity.setClassDefinition(true);
        entity.setClassName(className);
      }
 else {
        if (!entity.isClassDefinition()) {
          entity.setClassDefinition(true);
          converted=true;
        }
      }
      _current=entity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (!converted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName,entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedPort;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedProp;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(deletedProp.exportMoML());
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedRelation;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      _pushContext();
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      Entity entity=_searchForEntity(entityName,_current);
      boolean existedAlready=(entity != null);
      boolean converted=false;
      if (existedAlready) {
        if (entity.isClassDefinition()) {
          entity.setClassDefinition(false);
          Class entityClass=entity.getClass();
          entity.setClassName(entityClass.getName());
          converted=true;
        }
      }
 else {
        NamedObj candidate=_createEntity(className,entityName,source);
        if (candidate instanceof Entity) {
          entity=(Entity)candidate;
        }
 else {
          throw new IllegalActionException(_current,""String_Node_Str"" + entityName + ""String_Node_Str""+ ""String_Node_Str""+ className);
        }
      }
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=entity.toplevel();
        _toplevel.setDeferringChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      _current=entity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (!converted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespaceTranslations.push(_namespaceTranslationTable);
        if (groupName.equals(""String_Node_Str"")) {
          _namespace=_AUTO_NAMESPACE;
          _namespaceTranslationTable=new HashMap();
        }
 else {
          _namespace=groupName;
        }
      }
 else {
        _namespaces.push(_DEFAULT_NAMESPACE);
        _namespaceTranslations.push(_namespaceTranslationTable);
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      boolean skip=false;
      if (inputFileNamesToSkip != null) {
        Iterator inputFileNames=inputFileNamesToSkip.iterator();
        while (inputFileNames.hasNext()) {
          String inputFileName=(String)inputFileNames.next();
          if (source.endsWith(inputFileName)) {
            skip=true;
            break;
          }
        }
      }
      if (!skip) {
        MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
        newParser.setContext(_current);
        _parse(newParser,_base,source);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      String insertInsideAtSpec=(String)_attributes.get(""String_Node_Str"");
      LinkRequest request=new LinkRequest(portName,relationName,insertAtSpec,insertInsideAtSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null && !className.trim().equals(""String_Node_Str"")) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      boolean alreadyExisted=(port != null);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        List heritageList=container.getHeritageList();
        Iterator heritage=heritageList.iterator();
        while (heritage.hasNext()) {
          Entity inherited=(Entity)heritage.next();
          if (inherited.getPort(portName) != null) {
            throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + inherited.getPort(portName).getFullName());
          }
        }
        if (newClass == null) {
          port=container.newPort(portName);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            Entity inherited=(Entity)heritage.next();
            Port newPort=inherited.newPort(portName);
            newPort.setInherited(true);
          }
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            Entity inherited=(Entity)heritage.next();
            arguments[0]=inherited;
            NamedObj propagatedPort=_createInstance(newClass,arguments);
            propagatedPort.setInherited(true);
          }
        }
      }
      _pushContext();
      _current=port;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          boolean isOutput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          boolean isInput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          if (alreadyExisted && ioport.isInherited()) {
            if (ioport.isInput() != isInput || ioport.isOutput() != isOutput) {
              throw new IllegalActionException(ioport,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
            }
          }
          ioport.setOutput(isOutput);
          ioport.setInput(isInput);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      _handlePropertyElement(className,propertyName,value);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      boolean alreadyExisted=(relation != null);
      if (relation == null) {
        List heritageList=container.getHeritageList();
        Iterator heritage=heritageList.iterator();
        while (heritage.hasNext()) {
          CompositeEntity inherited=(CompositeEntity)heritage.next();
          if (inherited.getRelation(relationName) != null) {
            throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + inherited.getRelation(relationName).getFullName());
          }
        }
        NamedObj newRelation=null;
        _pushContext();
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            CompositeEntity inherited=(CompositeEntity)heritage.next();
            Relation propagatedRelation=inherited.newRelation(relationName);
            propagatedRelation.setInherited(true);
          }
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            CompositeEntity inherited=(CompositeEntity)heritage.next();
            arguments[0]=inherited;
            NamedObj propagatedRelation=_createInstance(newClass,arguments);
            propagatedRelation.setInherited(true);
          }
        }
        _namespace=_DEFAULT_NAMESPACE;
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _pushContext();
        _current=relation;
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        String oldName=_current.getName();
        if (!oldName.equals(newName) && _current.isInherited()) {
          throw new IllegalActionException(_current,""String_Node_Str"" + newName + ""String_Node_Str"");
        }
        Iterator heritage=_current.getHeritageList().iterator();
        Set changedName=new HashSet();
        HashMap changedClassName=new HashMap();
        NamedObj inherited=null;
        try {
          while (heritage.hasNext()) {
            inherited=(NamedObj)heritage.next();
            if (inherited.getName().equals(oldName)) {
              inherited.setName(newName);
              changedName.add(inherited);
            }
            if (inherited instanceof Instantiable) {
              Instantiable parent=((Instantiable)inherited).getParent();
              if (parent != null && (parent == _current || changedName.contains(parent))) {
                String previousClassName=inherited.getClassName();
                int last=previousClassName.lastIndexOf(oldName);
                if (last < 0) {
                  throw new InternalErrorException(""String_Node_Str"" + inherited.getFullName() + ""String_Node_Str""+ oldName+ ""String_Node_Str""+ previousClassName);
                }
                String newClassName=newName;
                if (last > 0) {
                  newClassName=previousClassName.substring(0,last) + newName;
                }
                inherited.setClassName(newClassName);
                changedClassName.put(inherited,previousClassName);
              }
            }
          }
        }
 catch (        NameDuplicationException ex) {
          Iterator toUndo=changedName.iterator();
          while (toUndo.hasNext()) {
            NamedObj revert=(NamedObj)toUndo.next();
            revert.setName(oldName);
          }
          Iterator classNameFixes=changedClassName.entrySet().iterator();
          while (classNameFixes.hasNext()) {
            Map.Entry revert=(Map.Entry)classNameFixes.next();
            NamedObj toFix=(NamedObj)revert.getKey();
            String previousClassName=(String)revert.getValue();
            toFix.setClassName(previousClassName);
          }
          throw new IllegalActionException(_current,ex,""String_Node_Str"" + ""String_Node_Str"" + inherited.getFullName());
        }
        _current.setName(newName);
        if (undoEnabled && _undoContext.isUndoable()) {
          UndoContext parentContext=(UndoContext)_undoContexts.peek();
          parentContext.applyRename(newName);
          _undoContext.appendUndoMoML(""String_Node_Str"" + oldName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
        if ((_current instanceof Instantiable) && ((Instantiable)_current).isClassDefinition()) {
          List deferredFrom=((Instantiable)_current).getChildren();
          if (deferredFrom != null) {
            Iterator deferrers=deferredFrom.iterator();
            while (deferrers.hasNext()) {
              WeakReference reference=(WeakReference)deferrers.next();
              Prototype deferrer=(Prototype)reference.get();
              if (deferrer != null) {
                String replacementName=newName;
                if (deferrer.getClassName().startsWith(""String_Node_Str"")) {
                  replacementName=_current.getFullName();
                }
                deferrer.setClassName(replacementName);
              }
            }
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      UnlinkRequest request=new UnlinkRequest(portName,relationName,indexSpec,insideIndexSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex previous=(Vertex)_current.getAttribute(vertexName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getExpression();
      }
      Vertex vertex=previous;
      if (vertex == null) {
        vertex=new Vertex((Relation)_current,vertexName);
        Iterator heritage=_current.getHeritageList().iterator();
        while (heritage.hasNext()) {
          Relation inherited=(Relation)heritage.next();
          Vertex propagatedVertex=new Vertex(inherited,vertexName);
          propagatedVertex.setInherited(true);
        }
      }
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null && !value.equals(previousValue)) {
        vertex.setExpression(value);
        vertex.setModifiedHeritage(true);
        _paramsToParse.add(vertex);
        Iterator heritage=vertex.getShadowedHeritageList().iterator();
        while (heritage.hasNext()) {
          Vertex inherited=(Vertex)heritage.next();
          inherited.setExpression(value);
          inherited.setModifiedHeritage(false);
          _paramsToParse.add(inherited);
        }
      }
      _pushContext();
      _current=vertex;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + vertexName + ""String_Node_Str"");
        if (previousValue != null) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + previousValue + ""String_Node_Str"");
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
      }
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex.getTargetException());
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex.getTargetException());
  }
catch (  Exception ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex);
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex);
    }
  }
  _attributes.clear();
  _attributeNameList.clear();
}","/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_skipElement <= 0) {
      if (_configureNesting > 0 || _docNesting > 0) {
        if (elementName.equals(""String_Node_Str"")) {
          _configureNesting++;
        }
 else         if (elementName.equals(""String_Node_Str"")) {
          _docNesting++;
        }
        _currentCharData.append(_getCurrentElement(elementName));
        _attributes.clear();
        _attributeNameList.clear();
        return;
      }
    }
    if (_skipRendition) {
      return;
    }
    boolean undoEnabled=_undoEnabled && _isUndoableElement(elementName);
    if (undoEnabled) {
      boolean childNodesUndoable=true;
      if (_undoContext != null) {
        _undoContexts.push(_undoContext);
        childNodesUndoable=_undoContext.hasUndoableChildren();
      }
      _undoContext=new UndoContext(childNodesUndoable);
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName);
      }
    }
    if (_skipElement > 0) {
      if (elementName.equals(_skipElementName)) {
        if (_skipElementIsNew) {
          _skipElementIsNew=false;
        }
 else {
          _skipElement++;
        }
      }
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      Entity entity=_searchForEntity(entityName,_current);
      boolean existedAlready=(entity != null);
      if (!existedAlready) {
        NamedObj candidate=_createEntity(className,entityName,source);
        if (candidate instanceof Entity) {
          entity=(Entity)candidate;
        }
 else {
          throw new IllegalActionException(_current,""String_Node_Str"" + entityName + ""String_Node_Str""+ ""String_Node_Str""+ className);
        }
      }
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=entity.toplevel();
        _toplevel.setDeferringChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      boolean converted=false;
      if (!existedAlready) {
        entity.setClassDefinition(true);
        entity.setClassName(className);
      }
 else {
        if (!entity.isClassDefinition()) {
          entity.setClassDefinition(true);
          converted=true;
        }
      }
      _current=entity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (!converted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName,entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedPort;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedProp;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(deletedProp.exportMoML());
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedRelation;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      _pushContext();
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      Entity entity=_searchForEntity(entityName,_current);
      boolean existedAlready=(entity != null);
      boolean converted=false;
      if (existedAlready) {
        if (entity.isClassDefinition()) {
          entity.setClassDefinition(false);
          converted=true;
        }
      }
 else {
        NamedObj candidate=_createEntity(className,entityName,source);
        if (candidate instanceof Entity) {
          entity=(Entity)candidate;
          entity.setClassName(className);
        }
 else {
          throw new IllegalActionException(_current,""String_Node_Str"" + entityName + ""String_Node_Str""+ ""String_Node_Str""+ className);
        }
      }
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=entity.toplevel();
        _toplevel.setDeferringChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      _current=entity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (!converted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespaceTranslations.push(_namespaceTranslationTable);
        if (groupName.equals(""String_Node_Str"")) {
          _namespace=_AUTO_NAMESPACE;
          _namespaceTranslationTable=new HashMap();
        }
 else {
          _namespace=groupName;
        }
      }
 else {
        _namespaces.push(_DEFAULT_NAMESPACE);
        _namespaceTranslations.push(_namespaceTranslationTable);
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      boolean skip=false;
      if (inputFileNamesToSkip != null) {
        Iterator inputFileNames=inputFileNamesToSkip.iterator();
        while (inputFileNames.hasNext()) {
          String inputFileName=(String)inputFileNames.next();
          if (source.endsWith(inputFileName)) {
            skip=true;
            break;
          }
        }
      }
      if (!skip) {
        MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
        newParser.setContext(_current);
        _parse(newParser,_base,source);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      String insertInsideAtSpec=(String)_attributes.get(""String_Node_Str"");
      LinkRequest request=new LinkRequest(portName,relationName,insertAtSpec,insertInsideAtSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null && !className.trim().equals(""String_Node_Str"")) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      boolean alreadyExisted=(port != null);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        List heritageList=container.getHeritageList();
        Iterator heritage=heritageList.iterator();
        while (heritage.hasNext()) {
          Entity inherited=(Entity)heritage.next();
          if (inherited.getPort(portName) != null) {
            throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + inherited.getPort(portName).getFullName());
          }
        }
        if (newClass == null) {
          port=container.newPort(portName);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            Entity inherited=(Entity)heritage.next();
            Port newPort=inherited.newPort(portName);
            newPort.setInherited(true);
          }
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            Entity inherited=(Entity)heritage.next();
            arguments[0]=inherited;
            NamedObj propagatedPort=_createInstance(newClass,arguments);
            propagatedPort.setInherited(true);
          }
        }
      }
      _pushContext();
      _current=port;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          boolean isOutput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          boolean isInput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          if (alreadyExisted && ioport.isInherited()) {
            if (ioport.isInput() != isInput || ioport.isOutput() != isOutput) {
              throw new IllegalActionException(ioport,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
            }
          }
          ioport.setOutput(isOutput);
          ioport.setInput(isInput);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      _handlePropertyElement(className,propertyName,value);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      boolean alreadyExisted=(relation != null);
      if (relation == null) {
        List heritageList=container.getHeritageList();
        Iterator heritage=heritageList.iterator();
        while (heritage.hasNext()) {
          CompositeEntity inherited=(CompositeEntity)heritage.next();
          if (inherited.getRelation(relationName) != null) {
            throw new IllegalActionException(container,""String_Node_Str"" + ""String_Node_Str"" + inherited.getRelation(relationName).getFullName());
          }
        }
        NamedObj newRelation=null;
        _pushContext();
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            CompositeEntity inherited=(CompositeEntity)heritage.next();
            Relation propagatedRelation=inherited.newRelation(relationName);
            propagatedRelation.setInherited(true);
          }
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
          heritage=heritageList.iterator();
          while (heritage.hasNext()) {
            CompositeEntity inherited=(CompositeEntity)heritage.next();
            arguments[0]=inherited;
            NamedObj propagatedRelation=_createInstance(newClass,arguments);
            propagatedRelation.setInherited(true);
          }
        }
        _namespace=_DEFAULT_NAMESPACE;
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _pushContext();
        _current=relation;
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        String oldName=_current.getName();
        if (!oldName.equals(newName) && _current.isInherited()) {
          throw new IllegalActionException(_current,""String_Node_Str"" + newName + ""String_Node_Str"");
        }
        Iterator heritage=_current.getHeritageList().iterator();
        Set changedName=new HashSet();
        HashMap changedClassName=new HashMap();
        NamedObj inherited=null;
        try {
          while (heritage.hasNext()) {
            inherited=(NamedObj)heritage.next();
            if (inherited.getName().equals(oldName)) {
              inherited.setName(newName);
              changedName.add(inherited);
            }
            if (inherited instanceof Instantiable) {
              Instantiable parent=((Instantiable)inherited).getParent();
              if (parent != null && (parent == _current || changedName.contains(parent))) {
                String previousClassName=inherited.getClassName();
                int last=previousClassName.lastIndexOf(oldName);
                if (last < 0) {
                  throw new InternalErrorException(""String_Node_Str"" + inherited.getFullName() + ""String_Node_Str""+ oldName+ ""String_Node_Str""+ previousClassName);
                }
                String newClassName=newName;
                if (last > 0) {
                  newClassName=previousClassName.substring(0,last) + newName;
                }
                inherited.setClassName(newClassName);
                changedClassName.put(inherited,previousClassName);
              }
            }
          }
        }
 catch (        NameDuplicationException ex) {
          Iterator toUndo=changedName.iterator();
          while (toUndo.hasNext()) {
            NamedObj revert=(NamedObj)toUndo.next();
            revert.setName(oldName);
          }
          Iterator classNameFixes=changedClassName.entrySet().iterator();
          while (classNameFixes.hasNext()) {
            Map.Entry revert=(Map.Entry)classNameFixes.next();
            NamedObj toFix=(NamedObj)revert.getKey();
            String previousClassName=(String)revert.getValue();
            toFix.setClassName(previousClassName);
          }
          throw new IllegalActionException(_current,ex,""String_Node_Str"" + ""String_Node_Str"" + inherited.getFullName());
        }
        _current.setName(newName);
        if (undoEnabled && _undoContext.isUndoable()) {
          UndoContext parentContext=(UndoContext)_undoContexts.peek();
          parentContext.applyRename(newName);
          _undoContext.appendUndoMoML(""String_Node_Str"" + oldName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
        if ((_current instanceof Instantiable) && ((Instantiable)_current).isClassDefinition()) {
          List deferredFrom=((Instantiable)_current).getChildren();
          if (deferredFrom != null) {
            Iterator deferrers=deferredFrom.iterator();
            while (deferrers.hasNext()) {
              WeakReference reference=(WeakReference)deferrers.next();
              Prototype deferrer=(Prototype)reference.get();
              if (deferrer != null) {
                String replacementName=newName;
                if (deferrer.getClassName().startsWith(""String_Node_Str"")) {
                  replacementName=_current.getFullName();
                }
                deferrer.setClassName(replacementName);
              }
            }
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      UnlinkRequest request=new UnlinkRequest(portName,relationName,indexSpec,insideIndexSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex previous=(Vertex)_current.getAttribute(vertexName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getExpression();
      }
      Vertex vertex=previous;
      if (vertex == null) {
        vertex=new Vertex((Relation)_current,vertexName);
        Iterator heritage=_current.getHeritageList().iterator();
        while (heritage.hasNext()) {
          Relation inherited=(Relation)heritage.next();
          Vertex propagatedVertex=new Vertex(inherited,vertexName);
          propagatedVertex.setInherited(true);
        }
      }
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null && !value.equals(previousValue)) {
        vertex.setExpression(value);
        vertex.setModifiedHeritage(true);
        _paramsToParse.add(vertex);
        Iterator heritage=vertex.getShadowedHeritageList().iterator();
        while (heritage.hasNext()) {
          Vertex inherited=(Vertex)heritage.next();
          inherited.setExpression(value);
          inherited.setModifiedHeritage(false);
          _paramsToParse.add(inherited);
        }
      }
      _pushContext();
      _current=vertex;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + vertexName + ""String_Node_Str"");
        if (previousValue != null) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + previousValue + ""String_Node_Str"");
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
      }
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex.getTargetException());
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex.getTargetException());
  }
catch (  Exception ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex);
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex);
    }
  }
  _attributes.clear();
  _attributeNameList.clear();
}"
75352,"/** 
 * Use the specified parser to parse the file or URL, which contains MoML, using the specified base to find the URL. If the URL has been previously parsed by this application, then return the instance that was the result of the previous parse. If the URL cannot be found relative to this base, then it is searched for relative to the current working directory (if this is permitted with the current security restrictions), and then relative to the classpath.
 * @param parser The parser to use.
 * @param base The base URL for relative references, or null ifnot known.
 * @param file The file or URL from which to read MoML.
 * @param className The class name to assign if the file isparsed anew.
 * @param source The source file to assign if the file isparsed anew, or null to not assign one.
 * @return The top-level composite entity of the Ptolemy II model.
 * @exception Exception If the parser fails.
 */
private NamedObj _findOrParse(MoMLParser parser,URL base,String file,String className,String source) throws Exception {
  _xmlFile=fileNameToURL(file,base);
  if (_imports != null) {
    NamedObj previous=(NamedObj)_imports.get(_xmlFile);
    if (previous != null) {
      return previous;
    }
  }
  InputStream input=_xmlFile.openStream();
  try {
    NamedObj toplevel=parser.parse(_xmlFile,input);
    input.close();
    toplevel.setClassName(className);
    toplevel.setSource(source);
    if (_imports == null) {
      _imports=new HashMap();
    }
    _imports.put(_xmlFile,toplevel);
    return toplevel;
  }
 catch (  CancelException ex) {
    return null;
  }
 finally {
    input.close();
    _xmlFile=null;
  }
}","/** 
 * Use the specified parser to parse the file or URL, which contains MoML, using the specified base to find the URL. If the URL has been previously parsed by this application, then return the instance that was the result of the previous parse. If the URL cannot be found relative to this base, then it is searched for relative to the current working directory (if this is permitted with the current security restrictions), and then relative to the classpath.
 * @param parser The parser to use.
 * @param base The base URL for relative references, or null ifnot known.
 * @param file The file or URL from which to read MoML.
 * @param className The class name to assign if the file isparsed anew.
 * @param source The source file to assign if the file isparsed anew, or null to not assign one.
 * @return The top-level composite entity of the Ptolemy II model.
 * @exception Exception If the parser fails.
 */
private NamedObj _findOrParse(MoMLParser parser,URL base,String file,String className,String source) throws Exception {
  URL previousXmlFile=parser._xmlFile;
  parser._xmlFile=fileNameToURL(file,base);
  if (_imports != null) {
    NamedObj previous=(NamedObj)_imports.get(parser._xmlFile);
    if (previous != null) {
      return previous;
    }
  }
  InputStream input=parser._xmlFile.openStream();
  try {
    NamedObj toplevel=parser.parse(parser._xmlFile,input);
    input.close();
    toplevel.setSource(source);
    if (_imports == null) {
      _imports=new HashMap();
    }
    _imports.put(parser._xmlFile,toplevel);
    return toplevel;
  }
 catch (  CancelException ex) {
    return null;
  }
 finally {
    input.close();
    parser._xmlFile=previousXmlFile;
  }
}"
75353,"/** 
 * Check that the specified token is compatible with the resolved type of this port.     * 
 * @param token The token to check.
 * @throws IllegalActionException If the specified token iseither incomparable to the resolved type or higher in the type lattice.
 */
protected void _checkType(Token token) throws IllegalActionException {
  int compare=TypeLattice.compare(token.getType(),_resolvedType);
  if (compare == CPO.HIGHER || compare == CPO.INCOMPARABLE) {
    throw new IllegalActionException(this,""String_Node_Str"" + token + ""String_Node_Str""+ ""String_Node_Str""+ getType().toString());
  }
}","/** 
 * Check that the specified token is compatible with the resolved type of this port.     * 
 * @param token The token to check.
 * @throws IllegalActionException If the specified token iseither incomparable to the resolved type or higher in the type lattice.
 */
protected void _checkType(Token token) throws IllegalActionException {
  int compare=TypeLattice.compare(token.getType(),_resolvedType);
  if (compare == CPO.HIGHER || compare == CPO.INCOMPARABLE) {
    throw new IllegalActionException(this,""String_Node_Str"" + token + ""String_Node_Str""+ token.getType()+ ""String_Node_Str""+ getType().toString());
  }
}"
75354,"private int _isShadowedImplementation(NamedObj object,NamedObj propagatingContext){
  if (object.isModifiedFromClass()) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + object.getFullName());
    }
    return 2;
  }
  if (!propagatingContext.deepContains(object)) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  String relativeName=object.getName(propagatingContext);
  if (_DEBUG) {
    System.out.println(""String_Node_Str"" + object.getFullName());
  }
  NamedObj context=propagatingContext;
  String relativeContextName=null;
  while (context != null) {
    if (!(context instanceof Prototype)) {
      if (relativeContextName == null) {
        relativeContextName=context.getName();
      }
 else {
        relativeContextName=context.getName() + ""String_Node_Str"" + relativeContextName;
      }
      context=(NamedObj)context.getContainer();
      continue;
    }
    Prototype defersTo=((Prototype)context).getDeferTo();
    if (defersTo == null) {
      if (relativeContextName == null) {
        relativeContextName=context.getName();
      }
 else {
        relativeContextName=context.getName() + ""String_Node_Str"" + relativeContextName;
      }
      context=(NamedObj)context.getContainer();
      continue;
    }
    NamedObj trueContext=defersTo;
    if (relativeContextName != null) {
      if (!(defersTo instanceof CompositeEntity)) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      trueContext=((CompositeEntity)defersTo).getEntity(relativeContextName);
    }
    if (trueContext == _context) {
      if (_DEBUG) {
        System.out.println(""String_Node_Str"" + defersTo.getFullName() + ""String_Node_Str""+ _context.getFullName());
      }
      return 1;
    }
    NamedObj possibleShadow=null;
    if (object instanceof Attribute) {
      possibleShadow=trueContext.getAttribute(relativeName);
    }
 else     if (object instanceof ComponentEntity && trueContext instanceof CompositeEntity) {
      possibleShadow=((CompositeEntity)trueContext).getEntity(relativeName);
    }
    if (possibleShadow == null) {
      throw new InternalErrorException(""String_Node_Str"" + defersTo.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ relativeName+ ""String_Node_Str""+ object.getFullName()+ ""String_Node_Str""+ propagatingContext.getFullName());
    }
    if (possibleShadow.isModifiedFromClass()) {
      if (_DEBUG) {
        System.out.println(""String_Node_Str"" + object.getFullName() + ""String_Node_Str""+ possibleShadow.getFullName());
      }
      return 2;
    }
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + possibleShadow.getFullName());
    }
    int result=_isShadowedImplementation(possibleShadow,trueContext);
    if (result == 2) {
      if (_DEBUG) {
        System.out.println(""String_Node_Str"" + object.getFullName() + ""String_Node_Str""+ possibleShadow.getFullName());
      }
      return 2;
    }
 else     if (result == 1) {
      return 1;
    }
    if (relativeContextName == null) {
      relativeContextName=context.getName();
    }
 else {
      relativeContextName=context.getName() + ""String_Node_Str"" + relativeContextName;
    }
    context=(NamedObj)context.getContainer();
  }
  if (_DEBUG) {
    System.out.println(""String_Node_Str"" + object.getFullName() + ""String_Node_Str"");
  }
  return 0;
}","private int _isShadowedImplementation(NamedObj object,NamedObj propagatingContext){
  if (object.isModifiedFromClass()) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + object.getFullName());
    }
    return 2;
  }
  if (!propagatingContext.deepContains(object)) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  String relativeName=object.getName(propagatingContext);
  if (_DEBUG) {
    System.out.println(""String_Node_Str"" + object.getFullName());
  }
  NamedObj context=propagatingContext;
  String relativeContextName=null;
  while (context != null) {
    if (!(context instanceof Prototype)) {
      if (relativeContextName == null) {
        relativeContextName=context.getName();
      }
 else {
        relativeContextName=context.getName() + ""String_Node_Str"" + relativeContextName;
      }
      context=(NamedObj)context.getContainer();
      continue;
    }
    Prototype defersTo=((Prototype)context).getDeferTo();
    if (defersTo == null) {
      if (relativeContextName == null) {
        relativeContextName=context.getName();
      }
 else {
        relativeContextName=context.getName() + ""String_Node_Str"" + relativeContextName;
      }
      context=(NamedObj)context.getContainer();
      continue;
    }
    NamedObj trueContext=defersTo;
    if (relativeContextName != null) {
      if (!(defersTo instanceof CompositeEntity)) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (_context instanceof ComponentEntity) {
        trueContext=((CompositeEntity)defersTo).getEntity(relativeContextName);
      }
 else       if (_context instanceof Attribute) {
        trueContext=defersTo.getAttribute(relativeContextName);
      }
 else       if (_context instanceof Port) {
        trueContext=((Entity)defersTo).getPort(relativeContextName);
      }
 else       if (_context instanceof Relation) {
        trueContext=((CompositeEntity)defersTo).getRelation(relativeContextName);
      }
      if (trueContext == null) {
        throw new InternalErrorException(""String_Node_Str"" + defersTo.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ relativeContextName);
      }
    }
    if (trueContext == _context) {
      if (_DEBUG) {
        System.out.println(""String_Node_Str"" + defersTo.getFullName() + ""String_Node_Str""+ _context.getFullName());
      }
      return 1;
    }
    NamedObj possibleShadow=null;
    if (object instanceof Attribute) {
      possibleShadow=trueContext.getAttribute(relativeName);
    }
 else     if (object instanceof ComponentEntity && trueContext instanceof CompositeEntity) {
      possibleShadow=((CompositeEntity)trueContext).getEntity(relativeName);
    }
    if (possibleShadow == null) {
      throw new InternalErrorException(""String_Node_Str"" + defersTo.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ relativeName+ ""String_Node_Str""+ object.getFullName()+ ""String_Node_Str""+ propagatingContext.getFullName());
    }
    if (possibleShadow.isModifiedFromClass()) {
      if (_DEBUG) {
        System.out.println(""String_Node_Str"" + object.getFullName() + ""String_Node_Str""+ possibleShadow.getFullName());
      }
      return 2;
    }
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + possibleShadow.getFullName());
    }
    int result=_isShadowedImplementation(possibleShadow,trueContext);
    if (result == 2) {
      if (_DEBUG) {
        System.out.println(""String_Node_Str"" + object.getFullName() + ""String_Node_Str""+ possibleShadow.getFullName());
      }
      return 2;
    }
 else     if (result == 1) {
      return 1;
    }
    if (relativeContextName == null) {
      relativeContextName=context.getName();
    }
 else {
      relativeContextName=context.getName() + ""String_Node_Str"" + relativeContextName;
    }
    context=(NamedObj)context.getContainer();
  }
  if (_DEBUG) {
    System.out.println(""String_Node_Str"" + object.getFullName() + ""String_Node_Str"");
  }
  return 0;
}"
75355,"/** 
 * Execute the change by evaluating the request and propagating the request if appropriate.
 * @exception Exception If an exception is thrownwhile evaluating the request.
 */
protected void _execute() throws Exception {
  if (_DEBUG) {
    System.out.println(""String_Node_Str"");
    System.out.println(getDescription());
    if (_context != null) {
      System.out.println(""String_Node_Str"" + _context.getFullName());
    }
  }
  if (_context != null) {
    _parser=ParserAttribute.getParser(_context);
    _parser.reset();
  }
  if (_parser == null) {
    _parser=new MoMLParser();
  }
  try {
    _parser._propagator=_propagator;
    _parser._propagatingContext=_context;
    if (_context != null) {
      _parser.setContext(_context);
    }
    if (_undoable) {
      _parser.setUndoable(true);
    }
    ErrorHandler handler=MoMLParser.getErrorHandler();
    if (!_reportToHandler) {
      MoMLParser.setErrorHandler(null);
    }
    try {
      _parser.parse(_base,getDescription());
    }
  finally {
      if (!_reportToHandler) {
        MoMLParser.setErrorHandler(handler);
      }
    }
  }
  finally {
    _parser._propagator=null;
    _parser._propagatingContext=null;
  }
  if (_undoable && _mergeWithPreviousUndo) {
    UndoStackAttribute undoInfo=UndoStackAttribute.getUndoInfo(_context);
    undoInfo.mergeTopTwo();
  }
  if (!_enablePropagation) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"");
    }
    return;
  }
  NamedObj context=(NamedObj)_context;
  if (context == null) {
    context=_parser.getToplevel();
  }
  if (_propagator == null) {
    _propagator=this;
  }
  String relativeName=null;
  while (context != null) {
    if (!(context instanceof Prototype)) {
      if (relativeName == null) {
        relativeName=context.getName();
      }
 else {
        relativeName=context.getName() + ""String_Node_Str"" + relativeName;
      }
      context=(NamedObj)context.getContainer();
      continue;
    }
    List othersList=((Prototype)context).getDeferredFrom();
    if (othersList != null) {
      Iterator others=othersList.iterator();
      while (others.hasNext()) {
        WeakReference reference=(WeakReference)others.next();
        NamedObj other=(NamedObj)reference.get();
        if (other != null) {
          if (_DEBUG) {
            System.out.println(""String_Node_Str"" + other.getFullName() + ""String_Node_Str""+ context.getFullName());
          }
          NamedObj trueContext=other;
          if (context != _context) {
            trueContext=((CompositeEntity)other).getEntity(relativeName);
          }
          if (_propagator._propagatedContexts == null) {
            _propagator._propagatedContexts=new HashSet();
          }
 else {
            if (_propagator._propagatedContexts.contains(trueContext)) {
              if (_DEBUG) {
                System.out.println(""String_Node_Str"" + other.getFullName() + ""String_Node_Str""+ trueContext.getFullName());
              }
              continue;
            }
          }
          _propagator._propagatedContexts.add(trueContext);
          String moml=getDescription();
          if (_DEBUG) {
            System.out.println(""String_Node_Str"" + moml + ""String_Node_Str""+ trueContext.getFullName()+ ""String_Node_Str""+ _propagator);
          }
          MoMLChangeRequest newChange=new MoMLChangeRequest(getSource(),trueContext,moml,_base,_propagator);
          other.requestChange(newChange);
        }
      }
    }
    if (relativeName == null) {
      relativeName=context.getName();
    }
 else {
      relativeName=context.getName() + ""String_Node_Str"" + relativeName;
    }
    context=(NamedObj)context.getContainer();
  }
}","/** 
 * Execute the change by evaluating the request and propagating the request if appropriate.
 * @exception Exception If an exception is thrownwhile evaluating the request.
 */
protected void _execute() throws Exception {
  if (_DEBUG) {
    System.out.println(""String_Node_Str"");
    System.out.println(getDescription());
    if (_context != null) {
      System.out.println(""String_Node_Str"" + _context.getFullName());
    }
  }
  if (_context != null) {
    _parser=ParserAttribute.getParser(_context);
    _parser.reset();
  }
  if (_parser == null) {
    _parser=new MoMLParser();
  }
  try {
    _parser._propagator=_propagator;
    _parser._propagatingContext=_context;
    if (_context != null) {
      _parser.setContext(_context);
    }
    if (_undoable) {
      _parser.setUndoable(true);
    }
    ErrorHandler handler=MoMLParser.getErrorHandler();
    if (!_reportToHandler) {
      MoMLParser.setErrorHandler(null);
    }
    try {
      _parser.parse(_base,getDescription());
    }
  finally {
      if (!_reportToHandler) {
        MoMLParser.setErrorHandler(handler);
      }
    }
  }
  finally {
    _parser._propagator=null;
    _parser._propagatingContext=null;
  }
  if (_undoable && _mergeWithPreviousUndo) {
    UndoStackAttribute undoInfo=UndoStackAttribute.getUndoInfo(_context);
    undoInfo.mergeTopTwo();
  }
  if (!_enablePropagation) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"");
    }
    return;
  }
  NamedObj context=_context;
  if (context == null) {
    context=_parser.getToplevel();
  }
  if (_propagator == null) {
    _propagator=this;
  }
  String relativeName=null;
  while (context != null) {
    if (!(context instanceof Prototype)) {
      if (relativeName == null) {
        relativeName=context.getName();
      }
 else {
        relativeName=context.getName() + ""String_Node_Str"" + relativeName;
      }
      context=(NamedObj)context.getContainer();
      continue;
    }
    List othersList=((Prototype)context).getDeferredFrom();
    if (othersList != null) {
      Iterator others=othersList.iterator();
      while (others.hasNext()) {
        WeakReference reference=(WeakReference)others.next();
        NamedObj other=(NamedObj)reference.get();
        if (other != null) {
          if (_DEBUG) {
            System.out.println(""String_Node_Str"" + other.getFullName() + ""String_Node_Str""+ context.getFullName());
          }
          NamedObj trueContext=other;
          if (context != _context) {
            if (_context instanceof ComponentEntity) {
              trueContext=((CompositeEntity)other).getEntity(relativeName);
            }
 else             if (_context instanceof Attribute) {
              trueContext=other.getAttribute(relativeName);
            }
 else             if (_context instanceof Port) {
              trueContext=((Entity)other).getPort(relativeName);
            }
 else             if (_context instanceof Relation) {
              trueContext=((CompositeEntity)other).getRelation(relativeName);
            }
            if (trueContext == null) {
              throw new InternalErrorException(""String_Node_Str"" + other.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ relativeName);
            }
          }
          if (_propagator._propagatedContexts == null) {
            _propagator._propagatedContexts=new HashSet();
          }
 else {
            if (_propagator._propagatedContexts.contains(trueContext)) {
              if (_DEBUG) {
                System.out.println(""String_Node_Str"" + other.getFullName() + ""String_Node_Str""+ trueContext.getFullName());
              }
              continue;
            }
          }
          _propagator._propagatedContexts.add(trueContext);
          String moml=getDescription();
          if (_DEBUG) {
            System.out.println(""String_Node_Str"" + moml + ""String_Node_Str""+ trueContext.getFullName()+ ""String_Node_Str""+ _propagator);
          }
          MoMLChangeRequest newChange=new MoMLChangeRequest(getSource(),trueContext,moml,_base,_propagator);
          other.requestChange(newChange);
        }
      }
    }
    if (relativeName == null) {
      relativeName=context.getName();
    }
 else {
      relativeName=context.getName() + ""String_Node_Str"" + relativeName;
    }
    context=(NamedObj)context.getContainer();
  }
}"
75356,"/** 
 * Visit a UnitExpr by visiting the UnitRerms.
 * @param unitExpr The UnitExpr to visit.
 * @return
 * @exception IllegalActionException Not thrown in this base class
 */
protected Object _visitUnitExpr(UnitExpr unitExpr) throws IllegalActionException {
  Iterator iter=unitExpr.getUTerms().iterator();
  Vector uTerms=new Vector();
  while (iter.hasNext()) {
    UnitTerm term=(UnitTerm)(iter.next());
    term.visit(this);
  }
  return null;
}","/** 
 * Visit a UnitExpr by visiting the UnitRerms.
 * @param unitExpr The UnitExpr to visit.
 * @return Null, can be overriden in a concrete visitor.
 * @exception IllegalActionException Not thrown in this base class
 */
protected Object _visitUnitExpr(UnitExpr unitExpr) throws IllegalActionException {
  Iterator iter=unitExpr.getUTerms().iterator();
  Vector uTerms=new Vector();
  while (iter.hasNext()) {
    UnitTerm term=(UnitTerm)(iter.next());
    term.visit(this);
  }
  return null;
}"
75357,"/** 
 * Visit a UnitTerm by visiting the UnitExpr if there is one. This method will almost certainly be overridden in a subclass.
 * @param uTerm The UnitTerm to visit.
 * @return
 * @exception IllegalActionException Not thrown in this base class
 */
protected Object _visitUnitTerm(UnitTerm uTerm) throws IllegalActionException {
  if (uTerm.isUnitExpr()) {
    UnitExpr uExpr=uTerm.getUnitExpr();
    _visitUnitExpr(uExpr);
  }
  return null;
}","/** 
 * Visit a UnitTerm by visiting the UnitExpr if there is one. This method will almost certainly be overridden in a subclass.
 * @param uTerm The UnitTerm to visit.
 * @return Null, can be overriden in a concrete visitor.
 * @exception IllegalActionException Not thrown in this base class
 */
protected Object _visitUnitTerm(UnitTerm uTerm) throws IllegalActionException {
  if (uTerm.isUnitExpr()) {
    UnitExpr uExpr=uTerm.getUnitExpr();
    _visitUnitExpr(uExpr);
  }
  return null;
}"
75358,"/** 
 * Visit a UnitEquation by visiting the left and right sides of the equation.
 * @param uEquation The UnitEquation to visit.
 * @return
 * @exception IllegalActionException Not thrown in this base class
 */
protected Object _visitUnitEquation(UnitEquation uEquation) throws IllegalActionException {
  _visitUnitExpr(uEquation.getLhs());
  _visitUnitExpr(uEquation.getRhs());
  return null;
}","/** 
 * Visit a UnitEquation by visiting the left and right sides of the equation.
 * @param uEquation The UnitEquation to visit.
 * @return Null, can be overriden in a concrete visitor.
 * @exception IllegalActionException Not thrown in this base class
 */
protected Object _visitUnitEquation(UnitEquation uEquation) throws IllegalActionException {
  _visitUnitExpr(uEquation.getLhs());
  _visitUnitExpr(uEquation.getRhs());
  return null;
}"
75359,"/** 
 * @param expression
 * @param equations
 */
public Vector parseEquations(String stringIn) throws ParseException {
  Reader reader=new StringReader(stringIn);
  this.ReInit(reader);
  Vector _equations=Equations();
  return _equations;
}","/** 
 * Parse a set of equations separated by semicolons.
 * @param expression
 * @exception ParseException If parsing error is encountered.
 */
public Vector parseEquations(String expression) throws ParseException {
  Reader reader=new StringReader(expression);
  this.ReInit(reader);
  Vector _equations=Equations();
  return _equations;
}"
75360,"public UnitExpr parseUnitExpr(String stringIn) throws ParseException {
  Reader reader=new StringReader(stringIn);
  this.ReInit(reader);
  UnitExpr unitExpr=uExpr();
  return unitExpr;
}","/** 
 * Parse a unit expression.
 * @param expression
 * @exception ParseException If parsing error is encountered.
 */
public UnitExpr parseUnitExpr(String expression) throws ParseException {
  Reader reader=new StringReader(expression);
  this.ReInit(reader);
  UnitExpr unitExpr=uExpr();
  return unitExpr;
}"
75361,"/** 
 * Return whether or not the given element name is undoable. NOTE: we need this method as the list of actions on namespaces and _current does not apply to elements such as ""link""
 * @param elementName  Description of Parameter
 * @return              Description of the Returned Value
 * @since Ptolemy 2.1
 */
private boolean _isUndoableElement(String elementName){
  if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")) {
    return true;
  }
  return false;
}","/** 
 * Return whether or not the given element name is undoable. NOTE: we need this method as the list of actions on namespaces and _current does not apply to elements such as ""link""
 * @param elementName  Description of Parameter
 * @return              Description of the Returned Value
 * @since Ptolemy 2.1
 */
private boolean _isUndoableElement(String elementName){
  if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")|| elementName.equals(""String_Node_Str"")) {
    return true;
  }
  return false;
}"
75362,"/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_skipElement <= 0) {
      if (_configureNesting > 0 || _docNesting > 0) {
        if (elementName.equals(""String_Node_Str"")) {
          _configureNesting++;
        }
 else         if (elementName.equals(""String_Node_Str"")) {
          _docNesting++;
        }
        _currentCharData.append(_getCurrentElement(elementName));
        _attributes.clear();
        _attributeNameList.clear();
        return;
      }
    }
    if (_skipRendition) {
      return;
    }
    if (_undoEnabled && _isUndoableElement(elementName)) {
      boolean childNodesUndoable=true;
      if (_undoContext != null) {
        _undoContexts.push(_undoContext);
        childNodesUndoable=_undoContext.hasUndoableChildren();
      }
      _undoContext=new UndoContext(childNodesUndoable);
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName);
      }
    }
    if (_skipElement > 0) {
      if (elementName.equals(_skipElementName)) {
        if (_skipElementIsNew) {
          _skipElementIsNew=false;
        }
 else {
          _skipElement++;
        }
      }
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      ComponentEntity previous=_searchForEntity(entityName);
      boolean existedAlready=false;
      if (previous != null) {
        existedAlready=true;
      }
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
        _toplevel.setDeferChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      if (!existedAlready) {
        ((Prototype)newEntity).setClassDefinition(true);
        NamedObj.MoMLInfo info=newEntity.getMoMLInfo();
        info.className=newEntity.getFullName();
        info.superclass=className;
      }
 else {
        if (!previous.isClassDefinition()) {
          previous.setClassDefinition(true);
          NamedObj.MoMLInfo info=previous.getMoMLInfo();
          info.superclass=info.className;
          info.className=previous.getFullName();
        }
      }
      _current=newEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (previous.isClassDefinition()) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName,entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedPort;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedProp;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(deletedProp.exportMoML());
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedRelation;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      _pushContext();
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      ComponentEntity previous=_searchForEntity(entityName);
      boolean existedAlready=false;
      if (previous != null) {
        existedAlready=true;
      }
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
        _toplevel.setDeferChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      _current=newEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespaceTranslations.push(_namespaceTranslationTable);
        if (groupName.equals(""String_Node_Str"")) {
          _namespace=_AUTO_NAMESPACE;
          _namespaceTranslationTable=new HashMap();
        }
 else {
          _namespace=groupName;
        }
      }
 else {
        _namespaces.push(_DEFAULT_NAMESPACE);
        _namespaceTranslations.push(_namespaceTranslationTable);
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      boolean skip=false;
      if (inputFileNamesToSkip != null) {
        Iterator inputFileNames=inputFileNamesToSkip.iterator();
        while (inputFileNames.hasNext()) {
          String inputFileName=(String)inputFileNames.next();
          if (source.endsWith(inputFileName)) {
            skip=true;
            break;
          }
        }
      }
      if (!skip) {
        MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
        newParser.setContext(_current);
        newParser._propagator=_propagator;
        _parse(newParser,_base,source);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      String insertInsideAtSpec=(String)_attributes.get(""String_Node_Str"");
      LinkRequest request=new LinkRequest(portName,relationName,insertAtSpec,insertInsideAtSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null && !className.trim().equals(""String_Node_Str"")) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      boolean alreadyExisted=(port != null);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        if (newClass == null) {
          port=container.newPort(portName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
        }
      }
      _pushContext();
      _current=port;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          boolean isOutput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          boolean isInput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          if (alreadyExisted && ioport.isClassElement() && (_propagator == null)) {
            if (ioport.isInput() != isInput || ioport.isOutput() != isOutput) {
              throw new IllegalActionException(ioport,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
            }
          }
          ioport.setOutput(isOutput);
          ioport.setInput(isInput);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      _handlePropertyElement(className,propertyName,value);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      boolean alreadyExisted=(relation != null);
      if (relation == null) {
        NamedObj newRelation=null;
        _pushContext();
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
        }
        _namespace=_DEFAULT_NAMESPACE;
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _pushContext();
        _current=relation;
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        String oldName=_current.getName();
        if (!oldName.equals(newName) && _current.isClassElement() && (_propagator == null)) {
          throw new IllegalActionException(_current,""String_Node_Str"" + newName + ""String_Node_Str"");
        }
        _current.setName(newName);
        if (_undoEnabled && _undoContext.isUndoable()) {
          try {
            UndoContext parentContext=(UndoContext)_undoContexts.peek();
            parentContext.applyRename(newName);
            _undoContext.appendUndoMoML(""String_Node_Str"" + oldName + ""String_Node_Str"");
            _undoContext.setChildrenUndoable(false);
          }
 catch (          Exception e) {
          }
        }
        if ((_current instanceof Prototype) && ((Prototype)_current).isClassDefinition()) {
          List deferredFrom=((Prototype)_current).getDeferredFrom();
          if (deferredFrom != null) {
            Iterator deferrers=deferredFrom.iterator();
            while (deferrers.hasNext()) {
              WeakReference reference=(WeakReference)deferrers.next();
              Prototype deferrer=(Prototype)reference.get();
              if (deferrer != null) {
                String replacementName=newName;
                if (deferrer.isClassDefinition()) {
                  if (deferrer.getMoMLInfo().superclass.startsWith(""String_Node_Str"")) {
                    replacementName=_current.getFullName();
                  }
                  deferrer.getMoMLInfo().superclass=replacementName;
                }
 else {
                  if (deferrer.getMoMLInfo().className.startsWith(""String_Node_Str"")) {
                    replacementName=_current.getFullName();
                  }
                  deferrer.getMoMLInfo().className=replacementName;
                }
              }
            }
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      UnlinkRequest request=new UnlinkRequest(portName,relationName,indexSpec,insideIndexSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex previous=(Vertex)_current.getAttribute(vertexName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getExpression();
      }
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null) {
        vertex.setExpression(value);
        _paramsToParse.add(vertex);
      }
      _pushContext();
      _current=vertex;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + vertexName + ""String_Node_Str"");
        if (previousValue != null) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + previousValue + ""String_Node_Str"");
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
      }
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex.getTargetException());
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex.getTargetException());
  }
catch (  Exception ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex);
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex);
    }
  }
  _attributes.clear();
  _attributeNameList.clear();
}","/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_skipElement <= 0) {
      if (_configureNesting > 0 || _docNesting > 0) {
        if (elementName.equals(""String_Node_Str"")) {
          _configureNesting++;
        }
 else         if (elementName.equals(""String_Node_Str"")) {
          _docNesting++;
        }
        _currentCharData.append(_getCurrentElement(elementName));
        _attributes.clear();
        _attributeNameList.clear();
        return;
      }
    }
    if (_skipRendition) {
      return;
    }
    boolean undoEnabled=_undoEnabled && _isUndoableElement(elementName);
    if (undoEnabled) {
      boolean childNodesUndoable=true;
      if (_undoContext != null) {
        _undoContexts.push(_undoContext);
        childNodesUndoable=_undoContext.hasUndoableChildren();
      }
      _undoContext=new UndoContext(childNodesUndoable);
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName);
      }
    }
    if (_skipElement > 0) {
      if (elementName.equals(_skipElementName)) {
        if (_skipElementIsNew) {
          _skipElementIsNew=false;
        }
 else {
          _skipElement++;
        }
      }
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      ComponentEntity previous=_searchForEntity(entityName);
      boolean existedAlready=false;
      if (previous != null) {
        existedAlready=true;
      }
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
        _toplevel.setDeferChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      if (!existedAlready) {
        ((Prototype)newEntity).setClassDefinition(true);
        NamedObj.MoMLInfo info=newEntity.getMoMLInfo();
        info.className=newEntity.getFullName();
        info.superclass=className;
      }
 else {
        if (!previous.isClassDefinition()) {
          previous.setClassDefinition(true);
          NamedObj.MoMLInfo info=previous.getMoMLInfo();
          info.superclass=info.className;
          info.className=previous.getFullName();
        }
      }
      _current=newEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          if (previous.isClassDefinition()) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          }
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName,entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedPort;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedProp;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(deletedProp.exportMoML());
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedRelation;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      _pushContext();
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      ComponentEntity previous=_searchForEntity(entityName);
      boolean existedAlready=false;
      if (previous != null) {
        existedAlready=true;
      }
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_linkRequests != null) {
        _linkRequestStack.push(_linkRequests);
      }
      _linkRequests=new LinkedList();
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
        _toplevel.setDeferChangeRequests(true);
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      _current=newEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespaceTranslations.push(_namespaceTranslationTable);
        if (groupName.equals(""String_Node_Str"")) {
          _namespace=_AUTO_NAMESPACE;
          _namespaceTranslationTable=new HashMap();
        }
 else {
          _namespace=groupName;
        }
      }
 else {
        _namespaces.push(_DEFAULT_NAMESPACE);
        _namespaceTranslations.push(_namespaceTranslationTable);
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      boolean skip=false;
      if (inputFileNamesToSkip != null) {
        Iterator inputFileNames=inputFileNamesToSkip.iterator();
        while (inputFileNames.hasNext()) {
          String inputFileName=(String)inputFileNames.next();
          if (source.endsWith(inputFileName)) {
            skip=true;
            break;
          }
        }
      }
      if (!skip) {
        MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
        newParser.setContext(_current);
        newParser._propagator=_propagator;
        _parse(newParser,_base,source);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      String insertInsideAtSpec=(String)_attributes.get(""String_Node_Str"");
      LinkRequest request=new LinkRequest(portName,relationName,insertAtSpec,insertInsideAtSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null && !className.trim().equals(""String_Node_Str"")) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      boolean alreadyExisted=(port != null);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        if (newClass == null) {
          port=container.newPort(portName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
        }
      }
      _pushContext();
      _current=port;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          boolean isOutput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          boolean isInput=direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str"");
          if (alreadyExisted && ioport.isClassElement() && (_propagator == null)) {
            if (ioport.isInput() != isInput || ioport.isOutput() != isOutput) {
              throw new IllegalActionException(ioport,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
            }
          }
          ioport.setOutput(isOutput);
          ioport.setInput(isInput);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      _handlePropertyElement(className,propertyName,value);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      boolean alreadyExisted=(relation != null);
      if (relation == null) {
        NamedObj newRelation=null;
        _pushContext();
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
        }
        _namespace=_DEFAULT_NAMESPACE;
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _pushContext();
        _current=relation;
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        String oldName=_current.getName();
        if (!oldName.equals(newName) && _current.isClassElement() && (_propagator == null)) {
          throw new IllegalActionException(_current,""String_Node_Str"" + newName + ""String_Node_Str"");
        }
        _current.setName(newName);
        if (undoEnabled && _undoContext.isUndoable()) {
          try {
            UndoContext parentContext=(UndoContext)_undoContexts.peek();
            parentContext.applyRename(newName);
            _undoContext.appendUndoMoML(""String_Node_Str"" + oldName + ""String_Node_Str"");
            _undoContext.setChildrenUndoable(false);
          }
 catch (          Exception e) {
          }
        }
        if ((_current instanceof Prototype) && ((Prototype)_current).isClassDefinition()) {
          List deferredFrom=((Prototype)_current).getDeferredFrom();
          if (deferredFrom != null) {
            Iterator deferrers=deferredFrom.iterator();
            while (deferrers.hasNext()) {
              WeakReference reference=(WeakReference)deferrers.next();
              Prototype deferrer=(Prototype)reference.get();
              if (deferrer != null) {
                String replacementName=newName;
                if (deferrer.isClassDefinition()) {
                  if (deferrer.getMoMLInfo().superclass.startsWith(""String_Node_Str"")) {
                    replacementName=_current.getFullName();
                  }
                  deferrer.getMoMLInfo().superclass=replacementName;
                }
 else {
                  if (deferrer.getMoMLInfo().className.startsWith(""String_Node_Str"")) {
                    replacementName=_current.getFullName();
                  }
                  deferrer.getMoMLInfo().className=replacementName;
                }
              }
            }
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      UnlinkRequest request=new UnlinkRequest(portName,relationName,indexSpec,insideIndexSpec);
      if (_linkRequests != null) {
        _linkRequests.add(request);
      }
 else {
        request.execute();
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex previous=(Vertex)_current.getAttribute(vertexName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getExpression();
      }
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null) {
        vertex.setExpression(value);
        _paramsToParse.add(vertex);
      }
      _pushContext();
      _current=vertex;
      _namespace=_DEFAULT_NAMESPACE;
      if (undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + vertexName + ""String_Node_Str"");
        if (previousValue != null) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + previousValue + ""String_Node_Str"");
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
      }
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex.getTargetException());
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex.getTargetException());
  }
catch (  Exception ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex);
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex);
    }
  }
  _attributes.clear();
  _attributeNameList.clear();
}"
75363,"/** 
 * Create an entity controller associated with the specified graph controller.
 * @param controller The associated graph controller.
 * @param access The access level.
 */
public ActorController(GraphController controller,Access access){
  super(controller,access);
  _access=access;
  if (access == FULL) {
    _portDialogFactory=new PortDialogFactory();
    _menuFactory.addMenuItemFactory(_portDialogFactory);
  }
  if (_configuration != null) {
    _menuFactory.addMenuItemFactory(new MenuActionFactory(_lookInsideAction));
    if (access == FULL) {
      _editIconAction.setConfiguration(_configuration);
      _menuFactory.addMenuItemFactory(new MenuActionFactory(_editIconAction));
      _removeIconAction.setConfiguration(_configuration);
      _menuFactory.addMenuItemFactory(new MenuActionFactory(_removeIconAction));
    }
  }
  _menuFactory.addMenuItemFactory(new MenuActionFactory(new SaveInLibraryAction()));
  _listenToActorAction=new ListenToActorAction((BasicGraphController)getController());
  _menuFactory.addMenuItemFactory(new MenuActionFactory(_listenToActorAction));
  _listenToActorAction.setConfiguration(_configuration);
  if (access == FULL) {
    _breakpointDialogFactory=new BreakpointDialogFactory((BasicGraphController)getController());
    _menuFactory.addMenuItemFactory(_breakpointDialogFactory);
  }
  Filter portFilter=new Filter(){
    public boolean accept(    Object candidate){
      GraphModel model=getController().getGraphModel();
      if (candidate instanceof Locatable && model.getSemanticObject(candidate) instanceof Entity) {
        return true;
      }
 else {
        return false;
      }
    }
  }
;
  GlobalLayout layout=new EntityLayout();
  controller.addGraphViewListener(new IncrementalLayoutListener(new IncrLayoutAdapter(layout){
    public void nodeDrawn(    Object node){
      layout(node);
    }
  }
,portFilter));
}","/** 
 * Create an entity controller associated with the specified graph controller.
 * @param controller The associated graph controller.
 * @param access The access level.
 */
public ActorController(GraphController controller,Access access){
  super(controller,access);
  _access=access;
  if (access == FULL) {
    _portDialogFactory=new PortDialogFactory();
    _menuFactory.addMenuItemFactory(_portDialogFactory);
  }
  if (_configuration != null) {
    _menuFactory.addMenuItemFactory(new MenuActionFactory(_lookInsideAction));
    if (access == FULL) {
      _editIconAction.setConfiguration(_configuration);
      _menuFactory.addMenuItemFactory(new MenuActionFactory(_editIconAction));
      _removeIconAction.setConfiguration(_configuration);
      _menuFactory.addMenuItemFactory(new MenuActionFactory(_removeIconAction));
    }
  }
  _menuFactory.addMenuItemFactory(new MenuActionFactory(new SaveInLibraryAction()));
  _listenToActorAction=new ListenToActorAction((BasicGraphController)getController());
  _menuFactory.addMenuItemFactory(new MenuActionFactory(_listenToActorAction));
  _listenToActorAction.setConfiguration(_configuration);
  if (access == FULL) {
    _breakpointDialogFactory=new BreakpointDialogFactory((BasicGraphController)getController());
    _menuFactory.addMenuItemFactory(_breakpointDialogFactory);
  }
}"
75364,"/** 
 * Create an entity controller associated with the specified graph controller with full access.
 * @param controller The associated graph controller.
 */
public ActorInstanceController(GraphController controller){
  super(controller,FULL);
  _menuFactory.addMenuItemFactory(new MenuActionFactory(_convertToClassAction));
}","/** 
 * Create an entity controller associated with the specified graph controller with the specified access.
 * @param controller The associated graph controller.
 */
public ActorInstanceController(GraphController controller,Access access){
  super(controller,access);
  if (access == FULL) {
    _menuFactory.addMenuItemFactory(new MenuActionFactory(_convertToClassAction));
  }
  Filter portFilter=new Filter(){
    public boolean accept(    Object candidate){
      GraphModel model=getController().getGraphModel();
      Object semanticObject=model.getSemanticObject(candidate);
      if (candidate instanceof Locatable && semanticObject instanceof Entity && !((Entity)semanticObject).isClassDefinition()) {
        return true;
      }
 else {
        return false;
      }
    }
  }
;
  GlobalLayout layout=new EntityLayout();
  controller.addGraphViewListener(new IncrementalLayoutListener(new IncrLayoutAdapter(layout){
    public void nodeDrawn(    Object node){
      layout(node);
    }
  }
,portFilter));
}"
75365,"public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  NamedObj object=getTarget();
  NamedObj container=(NamedObj)object.getContainer();
  StringBuffer moml=new StringBuffer();
  if (!((Prototype)object).isClassDefinition()) {
    moml.append(""String_Node_Str"" + object.getName() + ""String_Node_Str"");
  }
 else {
  }
  MoMLChangeRequest request=new MoMLChangeRequest(this,container,moml.toString());
  container.requestChange(request);
}","public void actionPerformed(ActionEvent e){
  if (_access != FULL) {
    return;
  }
  super.actionPerformed(e);
  NamedObj object=getTarget();
  NamedObj container=(NamedObj)object.getContainer();
  StringBuffer moml=new StringBuffer();
  if (!((Prototype)object).isClassDefinition()) {
    moml.append(""String_Node_Str"" + object.getName() + ""String_Node_Str"");
  }
 else {
  }
  MoMLChangeRequest request=new MoMLChangeRequest(this,container,moml.toString());
  container.requestChange(request);
}"
75366,"/** 
 * Create the controllers for nodes in this graph. In this base class, controllers with PARTIAL access are created. This is called by the constructor, so derived classes that override this must be careful not to reference local variables defined in the derived classes, because the derived classes will not have been fully constructed by the time this is called.
 */
protected void _createControllers(){
  super._createControllers();
  _attributeController=new AttributeController(this,AttributeController.PARTIAL);
  _classDefinitionController=new ActorController(this,AttributeController.PARTIAL);
  _entityController=new ActorController(this,AttributeController.PARTIAL);
  _entityPortController=new IOPortController(this,AttributeController.PARTIAL);
  _relationController=new RelationController(this);
  _linkController=new LinkController(this);
}","/** 
 * Create the controllers for nodes in this graph. In this base class, controllers with PARTIAL access are created. This is called by the constructor, so derived classes that override this must be careful not to reference local variables defined in the derived classes, because the derived classes will not have been fully constructed by the time this is called.
 */
protected void _createControllers(){
  super._createControllers();
  _attributeController=new AttributeController(this,AttributeController.PARTIAL);
  _classDefinitionController=new ClassDefinitionController(this,AttributeController.PARTIAL);
  _entityController=new ActorInstanceController(this,AttributeController.PARTIAL);
  _entityPortController=new IOPortController(this,AttributeController.PARTIAL);
  _relationController=new RelationController(this);
  _linkController=new LinkController(this);
}"
75367,"/** 
 * Return the node controller appropriate for the given object. If the object is an instance of Vertex, then return the local relation controller.  If it implements Locatable, then determine whether it is an Entity, Attribute, or Port, and return the appropriate default controller. If the argument is an instance of Port, then return the local port controller.
 * @param object A Vertex, Locatable, or Port.
 */
public NodeController getNodeController(Object object){
  NodeController result=super.getNodeController(object);
  if (result != null) {
    return result;
  }
  if (object instanceof Vertex) {
    return _relationController;
  }
 else   if (object instanceof Locatable) {
    Object semanticObject=getGraphModel().getSemanticObject(object);
    if (semanticObject instanceof Entity) {
      if (((Entity)semanticObject).isClassDefinition()) {
        return _classDefinitionController;
      }
 else {
        return _entityController;
      }
    }
 else     if (semanticObject instanceof Attribute) {
      return _attributeController;
    }
 else     if (semanticObject instanceof Port) {
      return _portController;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + semanticObject);
    }
  }
 else   if (object instanceof Port) {
    return _entityPortController;
  }
  throw new RuntimeException(""String_Node_Str"" + object);
}","/** 
 * Return the node controller appropriate for the given object. If the object is an instance of Vertex, then return the local relation controller.  If it implements Locatable, then determine whether it is an Entity, Attribute, or Port, and return the appropriate default controller. If the argument is an instance of Port, then return the local port controller.
 * @param object A Vertex, Locatable, or Port.
 */
public NodeController getNodeController(Object object){
  NodeController result=super.getNodeController(object);
  if (result != null) {
    return result;
  }
  if (object instanceof Vertex) {
    return _relationController;
  }
 else   if (object instanceof Locatable) {
    Object semanticObject=getGraphModel().getSemanticObject(object);
    if (semanticObject instanceof Entity) {
      if (_classDefinitionController != null && ((Entity)semanticObject).isClassDefinition()) {
        return _classDefinitionController;
      }
 else {
        return _entityController;
      }
    }
 else     if (semanticObject instanceof Attribute) {
      return _attributeController;
    }
 else     if (semanticObject instanceof Port) {
      return _portController;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + semanticObject);
    }
  }
 else   if (object instanceof Port) {
    return _entityPortController;
  }
  throw new RuntimeException(""String_Node_Str"" + object);
}"
75368,"/** 
 * Specify the container, adding the entity to the list of entities in the container.  If the container already contains an entity with the same name, then throw an exception and do not make any changes.  Similarly, if the container is not in the same workspace as this entity, throw an exception.  If this entity is a class element and the proposed container does not match the current container, then also throw an exception. If the entity is already contained by the container, do nothing. If this entity already has a container, remove it from that container first.  Otherwise, remove it from the directory of the workspace, if it is present. If the argument is null, then unlink the ports of the entity from any relations and remove it from its container. It is not added to the workspace directory, so this could result in this entity being garbage collected. Derived classes may further constrain the container to subclasses of CompositeEntity by overriding the protected method _checkContainer(). This method validates all deeply contained instances of Settable, since they may no longer be valid in the new context.  This method is write-synchronized to the workspace and increments its version number.
 * @param container The proposed container.
 * @exception IllegalActionException If the action would result in arecursive containment structure, or if this entity and container are not in the same workspace, or if the protected method _checkContainer() throws it, or if a contained Settable becomes invalid and the error handler throws it.
 * @exception NameDuplicationException If the name of this entitycollides with a name already in the container.
 * @see #isClassElement()
 */
public void setContainer(Prototype container) throws IllegalActionException, NameDuplicationException {
  if (container != null && _workspace != container.workspace()) {
    throw new IllegalActionException(this,container,""String_Node_Str"");
  }
  try {
    _workspace.getWriteAccess();
    _checkContainer(container);
    CompositeEntity previousContainer=(CompositeEntity)getContainer();
    if (previousContainer == container)     return;
    if (container != null) {
      ((CompositeEntity)container)._addEntity(this);
      if (previousContainer == null) {
        _workspace.remove(this);
      }
    }
    super.setContainer(container);
    if (previousContainer != null) {
      previousContainer._removeEntity(this);
    }
    if (container == null) {
      Iterator ports=portList().iterator();
      while (ports.hasNext()) {
        Port port=(Port)ports.next();
        port.unlinkAll();
      }
    }
 else {
      ((CompositeEntity)container)._finishedAddEntity(this);
      setModifiedFromClass(true);
    }
    validateSettables();
  }
  finally {
    _workspace.doneWriting();
  }
}","/** 
 * Backward compatibility form of this method. Before the existence of the Prototype class, the argument to setContainer() was a CompositeEntity.  Subclasses override that method. So that they continue to work, this method is provided to bridge the two.
 * @param container The proposed container.
 * @exception IllegalActionException If the action would result in arecursive containment structure, or if this entity and container are not in the same workspace, or if the protected method _checkContainer() throws it, or if a contained Settable becomes invalid and the error handler throws it.
 * @exception NameDuplicationException If the name of this entitycollides with a name already in the container.
 * @see #isClassElement()
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  setContainer((Prototype)container);
}"
75369,"/** 
 * Query the user for a filename, save the model to that file, and open a new window to view the model. This overrides the base class to update the entry in the ModelDirectory and to rename the model to match the file name.
 * @return True if the save succeeds.
 */
protected boolean _saveAs(){
  if (_tableau == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
  JFileChooser fileDialog=new JFileChooser();
  if (_fileFilter != null) {
    fileDialog.addChoosableFileFilter(_fileFilter);
  }
  fileDialog.setDialogTitle(""String_Node_Str"");
  if (_directory != null) {
    fileDialog.setCurrentDirectory(_directory);
  }
 else {
    String currentWorkingDirectory=StringUtilities.getProperty(""String_Node_Str"");
    if (currentWorkingDirectory != null) {
      fileDialog.setCurrentDirectory(new File(currentWorkingDirectory));
    }
  }
  if (_initialSaveAsFileName != null) {
    fileDialog.setSelectedFile(new File(fileDialog.getCurrentDirectory(),_initialSaveAsFileName));
  }
  int returnVal=fileDialog.showSaveDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    File file=fileDialog.getSelectedFile();
    try {
      URL newURL=file.toURL();
      String newKey=newURL.toExternalForm();
      Effigy previousOpen=getDirectory().getEffigy(newKey);
      if (previousOpen != null) {
        if (previousOpen.isModified()) {
          previousOpen.showTableaux();
          String confirm=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
          int selected=JOptionPane.showOptionDialog(this,confirm,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
          if (selected == 1) {
            return false;
          }
          previousOpen.setModified(false);
        }
        previousOpen.closeTableaux();
      }
      if (file.exists()) {
        String query=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
        int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
        if (selected == 1) {
          return false;
        }
      }
      _directory=fileDialog.getCurrentDirectory();
      _writeFile(file);
      getConfiguration().openModel(newURL,newURL,newKey);
      Effigy effigy=getEffigy();
      if (effigy != null) {
        String id=effigy.identifier.getExpression();
        if (id.equals(""String_Node_Str"")) {
          effigy.setContainer(null);
        }
      }
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
      return false;
    }
  }
  return true;
}","/** 
 * Query the user for a filename, save the model to that file, and open a new window to view the model. This overrides the base class to update the entry in the ModelDirectory and to rename the model to match the file name.
 * @return True if the save succeeds.
 */
protected boolean _saveAs(){
  if (_tableau == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
  JFileChooser fileDialog=new JFileChooser();
  if (_fileFilter != null) {
    fileDialog.addChoosableFileFilter(_fileFilter);
  }
  fileDialog.setDialogTitle(""String_Node_Str"");
  if (_directory != null) {
    fileDialog.setCurrentDirectory(_directory);
  }
 else {
    String currentWorkingDirectory=StringUtilities.getProperty(""String_Node_Str"");
    if (currentWorkingDirectory != null) {
      fileDialog.setCurrentDirectory(new File(currentWorkingDirectory));
    }
  }
  if (_initialSaveAsFileName != null) {
    fileDialog.setSelectedFile(new File(fileDialog.getCurrentDirectory(),_initialSaveAsFileName));
  }
  int returnVal=fileDialog.showSaveDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    File file=fileDialog.getSelectedFile();
    try {
      URL newURL=file.toURL();
      String newKey=newURL.toExternalForm();
      Effigy previousOpen=getDirectory().getEffigy(newKey);
      if (previousOpen != null && previousOpen != getEffigy()) {
        if (previousOpen.isModified()) {
          previousOpen.showTableaux();
          String confirm=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
          int selected=JOptionPane.showOptionDialog(this,confirm,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
          if (selected == 1) {
            return false;
          }
          previousOpen.setModified(false);
        }
        previousOpen.closeTableaux();
      }
      if (file.exists()) {
        String query=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
        int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
        if (selected == 1) {
          return false;
        }
      }
      _directory=fileDialog.getCurrentDirectory();
      _writeFile(file);
      getConfiguration().openModel(newURL,newURL,newKey);
      Effigy effigy=getEffigy();
      if (effigy != null) {
        String id=effigy.identifier.getExpression();
        if (id.equals(""String_Node_Str"")) {
          effigy.setContainer(null);
        }
      }
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
      return false;
    }
  }
  return true;
}"
75370,"/** 
 * Output an absent value by calling the sendClear() method of the output port.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  output.sendClear(0);
}","/** 
 * Output an absent value by calling the sendClear() method of the output port.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  output.sendClear(0);
}"
75371,"/** 
 * Return a new array that is a copy of the array argument.
 * @param matrix An array of ints.
 * @return A new array of ints.
 */
public static final double[] allocCopy(final double[] array){
  int elements=array.length;
  double[] newArray=new double[elements];
  System.arraycopy(array,0,newArray,0,elements);
  return newArray;
}","/** 
 * Return a new array that is a copy of the array argument.
 * @param array An array of ints.
 * @return A new array of ints.
 */
public static final double[] allocCopy(final double[] array){
  int elements=array.length;
  double[] newArray=new double[elements];
  System.arraycopy(array,0,newArray,0,elements);
  return newArray;
}"
75372,"/** 
 * Return a new array that is formed by converting the doubles in the argument array to complex numbers. Each complex number has real part equal to the value in the argument matrix and a zero imaginary part.
 * @param array An array of double.
 * @return A new array of complex numbers.
 */
public static final Complex[] toComplexArray(final double[] array){
  int length=array.length;
  Complex[] returnValue=new Complex[length];
  for (int i=0; i < length; i++) {
    returnValue[i]=new Complex(array[i],0.0);
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by converting the doubles in the argument array to complex numbers. Each complex number has real part equal to the value in the argument array and a zero imaginary part.
 * @param array An array of double.
 * @return A new array of complex numbers.
 */
public static final Complex[] toComplexArray(final double[] array){
  int length=array.length;
  Complex[] returnValue=new Complex[length];
  for (int i=0; i < length; i++) {
    returnValue[i]=new Complex(array[i],0.0);
  }
  return returnValue;
}"
75373,"/** 
 * Return a new array that is a copy of the array argument.
 * @param matrix An array of ints.
 * @return A new array of ints.
 */
public static final int[] allocCopy(final int[] array){
  int elements=array.length;
  int[] newArray=new int[elements];
  System.arraycopy(array,0,newArray,0,elements);
  return newArray;
}","/** 
 * Return a new array that is a copy of the array argument.
 * @param array An array of ints.
 * @return A new array of ints.
 */
public static final int[] allocCopy(final int[] array){
  int elements=array.length;
  int[] newArray=new int[elements];
  System.arraycopy(array,0,newArray,0,elements);
  return newArray;
}"
75374,"/** 
 * Return a new array that is formed by converting the integers in the argument array to complex numbers. Each complex number has real part equal to the value in the argument matrix and a zero imaginary part.
 * @param array An array of integers.
 * @return A new array of complex numbers.
 */
public static final Complex[] toComplexArray(final int[] array){
  int length=array.length;
  Complex[] returnValue=new Complex[length];
  for (int i=0; i < length; i++) {
    returnValue[i]=new Complex((double)array[i],0.0);
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by converting the integers in the argument array to complex numbers. Each complex number has real part equal to the value in the argument array and a zero imaginary part.
 * @param array An array of integers.
 * @return A new array of complex numbers.
 */
public static final Complex[] toComplexArray(final int[] array){
  int length=array.length;
  Complex[] returnValue=new Complex[length];
  for (int i=0; i < length; i++) {
    returnValue[i]=new Complex((double)array[i],0.0);
  }
  return returnValue;
}"
75375,"/** 
 * Return a new array that is a copy of the array argument.
 * @param matrix An array of ints.
 * @return A new array of ints.
 */
public static final long[] allocCopy(final long[] array){
  int elements=array.length;
  long[] newArray=new long[elements];
  System.arraycopy(array,0,newArray,0,elements);
  return newArray;
}","/** 
 * Return a new array that is a copy of the array argument.
 * @param array An array of ints.
 * @return A new array of ints.
 */
public static final long[] allocCopy(final long[] array){
  int elements=array.length;
  long[] newArray=new long[elements];
  System.arraycopy(array,0,newArray,0,elements);
  return newArray;
}"
75376,"/** 
 * Return a new array that is formed by converting the long numbers in the argument array to complex numbers. Each complex number has real part equal to the value in the argument matrix and a zero imaginary part.
 * @param array An array of long numbers.
 * @return A new array of complex numbers.
 */
public static final Complex[] toComplexArray(final long[] array){
  int length=array.length;
  Complex[] returnValue=new Complex[length];
  for (int i=0; i < length; i++) {
    returnValue[i]=new Complex((double)array[i],0.0);
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by converting the long numbers in the argument array to complex numbers. Each complex number has real part equal to the value in the argument array and a zero imaginary part.
 * @param array An array of long numbers.
 * @return A new array of complex numbers.
 */
public static final Complex[] toComplexArray(final long[] array){
  int length=array.length;
  Complex[] returnValue=new Complex[length];
  for (int i=0; i < length; i++) {
    returnValue[i]=new Complex((double)array[i],0.0);
  }
  return returnValue;
}"
75377,"/** 
 * Apply the changes by renaming the object.
 */
public void apply(){
  if (_changed) {
    String newName=getStringValue(""String_Node_Str"");
    NamedObj parent=MoMLChangeRequest.getDeferredToParent(_object);
    if (parent == null) {
      parent=(NamedObj)_object.getContainer();
    }
    String oldName=_object.getName(parent);
    StringBuffer moml=new StringBuffer(""String_Node_Str"");
    String elementName=""String_Node_Str"";
    if (_object instanceof Port) {
      elementName=""String_Node_Str"";
    }
 else     if (_object instanceof Attribute) {
      elementName=""String_Node_Str"";
    }
 else     if (_object instanceof Relation) {
      elementName=""String_Node_Str"";
    }
    moml.append(elementName);
    moml.append(""String_Node_Str"");
    moml.append(oldName);
    moml.append(""String_Node_Str"");
    moml.append(newName);
    moml.append(""String_Node_Str"");
    boolean showName=getBooleanValue(""String_Node_Str"");
    if (_object instanceof Port) {
      if (showName) {
        moml.append(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        if (_object.getAttribute(""String_Node_Str"") != null) {
          moml.append(""String_Node_Str"");
        }
      }
    }
 else {
      if (showName) {
        if (_object.getAttribute(""String_Node_Str"") != null) {
          moml.append(""String_Node_Str"");
        }
      }
 else {
        moml.append(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    moml.append(""String_Node_Str"");
    moml.append(elementName);
    moml.append(""String_Node_Str"");
    MoMLChangeRequest request=new MoMLChangeRequest(this,parent,moml.toString(),null);
    request.addChangeListener(this);
    request.setUndoable(true);
    parent.requestChange(request);
  }
}","/** 
 * Apply the changes by renaming the object.
 */
public void apply(){
  if (_changed) {
    String newName=getStringValue(""String_Node_Str"");
    NamedObj parent=MoMLChangeRequest.getDeferredToParent((NamedObj)_object.getContainer());
    if (parent == null) {
      parent=(NamedObj)_object.getContainer();
    }
    String oldName=_object.getName(parent);
    StringBuffer moml=new StringBuffer(""String_Node_Str"");
    String elementName=""String_Node_Str"";
    if (_object instanceof Port) {
      elementName=""String_Node_Str"";
    }
 else     if (_object instanceof Attribute) {
      elementName=""String_Node_Str"";
    }
 else     if (_object instanceof Relation) {
      elementName=""String_Node_Str"";
    }
    moml.append(elementName);
    moml.append(""String_Node_Str"");
    moml.append(oldName);
    moml.append(""String_Node_Str"");
    moml.append(newName);
    moml.append(""String_Node_Str"");
    boolean showName=getBooleanValue(""String_Node_Str"");
    if (_object instanceof Port) {
      if (showName) {
        moml.append(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        if (_object.getAttribute(""String_Node_Str"") != null) {
          moml.append(""String_Node_Str"");
        }
      }
    }
 else {
      if (showName) {
        if (_object.getAttribute(""String_Node_Str"") != null) {
          moml.append(""String_Node_Str"");
        }
      }
 else {
        moml.append(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    moml.append(""String_Node_Str"");
    moml.append(elementName);
    moml.append(""String_Node_Str"");
    MoMLChangeRequest request=new MoMLChangeRequest(this,parent,moml.toString(),null);
    request.addChangeListener(this);
    request.setUndoable(true);
    parent.requestChange(request);
  }
}"
75378,"private Set _findJarFiles(Director director) throws IOException {
  Map classMap=_allAtomicEntityJars();
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  classMap.put(director.getClass().getName(),_domainJar);
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  HashSet jarFilesThatHaveBeenRequired=new HashSet();
  jarFilesThatHaveBeenRequired.add(""String_Node_Str"");
  jarFilesThatHaveBeenRequired.add(""String_Node_Str"");
  boolean fixJarFiles=false;
  Iterator classNames=classMap.keySet().iterator();
  while (classNames.hasNext()) {
    String className=(String)classNames.next();
    if (jarFilesThatHaveBeenRequired.contains((String)classMap.get(className))) {
      continue;
    }
    if (!_copyPotentialJarFile((String)classMap.get(className),className,jarFilesThatHaveBeenRequired)) {
      String classResource=ClassUtilities.lookupClassAsResource(className);
      if (classResource == null) {
        throw new IOException(""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      classResource=StringUtilities.substitute(classResource,""String_Node_Str"",""String_Node_Str"");
      String canonicalClassResource=UtilityFunctions.findFile(classResource);
      String canonicalPtIIDirectory=UtilityFunctions.findFile(_ptIIDirectory);
      if (canonicalClassResource.equals(canonicalPtIIDirectory)) {
        String pathName=className.replace('.','/');
        String directoryName=pathName.substring(0,pathName.lastIndexOf(""String_Node_Str""));
        String jarFileName=directoryName + ""String_Node_Str"" + directoryName.substring(directoryName.lastIndexOf(""String_Node_Str""))+ ""String_Node_Str"";
        if (_copyPotentialJarFile(jarFileName,className,jarFilesThatHaveBeenRequired)) {
        }
 else {
          String warning=""String_Node_Str"" + className + ""String_Node_Str""+ _ptIIDirectory+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
          if (_codeBase.equals(""String_Node_Str"")) {
            throw new IOException(warning + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"" + warning + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            fixJarFiles=true;
            continue;
          }
        }
      }
    }
  }
  jarFilesThatHaveBeenRequired.remove(""String_Node_Str"");
  jarFilesThatHaveBeenRequired.remove(""String_Node_Str"");
  File potentialDomainJarFile=new File(_ptIIDirectory,_domainJar);
  if (!potentialDomainJarFile.exists()) {
    System.out.println(""String_Node_Str"" + _domainJar + ""String_Node_Str""+ potentialDomainJarFile+ ""String_Node_Str""+ ""String_Node_Str"");
    jarFilesThatHaveBeenRequired.add(""String_Node_Str"");
  }
  if (fixJarFiles) {
    jarFilesThatHaveBeenRequired.add(""String_Node_Str"");
    jarFilesThatHaveBeenRequired.add(_domainJar);
  }
  return jarFilesThatHaveBeenRequired;
}","private Set _findJarFiles(Director director) throws IOException {
  Map classMap=_allAtomicEntityJars();
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  classMap.put(director.getClass().getName(),_domainJar);
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  classMap.put(""String_Node_Str"",""String_Node_Str"");
  HashSet jarFilesThatHaveBeenRequired=new HashSet();
  jarFilesThatHaveBeenRequired.add(""String_Node_Str"");
  jarFilesThatHaveBeenRequired.add(""String_Node_Str"");
  boolean fixJarFiles=false;
  Iterator classNames=classMap.keySet().iterator();
  while (classNames.hasNext()) {
    String className=(String)classNames.next();
    if (jarFilesThatHaveBeenRequired.contains((String)classMap.get(className))) {
      continue;
    }
    if (!_copyPotentialJarFile((String)classMap.get(className),className,jarFilesThatHaveBeenRequired)) {
      String classResource=ClassUtilities.lookupClassAsResource(className);
      if (classResource == null) {
        throw new IOException(""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      classResource=StringUtilities.substitute(classResource,""String_Node_Str"",""String_Node_Str"");
      String canonicalClassResource=UtilityFunctions.findFile(classResource);
      String canonicalPtIIDirectory=UtilityFunctions.findFile(_ptIIDirectory);
      if (canonicalClassResource.equals(canonicalPtIIDirectory)) {
        String pathName=className.replace('.','/');
        String directoryName=pathName.substring(0,pathName.lastIndexOf(""String_Node_Str""));
        String jarFileName=directoryName + directoryName.substring(directoryName.lastIndexOf(""String_Node_Str"")) + ""String_Node_Str"";
        if (_copyPotentialJarFile(jarFileName,className,jarFilesThatHaveBeenRequired)) {
        }
 else {
          String warning=""String_Node_Str"" + className + ""String_Node_Str""+ _ptIIDirectory+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
          if (_codeBase.equals(""String_Node_Str"")) {
            throw new IOException(warning + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"" + warning + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            fixJarFiles=true;
            continue;
          }
        }
      }
    }
  }
  jarFilesThatHaveBeenRequired.remove(""String_Node_Str"");
  jarFilesThatHaveBeenRequired.remove(""String_Node_Str"");
  File potentialDomainJarFile=new File(_ptIIDirectory,_domainJar);
  if (!potentialDomainJarFile.exists()) {
    System.out.println(""String_Node_Str"" + _domainJar + ""String_Node_Str""+ potentialDomainJarFile+ ""String_Node_Str""+ ""String_Node_Str"");
    jarFilesThatHaveBeenRequired.add(""String_Node_Str"");
  }
  if (fixJarFiles) {
    jarFilesThatHaveBeenRequired.add(""String_Node_Str"");
    jarFilesThatHaveBeenRequired.add(_domainJar);
  }
  return jarFilesThatHaveBeenRequired;
}"
75379,"/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, and there are no other tableaux in the parent effigy or any effigy that contains it, then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (getEffigy() == null) {
    return super._close();
  }
  Effigy topEffigy=getEffigy().topEffigy();
  List tableaux=topEffigy.entityList(Tableau.class);
  Iterator tableauxIterator=tableaux.iterator();
  while (tableauxIterator.hasNext()) {
    Tableau tableau=(Tableau)tableauxIterator.next();
    if (!(tableau instanceof DialogTableau) && (tableau != _tableau)) {
      dispose();
      return true;
    }
  }
  return super._close();
}","/** 
 * Close the window.  Derived classes should override this to release any resources or remove any listeners.  In this class, if the data associated with this window has been modified, and there are no other tableaux in the parent effigy or any effigy that contains it, then ask the user whether to save the data before closing.
 * @return False if the user cancels on a save query.
 */
protected boolean _close(){
  if (getEffigy() == null) {
    return super._close();
  }
  Effigy topEffigy=getEffigy().topEffigy();
  if (!_tableau.isMaster()) {
    List tableaux=topEffigy.entityList(Tableau.class);
    Iterator tableauxIterator=tableaux.iterator();
    while (tableauxIterator.hasNext()) {
      Tableau tableau=(Tableau)tableauxIterator.next();
      if (!(tableau instanceof DialogTableau) && (tableau != _tableau)) {
        dispose();
        return true;
      }
    }
  }
  return super._close();
}"
75380,"/** 
 * Set the size of the specified component to match the current value of the attribute.  If the value of the attribute has not been set, then do nothing.
 * @param component The component whose size is to be set.
 * @return True if successful.
 */
public boolean setSize(Component component){
  try {
    IntMatrixToken token=(IntMatrixToken)getToken();
    if (token != null) {
      int width=token.getElementAt(0,0);
      int height=token.getElementAt(0,1);
      Dimension dimension=new Dimension(width,height);
      component.setSize(dimension);
      if (component instanceof JComponent) {
        ((JComponent)component).setPreferredSize(dimension);
        ((JComponent)component).setMinimumSize(dimension);
      }
    }
    return true;
  }
 catch (  Exception ex) {
    return false;
  }
}","/** 
 * Set the size of the specified component to match the current value of the attribute.  If the value of the attribute has not been set, then do nothing.  If it has not already done so, this method also registers with the component as a listener for component events like resizing.
 * @param component The component whose size is to be set.
 * @return True if successful.
 */
public boolean setSize(Component component){
  if (_listeningTo != component) {
    if (_listeningTo != null) {
      _listeningTo.removeComponentListener(this);
    }
    component.addComponentListener(this);
    _listeningTo=component;
  }
  try {
    IntMatrixToken token=(IntMatrixToken)getToken();
    if (token != null) {
      int width=token.getElementAt(0,0);
      int height=token.getElementAt(0,1);
      Dimension dimension=new Dimension(width,height);
      component.setSize(dimension);
      if (component instanceof JComponent) {
        ((JComponent)component).setPreferredSize(dimension);
        ((JComponent)component).setMinimumSize(dimension);
      }
    }
    return true;
  }
 catch (  Exception ex) {
    return false;
  }
}"
75381,"/** 
 * Set the value of the attribute to match those of the specified component.
 * @param component The component whose size is to be recorded.
 */
public void recordSize(Component component){
  try {
    Rectangle bounds=component.getBounds();
    int[][] boundsMatrix=new int[1][2];
    boundsMatrix[0][0]=bounds.width;
    boundsMatrix[0][1]=bounds.height;
    IntMatrixToken token=new IntMatrixToken(boundsMatrix);
    setToken(token);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"");
  }
}","/** 
 * Set the value of the attribute to match those of the specified component.
 * @param component The component whose size is to be recorded.
 */
public void recordSize(Component component){
  try {
    Rectangle bounds=component.getBounds();
    int[][] boundsMatrix=new int[1][2];
    boundsMatrix[0][0]=bounds.width;
    boundsMatrix[0][1]=bounds.height;
    IntMatrixToken token=new IntMatrixToken(boundsMatrix);
    setToken(token);
    setClassElement(false);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"");
  }
}"
75382,"/** 
 * Set the properties of the specified frame to match the current value of the attribute.  If the value of the attribute has not been set, then do nothing and return true. If the value of this attribute is malformed in any way, then just return false.
 * @param frame The frame whose properties are to be set.
 * @return True if successful.
 */
public boolean setProperties(Frame frame){
  try {
    RecordToken value=(RecordToken)getToken();
    if (value == null)     return true;
    ArrayToken boundsToken=(ArrayToken)value.get(""String_Node_Str"");
    int x=((IntToken)boundsToken.getElement(0)).intValue();
    int y=((IntToken)boundsToken.getElement(1)).intValue();
    int width=((IntToken)boundsToken.getElement(2)).intValue();
    int height=((IntToken)boundsToken.getElement(3)).intValue();
    frame.setBounds(x,y,width,height);
    if (frame instanceof Top) {
      ((Top)frame).setCentering(false);
    }
    return true;
  }
 catch (  Exception ex) {
    return false;
  }
}","/** 
 * Set the properties of the specified frame to match the current value of the attribute.  If the value of the attribute has not been set, then do nothing and return true. If the value of this attribute is malformed in any way, then just return false.
 * @param frame The frame whose properties are to be set.
 * @return True if successful.
 */
public boolean setProperties(Frame frame){
  if (_listeningTo != frame) {
    if (_listeningTo != null) {
      _listeningTo.removeComponentListener(this);
    }
    frame.addComponentListener(this);
    _listeningTo=frame;
  }
  try {
    RecordToken value=(RecordToken)getToken();
    if (value == null)     return true;
    ArrayToken boundsToken=(ArrayToken)value.get(""String_Node_Str"");
    BooleanToken maximizedToken=(BooleanToken)value.get(""String_Node_Str"");
    int x=((IntToken)boundsToken.getElement(0)).intValue();
    int y=((IntToken)boundsToken.getElement(1)).intValue();
    int width=((IntToken)boundsToken.getElement(2)).intValue();
    int height=((IntToken)boundsToken.getElement(3)).intValue();
    frame.setBounds(x,y,width,height);
    if (maximizedToken != null) {
      boolean maximized=maximizedToken.booleanValue();
      if (maximized) {
        frame.setExtendedState(frame.getExtendedState() | Frame.MAXIMIZED_BOTH);
      }
    }
    if (frame instanceof Top) {
      ((Top)frame).setCentering(false);
    }
    return true;
  }
 catch (  Exception ex) {
    return false;
  }
}"
75383,"/** 
 * Set the value of the attribute to match those of the specified frame.
 * @param frame The frame whose properties are to be recorded.
 */
public void recordProperties(Frame frame){
  try {
    Rectangle bounds=frame.getBounds();
    Token[] boundsArray=new IntToken[4];
    boundsArray[0]=new IntToken(bounds.x);
    boundsArray[1]=new IntToken(bounds.y);
    boundsArray[2]=new IntToken(bounds.width);
    boundsArray[3]=new IntToken(bounds.height);
    Token[] values=new Token[1];
    values[0]=new ArrayToken(boundsArray);
    String[] names=new String[1];
    names[0]=""String_Node_Str"";
    setToken(new RecordToken(names,values));
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex);
  }
}","/** 
 * Set the value of the attribute to match those of the specified frame.
 * @param frame The frame whose properties are to be recorded.
 */
public void recordProperties(Frame frame){
  try {
    Rectangle bounds=frame.getBounds();
    Token[] boundsArray=new IntToken[4];
    boundsArray[0]=new IntToken(bounds.x);
    boundsArray[1]=new IntToken(bounds.y);
    boundsArray[2]=new IntToken(bounds.width);
    boundsArray[3]=new IntToken(bounds.height);
    boolean maximized=(frame.getExtendedState() & Frame.MAXIMIZED_BOTH) == Frame.MAXIMIZED_BOTH;
    Token[] values=new Token[2];
    values[0]=new ArrayToken(boundsArray);
    values[1]=new BooleanToken(maximized);
    String[] names=new String[2];
    names[0]=""String_Node_Str"";
    names[1]=""String_Node_Str"";
    setToken(new RecordToken(names,values));
    setClassElement(false);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex);
  }
}"
75384,"/** 
 * Write the model to the specified file.  This overrides the base class to record the current size and position of the window in the model.
 * @param file The file to write to.
 * @exception IOException If the write fails.
 */
protected void _writeFile(File file) throws IOException {
  try {
    Component component=_jgraph.getParent();
    Component parent=component.getParent();
    while (parent != null && !(parent instanceof Frame)) {
      component=parent;
      parent=component.getParent();
    }
    if (parent instanceof Frame) {
      WindowPropertiesAttribute properties=(WindowPropertiesAttribute)getModel().getAttribute(""String_Node_Str"",WindowPropertiesAttribute.class);
      if (properties == null) {
        properties=new WindowPropertiesAttribute(getModel(),""String_Node_Str"");
      }
      properties.recordProperties((Frame)parent);
    }
    SizeAttribute size=(SizeAttribute)getModel().getAttribute(""String_Node_Str"",SizeAttribute.class);
    if (size == null) {
      size=new SizeAttribute(getModel(),""String_Node_Str"");
    }
    size.recordSize(_jgraph);
  }
 catch (  Exception ex) {
  }
  super._writeFile(file);
}","/** 
 * Write the model to the specified file.  This overrides the base class to record the current size and position of the window in the model.
 * @param file The file to write to.
 * @exception IOException If the write fails.
 */
protected void _writeFile(File file) throws IOException {
  try {
    Component component=_jgraph.getParent();
    Component parent=component.getParent();
    while (parent != null && !(parent instanceof Frame)) {
      component=parent;
      parent=component.getParent();
    }
    if (parent instanceof Frame) {
      WindowPropertiesAttribute properties=(WindowPropertiesAttribute)getModel().getAttribute(""String_Node_Str"",WindowPropertiesAttribute.class);
      if (properties == null) {
        properties=new WindowPropertiesAttribute(getModel(),""String_Node_Str"");
      }
      properties.recordProperties((Frame)parent);
    }
    SizeAttribute size=(SizeAttribute)getModel().getAttribute(""String_Node_Str"",SizeAttribute.class);
    if (size == null) {
      size=new SizeAttribute(getModel(),""String_Node_Str"");
    }
    size.recordSize(_jgraph);
    JCanvas canvas=_jgraph.getGraphPane().getCanvas();
    AffineTransform current=canvas.getCanvasPane().getTransformContext().getTransform();
    double scale=current.getScaleX();
    Parameter zoom=(Parameter)getModel().getAttribute(""String_Node_Str"",Parameter.class);
    if (zoom == null) {
      zoom=new Parameter(getModel(),""String_Node_Str"");
    }
    zoom.setToken(new DoubleToken(scale));
    Point2D center=getCenter();
    Parameter pan=(Parameter)getModel().getAttribute(""String_Node_Str"",Parameter.class);
    if (pan == null) {
      pan=new Parameter(getModel(),""String_Node_Str"");
    }
    Token[] centerArray=new Token[2];
    centerArray[0]=new DoubleToken(center.getX());
    centerArray[1]=new DoubleToken(center.getY());
    pan.setToken(new ArrayToken(centerArray));
  }
 catch (  Exception ex) {
  }
  super._writeFile(file);
}"
75385,"/** 
 * Zoom to fit the current figures.
 */
public void zoomFit(){
  GraphPane pane=_jgraph.getGraphPane();
  Rectangle2D bounds=pane.getForegroundLayer().getLayerBounds();
  if (bounds.isEmpty()) {
    return;
  }
  Rectangle2D viewSize=getVisibleRectangle();
  AffineTransform newTransform=CanvasUtilities.computeFitTransform(bounds,viewSize);
  JCanvas canvas=pane.getCanvas();
  canvas.getCanvasPane().setTransform(newTransform);
  _graphPanner.repaint();
}","/** 
 * Zoom to fit the current figures.
 */
public void zoomFit(){
  GraphPane pane=_jgraph.getGraphPane();
  Rectangle2D bounds=pane.getForegroundLayer().getLayerBounds();
  if (bounds.isEmpty()) {
    return;
  }
  Rectangle2D viewSize=getVisibleRectangle();
  AffineTransform newTransform=CanvasUtilities.computeFitTransform(bounds,viewSize);
  JCanvas canvas=pane.getCanvas();
  canvas.getCanvasPane().setTransform(newTransform);
  if (_graphPanner != null) {
    _graphPanner.repaint();
  }
}"
75386,"/** 
 * Construct a frame associated with the specified Ptolemy II model. After constructing this, it is necessary to call setVisible(true) to make the frame appear. This is typically done by calling show() on the controlling tableau. This constructor results in a graph frame that obtains its library either from the model (if it has one), or the <i>defaultLibrary</i> argument (if it is non-null), or the default library defined in the configuration.
 * @see Tableau#show()
 * @param entity The model to put in this frame.
 * @param tableau The tableau responsible for this frame.
 * @param defaultLibrary An attribute specifying the default libraryto use if the model does not have a library.
 */
public BasicGraphFrame(CompositeEntity entity,Tableau tableau,LibraryAttribute defaultLibrary){
  super(entity,tableau);
  entity.addChangeListener(this);
  getContentPane().setLayout(new BorderLayout());
  GraphPane pane=_createGraphPane();
  pane.getForegroundLayer().setPickHalo(2);
  _jgraph=new JGraph(pane);
  new EditorDropTarget(_jgraph);
  ActionListener deletionListener=new ActionListener(){
    /** 
 * Delete any nodes or edges from the graph that are currently selected.  In addition, delete any edges that are connected to any deleted nodes.
 */
    public void actionPerformed(    ActionEvent e){
      delete();
    }
  }
;
  _jgraph.registerKeyboardAction(deletionListener,""String_Node_Str"",KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,0),JComponent.WHEN_IN_FOCUSED_WINDOW);
  _jgraph.setRequestFocusEnabled(true);
  _jgraph.addMouseListener(new FocusMouseListener());
  _jgraph.setAlignmentX(1);
  _jgraph.setAlignmentY(1);
  _jgraph.setBackground(BACKGROUND_COLOR);
  try {
    SizeAttribute size=(SizeAttribute)getModel().getAttribute(""String_Node_Str"",SizeAttribute.class);
    if (size != null) {
      size.setSize(_jgraph);
    }
 else {
      _jgraph.setMinimumSize(new Dimension(200,200));
      _jgraph.setPreferredSize(new Dimension(600,400));
      _jgraph.setSize(600,400);
    }
  }
 catch (  Exception ex) {
  }
  _graphPanner=new JCanvasPanner(_jgraph);
  _graphPanner.setPreferredSize(new Dimension(200,150));
  _graphPanner.setMaximumSize(new Dimension(200,150));
  _graphPanner.setSize(200,150);
  boolean gotLibrary=false;
  try {
    LibraryAttribute libraryAttribute=(LibraryAttribute)entity.getAttribute(""String_Node_Str"",LibraryAttribute.class);
    if (libraryAttribute != null) {
      _topLibrary=libraryAttribute.getLibrary();
      gotLibrary=true;
    }
  }
 catch (  Exception ex) {
    try {
      MessageHandler.warning(""String_Node_Str"",ex);
    }
 catch (    CancelException e) {
    }
  }
  if (!gotLibrary) {
    try {
      if (defaultLibrary != null) {
        _topLibrary=defaultLibrary.getLibrary();
        gotLibrary=true;
      }
    }
 catch (    Exception ex) {
      try {
        MessageHandler.warning(""String_Node_Str"",ex);
      }
 catch (      CancelException e) {
      }
    }
  }
  if (!gotLibrary) {
    Configuration configuration=getConfiguration();
    if (configuration != null) {
      _topLibrary=(CompositeEntity)configuration.getEntity(""String_Node_Str"");
      if (_topLibrary == null) {
        Workspace workspace=entity.workspace();
        _topLibrary=new CompositeEntity(workspace);
        try {
          _topLibrary.setName(""String_Node_Str"");
          new Attribute(_topLibrary,""String_Node_Str"");
        }
 catch (        Exception ex) {
          throw new InternalErrorException(""String_Node_Str"" + ex);
        }
      }
    }
  }
  _libraryModel=new VisibleTreeModel(_topLibrary);
  _library=new PTree(_libraryModel);
  _library.setRootVisible(false);
  _library.setBackground(BACKGROUND_COLOR);
  _libraryScrollPane=new JScrollPane(_library);
  _libraryScrollPane.setMinimumSize(new Dimension(200,200));
  _libraryScrollPane.setPreferredSize(new Dimension(200,200));
  _palettePane=new JPanel();
  _palettePane.setBorder(null);
  _palettePane.setLayout(new BoxLayout(_palettePane,BoxLayout.Y_AXIS));
  _palettePane.add(_libraryScrollPane,BorderLayout.CENTER);
  _palettePane.add(_graphPanner,BorderLayout.SOUTH);
  _splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true);
  _splitPane.setLeftComponent(_palettePane);
  _splitPane.setRightComponent(_jgraph);
  getContentPane().add(_splitPane,BorderLayout.CENTER);
  _toolbar=new JToolBar();
  getContentPane().add(_toolbar,BorderLayout.NORTH);
  GUIUtilities.addToolBarButton(_toolbar,_zoomInAction);
  GUIUtilities.addToolBarButton(_toolbar,_zoomResetAction);
  GUIUtilities.addToolBarButton(_toolbar,_zoomFitAction);
  GUIUtilities.addToolBarButton(_toolbar,_zoomOutAction);
  _cutAction=new CutAction();
  _copyAction=new CopyAction();
  _pasteAction=new PasteAction();
  _createHierarchyAction=new CreateHierarchyAction();
  _layoutAction=new LayoutAction();
  _saveInLibraryAction=new SaveInLibraryAction();
  _importLibraryAction=new ImportLibraryAction();
  _instantiateEntityAction=new InstantiateEntityAction();
}","/** 
 * Construct a frame associated with the specified Ptolemy II model. After constructing this, it is necessary to call setVisible(true) to make the frame appear. This is typically done by calling show() on the controlling tableau. This constructor results in a graph frame that obtains its library either from the model (if it has one), or the <i>defaultLibrary</i> argument (if it is non-null), or the default library defined in the configuration.
 * @see Tableau#show()
 * @param entity The model to put in this frame.
 * @param tableau The tableau responsible for this frame.
 * @param defaultLibrary An attribute specifying the default libraryto use if the model does not have a library.
 */
public BasicGraphFrame(CompositeEntity entity,Tableau tableau,LibraryAttribute defaultLibrary){
  super(entity,tableau);
  entity.addChangeListener(this);
  getContentPane().setLayout(new BorderLayout());
  GraphPane pane=_createGraphPane();
  pane.getForegroundLayer().setPickHalo(2);
  _jgraph=new JGraph(pane);
  new EditorDropTarget(_jgraph);
  ActionListener deletionListener=new ActionListener(){
    /** 
 * Delete any nodes or edges from the graph that are currently selected.  In addition, delete any edges that are connected to any deleted nodes.
 */
    public void actionPerformed(    ActionEvent e){
      delete();
    }
  }
;
  _jgraph.registerKeyboardAction(deletionListener,""String_Node_Str"",KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,0),JComponent.WHEN_IN_FOCUSED_WINDOW);
  _jgraph.setRequestFocusEnabled(true);
  _jgraph.addMouseListener(new FocusMouseListener());
  _jgraph.setAlignmentX(1);
  _jgraph.setAlignmentY(1);
  _jgraph.setBackground(BACKGROUND_COLOR);
  try {
    SizeAttribute size=(SizeAttribute)getModel().getAttribute(""String_Node_Str"",SizeAttribute.class);
    if (size != null) {
      size.setSize(_jgraph);
    }
 else {
      _jgraph.setMinimumSize(new Dimension(200,200));
      _jgraph.setPreferredSize(new Dimension(600,400));
      _jgraph.setSize(600,400);
    }
    Parameter zoom=(Parameter)getModel().getAttribute(""String_Node_Str"",Parameter.class);
    if (zoom != null) {
      zoom(((DoubleToken)zoom.getToken()).doubleValue());
    }
    Parameter pan=(Parameter)getModel().getAttribute(""String_Node_Str"",Parameter.class);
    if (pan != null) {
      ArrayToken panToken=(ArrayToken)pan.getToken();
      Point2D center=new Point2D.Double(((DoubleToken)panToken.getElement(0)).doubleValue(),((DoubleToken)panToken.getElement(1)).doubleValue());
      setCenter(center);
    }
  }
 catch (  Exception ex) {
  }
  _graphPanner=new JCanvasPanner(_jgraph);
  _graphPanner.setPreferredSize(new Dimension(200,150));
  _graphPanner.setMaximumSize(new Dimension(200,150));
  _graphPanner.setSize(200,150);
  boolean gotLibrary=false;
  try {
    LibraryAttribute libraryAttribute=(LibraryAttribute)entity.getAttribute(""String_Node_Str"",LibraryAttribute.class);
    if (libraryAttribute != null) {
      _topLibrary=libraryAttribute.getLibrary();
      gotLibrary=true;
    }
  }
 catch (  Exception ex) {
    try {
      MessageHandler.warning(""String_Node_Str"",ex);
    }
 catch (    CancelException e) {
    }
  }
  if (!gotLibrary) {
    try {
      if (defaultLibrary != null) {
        _topLibrary=defaultLibrary.getLibrary();
        gotLibrary=true;
      }
    }
 catch (    Exception ex) {
      try {
        MessageHandler.warning(""String_Node_Str"",ex);
      }
 catch (      CancelException e) {
      }
    }
  }
  if (!gotLibrary) {
    Configuration configuration=getConfiguration();
    if (configuration != null) {
      _topLibrary=(CompositeEntity)configuration.getEntity(""String_Node_Str"");
      if (_topLibrary == null) {
        Workspace workspace=entity.workspace();
        _topLibrary=new CompositeEntity(workspace);
        try {
          _topLibrary.setName(""String_Node_Str"");
          new Attribute(_topLibrary,""String_Node_Str"");
        }
 catch (        Exception ex) {
          throw new InternalErrorException(""String_Node_Str"" + ex);
        }
      }
    }
  }
  _libraryModel=new VisibleTreeModel(_topLibrary);
  _library=new PTree(_libraryModel);
  _library.setRootVisible(false);
  _library.setBackground(BACKGROUND_COLOR);
  _libraryScrollPane=new JScrollPane(_library);
  _libraryScrollPane.setMinimumSize(new Dimension(200,200));
  _libraryScrollPane.setPreferredSize(new Dimension(200,200));
  _palettePane=new JPanel();
  _palettePane.setBorder(null);
  _palettePane.setLayout(new BoxLayout(_palettePane,BoxLayout.Y_AXIS));
  _palettePane.add(_libraryScrollPane,BorderLayout.CENTER);
  _palettePane.add(_graphPanner,BorderLayout.SOUTH);
  _splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true);
  _splitPane.setLeftComponent(_palettePane);
  _splitPane.setRightComponent(_jgraph);
  getContentPane().add(_splitPane,BorderLayout.CENTER);
  _toolbar=new JToolBar();
  getContentPane().add(_toolbar,BorderLayout.NORTH);
  GUIUtilities.addToolBarButton(_toolbar,_zoomInAction);
  GUIUtilities.addToolBarButton(_toolbar,_zoomResetAction);
  GUIUtilities.addToolBarButton(_toolbar,_zoomFitAction);
  GUIUtilities.addToolBarButton(_toolbar,_zoomOutAction);
  _cutAction=new CutAction();
  _copyAction=new CopyAction();
  _pasteAction=new PasteAction();
  _createHierarchyAction=new CreateHierarchyAction();
  _layoutAction=new LayoutAction();
  _saveInLibraryAction=new SaveInLibraryAction();
  _importLibraryAction=new ImportLibraryAction();
  _instantiateEntityAction=new InstantiateEntityAction();
}"
75387,"/** 
 * Zoom in or out to magnify by the specified factor, from the current magnification.
 * @param factor The magnification factor (relative to 1.0).
 */
public void zoom(double factor){
  JCanvas canvas=_jgraph.getGraphPane().getCanvas();
  AffineTransform current=canvas.getCanvasPane().getTransformContext().getTransform();
  Point2D center=getCenter();
  current.scale(factor,factor);
  canvas.getCanvasPane().setTransform(current);
  setCenter(center);
  _graphPanner.repaint();
}","/** 
 * Zoom in or out to magnify by the specified factor, from the current magnification.
 * @param factor The magnification factor (relative to 1.0).
 */
public void zoom(double factor){
  JCanvas canvas=_jgraph.getGraphPane().getCanvas();
  AffineTransform current=canvas.getCanvasPane().getTransformContext().getTransform();
  Point2D center=getCenter();
  current.scale(factor,factor);
  canvas.getCanvasPane().setTransform(current);
  setCenter(center);
  if (_graphPanner != null) {
    _graphPanner.repaint();
  }
}"
75388,"/** 
 * Set zoom to the nominal.
 */
public void zoomReset(){
  JCanvas canvas=_jgraph.getGraphPane().getCanvas();
  AffineTransform current=canvas.getCanvasPane().getTransformContext().getTransform();
  current.setToIdentity();
  canvas.getCanvasPane().setTransform(current);
  _graphPanner.repaint();
}","/** 
 * Set zoom to the nominal.
 */
public void zoomReset(){
  JCanvas canvas=_jgraph.getGraphPane().getCanvas();
  AffineTransform current=canvas.getCanvasPane().getTransformContext().getTransform();
  current.setToIdentity();
  canvas.getCanvasPane().setTransform(current);
  if (_graphPanner != null) {
    _graphPanner.repaint();
  }
}"
75389,"private void _checkBadTypes(NamedObj object) throws IllegalActionException {
  if (object instanceof Attribute && ModelTransformer._isIgnorableAttribute((Attribute)object)) {
    return;
  }
  if (object instanceof Typeable) {
    Typeable typeable=(Typeable)object;
    ptolemy.data.type.Type type=typeable.getType();
    boolean badType=false;
    if (type instanceof ptolemy.data.type.FunctionType) {
      badType=true;
    }
    if (type instanceof ptolemy.data.type.RecordType) {
      badType=true;
    }
    if (type instanceof ptolemy.data.type.ArrayType) {
      type=((ptolemy.data.type.ArrayType)type).getElementType();
      if (type instanceof ptolemy.data.type.ArrayType) {
        badType=true;
      }
    }
    if (badType) {
      throw new IllegalActionException(object.getFullName() + ""String_Node_Str"" + type+ ""String_Node_Str"");
    }
  }
  if (object instanceof CompositeEntity) {
    for (Iterator i=((CompositeEntity)object).entityList().iterator(); i.hasNext(); ) {
      _checkBadTypes((NamedObj)i.next());
    }
    for (Iterator i=((CompositeEntity)object).relationList().iterator(); i.hasNext(); ) {
      _checkBadTypes((NamedObj)i.next());
    }
  }
  if (object instanceof Entity) {
    for (Iterator i=((Entity)object).portList().iterator(); i.hasNext(); ) {
      _checkBadTypes((NamedObj)i.next());
    }
  }
  for (Iterator i=object.attributeList().iterator(); i.hasNext(); ) {
    _checkBadTypes((NamedObj)i.next());
  }
}","private void _checkBadTypes(NamedObj object) throws IllegalActionException {
  if (object instanceof Attribute && ModelTransformer._isIgnorableAttribute((Attribute)object)) {
    return;
  }
  if (object instanceof Typeable) {
    Typeable typeable=(Typeable)object;
    ptolemy.data.type.Type type=typeable.getType();
    boolean badType=false;
    if (type instanceof ptolemy.data.type.FunctionType) {
      badType=true;
    }
    if (type instanceof ptolemy.data.type.RecordType) {
      badType=true;
    }
    if (type instanceof ptolemy.data.type.ArrayType) {
      ptolemy.data.type.Type elementType=((ptolemy.data.type.ArrayType)type).getElementType();
      if (elementType instanceof ptolemy.data.type.ArrayType) {
        System.out.println(""String_Node_Str"" + elementType.getClass());
        badType=true;
      }
    }
    if (badType) {
      throw new IllegalActionException(object.getFullName() + ""String_Node_Str"" + type+ ""String_Node_Str"");
    }
  }
  if (object instanceof CompositeEntity) {
    for (Iterator i=((CompositeEntity)object).entityList().iterator(); i.hasNext(); ) {
      _checkBadTypes((NamedObj)i.next());
    }
    for (Iterator i=((CompositeEntity)object).relationList().iterator(); i.hasNext(); ) {
      _checkBadTypes((NamedObj)i.next());
    }
  }
  if (object instanceof Entity) {
    for (Iterator i=((Entity)object).portList().iterator(); i.hasNext(); ) {
      _checkBadTypes((NamedObj)i.next());
    }
  }
  for (Iterator i=object.attributeList().iterator(); i.hasNext(); ) {
    _checkBadTypes((NamedObj)i.next());
  }
}"
75390,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ShapeIcon newObject=(ShapeIcon)super.clone(workspace);
  newObject._figures=new LinkedList();
  newObject._shape=_defaultShape;
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ShapeIcon newObject=(ShapeIcon)super.clone(workspace);
  newObject._figures=new LinkedList();
  return newObject;
}"
75391,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  UpdatedValueIcon newObject=(UpdatedValueIcon)super.clone(workspace);
  newObject._associatedAttribute=null;
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  UpdatedValueIcon newObject=(UpdatedValueIcon)super.clone(workspace);
  newObject._associatedAttribute=null;
  try {
    newObject.attributeChanged(newObject.attributeName);
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
  return newObject;
}"
75392,"/** 
 * Return a circle.
 * @return A Circle.
 */
public Shape _getDefaultShape(){
  return new Ellipse2D.Double(0.0,0.0,20.0,20.0);
}","/** 
 * Return a circle.
 * @return A Circle.
 */
protected Shape _getDefaultShape(){
  return new Ellipse2D.Double(0.0,0.0,20.0,20.0);
}"
75393,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  FilledShapeAttribute newObject=(FilledShapeAttribute)super.clone(workspace);
  newObject._centeredValue=false;
  newObject._heightValue=0.0;
  newObject._inAttributeChanged=false;
  newObject._widthValue=0.0;
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  FilledShapeAttribute newObject=(FilledShapeAttribute)super.clone(workspace);
  newObject._inAttributeChanged=false;
  return newObject;
}"
75394,"/** 
 * Return the default shape to use for this icon. Note that this is called in the constructor, so if you override it in derived classed, you cannot access any methods or members of the derived class because they will not have been constructed.
 * @return The default shape for this attribute.
 */
public Shape _getDefaultShape(){
  return new Rectangle2D.Double(0.0,0.0,20.0,20.0);
}","/** 
 * Return the default shape to use for this icon. Note that this is called in the constructor, so if you override it in derived classed, you cannot access any methods or members of the derived class because they will not have been constructed.
 * @return The default shape for this attribute.
 */
protected Shape _getDefaultShape(){
  return new Rectangle2D.Double(0.0,0.0,20.0,20.0);
}"
75395,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ShapeAttribute newObject=(ShapeAttribute)super.clone(workspace);
  newObject._icon=(ShapeIcon)newObject.getAttribute(""String_Node_Str"");
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an object with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ShapeAttribute newObject=(ShapeAttribute)super.clone(workspace);
  newObject._icon=(ShapeIcon)newObject.getAttribute(""String_Node_Str"");
  newObject._none=(Variable)newObject.getAttribute(""String_Node_Str"");
  return newObject;
}"
75396,"/** 
 * Set the actor associated with this firing. This actor will then be returned when the getActor() method is invoked. If this firing already contains a reference to an actor, then the reference will overwritten.
 * @param actor The actor to associate with this firing.
 */
public void setActor(Actor actor){
  _incrementVersion();
  _actor=actor;
  if (_firing != null) {
    _firing.clear();
    _firing.add(this);
  }
}","/** 
 * Set the actor associated with this firing. This actor will then be returned when the getActor() method is invoked. If this firing already contains a reference to an actor, then the reference will overwritten.
 * @param actor The actor to associate with this firing.
 */
public void setActor(Actor actor){
  _incrementVersion();
  _actor=actor;
}"
75397,"/** 
 * Return the actor invocation sequence in the form of a sequence of firings. Since this ScheduleElement is a Firing, the iterator returned will contain exactly one Firing (this Firing). <p> A runtime exception is thrown if the underlying schedule structure is modified while the iterator is active.
 * @return An iterator over a sequence of firings.
 * @exception ConcurrentModificationException If theunderlying schedule structure is modified while the iterator is active.
 */
public Iterator firingIterator(){
  if (_firing == null) {
    _firing=new LinkedList();
    _firing.add(this);
  }
  return _firing.iterator();
}","/** 
 * Return the actor invocation sequence in the form of a sequence of firings. Since this ScheduleElement is a Firing, the iterator returned will contain exactly one Firing (this Firing). <p> A runtime exception is thrown if the underlying schedule structure is modified while the iterator is active.
 * @return An iterator over a sequence of firings.
 * @exception ConcurrentModificationException If theunderlying schedule structure is modified while the iterator is active.
 */
public Iterator firingIterator(){
  if (_firing == null) {
    _firing=Collections.singletonList(this);
  }
  return _firing.iterator();
}"
75398,"/** 
 * Return the parameterized scheduling sequence. An exception will be thrown if the graph is not schedulable.
 * @return A schedule of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If a parameterized schedulecannot be derived for the model.
 * @exception IllegalActionException If the rate parametersof the model are not correct, or the computed rates for external ports are not correct.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  _debug(""String_Node_Str"");
  PSDFDirector director=(PSDFDirector)getContainer();
  CompositeActor model=(CompositeActor)director.getContainer();
  PSDFGraphReader graphReader=new PSDFGraphReader();
  PSDFGraph psdfGraph=(PSDFGraph)(graphReader.convert(model));
  _debug(""String_Node_Str"");
  _debug(psdfGraph.toString() + ""String_Node_Str"");
  psdfGraph.printEdgeRateExpressions();
  _debug(""String_Node_Str"");
  PSDFAPGANStrategy scheduler=new PSDFAPGANStrategy(psdfGraph);
  ptolemy.graph.sched.Schedule schedule=scheduler.schedule();
  _debug(""String_Node_Str"");
  _debug(schedule.toString() + ""String_Node_Str"");
  SymbolicScheduleElement result=_expandAPGAN(psdfGraph,scheduler.getClusteredGraphRoot(),scheduler);
  _debug(""String_Node_Str"" + ""String_Node_Str"" + result.toString() + ""String_Node_Str"");
  _debug(""String_Node_Str"");
  _saveBufferSizes(_bufferSizeMap);
  _debug(""String_Node_Str"");
  _debug(displayBufferSizes() + ""String_Node_Str"");
  if (_debugging) {
    _debug(""String_Node_Str"");
    Iterator relations=_bufferSizeMap.keySet().iterator();
    while (relations.hasNext()) {
      Relation relation=(Relation)relations.next();
      _debug(relation.getName() + ""String_Node_Str"" + _bufferSizeMap.get(relation)+ ""String_Node_Str"");
    }
  }
  return (Schedule)result;
}","/** 
 * Return the parameterized scheduling sequence. An exception will be thrown if the graph is not schedulable.
 * @return A schedule of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If a parameterized schedulecannot be derived for the model.
 * @exception IllegalActionException If the rate parametersof the model are not correct, or the computed rates for external ports are not correct.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  _debug(""String_Node_Str"");
  PSDFDirector director=(PSDFDirector)getContainer();
  CompositeActor model=(CompositeActor)director.getContainer();
  PSDFGraphReader graphReader=new PSDFGraphReader();
  PSDFGraph psdfGraph=(PSDFGraph)(graphReader.convert(model));
  _debug(""String_Node_Str"");
  _debug(psdfGraph.toString() + ""String_Node_Str"");
  psdfGraph.printEdgeRateExpressions();
  _debug(""String_Node_Str"");
  PSDFAPGANStrategy scheduler=new PSDFAPGANStrategy(psdfGraph);
  ptolemy.graph.sched.Schedule graphSchedule=scheduler.schedule();
  _debug(""String_Node_Str"");
  _debug(graphSchedule.toString() + ""String_Node_Str"");
  SymbolicScheduleElement result=_expandAPGAN(psdfGraph,scheduler.getClusteredGraphRoot(),scheduler);
  _debug(""String_Node_Str"" + ""String_Node_Str"" + result.toString() + ""String_Node_Str"");
  _debug(""String_Node_Str"");
  _saveBufferSizes(_bufferSizeMap);
  _debug(""String_Node_Str"");
  _debug(displayBufferSizes() + ""String_Node_Str"");
  if (_debugging) {
    _debug(""String_Node_Str"");
    Iterator relations=_bufferSizeMap.keySet().iterator();
    while (relations.hasNext()) {
      Relation relation=(Relation)relations.next();
      _debug(relation.getName() + ""String_Node_Str"" + _bufferSizeMap.get(relation)+ ""String_Node_Str"");
    }
  }
  System.out.println(""String_Node_Str"" + result);
  if (result instanceof Schedule) {
    return (Schedule)result;
  }
 else {
    Schedule schedule=new Schedule();
    schedule.add((ScheduleElement)result);
    return schedule;
  }
}"
75399,"public String getFunctionName(){
  Node n=jjtGetChild(0);
  if (!(n instanceof ASTPtLeafNode))   return null;
 else   return ((ASTPtLeafNode)n).getName();
}","public String getFunctionName(){
  Node n=jjtGetChild(0);
  if (!(n instanceof ASTPtLeafNode))   return null;
 else {
    ASTPtLeafNode leaf=(ASTPtLeafNode)n;
    if (leaf.isIdentifier()) {
      return leaf.getName();
    }
 else {
      return null;
    }
  }
}"
75400,"/** 
 * Apply a function to the children of the specified node. This also handles indexing into matrices and arrays, which look like function calls. In the simplest cases, if the function is being applied to an expression that evaluated to a FunctionToken, an ArrayToken, or a MatrixToken, then the function application is simply applied to the available arguments. More complex is if the function is being applied to an expression that does not evaluate as above, resulting in three cases:  Of primary interest is a function node that represents the invocation of a Java method registered with the expression parser.  This method uses the reflection mechanism in the CachedMethod class to find the correct method, based on the types of the arguments and invoke it.  See that class for information about how method arguments are matched. A second case is the eval() function, which is handled specially in this method.  The argument to the function is evaluated, and the parsed as a string using the expression parser.  The result is then evaluated *in this evaluator*. This has the effect that any identifiers are evaluated in the same scope as the original expression. A third case is the matlab() function, which is also handled specially in this method, allowing the evaluation of expressions in matlab if matlab is installed.  The format of the function is covered in  {@link ptolemy.data.expr.MatlabUtilities#evaluate(String,Set,ParserScope)}.
 * @param node The specified node.
 * @exception IllegalActionException If an evaluation error occurs.
 */
public void visitFunctionApplicationNode(ASTPtFunctionApplicationNode node) throws IllegalActionException {
  ptolemy.data.Token value=null;
  String functionName=node.getFunctionName();
  if (_scope != null && functionName != null) {
    value=_scope.get(node.getFunctionName());
  }
  int argCount=node.jjtGetNumChildren() - 1;
  Type[] argTypes=new Type[argCount];
  ptolemy.data.Token[] argValues=new ptolemy.data.Token[argCount];
  for (int i=0; i < argCount; i++) {
    _evaluateChild(node,i + 1);
    ptolemy.data.Token token=_evaluatedChildToken;
    argValues[i]=token;
    argTypes[i]=token.getType();
  }
  if (value != null || functionName == null) {
    ptolemy.data.Token result;
    value=_evaluateChild(node,0);
    if (value instanceof ArrayToken) {
      if (argCount == 1) {
        result=_evaluateArrayIndex(node,value,argValues[0]);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName());
      }
    }
 else     if (value instanceof MatrixToken) {
      if (argCount == 2) {
        result=_evaluateMatrixIndex(node,value,argValues[0],argValues[1]);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName());
      }
    }
 else     if (value instanceof FunctionToken) {
      FunctionToken function=(FunctionToken)value;
      if (function.getNumberOfArguments() != argCount) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + value.toString());
      }
      result=function.apply(argValues);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + value.toString());
    }
    _evaluatedChildToken=(result);
    return;
  }
  if (node.getFunctionName().compareTo(""String_Node_Str"") == 0) {
    if (argCount == 1) {
      ptolemy.data.Token token=argValues[0];
      if (token instanceof StringToken) {
        PtParser parser=new PtParser();
        ASTPtRootNode tree=parser.generateParseTree(((StringToken)token).stringValue());
        tree.visit(this);
        return;
      }
    }
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (node.getFunctionName().compareTo(""String_Node_Str"") == 0) {
    if (argCount == 1) {
      ptolemy.data.Token token=argValues[0];
      if (token instanceof StringToken) {
        String expression=((StringToken)token).stringValue();
        ParseTreeFreeVariableCollector collector=new ParseTreeFreeVariableCollector();
        Set freeVariables=collector.collectFreeVariables(node,_scope);
        _evaluatedChildToken=MatlabUtilities.evaluate(expression,freeVariables,_scope);
        return;
      }
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  ptolemy.data.Token result=_functionCall(node.getFunctionName(),argTypes,argValues);
  _evaluatedChildToken=(result);
}","/** 
 * Apply a function to the children of the specified node. This also handles indexing into matrices and arrays, which look like function calls. In the simplest cases, if the function is being applied to an expression that evaluated to a FunctionToken, an ArrayToken, or a MatrixToken, then the function application is simply applied to the available arguments. More complex is if the function is being applied to an expression that does not evaluate as above, resulting in three cases:  Of primary interest is a function node that represents the invocation of a Java method registered with the expression parser.  This method uses the reflection mechanism in the CachedMethod class to find the correct method, based on the types of the arguments and invoke it.  See that class for information about how method arguments are matched. A second case is the eval() function, which is handled specially in this method.  The argument to the function is evaluated, and the parsed as a string using the expression parser.  The result is then evaluated *in this evaluator*. This has the effect that any identifiers are evaluated in the same scope as the original expression. A third case is the matlab() function, which is also handled specially in this method, allowing the evaluation of expressions in matlab if matlab is installed.  The format of the function is covered in  {@link ptolemy.data.expr.MatlabUtilities#evaluate(String,Set,ParserScope)}.
 * @param node The specified node.
 * @exception IllegalActionException If an evaluation error occurs.
 */
public void visitFunctionApplicationNode(ASTPtFunctionApplicationNode node) throws IllegalActionException {
  ptolemy.data.Token value=null;
  String functionName=node.getFunctionName();
  if (functionName != null && _scope != null) {
    value=_scope.get(node.getFunctionName());
  }
  int argCount=node.jjtGetNumChildren() - 1;
  Type[] argTypes=new Type[argCount];
  ptolemy.data.Token[] argValues=new ptolemy.data.Token[argCount];
  for (int i=0; i < argCount; i++) {
    _evaluateChild(node,i + 1);
    ptolemy.data.Token token=_evaluatedChildToken;
    argValues[i]=token;
    argTypes[i]=token.getType();
  }
  if (value != null || functionName == null) {
    ptolemy.data.Token result;
    if (value == null) {
      value=_evaluateChild(node,0);
    }
    if (value instanceof ArrayToken) {
      if (argCount == 1) {
        result=_evaluateArrayIndex(node,value,argValues[0]);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName());
      }
    }
 else     if (value instanceof MatrixToken) {
      if (argCount == 2) {
        result=_evaluateMatrixIndex(node,value,argValues[0],argValues[1]);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName());
      }
    }
 else     if (value instanceof FunctionToken) {
      FunctionToken function=(FunctionToken)value;
      if (function.getNumberOfArguments() != argCount) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + value.toString());
      }
      result=function.apply(argValues);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + value.toString());
    }
    _evaluatedChildToken=(result);
    return;
  }
  if (node.getFunctionName().compareTo(""String_Node_Str"") == 0) {
    if (argCount == 1) {
      ptolemy.data.Token token=argValues[0];
      if (token instanceof StringToken) {
        PtParser parser=new PtParser();
        ASTPtRootNode tree=parser.generateParseTree(((StringToken)token).stringValue());
        tree.visit(this);
        return;
      }
    }
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (node.getFunctionName().compareTo(""String_Node_Str"") == 0) {
    if (argCount == 1) {
      ptolemy.data.Token token=argValues[0];
      if (token instanceof StringToken) {
        String expression=((StringToken)token).stringValue();
        ParseTreeFreeVariableCollector collector=new ParseTreeFreeVariableCollector();
        Set freeVariables=collector.collectFreeVariables(node,_scope);
        _evaluatedChildToken=MatlabUtilities.evaluate(expression,freeVariables,_scope);
        return;
      }
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  ptolemy.data.Token result=_functionCall(node.getFunctionName(),argTypes,argValues);
  _evaluatedChildToken=(result);
}"
75401,"/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  super.removeDependency(input,output);
}","/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  removeDependency(input,output);
}"
75402,"/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  super.removeDependency(input,output);
  super.removeDependency(newServiceTime,output);
}","/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  removeDependency(input,output);
  removeDependency(newServiceTime,output);
}"
75403,"/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  super.removeDependency(input,output);
}","/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  removeDependency(input,output);
}"
75404,"/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  super.removeDependency(input,output);
}","/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  removeDependency(input,output);
}"
75405,"/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  super.removeDependency(input,output);
  super.removeDependency(delay,output);
}","/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  removeDependency(input,output);
  removeDependency(delay,output);
}"
75406,"public void removeDependencies(){
  super.removeDependency(input,output);
}","public void removeDependencies(){
  removeDependency(input,output);
}"
75407,"/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  super.removeDependency(next,output);
  super.removeDependency(next,request);
}","/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  removeDependency(next,output);
  removeDependency(next,request);
}"
75408,"/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  super.removeDependency(set,expired);
}","/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  removeDependency(set,expired);
}"
75409,"/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies() throws IllegalActionException {
  IODependenceOfAtomicActor ioDependence=(IODependenceOfAtomicActor)this.getAttribute(""String_Node_Str"",IODependence.class);
  ioDependence.removeDependence(input,output);
}","/** 
 * Explicitly declare which inputs and outputs are not dependent.
 */
public void removeDependencies(){
  super.removeDependency(input,output);
}"
75410,"/** 
 * Transform the properties to take into account channel losses, noise, etc., for transmission between the specified sender and the specified receiver.  In this base class, the specified properties are merged with the defaultProperties so that the resulting properties contain at least all the fields of the defaultProperties.
 * @param properties The transmit properties.
 * @param sender The sending port.
 * @param receiver The receiving port.
 * @return The transformed properties.
 * @exception IllegalActionException If the properties cannotbe transformed. Not thrown in this base class.
 */
protected RecordToken _transformProperties(RecordToken properties,WirelessIOPort sender,WirelessReceiver receiver) throws IllegalActionException {
  RecordToken result=properties;
  Token defaultPropertiesValue=defaultProperties.getToken();
  if (properties != null && defaultPropertiesValue instanceof RecordToken) {
    result=RecordToken.merge(properties,(RecordToken)defaultPropertiesValue);
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + result.toString() + ""String_Node_Str"");
  }
  return result;
}","/** 
 * Transform the properties to take into account channel losses, noise, etc., for transmission between the specified sender and the specified receiver.  In this base class, the specified properties are merged with the defaultProperties so that the resulting properties contain at least all the fields of the defaultProperties.
 * @param properties The transmit properties.
 * @param sender The sending port.
 * @param receiver The receiving port.
 * @return The transformed properties.
 * @exception IllegalActionException If the properties cannotbe transformed. Not thrown in this base class.
 */
protected RecordToken _transformProperties(RecordToken properties,WirelessIOPort sender,WirelessReceiver receiver) throws IllegalActionException {
  RecordToken result=properties;
  Token defaultPropertiesValue=defaultProperties.getToken();
  if (properties != null && defaultPropertiesValue instanceof RecordToken) {
    result=RecordToken.merge(properties,(RecordToken)defaultPropertiesValue);
  }
  if (_debugging) {
    if (result != null) {
      _debug(""String_Node_Str"" + result.toString() + ""String_Node_Str"");
    }
 else {
      _debug(""String_Node_Str"");
    }
  }
  return result;
}"
75411,"public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    return;
  }
  if (!_excludedNames.contains(node.getName())) {
    if (_scope != null) {
      ptolemy.data.Token token=_scope.get(node.getName());
      node.setToken(token);
      node.setConstant(true);
      node._name=null;
      return;
    }
    throw new IllegalActionException(""String_Node_Str"" + node.getName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
}","public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    return;
  }
  if (!_excludedNames.contains(node.getName())) {
    if (_scope != null) {
      ptolemy.data.Token token=_scope.get(node.getName());
      if (token != null) {
        node.setToken(token);
        node.setConstant(true);
        node._name=null;
        return;
      }
    }
  }
}"
75412,"/** 
 * Explicitly declare which inputs and outputs are not dependent. In this base class, this method does nothing. Subclasses should implement the details.  <p> To declare a pair, input and output, independent, use the <i> removeDependency(IOPort IOPort)</i> method. 
 * @see ptolemy.domains.de.lib.TimedDelay
 * @see #removeDependency(IOPort IOPort)
 */
public void removeDependencies(){
}","/** 
 * Explicitly declare which inputs and outputs are not dependent. In this base class, this method does nothing. Subclasses should implement the details.  <p> To declare a pair, input and output, independent, use the <i> removeDependency(IOPort IOPort)</i> method. 
 * @see ptolemy.domains.de.lib.TimedDelay
 * @see #removeDependency(IOPort,IOPort)
 */
public void removeDependencies(){
}"
75413,"public Object selectField(Object o,String fieldName){
  Object composite=(o instanceof ObjectToken) ? ((ObjectToken)o).getValue() : o;
  Class c=composite.getClass();
  Field f;
  try {
    f=c.getField(fieldName);
    return this.fromJavaObject(f.get(composite));
  }
 catch (  NoSuchFieldException nsfe1) {
    if (this.isClass(composite)) {
      try {
        f=this.getJavaClass(composite).getField(fieldName);
        return this.fromJavaObject(f.get(composite));
      }
 catch (      NoSuchFieldException nsfe2) {
      }
catch (      IllegalAccessException iae) {
        throw new InterpreterException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ composite.toString(),iae);
      }
    }
    try {
      return new ObjectToken(new MethodObject(composite,fieldName,this));
    }
 catch (    Exception e) {
      throw new InterpreterException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ composite,e);
    }
  }
catch (  IllegalAccessException iae) {
    throw new InterpreterException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ composite,iae);
  }
}","public Object selectField(Object composite,String fieldName){
  Class c=this.getJavaClassOfObject(composite);
  Field f;
  try {
    f=c.getField(fieldName);
    return this.fromJavaObject(f.get(this.toJavaObject(composite)));
  }
 catch (  NoSuchFieldException nsfe1) {
    if (this.isClass(composite)) {
      try {
        f=this.getJavaClass(composite).getField(fieldName);
        return this.fromJavaObject(f.get(null));
      }
 catch (      NoSuchFieldException nsfe2) {
      }
catch (      IllegalAccessException iae) {
        throw new InterpreterException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ composite.toString(),iae);
      }
    }
    try {
      return new ObjectToken(new MethodObject(composite,fieldName,this));
    }
 catch (    Exception e) {
      throw new InterpreterException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ composite,e);
    }
  }
catch (  IllegalAccessException iae) {
    throw new InterpreterException(""String_Node_Str"" + fieldName + ""String_Node_Str""+ composite,iae);
  }
}"
75414,"public Object toJavaObject(Object o){
  if (o instanceof BooleanToken) {
    return new Boolean(booleanValue(o));
  }
 else   if (o instanceof DoubleToken) {
    return new Double(realValue(o));
  }
 else   if (o instanceof IntToken) {
    return new Integer(intValue(o));
  }
 else   if (o instanceof StringToken) {
    return stringValue(o);
  }
 else   if (o instanceof ObjectToken) {
    return ((ObjectToken)o).getValue();
  }
 else   if (o instanceof Token) {
    return o;
  }
 else   throw new InterpreterException(""String_Node_Str"" + o.getClass().toString());
}","public Object toJavaObject(Object o){
  if (o instanceof BooleanToken) {
    return new Boolean(booleanValue(o));
  }
 else   if (o instanceof DoubleToken) {
    return new Double(realValue(o));
  }
 else   if (o instanceof IntToken) {
    return new Integer(intValue(o));
  }
 else   if (o instanceof StringToken) {
    return stringValue(o);
  }
 else   if (o instanceof ObjectToken) {
    Object v=((ObjectToken)o).getValue();
    if (v instanceof ClassObject)     return ((ClassObject)v).getClassObject();
 else     return ((ObjectToken)o).getValue();
  }
 else   if (o instanceof Token) {
    return o;
  }
 else   throw new InterpreterException(""String_Node_Str"" + o.getClass().toString());
}"
75415,"public Class getJavaClassOfObject(Object o){
  return (o instanceof ObjectToken) ? ObjectToken.class : o.getClass();
}","public Class getJavaClassOfObject(Object o){
  if (o == null) {
    return Object.class;
  }
 else   if (o instanceof BooleanToken) {
    return Boolean.class;
  }
 else   if (o instanceof DoubleToken) {
    return Double.class;
  }
 else   if (o instanceof IntToken) {
    return Integer.class;
  }
 else   if (o instanceof StringToken) {
    return String.class;
  }
 else   if (o instanceof ObjectToken) {
    Object v=((ObjectToken)o).getValue();
    if (v instanceof ClassObject)     return Class.class;
 else     return v.getClass();
  }
 else   if (o instanceof Token) {
    return o.getClass();
  }
 else   throw new InterpreterException(""String_Node_Str"" + o.getClass().toString());
}"
75416,"public Object fromJavaObject(Object o){
  try {
    if (o instanceof Token) {
      return o;
    }
 else     if (o instanceof Boolean) {
      return new BooleanToken(((Boolean)o).booleanValue());
    }
 else     if (o instanceof Double) {
      return new DoubleToken(((Double)o).doubleValue());
    }
 else     if (o instanceof Integer) {
      return new IntToken(((Integer)o).intValue());
    }
 else     if (o instanceof String) {
      return new StringToken((String)o);
    }
 else {
      return new ObjectToken(o);
    }
  }
 catch (  IllegalActionException ex) {
    throw new InterpreterException(""String_Node_Str"" + o.toString(),ex);
  }
}","public Object fromJavaObject(Object o){
  try {
    if (o instanceof Token) {
      return o;
    }
 else     if (o instanceof Boolean) {
      return new BooleanToken(((Boolean)o).booleanValue());
    }
 else     if (o instanceof Double) {
      return new DoubleToken(((Double)o).doubleValue());
    }
 else     if (o instanceof Integer) {
      return new IntToken(((Integer)o).intValue());
    }
 else     if (o instanceof String) {
      return new StringToken((String)o);
    }
 else     if (o instanceof Class) {
      return new ObjectToken(new ClassObject((Class)o,this));
    }
 else {
      return new ObjectToken(o);
    }
  }
 catch (  IllegalActionException ex) {
    throw new InterpreterException(""String_Node_Str"" + o.toString(),ex);
  }
}"
75417,"public void visitFunctionApplicationNode(ASTPtFunctionApplicationNode node) throws IllegalActionException {
  _debug(node);
  int numChildren=node.jjtGetNumChildren();
  int argCount=numChildren - 1;
  for (int i=1; i < numChildren; i++) {
    _generateChild(node,i);
  }
  if (_isValidName(node.getFunctionName())) {
    Local local=_getLocalForName(node.getFunctionName());
    Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.tokenClass));
    _body.getLocals().add(resultLocal);
    if (argCount == 1) {
      Local tokenCastLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.arrayTokenClass));
      _body.getLocals().add(tokenCastLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tokenCastLocal,Jimple.v().newCastExpr(local,RefType.v(PtolemyUtilities.arrayTokenClass))),_insertPoint);
      Local indexTokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(1));
      _units.insertBefore(Jimple.v().newAssignStmt(indexTokenLocal,Jimple.v().newCastExpr(indexTokenLocal,RefType.v(PtolemyUtilities.intTokenClass))),_insertPoint);
      Local indexLocal=Jimple.v().newLocal(""String_Node_Str"",IntType.v());
      _body.getLocals().add(indexLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(indexLocal,Jimple.v().newVirtualInvokeExpr(indexTokenLocal,PtolemyUtilities.intValueMethod)),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tokenCastLocal,PtolemyUtilities.arrayGetElementMethod,indexLocal)),_insertPoint);
    }
 else     if (argCount == 2) {
      Local tokenCastLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.matrixTokenClass));
      _body.getLocals().add(tokenCastLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tokenCastLocal,Jimple.v().newCastExpr(local,RefType.v(PtolemyUtilities.matrixTokenClass))),_insertPoint);
      Local rowIndexTokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(1));
      Local columnIndexTokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(1));
      _units.insertBefore(Jimple.v().newAssignStmt(rowIndexTokenLocal,Jimple.v().newCastExpr(rowIndexTokenLocal,RefType.v(PtolemyUtilities.intTokenClass))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(columnIndexTokenLocal,Jimple.v().newCastExpr(columnIndexTokenLocal,RefType.v(PtolemyUtilities.intTokenClass))),_insertPoint);
      Local rowIndexLocal=Jimple.v().newLocal(""String_Node_Str"",IntType.v());
      _body.getLocals().add(rowIndexLocal);
      Local columnIndexLocal=Jimple.v().newLocal(""String_Node_Str"",IntType.v());
      _body.getLocals().add(columnIndexLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(rowIndexLocal,Jimple.v().newVirtualInvokeExpr(rowIndexTokenLocal,PtolemyUtilities.intValueMethod)),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(columnIndexLocal,Jimple.v().newVirtualInvokeExpr(columnIndexTokenLocal,PtolemyUtilities.intValueMethod)),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tokenCastLocal,PtolemyUtilities.matrixGetElementAsTokenMethod,rowIndexLocal,columnIndexLocal)),_insertPoint);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName());
    }
    _nodeToLocal.put(node,resultLocal);
    return;
  }
  if (node.getFunctionName().compareTo(""String_Node_Str"") == 0) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  if (node.getFunctionName().compareTo(""String_Node_Str"") == 0) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  ptolemy.data.type.Type[] argTypes=new ptolemy.data.type.Type[argCount];
  for (int i=0; i < argCount; i++) {
    argTypes[i]=((ASTPtRootNode)node.jjtGetChild(i + 1)).getType();
  }
  CachedMethod cachedMethod=CachedMethod.findMethod(node.getFunctionName(),argTypes,CachedMethod.FUNCTION);
  if (!cachedMethod.isValid()) {
    throw new IllegalActionException(""String_Node_Str"" + cachedMethod + ""String_Node_Str"");
  }
  if (cachedMethod instanceof CachedMethod.BaseConvertCachedMethod || cachedMethod instanceof CachedMethod.ArrayMapCachedMethod || cachedMethod instanceof CachedMethod.MatrixMapCachedMethod) {
    throw new IllegalActionException(""String_Node_Str"" + cachedMethod.getClass());
  }
  Method method=cachedMethod.getMethod();
  SootMethod sootMethod=SootUtilities.getSootMethodForMethod(method);
  List args=new LinkedList();
  CachedMethod.ArgumentConversion[] conversions=cachedMethod.getConversions();
  for (int i=0; i < argCount; i++) {
    Local tokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(i + 1));
    Local argLocal=_convertTokenArgToJavaArg(tokenLocal,argTypes[i],conversions[i]);
    args.add(argLocal);
  }
  Type returnType=sootMethod.getReturnType();
  Local returnLocal=Jimple.v().newLocal(""String_Node_Str"",returnType);
  _body.getLocals().add(returnLocal);
  _units.insertBefore(Jimple.v().newAssignStmt(returnLocal,Jimple.v().newStaticInvokeExpr(sootMethod,args)),_insertPoint);
  Local tokenLocal=_convertJavaResultToToken(returnLocal,returnType);
  _nodeToLocal.put(node,tokenLocal);
}","public void visitFunctionApplicationNode(ASTPtFunctionApplicationNode node) throws IllegalActionException {
  _debug(node);
  int numChildren=node.jjtGetNumChildren();
  int argCount=numChildren - 1;
  for (int i=1; i < numChildren; i++) {
    _generateChild(node,i);
  }
  if (_isValidName(node.getFunctionName())) {
    Local local=_getLocalForName(node.getFunctionName());
    Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.tokenClass));
    _body.getLocals().add(resultLocal);
    if (argCount == 1) {
      Local tokenCastLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.arrayTokenClass));
      _body.getLocals().add(tokenCastLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tokenCastLocal,Jimple.v().newCastExpr(local,RefType.v(PtolemyUtilities.arrayTokenClass))),_insertPoint);
      Local indexTokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(1));
      _units.insertBefore(Jimple.v().newAssignStmt(indexTokenLocal,Jimple.v().newCastExpr(indexTokenLocal,RefType.v(PtolemyUtilities.intTokenClass))),_insertPoint);
      Local indexLocal=Jimple.v().newLocal(""String_Node_Str"",IntType.v());
      _body.getLocals().add(indexLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(indexLocal,Jimple.v().newVirtualInvokeExpr(indexTokenLocal,PtolemyUtilities.intValueMethod)),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tokenCastLocal,PtolemyUtilities.arrayGetElementMethod,indexLocal)),_insertPoint);
    }
 else     if (argCount == 2) {
      Local tokenCastLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.matrixTokenClass));
      _body.getLocals().add(tokenCastLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tokenCastLocal,Jimple.v().newCastExpr(local,RefType.v(PtolemyUtilities.matrixTokenClass))),_insertPoint);
      Local rowIndexTokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(1));
      Local columnIndexTokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(2));
      _units.insertBefore(Jimple.v().newAssignStmt(rowIndexTokenLocal,Jimple.v().newCastExpr(rowIndexTokenLocal,RefType.v(PtolemyUtilities.intTokenClass))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(columnIndexTokenLocal,Jimple.v().newCastExpr(columnIndexTokenLocal,RefType.v(PtolemyUtilities.intTokenClass))),_insertPoint);
      Local rowIndexLocal=Jimple.v().newLocal(""String_Node_Str"",IntType.v());
      _body.getLocals().add(rowIndexLocal);
      Local columnIndexLocal=Jimple.v().newLocal(""String_Node_Str"",IntType.v());
      _body.getLocals().add(columnIndexLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(rowIndexLocal,Jimple.v().newVirtualInvokeExpr(rowIndexTokenLocal,PtolemyUtilities.intValueMethod)),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(columnIndexLocal,Jimple.v().newVirtualInvokeExpr(columnIndexTokenLocal,PtolemyUtilities.intValueMethod)),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tokenCastLocal,PtolemyUtilities.matrixGetElementAsTokenMethod,rowIndexLocal,columnIndexLocal)),_insertPoint);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName());
    }
    _nodeToLocal.put(node,resultLocal);
    return;
  }
  if (node.getFunctionName().compareTo(""String_Node_Str"") == 0) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  if (node.getFunctionName().compareTo(""String_Node_Str"") == 0) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  ptolemy.data.type.Type[] argTypes=new ptolemy.data.type.Type[argCount];
  for (int i=0; i < argCount; i++) {
    argTypes[i]=((ASTPtRootNode)node.jjtGetChild(i + 1)).getType();
  }
  CachedMethod cachedMethod=CachedMethod.findMethod(node.getFunctionName(),argTypes,CachedMethod.FUNCTION);
  if (!cachedMethod.isValid()) {
    throw new IllegalActionException(""String_Node_Str"" + cachedMethod + ""String_Node_Str"");
  }
  if (cachedMethod instanceof CachedMethod.BaseConvertCachedMethod || cachedMethod instanceof CachedMethod.ArrayMapCachedMethod || cachedMethod instanceof CachedMethod.MatrixMapCachedMethod) {
    throw new IllegalActionException(""String_Node_Str"" + cachedMethod.getClass());
  }
  Method method=cachedMethod.getMethod();
  SootMethod sootMethod=SootUtilities.getSootMethodForMethod(method);
  List args=new LinkedList();
  CachedMethod.ArgumentConversion[] conversions=cachedMethod.getConversions();
  for (int i=0; i < argCount; i++) {
    Local tokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(i + 1));
    Local argLocal=_convertTokenArgToJavaArg(tokenLocal,argTypes[i],conversions[i]);
    args.add(argLocal);
  }
  Type returnType=sootMethod.getReturnType();
  Local returnLocal=Jimple.v().newLocal(""String_Node_Str"",returnType);
  _body.getLocals().add(returnLocal);
  _units.insertBefore(Jimple.v().newAssignStmt(returnLocal,Jimple.v().newStaticInvokeExpr(sootMethod,args)),_insertPoint);
  Local tokenLocal=_convertJavaResultToToken(returnLocal,returnType);
  _nodeToLocal.put(node,tokenLocal);
}"
75418,"public static void eliminateCastsAndInstanceOf(Body body,String phaseName,Set unsafeLocalSet,boolean debug){
  TokenTypeAnalysis tokenTypes=new TokenTypeAnalysis(body.getMethod(),new CompleteUnitGraph(body));
  for (Iterator units=body.getUnits().iterator(); units.hasNext(); ) {
    Unit unit=(Unit)units.next();
    for (Iterator boxes=unit.getUseBoxes().iterator(); boxes.hasNext(); ) {
      ValueBox box=(ValueBox)boxes.next();
      Value value=box.getValue();
      if (value instanceof InstanceOfExpr) {
        InstanceOfExpr expr=(InstanceOfExpr)value;
        Type checkType=expr.getCheckType();
        Value op=expr.getOp();
        if (!PtolemyUtilities.isTokenType(op.getType())) {
          continue;
        }
        ptolemy.data.type.Type type=tokenTypes.getTypeOfBefore((Local)op,unit);
        if (!type.isInstantiable() || type.equals(BaseType.GENERAL)) {
          continue;
        }
        Type opType=PtolemyUtilities.getSootTypeForTokenType(type);
        if (debug)         System.out.println(""String_Node_Str"" + expr);
        CastAndInstanceofEliminator.replaceInstanceofCheck(box,Scene.v().getActiveHierarchy(),checkType,opType,debug);
      }
    }
  }
}","public static void eliminateCastsAndInstanceOf(Body body,String phaseName,Set unsafeLocalSet,boolean debug){
  TokenTypeAnalysis tokenTypes=new TokenTypeAnalysis(body.getMethod(),new CompleteUnitGraph(body));
  for (Iterator units=body.getUnits().iterator(); units.hasNext(); ) {
    Unit unit=(Unit)units.next();
    for (Iterator boxes=unit.getUseBoxes().iterator(); boxes.hasNext(); ) {
      ValueBox box=(ValueBox)boxes.next();
      Value value=box.getValue();
      if (value instanceof InstanceOfExpr) {
        InstanceOfExpr expr=(InstanceOfExpr)value;
        Type checkType=expr.getCheckType();
        Value op=expr.getOp();
        if (!PtolemyUtilities.isTokenType(op.getType())) {
          continue;
        }
        ptolemy.data.type.Type type=tokenTypes.getTypeOfBefore((Local)op,unit);
        if (type.equals(BaseType.UNKNOWN) || type.equals(BaseType.GENERAL)) {
          System.out.println(""String_Node_Str"" + type);
          continue;
        }
        Type opType=PtolemyUtilities.getSootTypeForTokenType(type);
        if (debug)         System.out.println(""String_Node_Str"" + expr);
        CastAndInstanceofEliminator.replaceInstanceofCheck(box,Scene.v().getActiveHierarchy(),checkType,opType,debug);
      }
    }
  }
}"
75419,"public void inlineTokenAndTypeMethods(SootClass entityClass,int depth,Set unsafeLocalSet,boolean debug){
  boolean doneSomething=true;
  int count=0;
  while (doneSomething && count < 20) {
    doneSomething=false;
    count++;
    if (debug) {
      System.err.println(""String_Node_Str"" + entityClass + ""String_Node_Str""+ count+ ""String_Node_Str""+ depth);
      System.out.println(""String_Node_Str"" + entityClass + ""String_Node_Str""+ count+ ""String_Node_Str""+ depth);
    }
    for (Iterator methods=entityClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      LocalSplitter.v().transform(body,_phaseName + ""String_Node_Str"");
      LocalNameStandardizer.v().transform(body,_phaseName + ""String_Node_Str"");
      TypeAssigner.v().transform(body,_phaseName + ""String_Node_Str"");
      UnreachableCodeEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      CopyPropagator.v().transform(body,_phaseName + ""String_Node_Str"");
      ConstantPropagatorAndFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      ConditionalBranchFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      DeadAssignmentEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnreachableCodeEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnusedLocalEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      TokenInstanceofEliminator.eliminateCastsAndInstanceOf(body,_phaseName + ""String_Node_Str"",unsafeLocalSet,debug);
      UnreachableCodeEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      CopyPropagator.v().transform(body,_phaseName + ""String_Node_Str"");
      ConstantPropagatorAndFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      ConditionalBranchFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      DeadAssignmentEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnusedLocalEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnreachableCodeEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      CopyPropagator.v().transform(body,_phaseName + ""String_Node_Str"");
      ConstantPropagatorAndFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      ConditionalBranchFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      DeadAssignmentEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnusedLocalEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      LocalSplitter.v().transform(body,_phaseName + ""String_Node_Str"");
    }
    TypeSpecializerAnalysis typeAnalysis=new TypeSpecializerAnalysis(entityClass,unsafeLocalSet);
    for (Iterator methods=entityClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      if (_methodWillBeInlined(method)) {
        continue;
      }
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      CompleteUnitGraph unitGraph=new CompleteUnitGraph(body);
      SimpleLocalDefs localDefs=new SimpleLocalDefs(unitGraph);
      SimpleLocalUses localUses=new SimpleLocalUses(unitGraph,localDefs);
      if (debug)       System.out.println(""String_Node_Str"" + method);
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt stmt=(Stmt)units.next();
        if (debug)         System.out.println(""String_Node_Str"" + stmt);
        if (stmt.containsInvokeExpr()) {
          ValueBox box=stmt.getInvokeExprBox();
          Value value=box.getValue();
          if (debug)           System.out.println(""String_Node_Str"" + value);
          boolean flag=_inlineTokenMethodsIn(method,body,stmt,box,localDefs,localUses,typeAnalysis,depth,unsafeLocalSet,debug);
          doneSomething|=flag;
          if (!flag) {
            doneSomething|=_inlineTypeMethodsIn(method,body,stmt,box,localDefs,localUses,depth,unsafeLocalSet,debug);
          }
        }
      }
    }
  }
}","public void inlineTokenAndTypeMethods(SootClass entityClass,int depth,Set unsafeLocalSet,boolean debug){
  boolean doneSomething=true;
  int count=0;
  while (doneSomething && count < 20) {
    doneSomething=false;
    count++;
    if (debug) {
      System.err.println(""String_Node_Str"" + entityClass + ""String_Node_Str""+ count+ ""String_Node_Str""+ depth);
      System.out.println(""String_Node_Str"" + entityClass + ""String_Node_Str""+ count+ ""String_Node_Str""+ depth);
    }
    for (Iterator methods=entityClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      LocalSplitter.v().transform(body,_phaseName + ""String_Node_Str"");
      LocalNameStandardizer.v().transform(body,_phaseName + ""String_Node_Str"");
      TypeAssigner.v().transform(body,_phaseName + ""String_Node_Str"");
      UnreachableCodeEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      CopyPropagator.v().transform(body,_phaseName + ""String_Node_Str"");
      ConstantPropagatorAndFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      ConditionalBranchFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      DeadAssignmentEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnreachableCodeEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnusedLocalEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      if (debug)       System.out.println(""String_Node_Str"" + method);
      TokenInstanceofEliminator.eliminateCastsAndInstanceOf(body,_phaseName + ""String_Node_Str"",unsafeLocalSet,debug);
      UnreachableCodeEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      CopyPropagator.v().transform(body,_phaseName + ""String_Node_Str"");
      ConstantPropagatorAndFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      ConditionalBranchFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      DeadAssignmentEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnusedLocalEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnreachableCodeEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      CopyPropagator.v().transform(body,_phaseName + ""String_Node_Str"");
      ConstantPropagatorAndFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      ConditionalBranchFolder.v().transform(body,_phaseName + ""String_Node_Str"");
      DeadAssignmentEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      UnusedLocalEliminator.v().transform(body,_phaseName + ""String_Node_Str"");
      LocalSplitter.v().transform(body,_phaseName + ""String_Node_Str"");
    }
    TypeSpecializerAnalysis typeAnalysis=new TypeSpecializerAnalysis(entityClass,unsafeLocalSet);
    for (Iterator methods=entityClass.getMethods().iterator(); methods.hasNext(); ) {
      SootMethod method=(SootMethod)methods.next();
      if (_methodWillBeInlined(method)) {
        continue;
      }
      JimpleBody body=(JimpleBody)method.retrieveActiveBody();
      CompleteUnitGraph unitGraph=new CompleteUnitGraph(body);
      SimpleLocalDefs localDefs=new SimpleLocalDefs(unitGraph);
      SimpleLocalUses localUses=new SimpleLocalUses(unitGraph,localDefs);
      if (debug)       System.out.println(""String_Node_Str"" + method);
      for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
        Stmt stmt=(Stmt)units.next();
        if (debug)         System.out.println(""String_Node_Str"" + stmt);
        if (stmt.containsInvokeExpr()) {
          ValueBox box=stmt.getInvokeExprBox();
          Value value=box.getValue();
          if (debug)           System.out.println(""String_Node_Str"" + value);
          boolean flag=_inlineTokenMethodsIn(method,body,stmt,box,localDefs,localUses,typeAnalysis,depth,unsafeLocalSet,debug);
          doneSomething|=flag;
          if (!flag) {
            doneSomething|=_inlineTypeMethodsIn(method,body,stmt,box,localDefs,localUses,depth,unsafeLocalSet,debug);
          }
        }
      }
    }
  }
}"
75420,"private void _processClass(SootClass theClass){
  Hierarchy hierarchy=Scene.v().getActiveHierarchy();
  if (!theClass.isApplicationClass()) {
    theClass.setLibraryClass();
  }
  _addClasses(hierarchy.getSuperclassesOfIncluding(theClass));
  _addClasses(theClass.getInterfaces());
  for (Iterator fields=theClass.getFields().iterator(); fields.hasNext(); ) {
    SootField field=(SootField)fields.next();
    Type type=field.getType();
    if (type instanceof RefType) {
      _addClass(((RefType)type).getSootClass());
    }
  }
  for (Iterator methods=theClass.getMethods().iterator(); methods.hasNext(); ) {
    SootMethod method=(SootMethod)methods.next();
    for (Iterator types=method.getParameterTypes().iterator(); types.hasNext(); ) {
      Type type=(Type)types.next();
      if (type instanceof RefType) {
        _addClass(((RefType)type).getSootClass());
      }
    }
{
      Type type=method.getReturnType();
      if (type instanceof RefType) {
        _addClass(((RefType)type).getSootClass());
      }
    }
    if (!method.isConcrete()) {
      continue;
    }
    JimpleBody body=(JimpleBody)method.retrieveActiveBody();
    for (Iterator it=body.getTraps().iterator(); it.hasNext(); ) {
      Trap t=(Trap)it.next();
      _addClass(t.getException());
    }
    for (Iterator units=body.getUnits().iterator(); units.hasNext(); ) {
      Unit unit=(Unit)units.next();
      for (Iterator boxes=unit.getUseAndDefBoxes().iterator(); boxes.hasNext(); ) {
        ValueBox box=(ValueBox)boxes.next();
        Value value=box.getValue();
        if (value instanceof FieldRef) {
          SootField field=((FieldRef)value).getField();
          SootClass refClass=field.getDeclaringClass();
          if (!refClass.equals(theClass)) {
            _addClass(refClass);
          }
        }
 else         if (value instanceof InvokeExpr) {
          SootMethod refMethod=((InvokeExpr)value).getMethod();
          SootClass refClass=refMethod.getDeclaringClass();
          if (!refClass.equals(theClass)) {
            _addClass(refClass);
          }
        }
      }
    }
  }
}","private void _processClass(SootClass theClass){
  Hierarchy hierarchy=Scene.v().getActiveHierarchy();
  if (!theClass.isApplicationClass()) {
    theClass.setLibraryClass();
  }
  _addClasses(hierarchy.getSuperclassesOfIncluding(theClass));
  _addClasses(theClass.getInterfaces());
  for (Iterator fields=theClass.getFields().iterator(); fields.hasNext(); ) {
    SootField field=(SootField)fields.next();
    Type type=field.getType();
    if (type instanceof RefType) {
      _addClass(((RefType)type).getSootClass());
    }
  }
  for (Iterator methods=theClass.getMethods().iterator(); methods.hasNext(); ) {
    SootMethod method=(SootMethod)methods.next();
    for (Iterator types=method.getParameterTypes().iterator(); types.hasNext(); ) {
      Type type=(Type)types.next();
      if (type instanceof RefType) {
        _addClass(((RefType)type).getSootClass());
      }
    }
{
      Type type=method.getReturnType();
      if (type instanceof RefType) {
        _addClass(((RefType)type).getSootClass());
      }
    }
    if (!method.isConcrete()) {
      continue;
    }
    JimpleBody body=(JimpleBody)method.retrieveActiveBody();
    for (Iterator it=body.getTraps().iterator(); it.hasNext(); ) {
      Trap t=(Trap)it.next();
      _addClass(t.getException());
    }
    for (Iterator units=body.getUnits().iterator(); units.hasNext(); ) {
      Unit unit=(Unit)units.next();
      for (Iterator boxes=unit.getUseAndDefBoxes().iterator(); boxes.hasNext(); ) {
        ValueBox box=(ValueBox)boxes.next();
        Value value=box.getValue();
        if (value instanceof FieldRef) {
          SootField field=((FieldRef)value).getField();
          SootClass refClass=field.getDeclaringClass();
          if (!refClass.equals(theClass)) {
            _addClass(refClass);
          }
        }
 else         if (value instanceof InvokeExpr) {
          SootMethod refMethod=((InvokeExpr)value).getMethod();
          SootClass refClass=refMethod.getDeclaringClass();
          if (!refClass.equals(theClass)) {
            _addClass(refClass);
          }
        }
 else         if (value instanceof NewExpr) {
          SootClass refClass=((NewExpr)value).getBaseType().getSootClass();
          if (!refClass.equals(theClass)) {
            _addClass(refClass);
          }
        }
      }
    }
  }
}"
75421,"private void _getPortFields(SootClass theClass,Entity container,Entity object){
  for (Iterator ports=object.portList().iterator(); ports.hasNext(); ) {
    Port port=(Port)ports.next();
    if (port instanceof ParameterPort) {
      continue;
    }
    String fieldName=ModelTransformer.getFieldNameForPort(port,container);
    SootField field;
    if (!theClass.declaresFieldByName(fieldName)) {
      throw new RuntimeException(""String_Node_Str"" + theClass + ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ port.getFullName());
    }
    field=theClass.getFieldByName(fieldName);
    Type type=field.getType();
    if (!(type instanceof RefType)) {
      System.out.println(""String_Node_Str"" + theClass + ""String_Node_Str""+ port.getFullName()+ ""String_Node_Str""+ type);
      continue;
    }
 else {
      SootClass fieldClass=((RefType)type).getSootClass();
      if (!SootUtilities.derivesFrom(fieldClass,PtolemyUtilities.componentPortClass)) {
        System.out.println(""String_Node_Str"" + theClass + ""String_Node_Str""+ port.getFullName()+ ""String_Node_Str""+ fieldClass.getName());
        continue;
      }
    }
    field.setModifiers((field.getModifiers() & Modifier.STATIC) | Modifier.FINAL | Modifier.PUBLIC);
    field.addTag(new ValueTag(port));
    _portToFieldMap.put(port,field);
  }
}","private void _getPortFields(SootClass theClass,Entity container,Entity object){
  for (Iterator ports=object.portList().iterator(); ports.hasNext(); ) {
    Port port=(Port)ports.next();
    String fieldName=ModelTransformer.getFieldNameForPort(port,container);
    SootField field;
    if (!theClass.declaresFieldByName(fieldName)) {
      throw new RuntimeException(""String_Node_Str"" + theClass + ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ port.getFullName());
    }
    field=theClass.getFieldByName(fieldName);
    Type type=field.getType();
    if (!(type instanceof RefType)) {
      System.out.println(""String_Node_Str"" + theClass + ""String_Node_Str""+ port.getFullName()+ ""String_Node_Str""+ type);
      continue;
    }
 else {
      SootClass fieldClass=((RefType)type).getSootClass();
      if (!SootUtilities.derivesFrom(fieldClass,PtolemyUtilities.componentPortClass)) {
        System.out.println(""String_Node_Str"" + theClass + ""String_Node_Str""+ port.getFullName()+ ""String_Node_Str""+ fieldClass.getName());
        continue;
      }
    }
    field.setModifiers((field.getModifiers() & Modifier.STATIC) | Modifier.FINAL | Modifier.PUBLIC);
    field.addTag(new ValueTag(port));
    _portToFieldMap.put(port,field);
  }
}"
75422,"private boolean _inlineMethodCalls(SootClass modelClass,SootClass theClass,SootMethod method,JimpleBody body,PortInliner inliner,boolean debug){
  boolean doneSomething=false;
  CompleteUnitGraph unitGraph=new CompleteUnitGraph(body);
  SimpleLocalDefs localDefs=new SimpleLocalDefs(unitGraph);
  SimpleLocalUses localUses=new SimpleLocalUses(unitGraph,localDefs);
  for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
    Stmt stmt=(Stmt)units.next();
    if (!stmt.containsInvokeExpr()) {
      continue;
    }
    ValueBox box=stmt.getInvokeExprBox();
    Value value=stmt.getInvokeExpr();
    if (value instanceof InstanceInvokeExpr) {
      InstanceInvokeExpr r=(InstanceInvokeExpr)value;
      if (r.getBase().getType() instanceof RefType) {
        RefType type=(RefType)r.getBase().getType();
        if (r.getMethod().equals(PtolemyUtilities.connectionsChangedMethod)) {
          if (type.getSootClass().isApplicationClass()) {
            SootMethod inlinee=null;
            if (r instanceof VirtualInvokeExpr) {
              List methodList=Scene.v().getActiveHierarchy().resolveAbstractDispatch(type.getSootClass(),PtolemyUtilities.connectionsChangedMethod);
              if (methodList.size() == 1) {
                inlinee=(SootMethod)methodList.get(0);
              }
 else {
                String string=""String_Node_Str"" + stmt + ""String_Node_Str""+ method+ ""String_Node_Str"";
                for (int i=0; i < methodList.size(); i++) {
                  string+=""String_Node_Str"" + methodList.get(i) + ""String_Node_Str"";
                }
                System.out.println(string);
              }
            }
 else             if (r instanceof SpecialInvokeExpr) {
              inlinee=Scene.v().getActiveHierarchy().resolveSpecialDispatch((SpecialInvokeExpr)r,method);
            }
            if (!inlinee.getDeclaringClass().isApplicationClass()) {
              inlinee.getDeclaringClass().setLibraryClass();
            }
            inlinee.retrieveActiveBody();
            if (debug)             System.out.println(""String_Node_Str"" + r);
            SiteInliner.inlineSite(inlinee,stmt,method);
            doneSomething=true;
          }
 else {
            body.getUnits().remove(stmt);
            doneSomething=true;
          }
        }
        Value argValues[]=new Value[r.getArgCount()];
        int constantArgCount=0;
        for (Iterator args=r.getArgs().iterator(); args.hasNext(); ) {
          Value arg=(Value)args.next();
          if (Evaluator.isValueConstantValued(arg)) {
            argValues[constantArgCount++]=Evaluator.getConstantValueOf(arg);
          }
 else {
            break;
          }
        }
        boolean allArgsAreConstant=(r.getArgCount() == constantArgCount);
        if (SootUtilities.derivesFrom(type.getSootClass(),PtolemyUtilities.componentPortClass)) {
          TypedIOPort port=(TypedIOPort)getPortValue(method,(Local)r.getBase(),stmt,localDefs,localUses);
          if (port == null) {
            continue;
          }
          if (port instanceof Typeable) {
            PtolemyUtilities.inlineTypeableMethods(body,stmt,box,r,(Typeable)port);
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getFullNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getFullName()));
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getName()));
          }
          String methodName=r.getMethod().getName();
          if (port.getWidth() == 0 && (methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"")|| methodName.equals(""String_Node_Str""))) {
            Local local=SootUtilities.createRuntimeException(body,stmt,methodName + ""String_Node_Str"" + port.getFullName()+ ""String_Node_Str"");
            body.getUnits().insertBefore(Jimple.v().newThrowStmt(local),stmt);
            if (stmt instanceof DefinitionStmt) {
              if (methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"")) {
                box.setValue(IntConstant.v(0));
              }
 else {
                box.setValue(NullConstant.v());
              }
            }
 else {
              body.getUnits().remove(stmt);
            }
            continue;
          }
          if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isInput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isOutput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isMultiport()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            Object object=SootUtilities.reflectAndInvokeMethod(port,r.getMethod(),argValues);
            Constant constant=SootUtilities.convertArgumentToConstantValue(object);
            box.setValue(constant);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            inliner.inlineGet(body,stmt,box,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            inliner.inlineSend(body,stmt,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.getWidth() == 0) {
              body.getUnits().remove(stmt);
            }
 else {
              inliner.inlineBroadcast(body,stmt,r,port);
            }
          }
        }
      }
    }
  }
  return doneSomething;
}","private boolean _inlineMethodCalls(SootClass modelClass,SootClass theClass,SootMethod method,JimpleBody body,PortInliner inliner,boolean debug){
  if (debug)   System.out.println(""String_Node_Str"" + method);
  boolean doneSomething=false;
  CompleteUnitGraph unitGraph=new CompleteUnitGraph(body);
  SimpleLocalDefs localDefs=new SimpleLocalDefs(unitGraph);
  SimpleLocalUses localUses=new SimpleLocalUses(unitGraph,localDefs);
  for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
    Stmt stmt=(Stmt)units.next();
    if (!stmt.containsInvokeExpr()) {
      continue;
    }
    ValueBox box=stmt.getInvokeExprBox();
    Value value=stmt.getInvokeExpr();
    if (value instanceof InstanceInvokeExpr) {
      InstanceInvokeExpr r=(InstanceInvokeExpr)value;
      if (r.getBase().getType() instanceof RefType) {
        RefType type=(RefType)r.getBase().getType();
        if (r.getMethod().equals(PtolemyUtilities.connectionsChangedMethod)) {
          if (type.getSootClass().isApplicationClass()) {
            SootMethod inlinee=null;
            if (r instanceof VirtualInvokeExpr) {
              List methodList=Scene.v().getActiveHierarchy().resolveAbstractDispatch(type.getSootClass(),PtolemyUtilities.connectionsChangedMethod);
              if (methodList.size() == 1) {
                inlinee=(SootMethod)methodList.get(0);
              }
 else {
                String string=""String_Node_Str"" + stmt + ""String_Node_Str""+ method+ ""String_Node_Str"";
                for (int i=0; i < methodList.size(); i++) {
                  string+=""String_Node_Str"" + methodList.get(i) + ""String_Node_Str"";
                }
                System.out.println(string);
              }
            }
 else             if (r instanceof SpecialInvokeExpr) {
              inlinee=Scene.v().getActiveHierarchy().resolveSpecialDispatch((SpecialInvokeExpr)r,method);
            }
            if (!inlinee.getDeclaringClass().isApplicationClass()) {
              inlinee.getDeclaringClass().setLibraryClass();
            }
            inlinee.retrieveActiveBody();
            if (debug)             System.out.println(""String_Node_Str"" + r);
            SiteInliner.inlineSite(inlinee,stmt,method);
            doneSomething=true;
          }
 else {
            body.getUnits().remove(stmt);
            doneSomething=true;
          }
        }
        Value argValues[]=new Value[r.getArgCount()];
        int constantArgCount=0;
        for (Iterator args=r.getArgs().iterator(); args.hasNext(); ) {
          Value arg=(Value)args.next();
          if (Evaluator.isValueConstantValued(arg)) {
            argValues[constantArgCount++]=Evaluator.getConstantValueOf(arg);
          }
 else {
            break;
          }
        }
        boolean allArgsAreConstant=(r.getArgCount() == constantArgCount);
        if (SootUtilities.derivesFrom(type.getSootClass(),PtolemyUtilities.componentPortClass)) {
          TypedIOPort port=(TypedIOPort)getPortValue(method,(Local)r.getBase(),stmt,localDefs,localUses);
          if (port == null) {
            continue;
          }
          if (port instanceof Typeable) {
            PtolemyUtilities.inlineTypeableMethods(body,stmt,box,r,(Typeable)port);
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getFullNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getFullName()));
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getName()));
          }
          String methodName=r.getMethod().getName();
          if (port.getWidth() == 0 && (methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"")|| methodName.equals(""String_Node_Str""))) {
            Local local=SootUtilities.createRuntimeException(body,stmt,methodName + ""String_Node_Str"" + port.getFullName()+ ""String_Node_Str"");
            body.getUnits().insertBefore(Jimple.v().newThrowStmt(local),stmt);
            if (stmt instanceof DefinitionStmt) {
              if (methodName.equals(""String_Node_Str"") || methodName.equals(""String_Node_Str"")) {
                box.setValue(IntConstant.v(0));
              }
 else {
                box.setValue(NullConstant.v());
              }
            }
 else {
              body.getUnits().remove(stmt);
            }
            continue;
          }
          if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isInput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isOutput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isMultiport()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            Object object=SootUtilities.reflectAndInvokeMethod(port,r.getMethod(),argValues);
            Constant constant=SootUtilities.convertArgumentToConstantValue(object);
            box.setValue(constant);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            inliner.inlineGet(body,stmt,box,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            inliner.inlineSend(body,stmt,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.getWidth() == 0) {
              body.getUnits().remove(stmt);
            }
 else {
              inliner.inlineBroadcast(body,stmt,r,port);
            }
          }
        }
      }
    }
  }
  return doneSomething;
}"
75423,"private boolean _inlineInsideMethodCalls(SootClass theClass,SootMethod method,JimpleBody body,PortInliner inliner,boolean debug){
  boolean doneSomething=false;
  CompleteUnitGraph unitGraph=new CompleteUnitGraph(body);
  SimpleLocalDefs localDefs=new SimpleLocalDefs(unitGraph);
  SimpleLocalUses localUses=new SimpleLocalUses(unitGraph,localDefs);
  for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
    Stmt stmt=(Stmt)units.next();
    if (!stmt.containsInvokeExpr()) {
      continue;
    }
    ValueBox box=stmt.getInvokeExprBox();
    Value value=stmt.getInvokeExpr();
    if (value instanceof InstanceInvokeExpr) {
      InstanceInvokeExpr r=(InstanceInvokeExpr)value;
      if (r.getBase().getType() instanceof RefType) {
        RefType type=(RefType)r.getBase().getType();
        if (r.getMethod().equals(PtolemyUtilities.connectionsChangedMethod)) {
          if (type.getSootClass().isApplicationClass()) {
            SootMethod inlinee=null;
            if (r instanceof VirtualInvokeExpr) {
              List methodList=Scene.v().getActiveHierarchy().resolveAbstractDispatch(type.getSootClass(),PtolemyUtilities.connectionsChangedMethod);
              if (methodList.size() == 1) {
                inlinee=(SootMethod)methodList.get(0);
              }
 else {
                String string=""String_Node_Str"" + stmt + ""String_Node_Str""+ method+ ""String_Node_Str"";
                for (int i=0; i < methodList.size(); i++) {
                  string+=""String_Node_Str"" + methodList.get(i) + ""String_Node_Str"";
                }
                System.out.println(string);
              }
            }
 else             if (r instanceof SpecialInvokeExpr) {
              inlinee=Scene.v().getActiveHierarchy().resolveSpecialDispatch((SpecialInvokeExpr)r,method);
            }
            if (!inlinee.getDeclaringClass().isApplicationClass()) {
              inlinee.getDeclaringClass().setLibraryClass();
            }
            inlinee.retrieveActiveBody();
            if (debug)             System.out.println(""String_Node_Str"" + r);
            SiteInliner.inlineSite(inlinee,stmt,method);
            doneSomething=true;
          }
 else {
            body.getUnits().remove(stmt);
            doneSomething=true;
          }
        }
        Value argValues[]=new Value[r.getArgCount()];
        int constantArgCount=0;
        for (Iterator args=r.getArgs().iterator(); args.hasNext(); ) {
          Value arg=(Value)args.next();
          if (Evaluator.isValueConstantValued(arg)) {
            argValues[constantArgCount++]=Evaluator.getConstantValueOf(arg);
          }
 else {
            break;
          }
        }
        boolean allArgsAreConstant=(r.getArgCount() == constantArgCount);
        if (SootUtilities.derivesFrom(type.getSootClass(),PtolemyUtilities.componentPortClass)) {
          TypedIOPort port=(TypedIOPort)getPortValue(method,(Local)r.getBase(),stmt,localDefs,localUses);
          if (port == null) {
            continue;
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getFullNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getFullName()));
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getName()));
          }
          String methodName=r.getMethod().getName();
          if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isInput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isOutput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isMultiport()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            Object object=SootUtilities.reflectAndInvokeMethod(port,r.getMethod(),argValues);
            Constant constant=SootUtilities.convertArgumentToConstantValue(object);
            box.setValue(constant);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            inliner.inlineGetInside(body,stmt,box,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            inliner.inlineSendInside(body,stmt,r,port);
          }
        }
      }
    }
  }
  return doneSomething;
}","private boolean _inlineInsideMethodCalls(SootClass theClass,SootMethod method,JimpleBody body,PortInliner inliner,boolean debug){
  if (debug)   System.out.println(""String_Node_Str"" + method);
  boolean doneSomething=false;
  CompleteUnitGraph unitGraph=new CompleteUnitGraph(body);
  SimpleLocalDefs localDefs=new SimpleLocalDefs(unitGraph);
  SimpleLocalUses localUses=new SimpleLocalUses(unitGraph,localDefs);
  for (Iterator units=body.getUnits().snapshotIterator(); units.hasNext(); ) {
    Stmt stmt=(Stmt)units.next();
    if (!stmt.containsInvokeExpr()) {
      continue;
    }
    ValueBox box=stmt.getInvokeExprBox();
    Value value=stmt.getInvokeExpr();
    if (value instanceof InstanceInvokeExpr) {
      InstanceInvokeExpr r=(InstanceInvokeExpr)value;
      if (r.getBase().getType() instanceof RefType) {
        RefType type=(RefType)r.getBase().getType();
        if (r.getMethod().equals(PtolemyUtilities.connectionsChangedMethod)) {
          if (type.getSootClass().isApplicationClass()) {
            SootMethod inlinee=null;
            if (r instanceof VirtualInvokeExpr) {
              List methodList=Scene.v().getActiveHierarchy().resolveAbstractDispatch(type.getSootClass(),PtolemyUtilities.connectionsChangedMethod);
              if (methodList.size() == 1) {
                inlinee=(SootMethod)methodList.get(0);
              }
 else {
                String string=""String_Node_Str"" + stmt + ""String_Node_Str""+ method+ ""String_Node_Str"";
                for (int i=0; i < methodList.size(); i++) {
                  string+=""String_Node_Str"" + methodList.get(i) + ""String_Node_Str"";
                }
                System.out.println(string);
              }
            }
 else             if (r instanceof SpecialInvokeExpr) {
              inlinee=Scene.v().getActiveHierarchy().resolveSpecialDispatch((SpecialInvokeExpr)r,method);
            }
            if (!inlinee.getDeclaringClass().isApplicationClass()) {
              inlinee.getDeclaringClass().setLibraryClass();
            }
            inlinee.retrieveActiveBody();
            if (debug)             System.out.println(""String_Node_Str"" + r);
            SiteInliner.inlineSite(inlinee,stmt,method);
            doneSomething=true;
          }
 else {
            body.getUnits().remove(stmt);
            doneSomething=true;
          }
        }
        Value argValues[]=new Value[r.getArgCount()];
        int constantArgCount=0;
        for (Iterator args=r.getArgs().iterator(); args.hasNext(); ) {
          Value arg=(Value)args.next();
          if (Evaluator.isValueConstantValued(arg)) {
            argValues[constantArgCount++]=Evaluator.getConstantValueOf(arg);
          }
 else {
            break;
          }
        }
        boolean allArgsAreConstant=(r.getArgCount() == constantArgCount);
        if (SootUtilities.derivesFrom(type.getSootClass(),PtolemyUtilities.componentPortClass)) {
          TypedIOPort port=(TypedIOPort)getPortValue(method,(Local)r.getBase(),stmt,localDefs,localUses);
          if (port == null) {
            continue;
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getFullNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getFullName()));
          }
          if (r.getMethod().getSubSignature().equals(PtolemyUtilities.getNameMethod.getSubSignature())) {
            box.setValue(StringConstant.v(port.getName()));
          }
          String methodName=r.getMethod().getName();
          if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isInput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isOutput()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            if (port.isMultiport()) {
              box.setValue(IntConstant.v(1));
            }
 else {
              box.setValue(IntConstant.v(0));
            }
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            Object object=SootUtilities.reflectAndInvokeMethod(port,r.getMethod(),argValues);
            Constant constant=SootUtilities.convertArgumentToConstantValue(object);
            box.setValue(constant);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            box.setValue(IntConstant.v(1));
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            inliner.inlineGetInside(body,stmt,box,r,port);
          }
 else           if (r.getMethod().getName().equals(""String_Node_Str"")) {
            inliner.inlineSendInside(body,stmt,r,port);
          }
        }
      }
    }
  }
  return doneSomething;
}"
75424,"private static void _createActorsIn(CompositeActor model,HashSet createdSet,String phaseName,ConstVariableModelAnalysis constAnalysis,Map options){
  for (Iterator i=model.deepEntityList().iterator(); i.hasNext(); ) {
    Entity entity=(Entity)i.next();
    String className=entity.getClass().getName();
    String newClassName=getInstanceClassName(entity,options);
    if (Scene.v().containsClass(newClassName)) {
      continue;
    }
    System.out.println(""String_Node_Str"" + newClassName);
    System.out.println(""String_Node_Str"" + entity.getFullName());
    System.out.println(""String_Node_Str"" + className);
    if (entity instanceof CompositeActor) {
      CompositeActor composite=(CompositeActor)entity;
      _createCompositeActor(composite,newClassName,options);
    }
 else     if (entity instanceof Expression) {
      AtomicActorCreator creator=new ExpressionCreator();
      creator.createAtomicActor((Expression)entity,newClassName,constAnalysis,options);
    }
 else     if (entity instanceof FSMActor) {
      FSMCreator creator=new FSMCreator();
      creator.createAtomicActor((FSMActor)entity,newClassName,constAnalysis,options);
    }
 else {
      GenericAtomicActorCreator creator=new GenericAtomicActorCreator();
      creator.createAtomicActor((AtomicActor)entity,newClassName,constAnalysis,options);
    }
    SootClass entityClass=Scene.v().loadClassAndSupport(newClassName);
    addActorForClass(entityClass,entity);
  }
}","private static void _createActorsIn(CompositeActor model,HashSet createdSet,String phaseName,ConstVariableModelAnalysis constAnalysis,Map options){
  for (Iterator i=model.deepEntityList().iterator(); i.hasNext(); ) {
    Entity entity=(Entity)i.next();
    String className=entity.getClass().getName();
    String newClassName=getInstanceClassName(entity,options);
    if (Scene.v().containsClass(newClassName)) {
      continue;
    }
    System.out.println(""String_Node_Str"" + newClassName);
    System.out.println(""String_Node_Str"" + entity.getFullName());
    System.out.println(""String_Node_Str"" + className);
    if (entity.getClass().getName().equals(""String_Node_Str"")) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (entity instanceof CompositeActor) {
      CompositeActor composite=(CompositeActor)entity;
      _createCompositeActor(composite,newClassName,options);
    }
 else     if (entity instanceof Expression) {
      AtomicActorCreator creator=new ExpressionCreator();
      creator.createAtomicActor((Expression)entity,newClassName,constAnalysis,options);
    }
 else     if (entity instanceof FSMActor) {
      FSMCreator creator=new FSMCreator();
      creator.createAtomicActor((FSMActor)entity,newClassName,constAnalysis,options);
    }
 else {
      GenericAtomicActorCreator creator=new GenericAtomicActorCreator();
      creator.createAtomicActor((AtomicActor)entity,newClassName,constAnalysis,options);
    }
    SootClass entityClass=Scene.v().loadClassAndSupport(newClassName);
    addActorForClass(entityClass,entity);
  }
}"
75425,"private Local _convertTokenArgToJavaArg(Local tokenLocal,ptolemy.data.type.Type tokenType,CachedMethod.ArgumentConversion conversion) throws IllegalActionException {
  if (conversion == CachedMethod.IDENTITY_CONVERSION) {
    Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",PtolemyUtilities.tokenType);
    _body.getLocals().add(tempLocal);
    _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,tokenLocal),_insertPoint);
    return tempLocal;
  }
 else   if (conversion == CachedMethod.ARRAYTOKEN_CONVERSION) {
    Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.arrayTokenClass));
    _body.getLocals().add(tempLocal);
    Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(RefType.v(PtolemyUtilities.objectClass),1));
    _body.getLocals().add(resultLocal);
    _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(PtolemyUtilities.arrayTokenClass))),_insertPoint);
    _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.arrayValueMethod)),_insertPoint);
    return resultLocal;
  }
 else   if (conversion == CachedMethod.NATIVE_CONVERSION) {
    if (tokenType == ptolemy.data.type.BaseType.DOUBLE) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.doubleTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",DoubleType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(PtolemyUtilities.doubleTokenClass))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.doubleValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.UNSIGNED_BYTE) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.unsignedByteTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ByteType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(PtolemyUtilities.unsignedByteTokenClass))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.unsignedByteValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.INT) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.intTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",IntType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.intValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.LONG) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.longTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",LongType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.longValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.STRING) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.stringTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(""String_Node_Str""));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.stringValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.BOOLEAN) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.booleanTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",BooleanType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.booleanValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.COMPLEX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.complexTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(""String_Node_Str""));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.complexValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.FIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.intTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(""String_Node_Str""));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.fixValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.DOUBLE_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.doubleMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(DoubleType.v(),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.doubleMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.INT_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.intMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(IntType.v(),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.intMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.LONG_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.longMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(LongType.v(),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.longMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.BOOLEAN_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.booleanMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(BooleanType.v(),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.booleanMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.COMPLEX_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.complexMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(RefType.v(""String_Node_Str""),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.complexMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.FIX_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.fixMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(RefType.v(""String_Node_Str""),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.fixMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + conversion);
  }
}","private Local _convertTokenArgToJavaArg(Local tokenLocal,ptolemy.data.type.Type tokenType,CachedMethod.ArgumentConversion conversion) throws IllegalActionException {
  if (conversion == CachedMethod.IDENTITY_CONVERSION) {
    Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",PtolemyUtilities.tokenType);
    _body.getLocals().add(tempLocal);
    _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,tokenLocal),_insertPoint);
    return tempLocal;
  }
 else   if (conversion == CachedMethod.ARRAYTOKEN_CONVERSION) {
    Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.arrayTokenClass));
    _body.getLocals().add(tempLocal);
    Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(RefType.v(PtolemyUtilities.objectClass),1));
    _body.getLocals().add(resultLocal);
    _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(PtolemyUtilities.arrayTokenClass))),_insertPoint);
    _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.arrayValueMethod)),_insertPoint);
    return resultLocal;
  }
 else   if (conversion == CachedMethod.NATIVE_CONVERSION) {
    if (tokenType == ptolemy.data.type.BaseType.DOUBLE) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.doubleTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",DoubleType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(PtolemyUtilities.doubleTokenClass))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.doubleValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.UNSIGNED_BYTE) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.unsignedByteTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ByteType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(PtolemyUtilities.unsignedByteTokenClass))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.unsignedByteValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.INT) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.intTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",IntType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.intValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.LONG) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.longTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",LongType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.longValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.STRING) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.stringTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(""String_Node_Str""));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.stringValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.BOOLEAN) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.booleanTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",BooleanType.v());
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.booleanValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.COMPLEX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.complexTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(""String_Node_Str""));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.complexValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.FIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.intTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(""String_Node_Str""));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.fixValueMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.DOUBLE_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.doubleMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(DoubleType.v(),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.doubleMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.INT_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.intMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(IntType.v(),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.intMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.LONG_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.longMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(LongType.v(),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.longMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.BOOLEAN_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.booleanMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(BooleanType.v(),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.booleanMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.COMPLEX_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.complexMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(RefType.v(""String_Node_Str""),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(resultLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.complexMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else     if (tokenType == ptolemy.data.type.BaseType.FIX_MATRIX) {
      Local tempLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.fixMatrixTokenClass));
      _body.getLocals().add(tempLocal);
      Local resultLocal=Jimple.v().newLocal(""String_Node_Str"",ArrayType.v(RefType.v(""String_Node_Str""),2));
      _body.getLocals().add(resultLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newCastExpr(tokenLocal,RefType.v(""String_Node_Str""))),_insertPoint);
      _units.insertBefore(Jimple.v().newAssignStmt(tempLocal,Jimple.v().newVirtualInvokeExpr(tempLocal,PtolemyUtilities.fixMatrixMethod)),_insertPoint);
      return resultLocal;
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + tokenType);
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + conversion);
  }
}"
75426,"public void visitMethodCallNode(ASTPtMethodCallNode node) throws IllegalActionException {
  _debug(node);
  int argCount=node.jjtGetNumChildren();
  _generateAllChildren(node);
  ptolemy.data.type.Type baseTokenType=((ASTPtRootNode)node.jjtGetChild(0)).getType();
  if (argCount == 1 && baseTokenType instanceof RecordType) {
    RecordType type=(RecordType)baseTokenType;
    if (type.labelSet().contains(node.getMethodName())) {
      Local originalBaseLocal=(Local)_nodeToLocal.get(node.jjtGetChild(0));
      Local baseLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.recordTokenClass));
      _body.getLocals().add(baseLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(baseLocal,Jimple.v().newCastExpr(originalBaseLocal,RefType.v(PtolemyUtilities.recordTokenClass))),_insertPoint);
      Local returnLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.tokenClass));
      _body.getLocals().add(returnLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(returnLocal,Jimple.v().newVirtualInvokeExpr(baseLocal,PtolemyUtilities.recordGetMethod,StringConstant.v(node.getMethodName()))),_insertPoint);
      _nodeToLocal.put(node,returnLocal);
      return;
    }
  }
  ptolemy.data.type.Type[] argTypes=new ptolemy.data.type.Type[node.jjtGetNumChildren()];
  for (int i=0; i < node.jjtGetNumChildren(); i++) {
    argTypes[i]=((ASTPtRootNode)node.jjtGetChild(i)).getType();
  }
  CachedMethod cachedMethod=CachedMethod.findMethod(node.getMethodName(),argTypes,CachedMethod.METHOD);
  if (!cachedMethod.isValid()) {
    throw new IllegalActionException(""String_Node_Str"" + cachedMethod + ""String_Node_Str"");
  }
  if (cachedMethod instanceof CachedMethod.ArrayMapCachedMethod || cachedMethod instanceof CachedMethod.MatrixMapCachedMethod) {
    throw new IllegalActionException(""String_Node_Str"" + cachedMethod.getClass());
  }
  Method method=cachedMethod.getMethod();
  SootMethod sootMethod=SootUtilities.getSootMethodForMethod(method);
  Local originalBaseLocal=(Local)_nodeToLocal.get(node.jjtGetChild(0));
  RefType baseType=RefType.v(sootMethod.getDeclaringClass());
  Local baseLocal=Jimple.v().newLocal(""String_Node_Str"",baseType);
  _body.getLocals().add(baseLocal);
  if (cachedMethod instanceof CachedMethod.BaseConvertCachedMethod) {
    RefType tempBaseType=PtolemyUtilities.getSootTypeForTokenType(argTypes[0]);
    Local tempBaseLocal=_convertTokenArgToJavaArg(originalBaseLocal,argTypes[0],((CachedMethod.BaseConvertCachedMethod)cachedMethod).getBaseConversion());
    _units.insertBefore(Jimple.v().newAssignStmt(baseLocal,Jimple.v().newCastExpr(tempBaseLocal,baseType)),_insertPoint);
  }
 else {
    _units.insertBefore(Jimple.v().newAssignStmt(baseLocal,Jimple.v().newCastExpr(originalBaseLocal,baseType)),_insertPoint);
  }
  List args=new LinkedList();
  CachedMethod.ArgumentConversion[] conversions=cachedMethod.getConversions();
  for (int i=1; i < node.jjtGetNumChildren(); i++) {
    Local tokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(i));
    Local argLocal=_convertTokenArgToJavaArg(tokenLocal,argTypes[i - 1],conversions[i - 1]);
    args.add(argLocal);
  }
  Type returnType=sootMethod.getReturnType();
  Local returnLocal=Jimple.v().newLocal(""String_Node_Str"",returnType);
  _body.getLocals().add(returnLocal);
  _units.insertBefore(Jimple.v().newAssignStmt(returnLocal,Jimple.v().newVirtualInvokeExpr(baseLocal,sootMethod,args)),_insertPoint);
  Local tokenLocal=_convertJavaResultToToken(returnLocal,returnType);
  _nodeToLocal.put(node,tokenLocal);
}","public void visitMethodCallNode(ASTPtMethodCallNode node) throws IllegalActionException {
  _debug(node);
  int argCount=node.jjtGetNumChildren();
  _generateAllChildren(node);
  ptolemy.data.type.Type baseTokenType=((ASTPtRootNode)node.jjtGetChild(0)).getType();
  if (argCount == 1 && baseTokenType instanceof RecordType) {
    RecordType type=(RecordType)baseTokenType;
    if (type.labelSet().contains(node.getMethodName())) {
      Local originalBaseLocal=(Local)_nodeToLocal.get(node.jjtGetChild(0));
      Local baseLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.recordTokenClass));
      _body.getLocals().add(baseLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(baseLocal,Jimple.v().newCastExpr(originalBaseLocal,RefType.v(PtolemyUtilities.recordTokenClass))),_insertPoint);
      Local returnLocal=Jimple.v().newLocal(""String_Node_Str"",RefType.v(PtolemyUtilities.tokenClass));
      _body.getLocals().add(returnLocal);
      _units.insertBefore(Jimple.v().newAssignStmt(returnLocal,Jimple.v().newVirtualInvokeExpr(baseLocal,PtolemyUtilities.recordGetMethod,StringConstant.v(node.getMethodName()))),_insertPoint);
      _nodeToLocal.put(node,returnLocal);
      return;
    }
  }
  ptolemy.data.type.Type[] argTypes=new ptolemy.data.type.Type[node.jjtGetNumChildren()];
  for (int i=0; i < node.jjtGetNumChildren(); i++) {
    argTypes[i]=((ASTPtRootNode)node.jjtGetChild(i)).getType();
  }
  CachedMethod cachedMethod=CachedMethod.findMethod(node.getMethodName(),argTypes,CachedMethod.METHOD);
  if (!cachedMethod.isValid()) {
    throw new IllegalActionException(""String_Node_Str"" + cachedMethod + ""String_Node_Str"");
  }
  if (cachedMethod instanceof CachedMethod.ArrayMapCachedMethod || cachedMethod instanceof CachedMethod.MatrixMapCachedMethod) {
    throw new IllegalActionException(""String_Node_Str"" + cachedMethod.getClass());
  }
  Method method=cachedMethod.getMethod();
  SootMethod sootMethod=SootUtilities.getSootMethodForMethod(method);
  Local originalBaseLocal=(Local)_nodeToLocal.get(node.jjtGetChild(0));
  RefType baseType=RefType.v(sootMethod.getDeclaringClass());
  Local baseLocal=Jimple.v().newLocal(""String_Node_Str"",baseType);
  _body.getLocals().add(baseLocal);
  if (cachedMethod instanceof CachedMethod.BaseConvertCachedMethod) {
    RefType tempBaseType=PtolemyUtilities.getSootTypeForTokenType(argTypes[0]);
    Local tempBaseLocal=_convertTokenArgToJavaArg(originalBaseLocal,argTypes[0],((CachedMethod.BaseConvertCachedMethod)cachedMethod).getBaseConversion());
    _units.insertBefore(Jimple.v().newAssignStmt(baseLocal,Jimple.v().newCastExpr(tempBaseLocal,baseType)),_insertPoint);
  }
 else {
    _units.insertBefore(Jimple.v().newAssignStmt(baseLocal,Jimple.v().newCastExpr(originalBaseLocal,baseType)),_insertPoint);
  }
  List args=new LinkedList();
  CachedMethod.ArgumentConversion[] conversions=cachedMethod.getConversions();
  for (int i=1; i < node.jjtGetNumChildren(); i++) {
    Local tokenLocal=(Local)_nodeToLocal.get(node.jjtGetChild(i));
    Local argLocal=_convertTokenArgToJavaArg(tokenLocal,argTypes[i],conversions[i - 1]);
    args.add(argLocal);
  }
  Type returnType=sootMethod.getReturnType();
  Local returnLocal=Jimple.v().newLocal(""String_Node_Str"",returnType);
  _body.getLocals().add(returnLocal);
  _units.insertBefore(Jimple.v().newAssignStmt(returnLocal,Jimple.v().newVirtualInvokeExpr(baseLocal,sootMethod,args)),_insertPoint);
  Local tokenLocal=_convertJavaResultToToken(returnLocal,returnType);
  _nodeToLocal.put(node,tokenLocal);
}"
75427,"/** 
 * Return the parameterized scheduling sequence.   An exception will be thrown if the graph is not schedulable.  
 * @return A schedule of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If a parameterized schedule cannot be derived for the model.
 * @exception IllegalActionException If the rate parametersof the model are not correct, or the computed rates for external ports are not correct.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  _debug(""String_Node_Str"");
  PSDFDirector director=(PSDFDirector)getContainer();
  CompositeActor model=(CompositeActor)director.getContainer();
  PSDFGraphReader graphReader=new PSDFGraphReader();
  PSDFGraph psdfGraph=(PSDFGraph)(graphReader.convert(model));
  _debug(""String_Node_Str"");
  _debug(psdfGraph.toString() + ""String_Node_Str"");
  psdfGraph.printEdgeRateExpressions();
  _debug(""String_Node_Str"");
  PSDFAPGANStrategy scheduler=new PSDFAPGANStrategy(psdfGraph);
  ptolemy.graph.sched.Schedule schedule=scheduler.schedule();
  _debug(""String_Node_Str"");
  _debug(schedule.toString() + ""String_Node_Str"");
  SymbolicScheduleElement result=_expandAPGAN(psdfGraph,scheduler.getClusteredGraphRoot(),scheduler);
  _debug(""String_Node_Str"" + ""String_Node_Str"" + result.toString() + ""String_Node_Str"");
  return (Schedule)result;
}","/** 
 * Return the parameterized scheduling sequence.   An exception will be thrown if the graph is not schedulable.  
 * @return A schedule of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If a parameterized schedule cannot be derived for the model.
 * @exception IllegalActionException If the rate parametersof the model are not correct, or the computed rates for external ports are not correct.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  _debug(""String_Node_Str"");
  PSDFDirector director=(PSDFDirector)getContainer();
  CompositeActor model=(CompositeActor)director.getContainer();
  PSDFGraphReader graphReader=new PSDFGraphReader();
  PSDFGraph psdfGraph=(PSDFGraph)(graphReader.convert(model));
  _debug(""String_Node_Str"");
  _debug(psdfGraph.toString() + ""String_Node_Str"");
  psdfGraph.printEdgeRateExpressions();
  _debug(""String_Node_Str"");
  PSDFAPGANStrategy scheduler=new PSDFAPGANStrategy(psdfGraph);
  ptolemy.graph.sched.Schedule schedule=scheduler.schedule();
  _debug(""String_Node_Str"");
  _debug(schedule.toString() + ""String_Node_Str"");
  SymbolicScheduleElement result=_expandAPGAN(psdfGraph,scheduler.getClusteredGraphRoot(),scheduler);
  _debug(""String_Node_Str"" + ""String_Node_Str"" + result.toString() + ""String_Node_Str"");
  _debug(""String_Node_Str"");
  _saveBufferSizes(_bufferSizeMap);
  _debug(""String_Node_Str"");
  _debug(displayBufferSizes() + ""String_Node_Str"");
  if (_debugging) {
    _debug(""String_Node_Str"");
    Iterator relations=_bufferSizeMap.keySet().iterator();
    while (relations.hasNext()) {
      Relation relation=(Relation)relations.next();
      _debug(relation.getName() + ""String_Node_Str"" + _bufferSizeMap.get(relation)+ ""String_Node_Str"");
    }
  }
  return (Schedule)result;
}"
75428,"private SymbolicScheduleElement _expandAPGAN(PSDFGraph graph,ptolemy.graph.Node node,PSDFAPGANStrategy apgan){
  PSDFGraph childGraph=(PSDFGraph)apgan.getSubgraph(node);
  try {
    if (childGraph == null) {
      PSDFNodeWeight weight=(PSDFNodeWeight)node.getWeight();
      SymbolicFiring firing=new SymbolicFiring((Actor)weight.getComputation(),""String_Node_Str"");
      return firing;
    }
 else {
      Schedule schedule=new Schedule();
      Edge edge=(Edge)childGraph.edges().iterator().next();
      ptolemy.graph.Node source=edge.source();
      ptolemy.graph.Node sink=edge.sink();
      SymbolicScheduleElement first=_expandAPGAN(childGraph,source,apgan);
      SymbolicScheduleElement second=_expandAPGAN(childGraph,sink,apgan);
      String producedExpression=apgan.producedExpression(edge);
      String consumedExpression=apgan.consumedExpression(edge);
      if (producedExpression == null) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ edge);
      }
 else       if (consumedExpression == null) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ edge);
      }
      String denominator=PSDFGraphs.gcdExpression(producedExpression,consumedExpression);
      String firstIterations=""String_Node_Str"" + consumedExpression + ""String_Node_Str""+ denominator+ ""String_Node_Str"";
      String secondIterations=""String_Node_Str"" + producedExpression + ""String_Node_Str""+ denominator+ ""String_Node_Str"";
      first.setIterationCount(firstIterations);
      second.setIterationCount(secondIterations);
      SymbolicSchedule symbolicSchedule=new SymbolicSchedule(""String_Node_Str"");
      symbolicSchedule.add((ScheduleElement)first);
      symbolicSchedule.add((ScheduleElement)second);
      Iterator edges=childGraph.edges().iterator();
      while (edges.hasNext()) {
        Edge nextEdge=(Edge)edges.next();
        PSDFEdgeWeight weight=(PSDFEdgeWeight)nextEdge.getWeight();
        IOPort sourcePort=weight.getSourcePort();
        List relationList=sourcePort.linkedRelationList();
        if (relationList.size() != 1) {
          throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + relationList.size() + ""String_Node_Str""+ nextEdge+ ""String_Node_Str"");
        }
        Iterator relations=relationList.iterator();
        Relation relation=(Relation)relations.next();
        String produced=apgan.producedExpression(nextEdge);
        String consumed=apgan.consumedExpression(nextEdge);
        String bufferSizeExpression=""String_Node_Str"" + produced + ""String_Node_Str""+ consumed+ ""String_Node_Str""+ PSDFGraphs.gcdExpression(produced,consumed);
        _bufferSizeMap.put(relation,bufferSizeExpression);
      }
      return symbolicSchedule;
    }
  }
 catch (  Exception exception) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + exception.getMessage());
  }
}","private SymbolicScheduleElement _expandAPGAN(PSDFGraph graph,ptolemy.graph.Node node,PSDFAPGANStrategy apgan){
  PSDFGraph childGraph=(PSDFGraph)apgan.getSubgraph(node);
  try {
    if (childGraph == null) {
      PSDFNodeWeight weight=(PSDFNodeWeight)node.getWeight();
      SymbolicFiring firing=new SymbolicFiring((Actor)weight.getComputation(),""String_Node_Str"");
      return firing;
    }
 else {
      Schedule schedule=new Schedule();
      Edge edge=(Edge)childGraph.edges().iterator().next();
      ptolemy.graph.Node source=edge.source();
      ptolemy.graph.Node sink=edge.sink();
      SymbolicScheduleElement first=_expandAPGAN(childGraph,source,apgan);
      SymbolicScheduleElement second=_expandAPGAN(childGraph,sink,apgan);
      String producedExpression=apgan.producedExpression(edge);
      String consumedExpression=apgan.consumedExpression(edge);
      if (producedExpression == null) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ edge);
      }
 else       if (consumedExpression == null) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ edge);
      }
      String denominator=PSDFGraphs.gcdExpression(producedExpression,consumedExpression);
      String firstIterations=""String_Node_Str"" + consumedExpression + ""String_Node_Str""+ denominator+ ""String_Node_Str"";
      String secondIterations=""String_Node_Str"" + producedExpression + ""String_Node_Str""+ denominator+ ""String_Node_Str"";
      first.setIterationCount(firstIterations);
      second.setIterationCount(secondIterations);
      SymbolicSchedule symbolicSchedule=new SymbolicSchedule(""String_Node_Str"");
      symbolicSchedule.add((ScheduleElement)first);
      symbolicSchedule.add((ScheduleElement)second);
      Iterator edges=childGraph.edges().iterator();
      while (edges.hasNext()) {
        Edge nextEdge=(Edge)edges.next();
        PSDFEdgeWeight weight=(PSDFEdgeWeight)nextEdge.getWeight();
        IOPort sourcePort=weight.getSourcePort();
        List relationList=sourcePort.linkedRelationList();
        if (relationList.size() != 1) {
          throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + relationList.size() + ""String_Node_Str""+ nextEdge+ ""String_Node_Str"");
        }
        Iterator relations=relationList.iterator();
        Relation relation=(Relation)relations.next();
        String produced=apgan.producedExpression(nextEdge);
        String consumed=apgan.consumedExpression(nextEdge);
        String bufferSizeExpression=""String_Node_Str"" + produced + ""String_Node_Str""+ consumed+ ""String_Node_Str""+ PSDFGraphs.gcdExpression(produced,consumed);
        _debug(""String_Node_Str"" + bufferSizeExpression + ""String_Node_Str""+ relation.getName()+ ""String_Node_Str"");
        _bufferSizeMap.put(relation,bufferSizeExpression);
      }
      return symbolicSchedule;
    }
  }
 catch (  Exception exception) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + exception.getMessage());
  }
}"
75429,"/** 
 * Merge the top two undo entries into a single action. If there are fewer than two entries on the stack, do nothing. Note that when two entries are merged, the one on the top of the stack becomes the first one executed and the one below that on the stack becomes the second one executed.
 */
public void mergeTopTwo(){
  if (_undoEntries.size() > 1) {
    UndoAction lastUndo=(UndoAction)_undoEntries.pop();
    UndoAction firstUndo=(UndoAction)_undoEntries.pop();
    UndoAction mergedAction=_mergeActions(lastUndo,firstUndo);
    _undoEntries.push(mergedAction);
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + mergedAction.toString());
    }
  }
}","/** 
 * Merge the top two undo entries into a single action, unless we are in either a redo or an undo, in which case the merge happens automatically and need not be explicitly requested by the client. If there are fewer than two entries on the stack, do nothing. Note that when two entries are merged, the one on the top of the stack becomes the first one executed and the one below that on the stack becomes the second one executed.
 */
public void mergeTopTwo(){
  if (_inUndo == 0 && _inRedo == 0) {
    if (_undoEntries.size() > 1) {
      UndoAction lastUndo=(UndoAction)_undoEntries.pop();
      UndoAction firstUndo=(UndoAction)_undoEntries.pop();
      UndoAction mergedAction=_mergeActions(lastUndo,firstUndo);
      _undoEntries.push(mergedAction);
      if (_DEBUG) {
        System.out.println(""String_Node_Str"" + mergedAction.toString());
      }
    }
  }
}"
75430,"/** 
 * Push an action to the undo stack, or if we are executing an undo, onto the redo stack.
 * @param action The undo action.
 */
public void push(UndoAction action){
  if (_inUndo > 1) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + action.toString());
    }
    UndoAction previousRedo=(UndoAction)_redoEntries.pop();
    _redoEntries.push(_mergeActions(previousRedo,action));
    _inUndo++;
  }
 else   if (_inUndo == 1) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + action.toString());
    }
    _redoEntries.push(action);
    _inUndo++;
  }
 else   if (_inRedo > 1) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + action.toString());
    }
    UndoAction previousRedo=(UndoAction)_redoEntries.pop();
    _undoEntries.push(_mergeActions(previousRedo,action));
    _inRedo++;
  }
 else   if (_inRedo == 1) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + action.toString());
    }
    _undoEntries.push(action);
    _inRedo++;
  }
 else {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + action.toString());
    }
    _undoEntries.push(action);
    if (_DEBUG) {
      System.out.println(""String_Node_Str"");
    }
    _redoEntries.clear();
  }
}","/** 
 * Push an action to the undo stack, or if we are executing an undo, onto the redo stack.
 * @param action The undo action.
 */
public void push(UndoAction action){
  if (_inUndo > 1) {
    UndoAction previousRedo=(UndoAction)_redoEntries.pop();
    UndoAction mergedAction=_mergeActions(action,previousRedo);
    _redoEntries.push(mergedAction);
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + mergedAction.toString());
    }
    _inUndo++;
  }
 else   if (_inUndo == 1) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + action.toString());
    }
    _redoEntries.push(action);
    _inUndo++;
  }
 else   if (_inRedo > 1) {
    UndoAction previousUndo=(UndoAction)_undoEntries.pop();
    UndoAction mergedAction=_mergeActions(action,previousUndo);
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + mergedAction.toString());
    }
    _undoEntries.push(mergedAction);
    _inRedo++;
  }
 else   if (_inRedo == 1) {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + action.toString());
    }
    _undoEntries.push(action);
    _inRedo++;
  }
 else {
    if (_DEBUG) {
      System.out.println(""String_Node_Str"" + action.toString());
    }
    _undoEntries.push(action);
    if (_DEBUG) {
      System.out.println(""String_Node_Str"");
    }
    _redoEntries.clear();
  }
}"
75431,"/** 
 * Create a new background figure.  This method looks for entities contained by the same container, and if there are any, copies the icon of the last such entity.  If there are none, then it behaves like the base class.
 * @return A new figure.
 */
public Figure createBackgroundFigure(){
  Figure result=null;
  Nameable container=getContainer();
  if (container instanceof CompositeEntity) {
    CompositeEntity myContainer=((CompositeEntity)container);
    ComponentEntity entity=null;
    Iterator entities=myContainer.entityList().iterator();
    while (entities.hasNext()) {
      entity=(ComponentEntity)entities.next();
    }
    if (entity != null) {
      EditorIcon icon=null;
      Iterator icons=entity.attributeList(EditorIcon.class).iterator();
      while (icons.hasNext()) {
        icon=(EditorIcon)icons.next();
      }
      if (icon != null) {
        result=icon.createBackgroundFigure();
      }
 else {
        try {
          SingletonConfigurableAttribute description=(SingletonConfigurableAttribute)entity.getAttribute(""String_Node_Str"",SingletonConfigurableAttribute.class);
          if (description != null) {
            SingletonConfigurableAttribute myDescription=(SingletonConfigurableAttribute)myContainer.getAttribute(""String_Node_Str"",SingletonConfigurableAttribute.class);
            if (myDescription != null) {
              myDescription.configure(null,null,description.getText());
            }
          }
        }
 catch (        Exception e) {
        }
      }
    }
  }
  if (result == null) {
    result=super.createBackgroundFigure();
  }
  Rectangle2D bounds=result.getBounds();
  CompositeFigure composite=new CompositeFigure();
  BasicRectangle rectangle=new BasicRectangle(bounds.getX() + 10.0,bounds.getY() + 10.0,bounds.getWidth(),bounds.getHeight(),Color.white);
  composite.add(rectangle);
  BasicRectangle rectangle2=new BasicRectangle(bounds.getX() + 5.0,bounds.getY() + 5.0,bounds.getWidth(),bounds.getHeight(),Color.white);
  composite.add(rectangle2);
  BasicRectangle rectangle3=new BasicRectangle(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight(),Color.white);
  composite.add(rectangle3);
  composite.add(result);
  return composite;
}","/** 
 * Create a new background figure.  This method looks for entities contained by the same container, and if there are any, copies the icon of the last such entity.  If there are none, then it behaves like the base class.
 * @return A new figure.
 */
public Figure createBackgroundFigure(){
  Figure result=null;
  Nameable container=getContainer();
  if (container instanceof CompositeEntity) {
    CompositeEntity myContainer=((CompositeEntity)container);
    ComponentEntity entity=null;
    Iterator entities=myContainer.entityList().iterator();
    while (entities.hasNext()) {
      entity=(ComponentEntity)entities.next();
    }
    try {
      if (entity != null) {
        EditorIcon icon=null;
        Iterator icons=entity.attributeList(EditorIcon.class).iterator();
        while (icons.hasNext()) {
          icon=(EditorIcon)icons.next();
        }
        if (icon != null) {
          result=icon.createBackgroundFigure();
        }
 else {
          SingletonConfigurableAttribute description=(SingletonConfigurableAttribute)entity.getAttribute(""String_Node_Str"",SingletonConfigurableAttribute.class);
          if (description != null) {
            SingletonConfigurableAttribute myDescription=(SingletonConfigurableAttribute)myContainer.getAttribute(""String_Node_Str"",SingletonConfigurableAttribute.class);
            if (myDescription != null) {
              if (_originalDescription == null) {
                _originalDescription=myDescription.getText();
              }
              myDescription.configure(null,null,description.getText());
            }
          }
        }
      }
 else {
        if (result == null && _originalDescription != null) {
          SingletonConfigurableAttribute myDescription=(SingletonConfigurableAttribute)myContainer.getAttribute(""String_Node_Str"",SingletonConfigurableAttribute.class);
          if (myDescription != null) {
            myDescription.configure(null,null,_originalDescription);
          }
        }
      }
    }
 catch (    Exception e) {
    }
  }
  if (result == null) {
    result=super.createBackgroundFigure();
  }
  Rectangle2D bounds=result.getBounds();
  CompositeFigure composite=new CompositeFigure();
  BasicRectangle rectangle=new BasicRectangle(bounds.getX() + 10.0,bounds.getY() + 10.0,bounds.getWidth(),bounds.getHeight(),Color.white);
  composite.add(rectangle);
  BasicRectangle rectangle2=new BasicRectangle(bounds.getX() + 5.0,bounds.getY() + 5.0,bounds.getWidth(),bounds.getHeight(),Color.white);
  composite.add(rectangle2);
  BasicRectangle rectangle3=new BasicRectangle(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight(),Color.white);
  composite.add(rectangle3);
  composite.add(result);
  return composite;
}"
75432,"/** 
 * Set the expression associated with the iteration count. The expression will probably be something like ""a2::in::tokenConsumptionRate/gcd(a2::in::tokenConsumptionRate, a::out::tokenProductionRate).""
 * @param expression The expression to be associated with the iterationcount.
 */
public void setIterationCount(String expression){
  try {
    PtParser parser=new PtParser();
    _parseTree=parser.generateParseTree(expression);
  }
 catch (  Exception exception) {
    throw new RuntimeException(""String_Node_Str"" + expression + ""String_Node_Str""+ exception.getMessage());
  }
  _debugMessage(""String_Node_Str"");
  _debugMessage(""String_Node_Str"" + ""String_Node_Str"");
  _debugMessage(""String_Node_Str"" + expression + ""String_Node_Str"");
  _debugMessage(""String_Node_Str"" + _scheduleElement + ""String_Node_Str"");
  _debugMessage(""String_Node_Str"");
  _parseTree.displayParseTree(""String_Node_Str"");
  _debugMessage(""String_Node_Str"");
}","/** 
 * Set the expression associated with the iteration count. The expression will probably be something like ""a2::in::tokenConsumptionRate/gcd(a2::in::tokenConsumptionRate, a::out::tokenProductionRate).""
 * @param expression The expression to be associated with the iterationcount.
 */
public void setIterationCount(String expression){
  _expression=expression;
  try {
    PtParser parser=new PtParser();
    _parseTree=parser.generateParseTree(expression);
  }
 catch (  Exception exception) {
    throw new RuntimeException(""String_Node_Str"" + expression + ""String_Node_Str""+ exception.getMessage());
  }
  _debugMessage(""String_Node_Str"");
  _debugMessage(""String_Node_Str"" + ""String_Node_Str"");
  _debugMessage(""String_Node_Str"" + expression + ""String_Node_Str"");
  _debugMessage(""String_Node_Str"" + _scheduleElement + ""String_Node_Str"");
  _debugMessage(""String_Node_Str"");
  _parseTree.displayParseTree(""String_Node_Str"");
  _debugMessage(""String_Node_Str"");
}"
75433,"private SymbolicScheduleElement _expandAPGAN(PSDFGraph graph,ptolemy.graph.Node node,PSDFAPGANStrategy apgan){
  PSDFGraph childGraph=(PSDFGraph)apgan.getSubgraph(node);
  try {
    if (childGraph == null) {
      PSDFNodeWeight weight=(PSDFNodeWeight)node.getWeight();
      SymbolicFiring firing=new SymbolicFiring((Actor)weight.getComputation(),""String_Node_Str"");
      return firing;
    }
 else {
      Schedule schedule=new Schedule();
      Edge edge=(Edge)childGraph.edges().iterator().next();
      ptolemy.graph.Node source=edge.source();
      ptolemy.graph.Node sink=edge.sink();
      SymbolicScheduleElement first=_expandAPGAN(childGraph,source,apgan);
      SymbolicScheduleElement second=_expandAPGAN(childGraph,sink,apgan);
      String producedExpression=apgan.producedExpression(edge);
      String consumedExpression=apgan.consumedExpression(edge);
      String denominator=""String_Node_Str"" + producedExpression + ""String_Node_Str""+ consumedExpression+ ""String_Node_Str"";
      String firstIterations=consumedExpression + ""String_Node_Str"" + denominator;
      String secondIterations=producedExpression + ""String_Node_Str"" + denominator;
      first.setIterationCount(firstIterations);
      second.setIterationCount(secondIterations);
      schedule.add(first);
      schedule.add(second);
      SymbolicSchedule symbolicSchedule=new SymbolicSchedule(schedule,""String_Node_Str"");
      return symbolicSchedule;
    }
  }
 catch (  Exception exception) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + exception.getMessage());
  }
}","private SymbolicScheduleElement _expandAPGAN(PSDFGraph graph,ptolemy.graph.Node node,PSDFAPGANStrategy apgan){
  PSDFGraph childGraph=(PSDFGraph)apgan.getSubgraph(node);
  try {
    if (childGraph == null) {
      PSDFNodeWeight weight=(PSDFNodeWeight)node.getWeight();
      SymbolicFiring firing=new SymbolicFiring((Actor)weight.getComputation(),""String_Node_Str"");
      return firing;
    }
 else {
      Schedule schedule=new Schedule();
      Edge edge=(Edge)childGraph.edges().iterator().next();
      ptolemy.graph.Node source=edge.source();
      ptolemy.graph.Node sink=edge.sink();
      SymbolicScheduleElement first=_expandAPGAN(childGraph,source,apgan);
      SymbolicScheduleElement second=_expandAPGAN(childGraph,sink,apgan);
      String producedExpression=apgan.producedExpression(edge);
      String consumedExpression=apgan.consumedExpression(edge);
      if (producedExpression == null) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ edge);
      }
 else       if (consumedExpression == null) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ edge);
      }
      String denominator=""String_Node_Str"" + producedExpression + ""String_Node_Str""+ consumedExpression+ ""String_Node_Str"";
      String firstIterations=""String_Node_Str"" + consumedExpression + ""String_Node_Str""+ denominator+ ""String_Node_Str"";
      String secondIterations=""String_Node_Str"" + producedExpression + ""String_Node_Str""+ denominator+ ""String_Node_Str"";
      first.setIterationCount(firstIterations);
      second.setIterationCount(secondIterations);
      schedule.add(first);
      schedule.add(second);
      SymbolicSchedule symbolicSchedule=new SymbolicSchedule(schedule,""String_Node_Str"");
      return symbolicSchedule;
    }
  }
 catch (  Exception exception) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + exception.getMessage());
  }
}"
75434,"/** 
 * Return a string representation of this symbolic schedule.
 * @return The string representation.
 */
public String toString(){
  Schedule schedule=(Schedule)_scheduleElement;
  String result=""String_Node_Str"";
  result+=schedule.toString();
  result+=""String_Node_Str"";
  result+=""String_Node_Str"" + _parseTree().toString() + ""String_Node_Str"";
  return result;
}","/** 
 * Return a string representation of this symbolic schedule.
 * @return The string representation.
 */
public String toString(){
  Schedule schedule=(Schedule)_scheduleElement;
  String result=""String_Node_Str"";
  result+=schedule.toString();
  result+=""String_Node_Str"";
  result+=""String_Node_Str"" + expression() + ""String_Node_Str"";
  return result;
}"
75435,"/** 
 * Construct a directed graph with the nodes representing input and output ports, and directed edges representing dependencies.   The directed graph is returned.
 */
protected void _constructDirectedGraph() throws IllegalActionException, NameDuplicationException {
  Actor container=(Actor)getContainer();
  _dg=new DirectedGraph();
  Iterator inputs=container.inputPortList().listIterator();
  while (inputs.hasNext()) {
    _dg.addNodeWeight(inputs.next());
  }
  Iterator outputs=container.outputPortList().listIterator();
  while (outputs.hasNext()) {
    _dg.addNodeWeight(outputs.next());
  }
  Iterator embeddedActors=((CompositeActor)container).deepEntityList().iterator();
  while (embeddedActors.hasNext()) {
    Actor embeddedActor=(Actor)embeddedActors.next();
    Iterator inputsInside=embeddedActor.inputPortList().listIterator();
    while (inputsInside.hasNext()) {
      _dg.addNodeWeight(inputsInside.next());
    }
    Iterator outputsInside=embeddedActor.outputPortList().listIterator();
    while (outputsInside.hasNext()) {
      _dg.addNodeWeight(outputsInside.next());
    }
  }
  embeddedActors=((CompositeActor)container).deepEntityList().iterator();
  while (embeddedActors.hasNext()) {
    Actor embeddedActor=(Actor)embeddedActors.next();
    IODependence ioDependence=(IODependence)((NamedObj)embeddedActor).getAttribute(""String_Node_Str"",IODependence.class);
    if (ioDependence == null) {
      if (embeddedActor instanceof AtomicActor) {
        ioDependence=new IODependenceOfAtomicActor((Entity)embeddedActor,""String_Node_Str"");
      }
 else {
        ioDependence=new IODependenceOfCompositeActor((Entity)embeddedActor,""String_Node_Str"");
      }
    }
    Iterator inputPorts=embeddedActor.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      Set notDirectlyDependentOutputPorts=ioDependence.getNotDirectlyDependentPorts(inputPort);
      Iterator outputPorts=embeddedActor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort outputPort=(IOPort)outputPorts.next();
        if (!notDirectlyDependentOutputPorts.contains(outputPort)) {
          _dg.addEdge(inputPort,outputPort);
        }
      }
    }
    Iterator successors=embeddedActor.outputPortList().iterator();
    while (successors.hasNext()) {
      IOPort outPort=(IOPort)successors.next();
      Iterator inPortIterator=outPort.sinkPortList().iterator();
      while (inPortIterator.hasNext()) {
        _dg.addEdge(outPort,inPortIterator.next());
      }
    }
  }
  inputs=container.inputPortList().listIterator();
  while (inputs.hasNext()) {
    IOPort inputPort=(IOPort)inputs.next();
    Iterator inPortIterator=inputPort.insideSinkPortList().iterator();
    while (inPortIterator.hasNext()) {
      _dg.addEdge(inputPort,inPortIterator.next());
    }
  }
}","/** 
 * Construct a directed graph with the nodes representing input and output ports, and directed edges representing dependencies.   The directed graph is returned.
 */
protected void _constructDirectedGraph() throws IllegalActionException, NameDuplicationException {
  Actor container=(Actor)getContainer();
  _dg=new DirectedGraph();
  Iterator inputs=container.inputPortList().listIterator();
  while (inputs.hasNext()) {
    _dg.addNodeWeight(inputs.next());
  }
  Iterator outputs=container.outputPortList().listIterator();
  while (outputs.hasNext()) {
    _dg.addNodeWeight(outputs.next());
  }
  Iterator embeddedActors=((CompositeActor)container).deepEntityList().iterator();
  while (embeddedActors.hasNext()) {
    Actor embeddedActor=(Actor)embeddedActors.next();
    Iterator inputsInside=embeddedActor.inputPortList().listIterator();
    while (inputsInside.hasNext()) {
      _dg.addNodeWeight(inputsInside.next());
    }
    Iterator outputsInside=embeddedActor.outputPortList().listIterator();
    while (outputsInside.hasNext()) {
      _dg.addNodeWeight(outputsInside.next());
    }
  }
  embeddedActors=((CompositeActor)container).deepEntityList().iterator();
  while (embeddedActors.hasNext()) {
    Actor embeddedActor=(Actor)embeddedActors.next();
    IODependence ioDependence=(IODependence)((NamedObj)embeddedActor).getAttribute(""String_Node_Str"",IODependence.class);
    if (ioDependence == null) {
      if (embeddedActor instanceof AtomicActor) {
        ioDependence=new IODependenceOfAtomicActor((Entity)embeddedActor,""String_Node_Str"");
      }
 else       if (embeddedActor instanceof CompositeActor) {
        ioDependence=new IODependenceOfCompositeActor((Entity)embeddedActor,""String_Node_Str"");
      }
 else {
        return;
      }
    }
    Iterator inputPorts=embeddedActor.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      Set notDirectlyDependentOutputPorts=ioDependence.getNotDirectlyDependentPorts(inputPort);
      Iterator outputPorts=embeddedActor.outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort outputPort=(IOPort)outputPorts.next();
        if (!notDirectlyDependentOutputPorts.contains(outputPort)) {
          _dg.addEdge(inputPort,outputPort);
        }
      }
    }
    Iterator successors=embeddedActor.outputPortList().iterator();
    while (successors.hasNext()) {
      IOPort outPort=(IOPort)successors.next();
      Iterator inPortIterator=outPort.sinkPortList().iterator();
      while (inPortIterator.hasNext()) {
        _dg.addEdge(outPort,inPortIterator.next());
      }
    }
  }
  inputs=container.inputPortList().listIterator();
  while (inputs.hasNext()) {
    IOPort inputPort=(IOPort)inputs.next();
    Iterator inPortIterator=inputPort.insideSinkPortList().iterator();
    while (inPortIterator.hasNext()) {
      _dg.addEdge(inputPort,inPortIterator.next());
    }
  }
}"
75436,"private void _setupActor() throws Exception {
}","private void _setupActor(Actor actor) throws Exception {
}"
75437,"private void _refreshParameters() throws IllegalActionException, NameDuplicationException {
  Set parNames=new HashSet();
  for (int i=0; i < _actor.getParameters().length; i++) {
    String name=_actor.getParameters()[i].getName();
    if (this.getAttribute(name,ptolemy.data.expr.Parameter.class) == null)     new Parameter(this,name);
    parNames.add(name);
  }
  List parameters=this.attributeList(ptolemy.data.expr.Parameter.class);
  for (Iterator i=parameters.iterator(); i.hasNext(); ) {
    Parameter a=(Parameter)i.next();
    if (!parNames.contains(a.getName()))     a.setContainer(null);
  }
}","private void _refreshParameters() throws IllegalActionException, NameDuplicationException {
  Set parNames=new HashSet();
  if (_actor.getParameters() != null) {
    for (int i=0; i < _actor.getParameters().length; i++) {
      String name=_actor.getParameters()[i].getName();
      if (this.getAttribute(name,ptolemy.data.expr.Parameter.class) == null)       new Parameter(this,name);
      parNames.add(name);
    }
  }
  List parameters=this.attributeList(ptolemy.data.expr.Parameter.class);
  for (Iterator i=parameters.iterator(); i.hasNext(); ) {
    Parameter a=(Parameter)i.next();
    if (!parNames.contains(a.getName()))     a.setContainer(null);
  }
}"
75438,"/** 
 * The only attribute whose modifications are handled is the <tt>calCode</tt> attribute, which contains the source code of the CAL actor. <p> Whenever the source is changed, the text is parsed, transformed, and translated into an internal data structure used for interpretation.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If an error occurs parsing ortransforming the CAL source code.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == calCode) {
    String s=calCode.getExpression();
    try {
      _actor=_stringToActor(s);
      if (_actor != null) {
        _setupActor();
      }
    }
 catch (    Throwable ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * The only attribute whose modifications are handled is the <tt>calCode</tt> attribute, which contains the source code of the CAL actor. <p> Whenever the source is changed, the text is parsed, transformed, and translated into an internal data structure used for interpretation.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If an error occurs parsing ortransforming the CAL source code.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == calCode) {
    String s=calCode.getExpression();
    try {
      Actor actor=_stringToActor(s);
      if (actor != null) {
        _setupActor(actor);
      }
    }
 catch (    Throwable ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75439,"/** 
 * Create a new editable combo box entry in the given query associated with the attribute containing this style.  The name of the entry is the name of the attribute.  Attach the attribute to the created entry.
 * @param query The query into which to add the entry.
 * @exception IllegalActionException If the containing attributehas a value that cannot be edited using this style.
 */
public void addEntry(PtolemyQuery query) throws IllegalActionException {
  super.addEntry(query);
}","/** 
 * Create a new editable combo box entry in the given query associated with the attribute containing this style.  The name of the entry is the name of the attribute.  Attach the attribute to the created entry.
 * @param query The query into which to add the entry.
 * @exception IllegalActionException If the containing attributehas a value that cannot be edited using this style.
 */
public void addEntry(PtolemyQuery query) throws IllegalActionException {
  super.addEntry(query);
  _isEditable=true;
}"
75440,"/** 
 * Construct an attribute with the specified container and name.
 * @param container The container.
 * @param name The name of the attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable attribute for the container, or if the container is not an instance of Settable.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public EditableChoiceStyle(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","/** 
 * Construct an attribute with the specified container and name.
 * @param container The container.
 * @param name The name of the attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable attribute for the container, or if the container is not an instance of Settable.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public EditableChoiceStyle(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _isEditable=true;
}"
75441,"/** 
 * An attempt is made to acquire the file name.  If it is  successful, create the RenderedOp to be fired.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the URL is null.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == fileOrURL) {
    URL url=fileOrURL.asURL();
    if (url == null) {
      throw new IllegalActionException(""String_Node_Str"");
    }
 else {
      _fileRoot=url.getFile();
      try {
        _stream=new FileSeekableStream(_fileRoot);
      }
 catch (      IOException error) {
        throw new IllegalActionException(""String_Node_Str"");
      }
      _outputtedImage=JAI.create(""String_Node_Str"",_stream);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * An attempt is made to acquire the file name.  If it null, throw an exception.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the URL is null.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == fileOrURL) {
    URL url=fileOrURL.asURL();
    if (url == null) {
      throw new IllegalActionException(""String_Node_Str"");
    }
 else {
      _fileRoot=url.getFile();
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75442,"/** 
 * Output a JAIImageToken containing the image.
 * @exception IllegalActionException If a contained method throws it,or if the attempt to load the file has failed.
 */
public void fire() throws IllegalActionException {
  super.fire();
  output.send(0,new JAIImageToken(_outputtedImage));
}","/** 
 * Output a JAIImageToken containing the image.
 * @exception IllegalActionException If a contained method throws it,or if the attempt to load the file has failed.
 */
public void fire() throws IllegalActionException {
  super.fire();
  try {
    _stream=new FileSeekableStream(_fileRoot);
  }
 catch (  IOException error) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  _outputtedImage=JAI.create(""String_Node_Str"",_stream);
  PlanarImage dummy=_outputtedImage.getRendering();
  try {
    _stream.close();
  }
 catch (  IOException error) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  output.send(0,new JAIImageToken(_outputtedImage));
}"
75443,"/** 
 * Sets token production for initialize to one and resolves scheduling.
 * @exception IllegalActionException if thrown by base class.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  keyOut.setTokenInitProduction(1);
  parameters.setTokenInitProduction(1);
  getDirector().invalidateResolvedTypes();
}","/** 
 * Sets token production for initialize to one and resolves scheduling.
 * @exception IllegalActionException If thrown by base class.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  keyOut.setTokenInitProduction(1);
  parameters.setTokenInitProduction(1);
  getDirector().invalidateResolvedTypes();
}"
75444,"/** 
 * If there is a token on the <i>input</i> port, this method takes the data from the <i>input</i> and encrypts the data based on the <i>algorithm</i>, <i>provider</i>, <i>mode</i> and <i>padding</i> using the created secret key.  This is then sent on the <i>output</i>.  The public key is also sent out on the <i>keyOut</i> port.  All parameters should be the same as the corresponding decryption actor.  The call for encryption is done in the base class.
 * @exception IllegalActionException if thrown by base class.
 */
public void fire() throws IllegalActionException {
  keyOut.send(0,_unsignedByteArrayToArrayToken(_keyToBytes(_secretKey)));
  if (_algParams != null) {
    try {
      parameters.send(0,_unsignedByteArrayToArrayToken(_algParams.getEncoded()));
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
  }
}","/** 
 * If there is a token on the <i>input</i> port, this method takes the data from the <i>input</i> and encrypts the data based on the <i>algorithm</i>, <i>provider</i>, <i>mode</i> and <i>padding</i> using the created secret key.  This is then sent on the <i>output</i>.  The public key is also sent out on the <i>keyOut</i> port.  All parameters should be the same as the corresponding decryption actor.  The call for encryption is done in the base class.
 * @exception IllegalActionException If thrown by base class.
 */
public void fire() throws IllegalActionException {
}"
75445,"/** 
 * Get an instance of the cipher and outputs the key required for decryption.
 * @exception IllegalActionException If thrown by base class orif the algorithn is not found, or if the padding scheme is illegal, or if the specified provider does not exist.
 */
public void initialize() throws IllegalActionException {
  try {
    super.initialize();
    _secretKey=(SecretKey)_createSymmetricKey();
    _cipher.init(Cipher.ENCRYPT_MODE,_secretKey);
    _algParams=_cipher.getParameters();
    FIRST_RUN=true;
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
}","/** 
 * Get an instance of the cipher and outputs the key required for decryption.
 * @exception IllegalActionException If thrown by base class orif the algorithn is not found, or if the padding scheme is illegal, or if the specified provider does not exist.
 */
public void initialize() throws IllegalActionException {
  try {
    super.initialize();
    _secretKey=(SecretKey)_createSymmetricKey();
    _cipher.init(Cipher.ENCRYPT_MODE,_secretKey);
    _algorithmParameters=_cipher.getParameters();
    FIRST_RUN=true;
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
}"
75446,"/** 
 * Encrypt the data with the specified key.  Receives the data to be encrypted as a byte array and returns a byte array.  Also creates and sends an initialization vector if necessary.
 * @param dataBytes the data to be encrypted.
 * @return byte[] the encrypted data.
 * @exception IllegalActionException if exception below it thrown.
 * @exception IOException if error occurs in ByteArrayOutputStream.
 * @exception InvalideKeyException if key is invalid.
 * @exception BadPaddingException if padding is bad.
 * @exception IllegalBockSizeException if illegal block size.
 */
protected byte[] _process(byte[] dataBytes) throws IllegalActionException {
  _byteArrayOutputStream.reset();
  try {
    _byteArrayOutputStream.write(_cipher.doFinal(dataBytes));
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + dataBytes.length + ""String_Node_Str"");
  }
  return _byteArrayOutputStream.toByteArray();
}","/** 
 * Encrypt the data with the specified key.  Receives the data to be encrypted as a byte array and returns a byte array.  Also creates and sends an initialization vector if necessary.
 * @param dataBytes the data to be encrypted.
 * @return byte[] the encrypted data.
 * @exception IllegalActionException If error occurs inByteArrayOutputStream, if the key is invalid, if the padding is bad or if the block size is illegal.
 */
protected byte[] _process(byte[] dataBytes) throws IllegalActionException {
}"
75447,"/** 
 * Dequeue the events from the event queue that have the smallest time stamp and depth. Advance the model time to their time stamp, and mark the destination actor for firing. If the time stamp is greater than the stop time then return null. If there are no events on the event queue, and _stopWhenQueueIsEmpty flag is true (which is set to true by default) then return null, which will have the effect of stopping the simulation. If _stopWhenQueueIsEmpty is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are events available.  If _synchronizeToRealTime is true, then this method may suspend the calling thread using Object.wait(long) to let elapsed real time catch up with the current event.
 * @return The next actor to fire.
 */
protected Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  if (_eventQueue == null)   return null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else     if (!_isTopLevel() && _eventQueue.isEmpty()) {
      break;
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Thread.yield();
synchronized (_eventQueue) {
          if (_eventQueue.isEmpty()) {
            try {
              _eventQueue.wait();
            }
 catch (            InterruptedException e) {
              break;
            }
catch (            Exception e) {
              if (_debugging) {
                _debug(e.toString());
              }
            }
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      double currentTime;
      if (!_synchronizeToRealTime) {
        currentEvent=(DEEvent)_eventQueue.get();
        currentTime=currentEvent.timeStamp();
      }
 else {
synchronized (_eventQueue) {
          while (true) {
            currentEvent=(DEEvent)_eventQueue.get();
            currentTime=currentEvent.timeStamp();
            long elapsedTime=System.currentTimeMillis() - _realStartTime;
            double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
            if (currentTime <= elapsedTimeInSeconds) {
              break;
            }
            long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
            if (timeToWait > 0) {
              if (_debugging) {
                _debug(""String_Node_Str"" + timeToWait);
              }
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
synchronized (_eventQueue) {
        currentEvent=(DEEvent)_eventQueue.take();
        currentTime=currentEvent.timeStamp();
        actorToFire=currentEvent.actor();
        if (currentTime == Double.NEGATIVE_INFINITY) {
          currentTime=getCurrentTime();
        }
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging)           _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          actorToFire=null;
          continue;
        }
        try {
          setCurrentTime(currentTime);
        }
 catch (        IllegalActionException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getFullName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if ((nextEvent.timeStamp() == Double.NEGATIVE_INFINITY || nextEvent.isSimultaneousWith(currentEvent)) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}","/** 
 * Dequeue the events from the event queue that have the smallest time stamp and depth. Advance the model time to their time stamp, and mark the destination actor for firing. If the time stamp is greater than the stop time then return null. If there are no events on the event queue, and _stopWhenQueueIsEmpty flag is true (which is set to true by default) then return null, which will have the effect of stopping the simulation. If _stopWhenQueueIsEmpty is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are events available.  If _synchronizeToRealTime is true, then this method may suspend the calling thread using Object.wait(long) to let elapsed real time catch up with the current event.
 * @return The next actor to fire.
 */
protected Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  if (_eventQueue == null)   return null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else     if (!_isTopLevel() && _eventQueue.isEmpty()) {
      break;
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Thread.yield();
synchronized (_eventQueue) {
          if (_eventQueue.isEmpty()) {
            try {
              workspace().wait(_eventQueue);
            }
 catch (            InterruptedException e) {
              break;
            }
catch (            Exception e) {
              if (_debugging) {
                _debug(e.toString());
              }
            }
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (!_isTopLevel() && _eventQueue.get().timeStamp() > getCurrentTime()) {
      break;
    }
    if (actorToFire == null) {
      double currentTime;
      if (!_synchronizeToRealTime) {
        currentEvent=(DEEvent)_eventQueue.get();
        currentTime=currentEvent.timeStamp();
      }
 else {
synchronized (_eventQueue) {
          while (true) {
            currentEvent=(DEEvent)_eventQueue.get();
            currentTime=currentEvent.timeStamp();
            long elapsedTime=System.currentTimeMillis() - _realStartTime;
            double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
            if (currentTime <= elapsedTimeInSeconds) {
              break;
            }
            long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
            if (timeToWait > 0) {
              if (_debugging) {
                _debug(""String_Node_Str"" + timeToWait);
              }
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
synchronized (_eventQueue) {
        currentEvent=(DEEvent)_eventQueue.take();
        currentTime=currentEvent.timeStamp();
        actorToFire=currentEvent.actor();
        if (currentTime == Double.NEGATIVE_INFINITY) {
          currentTime=getCurrentTime();
        }
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging)           _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          actorToFire=null;
          continue;
        }
        try {
          setCurrentTime(currentTime);
        }
 catch (        IllegalActionException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getFullName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if ((nextEvent.timeStamp() == Double.NEGATIVE_INFINITY || nextEvent.isSimultaneousWith(currentEvent)) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}"
75448,"/** 
 * Initialize this actor, including the creation of an evaluation variable for the Ptolemy parser, a DatagramSocket for receiving datagrams, and a SocketReadingThread for blocking in the DatagramSocket.receive() method call.  This method is used as a bookend with wrapup() being the other end.  Resources created/allocated here are released in wrapup().
 * @exception IllegalActionException If the<i>localSocketNumber</i> parameter has a value outside 0..65535 or a socket could not be created.  
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _packetsAlreadyAwaitingFire=0;
  _defaultReturnAddress=((StringToken)defaultReturnAddress.getToken()).stringValue();
  if (_defaultReturnAddress.compareTo(""String_Node_Str"") >= 0 && _defaultReturnAddress.compareTo(""String_Node_Str"") <= 0) {
    _multiCast=true;
  }
 else {
    _multiCast=false;
  }
  int portNumber=((IntToken)(localSocketNumber.getToken())).intValue();
  if (portNumber < 0 || portNumber > 65535) {
    throw new IllegalActionException(this,localSocketNumber + ""String_Node_Str"");
  }
  if (_debugging)   _debug(this + ""String_Node_Str"" + portNumber);
  if (_multiCast=true) {
    try {
      if (_debugging) {
        _debug(""String_Node_Str"" + portNumber);
      }
      _multicastSocket=new MulticastSocket(portNumber);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + portNumber);
    }
    String address=((StringToken)defaultReturnAddress.getToken()).stringValue();
    try {
      _address=InetAddress.getByName(address);
    }
 catch (    UnknownHostException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
    }
    try {
      _multicastSocket.joinGroup(_address);
    }
 catch (    IOException exp) {
      throw new IllegalActionException(""String_Node_Str"" + exp);
    }
  }
 else {
    try {
      if (_debugging) {
        _debug(""String_Node_Str"" + portNumber);
      }
      _socket=new DatagramSocket(portNumber);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + portNumber);
    }
  }
  _ChangeRequestedToPlatformBufferLength=1;
  _socketReadingThread=new SocketReadingThread();
  _socketReadingThread.start();
}","/** 
 * Initialize this actor, including the creation of an evaluation variable for the Ptolemy parser, a DatagramSocket for receiving datagrams, and a SocketReadingThread for blocking in the DatagramSocket.receive() method call.  This method is used as a bookend with wrapup() being the other end.  Resources created/allocated here are released in wrapup().
 * @exception IllegalActionException If the<i>localSocketNumber</i> parameter has a value outside 0..65535 or a socket could not be created.  
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _packetsAlreadyAwaitingFire=0;
  _defaultReturnAddress=((StringToken)defaultReturnAddress.getToken()).stringValue();
  if (_defaultReturnAddress.compareTo(""String_Node_Str"") >= 0 && _defaultReturnAddress.compareTo(""String_Node_Str"") <= 0) {
    _multiCast=true;
  }
 else {
    _multiCast=false;
  }
  int portNumber=((IntToken)(localSocketNumber.getToken())).intValue();
  if (portNumber < 0 || portNumber > 65535) {
    throw new IllegalActionException(this,localSocketNumber + ""String_Node_Str"");
  }
  if (_debugging)   _debug(this + ""String_Node_Str"" + portNumber);
  if (_multiCast == true) {
    try {
      if (_debugging) {
        _debug(""String_Node_Str"" + portNumber);
      }
      _multicastSocket=new MulticastSocket(portNumber);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + portNumber);
    }
    String address=((StringToken)defaultReturnAddress.getToken()).stringValue();
    try {
      _address=InetAddress.getByName(address);
    }
 catch (    UnknownHostException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
    }
    try {
      _multicastSocket.joinGroup(_address);
    }
 catch (    IOException exp) {
      throw new IllegalActionException(""String_Node_Str"" + exp);
    }
  }
 else {
    try {
      if (_debugging) {
        _debug(""String_Node_Str"" + portNumber);
      }
      _socket=new DatagramSocket(portNumber);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + portNumber);
    }
  }
  _ChangeRequestedToPlatformBufferLength=1;
  _socketReadingThread=new SocketReadingThread();
  _socketReadingThread.start();
}"
75449,"private DirectedGraph _constructDirectedGraph() throws IllegalActionException, NameDuplicationException {
  Actor container=(Actor)getContainer();
  DirectedGraph dg=new DirectedGraph();
  Iterator inputs=container.inputPortList().listIterator();
  while (inputs.hasNext()) {
    dg.addNodeWeight(inputs.next());
  }
  Iterator outputs=container.outputPortList().listIterator();
  while (outputs.hasNext()) {
    dg.addNodeWeight(outputs.next());
  }
  if (container instanceof CompositeActor) {
    Iterator embeddedActors=((CompositeActor)container).deepEntityList().iterator();
    while (embeddedActors.hasNext()) {
      Actor embeddedActor=(Actor)embeddedActors.next();
      Iterator inputsInside=embeddedActor.inputPortList().listIterator();
      while (inputsInside.hasNext()) {
        dg.addNodeWeight(inputsInside.next());
      }
      Iterator outputsInside=embeddedActor.outputPortList().listIterator();
      while (outputsInside.hasNext()) {
        dg.addNodeWeight(outputsInside.next());
      }
    }
    embeddedActors=((CompositeActor)container).deepEntityList().iterator();
    while (embeddedActors.hasNext()) {
      Actor embeddedActor=(Actor)embeddedActors.next();
      IODependence ioDependence=embeddedActor.getIODependence();
      if (ioDependence == null) {
        ioDependence=new IODependence((Entity)embeddedActor,""String_Node_Str"");
      }
      Iterator inputPorts=embeddedActor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        Set notDirectlyDependentOutputPorts=ioDependence.getNotDirectlyDependentPorts(inputPort);
        Iterator outputPorts=embeddedActor.outputPortList().iterator();
        while (outputPorts.hasNext()) {
          IOPort outputPort=(IOPort)outputPorts.next();
          if (!notDirectlyDependentOutputPorts.contains(outputPort)) {
            dg.addEdge(inputPort,outputPort);
          }
        }
      }
      Iterator successors=embeddedActor.outputPortList().iterator();
      while (successors.hasNext()) {
        IOPort outPort=(IOPort)successors.next();
        Iterator inPortIterator=outPort.sinkPortList().iterator();
        while (inPortIterator.hasNext()) {
          dg.addEdge(outPort,inPortIterator.next());
        }
      }
    }
    inputs=container.inputPortList().listIterator();
    while (inputs.hasNext()) {
      IOPort inputPort=(IOPort)inputs.next();
      Iterator inPortIterator=inputPort.insideSinkPortList().iterator();
      while (inPortIterator.hasNext()) {
        dg.addEdge(inputPort,inPortIterator.next());
      }
    }
    return dg;
  }
  inputs=container.inputPortList().listIterator();
  outputs=container.outputPortList().listIterator();
  IODependence ioDependence=container.getIODependence();
  while (inputs.hasNext()) {
    IOPort inputPort=(IOPort)inputs.next();
    while (outputs.hasNext()) {
      dg.addEdge(inputPort,outputs.next());
    }
  }
  return dg;
}","private DirectedGraph _constructDirectedGraph() throws IllegalActionException, NameDuplicationException {
  Actor container=(Actor)getContainer();
  DirectedGraph dg=new DirectedGraph();
  Iterator inputs=container.inputPortList().listIterator();
  while (inputs.hasNext()) {
    dg.addNodeWeight(inputs.next());
  }
  Iterator outputs=container.outputPortList().listIterator();
  while (outputs.hasNext()) {
    dg.addNodeWeight(outputs.next());
  }
  if (container instanceof CompositeActor) {
    Iterator embeddedActors=((CompositeActor)container).deepEntityList().iterator();
    while (embeddedActors.hasNext()) {
      Actor embeddedActor=(Actor)embeddedActors.next();
      Iterator inputsInside=embeddedActor.inputPortList().listIterator();
      while (inputsInside.hasNext()) {
        dg.addNodeWeight(inputsInside.next());
      }
      Iterator outputsInside=embeddedActor.outputPortList().listIterator();
      while (outputsInside.hasNext()) {
        dg.addNodeWeight(outputsInside.next());
      }
    }
    embeddedActors=((CompositeActor)container).deepEntityList().iterator();
    while (embeddedActors.hasNext()) {
      Actor embeddedActor=(Actor)embeddedActors.next();
      IODependence ioDependence=embeddedActor.getIODependence();
      if (ioDependence == null) {
        ioDependence=new IODependence((Entity)embeddedActor,""String_Node_Str"");
      }
      Iterator inputPorts=embeddedActor.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort inputPort=(IOPort)inputPorts.next();
        Set notDirectlyDependentOutputPorts=ioDependence.getNotDirectlyDependentPorts(inputPort);
        Iterator outputPorts=embeddedActor.outputPortList().iterator();
        while (outputPorts.hasNext()) {
          IOPort outputPort=(IOPort)outputPorts.next();
          if (!notDirectlyDependentOutputPorts.contains(outputPort)) {
            dg.addEdge(inputPort,outputPort);
          }
        }
      }
      Iterator successors=embeddedActor.outputPortList().iterator();
      while (successors.hasNext()) {
        IOPort outPort=(IOPort)successors.next();
        Iterator inPortIterator=outPort.sinkPortList().iterator();
        while (inPortIterator.hasNext()) {
          dg.addEdge(outPort,inPortIterator.next());
        }
      }
    }
    inputs=container.inputPortList().listIterator();
    while (inputs.hasNext()) {
      IOPort inputPort=(IOPort)inputs.next();
      Iterator inPortIterator=inputPort.insideSinkPortList().iterator();
      while (inPortIterator.hasNext()) {
        dg.addEdge(inputPort,inPortIterator.next());
      }
    }
    return dg;
  }
  inputs=container.inputPortList().listIterator();
  while (inputs.hasNext()) {
    IOPort inputPort=(IOPort)inputs.next();
    outputs=container.outputPortList().listIterator();
    while (outputs.hasNext()) {
      dg.addEdge(inputPort,outputs.next());
    }
  }
  return dg;
}"
75450,"/** 
 * Resolve the IODependence describing the relation between the inputs and outputs of an actor. If the cached version is valid, use the cached one. Otherwise, recaculate a new  one. Cache and synchronize the new version with the workspace. 
 * @exception IllegalActionException If the name has a period in it, orthe attribute is not compatible with the specified container.
 * @exception NameDuplicationException If the container already containsan entity with the specified name.
 */
public void inferDependence() throws IllegalActionException, NameDuplicationException {
  if (_dgValid != workspace().getVersion()) {
    _dg=_constructDirectedGraph();
    _dgValid=workspace().getVersion();
  }
}","/** 
 * Resolve the IODependence describing the relation between the inputs and outputs of an actor. If the cached version is valid, use the cached one. Otherwise, recaculate a new  one. Cache and synchronize the new version with the workspace. 
 * @exception IllegalActionException If the name has a period in it, orthe attribute is not compatible with the specified container.
 * @exception NameDuplicationException If the container already containsan entity with the specified name.
 */
public void inferDependence() throws IllegalActionException, NameDuplicationException {
  if (_dgValid != workspace().getVersion()) {
    _dg=_constructDirectedGraph();
    if (_debugging) {
      _debug(getContainer().getName() + ""String_Node_Str"" + ""String_Node_Str"");
      _debug(_dg.toString());
    }
    _dgValid=workspace().getVersion();
  }
}"
75451,"/** 
 * React to notification of a change in controller status. event The event.
 */
public synchronized void controllerUpdate(ControllerEvent event){
  notifyAll();
}","/** 
 * React to notification of a change in controller status.
 * @param event The event.
 */
public synchronized void controllerUpdate(ControllerEvent event){
  notifyAll();
}"
75452,"public boolean postfire() throws IllegalActionException {
  ObjectToken objectToken=(ObjectToken)input.get(0);
  DataSource input=(DataSource)objectToken.getValue();
  if (_player != null) {
    _player.removeControllerListener(this);
  }
  try {
    _player=Manager.createRealizedPlayer(input);
    _player.addControllerListener(this);
    _player.prefetch();
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex.toString());
  }
catch (  MediaException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex.toString());
  }
  _player.setMediaTime(_startTime);
  _frame=new JFrame();
  _container=_frame.getContentPane();
  _container.setLayout(new GridLayout(2,1));
  Component controlPanel=_player.getControlPanelComponent();
  Component videoPanel=_player.getVisualComponent();
  _container.add(videoPanel);
  _container.add(controlPanel);
  _frame.show();
  _player.start();
  return super.postfire();
}","/** 
 * Accept an ObjectToken containing a DataSource, and set it up for playing.
 * @exception IllegalActionException If there is no director,if the file cannot be opened, or if the Java Media Framework throws an exception.
 * @return super.postfire()
 */
public boolean postfire() throws IllegalActionException {
  ObjectToken objectToken=(ObjectToken)input.get(0);
  DataSource input=(DataSource)objectToken.getValue();
  if (_player != null) {
    _player.removeControllerListener(this);
  }
  try {
    _player=Manager.createRealizedPlayer(input);
    _player.addControllerListener(this);
    _player.prefetch();
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex.toString());
  }
catch (  MediaException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex.toString());
  }
  _player.setMediaTime(_startTime);
  _frame=new JFrame();
  _container=_frame.getContentPane();
  _container.setLayout(new BorderLayout());
  Component controlPanel=_player.getControlPanelComponent();
  Component videoPanel=_player.getVisualComponent();
  _container.add(videoPanel,BorderLayout.CENTER);
  _container.add(controlPanel,BorderLayout.SOUTH);
  _container.validate();
  _frame.pack();
  _frame.show();
  _player.start();
  return super.postfire();
}"
75453,"/** 
 * React to notification of a change in controller status. event The event.
 */
public synchronized void controllerUpdate(ControllerEvent event){
  notifyAll();
}","/** 
 * React to notification of a change in controller status.
 * @param event The event.
 */
public synchronized void controllerUpdate(ControllerEvent event){
  notifyAll();
}"
75454,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public VideoPlayer(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setTypeEquals(BaseType.OBJECT);
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public VideoPlayer(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input.setTypeEquals(BaseType.OBJECT);
}"
75455,"/** 
 * Consume at most one array from the input port and produce two arrays containing the indices and values of the identified peaks.   If there is no token on the input, then no output is produced. If the input is an empty array, then the same empty array token is produced on both outputs.
 * @exception IllegalActionException If there is no director, orif sorting is not supported for the input array.
 */
public void fire() throws IllegalActionException {
  startIndex.update();
  endIndex.update();
  if (input.hasToken(0)) {
    ArrayToken inputArray=(ArrayToken)input.get(0);
    int inputSize=inputArray.length();
    if (inputSize == 0) {
      peakValues.send(0,inputArray);
      peakIndices.send(0,inputArray);
      return;
    }
    int start=((IntToken)startIndex.getToken()).intValue();
    int end=((IntToken)endIndex.getToken()).intValue();
    int maxPeaks=((IntToken)maximumNumberOfPeaks.getToken()).intValue();
    if (end >= inputSize) {
      end=inputSize - 1;
    }
    if (start >= inputSize) {
      start=inputSize - 1;
    }
    if (end < 0) {
      end=0;
    }
    if (start < 0) {
      start=0;
    }
    int increment=1;
    if (end < start) {
      increment=-1;
    }
    boolean searchValley=false;
    boolean searchPeak=true;
    int localMaxIndex=start;
    int localMinIndex=start;
    double localMax=((DoubleToken)inputArray.getElement(start)).doubleValue();
    double localMin=localMax;
    double dipValue=((DoubleToken)dip.getToken()).doubleValue();
    double squelchValue=((DoubleToken)squelch.getToken()).doubleValue();
    double dipThreshold=dipValue;
    double riseThreshold=dipValue;
    String scaleValue=((StringToken)scale.getToken()).stringValue();
    int scaleIndicator=_ABSOLUTE;
    if (!scaleValue.equals(""String_Node_Str"")) {
      double maxValue=localMax;
      for (int i=0; i <= inputSize - 1; i=i + increment) {
        double indata=((DoubleToken)inputArray.getElement(i)).doubleValue();
        if (indata > maxValue) {
          maxValue=indata;
        }
      }
      if (scaleValue.equals(""String_Node_Str"")) {
        scaleIndicator=_RELATIVE_DB;
        dipThreshold=localMax * Math.pow(10.0,(-dipValue / 20));
        riseThreshold=localMin * Math.pow(10.0,(dipValue / 20));
        squelchValue=maxValue * Math.pow(10.0,(-squelchValue / 20));
      }
 else       if (scaleValue.equals(""String_Node_Str"")) {
        scaleIndicator=_RELATIVE_DB_POWER;
        dipThreshold=localMax * Math.pow(10.0,(-dipValue / 10));
        riseThreshold=localMin * Math.pow(10.0,(dipValue / 10));
        squelchValue=maxValue * Math.pow(10.0,(-squelchValue / 10));
      }
 else       if (scaleValue.equals(""String_Node_Str"")) {
        scaleIndicator=_RELATIVE_LINEAR;
        dipThreshold=localMax - dipValue;
        riseThreshold=localMin + dipValue;
        squelchValue=maxValue - squelchValue;
      }
    }
    ArrayList resultIndices=new ArrayList();
    ArrayList resultPeaks=new ArrayList();
    for (int i=start; i <= end; i=i + increment) {
      double indata=((DoubleToken)inputArray.getElement(i)).doubleValue();
      if (_debugging) {
        _debug(""String_Node_Str"" + indata + ""String_Node_Str""+ i);
      }
      if (searchValley) {
        if (indata < localMin) {
          localMin=indata;
switch (scaleIndicator) {
case _RELATIVE_DB:
            riseThreshold=localMin * Math.pow(10.0,(dipValue / 20));
          break;
case _RELATIVE_DB_POWER:
        riseThreshold=localMin * Math.pow(10.0,(dipValue / 10));
      break;
case _RELATIVE_LINEAR:
    riseThreshold=localMax + dipValue;
  break;
}
localMinIndex=i;
}
if (_debugging) {
_debug(""String_Node_Str"" + riseThreshold);
}
if (indata > riseThreshold && indata > squelchValue) {
localMax=indata;
switch (scaleIndicator) {
case _RELATIVE_DB:
dipThreshold=localMax * Math.pow(10.0,(-dipValue / 20));
break;
case _RELATIVE_DB_POWER:
dipThreshold=localMax * Math.pow(10.0,(-dipValue / 10));
break;
case _RELATIVE_LINEAR:
dipThreshold=localMax - dipValue;
break;
}
localMaxIndex=i;
searchValley=false;
searchPeak=true;
}
}
 else if (searchPeak) {
if (indata > localMax && indata > squelchValue) {
localMax=indata;
switch (scaleIndicator) {
case _RELATIVE_DB:
dipThreshold=localMax * Math.pow(10.0,(-dipValue / 20));
break;
case _RELATIVE_DB_POWER:
dipThreshold=localMax * Math.pow(10.0,(-dipValue / 10));
break;
case _RELATIVE_LINEAR:
dipThreshold=localMax - dipValue;
break;
}
localMaxIndex=i;
}
if (_debugging) {
_debug(""String_Node_Str"" + dipThreshold);
}
if (indata < dipThreshold) {
if (_debugging) {
_debug(""String_Node_Str"" + localMax + ""String_Node_Str""+ localMaxIndex);
}
resultIndices.add(new IntToken(localMaxIndex));
resultPeaks.add(new DoubleToken(localMax));
if (resultPeaks.size() > maxPeaks) {
break;
}
localMin=indata;
switch (scaleIndicator) {
case _RELATIVE_DB:
riseThreshold=localMin * Math.pow(10.0,(dipValue / 20));
break;
case _RELATIVE_DB_POWER:
riseThreshold=localMin * Math.pow(10.0,(dipValue / 10));
break;
case _RELATIVE_LINEAR:
riseThreshold=localMin + dipValue;
break;
}
localMinIndex=i;
searchValley=true;
searchPeak=false;
}
}
}
if (resultPeaks.isEmpty()) {
resultPeaks.add(inputArray.getElement(start));
resultIndices.add(startIndex.getToken());
}
Token[] resultPeaksArray=(Token[])resultPeaks.toArray(new Token[resultPeaks.size()]);
Token[] resultIndicesArray=(Token[])resultIndices.toArray(new Token[resultIndices.size()]);
peakValues.send(0,new ArrayToken(resultPeaksArray));
peakIndices.send(0,new ArrayToken(resultIndicesArray));
}
}","/** 
 * Consume at most one array from the input port and produce two arrays containing the indices and values of the identified peaks.   If there is no token on the input, then no output is produced. If the input is an empty array, then the same empty array token is produced on both outputs.
 * @exception IllegalActionException If there is no director, orif sorting is not supported for the input array.
 */
public void fire() throws IllegalActionException {
  startIndex.update();
  endIndex.update();
  if (input.hasToken(0)) {
    ArrayToken inputArray=(ArrayToken)input.get(0);
    int inputSize=inputArray.length();
    if (inputSize == 0) {
      peakValues.send(0,inputArray);
      peakIndices.send(0,inputArray);
      return;
    }
    int start=((IntToken)startIndex.getToken()).intValue();
    int end=((IntToken)endIndex.getToken()).intValue();
    int maxPeaks=((IntToken)maximumNumberOfPeaks.getToken()).intValue();
    if (end >= inputSize) {
      end=inputSize - 1;
    }
    if (start >= inputSize) {
      start=inputSize - 1;
    }
    if (end < 0) {
      end=0;
    }
    if (start < 0) {
      start=0;
    }
    int increment=1;
    if (end < start) {
      increment=-1;
    }
    boolean searchValley=false;
    boolean searchPeak=true;
    int localMaxIndex=start;
    int localMinIndex=start;
    double localMax=((DoubleToken)inputArray.getElement(start)).doubleValue();
    double localMin=localMax;
    double dipValue=((DoubleToken)dip.getToken()).doubleValue();
    double squelchValue=((DoubleToken)squelch.getToken()).doubleValue();
    double dipThreshold=dipValue;
    double riseThreshold=dipValue;
    String scaleValue=((StringToken)scale.getToken()).stringValue();
    int scaleIndicator=_ABSOLUTE;
    if (!scaleValue.equals(""String_Node_Str"")) {
      double maxValue=localMax;
      for (int i=0; i <= inputSize - 1; i=i + increment) {
        double indata=((DoubleToken)inputArray.getElement(i)).doubleValue();
        if (indata > maxValue) {
          maxValue=indata;
        }
      }
      if (scaleValue.equals(""String_Node_Str"")) {
        scaleIndicator=_RELATIVE_DB;
        dipThreshold=localMax * Math.pow(10.0,(-dipValue / 20));
        riseThreshold=localMin * Math.pow(10.0,(dipValue / 20));
        squelchValue=maxValue * Math.pow(10.0,(-squelchValue / 20));
      }
 else       if (scaleValue.equals(""String_Node_Str"")) {
        scaleIndicator=_RELATIVE_DB_POWER;
        dipThreshold=localMax * Math.pow(10.0,(-dipValue / 10));
        riseThreshold=localMin * Math.pow(10.0,(dipValue / 10));
        squelchValue=maxValue * Math.pow(10.0,(-squelchValue / 10));
      }
 else       if (scaleValue.equals(""String_Node_Str"")) {
        scaleIndicator=_RELATIVE_LINEAR;
        dipThreshold=localMax - dipValue;
        riseThreshold=localMin + dipValue;
        squelchValue=maxValue - squelchValue;
      }
    }
    ArrayList resultIndices=new ArrayList();
    ArrayList resultPeaks=new ArrayList();
    for (int i=start; i <= end; i=i + increment) {
      double indata=((DoubleToken)inputArray.getElement(i)).doubleValue();
      if (_debugging) {
        _debug(""String_Node_Str"" + indata + ""String_Node_Str""+ i);
      }
      if (searchValley) {
        if (indata < localMin) {
          localMin=indata;
switch (scaleIndicator) {
case _RELATIVE_DB:
            riseThreshold=localMin * Math.pow(10.0,(dipValue / 20));
          break;
case _RELATIVE_DB_POWER:
        riseThreshold=localMin * Math.pow(10.0,(dipValue / 10));
      break;
case _RELATIVE_LINEAR:
    riseThreshold=localMin + dipValue;
  break;
}
localMinIndex=i;
}
if (_debugging) {
_debug(""String_Node_Str"" + riseThreshold);
}
if (indata > riseThreshold && indata > squelchValue) {
localMax=indata;
switch (scaleIndicator) {
case _RELATIVE_DB:
dipThreshold=localMax * Math.pow(10.0,(-dipValue / 20));
break;
case _RELATIVE_DB_POWER:
dipThreshold=localMax * Math.pow(10.0,(-dipValue / 10));
break;
case _RELATIVE_LINEAR:
dipThreshold=localMax - dipValue;
break;
}
localMaxIndex=i;
searchValley=false;
searchPeak=true;
}
}
 else if (searchPeak) {
if (indata > localMax && indata > squelchValue) {
localMax=indata;
switch (scaleIndicator) {
case _RELATIVE_DB:
dipThreshold=localMax * Math.pow(10.0,(-dipValue / 20));
break;
case _RELATIVE_DB_POWER:
dipThreshold=localMax * Math.pow(10.0,(-dipValue / 10));
break;
case _RELATIVE_LINEAR:
dipThreshold=localMax - dipValue;
break;
}
localMaxIndex=i;
}
if (_debugging) {
_debug(""String_Node_Str"" + dipThreshold);
}
if (indata < dipThreshold && localMax > squelchValue) {
if (_debugging) {
_debug(""String_Node_Str"" + localMax + ""String_Node_Str""+ localMaxIndex);
}
resultIndices.add(new IntToken(localMaxIndex));
resultPeaks.add(new DoubleToken(localMax));
if (resultPeaks.size() > maxPeaks) {
break;
}
localMin=indata;
switch (scaleIndicator) {
case _RELATIVE_DB:
riseThreshold=localMin * Math.pow(10.0,(dipValue / 20));
break;
case _RELATIVE_DB_POWER:
riseThreshold=localMin * Math.pow(10.0,(dipValue / 10));
break;
case _RELATIVE_LINEAR:
riseThreshold=localMin + dipValue;
break;
}
localMinIndex=i;
searchValley=true;
searchPeak=false;
}
}
}
if (resultPeaks.isEmpty()) {
resultPeaks.add(inputArray.getElement(start));
resultIndices.add(startIndex.getToken());
}
Token[] resultPeaksArray=(Token[])resultPeaks.toArray(new Token[resultPeaks.size()]);
Token[] resultIndicesArray=(Token[])resultIndices.toArray(new Token[resultIndices.size()]);
peakValues.send(0,new ArrayToken(resultPeaksArray));
peakIndices.send(0,new ArrayToken(resultIndicesArray));
}
}"
75456,"/** 
 * Return the list of identifiers within the scope.
 * @return The list of variable names within the scope.
 */
public Set identifierSet(){
  return getAllScopedVariableNames(Variable.this,_reference);
}","/** 
 * Return the list of identifiers within the scope.
 * @return The list of variable names within the scope.
 */
public Set identifierSet(){
  NamedObj reference=_reference;
  if (_reference == null) {
    reference=(NamedObj)Variable.this.getContainer();
  }
  return getAllScopedVariableNames(Variable.this,reference);
}"
75457,"/** 
 * Look up and return the type of the attribute with the specified name in the scope. Return null if such an attribute does not exist.
 * @return The attribute with the specified name in the scope.
 * @exception IllegalActionException If a value in the scopeexists with the given name, but cannot be evaluated.
 */
public ptolemy.data.type.Type getType(String name) throws IllegalActionException {
  Variable result=getScopedVariable(Variable.this,_reference,name);
  if (result != null) {
    return result.getType();
  }
 else {
    return null;
  }
}","/** 
 * Look up and return the type of the attribute with the specified name in the scope. Return null if such an attribute does not exist.
 * @return The attribute with the specified name in the scope.
 * @exception IllegalActionException If a value in the scopeexists with the given name, but cannot be evaluated.
 */
public ptolemy.data.type.Type getType(String name) throws IllegalActionException {
  NamedObj reference=_reference;
  if (_reference == null) {
    reference=(NamedObj)Variable.this.getContainer();
  }
  Variable result=getScopedVariable(Variable.this,reference,name);
  if (result != null) {
    return result.getType();
  }
 else {
    return null;
  }
}"
75458,"/** 
 * Construct a scope consisting of the variables of the specified container its containers and their scope-extending attributes. If the argument is null, then use the container of the enclosing instance of Variable as the reference for the scope.
 */
public VariableScope(NamedObj reference){
  _reference=reference;
  if (_reference == null) {
    _reference=(NamedObj)Variable.this.getContainer();
  }
}","/** 
 * Construct a scope consisting of the variables of the specified container its containers and their scope-extending attributes. If the argument is null, then use the container of the enclosing instance of Variable as the reference for the scope.
 */
public VariableScope(NamedObj reference){
  _reference=reference;
}"
75459,"/** 
 * Look up and return the attribute with the specified name in the scope. Return null if such an attribute does not exist.
 * @return The attribute with the specified name in the scope.
 * @exception IllegalActionException If a value in the scopeexists with the given name, but cannot be evaluated.
 */
public ptolemy.data.Token get(String name) throws IllegalActionException {
  if (_variablesDependentOn == null) {
    _variablesDependentOn=new HashMap();
  }
 else {
    if (_variablesDependentOnVersion == workspace().getVersion()) {
      Variable result=(Variable)_variablesDependentOn.get(name);
      if (result != null) {
        return result.getToken();
      }
    }
 else {
      _variablesDependentOn.clear();
    }
  }
  _variablesDependentOnVersion=workspace().getVersion();
  Variable result=getScopedVariable(Variable.this,_reference,name);
  if (result != null) {
    if (!_variablesDependentOn.containsValue(result)) {
      result.addValueListener(Variable.this);
      _variablesDependentOn.put(name,result);
    }
    return result.getToken();
  }
 else {
    return null;
  }
}","/** 
 * Look up and return the attribute with the specified name in the scope. Return null if such an attribute does not exist.
 * @return The attribute with the specified name in the scope.
 * @exception IllegalActionException If a value in the scopeexists with the given name, but cannot be evaluated.
 */
public ptolemy.data.Token get(String name) throws IllegalActionException {
  if (_variablesDependentOn == null) {
    _variablesDependentOn=new HashMap();
  }
 else {
    if (_variablesDependentOnVersion == workspace().getVersion()) {
      Variable result=(Variable)_variablesDependentOn.get(name);
      if (result != null) {
        return result.getToken();
      }
    }
 else {
      _variablesDependentOn.clear();
    }
  }
  _variablesDependentOnVersion=workspace().getVersion();
  NamedObj reference=_reference;
  if (_reference == null) {
    reference=(NamedObj)Variable.this.getContainer();
  }
  Variable result=getScopedVariable(Variable.this,reference,name);
  if (result != null) {
    if (!_variablesDependentOn.containsValue(result)) {
      result.addValueListener(Variable.this);
      _variablesDependentOn.put(name,result);
    }
    return result.getToken();
  }
 else {
    return null;
  }
}"
75460,"/** 
 * Evaluate the current expression to a token. If this variable was last set directly with a token, then do nothing. In other words, the expression is evaluated only if the value of the token was most recently given by an expression.  The expression is also evaluated if any of the variables it refers to have changed since the last evaluation.  If the value of this variable changes due to this evaluation, then notify all value dependents and notify the container (if there is one) by calling its attributeChanged() and attributeTypeChanged() methods, as appropriate. An exception is thrown if the expression is illegal, for example if a parse error occurs or if there is a dependency loop. <p> If evaluation results in a token that is not of the same type as the current type of the variable, then the type of the variable is changed, unless the new type is incompatible with statically specified types (setTypeEquals() and setTypeAtMost()). If the type is changed, the attributeTypeChanged() method of the container is called.  The container can reject the change by throwing an exception. <p> This method may trigger a model error, which is delegated up the container hierarchy until an error handler is found, and is ignored if no error handler is found.  A model error occurs if the expression cannot be parsed or cannot be evaluated. <p> Part of this method is read-synchronized on the workspace.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if a dependency loop is found.
 */
protected void _evaluate() throws IllegalActionException {
  if (_currentExpression == null || _currentExpression.trim().equals(""String_Node_Str"")) {
    _setToken(null);
    return;
  }
  if (_dependencyLoop) {
    _dependencyLoop=false;
    throw new IllegalActionException(""String_Node_Str"");
  }
  _dependencyLoop=true;
  try {
    workspace().getReadAccess();
    if (!_parseTreeValid) {
      PtParser parser=new PtParser();
      _parseTree=parser.generateParseTree(_currentExpression);
      _parseTreeValid=true;
    }
    if (_parseTreeEvaluator == null) {
      _parseTreeEvaluator=new ParseTreeEvaluator();
    }
    if (_parserScope == null) {
      _parserScope=new VariableScope();
    }
    Token result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_parserScope);
    _setTokenAndNotify(result);
  }
 catch (  IllegalActionException ex) {
    _needsEvaluation=true;
    throw new IllegalActionException(this,ex,""String_Node_Str"" + _currentExpression);
  }
 finally {
    _dependencyLoop=false;
    workspace().doneReading();
  }
}","/** 
 * Evaluate the current expression to a token. If this variable was last set directly with a token, then do nothing. In other words, the expression is evaluated only if the value of the token was most recently given by an expression.  The expression is also evaluated if any of the variables it refers to have changed since the last evaluation.  If the value of this variable changes due to this evaluation, then notify all value dependents and notify the container (if there is one) by calling its attributeChanged() and attributeTypeChanged() methods, as appropriate. An exception is thrown if the expression is illegal, for example if a parse error occurs or if there is a dependency loop. <p> If evaluation results in a token that is not of the same type as the current type of the variable, then the type of the variable is changed, unless the new type is incompatible with statically specified types (setTypeEquals() and setTypeAtMost()). If the type is changed, the attributeTypeChanged() method of the container is called.  The container can reject the change by throwing an exception. <p> This method may trigger a model error, which is delegated up the container hierarchy until an error handler is found, and is ignored if no error handler is found.  A model error occurs if the expression cannot be parsed or cannot be evaluated. <p> Part of this method is read-synchronized on the workspace.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if a dependency loop is found.
 */
protected void _evaluate() throws IllegalActionException {
  if (_currentExpression == null || _currentExpression.trim().equals(""String_Node_Str"")) {
    _setToken(null);
    return;
  }
  if (_dependencyLoop) {
    _dependencyLoop=false;
    throw new IllegalActionException(""String_Node_Str"");
  }
  _dependencyLoop=true;
  try {
    workspace().getReadAccess();
    if (!_parseTreeValid) {
      PtParser parser=new PtParser();
      _parseTree=parser.generateParseTree(_currentExpression);
      _parseTreeValid=(_parseTree != null);
    }
    if (_parseTreeEvaluator == null) {
      _parseTreeEvaluator=new ParseTreeEvaluator();
    }
    if (_parserScope == null) {
      _parserScope=new VariableScope();
    }
    Token result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_parserScope);
    _setTokenAndNotify(result);
  }
 catch (  IllegalActionException ex) {
    _needsEvaluation=true;
    throw new IllegalActionException(this,ex,""String_Node_Str"" + _currentExpression);
  }
 finally {
    _dependencyLoop=false;
    workspace().doneReading();
  }
}"
75461,"/** 
 * Return the CTSchedule. Caching of the schedule is done in the director class, so this method does not test for the validation of the schedule.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  CTSchedule ctSchedule=new CTSchedule();
  _signalTypeMap=new SignalTypeMap();
  LinkedList sinkActors=new LinkedList();
  LinkedList dynamicActors=new LinkedList();
  LinkedList discreteActors=new LinkedList();
  LinkedList arithmeticActors=new LinkedList();
  LinkedList eventGenerators=new LinkedList();
  LinkedList waveformGenerators=new LinkedList();
  LinkedList continuousActors=new LinkedList();
  Schedule discreteActorSchedule=new Schedule();
  Schedule continuousActorSchedule=new Schedule();
  Schedule dynamicActorSchedule=new Schedule();
  Schedule eventGeneratorSchedule=new Schedule();
  Schedule outputSchedule=new Schedule();
  Schedule outputSSCActors=new Schedule();
  Schedule stateTransitionSchedule=new Schedule();
  Schedule statefulActors=new Schedule();
  Schedule stateSSCActors=new Schedule();
  Schedule waveformGeneratorSchedule=new Schedule();
  CompositeActor container=(CompositeActor)getContainer().getContainer();
  boolean isCTComposite=false;
  if (container instanceof CTStepSizeControlActor) {
    isCTComposite=true;
  }
  Iterator containerInPorts=container.inputPortList().iterator();
  while (containerInPorts.hasNext()) {
    IOPort inPort=(IOPort)containerInPorts.next();
    if (!isCTComposite) {
      _signalTypeMap.setType(inPort,DISCRETE);
    }
 else {
      Parameter signalType=(Parameter)inPort.getAttribute(""String_Node_Str"");
      if (signalType != null) {
        String type=((StringToken)signalType.getToken()).stringValue();
        type=type.trim().toUpperCase();
        if (type.equals(""String_Node_Str"")) {
          _signalTypeMap.setType(inPort,CONTINUOUS);
        }
 else         if (type.equals(""String_Node_Str"")) {
          _signalTypeMap.setType(inPort,DISCRETE);
        }
 else {
          throw new IllegalActionException(inPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        _signalTypeMap.setType(inPort,CONTINUOUS);
      }
    }
    _signalTypeMap.propagateTypeInside(inPort);
  }
  continuousActors=(LinkedList)((LinkedList)container.deepEntityList()).clone();
  Iterator allActors=container.deepEntityList().iterator();
  while (allActors.hasNext()) {
    Actor a=(Actor)allActors.next();
    if (a instanceof CTStatefulActor) {
      statefulActors.add(new Firing(a));
    }
    if (a instanceof CTWaveformGenerator) {
      waveformGenerators.add(a);
    }
    if (a instanceof CTEventGenerator) {
      eventGenerators.add(a);
    }
    if (a instanceof CTDynamicActor) {
      dynamicActors.addLast(a);
    }
 else     if (!(a instanceof CTWaveformGenerator)) {
      arithmeticActors.add(a);
    }
    if (a instanceof SequenceActor) {
      if (predecessorList(a).isEmpty()) {
        throw new NotSchedulableException(((Nameable)a).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _signalTypeMap.setType(port,DISCRETE);
        if (port.isOutput()) {
          _signalTypeMap.propagateType(port);
        }
      }
    }
 else     if ((a instanceof TypedCompositeActor) && !(a instanceof CTStepSizeControlActor)) {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _signalTypeMap.setType(port,DISCRETE);
        if (port.isOutput()) {
          _signalTypeMap.propagateType(port);
        }
      }
    }
 else {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        Parameter signalType=(Parameter)port.getAttribute(""String_Node_Str"");
        if (signalType != null) {
          String type=((StringToken)signalType.getToken()).stringValue();
          type=type.trim().toUpperCase();
          if (type.equals(""String_Node_Str"")) {
            _signalTypeMap.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
 else           if (type.equals(""String_Node_Str"")) {
            _signalTypeMap.setType(port,DISCRETE);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
 else {
            throw new InvalidStateException(port,""String_Node_Str"");
          }
        }
 else         if (a instanceof CTCompositeActor) {
          _signalTypeMap.setType(port,CONTINUOUS);
          if (port.isOutput()) {
            _signalTypeMap.propagateType(port);
          }
        }
      }
      if (predecessorList(a).isEmpty()) {
        ports=((Entity)a).portList().iterator();
        while (ports.hasNext()) {
          IOPort port=(IOPort)ports.next();
          if (_signalTypeMap.getType(port) == UNKNOWN) {
            _signalTypeMap.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
        }
      }
    }
  }
  DirectedAcyclicGraph arithmeticGraph=_toGraph(arithmeticActors);
  if (!arithmeticGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  DirectedAcyclicGraph dynamicGraph=_toGraph(dynamicActors);
  if (!dynamicGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  Object[] sortedArithmeticActors=arithmeticGraph.topologicalSort();
  for (int i=0; i < sortedArithmeticActors.length; i++) {
    Actor actor=(Actor)sortedArithmeticActors[i];
    Iterator inputPorts=actor.inputPortList().iterator();
    CTReceiver.SignalType knownType=UNKNOWN;
    boolean needManuallySetType=true;
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      if (port.getWidth() != 0) {
        CTReceiver.SignalType type=_signalTypeMap.getType(port);
        if (type == UNKNOWN) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else         if (knownType == UNKNOWN) {
          knownType=type;
          needManuallySetType=false;
        }
 else         if (knownType != type) {
          needManuallySetType=true;
          break;
        }
      }
    }
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      CTReceiver.SignalType type=_signalTypeMap.getType(port);
      if (type == UNKNOWN) {
        if (needManuallySetType) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          _signalTypeMap.setType(port,knownType);
        }
      }
      _signalTypeMap.propagateType(port);
    }
  }
  _setPortSignalTypes(_signalTypeMap);
  if (_debugging)   _debug(""String_Node_Str"" + _signalTypeMap.toString() + ""String_Node_Str"");
  discreteActors=_signalTypeMap.getDiscreteActors();
  continuousActors=_signalTypeMap.getContinuousActors();
  DirectedAcyclicGraph discreteGraph=_toGraph(discreteActors);
  Object[] discreteSorted=discreteGraph.topologicalSort();
  for (int i=0; i < discreteSorted.length; i++) {
    Actor actor=(Actor)discreteSorted[i];
    discreteActorSchedule.add(new Firing(actor));
    if ((actor instanceof CompositeActor) && (actor instanceof CTStepSizeControlActor)) {
      if (!continuousActors.contains(actor)) {
        continuousActors.add(actor);
      }
    }
  }
  Iterator continuousIterator=continuousActors.iterator();
  while (continuousIterator.hasNext()) {
    Actor actor=(Actor)continuousIterator.next();
    if ((actor instanceof SequenceActor) || ((actor instanceof CompositeActor) && (!(actor instanceof CTStepSizeControlActor)))) {
      throw new NotSchedulableException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"");
    }
    continuousActorSchedule.add(new Firing(actor));
    if (actor instanceof CTEventGenerator) {
      sinkActors.add(actor);
    }
 else     if (!(actor instanceof CTDynamicActor)) {
      List successorList=successorList(actor);
      if (successorList.isEmpty()) {
        sinkActors.add(actor);
      }
 else {
        Iterator successors=successorList.iterator();
        boolean isSink=true;
        while (successors.hasNext()) {
          Actor successor=(Actor)successors.next();
          if (continuousActors.contains(successor)) {
            isSink=false;
            break;
          }
        }
        if (isSink) {
          sinkActors.add(actor);
        }
      }
    }
  }
  Iterator generators=waveformGenerators.iterator();
  while (generators.hasNext()) {
    Actor generator=(Actor)generators.next();
    waveformGeneratorSchedule.add(new Firing(generator));
  }
  if (!eventGenerators.isEmpty()) {
    DirectedAcyclicGraph eventGraph=_toGraph(eventGenerators);
    Object[] eventSorted=eventGraph.topologicalSort();
    for (int i=0; i < eventSorted.length; i++) {
      eventGeneratorSchedule.add(new Firing((Actor)eventSorted[i]));
    }
  }
  arithmeticGraph=_toArithmeticGraph(continuousActors);
  if (!dynamicActors.isEmpty()) {
    Object[] dynamicArray=dynamicActors.toArray();
    Object[] xSorted=dynamicGraph.topologicalSort(dynamicArray);
    for (int i=0; i < xSorted.length; i++) {
      Actor a=(Actor)xSorted[i];
      dynamicActorSchedule.add(0,new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
    Object[] fx=arithmeticGraph.backwardReachableNodes(dynamicArray);
    Object[] fxSorted=arithmeticGraph.topologicalSort(fx);
    for (int i=0; i < fxSorted.length; i++) {
      Actor a=(Actor)fxSorted[i];
      stateTransitionSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
  }
  if (!sinkActors.isEmpty()) {
    Object[] sinkArray=sinkActors.toArray();
    Object[] gx=arithmeticGraph.backwardReachableNodes(sinkArray);
    Object[] gxSorted=arithmeticGraph.topologicalSort(gx);
    for (int i=0; i < gxSorted.length; i++) {
      Actor a=(Actor)gxSorted[i];
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
    Iterator sinks=sinkActors.iterator();
    while (sinks.hasNext()) {
      Actor a=(Actor)sinks.next();
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
  }
  ctSchedule.add(discreteActorSchedule);
  ctSchedule.add(continuousActorSchedule);
  ctSchedule.add(dynamicActorSchedule);
  ctSchedule.add(eventGeneratorSchedule);
  ctSchedule.add(outputSchedule);
  ctSchedule.add(outputSSCActors);
  ctSchedule.add(stateTransitionSchedule);
  ctSchedule.add(statefulActors);
  ctSchedule.add(stateSSCActors);
  ctSchedule.add(waveformGeneratorSchedule);
  setValid(true);
  return ctSchedule;
}","/** 
 * Return the CTSchedule. Caching of the schedule is done in the director class, so this method does not test for the validation of the schedule.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  CTSchedule ctSchedule=new CTSchedule();
  _signalTypeMap=new SignalTypeMap();
  LinkedList sinkActors=new LinkedList();
  LinkedList dynamicActors=new LinkedList();
  LinkedList discreteActors=new LinkedList();
  LinkedList arithmeticActors=new LinkedList();
  LinkedList eventGenerators=new LinkedList();
  LinkedList waveformGenerators=new LinkedList();
  LinkedList continuousActors=new LinkedList();
  Schedule discreteActorSchedule=new Schedule();
  Schedule continuousActorSchedule=new Schedule();
  Schedule dynamicActorSchedule=new Schedule();
  Schedule eventGeneratorSchedule=new Schedule();
  Schedule outputSchedule=new Schedule();
  Schedule outputSSCActors=new Schedule();
  Schedule stateTransitionSchedule=new Schedule();
  Schedule statefulActors=new Schedule();
  Schedule stateSSCActors=new Schedule();
  Schedule waveformGeneratorSchedule=new Schedule();
  CompositeActor container=(CompositeActor)getContainer().getContainer();
  boolean isCTComposite=false;
  if (container instanceof CTStepSizeControlActor) {
    isCTComposite=true;
  }
  Iterator containerInPorts=container.inputPortList().iterator();
  while (containerInPorts.hasNext()) {
    IOPort inPort=(IOPort)containerInPorts.next();
    if (!isCTComposite) {
      _signalTypeMap.setType(inPort,DISCRETE);
    }
 else {
      Parameter signalType=(Parameter)inPort.getAttribute(""String_Node_Str"");
      if (signalType != null) {
        String type=((StringToken)signalType.getToken()).stringValue();
        type=type.trim().toUpperCase();
        if (type.equals(""String_Node_Str"")) {
          _signalTypeMap.setType(inPort,CONTINUOUS);
        }
 else         if (type.equals(""String_Node_Str"")) {
          _signalTypeMap.setType(inPort,DISCRETE);
        }
 else {
          throw new IllegalActionException(inPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        _signalTypeMap.setType(inPort,CONTINUOUS);
      }
    }
    _signalTypeMap.propagateTypeInside(inPort);
  }
  continuousActors=(LinkedList)((LinkedList)container.deepEntityList()).clone();
  Iterator allActors=container.deepEntityList().iterator();
  while (allActors.hasNext()) {
    Actor a=(Actor)allActors.next();
    if (a instanceof CTStatefulActor) {
      statefulActors.add(new Firing(a));
    }
    if (a instanceof CTWaveformGenerator) {
      waveformGenerators.add(a);
    }
    if (a instanceof CTEventGenerator) {
      eventGenerators.add(a);
    }
    if (a instanceof CTDynamicActor) {
      dynamicActors.addLast(a);
    }
 else     if (!(a instanceof CTWaveformGenerator)) {
      arithmeticActors.add(a);
    }
    if (a instanceof SequenceActor) {
      if (predecessorList(a).isEmpty()) {
        throw new NotSchedulableException(((Nameable)a).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _signalTypeMap.setType(port,DISCRETE);
        if (port.isOutput()) {
          _signalTypeMap.propagateType(port);
        }
      }
    }
 else     if ((a instanceof TypedCompositeActor) && !(a instanceof CTStepSizeControlActor)) {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _signalTypeMap.setType(port,DISCRETE);
        if (port.isOutput()) {
          _signalTypeMap.propagateType(port);
        }
      }
    }
 else {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        Parameter signalType=(Parameter)port.getAttribute(""String_Node_Str"");
        if (signalType != null) {
          String type=((StringToken)signalType.getToken()).stringValue();
          type=type.trim().toUpperCase();
          if (type.equals(""String_Node_Str"")) {
            _signalTypeMap.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
 else           if (type.equals(""String_Node_Str"")) {
            _signalTypeMap.setType(port,DISCRETE);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
 else {
            throw new InvalidStateException(port,""String_Node_Str"");
          }
        }
 else         if (a instanceof CTCompositeActor) {
          _signalTypeMap.setType(port,CONTINUOUS);
          if (port.isOutput()) {
            _signalTypeMap.propagateType(port);
          }
        }
      }
      if (predecessorList(a).isEmpty()) {
        ports=((Entity)a).portList().iterator();
        while (ports.hasNext()) {
          IOPort port=(IOPort)ports.next();
          if (_signalTypeMap.getType(port) == UNKNOWN) {
            _signalTypeMap.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
        }
      }
    }
  }
  DirectedAcyclicGraph arithmeticGraph=_toGraph(arithmeticActors);
  if (!arithmeticGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  DirectedAcyclicGraph dynamicGraph=_toGraph(dynamicActors);
  if (!dynamicGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  Object[] sortedArithmeticActors=arithmeticGraph.topologicalSort();
  for (int i=0; i < sortedArithmeticActors.length; i++) {
    Actor actor=(Actor)sortedArithmeticActors[i];
    Iterator inputPorts=actor.inputPortList().iterator();
    CTReceiver.SignalType knownType=UNKNOWN;
    boolean needManuallySetType=true;
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      if (port.getWidth() != 0) {
        CTReceiver.SignalType type=_signalTypeMap.getType(port);
        if (type == UNKNOWN) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else         if (knownType == UNKNOWN) {
          knownType=type;
          needManuallySetType=false;
        }
 else         if (knownType != type) {
          needManuallySetType=true;
          break;
        }
      }
    }
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      CTReceiver.SignalType type=_signalTypeMap.getType(port);
      if (type == UNKNOWN) {
        if (needManuallySetType) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          _signalTypeMap.setType(port,knownType);
        }
      }
      _signalTypeMap.propagateType(port);
    }
  }
  _setPortSignalTypes(_signalTypeMap);
  if (_debugging)   _debug(""String_Node_Str"" + _signalTypeMap.toString() + ""String_Node_Str"");
  discreteActors=_signalTypeMap.getDiscreteActors();
  continuousActors=_signalTypeMap.getContinuousActors();
  DirectedAcyclicGraph discreteGraph=_toGraph(discreteActors);
  Object[] discreteSorted=discreteGraph.topologicalSort();
  for (int i=0; i < discreteSorted.length; i++) {
    Actor actor=(Actor)discreteSorted[i];
    discreteActorSchedule.add(new Firing(actor));
    if ((actor instanceof CompositeActor) && (actor instanceof CTStepSizeControlActor)) {
      if (!continuousActors.contains(actor)) {
        continuousActors.add(actor);
      }
    }
  }
  Iterator continuousIterator=continuousActors.iterator();
  while (continuousIterator.hasNext()) {
    Actor actor=(Actor)continuousIterator.next();
    if ((actor instanceof SequenceActor) || ((actor instanceof CompositeActor) && (!(actor instanceof CTStepSizeControlActor)))) {
      throw new NotSchedulableException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"");
    }
    continuousActorSchedule.add(new Firing(actor));
    if (actor instanceof CTEventGenerator) {
      sinkActors.add(actor);
    }
 else     if (!(actor instanceof CTDynamicActor)) {
      List successorList=successorList(actor);
      if (successorList.isEmpty()) {
        sinkActors.add(actor);
      }
 else {
        Iterator successors=successorList.iterator();
        boolean isSink=true;
        while (successors.hasNext()) {
          Actor successor=(Actor)successors.next();
          if (continuousActors.contains(successor)) {
            isSink=false;
            break;
          }
        }
        if (isSink) {
          sinkActors.add(actor);
        }
      }
    }
  }
  Iterator generators=waveformGenerators.iterator();
  while (generators.hasNext()) {
    Actor generator=(Actor)generators.next();
    waveformGeneratorSchedule.add(new Firing(generator));
  }
  if (!eventGenerators.isEmpty()) {
    DirectedAcyclicGraph eventGraph=_toGraph(eventGenerators);
    Object[] eventSorted=eventGraph.topologicalSort();
    for (int i=0; i < eventSorted.length; i++) {
      eventGeneratorSchedule.add(new Firing((Actor)eventSorted[i]));
    }
  }
  arithmeticGraph=_toArithmeticGraph(continuousActors);
  if (!dynamicActors.isEmpty()) {
    Object[] dynamicArray=dynamicActors.toArray();
    Object[] xSorted=dynamicGraph.topologicalSort(dynamicArray);
    for (int i=0; i < xSorted.length; i++) {
      Actor a=(Actor)xSorted[i];
      dynamicActorSchedule.add(0,new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
    Object[] fx=arithmeticGraph.backwardReachableNodes(dynamicArray);
    Object[] fxSorted=arithmeticGraph.topologicalSort(fx);
    for (int i=0; i < fxSorted.length; i++) {
      Actor a=(Actor)fxSorted[i];
      stateTransitionSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
  }
  if (!sinkActors.isEmpty()) {
    Object[] sinkArray=sinkActors.toArray();
    Object[] gx=arithmeticGraph.backwardReachableNodes(sinkArray);
    Object[] gxSorted=arithmeticGraph.topologicalSort(gx);
    for (int i=0; i < gxSorted.length; i++) {
      Actor a=(Actor)gxSorted[i];
      if (sinkActors.contains(a)) {
        continue;
      }
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
    Iterator sinks=sinkActors.iterator();
    while (sinks.hasNext()) {
      Actor a=(Actor)sinks.next();
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
  }
  ctSchedule.add(discreteActorSchedule);
  ctSchedule.add(continuousActorSchedule);
  ctSchedule.add(dynamicActorSchedule);
  ctSchedule.add(eventGeneratorSchedule);
  ctSchedule.add(outputSchedule);
  ctSchedule.add(outputSSCActors);
  ctSchedule.add(stateTransitionSchedule);
  ctSchedule.add(statefulActors);
  ctSchedule.add(stateSSCActors);
  ctSchedule.add(waveformGeneratorSchedule);
  setValid(true);
  return ctSchedule;
}"
75462,"private DirectedAcyclicGraph _constructDirectedGraph() throws IllegalActionException {
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  Nameable container=getContainer();
  if (!(container instanceof CompositeActor))   return dag;
  CompositeActor castContainer=(CompositeActor)container;
  Iterator actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    dag.addNodeWeight(actors.next());
  }
  actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    IODependence ioDependence=actor.getIODependence();
    Iterator ports=actor.inputPortList().iterator();
    while (ports.hasNext()) {
      IOPort inputPort=(IOPort)ports.next();
      List delayPorts=null;
      if (ioDependence != null) {
        IOInformation ioInfo=ioDependence.getInputPort(inputPort);
        delayPorts=ioInfo.getDelayToPorts();
      }
      Iterator triggers=actor.outputPortList().iterator();
      while (triggers.hasNext()) {
        IOPort outPort=(IOPort)triggers.next();
        if (delayPorts != null && delayPorts.contains(outPort)) {
          continue;
        }
        Iterator inPortIterator=outPort.deepConnectedInPortList().iterator();
        int referenceDepth=outPort.depthInHierarchy();
        while (inPortIterator.hasNext()) {
          IOPort port=(IOPort)inPortIterator.next();
          if (port.depthInHierarchy() < referenceDepth) {
            if (((NamedObj)port.getContainer()).deepContains(outPort)) {
              continue;
            }
          }
          Actor destination=(Actor)(port.getContainer());
          if (destination.equals(actor)) {
            List directFeedthroughOutputs=null;
            if (ioDependence != null) {
              directFeedthroughOutputs=ioDependence.getInputPort(port).getDirectFeedthroughPorts();
            }
 else {
              directFeedthroughOutputs=destination.outputPortList();
            }
            if (directFeedthroughOutputs.contains(port)) {
              throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName());
            }
          }
          if (dag.containsNodeWeight(destination)) {
            dag.addEdge(actor,destination);
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName() + ""String_Node_Str""+ ((Nameable)destination).getFullName());
          }
        }
      }
    }
  }
  if (!dag.isAcyclic()) {
    Object[] cycleNodes=dag.cycleNodes();
    StringBuffer names=new StringBuffer();
    for (int i=0; i < cycleNodes.length; i++) {
      if (cycleNodes[i] instanceof Nameable) {
        if (i > 0)         names.append(""String_Node_Str"");
        names.append(((Nameable)cycleNodes[i]).getFullName());
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + names.toString());
  }
  return dag;
}","private DirectedAcyclicGraph _constructDirectedGraph() throws IllegalActionException {
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  Nameable container=getContainer();
  if (!(container instanceof CompositeActor))   return dag;
  CompositeActor castContainer=(CompositeActor)container;
  Iterator actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    dag.addNodeWeight(actors.next());
  }
  actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    IODependence ioDependence=actor.getIODependence();
    Iterator ports=actor.inputPortList().iterator();
    while (ports.hasNext()) {
      IOPort inputPort=(IOPort)ports.next();
      List delayPorts=null;
      if (ioDependence != null) {
        IOInformation ioInfo=ioDependence.getInputPort(inputPort);
        delayPorts=ioInfo.getDelayToPorts();
      }
      Iterator triggers=actor.outputPortList().iterator();
      while (triggers.hasNext()) {
        IOPort outPort=(IOPort)triggers.next();
        if (delayPorts != null && delayPorts.contains(outPort)) {
          continue;
        }
        Iterator inPortIterator=outPort.deepConnectedInPortList().iterator();
        int referenceDepth=outPort.depthInHierarchy();
        while (inPortIterator.hasNext()) {
          IOPort port=(IOPort)inPortIterator.next();
          if (port.depthInHierarchy() < referenceDepth) {
            if (((NamedObj)port.getContainer()).deepContains(outPort)) {
              continue;
            }
          }
          Actor destination=(Actor)(port.getContainer());
          if (destination.equals(actor)) {
            List directFeedthroughOutputs=null;
            if (ioDependence != null) {
              directFeedthroughOutputs=ioDependence.getInputPort(port).getDirectFeedthroughPorts();
            }
 else {
              directFeedthroughOutputs=destination.outputPortList();
            }
            if (directFeedthroughOutputs.contains(outPort)) {
              throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName());
            }
          }
          if (dag.containsNodeWeight(destination)) {
            dag.addEdge(actor,destination);
          }
 else {
            throw new IllegalActionException(this,""String_Node_Str"" + ((Nameable)actor).getFullName() + ""String_Node_Str""+ ((Nameable)destination).getFullName());
          }
        }
      }
    }
  }
  if (!dag.isAcyclic()) {
    Object[] cycleNodes=dag.cycleNodes();
    StringBuffer names=new StringBuffer();
    for (int i=0; i < cycleNodes.length; i++) {
      if (cycleNodes[i] instanceof Nameable) {
        if (i > 0)         names.append(""String_Node_Str"");
        names.append(((Nameable)cycleNodes[i]).getFullName());
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + names.toString());
  }
  return dag;
}"
75463,"/** 
 * Consume one input token, if there is one, and produce one output token.  If there is no input, the produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    System.arraycopy(_backward,0,_backwardCache,0,_order + 1);
    System.arraycopy(_forward,0,_forwardCache,0,_order + 1);
    DoubleToken in=(DoubleToken)input.get(0);
    _forwardCache[0]=in.doubleValue();
    _doFilter();
    _backwardCache[0]=_forwardCache[0];
    output.broadcast(new DoubleToken(_forwardCache[_order]));
  }
}","/** 
 * Consume one input token, if there is one, and produce one output token.  If there is no input, the produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    DoubleToken in=(DoubleToken)input.get(0);
    _forwardCache[0]=in.doubleValue();
    _doFilter();
    _backwardCache[0]=_forwardCache[0];
    output.broadcast(new DoubleToken(_forwardCache[_order]));
  }
}"
75464,"/** 
 * Consume one input token, if there is one, and produce one output token.  If there is no input, then produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    System.arraycopy(_backward,0,_backwardCache,0,_backward.length);
    System.arraycopy(_forward,0,_forwardCache,0,_forward.length);
    DoubleToken inputValue=(DoubleToken)input.get(0);
    double k;
    int M=_backward.length - 1;
    _forwardCache[0]=inputValue.doubleValue();
    for (int i=1; i <= M; i++) {
      k=_reflectionCoefs[M - i];
      _forwardCache[i]=k * _backwardCache[i] + _forwardCache[i - 1];
    }
    output.broadcast(new DoubleToken(_forwardCache[M]));
    for (int i=1; i < M; i++) {
      k=-_reflectionCoefs[M - 1 - i];
      _backwardCache[i]=_backwardCache[i + 1] + k * _forwardCache[i + 1];
    }
    _backwardCache[M]=_forwardCache[M];
  }
}","/** 
 * Consume one input token, if there is one, and produce one output token.  If there is no input, then produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    DoubleToken inputValue=(DoubleToken)input.get(0);
    double k;
    int M=_backward.length - 1;
    _forwardCache[0]=inputValue.doubleValue();
    for (int i=1; i <= M; i++) {
      k=_reflectionCoefs[M - i];
      _forwardCache[i]=k * _backwardCache[i] + _forwardCache[i - 1];
    }
    output.broadcast(new DoubleToken(_forwardCache[M]));
    for (int i=1; i < M; i++) {
      k=-_reflectionCoefs[M - 1 - i];
      _backwardCache[i]=_backwardCache[i + 1] + k * _forwardCache[i + 1];
    }
    _backwardCache[M]=_forwardCache[M];
  }
}"
75465,"/** 
 * Convert a MoML file that contains a Ptolemy II specification into a weighted graph representation, and display information about the weighted graph.
 * @param args The name of the MoML file.
 */
public static void main(String[] args){
  if (args.length != 1) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  NamedObj toplevel;
  try {
    MoMLParser parser=new MoMLParser();
    toplevel=parser.parseFile(args[0]);
  }
 catch (  Exception ex) {
    throw new RuntimeException(ex.getMessage() + ""String_Node_Str"");
  }
  if (!(toplevel instanceof CompositeActor)) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ((toplevel == null) ? ""String_Node_Str"" : toplevel.getClass().getName()) + ""String_Node_Str"");
  }
  GraphReader graphReader=new GraphReader();
  DirectedGraph graph=(DirectedGraph)(graphReader.convert((CompositeActor)toplevel));
  System.out.println(""String_Node_Str"");
  System.out.println(graph.toString());
  Collection sourceCollection=graph.sourceNodes();
  System.out.println(""String_Node_Str"" + sourceCollection.size());
  Iterator sources=sourceCollection.iterator();
  while (sources.hasNext()) {
    int i=0;
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ ((Node)(sources.next())).getWeight());
    System.out.println();
  }
  Collection sinkCollection=graph.sinkNodes();
  System.out.println(""String_Node_Str"" + sinkCollection.size());
  Iterator sinks=sinkCollection.iterator();
  while (sinks.hasNext()) {
    int i=0;
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ ((Node)(sinks.next())).getWeight());
    System.out.println();
  }
}","/** 
 * Convert a MoML file that contains a Ptolemy II specification into a weighted graph representation, and display information about the weighted graph.
 * @param args The name of the MoML file.
 */
public static void main(String[] args){
  if (args.length != 1) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  NamedObj toplevel;
  try {
    MoMLParser parser=new MoMLParser();
    toplevel=parser.parseFile(args[0]);
  }
 catch (  Exception ex) {
    throw new RuntimeException(ex.getMessage() + ""String_Node_Str"");
  }
  if (!(toplevel instanceof CompositeActor)) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ((toplevel == null) ? ""String_Node_Str"" : toplevel.getClass().getName()) + ""String_Node_Str"");
  }
  GraphReader graphReader=new GraphReader();
  DirectedGraph graph=(DirectedGraph)(graphReader.convert((CompositeActor)toplevel));
  System.out.println(""String_Node_Str"");
  System.out.println(graph.toString());
  Collection sourceCollection=graph.sourceNodes();
  System.out.println(""String_Node_Str"" + sourceCollection.size());
  Iterator sources=sourceCollection.iterator();
  int sourceNumber=1;
  while (sources.hasNext()) {
    System.out.println(""String_Node_Str"" + sourceNumber++ + ""String_Node_Str""+ ((Node)(sources.next())).getWeight());
    System.out.println();
  }
  Collection sinkCollection=graph.sinkNodes();
  System.out.println(""String_Node_Str"" + sinkCollection.size());
  Iterator sinks=sinkCollection.iterator();
  int sinkNumber=1;
  while (sinks.hasNext()) {
    System.out.println(""String_Node_Str"" + sinkNumber++ + ""String_Node_Str""+ ((Node)(sinks.next())).getWeight());
    System.out.println();
  }
}"
75466,"/** 
 * Return the CTSchedule. Caching of the schedule is done in the director class, so this method does not test for the validation of the schedule.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  CTSchedule ctSchedule=new CTSchedule();
  _signalTypeMap=new SignalTypeMap();
  LinkedList sinkActors=new LinkedList();
  LinkedList dynamicActors=new LinkedList();
  LinkedList discreteActors=new LinkedList();
  LinkedList arithmeticActors=new LinkedList();
  LinkedList eventGenerators=new LinkedList();
  LinkedList waveformGenerators=new LinkedList();
  LinkedList continuousActors=new LinkedList();
  Schedule discreteActorSchedule=new Schedule();
  Schedule continuousActorSchedule=new Schedule();
  Schedule dynamicActorSchedule=new Schedule();
  Schedule eventGeneratorSchedule=new Schedule();
  Schedule outputSchedule=new Schedule();
  Schedule outputSSCActors=new Schedule();
  Schedule stateTransitionSchedule=new Schedule();
  Schedule statefulActors=new Schedule();
  Schedule stateSSCActors=new Schedule();
  Schedule waveformGeneratorSchedule=new Schedule();
  CompositeActor container=(CompositeActor)getContainer().getContainer();
  boolean isCTComposite=false;
  if (container instanceof CTStepSizeControlActor) {
    isCTComposite=true;
  }
  Iterator containerInPorts=container.inputPortList().iterator();
  while (containerInPorts.hasNext()) {
    IOPort inPort=(IOPort)containerInPorts.next();
    if (!isCTComposite) {
      _signalTypeMap.setType(inPort,DISCRETE);
    }
 else {
      Parameter signalType=(Parameter)inPort.getAttribute(""String_Node_Str"");
      if (signalType != null) {
        String type=((StringToken)signalType.getToken()).stringValue();
        type=type.trim().toUpperCase();
        if (type.equals(""String_Node_Str"")) {
          _signalTypeMap.setType(inPort,CONTINUOUS);
        }
 else         if (type.equals(""String_Node_Str"")) {
          _signalTypeMap.setType(inPort,DISCRETE);
        }
 else {
          throw new IllegalActionException(inPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        _signalTypeMap.setType(inPort,CONTINUOUS);
      }
    }
    _signalTypeMap.propagateTypeInside(inPort);
  }
  continuousActors=(LinkedList)((LinkedList)container.deepEntityList()).clone();
  Iterator allActors=container.deepEntityList().iterator();
  while (allActors.hasNext()) {
    Actor a=(Actor)allActors.next();
    if (a instanceof CTStatefulActor) {
      statefulActors.add(new Firing(a));
    }
    if (a instanceof CTWaveformGenerator) {
      waveformGenerators.add(a);
    }
    if (a instanceof CTEventGenerator) {
      eventGenerators.add(a);
    }
    if (a instanceof CTDynamicActor) {
      dynamicActors.addLast(a);
    }
 else     if (!(a instanceof CTWaveformGenerator)) {
      arithmeticActors.add(a);
    }
    if (a instanceof SequenceActor) {
      if (predecessorList(a).isEmpty()) {
        throw new NotSchedulableException(((Nameable)a).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _signalTypeMap.setType(port,DISCRETE);
        if (port.isOutput()) {
          _signalTypeMap.propagateType(port);
        }
      }
    }
 else     if ((a instanceof TypedCompositeActor) && !(a instanceof CTStepSizeControlActor)) {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _signalTypeMap.setType(port,DISCRETE);
        if (port.isOutput()) {
          _signalTypeMap.propagateType(port);
        }
      }
    }
 else {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        Parameter signalType=(Parameter)port.getAttribute(""String_Node_Str"");
        if (signalType != null) {
          String type=((StringToken)signalType.getToken()).stringValue();
          type=type.trim().toUpperCase();
          if (type.equals(""String_Node_Str"")) {
            _signalTypeMap.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
 else           if (type.equals(""String_Node_Str"")) {
            _signalTypeMap.setType(port,DISCRETE);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
 else {
            throw new InvalidStateException(port,""String_Node_Str"");
          }
        }
 else         if (a instanceof CTCompositeActor) {
          _signalTypeMap.setType(port,CONTINUOUS);
          if (port.isOutput()) {
            _signalTypeMap.propagateType(port);
          }
        }
      }
      if (predecessorList(a).isEmpty()) {
        ports=((Entity)a).portList().iterator();
        while (ports.hasNext()) {
          IOPort port=(IOPort)ports.next();
          if (_signalTypeMap.getType(port) == UNKNOWN) {
            _signalTypeMap.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
        }
      }
    }
  }
  DirectedAcyclicGraph arithmeticGraph=_toGraph(arithmeticActors);
  if (!arithmeticGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  DirectedAcyclicGraph dynamicGraph=_toGraph(dynamicActors);
  if (!dynamicGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  Object[] sortedArithmeticActors=arithmeticGraph.topologicalSort();
  for (int i=0; i < sortedArithmeticActors.length; i++) {
    Actor actor=(Actor)sortedArithmeticActors[i];
    Iterator inputPorts=actor.inputPortList().iterator();
    CTReceiver.SignalType knownType=UNKNOWN;
    boolean needManuallySetType=true;
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      if (port.getWidth() != 0) {
        CTReceiver.SignalType type=_signalTypeMap.getType(port);
        if (type == UNKNOWN) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else         if (knownType == UNKNOWN) {
          knownType=type;
          needManuallySetType=false;
        }
 else         if (knownType != type) {
          needManuallySetType=true;
          break;
        }
      }
    }
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      CTReceiver.SignalType type=_signalTypeMap.getType(port);
      if (type == UNKNOWN) {
        if (needManuallySetType) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          _signalTypeMap.setType(port,knownType);
        }
      }
      _signalTypeMap.propagateType(port);
    }
  }
  _setPortSignalTypes(_signalTypeMap);
  if (_debugging)   _debug(""String_Node_Str"" + _signalTypeMap.toString() + ""String_Node_Str"");
  discreteActors=_signalTypeMap.getDiscreteActors();
  continuousActors=_signalTypeMap.getContinuousActors();
  DirectedAcyclicGraph discreteGraph=_toGraph(discreteActors);
  Object[] discreteSorted=discreteGraph.topologicalSort();
  for (int i=0; i < discreteSorted.length; i++) {
    discreteActorSchedule.add(new Firing((Actor)discreteSorted[i]));
  }
  Iterator continuousIterator=continuousActors.iterator();
  while (continuousIterator.hasNext()) {
    Actor actor=(Actor)continuousIterator.next();
    if ((actor instanceof SequenceActor) || ((actor instanceof CompositeActor) && (!(actor instanceof CTStepSizeControlActor)))) {
      throw new NotSchedulableException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"");
    }
    continuousActorSchedule.add(new Firing(actor));
    if (actor instanceof CTEventGenerator) {
      sinkActors.add(actor);
    }
 else     if (!(actor instanceof CTDynamicActor)) {
      List successorList=successorList(actor);
      if (successorList.isEmpty()) {
        sinkActors.add(actor);
      }
 else {
        Iterator successors=successorList.iterator();
        boolean isSink=true;
        while (successors.hasNext()) {
          Actor successor=(Actor)successors.next();
          if (continuousActors.contains(successor)) {
            isSink=false;
            break;
          }
        }
        if (isSink) {
          sinkActors.add(actor);
        }
      }
    }
  }
  Iterator generators=waveformGenerators.iterator();
  while (generators.hasNext()) {
    Actor generator=(Actor)generators.next();
    waveformGeneratorSchedule.add(new Firing(generator));
  }
  if (!eventGenerators.isEmpty()) {
    DirectedAcyclicGraph eventGraph=_toGraph(eventGenerators);
    Object[] eventSorted=eventGraph.topologicalSort();
    for (int i=0; i < eventSorted.length; i++) {
      eventGeneratorSchedule.add(new Firing((Actor)eventSorted[i]));
    }
  }
  arithmeticGraph=_toArithmeticGraph(continuousActors);
  if (!dynamicActors.isEmpty()) {
    Object[] dynamicArray=dynamicActors.toArray();
    Object[] xSorted=dynamicGraph.topologicalSort(dynamicArray);
    for (int i=0; i < xSorted.length; i++) {
      Actor a=(Actor)xSorted[i];
      dynamicActorSchedule.add(0,new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
    Object[] fx=arithmeticGraph.backwardReachableNodes(dynamicArray);
    Object[] fxSorted=arithmeticGraph.topologicalSort(fx);
    for (int i=0; i < fxSorted.length; i++) {
      Actor a=(Actor)fxSorted[i];
      stateTransitionSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
  }
  if (!sinkActors.isEmpty()) {
    Object[] sinkArray=sinkActors.toArray();
    Object[] gx=arithmeticGraph.backwardReachableNodes(sinkArray);
    Object[] gxSorted=arithmeticGraph.topologicalSort(gx);
    for (int i=0; i < gxSorted.length; i++) {
      Actor a=(Actor)gxSorted[i];
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
    Iterator sinks=sinkActors.iterator();
    while (sinks.hasNext()) {
      Actor a=(Actor)sinks.next();
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
  }
  ctSchedule.add(discreteActorSchedule);
  ctSchedule.add(continuousActorSchedule);
  ctSchedule.add(dynamicActorSchedule);
  ctSchedule.add(eventGeneratorSchedule);
  ctSchedule.add(outputSchedule);
  ctSchedule.add(outputSSCActors);
  ctSchedule.add(stateTransitionSchedule);
  ctSchedule.add(statefulActors);
  ctSchedule.add(stateSSCActors);
  ctSchedule.add(waveformGeneratorSchedule);
  setValid(true);
  return ctSchedule;
}","/** 
 * Return the CTSchedule. Caching of the schedule is done in the director class, so this method does not test for the validation of the schedule.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  CTSchedule ctSchedule=new CTSchedule();
  _signalTypeMap=new SignalTypeMap();
  LinkedList sinkActors=new LinkedList();
  LinkedList dynamicActors=new LinkedList();
  LinkedList discreteActors=new LinkedList();
  LinkedList arithmeticActors=new LinkedList();
  LinkedList eventGenerators=new LinkedList();
  LinkedList waveformGenerators=new LinkedList();
  LinkedList continuousActors=new LinkedList();
  Schedule discreteActorSchedule=new Schedule();
  Schedule continuousActorSchedule=new Schedule();
  Schedule dynamicActorSchedule=new Schedule();
  Schedule eventGeneratorSchedule=new Schedule();
  Schedule outputSchedule=new Schedule();
  Schedule outputSSCActors=new Schedule();
  Schedule stateTransitionSchedule=new Schedule();
  Schedule statefulActors=new Schedule();
  Schedule stateSSCActors=new Schedule();
  Schedule waveformGeneratorSchedule=new Schedule();
  CompositeActor container=(CompositeActor)getContainer().getContainer();
  boolean isCTComposite=false;
  if (container instanceof CTStepSizeControlActor) {
    isCTComposite=true;
  }
  Iterator containerInPorts=container.inputPortList().iterator();
  while (containerInPorts.hasNext()) {
    IOPort inPort=(IOPort)containerInPorts.next();
    if (!isCTComposite) {
      _signalTypeMap.setType(inPort,DISCRETE);
    }
 else {
      Parameter signalType=(Parameter)inPort.getAttribute(""String_Node_Str"");
      if (signalType != null) {
        String type=((StringToken)signalType.getToken()).stringValue();
        type=type.trim().toUpperCase();
        if (type.equals(""String_Node_Str"")) {
          _signalTypeMap.setType(inPort,CONTINUOUS);
        }
 else         if (type.equals(""String_Node_Str"")) {
          _signalTypeMap.setType(inPort,DISCRETE);
        }
 else {
          throw new IllegalActionException(inPort,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else {
        _signalTypeMap.setType(inPort,CONTINUOUS);
      }
    }
    _signalTypeMap.propagateTypeInside(inPort);
  }
  continuousActors=(LinkedList)((LinkedList)container.deepEntityList()).clone();
  Iterator allActors=container.deepEntityList().iterator();
  while (allActors.hasNext()) {
    Actor a=(Actor)allActors.next();
    if (a instanceof CTStatefulActor) {
      statefulActors.add(new Firing(a));
    }
    if (a instanceof CTWaveformGenerator) {
      waveformGenerators.add(a);
    }
    if (a instanceof CTEventGenerator) {
      eventGenerators.add(a);
    }
    if (a instanceof CTDynamicActor) {
      dynamicActors.addLast(a);
    }
 else     if (!(a instanceof CTWaveformGenerator)) {
      arithmeticActors.add(a);
    }
    if (a instanceof SequenceActor) {
      if (predecessorList(a).isEmpty()) {
        throw new NotSchedulableException(((Nameable)a).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _signalTypeMap.setType(port,DISCRETE);
        if (port.isOutput()) {
          _signalTypeMap.propagateType(port);
        }
      }
    }
 else     if ((a instanceof TypedCompositeActor) && !(a instanceof CTStepSizeControlActor)) {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        _signalTypeMap.setType(port,DISCRETE);
        if (port.isOutput()) {
          _signalTypeMap.propagateType(port);
        }
      }
    }
 else {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        Parameter signalType=(Parameter)port.getAttribute(""String_Node_Str"");
        if (signalType != null) {
          String type=((StringToken)signalType.getToken()).stringValue();
          type=type.trim().toUpperCase();
          if (type.equals(""String_Node_Str"")) {
            _signalTypeMap.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
 else           if (type.equals(""String_Node_Str"")) {
            _signalTypeMap.setType(port,DISCRETE);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
 else {
            throw new InvalidStateException(port,""String_Node_Str"");
          }
        }
 else         if (a instanceof CTCompositeActor) {
          _signalTypeMap.setType(port,CONTINUOUS);
          if (port.isOutput()) {
            _signalTypeMap.propagateType(port);
          }
        }
      }
      if (predecessorList(a).isEmpty()) {
        ports=((Entity)a).portList().iterator();
        while (ports.hasNext()) {
          IOPort port=(IOPort)ports.next();
          if (_signalTypeMap.getType(port) == UNKNOWN) {
            _signalTypeMap.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              _signalTypeMap.propagateType(port);
            }
          }
        }
      }
    }
  }
  DirectedAcyclicGraph arithmeticGraph=_toGraph(arithmeticActors);
  if (!arithmeticGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  DirectedAcyclicGraph dynamicGraph=_toGraph(dynamicActors);
  if (!dynamicGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  Object[] sortedArithmeticActors=arithmeticGraph.topologicalSort();
  for (int i=0; i < sortedArithmeticActors.length; i++) {
    Actor actor=(Actor)sortedArithmeticActors[i];
    Iterator inputPorts=actor.inputPortList().iterator();
    CTReceiver.SignalType knownType=UNKNOWN;
    boolean needManuallySetType=true;
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      if (port.getWidth() != 0) {
        CTReceiver.SignalType type=_signalTypeMap.getType(port);
        if (type == UNKNOWN) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else         if (knownType == UNKNOWN) {
          knownType=type;
          needManuallySetType=false;
        }
 else         if (knownType != type) {
          needManuallySetType=true;
          break;
        }
      }
    }
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      CTReceiver.SignalType type=_signalTypeMap.getType(port);
      if (type == UNKNOWN) {
        if (needManuallySetType) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          _signalTypeMap.setType(port,knownType);
        }
      }
      _signalTypeMap.propagateType(port);
    }
  }
  _setPortSignalTypes(_signalTypeMap);
  if (_debugging)   _debug(""String_Node_Str"" + _signalTypeMap.toString() + ""String_Node_Str"");
  discreteActors=_signalTypeMap.getDiscreteActors();
  continuousActors=_signalTypeMap.getContinuousActors();
  DirectedAcyclicGraph discreteGraph=_toGraph(discreteActors);
  Object[] discreteSorted=discreteGraph.topologicalSort();
  for (int i=0; i < discreteSorted.length; i++) {
    Actor actor=(Actor)discreteSorted[i];
    discreteActorSchedule.add(new Firing(actor));
    if ((actor instanceof CompositeActor) && (actor instanceof CTStepSizeControlActor)) {
      if (!continuousActors.contains(actor)) {
        continuousActors.add(actor);
      }
    }
  }
  Iterator continuousIterator=continuousActors.iterator();
  while (continuousIterator.hasNext()) {
    Actor actor=(Actor)continuousIterator.next();
    if ((actor instanceof SequenceActor) || ((actor instanceof CompositeActor) && (!(actor instanceof CTStepSizeControlActor)))) {
      throw new NotSchedulableException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"");
    }
    continuousActorSchedule.add(new Firing(actor));
    if (actor instanceof CTEventGenerator) {
      sinkActors.add(actor);
    }
 else     if (!(actor instanceof CTDynamicActor)) {
      List successorList=successorList(actor);
      if (successorList.isEmpty()) {
        sinkActors.add(actor);
      }
 else {
        Iterator successors=successorList.iterator();
        boolean isSink=true;
        while (successors.hasNext()) {
          Actor successor=(Actor)successors.next();
          if (continuousActors.contains(successor)) {
            isSink=false;
            break;
          }
        }
        if (isSink) {
          sinkActors.add(actor);
        }
      }
    }
  }
  Iterator generators=waveformGenerators.iterator();
  while (generators.hasNext()) {
    Actor generator=(Actor)generators.next();
    waveformGeneratorSchedule.add(new Firing(generator));
  }
  if (!eventGenerators.isEmpty()) {
    DirectedAcyclicGraph eventGraph=_toGraph(eventGenerators);
    Object[] eventSorted=eventGraph.topologicalSort();
    for (int i=0; i < eventSorted.length; i++) {
      eventGeneratorSchedule.add(new Firing((Actor)eventSorted[i]));
    }
  }
  arithmeticGraph=_toArithmeticGraph(continuousActors);
  if (!dynamicActors.isEmpty()) {
    Object[] dynamicArray=dynamicActors.toArray();
    Object[] xSorted=dynamicGraph.topologicalSort(dynamicArray);
    for (int i=0; i < xSorted.length; i++) {
      Actor a=(Actor)xSorted[i];
      dynamicActorSchedule.add(0,new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
    Object[] fx=arithmeticGraph.backwardReachableNodes(dynamicArray);
    Object[] fxSorted=arithmeticGraph.topologicalSort(fx);
    for (int i=0; i < fxSorted.length; i++) {
      Actor a=(Actor)fxSorted[i];
      stateTransitionSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
  }
  if (!sinkActors.isEmpty()) {
    Object[] sinkArray=sinkActors.toArray();
    Object[] gx=arithmeticGraph.backwardReachableNodes(sinkArray);
    Object[] gxSorted=arithmeticGraph.topologicalSort(gx);
    for (int i=0; i < gxSorted.length; i++) {
      Actor a=(Actor)gxSorted[i];
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
    Iterator sinks=sinkActors.iterator();
    while (sinks.hasNext()) {
      Actor a=(Actor)sinks.next();
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
  }
  ctSchedule.add(discreteActorSchedule);
  ctSchedule.add(continuousActorSchedule);
  ctSchedule.add(dynamicActorSchedule);
  ctSchedule.add(eventGeneratorSchedule);
  ctSchedule.add(outputSchedule);
  ctSchedule.add(outputSSCActors);
  ctSchedule.add(stateTransitionSchedule);
  ctSchedule.add(statefulActors);
  ctSchedule.add(stateSSCActors);
  ctSchedule.add(waveformGeneratorSchedule);
  setValid(true);
  return ctSchedule;
}"
75467,"/** 
 * Set the value of the shadow variables for the channel of the port. If the specified port is not an input port, then do nothing.
 * @see #_createInputVariables(IOPort port)
 * @param port An input port of this actor.
 * @param channel A channel of the input port.
 * @exception IllegalActionException If the port is not contained bythis actor, or if the shadow variable cannot take the token read from the channel (should not occur).
 */
protected void _setInputVariables(IOPort port,int channel) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  int width=port.getWidth();
  Variable[][] shadowVariables=(Variable[][])_inputVariableMap.get(port);
  if (shadowVariables == null) {
    throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  if (port.isKnown(channel)) {
    int portRate=SDFScheduler.getTokenConsumptionRate(port);
    if (_debug_info) {
      System.out.println(port.getName() + ""String_Node_Str"" + portRate);
    }
    if (_firingsSoFar == 0) {
      _hdfArray=new Token[portRate * _firingsPerScheduleIteration];
    }
    int index=portRate * _firingsSoFar;
    int flag=0;
    while (port.hasToken(channel)) {
      Token token=port.get(channel);
      flag++;
      if (index < portRate * (_firingsSoFar + 1)) {
        if (_debugging) {
          _debug(""String_Node_Str"",port.getName(),""String_Node_Str"" + channel + ""String_Node_Str"",token.toString());
        }
        _hdfArray[index]=token;
        if (_debug_info) {
          System.out.println(""String_Node_Str"" + index + ""String_Node_Str""+ _hdfArray[index].toString());
        }
        index++;
      }
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ flag);
    }
    if (index == portRate * _firingsPerScheduleIteration) {
      shadowVariables[channel][0].setToken(BooleanToken.TRUE);
      shadowVariables[channel][1].setToken(_hdfArray[index - 1]);
      shadowVariables[channel][2].setToken(new ArrayToken(_hdfArray));
      if (_debug_info) {
        System.out.println(""String_Node_Str"" + _hdfArray[index - 1].toString());
      }
    }
 else {
      shadowVariables[channel][0].setToken(BooleanToken.FALSE);
      if (_debugging) {
        _debug(""String_Node_Str"",port.getName(),""String_Node_Str"" + channel + ""String_Node_Str"");
      }
    }
  }
 else {
    shadowVariables[channel][0].setUnknown(true);
    shadowVariables[channel][1].setUnknown(true);
    shadowVariables[channel][2].setUnknown(true);
  }
}","/** 
 * Set the value of the shadow variables for the channel of the port. If the specified port is not an input port, then do nothing.
 * @see #_createInputVariables(IOPort port)
 * @param port An input port of this actor.
 * @param channel A channel of the input port.
 * @exception IllegalActionException If the port is not contained bythis actor, or if the shadow variable cannot take the token read from the channel (should not occur).
 */
protected void _setInputVariables(IOPort port,int channel) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  int width=port.getWidth();
  Variable[][] shadowVariables=(Variable[][])_inputVariableMap.get(port);
  if (shadowVariables == null) {
    throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  if (port.isKnown(channel)) {
    int portRate=SDFScheduler.getTokenConsumptionRate(port);
    if (_debug_info) {
      System.out.println(port.getFullName() + ""String_Node_Str"" + portRate);
    }
    if (_firingsSoFar == 0 && channel == 0) {
      Token[][] a_of_p=new Token[width][portRate * _firingsPerScheduleIteration];
      _hdfArrays.put(port,a_of_p);
    }
    int index=portRate * _firingsSoFar;
    int flag=0;
    while (port.hasToken(channel)) {
      Token token=port.get(channel);
      flag++;
      if (index < portRate * (_firingsSoFar + 1)) {
        if (_debugging) {
          _debug(""String_Node_Str"",port.getName(),""String_Node_Str"" + channel + ""String_Node_Str"",token.toString());
        }
        Token[][] a_of_p=(Token[][])_hdfArrays.get(port);
        a_of_p[channel][index]=token;
        if (_debug_info) {
          System.out.println(""String_Node_Str"" + index + ""String_Node_Str""+ a_of_p[channel][index].toString());
        }
        index++;
      }
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + port.getFullName() + ""String_Node_Str""+ flag);
    }
    if (index == portRate * _firingsPerScheduleIteration && index > 0) {
      Token[][] a_of_p=(Token[][])_hdfArrays.get(port);
      shadowVariables[channel][0].setToken(BooleanToken.TRUE);
      shadowVariables[channel][1].setToken(a_of_p[channel][index - 1]);
      shadowVariables[channel][2].setToken(new ArrayToken(a_of_p[channel]));
    }
 else {
      shadowVariables[channel][0].setToken(BooleanToken.FALSE);
      if (_debugging) {
        _debug(""String_Node_Str"",port.getName(),""String_Node_Str"" + channel + ""String_Node_Str"");
      }
    }
  }
 else {
    shadowVariables[channel][0].setUnknown(true);
    shadowVariables[channel][1].setUnknown(true);
    shadowVariables[channel][2].setUnknown(true);
  }
}"
75468,"/** 
 * Create a new instance of Transition with the specified name in this actor, and return it. This method is write-synchronized on the workspace.
 * @param name The name of the new transition.
 * @return A transition with the given name.
 * @exception IllegalActionException If the name argument is null.
 * @exception NameDuplicationException If name collides with thatof a transition already in this actor.
 */
public ComponentRelation newRelation(String name) throws IllegalActionException, NameDuplicationException {
  try {
    workspace().getWriteAccess();
    Transition tr=new Transition(this,name);
    return tr;
  }
  finally {
    workspace().doneWriting();
  }
}","/** 
 * Create a new instance of Transition with the specified name in this actor, and return it. This method is write-synchronized on the workspace.
 * @param name The name of the new transition.
 * @return A transition with the given name.
 * @exception IllegalActionException If the name argument is null.
 * @exception NameDuplicationException If name collides with thatof a transition already in this actor.
 */
public ComponentRelation newRelation(String name) throws IllegalActionException, NameDuplicationException {
  try {
    workspace().getWriteAccess();
    Director director=getDirector();
    Transition tr=new Transition(this,name);
    if (director instanceof HDFFSMDirector) {
      (tr.preemptive).setVisibility(Settable.NONE);
    }
    return tr;
  }
  finally {
    workspace().doneWriting();
  }
}"
75469,"/** 
 * Create receivers and input variables for the input ports of this actor, and validate attributes of this actor, and attributes of the ports of this actor. Set current state to the initial state. Throw an exception if this actor does not contain a state with name specified by the <i>initialStateName</i> attribute.
 * @exception IllegalActionException If this actor does not contain astate with name specified by the <i>initialStateName</i> attribute.
 */
public void preinitialize() throws IllegalActionException {
  _stopRequested=false;
  _reachedFinalState=false;
  _createReceivers();
}","/** 
 * Create receivers and input variables for the input ports of this actor, and validate attributes of this actor, and attributes of the ports of this actor. Set current state to the initial state. Throw an exception if this actor does not contain a state with name specified by the <i>initialStateName</i> attribute.
 * @exception IllegalActionException If this actor does not contain astate with name specified by the <i>initialStateName</i> attribute.
 */
public void preinitialize() throws IllegalActionException {
  _stopRequested=false;
  _reachedFinalState=false;
  _createReceivers();
  _hdfArrays=new Hashtable();
}"
75470,"/** 
 * Initialize the actors associated with this director, set the size of the schedule cache, and then compute the schedule. The schedule is computed during initialization so that hierarchical opaque composite actors can be scheduled properly (since the act of computing the schedule sets the rate parameters of the external ports). The order in which the actors are initialized is arbitrary.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it, or if there is no scheduler, or if the cache size parameter is not set to a valid value.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  SDFScheduler scheduler=(SDFScheduler)getScheduler();
  int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
}","/** 
 * Initialize the actors associated with this director, set the size of the schedule cache, and then compute the schedule. The schedule is computed during initialization so that hierarchical opaque composite actors can be scheduled properly (since the act of computing the schedule sets the rate parameters of the external ports). The order in which the actors are initialized is arbitrary.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it, or if there is no scheduler, or if the cache size parameter is not set to a valid value.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  SDFScheduler scheduler=(SDFScheduler)getScheduler();
  getSchedule();
  int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
}"
75471,"/** 
 * Create receivers and invoke the preinitialize() methods of all actors deeply contained by the container of this director. Propagate the consumption and production rates of the current state out to the corresponding ports of the container of this director. This method is invoked once per execution, before any iteration, and before the initialize() method.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it, or there is no controller.
 */
public void preinitialize() throws IllegalActionException {
  _firingsPerScheduleIteration=1;
  _firingsSoFar=0;
  super.preinitialize();
  FSMActor ctrl=getController();
  State initialState=ctrl.getInitialState();
  if (_debug_info) {
    System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ initialState.getName());
  }
  TypedCompositeActor curRefinement=(TypedCompositeActor)(initialState.getRefinement())[0];
  if (curRefinement != null) {
    Director refinementDir=curRefinement.getDirector();
    if (_debug_info) {
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refinementDir.getName());
    }
    if (refinementDir instanceof HDFFSMDirector) {
      refinementDir.preinitialize();
    }
 else     if (refinementDir instanceof SDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(true);
      refinmentSched.getSchedule();
    }
 else     if (refinementDir instanceof HDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(false);
      ((HDFDirector)refinementDir).getSchedule();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + refinementDir.getFullName());
      if (_debug_info) {
        CompositeActor container=(CompositeActor)getContainer();
        System.out.println(getName() + ""String_Node_Str"" + ((Nameable)container).getName());
      }
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
    CompositeActor hdfActor=_getHighestFSM();
    Director director=hdfActor.getExecutiveDirector();
    ((StaticSchedulingDirector)director).invalidateSchedule();
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Create receivers and invoke the preinitialize() methods of all actors deeply contained by the container of this director. Propagate the consumption and production rates of the current state out to the corresponding ports of the container of this director. This method is invoked once per execution, before any iteration, and before the initialize() method.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it, or there is no controller.
 */
public void preinitialize() throws IllegalActionException {
  _firingsPerScheduleIteration=1;
  _firingsSoFar=0;
  super.preinitialize();
  FSMActor ctrl=getController();
  State initialState=ctrl.getInitialState();
  if (_debug_info) {
    System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ initialState.getName());
  }
  TypedCompositeActor curRefinement=(TypedCompositeActor)(initialState.getRefinement())[0];
  if (curRefinement != null) {
    Director refinementDir=curRefinement.getDirector();
    if (_debug_info) {
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ curRefinement.getFullName());
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refinementDir.getFullName());
    }
    if (refinementDir instanceof HDFFSMDirector) {
      refinementDir.preinitialize();
    }
 else     if (refinementDir instanceof HDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(false);
      ((HDFDirector)refinementDir).getSchedule();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + refinementDir.getFullName());
      if (_debug_info) {
        CompositeActor container=(CompositeActor)getContainer();
        System.out.println(getName() + ""String_Node_Str"" + ((Nameable)container).getName());
      }
    }
 else     if (refinementDir instanceof SDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(false);
      refinmentSched.getSchedule();
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
    CompositeActor hdfActor=_getHighestFSM();
    Director director=hdfActor.getExecutiveDirector();
    ((StaticSchedulingDirector)director).invalidateSchedule();
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
75472,"/** 
 * Return true if the mode controller wishes to be scheduled for another iteration. Postfire the refinement of the current state of the mode controller. If a type B firing has occurred and exactly one transition is enabled, then change state to the destination state of the enabled transition. Note that a type B firing is the last firing of an actor in an iteration of the HDF graph in which it is embedded. <p> If a state transition to a refinement with different port rates from the previous refinement occurs, then the port rates of the container of this director are updated to be consistant with the port rates of the new state's refinement. The HDF director will be notified of the change in port rates. If a change in port rates occurs and this FSM is governed by an SDF director, an exception will occur.
 * @return True if the mode controller wishes to be scheduled foranother iteration.
 * @exception IllegalActionException If a refinement throws it,if there is no controller, or if an inconsistancy in port rates is detected between refinement actors.
 */
public boolean postfire() throws IllegalActionException {
  FSMActor ctrl=getController();
  State curState=ctrl.currentState();
  TypedActor[] currentRefinement=curState.getRefinement();
  if (currentRefinement == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_debug_info) {
  }
  boolean postfireReturn=currentRefinement[0].postfire();
  _firingsSoFar++;
  if (_debug_info) {
    System.out.println(getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ _firingsSoFar+ ""String_Node_Str""+ _firingsPerScheduleIteration);
  }
  if (_firingsSoFar == _firingsPerScheduleIteration) {
    _firingsSoFar=0;
    Transition lastChosenTr=_getLastChosenTransition();
    if (lastChosenTr == null) {
      if (_debug_info)       System.out.println(getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ curState.getFullName());
      TypedCompositeActor actor=(TypedCompositeActor)(curState.getRefinement())[0];
      _updateInputTokenConsumptionRates(actor);
      _updateOutputTokenProductionRates(actor);
      CompositeActor hdfActor=_getHighestFSM();
      Director director=hdfActor.getExecutiveDirector();
      if (director instanceof HDFDirector) {
        ((HDFDirector)director).invalidateSchedule();
      }
    }
 else {
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"");
      State newState=lastChosenTr.destinationState();
      _setCurrentState(newState);
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + newState.getFullName());
      curState=newState;
      _setCurrentConnectionMap();
      _currentLocalReceiverMap=(Map)_localReceiverMaps.get(ctrl.currentState());
      TypedCompositeActor actor=(TypedCompositeActor)(curState.getRefinement())[0];
      _updateInputTokenConsumptionRates(actor);
      _updateOutputTokenProductionRates(actor);
      CompositeActor hdfActor=_getHighestFSM();
      Director director=hdfActor.getExecutiveDirector();
      if (director instanceof HDFDirector) {
        ((HDFDirector)director).invalidateSchedule();
      }
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    return super.postfire();
  }
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"");
  return postfireReturn;
}","/** 
 * Return true if the mode controller wishes to be scheduled for another iteration. Postfire the refinement of the current state of the mode controller. If a type B firing has occurred and exactly one transition is enabled, then change state to the destination state of the enabled transition. Note that a type B firing is the last firing of an actor in an iteration of the HDF graph in which it is embedded. <p> If a state transition to a refinement with different port rates from the previous refinement occurs, then the port rates of the container of this director are updated to be consistant with the port rates of the new state's refinement. The HDF director will be notified of the change in port rates. If a change in port rates occurs and this FSM is governed by an SDF director, an exception will occur.
 * @return True if the mode controller wishes to be scheduled foranother iteration.
 * @exception IllegalActionException If a refinement throws it,if there is no controller, or if an inconsistancy in port rates is detected between refinement actors.
 */
public boolean postfire() throws IllegalActionException {
  FSMActor ctrl=getController();
  State curState=ctrl.currentState();
  TypedActor[] currentRefinement=curState.getRefinement();
  if (currentRefinement == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_debug_info) {
  }
  boolean postfireReturn=currentRefinement[0].postfire();
  _firingsSoFar++;
  if (_debug_info) {
    System.out.println(getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ _firingsSoFar+ ""String_Node_Str""+ _firingsPerScheduleIteration);
  }
  if (_firingsSoFar == _firingsPerScheduleIteration) {
    _firingsSoFar=0;
    Transition lastChosenTr=_getLastChosenTransition();
    if (lastChosenTr == null) {
      if (_debug_info)       System.out.println(getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ curState.getFullName());
      TypedCompositeActor actor=(TypedCompositeActor)(curState.getRefinement())[0];
      Director refinementDir=actor.getDirector();
      _updateInputTokenConsumptionRates(actor);
      _updateOutputTokenProductionRates(actor);
      CompositeActor hdfActor=_getHighestFSM();
      Director director=hdfActor.getExecutiveDirector();
      if (director instanceof HDFDirector) {
        ((HDFDirector)director).invalidateSchedule();
      }
    }
 else {
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"");
      State newState=lastChosenTr.destinationState();
      _setCurrentState(newState);
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + newState.getFullName());
      BooleanToken resetToken=(BooleanToken)lastChosenTr.reset.getToken();
      if (resetToken.booleanValue()) {
        initialize();
      }
      curState=newState;
      _setCurrentConnectionMap();
      _currentLocalReceiverMap=(Map)_localReceiverMaps.get(ctrl.currentState());
      TypedCompositeActor actor=(TypedCompositeActor)(curState.getRefinement())[0];
      Director refinementDir=actor.getDirector();
      if (refinementDir instanceof HDFFSMDirector) {
        refinementDir.postfire();
      }
 else       if (refinementDir instanceof HDFDirector) {
        Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
        refinmentSched.setValid(false);
        refinmentSched.getSchedule();
        ((HDFDirector)refinementDir).getSchedule();
      }
 else       if (refinementDir instanceof SDFDirector) {
        Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
        refinmentSched.setValid(false);
        refinmentSched.getSchedule();
      }
 else {
      }
      _updateInputTokenConsumptionRates(actor);
      _updateOutputTokenProductionRates(actor);
      CompositeActor hdfActor=_getHighestFSM();
      Director director=hdfActor.getExecutiveDirector();
      if (director instanceof HDFDirector) {
        ((HDFDirector)director).invalidateSchedule();
      }
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    return super.postfire();
  }
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"");
  return postfireReturn;
}"
75473,"/** 
 * Invoke the initialize() method of each deeply contained actor. This method should be invoked once per execution, after the initialization phase, but before any iteration.  Since type resolution has been completed, the initialize() method of a contained actor may produce output or schedule events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _firingsSoFar=0;
}","/** 
 * Invoke the initialize() method of each deeply contained actor. This method should be invoked once per execution, after the initialization phase, but before any iteration.  Since type resolution has been completed, the initialize() method of a contained actor may produce output or schedule events. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _firingsSoFar=0;
  FSMActor controller=getController();
  State initialState=controller.getInitialState();
  TypedCompositeActor curRefinement=(TypedCompositeActor)(initialState.getRefinement())[0];
  if (curRefinement != null) {
    Director refinementDir=curRefinement.getDirector();
    if (_debug_info) {
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ curRefinement.getFullName());
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refinementDir.getFullName());
    }
    if (refinementDir instanceof HDFFSMDirector) {
      refinementDir.initialize();
    }
 else     if (refinementDir instanceof HDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(false);
      ((HDFDirector)refinementDir).getSchedule();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + refinementDir.getFullName());
      if (_debug_info) {
        CompositeActor container=(CompositeActor)getContainer();
        System.out.println(getName() + ""String_Node_Str"" + ((Nameable)container).getName());
      }
    }
 else     if (refinementDir instanceof SDFDirector) {
      Scheduler refinmentSched=((StaticSchedulingDirector)refinementDir).getScheduler();
      refinmentSched.setValid(false);
      refinmentSched.getSchedule();
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    _updateInputTokenConsumptionRates(curRefinement);
    _updateOutputTokenProductionRates(curRefinement);
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
    CompositeActor hdfActor=_getHighestFSM();
    Director director=hdfActor.getExecutiveDirector();
    ((StaticSchedulingDirector)director).invalidateSchedule();
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
75474,"/** 
 * Return a default Configuration.  The initial default configuration is the MoML file ptolemy/configs/full/configuration.xml, but using different command line arguments can change the value
 * @return A default configuration.
 * @exception Exception If the configuration cannot be opened.
 */
protected Configuration _createDefaultConfiguration() throws Exception {
  if (_configurationURL == null) {
    _configurationURL=specToURL(""String_Node_Str"");
  }
  Configuration configuration=null;
  try {
    configuration=_readConfiguration(_configurationURL);
  }
 catch (  Exception ex) {
    throw new Exception(""String_Node_Str"" + _configurationURL + ""String_Node_Str"",ex);
  }
  String libraryName=null;
  try {
    libraryName=StringUtilities.preferencesDirectory() + BasicGraphFrame.VERGIL_USER_LIBRARY_NAME + ""String_Node_Str"";
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ex);
  }
  if (libraryName != null) {
    System.out.print(""String_Node_Str"" + libraryName + ""String_Node_Str"");
    File file=new File(libraryName);
    if (!file.isFile() || !file.exists()) {
      try {
        file.createNewFile();
        FileWriter writer=new FileWriter(file);
        writer.write(""String_Node_Str"" + BasicGraphFrame.VERGIL_USER_LIBRARY_NAME + ""String_Node_Str"");
        writer.close();
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"" + libraryName,ex);
      }
      try {
        openLibrary(configuration,file);
        System.out.println(""String_Node_Str"");
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"",ex);
      }
    }
  }
  return configuration;
}","/** 
 * Return a default Configuration.  The initial default configuration is the MoML file ptolemy/configs/full/configuration.xml, but using different command line arguments can change the value
 * @return A default configuration.
 * @exception Exception If the configuration cannot be opened.
 */
protected Configuration _createDefaultConfiguration() throws Exception {
  if (_configurationURL == null) {
    _configurationURL=specToURL(""String_Node_Str"");
  }
  Configuration configuration=null;
  try {
    configuration=_readConfiguration(_configurationURL);
  }
 catch (  Exception ex) {
    throw new Exception(""String_Node_Str"" + _configurationURL + ""String_Node_Str"",ex);
  }
  String libraryName=null;
  try {
    libraryName=StringUtilities.preferencesDirectory() + BasicGraphFrame.VERGIL_USER_LIBRARY_NAME + ""String_Node_Str"";
  }
 catch (  Exception ex) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ex);
  }
  if (libraryName != null) {
    System.out.print(""String_Node_Str"" + libraryName + ""String_Node_Str"");
    File file=new File(libraryName);
    if (!file.isFile() || !file.exists()) {
      try {
        file.createNewFile();
        FileWriter writer=new FileWriter(file);
        writer.write(""String_Node_Str"" + BasicGraphFrame.VERGIL_USER_LIBRARY_NAME + ""String_Node_Str"");
        writer.close();
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"" + libraryName,ex);
      }
    }
    try {
      openLibrary(configuration,file);
      System.out.println(""String_Node_Str"");
    }
 catch (    Exception ex) {
      MessageHandler.error(""String_Node_Str"",ex);
    }
  }
  return configuration;
}"
75475,"/** 
 * Return true if the mode controller wishes to be scheduled for another iteration. Postfire the refinement of the current state of the mode controller. If a type B firing has occurred and exactly one transition is enabled, then change state to the destination state of the enabled transition. Note that a type B firing is the last firing of an actor in an iteration of the HDF graph in which it is embedded. <p> If a state transition to a refinement with different port rates from the previous refinement occurs, then the port rates of the container of this director are updated to be consistant with the port rates of the new state's refinement. The HDF director will be notified of the change in port rates. If a change in port rates occurs and this FSM is governed by an SDF director, an exception will occur.
 * @return True if the mode controller wishes to be scheduled foranother iteration.
 * @exception IllegalActionException If a refinement throws it,if there is no controller, or if an inconsistancy in port rates is detected between refinement actors.
 */
public boolean postfire() throws IllegalActionException {
  FSMActor ctrl=getController();
  State curState=ctrl.currentState();
  TypedActor[] currentRefinement=curState.getRefinement();
  if (currentRefinement == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_debug_info) {
  }
  boolean postfireReturn=currentRefinement[0].postfire();
  _firingsSoFar++;
  if (_firingsPerScheduleIteration == -1) {
    _firingsPerScheduleIteration=_getFiringsPerSchedulIteration();
  }
  if (_debug_info) {
    System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ _firingsSoFar+ ""String_Node_Str""+ _firingsPerScheduleIteration);
  }
  if (_firingsSoFar == _firingsPerScheduleIteration) {
    _firingsSoFar=0;
    Transition lastChosenTr=_getLastChosenTransition();
    if (lastChosenTr == null) {
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"");
      State newState=lastChosenTr.destinationState();
      _setCurrentState(newState);
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + newState.getFullName());
      curState=newState;
      _setCurrentConnectionMap();
      _currentLocalReceiverMap=(Map)_localReceiverMaps.get(ctrl.currentState());
      TypedCompositeActor actor=(TypedCompositeActor)(curState.getRefinement())[0];
      _updateInputTokenConsumptionRates(actor);
      _updateOutputTokenProductionRates(actor);
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
      CompositeActor hdfActor=_getHighestFSM();
      Director director=hdfActor.getExecutiveDirector();
      if (director instanceof HDFDirector) {
        ((HDFDirector)director).invalidateSchedule();
      }
      _firingsPerScheduleIteration=_getFiringsPerSchedulIteration();
    }
  }
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"");
  return postfireReturn;
}","/** 
 * Return true if the mode controller wishes to be scheduled for another iteration. Postfire the refinement of the current state of the mode controller. If a type B firing has occurred and exactly one transition is enabled, then change state to the destination state of the enabled transition. Note that a type B firing is the last firing of an actor in an iteration of the HDF graph in which it is embedded. <p> If a state transition to a refinement with different port rates from the previous refinement occurs, then the port rates of the container of this director are updated to be consistant with the port rates of the new state's refinement. The HDF director will be notified of the change in port rates. If a change in port rates occurs and this FSM is governed by an SDF director, an exception will occur.
 * @return True if the mode controller wishes to be scheduled foranother iteration.
 * @exception IllegalActionException If a refinement throws it,if there is no controller, or if an inconsistancy in port rates is detected between refinement actors.
 */
public boolean postfire() throws IllegalActionException {
  FSMActor ctrl=getController();
  State curState=ctrl.currentState();
  TypedActor[] currentRefinement=curState.getRefinement();
  if (currentRefinement == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_debug_info) {
  }
  boolean postfireReturn=currentRefinement[0].postfire();
  _firingsSoFar++;
  _firingsSoFar=0;
  Transition lastChosenTr=_getLastChosenTransition();
  if (lastChosenTr == null) {
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"");
    State newState=lastChosenTr.destinationState();
    _setCurrentState(newState);
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + newState.getFullName());
    curState=newState;
    _setCurrentConnectionMap();
    _currentLocalReceiverMap=(Map)_localReceiverMaps.get(ctrl.currentState());
    TypedCompositeActor actor=(TypedCompositeActor)(curState.getRefinement())[0];
    _updateInputTokenConsumptionRates(actor);
    _updateOutputTokenProductionRates(actor);
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
    CompositeActor hdfActor=_getHighestFSM();
    Director director=hdfActor.getExecutiveDirector();
    if (director instanceof HDFDirector) {
      ((HDFDirector)director).invalidateSchedule();
    }
  }
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"");
  return super.postfire();
}"
75476,"/** 
 * Create shadow variables for the port, if it is an input port, and otherwise do nothing. The shadow variables are contained by this actor and can be referenced in the guard and trigger expressions of transitions.  The shadow variables are lazy so that they are not evaluated until their values are needed, so the guard and trigger transitions should also be lazy. <p> If the given port is not a multiport, but is connected to something, then three variables are created: one is input status variable with name ""<i>portName</i>_isPresent""; the second is input value variable with name ""<i>portName</i>""; The third is input array variable with name ""<i>portName</i>Array"". The input status variable always contains a BooleanToken. When this actor is fired, the status variable is set to <i>true</i> if the port has a token, and to <i>false</i> otherwise. The input value variable always contains the latest token received from the port. The input array variable contains an ArrayToken, which contains an array of tokens when the port rate is greater than one. By default, its last token is the latest token, and  hence is the same token in input  value variable. <p> If the given port is a multiport, a status variable, a value variable, and an array variable are created for each channel.  The status variable is named  ""<i>portName</i>_<i>channelIndex</i>_isPresent"". The value variable is named ""<i>portName</i>_<i>channelIndex</i>"". The array variable is named ""<i>portName</i>_<i>channelIndex</i>Array"". <p> If a variable to be created has the same name as an attribute already contained by this actor, that attribute will be removed from this actor by setting its container to null.
 * @param port The port for which to create a shadow variable.
 * @exception IllegalActionException If the port is not containedby this FSMActor.
 */
protected void _createInputVariables(IOPort port) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  if (_inputVariableMap.get(port) != null) {
    _removeInputVariables(port);
  }
  int width=port.getWidth();
  if (width == 0) {
    return;
  }
  Variable[][] shadowVariables=new Variable[width][3];
  String portName=port.getName();
  for (int channelIndex=0; channelIndex < width; ++channelIndex) {
    String shadowName=null;
    if (port.isMultiport()) {
      shadowName=portName + ""String_Node_Str"" + channelIndex;
    }
 else {
      shadowName=portName;
    }
    String predicateName=shadowName + ""String_Node_Str"";
    Attribute previousAttribute=getAttribute(predicateName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][0]=new Variable(this,predicateName);
      shadowVariables[channelIndex][0].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ portName+ ""String_Node_Str""+ ex.getMessage());
    }
    previousAttribute=getAttribute(shadowName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][1]=new Variable(this,shadowName);
      shadowVariables[channelIndex][1].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
    String shadowArrayName=shadowName + ""String_Node_Str"";
    previousAttribute=getAttribute(shadowArrayName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][2]=new Variable(this,shadowArrayName);
      shadowVariables[channelIndex][2].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
  }
  _inputVariableMap.put(port,shadowVariables);
}","/** 
 * Create shadow variables for the port, if it is an input port, and otherwise do nothing. The shadow variables are contained by this actor and can be referenced in the guard and trigger expressions of transitions.  The shadow variables are lazy so that they are not evaluated until their values are needed, so the guard and trigger transitions should also be lazy. <p> If the given port is not a multiport, but is connected to something, then three variables are created: one is input status variable with name ""<i>portName</i>_isPresent""; the second is input value variable with name ""<i>portName</i>""; The third is input array variable with name ""<i>portName</i>Array"". The input status variable always contains a BooleanToken. When this actor is fired, the status variable is set to <i>true</i> if the port has a token, and to <i>false</i> otherwise. The input value variable always contains the latest token received from the port. The input array variable contains an ArrayToken, which contains an array of tokens when the port rate is greater than one. By default, its last token is the latest token, and  hence is the same token in input  value variable. <p> If the given port is a multiport, a status variable, a value variable, and an array variable are created for each channel.  The status variable is named  ""<i>portName</i>_<i>channelIndex</i>_isPresent"". The value variable is named ""<i>portName</i>_<i>channelIndex</i>"". The array variable is named ""<i>portName</i>_<i>channelIndex</i>Array"". <p> If a variable to be created has the same name as an attribute already contained by this actor, that attribute will be removed from this actor by setting its container to null.
 * @param port The port for which to create a shadow variable.
 * @exception IllegalActionException If the port is not containedby this FSMActor.
 */
protected void _createInputVariables(IOPort port) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  if (_inputVariableMap.get(port) != null) {
    _removeInputVariables(port);
  }
  int width=port.getWidth();
  if (width == 0) {
    return;
  }
  Variable[][] shadowVariables=new Variable[width][3];
  String portName=port.getName();
  for (int channelIndex=0; channelIndex < width; ++channelIndex) {
    String shadowName=null;
    if (port.isMultiport()) {
      shadowName=portName + ""String_Node_Str"" + channelIndex;
    }
 else {
      shadowName=portName;
    }
    String predicateName=shadowName + ""String_Node_Str"";
    Attribute previousAttribute=getAttribute(predicateName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][0]=new Variable(this,predicateName);
      shadowVariables[channelIndex][0].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ portName+ ""String_Node_Str""+ ex.getMessage());
    }
    previousAttribute=getAttribute(shadowName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][1]=new Variable(this,shadowName);
      shadowVariables[channelIndex][1].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
    String shadowArrayName=shadowName + ""String_Node_Str"";
    previousAttribute=getAttribute(shadowArrayName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][2]=new Variable(this,shadowArrayName);
      shadowVariables[channelIndex][2].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
  }
  _inputVariableMap.put(port,shadowVariables);
  _inputVariableVersion=_workspace.getVersion();
}"
75477,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the attribute public members to refer to the attributes of the new actor.
 * @param workspace The workspace for the new actor.
 * @return A new FSMActor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  FSMActor newObject=(FSMActor)super.clone(workspace);
  newObject._inputPortsVersion=-1;
  newObject._outputPortsVersion=-1;
  newObject._connectionMapsVersion=-1;
  newObject._connectionMaps=null;
  newObject._initialStateVersion=-1;
  newObject._inputVariableMap=new HashMap();
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the attribute public members to refer to the attributes of the new actor.
 * @param workspace The workspace for the new actor.
 * @return A new FSMActor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  FSMActor newObject=(FSMActor)super.clone(workspace);
  newObject._inputPortsVersion=-1;
  newObject._outputPortsVersion=-1;
  newObject._connectionMapsVersion=-1;
  newObject._connectionMaps=null;
  newObject._initialStateVersion=-1;
  newObject._inputVariableMap=new HashMap();
  newObject._inputVariableVersion=-1;
  return newObject;
}"
75478,"/** 
 * Set the value of the shadow variables for the channel of the port. If the specified port is not an input port, then do nothing.
 * @see #_createInputVariables(IOPort port)
 * @param port An input port of this actor.
 * @param channel A channel of the input port.
 * @exception IllegalActionException If the port is not contained bythis actor, or if the shadow variable cannot take the token read from the channel (should not occur).
 */
protected void _setInputVariables(IOPort port,int channel) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  int width=port.getWidth();
  Variable[][] shadowVariables=(Variable[][])_inputVariableMap.get(port);
  if (shadowVariables == null) {
    throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  if (port.isKnown(channel)) {
    int portRate=SDFScheduler.getTokenConsumptionRate(port);
    if (_debug_info) {
      System.out.println(port.getName() + ""String_Node_Str"" + portRate);
    }
    Token[] hdfArray=new Token[portRate];
    for (int i=0; i < portRate; i++) {
      hdfArray[i]=new IntToken(0);
    }
    int index=0;
    while (index < portRate && port.hasToken(channel)) {
      shadowVariables[channel][0].setToken(BooleanToken.TRUE);
      Token token=port.get(channel);
      if (_debugging) {
        _debug(""String_Node_Str"",port.getName(),""String_Node_Str"" + channel + ""String_Node_Str"",token.toString());
      }
      hdfArray[index]=token;
      if (_debug_info) {
        System.out.println(""String_Node_Str"" + index + ""String_Node_Str""+ hdfArray[index].toString());
      }
      index++;
    }
    if (index > 0) {
      shadowVariables[channel][1].setToken(hdfArray[index - 1]);
      shadowVariables[channel][2].setToken(new ArrayToken(hdfArray));
      if (_debug_info) {
        System.out.println(""String_Node_Str"" + hdfArray[index - 1].toString());
      }
    }
 else {
      shadowVariables[channel][0].setToken(BooleanToken.FALSE);
      if (_debugging) {
        _debug(""String_Node_Str"",port.getName(),""String_Node_Str"" + channel + ""String_Node_Str"");
      }
    }
  }
 else {
    shadowVariables[channel][0].setUnknown(true);
    shadowVariables[channel][1].setUnknown(true);
    shadowVariables[channel][2].setUnknown(true);
  }
}","/** 
 * Set the value of the shadow variables for the channel of the port. If the specified port is not an input port, then do nothing.
 * @see #_createInputVariables(IOPort port)
 * @param port An input port of this actor.
 * @param channel A channel of the input port.
 * @exception IllegalActionException If the port is not contained bythis actor, or if the shadow variable cannot take the token read from the channel (should not occur).
 */
protected void _setInputVariables(IOPort port,int channel) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  int width=port.getWidth();
  Variable[][] shadowVariables=(Variable[][])_inputVariableMap.get(port);
  if (shadowVariables == null) {
    throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  if (port.isKnown(channel)) {
    int portRate=SDFScheduler.getTokenConsumptionRate(port);
    if (_debug_info) {
      System.out.println(port.getName() + ""String_Node_Str"" + portRate);
    }
    Token[] hdfArray=new Token[portRate];
    int index=0;
    while (port.hasToken(channel)) {
      shadowVariables[channel][0].setToken(BooleanToken.TRUE);
      Token token=port.get(channel);
      if (index < portRate) {
        if (_debugging) {
          _debug(""String_Node_Str"",port.getName(),""String_Node_Str"" + channel + ""String_Node_Str"",token.toString());
        }
        hdfArray[index]=token;
        if (_debug_info) {
          System.out.println(""String_Node_Str"" + index + ""String_Node_Str""+ hdfArray[index].toString());
        }
        index++;
      }
    }
    if (index > 0) {
      shadowVariables[channel][1].setToken(hdfArray[index - 1]);
      shadowVariables[channel][2].setToken(new ArrayToken(hdfArray));
      if (_debug_info) {
        System.out.println(""String_Node_Str"" + hdfArray[index - 1].toString());
      }
    }
 else {
      shadowVariables[channel][0].setToken(BooleanToken.FALSE);
      if (_debugging) {
        _debug(""String_Node_Str"",port.getName(),""String_Node_Str"" + channel + ""String_Node_Str"");
      }
    }
  }
 else {
    shadowVariables[channel][0].setUnknown(true);
    shadowVariables[channel][1].setUnknown(true);
    shadowVariables[channel][2].setUnknown(true);
  }
}"
75479,"/** 
 * Create shadow variables for the port, if it is an input port, and otherwise do nothing. The shadow variables are contained by this actor and can be referenced in the guard and trigger expressions of transitions.  The shadow variables are lazy so that they are not evaluated until their values are needed, so the guard and trigger transitions should also be lazy. <p> If the given port is not a multiport, but is connected to something, then two variables are created: one is input status variable with name ""<i>portName</i>_isPresent""; the other is input value variable with name ""<i>portName</i>"". The input status variable always contains a BooleanToken. When this actor is fired, the status variable is set to <i>true</i> if the port has a token, and to <i>false</i> otherwise. The input value variable always contains the latest token received from the port. <p> If the given port is a multiport, a status variable and a value variable are created for each channel. The status variable is named ""<i>portName</i>_<i>channelIndex</i>_isPresent"". The value variable is named ""<i>portName</i>_<i>channelIndex</i>"". <p> If a variable to be created has the same name as an attribute already contained by this actor, that attribute will be removed from this actor by setting its container to null.
 * @param port The port for which to create a shadow variable.
 * @exception IllegalActionException If the port is not containedby this FSMActor.
 */
protected void _createInputVariables(IOPort port) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  if (_inputVariableMap.get(port) != null) {
    _removeInputVariables(port);
  }
  int width=port.getWidth();
  if (width == 0) {
    return;
  }
  Variable[][] shadowVariables=new Variable[width][3];
  String portName=port.getName();
  for (int channelIndex=0; channelIndex < width; ++channelIndex) {
    String shadowName=null;
    if (port.isMultiport()) {
      shadowName=portName + ""String_Node_Str"" + channelIndex;
    }
 else {
      shadowName=portName;
    }
    String predicateName=shadowName + ""String_Node_Str"";
    Attribute previousAttribute=getAttribute(predicateName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][0]=new Variable(this,predicateName);
      shadowVariables[channelIndex][0].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ portName+ ""String_Node_Str""+ ex.getMessage());
    }
    previousAttribute=getAttribute(shadowName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][1]=new Variable(this,shadowName);
      shadowVariables[channelIndex][1].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
    String shadowArrayName=shadowName + ""String_Node_Str"";
    previousAttribute=getAttribute(shadowArrayName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][2]=new Variable(this,shadowArrayName);
      shadowVariables[channelIndex][2].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
  }
  _inputVariableMap.put(port,shadowVariables);
}","/** 
 * Create shadow variables for the port, if it is an input port, and otherwise do nothing. The shadow variables are contained by this actor and can be referenced in the guard and trigger expressions of transitions.  The shadow variables are lazy so that they are not evaluated until their values are needed, so the guard and trigger transitions should also be lazy. <p> If the given port is not a multiport, but is connected to something, then three variables are created: one is input status variable with name ""<i>portName</i>_isPresent""; the second is input value variable with name ""<i>portName</i>""; The third is input array variable with name ""<i>portName</i>Array"". The input status variable always contains a BooleanToken. When this actor is fired, the status variable is set to <i>true</i> if the port has a token, and to <i>false</i> otherwise. The input value variable always contains the latest token received from the port. The input array variable contains an ArrayToken, which contains an array of tokens when the port rate is greater than one. By default, its last token is the latest token, and  hence is the same token in input  value variable. <p> If the given port is a multiport, a status variable, a value variable, and an array variable are created for each channel.  The status variable is named  ""<i>portName</i>_<i>channelIndex</i>_isPresent"". The value variable is named ""<i>portName</i>_<i>channelIndex</i>"". The array variable is named ""<i>portName</i>_<i>channelIndex</i>Array"". <p> If a variable to be created has the same name as an attribute already contained by this actor, that attribute will be removed from this actor by setting its container to null.
 * @param port The port for which to create a shadow variable.
 * @exception IllegalActionException If the port is not containedby this FSMActor.
 */
protected void _createInputVariables(IOPort port) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  if (_inputVariableMap.get(port) != null) {
    _removeInputVariables(port);
  }
  int width=port.getWidth();
  if (width == 0) {
    return;
  }
  Variable[][] shadowVariables=new Variable[width][3];
  String portName=port.getName();
  for (int channelIndex=0; channelIndex < width; ++channelIndex) {
    String shadowName=null;
    if (port.isMultiport()) {
      shadowName=portName + ""String_Node_Str"" + channelIndex;
    }
 else {
      shadowName=portName;
    }
    String predicateName=shadowName + ""String_Node_Str"";
    Attribute previousAttribute=getAttribute(predicateName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][0]=new Variable(this,predicateName);
      shadowVariables[channelIndex][0].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ portName+ ""String_Node_Str""+ ex.getMessage());
    }
    previousAttribute=getAttribute(shadowName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][1]=new Variable(this,shadowName);
      shadowVariables[channelIndex][1].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
    String shadowArrayName=shadowName + ""String_Node_Str"";
    previousAttribute=getAttribute(shadowArrayName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][2]=new Variable(this,shadowArrayName);
      shadowVariables[channelIndex][2].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
  }
  _inputVariableMap.put(port,shadowVariables);
}"
75480,"/** 
 * Create a new TypedIOPort with the specified name. The container of the port is set to this actor. This method is write-synchronized on the workspace.
 * @param name The name for the new port.
 * @return The new port.
 * @exception NameDuplicationException If the actor already has a portwith the specified name.
 */
public Port newPort(String name) throws NameDuplicationException {
  try {
    _workspace.getWriteAccess();
    TypedIOPort p=new TypedIOPort(this,name);
    return p;
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _workspace.doneWriting();
  }
}","/** 
 * Create a new TypedIOPort with the specified name. The container of the port is set to this actor. This method is write-synchronized on the workspace.
 * @param name The name for the new port.
 * @return The new port.
 * @exception NameDuplicationException If the actor already has a portwith the specified name.
 */
public Port newPort(String name) throws NameDuplicationException {
  try {
    _workspace.getWriteAccess();
    return new TypedIOPort(this,name);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _workspace.doneWriting();
  }
}"
75481,"/** 
 * Construct a new tableau for the model represented by the given effigy.
 * @param container The container.
 * @param name The name.
 * @param editor The text editor to use, or null to use the default.
 * @exception IllegalActionException If the container does not acceptthis entity (this should not occur).
 * @exception NameDuplicationException If the name coincides with anattribute already in the container.
 */
public TextEditorTableau(TextEffigy container,String name,TextEditor editor) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  String title=""String_Node_Str"";
  TextEditor frame=editor;
  if (frame == null) {
    frame=new TextEditor(title,container.getDocument());
  }
  frame.text.setColumns(80);
  frame.text.setRows(40);
  setFrame(frame);
  frame.setTableau(this);
}","/** 
 * Construct a new tableau for the model represented by the given effigy.
 * @param container The container.
 * @param name The name.
 * @param editor The text editor to use, or null to use the default.
 * @exception IllegalActionException If the container does not acceptthis entity (this should not occur).
 * @exception NameDuplicationException If the name coincides with anattribute already in the container.
 */
public TextEditorTableau(TextEffigy container,String name,TextEditor editor) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  String title=""String_Node_Str"";
  TextEditor frame=editor;
  if (frame == null) {
    frame=new TextEditor(title,container.getDocument());
  }
  frame.text.setColumns(80);
  frame.text.setRows(40);
  setFrame(frame);
  frame.setTableau(this);
  frame.setModified(false);
}"
75482,"/** 
 * Test if this graph is acyclic (is a DAG). The computation is done in <code>AcyclicAnalysis</code>. Please see  {@link ptolemy.graph.analysis.AcyclicAnalysis}
 * @return True if the the graph is acyclic, orempty; false otherwise.
 */
public boolean isAcyclic(){
  return !_acyclicAnalysis.hasCycle();
}","/** 
 * Test if this graph is acyclic (is a DAG).
 * @return True if the the graph is acyclic, orempty; false otherwise.
 */
public boolean isAcyclic(){
  return !_acyclicAnalysis.hasCycle();
}"
75483,"/** 
 * Override the base class to make the shell uneditable.
 * @exception IllegalActionException If the parent class throws it.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  if (_returnFalseInPostfire && _frame != null) {
    _frame.dispose();
  }
 else   if (shell != null) {
    shell.setEditable(false);
  }
}","/** 
 * Override the base class to make the shell uneditable.
 * @exception IllegalActionException If the parent class throws it.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  if (_returnFalseInPostfire && _frame != null) {
    _frame.dispose();
    _frame=null;
    shell=null;
  }
 else   if (shell != null) {
    shell.setEditable(false);
  }
}"
75484,"/** 
 * Clone the variable.  This creates a new variable containing the same token (if the value was set with setToken()) or the same (unevaluated) expression, if the expression was set with setExpression().  The list of variables added to the scope is not cloned; i.e., the clone has an empty scope. The clone has the same static type constraints (those given by setTypeEquals() and setTypeAtMost()), but none of the dynamic type constraints (those relative to other variables).
 * @param workspace The workspace in which to place the cloned variable.
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @see java.lang.Object#clone()
 * @return The cloned variable.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Variable newObject=(Variable)super.clone(workspace);
  if (_currentExpression != null) {
    newObject._needsEvaluation=true;
  }
  newObject._dependencyLoop=false;
  newObject._parserScope=null;
  if (_declaredType instanceof StructuredType && !_declaredType.isConstant()) {
    newObject._declaredType=(Type)((StructuredType)_declaredType).clone();
    newObject._varType=newObject._declaredType;
  }
  newObject._parseTree=null;
  newObject._constraints=new LinkedList();
  newObject._typeTerm=null;
  return newObject;
}","/** 
 * Clone the variable.  This creates a new variable containing the same token (if the value was set with setToken()) or the same (unevaluated) expression, if the expression was set with setExpression().  The list of variables added to the scope is not cloned; i.e., the clone has an empty scope. The clone has the same static type constraints (those given by setTypeEquals() and setTypeAtMost()), but none of the dynamic type constraints (those relative to other variables).
 * @param workspace The workspace in which to place the cloned variable.
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @see java.lang.Object#clone()
 * @return The cloned variable.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Variable newObject=(Variable)super.clone(workspace);
  if (_currentExpression != null) {
    newObject._needsEvaluation=true;
  }
  newObject._dependencyLoop=false;
  newObject._parserScope=null;
  _variablesDependentOn=null;
  if (_declaredType instanceof StructuredType && !_declaredType.isConstant()) {
    newObject._declaredType=(Type)((StructuredType)_declaredType).clone();
    newObject._varType=newObject._declaredType;
  }
  newObject._parseTree=null;
  newObject._constraints=new LinkedList();
  newObject._typeTerm=null;
  return newObject;
}"
75485,"/** 
 * Return true if the transition is enabled, that is the guard is true, or some event has been detected due to crossing some level.
 * @return True if the transition is enabled and some event is detected.
 * @exception IllegalActionException If thrown when evaluating the guard.
 */
public boolean isEnabled() throws IllegalActionException {
  try {
    if (!_relationList.isEmpty()) {
      _parseTreeEvaluator.setEvaluationMode(false);
    }
    Token token=_guard.getToken();
    if (token == null) {
      return false;
    }
    boolean result=((BooleanToken)token).booleanValue();
    return result;
  }
 catch (  UnknownResultException ex) {
    return false;
  }
}","/** 
 * Return true if the transition is enabled, that is the guard is true, or some event has been detected due to crossing some level.
 * @return True if the transition is enabled and some event is detected.
 * @exception IllegalActionException If thrown when evaluating the guard.
 */
public boolean isEnabled() throws IllegalActionException {
  try {
    if (_exeDirectorIsHSDirector && !_relationList.isEmpty()) {
      _parseTreeEvaluator.setEvaluationMode(false);
    }
    Token token=_guard.getToken();
    if (token == null) {
      return false;
    }
    boolean result=((BooleanToken)token).booleanValue();
    return result;
  }
 catch (  UnknownResultException ex) {
    return false;
  }
}"
75486,"/** 
 * Construct a transition with the given name contained by the specified entity. The container argument must not be null, or a NullPointerException will be thrown. This transition will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string.
 * @param container The container.
 * @param name The name of the transition.
 * @exception IllegalActionException If the container is incompatiblewith this transition.
 * @exception NameDuplicationException If the name coincides withany relation already in the container.
 */
public Transition(FSMActor container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  guardExpression=new StringAttribute(this,""String_Node_Str"");
  outputActions=new OutputActionsAttribute(this,""String_Node_Str"");
  setActions=new CommitActionsAttribute(this,""String_Node_Str"");
  exitAngle=new Parameter(this,""String_Node_Str"");
  exitAngle.setVisibility(Settable.NONE);
  exitAngle.setExpression(""String_Node_Str"");
  exitAngle.setTypeEquals(BaseType.DOUBLE);
  gamma=new Parameter(this,""String_Node_Str"");
  gamma.setVisibility(Settable.NONE);
  gamma.setExpression(""String_Node_Str"");
  gamma.setTypeEquals(BaseType.DOUBLE);
  reset=new Parameter(this,""String_Node_Str"");
  reset.setTypeEquals(BaseType.BOOLEAN);
  reset.setToken(BooleanToken.FALSE);
  preemptive=new Parameter(this,""String_Node_Str"");
  preemptive.setTypeEquals(BaseType.BOOLEAN);
  preemptive.setToken(BooleanToken.FALSE);
  triggerExpression=new StringAttribute(this,""String_Node_Str"");
  triggerExpression.setVisibility(Settable.NONE);
  _guard=new Variable(this,""String_Node_Str"");
  _guard.setLazy(true);
  _guard.setTypeEquals(BaseType.BOOLEAN);
  TypedCompositeActor modalModel=(TypedCompositeActor)container.getContainer();
  if (modalModel.getDirector() instanceof HSDirector) {
    _relationList=new RelationList(this,""String_Node_Str"");
    _parseTreeEvaluator=new ParseTreeEvaluatorForGuardExpression(_relationList,1e-4);
    _guard.setParseTreeEvaluator((ParseTreeEvaluator)_parseTreeEvaluator);
  }
  _trigger=new Variable(this,""String_Node_Str"");
  _trigger.setLazy(true);
  _trigger.setTypeEquals(BaseType.BOOLEAN);
  refinementName=new StringAttribute(this,""String_Node_Str"");
}","/** 
 * Construct a transition with the given name contained by the specified entity. The container argument must not be null, or a NullPointerException will be thrown. This transition will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string.
 * @param container The container.
 * @param name The name of the transition.
 * @exception IllegalActionException If the container is incompatiblewith this transition.
 * @exception NameDuplicationException If the name coincides withany relation already in the container.
 */
public Transition(FSMActor container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  guardExpression=new StringAttribute(this,""String_Node_Str"");
  outputActions=new OutputActionsAttribute(this,""String_Node_Str"");
  setActions=new CommitActionsAttribute(this,""String_Node_Str"");
  exitAngle=new Parameter(this,""String_Node_Str"");
  exitAngle.setVisibility(Settable.NONE);
  exitAngle.setExpression(""String_Node_Str"");
  exitAngle.setTypeEquals(BaseType.DOUBLE);
  gamma=new Parameter(this,""String_Node_Str"");
  gamma.setVisibility(Settable.NONE);
  gamma.setExpression(""String_Node_Str"");
  gamma.setTypeEquals(BaseType.DOUBLE);
  reset=new Parameter(this,""String_Node_Str"");
  reset.setTypeEquals(BaseType.BOOLEAN);
  reset.setToken(BooleanToken.FALSE);
  preemptive=new Parameter(this,""String_Node_Str"");
  preemptive.setTypeEquals(BaseType.BOOLEAN);
  preemptive.setToken(BooleanToken.FALSE);
  triggerExpression=new StringAttribute(this,""String_Node_Str"");
  triggerExpression.setVisibility(Settable.NONE);
  _guard=new Variable(this,""String_Node_Str"");
  _guard.setLazy(true);
  _guard.setTypeEquals(BaseType.BOOLEAN);
  TypedCompositeActor modalModel=(TypedCompositeActor)container.getContainer();
  if (modalModel != null && modalModel.getDirector() instanceof HSDirector) {
    _exeDirectorIsHSDirector=true;
    _relationList=new RelationList(this,""String_Node_Str"");
    _parseTreeEvaluator=new ParseTreeEvaluatorForGuardExpression(_relationList,1e-4);
    _guard.setParseTreeEvaluator((ParseTreeEvaluator)_parseTreeEvaluator);
  }
 else {
    _exeDirectorIsHSDirector=false;
  }
  _trigger=new Variable(this,""String_Node_Str"");
  _trigger.setLazy(true);
  _trigger.setTypeEquals(BaseType.BOOLEAN);
  refinementName=new StringAttribute(this,""String_Node_Str"");
}"
75487,"/** 
 * React to a change in an attribute. If the changed attribute is the <i>preemptive</i> parameter, evaluate the parameter. If the parameter is given an expression that does not evaluate to a boolean value, throw an exception; otherwise increment the version number of the workspace.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If thrown by the superclassattributeChanged() method, or the changed attribute is the <i>preemptive</i> parameter and is given an expression that does not evaluate to a boolean value.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  super.attributeChanged(attribute);
  if (attribute == preemptive) {
    preemptive.getToken();
    workspace().incrVersion();
  }
  if (attribute == guardExpression) {
    String expr=guardExpression.getExpression();
    _guard.setExpression(expr);
    _relationList.destroy();
    _parseTreeEvaluator.setEvaluationMode(true);
  }
  if (attribute == triggerExpression) {
    String expr=triggerExpression.getExpression();
    _trigger.setExpression(expr);
  }
  if (attribute == refinementName) {
    _refinementVersion=-1;
  }
  if (attribute == outputActions && _debugging)   outputActions.addDebugListener(new StreamListener());
  if (attribute == setActions && _debugging)   setActions.addDebugListener(new StreamListener());
}","/** 
 * React to a change in an attribute. If the changed attribute is the <i>preemptive</i> parameter, evaluate the parameter. If the parameter is given an expression that does not evaluate to a boolean value, throw an exception; otherwise increment the version number of the workspace.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If thrown by the superclassattributeChanged() method, or the changed attribute is the <i>preemptive</i> parameter and is given an expression that does not evaluate to a boolean value.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  super.attributeChanged(attribute);
  if (attribute == preemptive) {
    preemptive.getToken();
    workspace().incrVersion();
  }
  if (attribute == guardExpression) {
    String expr=guardExpression.getExpression();
    _guard.setExpression(expr);
    if (_exeDirectorIsHSDirector) {
      _relationList.destroy();
      _parseTreeEvaluator.setEvaluationMode(true);
    }
  }
  if (attribute == triggerExpression) {
    String expr=triggerExpression.getExpression();
    _trigger.setExpression(expr);
  }
  if (attribute == refinementName) {
    _refinementVersion=-1;
  }
  if (attribute == outputActions && _debugging)   outputActions.addDebugListener(new StreamListener());
  if (attribute == setActions && _debugging)   setActions.addDebugListener(new StreamListener());
}"
75488,"/** 
 * Visit the relation node. The evaluation part is the same as normal parseTreeEvaluator, except that information about each relation (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The relation node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitRelationNode throws the IllegalActionException.
 */
public void visitRelationalNode(ASTPtRelationalNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    return;
  }
  Set variablesOfNode=_variableCollector.collectFreeVariables(node);
  Iterator absentDiscreteVariables=_absentDiscreteVariables.listIterator();
  while (absentDiscreteVariables.hasNext()) {
    String variableName=(String)absentDiscreteVariables.next();
    if (variablesOfNode.contains(variableName)) {
      _evaluatedChildToken=new BooleanToken(false);
      if (_constructingRelationList) {
        _relationList.addRelation(0,0.0);
      }
      _relationIndex++;
      if (_relationIndex >= _relationList.length()) {
        _relationIndex-=_relationList.length();
      }
      return;
    }
  }
  ptolemy.data.Token[] tokens=_evaluateAllChildren(node);
  int numChildren=node.jjtGetNumChildren();
  _assert(numChildren == 2,node,""String_Node_Str"");
  ptolemy.data.expr.Token operator=(ptolemy.data.expr.Token)node.getOperator();
  ptolemy.data.Token leftToken=tokens[0];
  ptolemy.data.Token rightToken=tokens[1];
  ptolemy.data.Token result;
  if (operator.kind == PtParserConstants.EQUALS || operator.kind == PtParserConstants.NOTEQUALS) {
    if (operator.kind == PtParserConstants.EQUALS) {
      result=leftToken.isCloseTo(rightToken,_errorTolerance);
    }
 else {
      result=leftToken.isCloseTo(rightToken,_errorTolerance).not();
    }
    if ((leftToken instanceof BooleanToken) && (rightToken instanceof BooleanToken)) {
      if (((BooleanToken)result).booleanValue()) {
        _relationType=1;
      }
 else {
        _relationType=2;
      }
      _difference=0.0;
    }
 else {
      ScalarToken difference=(ScalarToken)leftToken.subtract(rightToken);
      if (((BooleanToken)result).booleanValue()) {
        _relationType=3;
      }
 else {
        if (difference.doubleValue() < 0) {
          _relationType=4;
        }
 else {
          _relationType=5;
        }
      }
      _difference=difference.doubleValue();
    }
  }
 else {
    if (!((leftToken instanceof ScalarToken) && (rightToken instanceof ScalarToken))) {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str"");
    }
    ScalarToken leftScalar=(ScalarToken)leftToken;
    ScalarToken rightScalar=(ScalarToken)rightToken;
    if (operator.kind == PtParserConstants.GTE) {
      result=leftScalar.isLessThan(rightScalar).not();
    }
 else     if (operator.kind == PtParserConstants.GT) {
      result=rightScalar.isLessThan(leftScalar);
    }
 else     if (operator.kind == PtParserConstants.LTE) {
      result=rightScalar.isLessThan(leftScalar).not();
    }
 else     if (operator.kind == PtParserConstants.LT) {
      result=leftScalar.isLessThan(rightScalar);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str""+ leftToken.getClass().getName()+ ""String_Node_Str""+ rightToken.getClass().getName());
    }
    if (((BooleanToken)result).booleanValue()) {
      _relationType=1;
    }
 else {
      _relationType=2;
    }
    _difference=((ScalarToken)leftScalar.subtract(rightScalar)).doubleValue();
  }
  _evaluatedChildToken=result;
  if (_constructingRelationList) {
    _relationList.addRelation(_relationType,_difference);
  }
 else {
    _relationList.setRelation(_relationIndex,_relationType,_difference);
  }
  _relationIndex++;
  if (_relationIndex >= _relationList.length()) {
    _relationIndex-=_relationList.length();
  }
  return;
}","/** 
 * Visit the relation node. The evaluation part is the same as normal parseTreeEvaluator, except that information about each relation (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The relation node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitRelationNode throws the IllegalActionException.
 */
public void visitRelationalNode(ASTPtRelationalNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    return;
  }
  Set variablesOfNode=_variableCollector.collectFreeVariables(node);
  Iterator absentDiscreteVariables=_absentDiscreteVariables.listIterator();
  while (absentDiscreteVariables.hasNext()) {
    String variableName=(String)absentDiscreteVariables.next();
    if (variablesOfNode.contains(variableName)) {
      _evaluatedChildToken=new BooleanToken(false);
      if (_constructingRelationList) {
        _relationList.addRelation(0,0.0);
      }
      _relationIndex++;
      if (_relationIndex >= _relationList.length()) {
        _relationIndex-=_relationList.length();
      }
      return;
    }
  }
  ptolemy.data.Token[] tokens=_evaluateAllChildren(node);
  int numChildren=node.jjtGetNumChildren();
  _assert(numChildren == 2,node,""String_Node_Str"");
  ptolemy.data.expr.Token operator=(ptolemy.data.expr.Token)node.getOperator();
  ptolemy.data.Token leftToken=tokens[0];
  ptolemy.data.Token rightToken=tokens[1];
  ptolemy.data.Token result;
  if (operator.kind == PtParserConstants.EQUALS || operator.kind == PtParserConstants.NOTEQUALS) {
    if (operator.kind == PtParserConstants.EQUALS) {
      result=leftToken.isCloseTo(rightToken,_errorTolerance);
    }
 else {
      result=leftToken.isCloseTo(rightToken,_errorTolerance).not();
    }
    if ((leftToken instanceof ScalarToken) && (rightToken instanceof ScalarToken)) {
      ScalarToken difference=(ScalarToken)leftToken.subtract(rightToken);
      if (((BooleanToken)result).booleanValue()) {
        _relationType=3;
      }
 else {
        if (difference.doubleValue() < 0) {
          _relationType=4;
        }
 else {
          _relationType=5;
        }
      }
      _difference=difference.doubleValue();
    }
 else {
      if (((BooleanToken)result).booleanValue()) {
        _relationType=1;
      }
 else {
        _relationType=2;
      }
      _difference=0.0;
    }
  }
 else {
    if (!((leftToken instanceof ScalarToken) && (rightToken instanceof ScalarToken))) {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str"");
    }
    ScalarToken leftScalar=(ScalarToken)leftToken;
    ScalarToken rightScalar=(ScalarToken)rightToken;
    if (operator.kind == PtParserConstants.GTE) {
      result=leftScalar.isLessThan(rightScalar).not();
    }
 else     if (operator.kind == PtParserConstants.GT) {
      result=rightScalar.isLessThan(leftScalar);
    }
 else     if (operator.kind == PtParserConstants.LTE) {
      result=rightScalar.isLessThan(leftScalar).not();
    }
 else     if (operator.kind == PtParserConstants.LT) {
      result=leftScalar.isLessThan(rightScalar);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str""+ leftToken.getClass().getName()+ ""String_Node_Str""+ rightToken.getClass().getName());
    }
    if (((BooleanToken)result).booleanValue()) {
      _relationType=1;
    }
 else {
      _relationType=2;
    }
    _difference=((ScalarToken)leftScalar.subtract(rightScalar)).doubleValue();
  }
  _evaluatedChildToken=result;
  if (_constructingRelationList) {
    _relationList.addRelation(_relationType,_difference);
  }
 else {
    _relationList.setRelation(_relationIndex,_relationType,_difference);
  }
  _relationIndex++;
  if (_relationIndex >= _relationList.length()) {
    _relationIndex-=_relationList.length();
  }
  return;
}"
75489,"/** 
 * Request that execution of the current iteration stops. This is similar to stopFire(), except that the current iteration is not allowed to complete.  This is useful if there is actor in the model that has a bug where it fails to consume inputs. An iteration will never terminate if such an actor receives an event. If the director is paused waiting for events to appear in the event queue, then it stops waiting, and calls stopFire() for all actors that are deeply contained by the container of this director.
 */
public void stop(){
  if (_eventQueue != null) {
synchronized (_eventQueue) {
      _stopRequested=true;
      _eventQueue.notifyAll();
    }
  }
  super.stop();
}","/** 
 * Request that execution of the current iteration stop. This is similar to stopFire(), except that the current iteration is not allowed to complete.  This is useful if there is actor in the model that has a bug where it fails to consume inputs. An iteration will never terminate if such an actor receives an event. If the director is paused waiting for events to appear in the event queue, then it stops waiting, and calls stopFire() for all actors that are deeply contained by the container of this director.
 */
public void stop(){
  if (_eventQueue != null) {
synchronized (_eventQueue) {
      _stopRequested=true;
      _eventQueue.notifyAll();
    }
  }
  super.stop();
}"
75490,"/** 
 * Request that execution of the current iteration completes. If the director is paused waiting for events to appear in the event queue, then it stops waiting, and calls stopFire() for all actors that are deeply contained by the container of this director.
 */
public void stopFire(){
  if (_eventQueue != null) {
synchronized (_eventQueue) {
      _eventQueue.notifyAll();
    }
  }
  super.stopFire();
}","/** 
 * Request that execution of the current iteration complete. If the director is paused waiting for events to appear in the event queue, then it stops waiting, and calls stopFire() for all actors that are deeply contained by the container of this director.
 */
public void stopFire(){
  if (_eventQueue != null) {
synchronized (_eventQueue) {
      _eventQueue.notifyAll();
    }
  }
  super.stopFire();
}"
75491,"/** 
 * Return the type of the identifier with the given name.
 * @exception IllegalActionException If the identifier is undefined.
 */
protected Type _getTypeForName(String name) throws IllegalActionException {
  if (_scope != null) {
    Type type=_scope.getType(name);
    if (type != null) {
      return type;
    }
  }
  if (Constants.get(name) != null) {
    return Constants.get(name).getType();
  }
  return BaseType.GENERAL;
}","/** 
 * Return the type of the identifier with the given name.
 * @exception IllegalActionException If the identifier is undefined.
 */
protected Type _getTypeForName(String name) throws IllegalActionException {
  if (_scope != null) {
    Type type=_scope.getType(name);
    if (type != null) {
      return type;
    }
  }
  if (Constants.get(name) != null) {
    return Constants.get(name).getType();
  }
  throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
}"
75492,"/** 
 * Set the type of the given node to be the type of constant the variable refers to, if the node represents a constant, or the type of the identifier the node refers to in the current scope.
 * @param node The specified node.
 * @exception IllegalActionException If an inference erroroccurs, or an identifier is not bound in the current scope.
 */
public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    _setType(node,node.getToken().getType());
    return;
  }
  _setType(node,_getTypeForName(node.getName()));
}","/** 
 * Set the type of the given node to be the type of constant the variable refers to, if the node represents a constant, or the type of the identifier the node refers to in the current scope.
 * @param node The specified node.
 * @exception IllegalActionException If an inference erroroccurs, or an identifier is not bound in the current scope.
 */
public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    _setType(node,node.getToken().getType());
    return;
  }
  String name=node.getName();
  if (_scope != null) {
    Type type=_scope.getType(name);
    if (type != null) {
      _setType(node,type);
      return;
    }
  }
  if (Constants.get(name) != null) {
    _setType(node,Constants.get(name).getType());
    return;
  }
  throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
}"
75493,"/** 
 * Set the type of the given node to be the return type of the function determined for the given node.
 * @param node The specified node.
 * @exception IllegalActionException If an inference error occurs.
 */
public void visitFunctionApplicationNode(ASTPtFunctionApplicationNode node) throws IllegalActionException {
  int argCount=node.jjtGetNumChildren() - 1;
  Type[] childTypes=new Type[argCount];
  for (int i=0; i < argCount; i++) {
    childTypes[i]=_inferChild(node,i + 1);
    if (childTypes[i] == null) {
      throw new RuntimeException(""String_Node_Str"" + node + ""String_Node_Str"");
    }
  }
  Type baseType=_inferChild(node,0);
  if (baseType instanceof FunctionType) {
    _setType(node,((FunctionType)baseType).getReturnType());
    return;
  }
 else   if (argCount == 1) {
    if (baseType instanceof ArrayType) {
      _setType(node,((ArrayType)baseType).getElementType());
      return;
    }
 else {
      _assert(true,node,""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName() + ""String_Node_Str"");
    }
  }
 else   if (argCount == 2) {
    if (baseType instanceof UnsizedMatrixType) {
      _setType(node,((UnsizedMatrixType)baseType).getElementType());
      return;
    }
 else {
      _assert(true,node,""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName() + ""String_Node_Str"");
    }
  }
  String functionName=node.getFunctionName();
  if (functionName == null) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName());
  }
  if (functionName.compareTo(""String_Node_Str"") == 0 && argCount == 2) {
    ASTPtRootNode castTypeNode=((ASTPtRootNode)node.jjtGetChild(0 + 1));
    ParseTreeEvaluator parseTreeEvaluator=new ParseTreeEvaluator();
    try {
      ptolemy.data.Token t=parseTreeEvaluator.evaluateParseTree(castTypeNode,_scope);
      _setType(node,t.getType());
    }
 catch (    IllegalActionException ex) {
      _setType(node,childTypes[0]);
    }
    return;
  }
  if (functionName.compareTo(""String_Node_Str"") == 0) {
    _setType(node,BaseType.GENERAL);
    return;
  }
  if (functionName.compareTo(""String_Node_Str"") == 0) {
    _setType(node,BaseType.GENERAL);
    return;
  }
  CachedMethod cachedMethod=CachedMethod.findMethod(functionName,childTypes,CachedMethod.FUNCTION);
  if (cachedMethod.isValid()) {
    Type type=cachedMethod.getReturnType();
    _setType(node,type);
  }
 else {
    StringBuffer buffer=new StringBuffer();
    for (int i=0; i < childTypes.length; i++) {
      if (i == 0) {
        buffer.append(childTypes[i].toString());
      }
 else {
        buffer.append(""String_Node_Str"" + childTypes[i].toString());
      }
    }
    throw new IllegalActionException(""String_Node_Str"" + node.getFunctionName() + ""String_Node_Str""+ buffer+ ""String_Node_Str"");
  }
}","/** 
 * Set the type of the given node to be the return type of the function determined for the given node.
 * @param node The specified node.
 * @exception IllegalActionException If an inference error occurs.
 */
public void visitFunctionApplicationNode(ASTPtFunctionApplicationNode node) throws IllegalActionException {
  int argCount=node.jjtGetNumChildren() - 1;
  String functionName=node.getFunctionName();
  Type[] childTypes=new Type[argCount];
  for (int i=0; i < argCount; i++) {
    childTypes[i]=_inferChild(node,i + 1);
    if (childTypes[i] == null) {
      throw new RuntimeException(""String_Node_Str"" + node + ""String_Node_Str"");
    }
  }
  Type baseType=null;
  if (_scope != null && functionName != null) {
    baseType=_scope.getType(functionName);
  }
  if (baseType != null || functionName == null) {
    baseType=_inferChild(node,0);
    if (baseType instanceof FunctionType) {
      _setType(node,((FunctionType)baseType).getReturnType());
      return;
    }
 else     if (argCount == 1) {
      if (baseType instanceof ArrayType) {
        _setType(node,((ArrayType)baseType).getElementType());
        return;
      }
 else {
        _assert(true,node,""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName() + ""String_Node_Str"");
      }
    }
 else     if (argCount == 2) {
      if (baseType instanceof UnsizedMatrixType) {
        _setType(node,((UnsizedMatrixType)baseType).getElementType());
        return;
      }
 else {
        _assert(true,node,""String_Node_Str"" + ""String_Node_Str"" + node.getFunctionName() + ""String_Node_Str"");
      }
    }
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + functionName);
  }
  if (functionName.compareTo(""String_Node_Str"") == 0 && argCount == 2) {
    ASTPtRootNode castTypeNode=((ASTPtRootNode)node.jjtGetChild(0 + 1));
    ParseTreeEvaluator parseTreeEvaluator=new ParseTreeEvaluator();
    try {
      ptolemy.data.Token t=parseTreeEvaluator.evaluateParseTree(castTypeNode,_scope);
      _setType(node,t.getType());
    }
 catch (    IllegalActionException ex) {
      _setType(node,childTypes[0]);
    }
    return;
  }
  if (functionName.compareTo(""String_Node_Str"") == 0) {
    _setType(node,BaseType.GENERAL);
    return;
  }
  if (functionName.compareTo(""String_Node_Str"") == 0) {
    _setType(node,BaseType.GENERAL);
    return;
  }
  CachedMethod cachedMethod=CachedMethod.findMethod(functionName,childTypes,CachedMethod.FUNCTION);
  if (cachedMethod.isValid()) {
    Type type=cachedMethod.getReturnType();
    _setType(node,type);
  }
 else {
    StringBuffer buffer=new StringBuffer();
    for (int i=0; i < childTypes.length; i++) {
      if (i == 0) {
        buffer.append(childTypes[i].toString());
      }
 else {
        buffer.append(""String_Node_Str"" + childTypes[i].toString());
      }
    }
    throw new IllegalActionException(""String_Node_Str"" + node.getFunctionName() + ""String_Node_Str""+ buffer+ ""String_Node_Str"");
  }
}"
75494,"/** 
 * Place a Token into the receiver via rendezvous. This method does not return until the rendezvous has been completed. If get has already been reached, it notifies the waiting get and waits for the rendezvous to complete. When the rendezvous is complete it returns. If a get has not yet been reached, the method delays until a get is reached. It is assumed that at most one process is trying to receive from and send to the channel associated with this receiver. to receive from it and at most one channel send to it.
 * @param t The token being transferred in the rendezvous.
 * @exception TerminateProcessException If execution terminationhas been requested, or if the execution is abruptly terminated from the outside (via an InterruptedException).
 */
public synchronized void put(Token t,Branch branch){
  boolean blocked=false;
  try {
    _token=t;
    if (_isGetWaiting()) {
      _setGetWaiting(false);
      _setRendezvousComplete(false);
      notifyAll();
      while (!_isRendezvousComplete()) {
        _checkFlagsAndWait();
      }
      return;
    }
 else {
      _setPutWaiting(true);
      notifyAll();
      while (_isConditionalReceiveWaiting()) {
        _checkFlagsAndWait();
      }
      _checkFlags();
      prepareToBlock(branch);
      blocked=true;
      while (_isPutWaiting()) {
        _checkFlagsAndWait();
      }
      _checkFlags();
      wakeUpBlockedPartner();
      blocked=false;
      _setRendezvousComplete(true);
      notifyAll();
      return;
    }
  }
 catch (  InterruptedException ex) {
    throw new TerminateProcessException(""String_Node_Str"");
  }
 finally {
    if (blocked) {
      wakeUpBlockedPartner();
    }
  }
}","/** 
 * Place a Token into the receiver via rendezvous. This method does not return until the rendezvous has been completed. If get has already been reached, it notifies the waiting get and waits for the rendezvous to complete. When the rendezvous is complete it returns. If a get has not yet been reached, the method delays until a get is reached. It is assumed that at most one process is trying to receive from and send to the channel associated with this receiver. to receive from it and at most one channel send to it.
 * @param t The token being transferred in the rendezvous.
 * @exception TerminateProcessException If execution terminationhas been requested, or if the execution is abruptly terminated from the outside (via an InterruptedException).
 */
public synchronized void put(Token t,Branch branch){
  boolean blocked=false;
  try {
    _token=t;
    if (_isGetWaiting()) {
      _setGetWaiting(false);
      _setRendezvousComplete(false);
      notifyAll();
      while (!_isRendezvousComplete()) {
        _checkFlagsAndWait();
      }
      return;
    }
 else {
      _setPutWaiting(true);
      notifyAll();
      while (_isConditionalReceiveWaiting()) {
        _checkFlagsAndWait();
      }
      _checkFlags();
      markBlocked(branch);
      blocked=true;
      while (_isPutWaiting()) {
        _checkFlagsAndWait();
      }
      _checkFlags();
      markUnblocked();
      blocked=false;
      _setRendezvousComplete(true);
      notifyAll();
      return;
    }
  }
 catch (  InterruptedException ex) {
    throw new TerminateProcessException(""String_Node_Str"");
  }
 finally {
    if (blocked) {
      markUnblocked();
    }
  }
}"
75495,"/** 
 * Retrieve a Token from the receiver by rendezvous. This method does not return until the rendezvous has been completed. If a put has already been reached, it notifies the waiting put and waits for the rendezvous to complete. When the rendezvous is complete it returns with the token. If a put has not yet been reached, the method delays until a put is reached. It is assumed that at most one process is trying to receive from and send to the channel associated with this receiver.
 * @return The token transferred by the rendezvous.
 * @exception TerminateProcessException If execution terminationhas been requested, or if the execution is abruptly terminated from the outside (via an InterruptedException).
 */
public synchronized Token get(Branch branch){
  Token tmp=null;
  boolean blocked=false;
  try {
    if (_isPutWaiting()) {
      _setPutWaiting(false);
      tmp=_token;
      _setRendezvousComplete(false);
      notifyAll();
      while (!_isRendezvousComplete()) {
        _checkFlagsAndWait();
      }
    }
 else {
      _setGetWaiting(true);
      notifyAll();
      while (_isConditionalSendWaiting()) {
        _checkFlagsAndWait();
      }
      _checkFlags();
      prepareToBlock(branch);
      blocked=true;
      while (_isGetWaiting()) {
        _checkFlagsAndWait();
      }
      _checkFlags();
      wakeUpBlockedPartner();
      blocked=false;
      tmp=_token;
      _setRendezvousComplete(true);
      notifyAll();
    }
  }
 catch (  InterruptedException ex) {
    throw new TerminateProcessException(""String_Node_Str"");
  }
 finally {
    if (blocked) {
      wakeUpBlockedPartner();
    }
  }
  return tmp;
}","/** 
 * Retrieve a Token from the receiver by rendezvous. This method does not return until the rendezvous has been completed. If a put has already been reached, it notifies the waiting put and waits for the rendezvous to complete. When the rendezvous is complete it returns with the token. If a put has not yet been reached, the method delays until a put is reached. It is assumed that at most one process is trying to receive from and send to the channel associated with this receiver.
 * @return The token transferred by the rendezvous.
 * @exception TerminateProcessException If execution terminationhas been requested, or if the execution is abruptly terminated from the outside (via an InterruptedException).
 */
public synchronized Token get(Branch branch){
  Token tmp=null;
  boolean blocked=false;
  try {
    if (_isPutWaiting()) {
      _setPutWaiting(false);
      tmp=_token;
      _setRendezvousComplete(false);
      notifyAll();
      while (!_isRendezvousComplete()) {
        _checkFlagsAndWait();
      }
    }
 else {
      _setGetWaiting(true);
      notifyAll();
      while (_isConditionalSendWaiting()) {
        _checkFlagsAndWait();
      }
      _checkFlags();
      markBlocked(branch);
      blocked=true;
      while (_isGetWaiting()) {
        _checkFlagsAndWait();
      }
      _checkFlags();
      markUnblocked();
      blocked=false;
      tmp=_token;
      _setRendezvousComplete(true);
      notifyAll();
    }
  }
 catch (  InterruptedException ex) {
    throw new TerminateProcessException(""String_Node_Str"");
  }
 finally {
    if (blocked) {
      markUnblocked();
    }
  }
  return tmp;
}"
75496,"/** 
 * The model has finished executing, so set a flag so that the next time an actor tries to get or put it gets a TerminateProcessException which will cause it to finish.
 */
public synchronized void requestFinish(){
  _modelFinished=true;
  _setConditionalReceive(false,null);
  _setConditionalSend(false,null);
  _setPutWaiting(false);
  _setGetWaiting(false);
  _setRendezvousComplete(false);
}","/** 
 * The model has finished executing, so set a flag so that the next time an actor tries to get or put it gets a TerminateProcessException which will cause it to finish.
 */
public synchronized void requestFinish(){
  _modelFinished=true;
  _setConditionalReceive(false,null,-1);
  _setConditionalSend(false,null,-1);
  _setPutWaiting(false);
  _setGetWaiting(false);
  _setRendezvousComplete(false);
}"
75497,"/** 
 * Set a flag so that a ConditionalSend branch knows whether or not a ConditionalReceive is ready to rendezvous with it.
 * @param v Boolean indicating whether or not a conditionalreceive is waiting to rendezvous.
 * @param p The CSPActor which contains the ConditionalReceivebranch that is trying to rendezvous. It is stored in the receiver so that if a ConditionalSend arrives, it can easily check whether the ConditionalReceive branch was the first branch of its conditional construct(CIF or CDO) to succeed.
 */
protected synchronized void _setConditionalReceive(boolean v,ConditionalBranchController p){
  _conditionalReceiveWaiting=v;
  _otherController=p;
}","/** 
 * Set a flag so that a ConditionalSend branch knows whether or not a ConditionalReceive is ready to rendezvous with it.
 * @param v Boolean indicating whether or not a conditionalreceive is waiting to rendezvous.
 * @param p The CSPActor which contains the ConditionalReceivebranch that is trying to rendezvous. It is stored in the receiver so that if a ConditionalSend arrives, it can easily check whether the ConditionalReceive branch was the first branch of its conditional construct(CIF or CDO) to succeed.
 * @param otherID The branch ID of the branch requesting theconditional receive.
 */
protected synchronized void _setConditionalReceive(boolean v,ConditionalBranchController p,int otherID){
  _conditionalReceiveWaiting=v;
  _otherController=p;
  _otherID=otherID;
}"
75498,"/** 
 * Set a flag so that a ConditionalReceive branch knows whether or not a ConditionalSend is ready to rendezvous with it.
 * @param v Boolean indicating whether or not a conditionalsend is waiting to rendezvous.
 * @param p The CSPActor which contains the ConditionalSendbranch that is trying to rendezvous. It is stored in the receiver so that if a ConditionalReceive arrives, it can easily check whether the ConditionalSend branch was the first branch of its conditional construct(CIF or CDO) to succeed.
 */
protected synchronized void _setConditionalSend(boolean v,ConditionalBranchController p){
  _conditionalSendWaiting=v;
  _otherController=p;
}","/** 
 * Set a flag so that a ConditionalReceive branch knows whether or not a ConditionalSend is ready to rendezvous with it.
 * @param v Boolean indicating whether or not a conditionalsend is waiting to rendezvous.
 * @param p The CSPActor which contains the ConditionalSendbranch that is trying to rendezvous. It is stored in the receiver so that if a ConditionalReceive arrives, it can easily check whether the ConditionalSend branch was the first branch of its conditional construct(CIF or CDO) to succeed.
 * @param otherID The branch ID of the branch requesting theconditional send.
 */
protected synchronized void _setConditionalSend(boolean v,ConditionalBranchController p,int otherID){
  _conditionalSendWaiting=v;
  _otherController=p;
  _otherID=otherID;
}"
75499,"public ConditionalBranch(boolean guard,IOPort port,int branchID,ConditionalBranchController cbc) throws IllegalActionException {
  _branchID=branchID;
  _guard=guard;
  _controller=cbc;
}","/** 
 * Create a guarded communication statement. This class contains all of the information necessary to carry out a guarded communication statement, with the exception of the type of communication. The receiver is set in the subclass as it is subject to communication specific tests. This constructor allows actors which do not implement the ConditionalBranchActor interface access to CSP functionality by passing their own ConditionalBranchController.
 * @param guard The guard for the guarded communication statementrepresented by this object.
 * @param port The IOPort that contains the channel totry an communicate through.
 * @param branchID The identification number assigned to this branchupon creation by the CSPActor.
 * @param cbc The ConditionalBranchController associated with this branch.
 * @exception IllegalActionException If the actor that containsthe port is not of type CSPActor.
 */
public ConditionalBranch(boolean guard,IOPort port,int branchID,ConditionalBranchController cbc) throws IllegalActionException {
  _branchID=branchID;
  _guard=guard;
  _controller=cbc;
}"
75500,"/** 
 * Set the CSPReceiver this branch is trying to rendezvous with. This method should only be called from derived classes.
 * @param receiver The CSPReceiver this branch is trying to rendezvouswith.
 */
void setReceiver(CSPReceiver rec){
  _receiver=rec;
}","/** 
 * Set the CSPReceiver this branch is trying to rendezvous with. This method should only be called from derived classes.
 * @param rec The CSPReceiver this branch is trying to rendezvouswith.
 */
void setReceiver(CSPReceiver rec){
  _receiver=rec;
}"
75501,"/** 
 * Create a guarded communication with a get() communication.
 * @param guard The guard for the guarded communication statementrepresented by this object.
 * @param port The IOPort containing the channel (and thus receiver)that this branch will try to rendezvous with.
 * @param channel The channel in the IOPort that this branch istrying to rendezvous with.
 * @param branch The identification number assigned to this branchupon creation by the CSPActor.
 * @exception IllegalActionException If the channel has morethan one receiver or if the receiver is not of type CSPReceiver.
 */
public ConditionalReceive(boolean guard,IOPort port,int channel,int branch,ConditionalBranchController cbc) throws IllegalActionException {
  super(guard,port,branch,cbc);
  _init(port,channel);
}","/** 
 * Create a guarded communication with a get() communication. This constructor allows actors which are not CSPActors access to CSP functionality by providing their own ConditionalBranchController.
 * @param guard The guard for the guarded communication statementrepresented by this object.
 * @param port The IOPort containing the channel (and thus receiver)that this branch will try to rendezvous with.
 * @param channel The channel in the IOPort that this branch istrying to rendezvous with.
 * @param branch The identification number assigned to this branchupon creation by the CSPActor.
 * @param cbc The ConditionalBranchController that this branch uses.
 * @exception IllegalActionException If the channel has morethan one receiver or if the receiver is not of type CSPReceiver.
 */
public ConditionalReceive(boolean guard,IOPort port,int channel,int branch,ConditionalBranchController cbc) throws IllegalActionException {
  super(guard,port,branch,cbc);
  _init(port,channel);
}"
75502,"/** 
 * The run method has roughly three parts: (1) where there is already a put waiting, (2) where there is a ConditionalSend waiting, and (3) where the ConditionalReceive is the first to arrive at the receiver. <P> The algorithm used in this method, together with some methods in ConditionalBranchController, control how conditional communication takes place in the CSP domain.
 */
public void run(){
  try {
    CSPReceiver receiver=getReceiver();
    ConditionalBranchController controller=getController();
synchronized (receiver) {
      if (receiver._isConditionalReceiveWaiting() || receiver._isGetWaiting()) {
        throw new InvalidStateException(((Nameable)controller.getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      while (true) {
        if (!isAlive()) {
          controller._branchFailed(getID());
          return;
        }
 else         if (receiver._isPutWaiting()) {
          _arriveAfterPut(receiver,controller);
          return;
        }
 else         if (receiver._isConditionalSendWaiting()) {
          if (!_arriveAfterConditionalSend(receiver,controller)) {
            return;
          }
        }
 else {
          _arriveFirst(receiver,controller);
          return;
        }
      }
    }
  }
 catch (  InterruptedException ex) {
    getController()._branchFailed(getID());
  }
catch (  TerminateProcessException ex) {
    getController()._branchFailed(getID());
  }
 finally {
    getReceiver()._setConditionalReceive(false,null);
  }
}","/** 
 * The run method has roughly three parts: (1) where there is already a put waiting, (2) where there is a ConditionalSend waiting, and (3) where the ConditionalReceive is the first to arrive at the receiver. <P> The algorithm used in this method, together with some methods in ConditionalBranchController, control how conditional communication takes place in the CSP domain.
 */
public void run(){
  try {
    CSPReceiver receiver=getReceiver();
    ConditionalBranchController controller=getController();
synchronized (receiver) {
      if (receiver._isConditionalReceiveWaiting() || receiver._isGetWaiting()) {
        throw new InvalidStateException(((Nameable)controller.getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      while (true) {
        if (!isAlive()) {
          controller._branchFailed(getID());
          return;
        }
 else         if (receiver._isPutWaiting()) {
          _arriveAfterPut(receiver,controller);
          return;
        }
 else         if (receiver._isConditionalSendWaiting()) {
          if (!_arriveAfterConditionalSend(receiver,controller)) {
            return;
          }
        }
 else {
          _arriveFirst(receiver,controller);
          return;
        }
      }
    }
  }
 catch (  InterruptedException ex) {
    getController()._branchFailed(getID());
  }
catch (  TerminateProcessException ex) {
    getController()._branchFailed(getID());
  }
 finally {
    getReceiver()._setConditionalReceive(false,null,-1);
  }
}"
75503,"/** 
 * Encounter a conditionalSend that is already waiting on this conditionalReceive. Since this conditionalReceive arrived second, check if both branches are ""first"" and if so perform the data transfer and reset the state of the receiver. Since a conditionalSend can ""disappear,"" then this method can return to the top of the main loop in the run method that calls this method. Return true if this method should go to the top of the calling loop; return false otherwise.
 * @return true if this method should continue at the beginning ofthe loop that calls this method; otherwise return false.
 * @param controller The conditional branch controller that control thisconditional receive.
 * @param receiver The CSPReceiver through which a rendezvous attempt istaking place.
 */
protected boolean _arriveAfterConditionalSend(CSPReceiver receiver,ConditionalBranchController controller) throws InterruptedException {
  if (controller._isBranchFirst(getID())) {
    if (receiver._getOtherController()._isBranchFirst(getID())) {
      setToken(receiver.get());
      receiver._setConditionalSend(false,null);
      controller._branchSucceeded(getID());
      return false;
    }
 else {
      controller._releaseFirst(getID());
      receiver.notifyAll();
    }
  }
  getController()._branchBlocked(this.getReceiver());
  getReceiver()._checkFlagsAndWait();
  getController()._branchUnblocked(this.getReceiver());
  return true;
}","/** 
 * Encounter a conditionalSend that is already waiting on this conditionalReceive. Since this conditionalReceive arrived second, check if both branches are ""first"" and if so perform the data transfer and reset the state of the receiver. Since a conditionalSend can ""disappear,"" then this method can return to the top of the main loop in the run method that calls this method. Return true if this method should go to the top of the calling loop; return false otherwise.
 * @return true if this method should continue at the beginning ofthe loop that calls this method; otherwise return false.
 * @param controller The conditional branch controller that control thisconditional receive.
 * @param receiver The CSPReceiver through which a rendezvous attempt istaking place.
 */
protected boolean _arriveAfterConditionalSend(CSPReceiver receiver,ConditionalBranchController controller) throws InterruptedException {
  System.out.println(Thread.currentThread().getName() + ""String_Node_Str"" + ""String_Node_Str""+ controller._isBranchFirst(getID())+ ""String_Node_Str""+ ""String_Node_Str""+ receiver._isPutWaiting()+ ""String_Node_Str""+ receiver._getOtherController()._isBranchFirst(receiver.getOtherID()));
  if (controller._isBranchFirst(getID())) {
    if (receiver._getOtherController()._isBranchFirst(receiver.getOtherID())) {
      setToken(receiver.get());
      receiver._setConditionalSend(false,null,-1);
      controller._branchSucceeded(getID());
      return false;
    }
 else {
      controller._releaseFirst(getID());
      receiver.notifyAll();
    }
  }
  getController()._branchBlocked(this.getReceiver());
  getReceiver()._checkFlagsAndWait();
  getController()._branchUnblocked(this.getReceiver());
  return true;
}"
75504,"/** 
 * Begin a rendezvous attempt prior to any other conditionalSends or (non-conditional) put attempts. Wait until a put or conditionalSend attempt is made by another branch.
 * @param controller The conditional branch controller that control thisconditional receive.
 * @param receiver The CSPReceiver through which a rendezvous attempt istaking place.
 */
protected void _arriveFirst(CSPReceiver receiver,ConditionalBranchController controller) throws InterruptedException {
  receiver._setConditionalReceive(true,controller);
  getController()._branchBlocked(this.getReceiver());
  getReceiver()._checkFlagsAndWait();
  getController()._branchUnblocked(this.getReceiver());
  while (true) {
    if (!isAlive()) {
      receiver._setConditionalReceive(false,null);
      controller._branchFailed(getID());
      receiver.notifyAll();
      return;
    }
 else     if (receiver._isPutWaiting()) {
      if (controller._isBranchFirst(getID())) {
        receiver._setConditionalReceive(false,null);
        setToken(receiver.get());
        controller._branchSucceeded(getID());
        return;
      }
    }
    getController()._branchBlocked(this.getReceiver());
    getReceiver()._checkFlagsAndWait();
    getController()._branchUnblocked(this.getReceiver());
  }
}","/** 
 * Begin a rendezvous attempt prior to any other conditionalSends or (non-conditional) put attempts. Wait until a put or conditionalSend attempt is made by another branch.
 * @param controller The conditional branch controller that control thisconditional receive.
 * @param receiver The CSPReceiver through which a rendezvous attempt istaking place.
 */
protected void _arriveFirst(CSPReceiver receiver,ConditionalBranchController controller) throws InterruptedException {
  receiver._setConditionalReceive(true,controller,getID());
  getController()._branchBlocked(this.getReceiver());
  getReceiver()._checkFlagsAndWait();
  getController()._branchUnblocked(this.getReceiver());
  while (true) {
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"" + ""String_Node_Str""+ isAlive()+ ""String_Node_Str""+ ""String_Node_Str""+ controller._isBranchFirst(getID())+ ""String_Node_Str""+ ""String_Node_Str""+ receiver._isPutWaiting());
    if (!isAlive()) {
      receiver._setConditionalReceive(false,null,-1);
      controller._branchFailed(getID());
      receiver.notifyAll();
      return;
    }
 else     if (controller._isBranchFirst(getID())) {
      if (receiver._isPutWaiting()) {
        receiver._setConditionalReceive(false,null,-1);
        setToken(receiver.get());
        controller._branchSucceeded(getID());
        return;
      }
 else {
        controller._releaseFirst(getID());
        receiver.notifyAll();
      }
    }
    getController()._branchBlocked(this.getReceiver());
    getReceiver()._checkFlagsAndWait();
    getController()._branchUnblocked(this.getReceiver());
  }
}"
75505,"/** 
 * Create a guarded communication with a send communication.
 * @param guard The guard for the guarded communication statementrepresented by this object.
 * @param port The IOPort containing the channel (and thus receiver)that this branch will try to rendezvous with.
 * @param channel The channel in the IOPort that this branch istrying to rendezvous with.
 * @param branchID The identification number assigned to this branchupon creation by the CSPActor.
 * @param token The token this branch is trying to send.
 * @exception IllegalActionException If the channel has morethan one receiver or if the receiver is not of type CSPReceiver.
 */
public ConditionalSend(boolean guard,IOPort port,int channel,int branchID,Token token,ConditionalBranchController cbc) throws IllegalActionException {
  super(guard,port,branchID,cbc);
  Receiver[][] receivers;
  try {
    port.workspace().getReadAccess();
    if (!port.isOutput()) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channel >= port.getWidth() || channel < 0) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    receivers=port.getRemoteReceivers();
    if (receivers == null || receivers[channel] == null) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channel].length != 1) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + channel + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (!(receivers[channel][0] instanceof CSPReceiver)) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + channel + ""String_Node_Str""+ ""String_Node_Str"");
    }
    setReceiver((CSPReceiver)receivers[channel][0]);
  }
  finally {
    port.workspace().doneReading();
  }
  setToken(token);
}","/** 
 * Create a guarded communication with a send communication. This constructor allows actors which are not CSPActors access to CSP functionality by providing their own ConditionalBranchController.
 * @param guard The guard for the guarded communication statementrepresented by this object.
 * @param port The IOPort containing the channel (and thus receiver)that this branch will try to rendezvous with.
 * @param channel The channel in the IOPort that this branch istrying to rendezvous with.
 * @param branchID The identification number assigned to this branchupon creation by the CSPActor.
 * @param token The token this branch is trying to send.
 * @param cbc The ConditionalBranchController that this branch uses.
 * @exception IllegalActionException If the channel has morethan one receiver or if the receiver is not of type CSPReceiver.
 */
public ConditionalSend(boolean guard,IOPort port,int channel,int branchID,Token token,ConditionalBranchController cbc) throws IllegalActionException {
  super(guard,port,branchID,cbc);
  Receiver[][] receivers;
  try {
    port.workspace().getReadAccess();
    if (!port.isOutput()) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (channel >= port.getWidth() || channel < 0) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    receivers=port.getRemoteReceivers();
    if (receivers == null || receivers[channel] == null) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (receivers[channel].length != 1) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + channel + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (!(receivers[channel][0] instanceof CSPReceiver)) {
      throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + channel + ""String_Node_Str""+ ""String_Node_Str"");
    }
    setReceiver((CSPReceiver)receivers[channel][0]);
  }
  finally {
    port.workspace().doneReading();
  }
  setToken(token);
}"
75506,"/** 
 * The run method has roughly three parts: (1) when there is already a get waiting, (2) when there is a ConditionalReceive waiting, and (3) where this ConditionalSend is the first to arrive at the receiver. <P> The algorithm used in this method, together with some methods in ConditionalBranchController, control how conditional communication takes place in the CSP domain.
 */
public void run(){
  try {
    CSPReceiver receiver=getReceiver();
    ConditionalBranchController controller=getController();
synchronized (receiver) {
      if (receiver._isConditionalSendWaiting() || receiver._isPutWaiting()) {
        throw new InvalidStateException(((Nameable)controller.getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      while (true) {
        if (!isAlive()) {
          controller._branchFailed(getID());
          return;
        }
 else         if (receiver._isGetWaiting()) {
          _arriveAfterGet(receiver,controller);
          return;
        }
 else         if (receiver._isConditionalReceiveWaiting()) {
          if (!_arriveAfterCondRec(receiver,controller)) {
            return;
          }
        }
 else {
          _arriveFirst(receiver,controller);
          return;
        }
      }
    }
  }
 catch (  InterruptedException ex) {
    getController()._branchFailed(getID());
  }
catch (  TerminateProcessException ex) {
    getController()._branchFailed(getID());
  }
 finally {
    setToken(null);
    getReceiver()._setConditionalSend(false,null);
  }
}","/** 
 * The run method has roughly three parts: (1) when there is already a get waiting, (2) when there is a ConditionalReceive waiting, and (3) where this ConditionalSend is the first to arrive at the receiver. <P> The algorithm used in this method, together with some methods in ConditionalBranchController, control how conditional communication takes place in the CSP domain.
 */
public void run(){
  try {
    CSPReceiver receiver=getReceiver();
    ConditionalBranchController controller=getController();
synchronized (receiver) {
      if (receiver._isConditionalSendWaiting() || receiver._isPutWaiting()) {
        throw new InvalidStateException(((Nameable)controller.getParent()).getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      while (true) {
        if (!isAlive()) {
          controller._branchFailed(getID());
          return;
        }
 else         if (receiver._isGetWaiting()) {
          _arriveAfterGet(receiver,controller);
          return;
        }
 else         if (receiver._isConditionalReceiveWaiting()) {
          if (!_arriveAfterCondRec(receiver,controller)) {
            return;
          }
        }
 else {
          _arriveFirst(receiver,controller);
          return;
        }
      }
    }
  }
 catch (  InterruptedException ex) {
    getController()._branchFailed(getID());
  }
catch (  TerminateProcessException ex) {
    getController()._branchFailed(getID());
  }
 finally {
    setToken(null);
    getReceiver()._setConditionalSend(false,null,-1);
  }
}"
75507,"/** 
 * @param controller The conditional branch controller that controlsthis conditional receive.
 * @param receiver The CSPReceiver through which a rendezvous attempt istaking place.
 */
protected void _arriveFirst(CSPReceiver receiver,ConditionalBranchController controller) throws InterruptedException {
  receiver._setConditionalSend(true,controller);
  getController()._branchBlocked(this.getReceiver());
  getReceiver()._checkFlagsAndWait();
  getController()._branchUnblocked(this.getReceiver());
  while (true) {
    if (!isAlive()) {
      receiver._setConditionalSend(false,null);
      controller._branchFailed(getID());
      receiver.notifyAll();
      return;
    }
 else     if (receiver._isGetWaiting()) {
      if (controller._isBranchFirst(getID())) {
        receiver._setConditionalSend(false,null);
        receiver.put(getToken());
        controller._branchSucceeded(getID());
        return;
      }
    }
    getController()._branchBlocked(this.getReceiver());
    getReceiver()._checkFlagsAndWait();
    getController()._branchUnblocked(this.getReceiver());
  }
}","/** 
 * @param controller The conditional branch controller that controlsthis conditional receive.
 * @param receiver The CSPReceiver through which a rendezvous attempt istaking place.
 */
protected void _arriveFirst(CSPReceiver receiver,ConditionalBranchController controller) throws InterruptedException {
  receiver._setConditionalSend(true,controller,getID());
  getController()._branchBlocked(this.getReceiver());
  getReceiver()._checkFlagsAndWait();
  getController()._branchUnblocked(this.getReceiver());
  while (true) {
    System.out.println(Thread.currentThread().getName() + ""String_Node_Str"" + ""String_Node_Str""+ isAlive()+ ""String_Node_Str""+ ""String_Node_Str""+ controller._isBranchFirst(getID())+ ""String_Node_Str""+ ""String_Node_Str""+ receiver._isGetWaiting());
    if (!isAlive()) {
      receiver._setConditionalSend(false,null,-1);
      controller._branchFailed(getID());
      receiver.notifyAll();
      return;
    }
 else     if (controller._isBranchFirst(getID())) {
      if (receiver._isGetWaiting()) {
        receiver._setConditionalSend(false,null,-1);
        receiver.put(getToken());
        controller._branchSucceeded(getID());
        return;
      }
 else {
        controller._releaseFirst(getID());
        receiver.notifyAll();
      }
    }
    getController()._branchBlocked(this.getReceiver());
    getReceiver()._checkFlagsAndWait();
    getController()._branchUnblocked(this.getReceiver());
  }
}"
75508,"/** 
 * @param controller The conditional branch controller that controlsthis conditional receive.
 * @param receiver The CSPReceiver through which a rendezvous attempt istaking place.
 */
protected boolean _arriveAfterCondRec(CSPReceiver receiver,ConditionalBranchController controller) throws InterruptedException {
  if (controller._isBranchFirst(getID())) {
    ConditionalBranchController side2=receiver._getOtherController();
    if (side2._isBranchFirst(getID())) {
      receiver.put(getToken());
      receiver._setConditionalReceive(false,null);
      controller._branchSucceeded(getID());
      return false;
    }
 else {
      controller._releaseFirst(getID());
      receiver.notifyAll();
    }
  }
  getController()._branchBlocked(this.getReceiver());
  getReceiver()._checkFlagsAndWait();
  getController()._branchUnblocked(this.getReceiver());
  return true;
}","/** 
 * @param controller The conditional branch controller that controlsthis conditional receive.
 * @param receiver The CSPReceiver through which a rendezvous attempt istaking place.
 */
protected boolean _arriveAfterCondRec(CSPReceiver receiver,ConditionalBranchController controller) throws InterruptedException {
  System.out.println(Thread.currentThread().getName() + ""String_Node_Str"" + ""String_Node_Str""+ controller._isBranchFirst(getID())+ ""String_Node_Str""+ ""String_Node_Str""+ receiver._isGetWaiting()+ ""String_Node_Str""+ receiver._getOtherController()._isBranchFirst(receiver.getOtherID()));
  if (controller._isBranchFirst(getID())) {
    ConditionalBranchController side2=receiver._getOtherController();
    if (side2._isBranchFirst(receiver.getOtherID())) {
      receiver.put(getToken());
      receiver._setConditionalReceive(false,null,-1);
      controller._branchSucceeded(getID());
      return false;
    }
 else {
      controller._releaseFirst(getID());
      receiver.notifyAll();
    }
  }
  getController()._branchBlocked(this.getReceiver());
  getReceiver()._checkFlagsAndWait();
  getController()._branchUnblocked(this.getReceiver());
  return true;
}"
75509,"/** 
 * Evaluate the specified command.
 * @param command The command.
 * @return The return value of the command, or null if there is none.
 * @exception Exception If something goes wrong processing the command.
 */
public String evaluateCommand(String command) throws Exception {
  PtParser parser=new PtParser();
  ASTPtRootNode node=parser.generateSimpleAssignmentParseTree(command);
  String targetName=null;
  if (node instanceof ASTPtAssignmentNode) {
    ASTPtAssignmentNode assignmentNode=(ASTPtAssignmentNode)node;
    targetName=assignmentNode.getIdentifier();
    node=assignmentNode.getExpressionTree();
  }
  final NamedObj model=((ExpressionShellEffigy)getContainer()).getModel();
  ParserScope scope=new ModelScope(){
    public ptolemy.data.Token get(    String name) throws IllegalActionException {
      Variable result=getScopedVariable(null,model,name);
      if (result != null) {
        return result.getToken();
      }
 else {
        return null;
      }
    }
    public ptolemy.data.type.Type getType(    String name) throws IllegalActionException {
      Variable result=getScopedVariable(null,model,name);
      if (result != null) {
        return result.getType();
      }
 else {
        return null;
      }
    }
    public Set identifierSet(){
      return getAllScopedVariableNames(null,model);
    }
  }
;
  Token result=_evaluator.evaluateParseTree(node,scope);
  if (targetName != null) {
    Attribute attribute=model.getAttribute(targetName);
    if (attribute != null && !(attribute instanceof Parameter)) {
      attribute.setContainer(null);
      attribute=null;
    }
    if (attribute == null) {
      attribute=new Parameter(model,targetName);
    }
    ((Parameter)attribute).setToken(result);
  }
  if (result == null) {
    return ""String_Node_Str"";
  }
 else {
    return result.toString();
  }
}","/** 
 * Evaluate the specified command.
 * @param command The command.
 * @return The return value of the command, or null if there is none.
 * @exception Exception If something goes wrong processing the command.
 */
public String evaluateCommand(String command) throws Exception {
  if (command.trim().equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  PtParser parser=new PtParser();
  ASTPtRootNode node=parser.generateSimpleAssignmentParseTree(command);
  String targetName=null;
  if (node instanceof ASTPtAssignmentNode) {
    ASTPtAssignmentNode assignmentNode=(ASTPtAssignmentNode)node;
    targetName=assignmentNode.getIdentifier();
    node=assignmentNode.getExpressionTree();
  }
  final NamedObj model=((ExpressionShellEffigy)getContainer()).getModel();
  ParserScope scope=new ModelScope(){
    public ptolemy.data.Token get(    String name) throws IllegalActionException {
      Variable result=getScopedVariable(null,model,name);
      if (result != null) {
        return result.getToken();
      }
 else {
        return null;
      }
    }
    public ptolemy.data.type.Type getType(    String name) throws IllegalActionException {
      Variable result=getScopedVariable(null,model,name);
      if (result != null) {
        return result.getType();
      }
 else {
        return null;
      }
    }
    public Set identifierSet(){
      return getAllScopedVariableNames(null,model);
    }
  }
;
  Token result=_evaluator.evaluateParseTree(node,scope);
  if (targetName != null) {
    Attribute attribute=model.getAttribute(targetName);
    if (attribute != null && !(attribute instanceof Parameter)) {
      attribute.setContainer(null);
      attribute=null;
    }
    if (attribute == null) {
      attribute=new Parameter(model,targetName);
    }
    ((Parameter)attribute).setToken(result);
  }
  if (result == null) {
    return ""String_Node_Str"";
  }
 else {
    return result.toString();
  }
}"
75510,"/** 
 * Evaluate the specified command. If this method returns null, then the associated ShellTextArea will not display a prompt until returnResult() is called.
 * @see ShellTextArea#returnResult(String)
 * @param command The command.
 * @return The return value of the command, or null if there is none.
 * @exception Exception If something goes wrong processing the command.
 */
public String evaluateCommand(String command) throws Exception ;","/** 
 * Evaluate the specified command. If this method returns null, then the associated ShellTextArea will not display a prompt until returnResult() is called. If this method returns an empty string, then the associated ShellTextArea will display the prompt.
 * @see ShellTextArea#returnResult(String)
 * @param command The command.
 * @return The return value of the command, or null if there is none.
 * @exception Exception If something goes wrong processing the command.
 */
public String evaluateCommand(String command) throws Exception ;"
75511,"private void _evalCommand(){
  String newtext=_jTextArea.getText().substring(_promptCursor);
  _promptCursor+=newtext.length();
  if (_commandBuffer.length() > 0) {
    _commandBuffer.append(""String_Node_Str"");
  }
  _commandBuffer.append(newtext);
  String command=_commandBuffer.toString();
  if (_interpreter == null) {
    appendJTextArea(""String_Node_Str"" + mainPrompt);
  }
 else {
    if (_interpreter.isCommandComplete(command)) {
      appendJTextArea(""String_Node_Str"");
      Cursor oldCursor=_jTextArea.getCursor();
      _jTextArea.setCursor(new Cursor(Cursor.WAIT_CURSOR));
      String result;
      try {
        result=_interpreter.evaluateCommand(command);
      }
 catch (      RuntimeException e) {
        MessageHandler.error(""String_Node_Str"",e);
        result=""String_Node_Str"";
        throw e;
      }
catch (      Exception e) {
        result=e.getMessage();
      }
      if (result != null) {
        appendJTextArea(result + ""String_Node_Str"" + mainPrompt);
      }
 else {
        setEditable(false);
      }
      _commandBuffer.setLength(0);
      _jTextArea.setCursor(oldCursor);
      _updateHistory(command);
    }
 else {
      appendJTextArea(""String_Node_Str"" + contPrompt);
    }
  }
}","private void _evalCommand(){
  String newtext=_jTextArea.getText().substring(_promptCursor);
  _promptCursor+=newtext.length();
  if (_commandBuffer.length() > 0) {
    _commandBuffer.append(""String_Node_Str"");
  }
  _commandBuffer.append(newtext);
  String command=_commandBuffer.toString();
  if (_interpreter == null) {
    appendJTextArea(""String_Node_Str"" + mainPrompt);
  }
 else {
    if (_interpreter.isCommandComplete(command)) {
      appendJTextArea(""String_Node_Str"");
      Cursor oldCursor=_jTextArea.getCursor();
      _jTextArea.setCursor(new Cursor(Cursor.WAIT_CURSOR));
      String result;
      try {
        result=_interpreter.evaluateCommand(command);
      }
 catch (      RuntimeException e) {
        MessageHandler.error(""String_Node_Str"",e);
        result=""String_Node_Str"";
        throw e;
      }
catch (      Exception e) {
        result=e.getMessage();
      }
      if (result != null) {
        if (result.trim().equals(""String_Node_Str"")) {
          appendJTextArea(mainPrompt);
        }
 else {
          appendJTextArea(result + ""String_Node_Str"" + mainPrompt);
        }
      }
 else {
        setEditable(false);
      }
      _commandBuffer.setLength(0);
      _jTextArea.setCursor(oldCursor);
      _updateHistory(command);
    }
 else {
      appendJTextArea(""String_Node_Str"" + contPrompt);
    }
  }
}"
75512,"private void _analyzeAllVariables(Entity model) throws IllegalActionException {
  Set notTestedSet=new HashSet();
  Set testedSet=new HashSet();
  Set notConstants=new HashSet();
  List variableList=model.attributeList(Variable.class);
  notTestedSet.addAll(variableList);
  PtParser parser=new PtParser();
  ParseTreeFreeVariableCollector collector=new ParseTreeFreeVariableCollector();
  boolean doneSomething=true;
  while (doneSomething) {
    doneSomething=false;
    while (!notTestedSet.isEmpty()) {
      Variable variable=(Variable)notTestedSet.iterator().next();
      notTestedSet.remove(variable);
      boolean isNotConstant=false;
      if (_notConstantVariableSet.contains(variable)) {
        isNotConstant=true;
      }
 else {
        String expression=variable.getExpression();
        try {
          ASTPtRootNode root=parser.generateParseTree(expression);
          Set freeVarNames=new HashSet(collector.collectFreeVariables(root));
          for (Iterator names=freeVarNames.iterator(); names.hasNext() && !isNotConstant; ) {
            String name=(String)names.next();
            Variable scopeVariable=ModelScope.getScopedVariable(variable,variable,name);
            if (scopeVariable == null || _notConstantVariableSet.contains(scopeVariable)) {
              isNotConstant=true;
            }
          }
        }
 catch (        IllegalActionException ex) {
          isNotConstant=true;
        }
      }
      if (isNotConstant) {
        notConstants.add(variable.getName());
        _notConstantVariableSet.add(variable);
        doneSomething=true;
        isNotConstant=true;
      }
 else {
        testedSet.add(variable);
      }
    }
    notTestedSet.addAll(testedSet);
    testedSet.clear();
  }
  _entityToNotConstVariableSet.put(model,notConstants);
  Set constants=new HashSet();
  for (Iterator variables=variableList.iterator(); variables.hasNext(); ) {
    constants.add(((Variable)variables.next()).getName());
    constants.removeAll(notConstants);
  }
  _entityToConstVariableSet.put(model,constants);
  if (model instanceof CompositeEntity) {
    for (Iterator entities=((CompositeEntity)model).entityList().iterator(); entities.hasNext(); ) {
      Entity entity=(Entity)entities.next();
      _analyzeAllVariables(entity);
    }
  }
}","private void _analyzeAllVariables(Entity model) throws IllegalActionException {
  Set notTestedSet=new HashSet();
  Set testedSet=new HashSet();
  Set notConstants=new HashSet();
  List variableList=model.attributeList(Variable.class);
  notTestedSet.addAll(variableList);
  PtParser parser=new PtParser();
  ParseTreeFreeVariableCollector collector=new ParseTreeFreeVariableCollector();
  boolean doneSomething=true;
  while (doneSomething) {
    doneSomething=false;
    while (!notTestedSet.isEmpty()) {
      Variable variable=(Variable)notTestedSet.iterator().next();
      notTestedSet.remove(variable);
      boolean isNotConstant=false;
      if (_notConstantVariableSet.contains(variable)) {
        isNotConstant=true;
      }
 else {
        String expression=variable.getExpression();
        try {
          ASTPtRootNode root=parser.generateParseTree(expression);
          Set freeVarNames=new HashSet(collector.collectFreeVariables(root));
          for (Iterator names=freeVarNames.iterator(); names.hasNext() && !isNotConstant; ) {
            String name=(String)names.next();
            Variable scopeVariable=ModelScope.getScopedVariable(variable,variable,name);
            if (scopeVariable != null && _notConstantVariableSet.contains(scopeVariable)) {
              isNotConstant=true;
            }
          }
        }
 catch (        IllegalActionException ex) {
          isNotConstant=true;
        }
      }
      if (isNotConstant) {
        notConstants.add(variable.getName());
        _notConstantVariableSet.add(variable);
        doneSomething=true;
        isNotConstant=true;
      }
 else {
        testedSet.add(variable);
      }
    }
    notTestedSet.addAll(testedSet);
    testedSet.clear();
  }
  _entityToNotConstVariableSet.put(model,notConstants);
  Set constants=new HashSet();
  for (Iterator variables=variableList.iterator(); variables.hasNext(); ) {
    constants.add(((Variable)variables.next()).getName());
    constants.removeAll(notConstants);
  }
  _entityToConstVariableSet.put(model,constants);
  if (model instanceof CompositeEntity) {
    for (Iterator entities=((CompositeEntity)model).entityList().iterator(); entities.hasNext(); ) {
      Entity entity=(Entity)entities.next();
      _analyzeAllVariables(entity);
    }
  }
}"
75513,"public ptolemy.data.type.Type getType(String name) throws IllegalActionException {
  if (name.equals(""String_Node_Str"")) {
    return BaseType.DOUBLE;
  }
 else   if (name.equals(""String_Node_Str"")) {
    return BaseType.INT;
  }
  if (_nameToType.containsKey(name)) {
    return (ptolemy.data.type.Type)_nameToType.get(name);
  }
  Variable result=getScopedVariable(null,_entity,name);
  if (result != null) {
    return result.getType();
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
}","public ptolemy.data.type.Type getType(String name) throws IllegalActionException {
  if (name.equals(""String_Node_Str"")) {
    return BaseType.DOUBLE;
  }
 else   if (name.equals(""String_Node_Str"")) {
    return BaseType.INT;
  }
  if (_nameToType.containsKey(name)) {
    return (ptolemy.data.type.Type)_nameToType.get(name);
  }
  Variable result=getScopedVariable(null,_entity,name);
  if (result != null) {
    return result.getType();
  }
 else {
    return null;
  }
}"
75514,"/** 
 * Add to the scene a standard set of transformations that are useful for optimizing efficiency.
 * @param toplevel The composite actor we are generating code for.
 */
public static void addStandardTransforms(CompositeActor toplevel){
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",WatchDogTimer.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ModelTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlineDirectorTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",CommandLineTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ClassWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",FieldsForEntitiesTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",FieldsForAttributesTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",FieldsForPortsTransformer.v(toplevel)));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InvocationBinder.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlineParameterTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlineTokenTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TokenInstanceofEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(CopyPropagator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ClassWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlinePortTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",FieldsForAttributesTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlineTokenTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ClassWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InvocationBinder.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",NamedObjEqualityEliminator.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(CastAndInstanceofEliminator.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",UnreachableMethodRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ExceptionEliminator.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(CastAndInstanceofEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InvocationBinder.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",NamedObjEliminator.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",UnreachableMethodRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(DeadObjectEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(ImprovedDeadAssignmentEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(DeadObjectEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(ImprovedDeadAssignmentEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(DeadObjectEliminator.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ClassWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",TokenToNativeTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",UnusedFieldRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",SideEffectFreeInvocationRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ExceptionEliminator.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(DeadObjectEliminator.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",SideEffectFreeInvocationRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",LibraryUsageReporter.v()));
}","/** 
 * Add to the scene a standard set of transformations that are useful for optimizing efficiency.
 * @param toplevel The composite actor we are generating code for.
 */
public static void addStandardTransforms(CompositeActor toplevel){
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",WatchDogTimer.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ModelTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlineDirectorTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",CommandLineTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ClassWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",FieldsForEntitiesTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",FieldsForAttributesTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",FieldsForPortsTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalNameStandardizer.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InvocationBinder.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlineParameterTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlineTokenTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TokenInstanceofEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(CopyPropagator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ClassWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlinePortTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",FieldsForAttributesTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InlineTokenTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ClassWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InvocationBinder.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",NamedObjEqualityEliminator.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(CastAndInstanceofEliminator.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",UnreachableMethodRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ExceptionEliminator.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(LocalSplitter.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(CastAndInstanceofEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(TypeAssigner.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",InvocationBinder.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",NamedObjEliminator.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",UnreachableMethodRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(DeadObjectEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(ImprovedDeadAssignmentEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(DeadObjectEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(ImprovedDeadAssignmentEliminator.v())));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(DeadObjectEliminator.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ClassWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",TokenToNativeTransformer.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",UnusedFieldRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",SideEffectFreeInvocationRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",ExceptionEliminator.v(toplevel)));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",new TransformerAdapter(DeadObjectEliminator.v())));
  _addStandardOptimizations(Scene.v().getPack(""String_Node_Str""));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",SideEffectFreeInvocationRemover.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",JimpleWriter.v()));
  Scene.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",LibraryUsageReporter.v()));
}"
75515,"public boolean _inlineTokenMethodsIn(SootMethod method,JimpleBody body,Unit unit,ValueBox box,SimpleLocalDefs localDefs,SimpleLocalUses localUses,TypeSpecializerAnalysis typeAnalysis,int depth,Set unsafeLocalSet,boolean debug){
  Hierarchy hierarchy=Scene.v().getActiveHierarchy();
  boolean doneSomething=false;
  Value value=box.getValue();
  if (value instanceof InvokeExpr) {
    InvokeExpr r=(InvokeExpr)value;
    if (unit instanceof AssignStmt && r.getMethod().getName().equals(""String_Node_Str"")) {
      AssignStmt stmt=(AssignStmt)unit;
      unsafeLocalSet.add(stmt.getLeftOp());
      unsafeLocalSet.addAll(_computeTokenLocalsDefinedFrom(localUses,stmt));
      if (debug)       System.out.println(""String_Node_Str"" + unsafeLocalSet);
    }
  }
  if (value instanceof VirtualInvokeExpr || value instanceof InterfaceInvokeExpr || value instanceof SpecialInvokeExpr) {
    InstanceInvokeExpr r=(InstanceInvokeExpr)value;
    Local local=(Local)r.getBase();
    Type baseType=local.getType();
    if (baseType instanceof NullType) {
      if (debug) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
      Local exception=SootUtilities.createRuntimeException(body,unit,""String_Node_Str"");
      body.getUnits().insertBefore(Jimple.v().newThrowStmt(exception),unit);
      body.getUnits().remove(unit);
    }
    boolean isInlineableTokenMethod=false;
    isInlineableTokenMethod=_isInlineableTokenType(local,typeAnalysis,unsafeLocalSet,depth,debug);
    if (baseType instanceof RefType && Scene.v().getApplicationClasses().contains(((RefType)baseType).getSootClass())) {
      for (Iterator args=r.getArgs().iterator(); args.hasNext() && !isInlineableTokenMethod; ) {
        Object arg=args.next();
        if (arg instanceof Local) {
          Local argLocal=(Local)arg;
          if (debug)           System.out.println(""String_Node_Str"" + argLocal.getType());
          isInlineableTokenMethod=_isInlineableTokenType(argLocal,typeAnalysis,unsafeLocalSet,depth,debug);
          if (debug) {
            System.out.println(""String_Node_Str"" + isInlineableTokenMethod);
          }
        }
      }
    }
    if (!isInlineableTokenMethod) {
      return false;
    }
    RefType type=(RefType)typeAnalysis.getSpecializedSootType(local);
    List methodList;
    if (value instanceof SpecialInvokeExpr) {
      SootMethod invokedMethod=hierarchy.resolveSpecialDispatch((SpecialInvokeExpr)r,method);
      methodList=new LinkedList();
      methodList.add(invokedMethod);
    }
 else {
      methodList=hierarchy.resolveAbstractDispatch(type.getSootClass(),r.getMethod());
    }
    if (methodList.size() == 1) {
      SootMethod inlinee=(SootMethod)methodList.get(0);
      if (inlinee.getName().equals(""String_Node_Str"")) {
        SootMethod newGetClassMethod=Scene.v().getMethod(""String_Node_Str"" + ""String_Node_Str"");
        box.setValue(Jimple.v().newStaticInvokeExpr(newGetClassMethod,StringConstant.v(""String_Node_Str"")));
      }
 else {
        SootClass declaringClass=inlinee.getDeclaringClass();
        declaringClass.setLibraryClass();
        if (!inlinee.isAbstract() && !inlinee.isNative()) {
          if (debug)           System.out.println(""String_Node_Str"" + inlinee);
          inlinee.retrieveActiveBody();
          SiteInliner.inlineSite(inlinee,(Stmt)unit,method);
          doneSomething=true;
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + inlinee);
        }
      }
    }
 else {
      if (debug) {
        System.out.println(""String_Node_Str"" + r);
        for (Iterator j=methodList.iterator(); j.hasNext(); ) {
          System.out.println(""String_Node_Str"" + j.next());
        }
      }
    }
  }
 else   if (value instanceof SpecialInvokeExpr) {
    SpecialInvokeExpr r=(SpecialInvokeExpr)value;
    if (debug)     System.out.println(""String_Node_Str"" + r.getMethod());
    Type baseType=typeAnalysis.getSpecializedSootType((Local)r.getBase());
    if (baseType instanceof RefType) {
      RefType type=(RefType)baseType;
      boolean isInlineableTokenMethod=SootUtilities.derivesFrom(type.getSootClass(),PtolemyUtilities.tokenClass);
      if (isInlineableTokenMethod) {
        type=(RefType)typeAnalysis.getSpecializedSootType((Local)r.getBase());
        if (PtolemyUtilities.getTypeDepth(typeAnalysis.getSpecializedType((Local)r.getBase())) != depth) {
          if (debug)           System.out.println(""String_Node_Str"" + PtolemyUtilities.getTypeDepth(typeAnalysis.getSpecializedType((Local)r.getBase())) + ""String_Node_Str""+ depth);
          return false;
        }
      }
      if (isInlineableTokenMethod) {
        SootMethod inlinee=hierarchy.resolveSpecialDispatch(r,method);
        SootClass declaringClass=inlinee.getDeclaringClass();
        declaringClass.setLibraryClass();
        if (!inlinee.isAbstract() && !inlinee.isNative()) {
          if (debug)           System.out.println(""String_Node_Str"");
          inlinee.retrieveActiveBody();
          SiteInliner.inlineSite(inlinee,(Stmt)unit,method);
          doneSomething=true;
        }
 else {
          if (debug)           System.out.println(""String_Node_Str"");
          body.getUnits().remove(unit);
        }
      }
    }
  }
 else   if (value instanceof StaticInvokeExpr) {
    StaticInvokeExpr r=(StaticInvokeExpr)value;
    if (r.getMethod().getDeclaringClass().equals(PtolemyUtilities.typeLatticeClass)) {
      try {
        if (debug) {
          System.out.println(""String_Node_Str"" + unit);
        }
        typeAnalysis.inlineTypeLatticeMethods(method,unit,box,r,localDefs,localUses);
      }
 catch (      Exception ex) {
        System.out.println(""String_Node_Str"" + ex.getMessage());
      }
    }
 else {
      if (debug) {
        System.out.println(""String_Node_Str"" + r.getMethod());
      }
      SootMethod inlinee=(SootMethod)r.getMethod();
      SootClass declaringClass=inlinee.getDeclaringClass();
      if (_mangleExceptionMessages && (inlinee.getName().equals(""String_Node_Str"") || inlinee.getName().equals(""String_Node_Str"") || inlinee.getName().equals(""String_Node_Str"")|| inlinee.getName().equals(""String_Node_Str""))) {
        box.setValue(StringConstant.v(""String_Node_Str""));
      }
 else       if (SootUtilities.derivesFrom(declaringClass,PtolemyUtilities.tokenClass)) {
        declaringClass.setLibraryClass();
        if (!inlinee.isAbstract() && !inlinee.isNative()) {
          if (debug)           System.out.println(""String_Node_Str"");
          inlinee.retrieveActiveBody();
          SiteInliner.inlineSite(inlinee,(Stmt)unit,method);
          doneSomething=true;
        }
      }
    }
  }
  return doneSomething;
}","public boolean _inlineTokenMethodsIn(SootMethod method,JimpleBody body,Unit unit,ValueBox box,SimpleLocalDefs localDefs,SimpleLocalUses localUses,TypeSpecializerAnalysis typeAnalysis,int depth,Set unsafeLocalSet,boolean debug){
  Hierarchy hierarchy=Scene.v().getActiveHierarchy();
  boolean doneSomething=false;
  Value value=box.getValue();
  if (value instanceof InvokeExpr) {
    InvokeExpr r=(InvokeExpr)value;
    if (unit instanceof AssignStmt && r.getMethod().getName().equals(""String_Node_Str"")) {
      AssignStmt stmt=(AssignStmt)unit;
      unsafeLocalSet.add(stmt.getLeftOp());
      unsafeLocalSet.addAll(_computeTokenLocalsDefinedFrom(localUses,stmt));
      if (debug)       System.out.println(""String_Node_Str"" + unsafeLocalSet);
    }
  }
  if (value instanceof VirtualInvokeExpr || value instanceof InterfaceInvokeExpr || value instanceof SpecialInvokeExpr) {
    InstanceInvokeExpr r=(InstanceInvokeExpr)value;
    Local local=(Local)r.getBase();
    Type baseType=local.getType();
    if (baseType instanceof NullType) {
      if (debug) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
      Local exception=SootUtilities.createRuntimeException(body,unit,""String_Node_Str"");
      body.getUnits().insertBefore(Jimple.v().newThrowStmt(exception),unit);
      body.getUnits().remove(unit);
    }
    boolean isInlineableTokenMethod=false;
    isInlineableTokenMethod=_isInlineableTokenType(local,typeAnalysis,unsafeLocalSet,depth,debug);
    if (baseType instanceof RefType && Scene.v().getApplicationClasses().contains(((RefType)baseType).getSootClass())) {
      for (Iterator args=r.getArgs().iterator(); args.hasNext() && !isInlineableTokenMethod; ) {
        Object arg=args.next();
        if (arg instanceof Local) {
          Local argLocal=(Local)arg;
          if (debug)           System.out.println(""String_Node_Str"" + argLocal.getType());
          isInlineableTokenMethod=_isInlineableTokenType(argLocal,typeAnalysis,unsafeLocalSet,depth,debug);
          if (debug) {
            System.out.println(""String_Node_Str"" + isInlineableTokenMethod);
          }
        }
      }
    }
    if (!isInlineableTokenMethod) {
      return false;
    }
    RefType type=(RefType)typeAnalysis.getSpecializedSootType(local);
    List methodList;
    if (value instanceof SpecialInvokeExpr) {
      SootMethod targetMethod=hierarchy.resolveSpecialDispatch((SpecialInvokeExpr)r,method);
      methodList=new LinkedList();
      methodList.add(targetMethod);
    }
 else {
      methodList=hierarchy.resolveAbstractDispatch(type.getSootClass(),r.getMethod());
    }
    if (methodList.size() == 1) {
      SootMethod inlinee=(SootMethod)methodList.get(0);
      if (inlinee.getName().equals(""String_Node_Str"")) {
        SootMethod newGetClassMethod=Scene.v().getMethod(""String_Node_Str"" + ""String_Node_Str"");
        box.setValue(Jimple.v().newStaticInvokeExpr(newGetClassMethod,StringConstant.v(""String_Node_Str"")));
      }
 else {
        SootClass declaringClass=inlinee.getDeclaringClass();
        declaringClass.setLibraryClass();
        if (!inlinee.isAbstract() && !inlinee.isNative()) {
          if (debug)           System.out.println(""String_Node_Str"" + inlinee);
          inlinee.retrieveActiveBody();
          SiteInliner.inlineSite(inlinee,(Stmt)unit,method);
          doneSomething=true;
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + inlinee);
        }
      }
    }
 else {
      if (debug) {
        System.out.println(""String_Node_Str"" + r);
        for (Iterator j=methodList.iterator(); j.hasNext(); ) {
          System.out.println(""String_Node_Str"" + j.next());
        }
      }
    }
  }
 else   if (value instanceof SpecialInvokeExpr) {
    SpecialInvokeExpr r=(SpecialInvokeExpr)value;
    if (debug)     System.out.println(""String_Node_Str"" + r.getMethod());
    Type baseType=typeAnalysis.getSpecializedSootType((Local)r.getBase());
    if (baseType instanceof RefType) {
      RefType type=(RefType)baseType;
      boolean isInlineableTokenMethod=SootUtilities.derivesFrom(type.getSootClass(),PtolemyUtilities.tokenClass);
      if (isInlineableTokenMethod) {
        type=(RefType)typeAnalysis.getSpecializedSootType((Local)r.getBase());
        if (PtolemyUtilities.getTypeDepth(typeAnalysis.getSpecializedType((Local)r.getBase())) != depth) {
          if (debug)           System.out.println(""String_Node_Str"" + PtolemyUtilities.getTypeDepth(typeAnalysis.getSpecializedType((Local)r.getBase())) + ""String_Node_Str""+ depth);
          return false;
        }
      }
      if (isInlineableTokenMethod) {
        SootMethod inlinee=hierarchy.resolveSpecialDispatch(r,method);
        SootClass declaringClass=inlinee.getDeclaringClass();
        declaringClass.setLibraryClass();
        if (!inlinee.isAbstract() && !inlinee.isNative()) {
          if (debug)           System.out.println(""String_Node_Str"");
          inlinee.retrieveActiveBody();
          SiteInliner.inlineSite(inlinee,(Stmt)unit,method);
          doneSomething=true;
        }
 else {
          if (debug)           System.out.println(""String_Node_Str"");
          body.getUnits().remove(unit);
        }
      }
    }
  }
 else   if (value instanceof StaticInvokeExpr) {
    StaticInvokeExpr r=(StaticInvokeExpr)value;
    if (r.getMethod().getDeclaringClass().equals(PtolemyUtilities.typeLatticeClass)) {
      try {
        if (debug) {
          System.out.println(""String_Node_Str"" + unit);
        }
        typeAnalysis.inlineTypeLatticeMethods(method,unit,box,r,localDefs,localUses);
      }
 catch (      Exception ex) {
        System.out.println(""String_Node_Str"" + ex.getMessage());
      }
    }
 else {
      if (debug) {
        System.out.println(""String_Node_Str"" + r.getMethod());
      }
      SootMethod inlinee=(SootMethod)r.getMethod();
      SootClass declaringClass=inlinee.getDeclaringClass();
      Type returnType=inlinee.getReturnType();
      if (_mangleExceptionMessages && (inlinee.getName().equals(""String_Node_Str"") || inlinee.getName().equals(""String_Node_Str"") || inlinee.getName().equals(""String_Node_Str"")|| inlinee.getName().equals(""String_Node_Str""))) {
        box.setValue(StringConstant.v(""String_Node_Str""));
      }
 else       if (SootUtilities.derivesFrom(declaringClass,PtolemyUtilities.tokenClass) || ((returnType instanceof RefType) && SootUtilities.derivesFrom(((RefType)returnType).getSootClass(),PtolemyUtilities.tokenClass))) {
        declaringClass.setLibraryClass();
        if (!inlinee.isAbstract() && !inlinee.isNative()) {
          if (debug)           System.out.println(""String_Node_Str"");
          inlinee.retrieveActiveBody();
          SiteInliner.inlineSite(inlinee,(Stmt)unit,method);
          doneSomething=true;
        }
      }
    }
  }
  return doneSomething;
}"
75516,"/** 
 * Override the base class to invalidate the schedule and resolved types of the director of the container, if there is one, in addition to what the base class does.
 * @param relation The relation to link to.
 * @exception IllegalActionException If the link crosses levels ofthe hierarchy, or the port has no container, or the relation is not a ComponentRelation.
 */
public void link(ComponentRelation relation) throws IllegalActionException {
  super.link(relation);
  _invalidate();
}","/** 
 * Override the base class to invalidate the schedule and resolved types of the director of the container, if there is one, in addition to what the base class does.
 * @param relation The relation to link to.
 * @exception IllegalActionException If the link crosses levels ofthe hierarchy, or the port has no container, or the relation is not an instance of IORelation.
 */
public void link(Relation relation) throws IllegalActionException {
  super.link(relation);
  _invalidate();
}"
75517,"/** 
 * Check that a port that is not a multiport will not have too many links if a link is established with the specified relation.
 * @exception IllegalActionException If the port will have too manylinks.
 */
private void _checkMultiportLink(IORelation relation) throws IllegalActionException {
  if (_isInsideLinkable(relation.getContainer())) {
    if (!isInsideLinked(relation)) {
      if (!isMultiport() && numInsideLinks() >= 1) {
        throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
      }
      if ((relation.getWidth() != 1) || !relation.isWidthFixed()) {
        if (!isMultiport()) {
          throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
        }
        if (!relation.isWidthFixed()) {
          try {
            _getInsideWidth(null);
          }
 catch (          InvalidStateException ex) {
            throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
      }
    }
  }
 else {
    if (!isLinked(relation)) {
      if (!isMultiport() && numLinks() >= 1) {
        throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
      }
      if (relation.getWidth() != 1 || !relation.isWidthFixed()) {
        if (!isMultiport()) {
          throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
        }
        Iterator relations=linkedRelationList().iterator();
        while (relations.hasNext()) {
          IORelation theRelation=(IORelation)relations.next();
          if (theRelation != null && !theRelation.isWidthFixed()) {
            throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
      }
    }
  }
}","/** 
 * Check that a port that is not a multiport will not have too many links if a link is established with the specified relation.
 * @exception IllegalActionException If the port will have too manylinks.
 */
private void _checkMultiportLink(IORelation relation) throws IllegalActionException {
  if (_isInsideLinkable(relation.getContainer())) {
    if (!isMultiport() && numInsideLinks() >= 1) {
      throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
    }
    if ((relation.getWidth() != 1) || !relation.isWidthFixed()) {
      if (!isMultiport()) {
        throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!relation.isWidthFixed()) {
        try {
          _getInsideWidth(null);
        }
 catch (        InvalidStateException ex) {
          throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
 else {
    if (!isMultiport() && numLinks() >= 1) {
      throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (relation.getWidth() != 1 || !relation.isWidthFixed()) {
      if (!isMultiport()) {
        throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"");
      }
      Iterator relations=linkedRelationList().iterator();
      while (relations.hasNext()) {
        IORelation theRelation=(IORelation)relations.next();
        if (theRelation != null && !theRelation.isWidthFixed()) {
          throw new IllegalActionException(this,relation,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
}"
75518,"/** 
 * Get the output string to be sent. This does not return until a value is entered on the shell by the user.
 * @return The output string to be sent.
 */
public synchronized String getOutput(){
  while (_outputValues.size() < 1 && !_stopRequested) {
    try {
      wait();
    }
 catch (    InterruptedException ex) {
    }
  }
  if (_stopRequested) {
    return (""String_Node_Str"");
  }
 else {
    return ((String)_outputValues.remove(0));
  }
}","/** 
 * Get the output string to be sent. This does not return until a value is entered on the shell by the user.
 * @return The output string to be sent.
 */
public synchronized String getOutput(){
  while (_outputValues.size() < 1 && !_stopRequested) {
    try {
      workspace().wait(this);
    }
 catch (    InterruptedException ex) {
    }
  }
  if (_stopRequested) {
    return (""String_Node_Str"");
  }
 else {
    return ((String)_outputValues.remove(0));
  }
}"
75519,"/** 
 * Set the mode of parse tree evaluator to construction mode with mode as true, to update mode with mode as false.
 * @param mode The mode of the parse tree evaluator.
 */
public void setEvaluationMode(boolean mode){
  _construction=mode;
  if (mode) {
    _relationNumber=0;
    _relationIndex=0;
  }
}","/** 
 * Set the mode of parse tree evaluator.  If the given flag is true, then the relation list will be populated, based on the nodes in the parse tree.  If the given flag is false, then the list will simply be updated with new information
 * @param mode The mode of the parse tree evaluator.
 */
public void setEvaluationMode(boolean mode){
  _constructingRelationList=mode;
}"
75520,"/** 
 * Construct a parse tree evaluator for guard expression. The relation list is used to store the information of the relation nodes and leaf nodes with boolean tokens. If the relation list is empty, the evaluator is in construction mode, otherwise, it is in update mode.
 * @param relationList The relation list.
 * @param errorTolerance The errorTolerance.
 */
public ParseTreeEvaluatorForGuardExpression(RelationList relationList,double errorTolerance){
  if (relationList.isEmpty()) {
    _construction=true;
  }
 else {
    _construction=false;
  }
  _relationList=relationList;
  _relationIndex=0;
  _relationNumber=0;
  _absentDiscreteVariables=new LinkedList();
  _errorTolerance=errorTolerance;
  _variableCollector=new ParseTreeFreeVariableCollector();
}","/** 
 * Construct a parse tree evaluator for guard expression. The relation list is used to store the information of the relation nodes and leaf nodes with boolean tokens. If the relation list is empty, the evaluator is in construction mode, otherwise, it is in update mode.
 * @param relationList The relation list.
 * @param errorTolerance The errorTolerance.
 */
public ParseTreeEvaluatorForGuardExpression(RelationList relationList,double errorTolerance){
  if (relationList.isEmpty()) {
    _constructingRelationList=true;
  }
 else {
    _constructingRelationList=false;
  }
  _relationList=relationList;
  _relationIndex=0;
  _absentDiscreteVariables=new LinkedList();
  _errorTolerance=errorTolerance;
  _variableCollector=new ParseTreeFreeVariableCollector();
}"
75521,"/** 
 * Visit the leaf node. It is evaluated the same way as normal parse tree evaluator, except that if the the result is a boolean token, the information about the node (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The leaf node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitLeafNode throws the IllegalActionException.
 */
public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  String nodeName=node.getName();
  String discreteVariableName=""String_Node_Str"";
  if (nodeName != null) {
    int variableNameEndIndex=nodeName.indexOf(""String_Node_Str"");
    if (variableNameEndIndex != -1) {
      discreteVariableName=nodeName.substring(0,variableNameEndIndex);
    }
  }
  if (_absentDiscreteVariables.contains(nodeName)) {
    _evaluatedChildToken=new BooleanToken(false);
    if (_construction) {
      _relationList.addRelation(0,0.0);
      _relationNumber++;
    }
    _relationIndex++;
    if (_relationIndex >= _relationNumber) {
      _relationIndex-=_relationNumber;
    }
    return;
  }
  super.visitLeafNode(node);
  ptolemy.data.Token result=_evaluatedChildToken;
  if (!(result instanceof BooleanToken))   return;
  if (((BooleanToken)result).booleanValue()) {
    _relationType=1;
    if (_absentDiscreteVariables.contains(discreteVariableName)) {
      _absentDiscreteVariables.remove(discreteVariableName);
    }
  }
 else {
    _relationType=2;
    if (!_absentDiscreteVariables.contains(discreteVariableName)) {
      _absentDiscreteVariables.add(discreteVariableName);
    }
  }
  _difference=0.0;
  if (_construction) {
    _relationList.addRelation(_relationType,_difference);
    _relationNumber++;
  }
 else {
    _relationList.setRelation(_relationIndex,_relationType,_difference);
  }
  _relationIndex++;
  if (_relationIndex >= _relationNumber) {
    _relationIndex-=_relationNumber;
  }
}","/** 
 * Visit the leaf node. It is evaluated the same way as normal parse tree evaluator, except that if the the result is a boolean token, the information about the node (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The leaf node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitLeafNode throws the IllegalActionException.
 */
public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  String nodeName=node.getName();
  String discreteVariableName=""String_Node_Str"";
  if (nodeName != null) {
    int variableNameEndIndex=nodeName.indexOf(""String_Node_Str"");
    if (variableNameEndIndex != -1) {
      discreteVariableName=nodeName.substring(0,variableNameEndIndex);
    }
  }
  if (_absentDiscreteVariables.contains(nodeName)) {
    _evaluatedChildToken=new BooleanToken(false);
    if (_constructingRelationList) {
      _relationList.addRelation(0,0.0);
    }
    _relationIndex++;
    return;
  }
  super.visitLeafNode(node);
  ptolemy.data.Token result=_evaluatedChildToken;
  if (!(result instanceof BooleanToken))   return;
  if (((BooleanToken)result).booleanValue()) {
    _relationType=1;
    if (_absentDiscreteVariables.contains(discreteVariableName)) {
      _absentDiscreteVariables.remove(discreteVariableName);
    }
  }
 else {
    _relationType=2;
    if (!_absentDiscreteVariables.contains(discreteVariableName)) {
      _absentDiscreteVariables.add(discreteVariableName);
    }
  }
  _difference=0.0;
  if (_constructingRelationList) {
    _relationList.addRelation(_relationType,_difference);
  }
 else {
    _relationList.setRelation(_relationIndex,_relationType,_difference);
  }
  _relationIndex++;
}"
75522,"/** 
 * Visit the relation node. The evaluation part is the same as normal parseTreeEvaluator, except that information about each relation (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The relation node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitRelationNode throws the IllegalActionException.
 */
public void visitRelationalNode(ASTPtRelationalNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    return;
  }
  Set variablesOfNode=_variableCollector.collectFreeVariables(node);
  Iterator absentDiscreteVariables=_absentDiscreteVariables.listIterator();
  while (absentDiscreteVariables.hasNext()) {
    String variableName=(String)absentDiscreteVariables.next();
    if (variablesOfNode.contains(variableName)) {
      _evaluatedChildToken=new BooleanToken(false);
      if (_construction) {
        _relationList.addRelation(0,0.0);
        _relationNumber++;
      }
      _relationIndex++;
      if (_relationIndex >= _relationNumber) {
        _relationIndex-=_relationNumber;
      }
      return;
    }
  }
  ptolemy.data.Token[] tokens=_evaluateAllChildren(node);
  int numChildren=node.jjtGetNumChildren();
  _assert(numChildren == 2,node,""String_Node_Str"");
  ptolemy.data.expr.Token operator=(ptolemy.data.expr.Token)node.getOperator();
  ptolemy.data.Token leftToken=tokens[0];
  ptolemy.data.Token rightToken=tokens[1];
  ptolemy.data.Token result;
  if (operator.kind == PtParserConstants.EQUALS || operator.kind == PtParserConstants.NOTEQUALS) {
    if (operator.kind == PtParserConstants.EQUALS) {
      result=leftToken.isCloseTo(rightToken,_errorTolerance);
    }
 else {
      result=leftToken.isCloseTo(rightToken,_errorTolerance).not();
    }
    if ((leftToken instanceof BooleanToken) && (rightToken instanceof BooleanToken)) {
      if (((BooleanToken)result).booleanValue()) {
        _relationType=1;
      }
 else {
        _relationType=2;
      }
      _difference=0.0;
    }
 else {
      ScalarToken difference=(ScalarToken)leftToken.subtract(rightToken);
      if (((BooleanToken)result).booleanValue()) {
        _relationType=3;
      }
 else {
        if (difference.doubleValue() < 0) {
          _relationType=4;
        }
 else {
          _relationType=5;
        }
      }
      _difference=difference.doubleValue();
    }
  }
 else {
    if (!((leftToken instanceof ScalarToken) && (rightToken instanceof ScalarToken))) {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str"");
    }
    ScalarToken leftScalar=(ScalarToken)leftToken;
    ScalarToken rightScalar=(ScalarToken)rightToken;
    if (operator.kind == PtParserConstants.GTE) {
      result=leftScalar.isLessThan(rightScalar).not();
    }
 else     if (operator.kind == PtParserConstants.GT) {
      result=rightScalar.isLessThan(leftScalar);
    }
 else     if (operator.kind == PtParserConstants.LTE) {
      result=rightScalar.isLessThan(leftScalar).not();
    }
 else     if (operator.kind == PtParserConstants.LT) {
      result=leftScalar.isLessThan(rightScalar);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str""+ leftToken.getClass().getName()+ ""String_Node_Str""+ rightToken.getClass().getName());
    }
    if (((BooleanToken)result).booleanValue()) {
      _relationType=1;
    }
 else {
      _relationType=2;
    }
    _difference=((ScalarToken)leftScalar.subtract(rightScalar)).doubleValue();
  }
  _evaluatedChildToken=result;
  if (_construction) {
    _relationList.addRelation(_relationType,_difference);
    _relationNumber++;
  }
 else {
    _relationList.setRelation(_relationIndex,_relationType,_difference);
  }
  _relationIndex++;
  if (_relationIndex >= _relationNumber) {
    _relationIndex-=_relationNumber;
  }
  return;
}","/** 
 * Visit the relation node. The evaluation part is the same as normal parseTreeEvaluator, except that information about each relation (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The relation node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitRelationNode throws the IllegalActionException.
 */
public void visitRelationalNode(ASTPtRelationalNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    return;
  }
  Set variablesOfNode=_variableCollector.collectFreeVariables(node);
  Iterator absentDiscreteVariables=_absentDiscreteVariables.listIterator();
  while (absentDiscreteVariables.hasNext()) {
    String variableName=(String)absentDiscreteVariables.next();
    if (variablesOfNode.contains(variableName)) {
      _evaluatedChildToken=new BooleanToken(false);
      if (_constructingRelationList) {
        _relationList.addRelation(0,0.0);
      }
      _relationIndex++;
      return;
    }
  }
  ptolemy.data.Token[] tokens=_evaluateAllChildren(node);
  int numChildren=node.jjtGetNumChildren();
  _assert(numChildren == 2,node,""String_Node_Str"");
  ptolemy.data.expr.Token operator=(ptolemy.data.expr.Token)node.getOperator();
  ptolemy.data.Token leftToken=tokens[0];
  ptolemy.data.Token rightToken=tokens[1];
  ptolemy.data.Token result;
  if (operator.kind == PtParserConstants.EQUALS || operator.kind == PtParserConstants.NOTEQUALS) {
    if (operator.kind == PtParserConstants.EQUALS) {
      result=leftToken.isCloseTo(rightToken,_errorTolerance);
    }
 else {
      result=leftToken.isCloseTo(rightToken,_errorTolerance).not();
    }
    if ((leftToken instanceof BooleanToken) && (rightToken instanceof BooleanToken)) {
      if (((BooleanToken)result).booleanValue()) {
        _relationType=1;
      }
 else {
        _relationType=2;
      }
      _difference=0.0;
    }
 else {
      ScalarToken difference=(ScalarToken)leftToken.subtract(rightToken);
      if (((BooleanToken)result).booleanValue()) {
        _relationType=3;
      }
 else {
        if (difference.doubleValue() < 0) {
          _relationType=4;
        }
 else {
          _relationType=5;
        }
      }
      _difference=difference.doubleValue();
    }
  }
 else {
    if (!((leftToken instanceof ScalarToken) && (rightToken instanceof ScalarToken))) {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str"");
    }
    ScalarToken leftScalar=(ScalarToken)leftToken;
    ScalarToken rightScalar=(ScalarToken)rightToken;
    if (operator.kind == PtParserConstants.GTE) {
      result=leftScalar.isLessThan(rightScalar).not();
    }
 else     if (operator.kind == PtParserConstants.GT) {
      result=rightScalar.isLessThan(leftScalar);
    }
 else     if (operator.kind == PtParserConstants.LTE) {
      result=rightScalar.isLessThan(leftScalar).not();
    }
 else     if (operator.kind == PtParserConstants.LT) {
      result=leftScalar.isLessThan(rightScalar);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str""+ leftToken.getClass().getName()+ ""String_Node_Str""+ rightToken.getClass().getName());
    }
    if (((BooleanToken)result).booleanValue()) {
      _relationType=1;
    }
 else {
      _relationType=2;
    }
    _difference=((ScalarToken)leftScalar.subtract(rightScalar)).doubleValue();
  }
  _evaluatedChildToken=result;
  if (_constructingRelationList) {
    _relationList.addRelation(_relationType,_difference);
  }
 else {
    _relationList.setRelation(_relationIndex,_relationType,_difference);
  }
  _relationIndex++;
  return;
}"
75523,"/** 
 * Update the model here to achieve consistency.
 * @exception IllegalActionException If there is no director,or if the director's postfire() method throws it, or if this actor is not opaque.
 */
public boolean postfire() throws IllegalActionException {
  if (!_stopRequested && _model != null) {
    String delete=_requestToRemoveAll(this);
    MoMLChangeRequest removeRequest=new MoMLChangeRequest(this,this,delete,null);
    requestChange(removeRequest);
    MoMLChangeRequest request=new MoMLChangeRequest(this,this,_model.exportMoML(),null);
    requestChange(request);
    String moml=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + _model.getName() + ""String_Node_Str""+ ""String_Node_Str""+ _model.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    MoMLChangeRequest request2=new MoMLChangeRequest(this,this,moml,null);
    requestChange(request2);
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _model=null;
  }
  return super.postfire();
}","/** 
 * Update the model here to achieve consistency.
 * @exception IllegalActionException If there is no director,or if the director's postfire() method throws it, or if this actor is not opaque.
 */
public boolean postfire() throws IllegalActionException {
  if (!_stopRequested && _model != null) {
    String delete=_requestToRemoveAll(this);
    MoMLChangeRequest removeRequest=new MoMLChangeRequest(this,this,delete,null);
    requestChange(removeRequest);
    StringWriter writer=new StringWriter();
    try {
      _model.exportMoML(writer,1);
    }
 catch (    Exception ex) {
    }
    String modelMoML=writer.toString();
    String moml=""String_Node_Str"" + modelMoML + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _model.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ _model.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    System.out.println(""String_Node_Str"" + moml);
    MoMLChangeRequest request2=new MoMLChangeRequest(this,this,moml,null);
    requestChange(request2);
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    _model=null;
  }
  return super.postfire();
}"
75524,"/** 
 * Return true if the actor either of its input port has token.
 * @exception IllegalActionException Not thrown in this base class.
 */
public boolean prefire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (input.hasToken(0) || modelString.hasToken(0)) {
    return true;
  }
  return false;
}","/** 
 * Return true if the actor either of its input port has token.
 * @exception IllegalActionException Not thrown in this base class.
 */
public boolean prefire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (input.hasToken(0) || modelString.hasToken(0)) {
    return super.prefire();
  }
  return false;
}"
75525,"/** 
 * Initialize this actor. create a new moml parser for passing the applied model to it.
 * @exception IllegalActionException If there is no director, orif the director's initialize() method throws it, or if the actor is not opaque.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _model=null;
  try {
    _parser=new MoMLParser();
    _parser.setMoMLFilters(BackwardCompatibility.allFilters());
    _parser.addMoMLFilter(new RemoveGraphicalClasses());
    Const constActor=new Const(this,""String_Node_Str"");
    constActor.value.setExpression(defaultValue.getToken().toString());
    connect(input,constActor.trigger);
    connect(constActor.output,output);
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  super.initialize();
}","/** 
 * Initialize this actor. create a new moml parser for passing the applied model to it.
 * @exception IllegalActionException If there is no director, orif the director's initialize() method throws it, or if the actor is not opaque.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _model=null;
  try {
    _parser=new MoMLParser();
    _parser.setMoMLFilters(BackwardCompatibility.allFilters());
    Const constActor=new Const(this,""String_Node_Str"");
    constActor.value.setExpression(defaultValue.getToken().toString());
    connect(input,constActor.trigger);
    connect(constActor.output,output);
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  super.initialize();
}"
75526,"/** 
 * Construct an actor with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public MobileModel(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  modelString=new TypedIOPort(this,""String_Node_Str"",true,false);
  modelString.setTypeEquals(BaseType.STRING);
  defaultValue=new Parameter(this,""String_Node_Str"",new IntToken(0));
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeAtLeast(defaultValue);
  new Director(this,""String_Node_Str"");
  getMoMLInfo().className=""String_Node_Str"";
}","/** 
 * Construct an actor with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public MobileModel(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  modelString=new TypedIOPort(this,""String_Node_Str"",true,false);
  modelString.setTypeEquals(BaseType.STRING);
  defaultValue=new Parameter(this,""String_Node_Str"",new IntToken(0));
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeAtLeast(defaultValue);
  new DEDirector(this,""String_Node_Str"");
  getMoMLInfo().className=""String_Node_Str"";
}"
75527,"/** 
 * Evaluate the specified command.
 * @param command The command.
 * @return The return value of the command, or null if there is none.
 * @exception Exception If something goes wrong processing the command.
 */
public String evaluateCommand(String command) throws Exception {
  PtParser parser=new PtParser();
  ASTPtRootNode node=parser.generateSimpleAssignmentParseTree(command);
  String targetName=null;
  if (node instanceof ASTPtAssignmentNode) {
    ASTPtAssignmentNode assignmentNode=(ASTPtAssignmentNode)node;
    targetName=assignmentNode.getIdentifier();
    node=assignmentNode.getExpressionTree();
  }
  final NamedObj model=((ExpressionShellEffigy)getContainer()).getModel();
  ParserScope scope=new ModelScope(){
    public ptolemy.data.Token get(    String name) throws IllegalActionException {
      Variable result=getScopedVariable(null,model,name);
      if (result != null) {
        return result.getToken();
      }
 else {
        return null;
      }
    }
    public ptolemy.data.type.Type getType(    String name) throws IllegalActionException {
      Variable result=getScopedVariable(null,model,name);
      if (result != null) {
        return result.getType();
      }
 else {
        return null;
      }
    }
    public Set identifierSet(){
      return getAllScopedVariableNames(null,model);
    }
  }
;
  Token result=_evaluator.evaluateParseTree(node,scope);
  if (targetName != null) {
    Parameter parameter=new Parameter(model,targetName);
    parameter.setToken(result);
  }
  if (result == null) {
    return ""String_Node_Str"";
  }
 else {
    return result.toString();
  }
}","/** 
 * Evaluate the specified command.
 * @param command The command.
 * @return The return value of the command, or null if there is none.
 * @exception Exception If something goes wrong processing the command.
 */
public String evaluateCommand(String command) throws Exception {
  PtParser parser=new PtParser();
  ASTPtRootNode node=parser.generateSimpleAssignmentParseTree(command);
  String targetName=null;
  if (node instanceof ASTPtAssignmentNode) {
    ASTPtAssignmentNode assignmentNode=(ASTPtAssignmentNode)node;
    targetName=assignmentNode.getIdentifier();
    node=assignmentNode.getExpressionTree();
  }
  final NamedObj model=((ExpressionShellEffigy)getContainer()).getModel();
  ParserScope scope=new ModelScope(){
    public ptolemy.data.Token get(    String name) throws IllegalActionException {
      Variable result=getScopedVariable(null,model,name);
      if (result != null) {
        return result.getToken();
      }
 else {
        return null;
      }
    }
    public ptolemy.data.type.Type getType(    String name) throws IllegalActionException {
      Variable result=getScopedVariable(null,model,name);
      if (result != null) {
        return result.getType();
      }
 else {
        return null;
      }
    }
    public Set identifierSet(){
      return getAllScopedVariableNames(null,model);
    }
  }
;
  Token result=_evaluator.evaluateParseTree(node,scope);
  if (targetName != null) {
    Attribute attribute=model.getAttribute(targetName);
    if (attribute != null && !(attribute instanceof Parameter)) {
      attribute.setContainer(null);
      attribute=null;
    }
    if (attribute == null) {
      attribute=new Parameter(model,targetName);
    }
    ((Parameter)attribute).setToken(result);
  }
  if (result == null) {
    return ""String_Node_Str"";
  }
 else {
    return result.toString();
  }
}"
75528,"/** 
 * Create the MakeFile.
 * @param classPath The classPath.
 * @param className The class for which the Makefile is to be generated.The makefile will have the name <i>className</i>.make.
 */
public static void generateMakeFile(String classPath,String className){
  boolean gc=Options.v().getBoolean(""String_Node_Str"");
  StringBuffer code=new StringBuffer();
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + NativeMethodGenerator.nativeBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + OverriddenMethodGenerator.overriddenBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + Options.v().get(""String_Node_Str"") + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
    code.append(""String_Node_Str"");
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
  HashSet libSources=RequiredFileGenerator.generateUserClasses(code);
  code.append(""String_Node_Str"");
  Iterator i=libSources.iterator();
  while (i.hasNext()) {
    code.append(""String_Node_Str"" + (String)i.next() + ""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + StubFileGenerator.stubFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + StubFileGenerator.stubFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  FileHandler.write(className + ""String_Node_Str"",code.toString());
}","/** 
 * Create the MakeFile.
 * @param classPath The classPath.
 * @param className The class for which the Makefile is to be generated.The makefile will have the name <i>className</i>.make.
 */
public static void generateMakeFile(String classPath,String className){
  boolean gc=Options.v().getBoolean(""String_Node_Str"");
  StringBuffer code=new StringBuffer();
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + NativeMethodGenerator.nativeBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + OverriddenMethodGenerator.overriddenBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + Options.v().get(""String_Node_Str"") + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
    code.append(""String_Node_Str"");
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
  HashSet libSources=RequiredFileGenerator.generateUserClasses(code);
  code.append(""String_Node_Str"");
  Iterator i=libSources.iterator();
  while (i.hasNext()) {
    code.append(""String_Node_Str"" + (String)i.next() + ""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + StubFileGenerator.stubFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + StubFileGenerator.stubFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  FileHandler.write(className + ""String_Node_Str"",code.toString());
}"
75529,"/** 
 * If the string is longer than 79 characters, split it up by displaying adding newlines in all newline delimited substrings that are longer than 79 characters.  If the <i>longName</i> argument is null, then the string ""<Unnamed>"" is returned.
 * @see #abbreviate(String longName)
 * @param longName The string to optionally split up
 * @return Either the original string, or the string with newlinesinserted
 */
public static String split(String longName){
  if (longName == null) {
    return ""String_Node_Str"";
  }
  if (longName.length() < 80) {
    return longName;
  }
  StringBuffer results=new StringBuffer();
  StringTokenizer tokenizer=new StringTokenizer(longName,""String_Node_Str"",true);
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    int i=0;
    while (i < token.length() - 79) {
      int lastSpaceIndex=token.substring(i,i + 79).lastIndexOf(""String_Node_Str"");
      if (lastSpaceIndex < 0) {
        results.append(token.substring(i,i + 79) + ""String_Node_Str"");
        i+=79;
      }
 else {
        results.append(token.substring(i,lastSpaceIndex) + ""String_Node_Str"");
        i=lastSpaceIndex + 1;
      }
    }
    results.append(token.substring(i));
  }
  return results.toString();
}","/** 
 * If the string is longer than 79 characters, split it up by displaying adding newlines in all newline delimited substrings that are longer than 79 characters.  If the <i>longName</i> argument is null, then the string ""<Unnamed>"" is returned.
 * @see #abbreviate(String longName)
 * @param longName The string to optionally split up
 * @return Either the original string, or the string with newlinesinserted
 */
public static String split(String longName){
  if (longName == null) {
    return ""String_Node_Str"";
  }
  if (longName.length() < 80) {
    return longName;
  }
  StringBuffer results=new StringBuffer();
  StringTokenizer tokenizer=new StringTokenizer(longName,""String_Node_Str"",true);
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    int i=0;
    while (i < token.length() - 79) {
      int lastSpaceIndex=token.substring(i,i + 79).lastIndexOf(""String_Node_Str"");
      if (lastSpaceIndex < 0) {
        results.append(token.substring(i,i + 79) + ""String_Node_Str"");
        i+=79;
      }
 else {
        results.append(token.substring(i,i + lastSpaceIndex) + ""String_Node_Str"");
        i+=lastSpaceIndex + 1;
      }
    }
    results.append(token.substring(i));
  }
  return results.toString();
}"
75530,"/** 
 * Check whether the current director is a GRDirector. If not, throw an illegal action exception.
 * @exception IllegalActionException If the current directoris not a GRDirector.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
}","/** 
 * Check whether the current director is a GRDirector. If not, throw an illegal action exception.
 * @exception IllegalActionException If the current directoris not a GRDirector.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _isSceneGraphInitialized=false;
}"
75531,"/** 
 * Initialize all the actors associated with this director. Perform some internal initialization for this director.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _buildActorTable();
  _iteration=0;
}","/** 
 * Initialize all the actors associated with this director. Perform some internal initialization for this director.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _buildActorTable();
  _iteration=0;
  TypedCompositeActor container=(TypedCompositeActor)getContainer();
  List viewScreens=container.entityList(ViewScreen.class);
  if (viewScreens.size() != 1) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  ViewScreen viewScreen=(ViewScreen)viewScreens.get(0);
  for (Iterator actors=container.entityList(GRActor.class).iterator(); actors.hasNext(); ) {
    GRActor actor=(GRActor)actors.next();
    actor._setViewScreen(viewScreen);
  }
}"
75532,"/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>The graph is not acyclic <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return A Schedule type of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 */
protected Schedule _getSchedule(){
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  GRDirector director=(GRDirector)getContainer();
  if (director == null) {
    return null;
  }
  int referenceDepth=director.depthInHierarchy();
  CompositeActor container=(CompositeActor)(director.getContainer());
  if (container == null) {
    return null;
  }
  CompositeActor castContainer=(CompositeActor)container;
  int count=0;
  List entities=castContainer.deepEntityList();
  Iterator actors=entities.iterator();
  int actorCount=entities.size();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    dag.addNodeWeight(actor);
  }
  actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    Set successors=new HashSet();
    Iterator outports=actor.outputPortList().iterator();
    while (outports.hasNext()) {
      IOPort outPort=(IOPort)outports.next();
      Iterator sinkPorts=outPort.sinkPortList().iterator();
      while (sinkPorts.hasNext()) {
        IOPort sinkPort=(IOPort)sinkPorts.next();
        if (sinkPort.isOutput()) {
          continue;
        }
        Actor sinkActor=(Actor)sinkPort.getContainer();
        successors.add(sinkActor);
      }
    }
    Iterator succeedingActors=successors.iterator();
    while (succeedingActors.hasNext()) {
      Actor connectedActor=(Actor)succeedingActors.next();
      dag.addEdge(actor,connectedActor);
    }
  }
  if (!dag.isAcyclic()) {
    Object[] cycleNodes=dag.cycleNodes();
    StringBuffer names=new StringBuffer();
    for (int i=0; i < cycleNodes.length; i++) {
      if (cycleNodes[i] instanceof Nameable) {
        if (i > 0)         names.append(""String_Node_Str"");
        names.append(((Nameable)cycleNodes[i]).getFullName());
      }
    }
    throw new NotSchedulableException(this,""String_Node_Str"" + names.toString());
  }
  if (dag.top() == null) {
  }
  Schedule schedule=new Schedule();
  Object[] sorted=dag.topologicalSort();
  for (int counter=0; counter < actorCount; counter++) {
    Firing firing=new Firing();
    schedule.add(firing);
    firing.setActor((Actor)sorted[counter]);
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(schedule.toString());
  }
  setValid(true);
  return schedule;
}","/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>The graph is not acyclic <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return A Schedule type of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 */
protected Schedule _getSchedule(){
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  GRDirector director=(GRDirector)getContainer();
  if (director == null) {
    return null;
  }
  int referenceDepth=director.depthInHierarchy();
  CompositeActor container=(CompositeActor)(director.getContainer());
  if (container == null) {
    return null;
  }
  CompositeActor castContainer=(CompositeActor)container;
  int count=0;
  List entities=castContainer.deepEntityList();
  Iterator actors=entities.iterator();
  int actorCount=entities.size();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    dag.addNodeWeight(actor);
  }
  actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    Set successors=new HashSet();
    Iterator outports=actor.outputPortList().iterator();
    while (outports.hasNext()) {
      IOPort outPort=(IOPort)outports.next();
      Iterator sinkPorts=outPort.sinkPortList().iterator();
      while (sinkPorts.hasNext()) {
        IOPort sinkPort=(IOPort)sinkPorts.next();
        if (sinkPort.isOutput()) {
          continue;
        }
        Actor sinkActor=(Actor)sinkPort.getContainer();
        successors.add(sinkActor);
      }
    }
    Iterator succeedingActors=successors.iterator();
    while (succeedingActors.hasNext()) {
      Actor connectedActor=(Actor)succeedingActors.next();
      dag.addEdge(actor,connectedActor);
    }
  }
  if (!dag.isAcyclic()) {
    Object[] cycleNodes=dag.cycleNodes();
    StringBuffer names=new StringBuffer();
    for (int i=0; i < cycleNodes.length; i++) {
      if (cycleNodes[i] instanceof Nameable) {
        if (i > 0)         names.append(""String_Node_Str"");
        names.append(((Nameable)cycleNodes[i]).getFullName());
      }
    }
    throw new NotSchedulableException(this,""String_Node_Str"" + names.toString());
  }
  if (dag.top() == null) {
  }
  Schedule schedule=new Schedule();
  Object[] sorted=dag.topologicalSort();
  for (int counter=0; counter < actorCount; counter++) {
    Firing firing=new Firing();
    firing.setActor((Actor)sorted[counter]);
    schedule.add(firing);
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(schedule.toString());
  }
  setValid(true);
  return schedule;
}"
75533,"protected void _makeSceneGraphConnection() throws IllegalActionException {
  if (_root == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    ViewScreen viewScreen=(ViewScreen)_root;
    viewScreen.addChild(_getNodeObject());
  }
}","protected void _makeSceneGraphConnection() throws IllegalActionException {
  if (_viewScreen == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    _viewScreen.addChild(_getNodeObject());
  }
}"
75534,"protected void _makeSceneGraphConnection() throws IllegalActionException {
  if (_root == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    ViewScreen viewScreen=(ViewScreen)_root;
    viewScreen.addChild(_getNodeObject());
  }
}","protected void _makeSceneGraphConnection() throws IllegalActionException {
  if (_viewScreen == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    _viewScreen.addChild(_getNodeObject());
  }
}"
75535,"public MouseInput3D(TypedCompositeActor container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  x=new TypedIOPort(this,""String_Node_Str"");
  x.setOutput(true);
  x.setTypeEquals(BaseType.INT);
  y=new TypedIOPort(this,""String_Node_Str"");
  y.setOutput(true);
  y.setTypeEquals(BaseType.INT);
}","public MouseInput3D(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  x=new TypedIOPort(this,""String_Node_Str"");
  x.setOutput(true);
  x.setTypeEquals(BaseType.INT);
  y=new TypedIOPort(this,""String_Node_Str"");
  y.setOutput(true);
  y.setTypeEquals(BaseType.INT);
}"
75536,"/** 
 * Construct a ViewScreen in the given container with the given name. If the container argument is null, a NullPointerException will be thrown. If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of the director.
 * @param name Name of this ViewScreen.
 * @exception IllegalActionException If this actoris not compatible with the specified container.
 * @exception NameDuplicationException If the container not aCompositeActor and the name collides with an entity in the container.
 */
public ViewScreen(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  sceneGraphIn=new TypedIOPort(this,""String_Node_Str"");
  sceneGraphIn.setInput(true);
  sceneGraphIn.setTypeEquals(SceneGraphToken.TYPE);
  sceneGraphIn.setMultiport(true);
  horizontalResolution=new Parameter(this,""String_Node_Str"",new IntToken(400));
  horizontalResolution.setTypeEquals(BaseType.INT);
  verticalResolution=new Parameter(this,""String_Node_Str"",new IntToken(400));
  verticalResolution.setTypeEquals(BaseType.INT);
  rotatable=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
  rotatable.setTypeEquals(BaseType.BOOLEAN);
  scalable=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  scalable.setTypeEquals(BaseType.BOOLEAN);
  translatable=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  translatable.setTypeEquals(BaseType.BOOLEAN);
  showAxes=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  showAxes.setTypeEquals(BaseType.BOOLEAN);
  iterationSynchronized=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  iterationSynchronized.setTypeEquals(BaseType.BOOLEAN);
  backgroundColor=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(new double[][]{{0.0,0.0,0.0}}));
  backgroundColor.setTypeEquals(BaseType.DOUBLE_MATRIX);
  _lastTransform=new Transform3D();
  _root=this;
}","/** 
 * Construct a ViewScreen in the given container with the given name. If the container argument is null, a NullPointerException will be thrown. If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of the director.
 * @param name Name of this ViewScreen.
 * @exception IllegalActionException If this actoris not compatible with the specified container.
 * @exception NameDuplicationException If the container not aCompositeActor and the name collides with an entity in the container.
 */
public ViewScreen(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  sceneGraphIn=new TypedIOPort(this,""String_Node_Str"");
  sceneGraphIn.setInput(true);
  sceneGraphIn.setTypeEquals(SceneGraphToken.TYPE);
  sceneGraphIn.setMultiport(true);
  horizontalResolution=new Parameter(this,""String_Node_Str"",new IntToken(400));
  horizontalResolution.setTypeEquals(BaseType.INT);
  verticalResolution=new Parameter(this,""String_Node_Str"",new IntToken(400));
  verticalResolution.setTypeEquals(BaseType.INT);
  rotatable=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
  rotatable.setTypeEquals(BaseType.BOOLEAN);
  scalable=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  scalable.setTypeEquals(BaseType.BOOLEAN);
  translatable=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  translatable.setTypeEquals(BaseType.BOOLEAN);
  showAxes=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  showAxes.setTypeEquals(BaseType.BOOLEAN);
  iterationSynchronized=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  iterationSynchronized.setTypeEquals(BaseType.BOOLEAN);
  backgroundColor=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(new double[][]{{0.0,0.0,0.0}}));
  backgroundColor.setTypeEquals(BaseType.DOUBLE_MATRIX);
  _lastTransform=new Transform3D();
}"
75537,"/** 
 * Add the node argument as a child to the encapsulated Java3D node in this actor.
 */
protected void addChild(Node node){
  _addChild(node);
}","/** 
 * Add the node argument as a child to the encapsulated Java3D node in this actor.
 */
public void addChild(Node node){
  _addChild(node);
}"
75538,"/** 
 * Apply the specified function to the specified array and return an array with the results. The function must take at least one argument. If the function takes more than one argument, then the specified array should be an array of arrays, where each subarray is a set of arguments.  Since arrays in the expression language can only contain elements of the same type, this method will only work for functions whose arguments are all of the same type.
 * @param function A function with at least one argument.
 * @param array The array to which to apply the function.
 * @return A new array that is the result of applying the functionto the specified array.
 * @exception IllegalActionException If the specified function does nottake at least one argument, or if an error occurs applying the function, or if the number of arguments does not match the subarray lengths.
 */
public static ArrayToken map(FunctionToken function,ArrayToken array) throws IllegalActionException {
  int arity=function.getNumberOfArguments();
  Token[] result=new Token[array.length()];
  if (arity == 1) {
    for (int i=0; i < array.length(); i++) {
      Token args=(Token)array.getElement(i);
      LinkedList arglist=new LinkedList();
      arglist.add(args);
      result[i]=function.apply(arglist);
    }
  }
 else   if (arity > 1) {
    for (int i=0; i < array.length(); i++) {
      Token args=(Token)array.getElement(i);
      if (!(args instanceof ArrayToken)) {
        throw new IllegalActionException(""String_Node_Str"");
      }
      LinkedList arglist=new LinkedList();
      ArrayToken castArgs=(ArrayToken)args;
      if (castArgs.length() != arity) {
        throw new IllegalActionException(""String_Node_Str"");
      }
 else {
        for (int j=1; j < arity; j++) {
          arglist.add(castArgs.getElement(j));
        }
        result[i]=function.apply(arglist);
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"");
  }
  return new ArrayToken(result);
}","/** 
 * Apply the specified function to the specified array and return an array with the results. The function must take at least one argument. If the function takes more than one argument, then the specified array should be an array of arrays, where each subarray is a set of arguments.  Since arrays in the expression language can only contain elements of the same type, this method will only work for functions whose arguments are all of the same type.
 * @param function A function with at least one argument.
 * @param array The array to which to apply the function.
 * @return A new array that is the result of applying the functionto the specified array.
 * @exception IllegalActionException If the specified function does nottake at least one argument, or if an error occurs applying the function, or if the number of arguments does not match the subarray lengths.
 */
public static ArrayToken map(FunctionToken function,ArrayToken array) throws IllegalActionException {
  int arity=function.getNumberOfArguments();
  Token[] result=new Token[array.length()];
  if (arity == 1) {
    for (int i=0; i < array.length(); i++) {
      Token args=(Token)array.getElement(i);
      LinkedList arglist=new LinkedList();
      arglist.add(args);
      result[i]=function.apply(arglist);
    }
  }
 else   if (arity > 1) {
    for (int i=0; i < array.length(); i++) {
      Token args=(Token)array.getElement(i);
      if (!(args instanceof ArrayToken)) {
        throw new IllegalActionException(""String_Node_Str"");
      }
      LinkedList arglist=new LinkedList();
      ArrayToken castArgs=(ArrayToken)args;
      if (castArgs.length() != arity) {
        throw new IllegalActionException(""String_Node_Str"");
      }
 else {
        for (int j=0; j < arity; j++) {
          arglist.add(castArgs.getElement(j));
        }
        result[i]=function.apply(arglist);
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"");
  }
  return new ArrayToken(result);
}"
75539,"public static ArrayToken map(FunctionToken function,ArrayToken array){
  int num=function.getNumberOfArguments();
  ArrayToken result=null;
  if (BaseType.SCALAR.isCompatible(array.getElementType())) {
    if (num != 1) {
      throw new IllegalActionException(""String_Node_Str"");
    }
 else {
      for (int i=0; i < array.length(); i++) {
        ScalarToken args=(ScalarToken)array.getElement(i);
        LinkedList arglist=new LinkedList();
        arglist.add(args);
        result.add(function.apply(arglist));
      }
    }
  }
 else {
    for (int i=0; i < array.length(); i++) {
      ArrayToken args=(ArrayToken)array.getElement(i);
      LinkedList arglist=new LinkedList();
      if (args.length() != num) {
        throw new IllegalActionException(""String_Node_Str"");
      }
 else {
        for (int j=1; j < num; j++) {
          arglist.add(args.getElement(j));
        }
        result.add(function.apply(arglist));
      }
    }
  }
  return result;
}","/** 
 * Apply the specified function to the specified array and return an array with the results. The function must take at least one argument. If the function takes more than one argument, then the specified array should be an array of arrays, where each subarray is a set of arguments.  Since arrays in the expression language can only contain elements of the same type, this method will only work for functions whose arguments are all of the same type.
 * @param function A function with at least one argument.
 * @param array The array to which to apply the function.
 * @return A new array that is the result of applying the functionto the specified array.
 * @exception IllegalActionException If the specified function does nottake at least one argument, or if an error occurs applying the function, or if the number of arguments does not match the subarray lengths.
 */
public static ArrayToken map(FunctionToken function,ArrayToken array) throws IllegalActionException {
  int arity=function.getNumberOfArguments();
  ArrayToken result=null;
  if (BaseType.SCALAR.isCompatible(array.getElementType())) {
    if (arity != 1) {
      throw new IllegalActionException(""String_Node_Str"");
    }
 else {
      for (int i=0; i < array.length(); i++) {
        ScalarToken args=(ScalarToken)array.getElement(i);
        LinkedList arglist=new LinkedList();
        arglist.add(args);
        result.add(function.apply(arglist));
      }
    }
  }
 else {
    for (int i=0; i < array.length(); i++) {
      ArrayToken args=(ArrayToken)array.getElement(i);
      LinkedList arglist=new LinkedList();
      if (args.length() != arity) {
        throw new IllegalActionException(""String_Node_Str"");
      }
 else {
        for (int j=1; j < arity; j++) {
          arglist.add(args.getElement(j));
        }
        result.add(function.apply(arglist));
      }
    }
  }
  return result;
}"
75540,"public ArrayToken iterate(FunctionToken function,int length,Token initValue){
  int num=function.getNumberOfArguments();
  ArrayToken result=null;
  if (num != 1) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    result.add(initValue);
    Token iterate=initValue;
    for (int i=0; i < length; i++) {
      LinkedList arglist=new LinkedList();
      arglist.add(iterate);
      iterate=function.apply(arglist);
      result.add(iterate);
    }
  }
  return result;
}","/** 
 * Iterate the specified function to produce an array of the specified length.  The first element of the output array is the <i>initial</i> argument, the second is the result of applying the function to <i>initial</i>, the third is the result of applying the function to that result, etc.
 * @param function A single-argument function to iterate.
 * @param length The length of the resulting array.
 * @param initial The first element of the result.
 * @return A new array that is the result of applying the functionrepeatedly.
 * @exception IllegalActionException If the specified function does nottake exactly one argument, or if an error occurs applying the function.
 */
public ArrayToken iterate(FunctionToken function,int length,Token initial) throws IllegalActionException {
  int arity=function.getNumberOfArguments();
  if (arity != 1) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    ArrayToken result=null;
    Token iterate=initial;
    result.add(iterate);
    for (int i=1; i < length; i++) {
      LinkedList arglist=new LinkedList();
      arglist.add(iterate);
      iterate=function.apply(arglist);
    }
    return result;
  }
}"
75541,"/** 
 * Test that the value of this token is close to the first argument, where ""close"" means that the distance between their values is less than or equal to the second argument. It is assumed that the type of the first argument is DoubleToken.
 * @param token The token to compare to this token.
 * @return A token containing true if the value of this token is closeto that of the argument.
 */
protected BooleanToken _isCloseTo(ScalarToken rightArgument,double epsilon){
  return BooleanToken.getInstance(Math.abs(doubleValue() - ((DoubleToken)rightArgument).doubleValue()) <= epsilon);
}","/** 
 * Test that the value of this token is close to the first argument, where ""close"" means that the distance between their values is less than or equal to the second argument. It is assumed that the type of the first argument is DoubleToken.
 * @param token The token to compare to this token.
 * @return A token containing true if the value of this token is closeto that of the argument.
 */
protected BooleanToken _isCloseTo(ScalarToken rightArgument,double epsilon){
  double right=((DoubleToken)rightArgument).doubleValue();
  double left=doubleValue();
  if (right > left + epsilon || right < left - epsilon) {
    return BooleanToken.FALSE;
  }
 else {
    return BooleanToken.TRUE;
  }
}"
75542,"/** 
 * Indicate that the calling thread is finished writing. This wakes up any threads that are suspended on access to this workspace so that they may contend for permissions. It also increments the version number of the workspace.
 * @exception InvalidStateException If this method is called whenthe workspace is read-only.
 */
public final synchronized void doneWriting(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,false);
  }
  if (current != _writer) {
    if (record != null && record.failedWriteAttempts > 0) {
      record.failedWriteAttempts--;
    }
 else {
      throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    if (_writeDepth > 0) {
      _writeReq--;
      _writeDepth--;
      if (_writeDepth == 0) {
        _writer=null;
        incrVersion();
        notifyAll();
      }
    }
 else {
      throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}","/** 
 * Indicate that the calling thread is finished writing. This wakes up any threads that are suspended on access to this workspace so that they may contend for permissions. It also increments the version number of the workspace.
 * @exception InvalidStateException If this method is called whenthe workspace is read-only.
 */
public final synchronized void doneWriting(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,false);
  }
  if (current != _writer) {
    if (record != null && record.failedWriteAttempts > 0) {
      record.failedWriteAttempts--;
    }
 else {
      throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    if (_writeDepth > 0) {
      _writeDepth--;
      if (_writeDepth == 0) {
        _writer=null;
        incrVersion();
        notifyAll();
      }
    }
 else {
      throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}"
75543,"/** 
 * Obtain permissions to read objects in the workspace. This obtains many permissions on the read access and should be called in conjunction with _releaseAllReadPermissions. This method suspends the calling thread until such permission has been obtained.  Permission is granted unless either another thread has write permission, or there are threads that have requested write permission and not gotten it yet.
 * @param count This is the number of read permissions desired on theworkspace.
 */
private synchronized void _reacquireReadPermissions(int count){
  if (count == 0)   return;
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,false);
  }
  if (record == null || count > record.failedReadAttempts) {
    throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  while (true) {
    if (current == _writer || _writeReq == 0) {
      _numReaders++;
      record.failedReadAttempts-=count;
      record.readDepth=count;
      return;
    }
    try {
      wait();
    }
 catch (    InterruptedException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
    }
  }
}","/** 
 * Obtain permissions to read objects in the workspace. This obtains many permissions on the read access and should be called in conjunction with _releaseAllReadPermissions. This method suspends the calling thread until such permission has been obtained.  Permission is granted unless either another thread has write permission, or there are threads that have requested write permission and not gotten it yet.
 * @param count This is the number of read permissions desired on theworkspace.
 */
private synchronized void _reacquireReadPermissions(int count){
  if (count == 0)   return;
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,false);
  }
  if (record == null || count > record.failedReadAttempts) {
    throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  while (true) {
    if (current == _writer || (_writeReq == 0 && _writer == null)) {
      _numReaders++;
      record.failedReadAttempts-=count;
      record.readDepth=count;
      return;
    }
    try {
      wait();
    }
 catch (    InterruptedException ex) {
      throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
    }
  }
}"
75544,"/** 
 * Obtain permission to read objects in the workspace. This method suspends the calling thread until such permission has been obtained.  Permission is granted unless either another thread has write permission, or there are threads that have requested write permission and not gotten it yet. If this thread already has a read permission, then another permission is granted irrespective of other write requests. It is essential that doneReading() be called after this, or write permission may never again be granted in this workspace. If the workspace is read-only, the calling thread will not suspend, and will just return immediately from the method call. The pairing between the getReadAccess() and doneReading() methods is not checked under this condition.
 */
public final synchronized void getReadAccess(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,true);
  }
  if (record.readDepth > 0) {
    record.readDepth++;
    return;
  }
 else   if (current == _writer) {
    record.readDepth++;
    _numReaders++;
    return;
  }
  record.failedReadAttempts++;
  while (_writeReq != 0) {
    try {
      wait(this);
    }
 catch (    InterruptedException ex) {
      throw new InternalErrorException(current.getName() + ""String_Node_Str"" + ""String_Node_Str""+ ex.getMessage());
    }
  }
  record.failedReadAttempts--;
  record.readDepth++;
  _numReaders++;
  return;
}","/** 
 * Obtain permission to read objects in the workspace. This method suspends the calling thread until such permission has been obtained.  Permission is granted unless either another thread has write permission, or there are threads that have requested write permission and not gotten it yet. If this thread already has a read permission, then another permission is granted irrespective of other write requests. It is essential that doneReading() be called after this, or write permission may never again be granted in this workspace. If the workspace is read-only, the calling thread will not suspend, and will just return immediately from the method call. The pairing between the getReadAccess() and doneReading() methods is not checked under this condition.
 */
public final synchronized void getReadAccess(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,true);
  }
  if (record.readDepth > 0) {
    record.readDepth++;
    return;
  }
 else   if (current == _writer) {
    record.readDepth++;
    _numReaders++;
    return;
  }
  record.failedReadAttempts++;
  while (_writeReq != 0 || _writer != null) {
    try {
      wait();
    }
 catch (    InterruptedException ex) {
      throw new InternalErrorException(current.getName() + ""String_Node_Str"" + ""String_Node_Str""+ ex.getMessage());
    }
  }
  record.failedReadAttempts--;
  record.readDepth++;
  _numReaders++;
  return;
}"
75545,"/** 
 * Indicate that the calling thread is finished reading. If this thread is completely done reading (it has no other active read or write permissions), then wake up any threads that are suspended on access to this workspace so that they may contend for permissions. If the workspace is read-only, the pairing between the getReadAccess() and doneReading() methods is not checked.
 * @exception InvalidStateException If this method is calledbefore a corresponding call to getReadAccess().
 */
public final synchronized void doneReading(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,false);
  }
  if (record == null) {
    throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (record.readDepth > 0) {
    record.readDepth--;
    if (record.readDepth == 0) {
      _numReaders--;
      if (_numReaders == 0) {
        notifyAll();
      }
    }
  }
 else   if (record.failedReadAttempts > 0) {
    record.failedReadAttempts--;
  }
 else {
    throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Indicate that the calling thread is finished reading. If this thread is completely done reading (it has no other active read or write permissions), then wake up any threads that are suspended on access to this workspace so that they may contend for permissions. If the workspace is read-only, the pairing between the getReadAccess() and doneReading() methods is not checked.
 * @exception InvalidStateException If this method is calledbefore a corresponding call to getReadAccess().
 */
public final synchronized void doneReading(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,false);
  }
  if (record == null) {
    throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (record.readDepth > 0) {
    record.readDepth--;
    if (record.readDepth == 0) {
      _numReaders--;
      notifyAll();
    }
  }
 else   if (record.failedReadAttempts > 0) {
    record.failedReadAttempts--;
  }
 else {
    throw new InvalidStateException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
}"
75546,"/** 
 * Frees the thread of all the readAccesses on the workspace. The method _reacquireAllReadAccesses should be called after this method is called.
 * @return The number of readAccess that the thread possessed on theworkspace
 */
private synchronized int _releaseAllReadPermissions(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,false);
  }
  if (record == null || record.readDepth == 0) {
    return 0;
  }
 else {
    _numReaders--;
    if (_numReaders == 0) {
      notifyAll();
    }
    int result=record.readDepth;
    record.failedReadAttempts+=result;
    record.readDepth=0;
    return result;
  }
}","/** 
 * Frees the thread of all the readAccesses on the workspace. The method _reacquireAllReadAccesses should be called after this method is called.
 * @return The number of readAccess that the thread possessed on theworkspace
 */
private synchronized int _releaseAllReadPermissions(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,false);
  }
  if (record == null || record.readDepth == 0) {
    return 0;
  }
 else {
    _numReaders--;
    notifyAll();
    int result=record.readDepth;
    record.failedReadAttempts+=result;
    record.readDepth=0;
    return result;
  }
}"
75547,"/** 
 * Obtain permission to write to objects in the workspace. Permission is granted if there are no other threads that currently have read or write permission.  In particular, it <i>is</i> granted if this thread already has write permission, or if it is the only thread with read permission. This method suspends the calling thread until such permission has been obtained.  It is essential that doneWriting() be called after this, or read or write permission may never again be granted in this workspace.
 * @exception InvalidStateException If this method is called when theworkspace is read-only.
 */
public final synchronized void getWriteAccess(){
  Thread current=Thread.currentThread();
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,true);
  }
  _writeReq++;
  if (current == _writer) {
    _writeDepth++;
    return;
  }
  record.failedWriteAttempts++;
  while (true) {
    if (_writer == null) {
      if (_numReaders == 0) {
        _writer=current;
        _writeDepth=1;
        record.failedWriteAttempts--;
        return;
      }
 else       if (_numReaders == 1) {
        if (record != null && record.readDepth > 0) {
          _writer=current;
          _writeDepth=1;
          record.failedWriteAttempts--;
          return;
        }
      }
    }
    try {
      wait();
    }
 catch (    InterruptedException ex) {
      _writeReq--;
      throw new InternalErrorException(current.getName() + ""String_Node_Str"" + ""String_Node_Str""+ ex.getMessage());
    }
  }
}","/** 
 * Obtain permission to write to objects in the workspace. Permission is granted if there are no other threads that currently have read or write permission.  In particular, it <i>is</i> granted if this thread already has write permission, or if it is the only thread with read permission. This method suspends the calling thread until such permission has been obtained.  It is essential that doneWriting() be called after this, or read or write permission may never again be granted in this workspace.
 * @exception InvalidStateException If this method is called when theworkspace is read-only.
 */
public final synchronized void getWriteAccess(){
  Thread current=Thread.currentThread();
  if (current == _writer) {
    _writeDepth++;
    return;
  }
  AccessRecord record=null;
  if (current == _lastReader) {
    record=_lastReaderRecord;
  }
 else {
    record=_getAccessRecord(current,true);
  }
  _writeReq++;
  record.failedWriteAttempts++;
  try {
    while (true) {
      if (_writer == null) {
        if (_numReaders == 0 || _numReaders == 1 && record.readDepth > 0) {
          _writer=current;
          _writeDepth=1;
          record.failedWriteAttempts--;
          return;
        }
      }
      try {
        wait();
      }
 catch (      InterruptedException ex) {
        throw new InternalErrorException(current.getName() + ""String_Node_Str"" + ""String_Node_Str""+ ex.getMessage());
      }
    }
  }
  finally {
    _writeReq--;
    if (_writeReq == 0 && _writer == null) {
      notifyAll();
    }
  }
}"
75548,"/** 
 * Returns the C filename corresponding to a class.
 * @param className The name of a class.
 * @return The C fileName corresponding to this class.
 */
public static String classNameToFileName(String className){
  if (isSystemClass(className)) {
    return (Options.v().get(""String_Node_Str"") + ""String_Node_Str"" + _sanitize(className).replace('.','/'));
  }
 else {
    return (_sanitize(className));
  }
}","/** 
 * Returns the C filename corresponding to a class.
 * @param className The name of a class.
 * @return The C fileName corresponding to this class.
 */
public static String classNameToFileName(String className){
  if (isSystemClass(className)) {
    return (Options.v().get(""String_Node_Str"") + ""String_Node_Str"" + _sanitize(className).replace('.','/'));
  }
 else {
    return (_sanitize(className).replace('.','/'));
  }
}"
75549,"/** 
 * Write out the C (.i, .h, interface Header) files. Sample option arguments: <code>-p wjtp.writeJimple1 outDir:jimple1</code>
 * @param phaseName The name of the phase, for example<code>wjtp.writeJimple2</code>.
 * @param options The options Map.  This method uses the<code>outdir</code> option to specify where the .jimple file should be written
 */
public void internalTransform(String phaseName,Map options){
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  String outDir=soot.Options.getString(options,""String_Node_Str"");
  String mainFile=soot.Options.getString(options,""String_Node_Str"") + ""String_Node_Str"";
  OverriddenMethodGenerator.init();
  ArrayList classList=new ArrayList();
  for (Iterator classes=Scene.v().getApplicationClasses().iterator(); classes.hasNext(); classList.add(classes.next()))   ;
  StringBuffer sourcesList=new StringBuffer();
  for (Iterator sootClasses=classList.iterator(); sootClasses.hasNext(); ) {
    SootClass sootClass=(SootClass)sootClasses.next();
    String fileName;
    if (!outDir.equals(""String_Node_Str"")) {
      File outDirFile=new File(outDir);
      if (!outDirFile.isDirectory()) {
        outDirFile.mkdirs();
      }
      fileName=outDir + System.getProperty(""String_Node_Str"");
    }
 else {
      fileName=""String_Node_Str"";
    }
    fileName+=sootClass.getName();
    HeaderFileGenerator hGenerator=new HeaderFileGenerator();
    CodeFileGenerator cGenerator=new CodeFileGenerator();
    StubFileGenerator sGenerator=new StubFileGenerator();
    CNames.setup();
    RequiredFileGenerator RFG=new RequiredFileGenerator();
    String classPath=Scene.v().getSootClassPath();
    System.out.println(""String_Node_Str"" + classPath);
    Options.v().put(""String_Node_Str"",""String_Node_Str"");
    Options.v().put(""String_Node_Str"",""String_Node_Str"");
    Options.v().put(""String_Node_Str"",""String_Node_Str"");
    RFG.init(classPath,sootClass.getName());
    System.out.println(""String_Node_Str"" + mainFile);
    System.out.println(""String_Node_Str"" + sootClass.getName());
    boolean isMainClass=false;
    MainFileGenerator mGenerator=null;
    if (mainFile.equals(sootClass.getName())) {
      isMainClass=true;
      mGenerator=new MainFileGenerator();
    }
    System.out.println(""String_Node_Str"" + fileName);
    String code=null;
    code=sGenerator.generate(sootClass);
    FileHandler.write(fileName + StubFileGenerator.stubFileNameSuffix(),code);
    code=hGenerator.generate(sootClass);
    FileHandler.write(fileName + ""String_Node_Str"",code);
    code=cGenerator.generate(sootClass);
    FileHandler.write(fileName + ""String_Node_Str"",code);
    sourcesList.append(""String_Node_Str"" + fileName + ""String_Node_Str"");
    try {
      RFG.generateTransitiveClosureOf(classPath,sootClass.getName());
    }
 catch (    IOException exception) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (isMainClass) {
      code=mGenerator.generate(sootClass);
      FileHandler.write(fileName + ""String_Node_Str"",code);
    }
    System.out.println(""String_Node_Str"" + fileName);
  }
  MakefileWriter.addMakefileSubstitution(""String_Node_Str"",sourcesList.toString());
  _completedTransform=true;
}","/** 
 * Write out the C (.i, .h, interface Header) files. Sample option arguments: <code>-p wjtp.writeJimple1 outDir:jimple1</code>
 * @param phaseName The name of the phase, for example<code>wjtp.writeJimple2</code>.
 * @param options The options Map.  This method uses the<code>outdir</code> option to specify where the .jimple file should be written
 */
public void internalTransform(String phaseName,Map options){
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  String outDir=soot.Options.getString(options,""String_Node_Str"");
  String mainFile=soot.Options.getString(options,""String_Node_Str"") + ""String_Node_Str"";
  OverriddenMethodGenerator.init();
  ArrayList classList=new ArrayList();
  for (Iterator classes=Scene.v().getApplicationClasses().iterator(); classes.hasNext(); classList.add(classes.next()))   ;
  StringBuffer sourcesList=new StringBuffer();
  for (Iterator sootClasses=classList.iterator(); sootClasses.hasNext(); ) {
    SootClass sootClass=(SootClass)sootClasses.next();
    String fileName;
    fileName=CNames.classNameToFileName(sootClass.getName());
    HeaderFileGenerator hGenerator=new HeaderFileGenerator();
    CodeFileGenerator cGenerator=new CodeFileGenerator();
    StubFileGenerator sGenerator=new StubFileGenerator();
    CNames.setup();
    RequiredFileGenerator RFG=new RequiredFileGenerator();
    String classPath=Scene.v().getSootClassPath();
    System.out.println(""String_Node_Str"" + classPath);
    Options.v().put(""String_Node_Str"",""String_Node_Str"");
    Options.v().put(""String_Node_Str"",""String_Node_Str"");
    Options.v().put(""String_Node_Str"",""String_Node_Str"");
    RFG.init(classPath,sootClass.getName());
    System.out.println(""String_Node_Str"" + mainFile);
    System.out.println(""String_Node_Str"" + sootClass.getName());
    boolean isMainClass=false;
    MainFileGenerator mGenerator=null;
    if (mainFile.equals(sootClass.getName())) {
      isMainClass=true;
      mGenerator=new MainFileGenerator();
    }
    System.out.println(""String_Node_Str"" + fileName);
    String code=null;
    code=sGenerator.generate(sootClass);
    FileHandler.write(fileName + StubFileGenerator.stubFileNameSuffix(),code);
    code=hGenerator.generate(sootClass);
    FileHandler.write(fileName + ""String_Node_Str"",code);
    code=cGenerator.generate(sootClass);
    FileHandler.write(fileName + ""String_Node_Str"",code);
    sourcesList.append(""String_Node_Str"" + fileName + ""String_Node_Str"");
    try {
      RFG.generateTransitiveClosureOf(classPath,sootClass.getName());
    }
 catch (    IOException exception) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (isMainClass) {
      code=mGenerator.generate(sootClass);
      FileHandler.write(fileName + ""String_Node_Str"",code);
    }
    System.out.println(""String_Node_Str"" + fileName);
  }
  MakefileWriter.addMakefileSubstitution(""String_Node_Str"",sourcesList.toString());
  _completedTransform=true;
}"
75550,"/** 
 * Create the MakeFile.
 * @param classPath The classPath.
 * @param className The class for which the Makefile is to be generated.The makefile will have the name <i>className</i>.make.
 */
public static void generateMakeFile(String classPath,String className){
  boolean gc=Options.v().getBoolean(""String_Node_Str"");
  StringBuffer code=new StringBuffer();
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + NativeMethodGenerator.nativeBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + OverriddenMethodGenerator.overriddenBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + Options.v().get(""String_Node_Str"") + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
    code.append(""String_Node_Str"");
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
  HashSet libSources=RequiredFileGenerator.generateUserClasses(code);
  code.append(""String_Node_Str"");
  Iterator i=libSources.iterator();
  while (i.hasNext()) {
    code.append(""String_Node_Str"" + (String)i.next() + ""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + StubFileGenerator.stubFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + StubFileGenerator.stubFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  FileHandler.write(className + ""String_Node_Str"",code.toString());
}","/** 
 * Create the MakeFile.
 * @param classPath The classPath.
 * @param className The class for which the Makefile is to be generated.The makefile will have the name <i>className</i>.make.
 */
public static void generateMakeFile(String classPath,String className){
  boolean gc=Options.v().getBoolean(""String_Node_Str"");
  StringBuffer code=new StringBuffer();
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + NativeMethodGenerator.nativeBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + OverriddenMethodGenerator.overriddenBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + Options.v().get(""String_Node_Str"") + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
    code.append(""String_Node_Str"");
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
  HashSet libSources=RequiredFileGenerator.generateUserClasses(code);
  code.append(""String_Node_Str"");
  Iterator i=libSources.iterator();
  while (i.hasNext()) {
    code.append(""String_Node_Str"" + (String)i.next() + ""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + StubFileGenerator.stubFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + StubFileGenerator.stubFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  if (gc) {
    code.append(""String_Node_Str"");
  }
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  FileHandler.write(className + ""String_Node_Str"",code.toString());
}"
75551,"public void event(String actorName,double time,int scheduleEvent){
  try {
    if (scheduleEvent == -1) {
      if (plot != null) {
        plot.clear(true);
        _taskMap.clear();
        _taskState.clear();
      }
    }
 else {
      if (_taskMap != null) {
        Object taskID=_taskMap.get(actorName);
        int id;
        if (taskID == null) {
          id=_taskMap.size();
          _taskMap.put(actorName,new Integer(id));
          _taskState.add(new Integer(0));
          plot.addLegend(id,actorName);
        }
 else {
          id=((Integer)taskID).intValue();
        }
        int _oldState=((Integer)_taskState.get(id)).intValue();
        plot.addPoint(id,time,id + _oldState / 2.1,true);
        plot.addPoint(id,time,id + scheduleEvent / 2.1,true);
        plot.repaint();
        _taskState.set(id,new Integer(scheduleEvent));
      }
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","public void event(final String actorName,double time,int scheduleEvent){
  try {
    if (scheduleEvent == -1) {
      if (plot != null) {
        plot.clear(true);
        _taskMap.clear();
        _taskState.clear();
        System.out.println(""String_Node_Str"");
      }
    }
 else {
      if (_taskMap != null) {
        Object taskID=_taskMap.get(actorName);
        int id;
        if (taskID == null) {
          id=_taskMap.size();
          final int finalid=id;
          _taskMap.put(actorName,new Integer(id));
          _taskState.add(new Integer(0));
          System.out.println(""String_Node_Str"");
          Runnable doAddPoint=new Runnable(){
            public void run(){
              plot.addLegend(finalid,actorName);
            }
          }
;
          plot.deferIfNecessary(doAddPoint);
        }
 else {
          id=((Integer)taskID).intValue();
        }
        int _oldState=((Integer)_taskState.get(id)).intValue();
        plot.addPoint(id,time,id + _oldState / 2.1,true);
        plot.addPoint(id,time,id + scheduleEvent / 2.1,true);
        _taskState.set(id,new Integer(scheduleEvent));
        plot.repaint();
      }
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}"
75552,"/** 
 * Obtain permission to read objects in the workspace. This method suspends the calling thread until such permission has been obtained.  Permission is granted unless either another thread has write permission, or there are threads that have requested write permission and not gotten it yet. If this thread already has a read permission, then another permission is granted irrespective of other write requests. It is essential that doneReading() be called after this, or write permission may never again be granted in this workspace. If the workspace is read-only, the calling thread will not suspend, and will just return immediately from the method call. The pairing between the getReadAccess() and doneReading() methods is not checked under this condition.
 */
public final synchronized void getReadAccess(){
  if (_readOnly) {
    return;
  }
  while (true) {
    Thread current=Thread.currentThread();
    if (current instanceof PtolemyThread) {
      PtolemyThread ptThread=(PtolemyThread)current;
      if (ptThread.readDepth != 0) {
        ptThread.readDepth++;
        return;
      }
 else {
        if (current == _writer || _writeReq == 0) {
          ptThread.readDepth++;
          _numPtReaders++;
          return;
        }
      }
    }
 else {
      ReadDepth depth=(ReadDepth)_readers.get(current);
      if (depth != null) {
        depth.incr();
        return;
      }
 else {
        if (current == _writer || _writeReq == 0) {
          if (depth == null) {
            depth=new ReadDepth();
            _readers.put(current,depth);
          }
          depth.incr();
          return;
        }
      }
    }
    wait(this);
  }
}","/** 
 * Obtain permission to read objects in the workspace. This method suspends the calling thread until such permission has been obtained.  Permission is granted unless either another thread has write permission, or there are threads that have requested write permission and not gotten it yet. If this thread already has a read permission, then another permission is granted irrespective of other write requests. It is essential that doneReading() be called after this, or write permission may never again be granted in this workspace. If the workspace is read-only, the calling thread will not suspend, and will just return immediately from the method call. The pairing between the getReadAccess() and doneReading() methods is not checked under this condition.
 */
public final synchronized void getReadAccess(){
  if (_readOnly) {
    return;
  }
  Thread current=Thread.currentThread();
  while (true) {
    if (current instanceof PtolemyThread) {
      PtolemyThread ptThread=(PtolemyThread)current;
      if (ptThread.readDepth != 0) {
        ptThread.readDepth++;
        return;
      }
 else {
        if (current == _writer || _writeReq == 0) {
          ptThread.readDepth++;
          _numPtReaders++;
          return;
        }
      }
    }
 else {
      ReadDepth depth=(ReadDepth)_readers.get(current);
      if (depth != null) {
        depth.incr();
        return;
      }
 else {
        if (current == _writer || _writeReq == 0) {
          depth=new ReadDepth();
          _readers.put(current,depth);
          depth.incr();
          return;
        }
      }
    }
    wait(this);
  }
}"
75553,"/** 
 * Specify whether this workspace is read only. When the workspace is read only, calling getWriteAccess() or doneWriting() will result in a runtime exception, and calling getReadAccess() and doneReading() will return immediately. Accesses to topology information are considerably more efficient if the workspace is read only.
 * @param flagValue True to make the workspace read only, and falseotherwise.
 * @exception IllegalActionException If a thread has writeaccess on the workspace.
 */
public synchronized void setReadOnly(boolean flagValue) throws IllegalActionException {
  if (flagValue == true) {
    if (_writer != null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _readOnly=flagValue;
}","/** 
 * Specify whether this workspace is read only. When the workspace is read only, calling getWriteAccess() or doneWriting() will result in a runtime exception, and calling getReadAccess() and doneReading() will return immediately. Accesses to topology information are considerably more efficient if the workspace is read only.
 * @param flagValue True to make the workspace read only, and falseotherwise.
 * @exception IllegalActionException If a thread has writeaccess on the workspace.
 */
public synchronized void setReadOnly(boolean flagValue) throws IllegalActionException {
  if (flagValue == true) {
    if (_writer != null || (_readers.isEmpty() && _numPtReaders == 0)) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _readOnly=flagValue;
}"
75554,"/** 
 * Initialize this display.  If place() has not been called with a container into which to place the display, then create a new frame into which to put it.
 * @exception IllegalActionException If the parent class throws it,or if the numRows or numColumns parameters are incorrect, or if there is no effigy for the top level container, or if a problem occurs creating the effigy and tableau.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (textArea == null) {
    Effigy containerEffigy=Configuration.findEffigy(toplevel());
    if (containerEffigy == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + toplevel().getFullName());
    }
    try {
      TextEffigy textEffigy=TextEffigy.newTextEffigy(containerEffigy,""String_Node_Str"");
      textEffigy.identifier.setExpression(getFullName());
      DisplayWindowTableau tableau=new DisplayWindowTableau(textEffigy,""String_Node_Str"");
      _frame=tableau.frame;
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,null,ex,""String_Node_Str"");
    }
    textArea=_frame.text;
    int numRows=((IntToken)rowsDisplayed.getToken()).intValue();
    textArea.setRows(numRows);
    int numColumns=((IntToken)columnsDisplayed.getToken()).intValue();
    textArea.setColumns(numColumns);
    _windowProperties.setProperties(_frame);
  }
 else {
    textArea.setText(null);
  }
  if (_frame != null) {
    _frame.show();
  }
}","/** 
 * Initialize this display.  If place() has not been called with a container into which to place the display, then create a new frame into which to put it.
 * @exception IllegalActionException If the parent class throws it,or if the numRows or numColumns parameters are incorrect, or if there is no effigy for the top level container, or if a problem occurs creating the effigy and tableau.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (textArea == null) {
    Effigy containerEffigy=Configuration.findEffigy(toplevel());
    if (containerEffigy == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + toplevel().getFullName());
    }
    try {
      TextEffigy textEffigy=TextEffigy.newTextEffigy(containerEffigy,""String_Node_Str"");
      textEffigy.identifier.setExpression(getFullName());
      DisplayWindowTableau tableau=new DisplayWindowTableau(textEffigy,""String_Node_Str"");
      _frame=tableau.frame;
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,null,ex,""String_Node_Str"");
    }
    textArea=_frame.text;
    int numRows=((IntToken)rowsDisplayed.getToken()).intValue();
    textArea.setRows(numRows);
    int numColumns=((IntToken)columnsDisplayed.getToken()).intValue();
    textArea.setColumns(numColumns);
    _windowProperties.setProperties(_frame);
    _frame.show();
  }
 else {
    textArea.setText(null);
  }
}"
75555,"/** 
 * Override the base class to remove the display from its graphical container if the argument is null.
 * @param container The proposed container.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  Nameable previousContainer=getContainer();
  super.setContainer(container);
  if (container != previousContainer) {
    _remove();
  }
}","/** 
 * Override the base class to remove the display from its graphical container if the argument is null.
 * @param container The proposed container.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  Nameable previousContainer=getContainer();
  super.setContainer(container);
  if (container != previousContainer && previousContainer != null) {
    _remove();
  }
}"
75556,"/** 
 * Override the base class to remove the plot from its graphical container if the argument is null.
 * @param container The proposed container.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  Nameable previousContainer=getContainer();
  super.setContainer(container);
  if (container != previousContainer) {
    _remove();
  }
}","/** 
 * Override the base class to remove the plot from its graphical container if the argument is null.
 * @param container The proposed container.
 * @exception IllegalActionException If the base class throws it.
 * @exception NameDuplicationException If the base class throws it.
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  Nameable previousContainer=getContainer();
  super.setContainer(container);
  if (container != previousContainer && previousContainer != null) {
    _remove();
  }
}"
75557,"/** 
 * Advance time to the next event time (or the outside time if this director is embedded in another domain); if there are any tasks that finish at the current time, then finish the execution of the current task by calling the fire() method of that actors. If <i>synchronizeToRealTime</i> is true, then wait until the real time has caught up the current time.
 * @return True
 * @exception IllegalActionException If the execution methodof one of the actors throws it.
 */
public boolean prefire() throws IllegalActionException {
  if (_isEmbedded()) {
    _outsideTime=((CompositeActor)getContainer()).getExecutiveDirector().getCurrentTime();
  }
 else {
    _outsideTime=_nextIterationTime;
  }
  if (_debugging)   _debug(""String_Node_Str"" + _outsideTime,""String_Node_Str"" + getCurrentTime());
  if (!_isEmbedded() && _synchronizeToRealTime) {
    long elapsedTime=System.currentTimeMillis() - _realStartTime;
    double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
    if (Math.abs(_outsideTime - elapsedTimeInSeconds) > 1e-3) {
      long timeToWait=(long)((_outsideTime - elapsedTimeInSeconds) * 1000.0);
      if (timeToWait > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"" + timeToWait);
        }
synchronized (_eventQueue) {
          try {
            _eventQueue.wait(timeToWait);
          }
 catch (          InterruptedException ex) {
          }
        }
      }
    }
  }
  while (!_interruptQueue.isEmpty()) {
    DEEvent interruptEvent=(DEEvent)_interruptQueue.get();
    double timeStamp=interruptEvent.timeStamp();
    if ((timeStamp + 1e-10) < _outsideTime) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + timeStamp + ""String_Node_Str""+ getCurrentTime());
    }
 else     if (Math.abs(timeStamp - _outsideTime) < 1e-10) {
      _interruptQueue.take();
      Actor actor=interruptEvent.actor();
      if (actor != null) {
        if (actor.prefire()) {
          actor.fire();
          if (!actor.postfire()) {
            _disableActor(actor);
          }
        }
      }
    }
 else {
      break;
    }
  }
  if (!_eventQueue.isEmpty()) {
    TMEvent event=(TMEvent)_eventQueue.get();
    if (event.hasStarted()) {
      if (_debugging)       _debug(""String_Node_Str"" + (_outsideTime - getCurrentTime()),""String_Node_Str"",event.toString());
      event.timeProgress(_outsideTime - getCurrentTime());
      setCurrentTime(_outsideTime);
      if (Math.abs(event.processingTime()) < 1e-10) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",event.toString());
        _eventQueue.take();
        Actor actor=event.actor();
        actor.fire();
        _displaySchedule(((Nameable)actor).getName(),getCurrentTime(),ScheduleListener.TASK_SLEEPING);
        _displaySchedule();
        if (!actor.postfire()) {
          _disableActor(actor);
        }
      }
    }
  }
  setCurrentTime(_outsideTime);
  return true;
}","/** 
 * Advance time to the next event time (or the outside time if this director is embedded in another domain); if there are any tasks that finish at the current time, then finish the execution of the current task by calling the fire() method of that actors. If <i>synchronizeToRealTime</i> is true, then wait until the real time has caught up the current time.
 * @return True
 * @exception IllegalActionException If the execution methodof one of the actors throws it.
 */
public boolean prefire() throws IllegalActionException {
  if (_isEmbedded()) {
    _outsideTime=((CompositeActor)getContainer()).getExecutiveDirector().getCurrentTime();
  }
 else {
    _outsideTime=_nextIterationTime;
  }
  if (_debugging)   _debug(""String_Node_Str"" + _outsideTime,""String_Node_Str"" + getCurrentTime());
  if (!_isEmbedded() && _synchronizeToRealTime) {
    long elapsedTime=System.currentTimeMillis() - _realStartTime;
    double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
    if (Math.abs(_outsideTime - elapsedTimeInSeconds) > 1e-3) {
      long timeToWait=(long)((_outsideTime - elapsedTimeInSeconds) * 1000.0);
      if (timeToWait > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"" + timeToWait);
        }
synchronized (_eventQueue) {
          try {
            _eventQueue.wait(timeToWait);
          }
 catch (          InterruptedException ex) {
          }
        }
      }
    }
  }
  double cachedCurrentTime=getCurrentTime();
  setCurrentTime(_outsideTime);
  if (_debugging) {
    _debug(""String_Node_Str"" + _eventQueue.size());
  }
  if (!_eventQueue.isEmpty()) {
    TMEvent event=(TMEvent)_eventQueue.get();
    if (event.hasStarted()) {
      if (_debugging)       _debug(""String_Node_Str"" + (getCurrentTime() - cachedCurrentTime),""String_Node_Str"",event.toString());
      event.timeProgress(getCurrentTime() - cachedCurrentTime);
      if (_debugging)       _debug(""String_Node_Str"" + event.processingTime());
      if (Math.abs(event.processingTime()) < 1e-10) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",event.toString());
        _eventQueue.take();
        Actor actor=event.actor();
        actor.fire();
        _displaySchedule(((Nameable)actor).getName(),getCurrentTime(),ScheduleListener.TASK_SLEEPING);
        _displaySchedule();
        if (!actor.postfire()) {
          _disableActor(actor);
        }
      }
 else {
        if (_debugging)         _debug(getName(),""String_Node_Str"" + event.processingTime());
      }
    }
  }
  while (!_interruptQueue.isEmpty()) {
    DEEvent interruptEvent=(DEEvent)_interruptQueue.get();
    double timeStamp=interruptEvent.timeStamp();
    if ((timeStamp + 1e-10) < _outsideTime) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + timeStamp + ""String_Node_Str""+ getCurrentTime());
    }
 else     if (Math.abs(timeStamp - _outsideTime) < 1e-10) {
      _interruptQueue.take();
      Actor actor=interruptEvent.actor();
      if (actor != null) {
        if (actor.prefire()) {
          actor.fire();
          if (!actor.postfire()) {
            _disableActor(actor);
          }
        }
      }
    }
 else {
      break;
    }
  }
  return true;
}"
75558,"/** 
 * Execute the model for one iteration. It first compare the current time to the time stamp of the first event in the interrupt event queue. If they are equal, then dequeue the events at the current time from the interrupt event queue, and fire the destination actors. If the current time is less than the time stamp of the first event in the interrupt event queue, then look at the TM event queue. Pick the task with the highest priority and start/continue its execution. If the task has <i>executionTime</i> being zero, then finish that task. Otherwise, finish its execution util time advances.
 * @exception IllegalActionException If an interrupt is in the past,or one of the execution methods of an actor throws it.
 */
public void fire() throws IllegalActionException {
  _nextIterationTime=((DoubleToken)stopTime.getToken()).doubleValue();
  while (!_interruptQueue.isEmpty()) {
    DEEvent interruptEvent=(DEEvent)_interruptQueue.get();
    double timeStamp=interruptEvent.timeStamp();
    if ((timeStamp + 1e-10) < getCurrentTime()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + timeStamp + ""String_Node_Str""+ getCurrentTime());
    }
 else     if (timeStamp == getCurrentTime()) {
      _interruptQueue.take();
      Actor actor=interruptEvent.actor();
      if (actor != null) {
        if (actor.prefire()) {
          actor.fire();
          if (!actor.postfire()) {
            _disableActor(actor);
          }
        }
      }
    }
 else {
      _nextIterationTime=timeStamp;
      break;
    }
  }
  TMEvent event=null;
  while (!_eventQueue.isEmpty()) {
    event=(TMEvent)_eventQueue.get();
    if (_debugging)     _debug(""String_Node_Str"",event.toString());
    if (!event.hasStarted()) {
      if (_debugging)       _debug(getName(),""String_Node_Str"",event.toString(),""String_Node_Str"" + ((NamedObj)event.actor()).getName() + ""String_Node_Str"");
      event.receiver()._triggerEvent(event.token());
      Actor actor=event.actor();
      if (actor == getContainer() || !actor.prefire()) {
        _eventQueue.take();
        event=null;
      }
 else {
        double processingTime=((DoubleToken)defaultTaskExecutionTime.getToken()).doubleValue();
        if (actor instanceof TMActor) {
          processingTime=((TMActor)actor).getExecutionTime();
        }
 else {
          Parameter executionTime=(Parameter)((IOPort)event.receiver().getContainer()).getAttribute(""String_Node_Str"");
          if (executionTime == null) {
            executionTime=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
          }
          if (executionTime != null) {
            processingTime=((DoubleToken)executionTime.getToken()).doubleValue();
          }
        }
        if (processingTime == 0.0) {
          if (_debugging)           _debug(getName(),event.toString(),""String_Node_Str"");
          _eventQueue.take();
          actor.fire();
          _displaySchedule(((Nameable)actor).getName(),getCurrentTime(),ScheduleListener.TASK_SLEEPING);
          _displaySchedule();
          if (!actor.postfire()) {
            _disableActor(actor);
          }
        }
 else {
          event.setProcessingTime(processingTime);
          if (_debugging)           _debug(""String_Node_Str"",event.toString());
          _preemptive=((BooleanToken)preemptive.getToken()).booleanValue();
          if (!_preemptive) {
            event=(TMEvent)_eventQueue.take();
            event.startProcessing();
            event.setPriority(0);
            _eventQueue.put(event);
          }
 else {
            event.startProcessing();
          }
          if (_debugging)           _debug(""String_Node_Str"",event.toString());
          _displaySchedule();
          break;
        }
      }
    }
 else {
      break;
    }
  }
  if (event != null && event.processingTime() > 0) {
    double finishTime=getCurrentTime() + event.processingTime();
    if (_debugging)     _debug(""String_Node_Str"" + finishTime);
    if (finishTime < _nextIterationTime) {
      _nextIterationTime=finishTime;
    }
  }
  if (_isEmbedded() && _nextIterationTime < Double.MAX_VALUE) {
    _requestFiringAt(_nextIterationTime);
  }
}","/** 
 * Execute the model for one iteration. It first compare the current time to the time stamp of the first event in the interrupt event queue. If they are equal, then dequeue the events at the current time from the interrupt event queue, and fire the destination actors. If the current time is less than the time stamp of the first event in the interrupt event queue, then look at the TM event queue. Pick the task with the highest priority and start/continue its execution. If the task has <i>executionTime</i> being zero, then finish that task. Otherwise, finish its execution util time advances.
 * @exception IllegalActionException If an interrupt is in the past,or one of the execution methods of an actor throws it.
 */
public void fire() throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"");
  _nextIterationTime=((DoubleToken)stopTime.getToken()).doubleValue();
  while (!_interruptQueue.isEmpty()) {
    DEEvent interruptEvent=(DEEvent)_interruptQueue.get();
    double timeStamp=interruptEvent.timeStamp();
    if ((timeStamp + 1e-10) < getCurrentTime()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + timeStamp + ""String_Node_Str""+ getCurrentTime());
    }
 else     if (timeStamp == getCurrentTime()) {
      _interruptQueue.take();
      Actor actor=interruptEvent.actor();
      if (actor != null) {
        if (actor.prefire()) {
          actor.fire();
          if (!actor.postfire()) {
            _disableActor(actor);
          }
        }
      }
    }
 else {
      _nextIterationTime=timeStamp;
      break;
    }
  }
  TMEvent event=null;
  while (!_eventQueue.isEmpty()) {
    event=(TMEvent)_eventQueue.get();
    if (_debugging)     _debug(""String_Node_Str"",event.toString());
    if (!event.hasStarted()) {
      if (_debugging)       _debug(getName(),""String_Node_Str"",event.toString(),""String_Node_Str"" + ((NamedObj)event.actor()).getName() + ""String_Node_Str"");
      event.receiver()._triggerEvent(event.token());
      Actor actor=event.actor();
      if (actor == getContainer() || !actor.prefire()) {
        _eventQueue.take();
        event=null;
      }
 else {
        double processingTime=((DoubleToken)defaultTaskExecutionTime.getToken()).doubleValue();
        if (actor instanceof TMActor) {
          processingTime=((TMActor)actor).getExecutionTime();
        }
 else {
          Parameter executionTime=(Parameter)((IOPort)event.receiver().getContainer()).getAttribute(""String_Node_Str"");
          if (executionTime == null) {
            executionTime=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
          }
          if (executionTime != null) {
            processingTime=((DoubleToken)executionTime.getToken()).doubleValue();
          }
        }
        if (processingTime == 0.0) {
          if (_debugging)           _debug(getName(),event.toString(),""String_Node_Str"");
          _eventQueue.take();
          actor.fire();
          _displaySchedule(((Nameable)actor).getName(),getCurrentTime(),ScheduleListener.TASK_SLEEPING);
          _displaySchedule();
          if (!actor.postfire()) {
            _disableActor(actor);
          }
        }
 else {
          event.setProcessingTime(processingTime);
          if (_debugging)           _debug(""String_Node_Str"",event.toString());
          _preemptive=((BooleanToken)preemptive.getToken()).booleanValue();
          if (!_preemptive) {
            event=(TMEvent)_eventQueue.take();
            event.startProcessing();
            event.setPriority(0);
            _eventQueue.put(event);
          }
 else {
            event.startProcessing();
          }
          if (_debugging)           _debug(""String_Node_Str"",event.toString());
          _displaySchedule();
          break;
        }
      }
    }
 else {
      break;
    }
  }
  if (event != null && event.processingTime() > 0) {
    double finishTime=getCurrentTime() + event.processingTime();
    if (_debugging)     _debug(""String_Node_Str"" + finishTime);
    if (finishTime < _nextIterationTime) {
      _nextIterationTime=finishTime;
    }
  }
  if (_isEmbedded() && _nextIterationTime < Double.MAX_VALUE) {
    _requestFiringAt(_nextIterationTime);
  }
}"
75559,"/** 
 * Return true if the transition is enabled, that is the guard is true, or some event has been detected.
 * @return True if the transition is enabled and some event is detected.
 * @exception IllegalActionException If thrown when evaluating the guard.
 */
public boolean isEnabled() throws IllegalActionException {
  try {
    if (!_relationList.isEmpty()) {
      _parseTreeEvaluator.setEvaluationPhase(false);
    }
    Token token=_guard.getToken();
    if (token == null) {
      return false;
    }
    boolean result=((BooleanToken)token).booleanValue() || _relationList.hasEvent();
    return result;
  }
 catch (  UnknownResultException ex) {
    return false;
  }
}","/** 
 * Return true if the transition is enabled, that is the guard is true, or some event has been detected.
 * @return True if the transition is enabled and some event is detected.
 * @exception IllegalActionException If thrown when evaluating the guard.
 */
public boolean isEnabled() throws IllegalActionException {
  try {
    if (!_relationList.isEmpty()) {
      _parseTreeEvaluator.setEvaluationMode(false);
    }
    Token token=_guard.getToken();
    if (token == null) {
      return false;
    }
    boolean result=((BooleanToken)token).booleanValue() || _relationList.hasEvent();
    return result;
  }
 catch (  UnknownResultException ex) {
    return false;
  }
}"
75560,"/** 
 * Construct a parse tree evaluator for guard expression. The relatoin list is used to store the information of the relation nodes and leaf nodes with boolean tokens. If the relation list is empty, the evaluator is in construction mode, otherwise, it is in update mode.
 * @param relationList The relation list.
 */
public ParseTreeEvaluatorForGuardExpression(RelationList relationList){
  if (relationList.isEmpty()) {
    _construction=true;
  }
 else {
    _construction=false;
  }
  _relationList=relationList;
}","/** 
 * Construct a parse tree evaluator for guard expression. The relatoin list is used to store the information of the relation nodes and leaf nodes with boolean tokens. If the relation list is empty, the evaluator is in construction mode, otherwise, it is in update mode.
 * @param relationList The relation list.
 */
public ParseTreeEvaluatorForGuardExpression(RelationList relationList){
  if (relationList.isEmpty()) {
    _construction=true;
  }
 else {
    _construction=false;
  }
  _relationList=relationList;
  _relationIndex=0;
  _absentDiscreteVariables=new LinkedList();
  _variableCollector=new ParseTreeFreeVariableCollector();
}"
75561,"/** 
 * Visit the leaf node. It is evaluated the same way as normal parse tree evaluator, except that if the the result is a boolean token, the information about the node (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The leaf node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitLeafNode throws the IllegalActionException.
 */
public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  super.visitLeafNode(node);
  ptolemy.data.Token result=node.getToken();
  if (!(result instanceof BooleanToken))   return;
  if (((BooleanToken)result).booleanValue()) {
    _relationType=1;
  }
 else {
    _relationType=2;
  }
  _difference=0.0;
  if (_construction) {
    _relationList.addRelation(_relationType,_difference);
  }
 else {
    _relationList.setRelation(_relationType,_difference);
  }
}","/** 
 * Visit the leaf node. It is evaluated the same way as normal parse tree evaluator, except that if the the result is a boolean token, the information about the node (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The leaf node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitLeafNode throws the IllegalActionException.
 */
public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  String nodeName=node.getName();
  String discreteVariableName=""String_Node_Str"";
  if (nodeName != null) {
    int variableNameEndIndex=nodeName.indexOf(""String_Node_Str"");
    if (variableNameEndIndex != -1) {
      discreteVariableName=nodeName.substring(0,variableNameEndIndex);
    }
  }
  if (_absentDiscreteVariables.contains(nodeName)) {
    node.setToken(new BooleanToken(false));
    if (_construction) {
      _relationList.addRelation(0,0.0);
    }
    _relationIndex++;
    return;
  }
  super.visitLeafNode(node);
  ptolemy.data.Token result=node.getToken();
  if (!(result instanceof BooleanToken))   return;
  if (((BooleanToken)result).booleanValue()) {
    _relationType=1;
    if (_absentDiscreteVariables.contains(discreteVariableName)) {
      _absentDiscreteVariables.remove(discreteVariableName);
    }
  }
 else {
    _relationType=2;
    if (!_absentDiscreteVariables.contains(discreteVariableName)) {
      _absentDiscreteVariables.add(discreteVariableName);
    }
  }
  _difference=0.0;
  if (_construction) {
    _relationList.addRelation(_relationType,_difference);
  }
 else {
    _relationList.setRelation(_relationIndex,_relationType,_difference);
  }
  _relationIndex++;
}"
75562,"/** 
 * Visit the relation node. The evaluation part is the same as normal parseTreeEvaluator, except that information about each relation (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The relation node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitRelationNode throws the IllegalActionException.
 */
public void visitRelationalNode(ASTPtRelationalNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    return;
  }
  ptolemy.data.Token[] tokens=_evaluateAllChildren(node);
  int numChildren=node.jjtGetNumChildren();
  _assert(numChildren == 2,node,""String_Node_Str"");
  ptolemy.data.expr.Token operator=(ptolemy.data.expr.Token)node.getOperator();
  ptolemy.data.Token leftToken=tokens[0];
  ptolemy.data.Token rightToken=tokens[1];
  ptolemy.data.Token result;
  if (operator.kind == PtParserConstants.EQUALS || operator.kind == PtParserConstants.NOTEQUALS) {
    if (operator.kind == PtParserConstants.EQUALS) {
      result=leftToken.isEqualTo(rightToken);
    }
 else {
      result=leftToken.isEqualTo(rightToken).not();
    }
    if ((leftToken instanceof BooleanToken) && (rightToken instanceof BooleanToken)) {
      if (((BooleanToken)result).booleanValue()) {
        _relationType=1;
      }
 else {
        _relationType=2;
      }
      _difference=0.0;
    }
 else {
      ScalarToken difference=(ScalarToken)leftToken.subtract(rightToken);
      if (((BooleanToken)result).booleanValue()) {
        _relationType=3;
      }
 else {
        if (difference.doubleValue() < 0) {
          _relationType=4;
        }
 else {
          _relationType=5;
        }
      }
      _difference=difference.absolute().doubleValue();
    }
  }
 else {
    if (!((leftToken instanceof ScalarToken) && (rightToken instanceof ScalarToken))) {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str"");
    }
    ScalarToken leftScalar=(ScalarToken)leftToken;
    ScalarToken rightScalar=(ScalarToken)rightToken;
    if (operator.kind == PtParserConstants.GTE) {
      result=leftScalar.isLessThan(rightScalar).not();
    }
 else     if (operator.kind == PtParserConstants.GT) {
      result=rightScalar.isLessThan(leftScalar);
    }
 else     if (operator.kind == PtParserConstants.LTE) {
      result=rightScalar.isLessThan(leftScalar).not();
    }
 else     if (operator.kind == PtParserConstants.LT) {
      result=leftScalar.isLessThan(rightScalar);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str""+ leftToken.getClass().getName()+ ""String_Node_Str""+ rightToken.getClass().getName());
    }
    if (((BooleanToken)result).booleanValue()) {
      _relationType=1;
    }
 else {
      _relationType=2;
    }
    _difference=((ScalarToken)leftScalar.subtract(rightScalar)).absolute().doubleValue();
  }
  node.setToken(result);
  if (_construction) {
    _relationList.addRelation(_relationType,_difference);
  }
 else {
    _relationList.setRelation(_relationType,_difference);
  }
  return;
}","/** 
 * Visit the relation node. The evaluation part is the same as normal parseTreeEvaluator, except that information about each relation (the difference and relationType) is either added into the relation list or used to update the according element in the relation list, depending on the evaluator mode.
 * @param node The relation node to be evaluated.
 * @exception IllegalActionException If the super class methodvisitRelationNode throws the IllegalActionException.
 */
public void visitRelationalNode(ASTPtRelationalNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    return;
  }
  Set variablesOfNode=_variableCollector.collectFreeVariables(node);
  Iterator absentDiscreteVariables=_absentDiscreteVariables.listIterator();
  while (absentDiscreteVariables.hasNext()) {
    String variableName=(String)absentDiscreteVariables.next();
    if (variablesOfNode.contains(variableName)) {
      node.setToken(new BooleanToken(false));
      if (_construction) {
        _relationList.addRelation(0,0.0);
      }
      _relationIndex++;
      return;
    }
  }
  ptolemy.data.Token[] tokens=_evaluateAllChildren(node);
  int numChildren=node.jjtGetNumChildren();
  _assert(numChildren == 2,node,""String_Node_Str"");
  ptolemy.data.expr.Token operator=(ptolemy.data.expr.Token)node.getOperator();
  ptolemy.data.Token leftToken=tokens[0];
  ptolemy.data.Token rightToken=tokens[1];
  ptolemy.data.Token result;
  if (operator.kind == PtParserConstants.EQUALS || operator.kind == PtParserConstants.NOTEQUALS) {
    if (operator.kind == PtParserConstants.EQUALS) {
      result=leftToken.isEqualTo(rightToken);
    }
 else {
      result=leftToken.isEqualTo(rightToken).not();
    }
    if ((leftToken instanceof BooleanToken) && (rightToken instanceof BooleanToken)) {
      if (((BooleanToken)result).booleanValue()) {
        _relationType=1;
      }
 else {
        _relationType=2;
      }
      _difference=0.0;
    }
 else {
      ScalarToken difference=(ScalarToken)leftToken.subtract(rightToken);
      if (((BooleanToken)result).booleanValue()) {
        _relationType=3;
      }
 else {
        if (difference.doubleValue() < 0) {
          _relationType=4;
        }
 else {
          _relationType=5;
        }
      }
      _difference=difference.absolute().doubleValue();
    }
  }
 else {
    if (!((leftToken instanceof ScalarToken) && (rightToken instanceof ScalarToken))) {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str"");
    }
    ScalarToken leftScalar=(ScalarToken)leftToken;
    ScalarToken rightScalar=(ScalarToken)rightToken;
    if (operator.kind == PtParserConstants.GTE) {
      result=leftScalar.isLessThan(rightScalar).not();
    }
 else     if (operator.kind == PtParserConstants.GT) {
      result=rightScalar.isLessThan(leftScalar);
    }
 else     if (operator.kind == PtParserConstants.LTE) {
      result=rightScalar.isLessThan(leftScalar).not();
    }
 else     if (operator.kind == PtParserConstants.LT) {
      result=leftScalar.isLessThan(rightScalar);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + operator.image + ""String_Node_Str""+ leftToken.getClass().getName()+ ""String_Node_Str""+ rightToken.getClass().getName());
    }
    if (((BooleanToken)result).booleanValue()) {
      _relationType=1;
    }
 else {
      _relationType=2;
    }
    _difference=((ScalarToken)leftScalar.subtract(rightScalar)).absolute().doubleValue();
  }
  node.setToken(result);
  if (_construction) {
    _relationList.addRelation(_relationType,_difference);
  }
 else {
    _relationList.setRelation(_relationIndex,_relationType,_difference);
  }
  _relationIndex++;
  return;
}"
75563,"/** 
 * Constructor to construct a relation node with given type and difference information.
 */
public RelationNode(int type,double difference){
  _currentType=type;
  _formerType=type;
  _difference=difference;
}","/** 
 * Constructor to construct a relation node with given type and difference information.
 */
public RelationNode(int type,double difference){
  _currentType=type;
  _formerType=type;
  _difference=difference;
  _formerDifference=difference;
}"
75564,"/** 
 * Update the according relation in the relation list with the given type and difference information.
 * @parameter type The current type of the relation.
 * @parameter difference The current difference of the relation.
 */
public void setRelation(int type,double difference){
  RelationNode relationNode=(RelationNode)_relationList.get(_index);
  relationNode.setValue(type);
  relationNode.setDifference(difference);
  _index++;
  if (_index == _relationNumber) {
    _index-=_relationNumber;
  }
}","/** 
 * Update the according relation in the relation list with the given type and difference information.
 * @parameter type The current type of the relation.
 * @parameter difference The current difference of the relation.
 */
public void setRelation(int relationIndex,int type,double difference){
  int index=relationIndex - relationIndex / _relationNumber * _relationNumber;
  RelationNode relationNode=(RelationNode)_relationList.get(index);
  relationNode.setValue(type);
  relationNode.setDifference(difference);
}"
75565,"/** 
 * Return a conversion to convert the second argument into the class given by the first argument. If no such conversion is possible, then the returned conversion is IMPOSSIBLE.
 */
protected static ArgumentConversion _getConversion(Class formal,Type actual){
  if (formal.isAssignableFrom(actual.getTokenClass()))   return IDENTITY;
  if (actual instanceof ArrayType && formal.isArray() && formal.getComponentType().isAssignableFrom(ptolemy.data.Token.class))   return ARRAYTOKEN;
  try {
    Class typeClass=ASTPtFunctionNode.convertTokenTypeToJavaType(actual);
    if (formal.isAssignableFrom(ASTPtFunctionNode.convertTokenTypeToJavaType(actual))) {
      return NATIVE;
    }
  }
 catch (  IllegalActionException ex) {
  }
  try {
    if (formal.isPrimitive()) {
      Type type=ASTPtFunctionNode.convertJavaTypeToTokenType(formal);
      if (ptolemy.graph.CPO.LOWER == TypeLattice.compare(actual,type)) {
        return NATIVE;
      }
    }
  }
 catch (  IllegalActionException ex) {
  }
  return IMPOSSIBLE;
}","/** 
 * Return a conversion to convert the second argument into the class given by the first argument. If no such conversion is possible, then the returned conversion is IMPOSSIBLE.
 */
protected static ArgumentConversion _getConversion(Class formal,Type actual){
  if (formal.isAssignableFrom(actual.getTokenClass()))   return IDENTITY;
  if (actual instanceof ArrayType && formal.isArray() && formal.getComponentType().isAssignableFrom(ptolemy.data.Token.class))   return ARRAYTOKEN;
  try {
    if (formal.isAssignableFrom(ASTPtFunctionNode.convertTokenTypeToJavaType(actual))) {
      return NATIVE;
    }
  }
 catch (  IllegalActionException ex) {
  }
  try {
    if (formal.isPrimitive()) {
      Type type=ASTPtFunctionNode.convertJavaTypeToTokenType(formal);
      if (ptolemy.graph.CPO.LOWER == TypeLattice.compare(actual,type)) {
        return NATIVE;
      }
    }
  }
 catch (  IllegalActionException ex) {
  }
  return IMPOSSIBLE;
}"
75566,"/** 
 * Initialize this actor.  If the types stored in the type parameters do not correspond to the types of corresponding typeable objects in the model, then throw an exception indicating a failed regression test.
 * @exception IllegalActionException If the test fails.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  ArrayList portActorNameList=new ArrayList();
  ArrayList parameterActorNameList=new ArrayList();
  ArrayList portAssignments=new ArrayList();
  ArrayList parameterAssignments=new ArrayList();
  List entityList=((CompositeEntity)getContainer()).entityList();
  for (Iterator i=entityList.iterator(); i.hasNext(); ) {
    ComponentEntity entity=(ComponentEntity)i.next();
    if (entity.equals(this)) {
      continue;
    }
    ArrayList portNames=new ArrayList();
    ArrayList portTypes=new ArrayList();
    for (Iterator ports=entity.portList().iterator(); ports.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)ports.next();
      portNames.add(port.getName());
      portTypes.add(new StringToken(port.getType().toString()));
    }
    if (portNames.size() > 0) {
      portActorNameList.add(entity.getName());
      portAssignments.add(new RecordToken((String[])portNames.toArray(new String[portNames.size()]),(Token[])portTypes.toArray(new Token[portTypes.size()])));
    }
    ArrayList paramNames=new ArrayList();
    ArrayList paramTypes=new ArrayList();
    for (Iterator params=entity.attributeList(Parameter.class).iterator(); params.hasNext(); ) {
      Parameter param=(Parameter)params.next();
      paramNames.add(param.getName());
      paramTypes.add(new StringToken(param.getType().toString()));
    }
    if (paramNames.size() > 0) {
      parameterActorNameList.add(entity.getName());
      parameterAssignments.add(new RecordToken((String[])paramNames.toArray(new String[paramNames.size()]),(Token[])paramTypes.toArray(new Token[paramTypes.size()])));
    }
  }
  RecordToken actualPortTypes=new RecordToken((String[])portActorNameList.toArray(new String[portActorNameList.size()]),(Token[])portAssignments.toArray(new Token[portAssignments.size()]));
  RecordToken actualParameterTypes=new RecordToken((String[])parameterActorNameList.toArray(new String[parameterActorNameList.size()]),(Token[])parameterAssignments.toArray(new Token[parameterAssignments.size()]));
  if (((BooleanToken)trainingMode.getToken()).booleanValue()) {
    if (NonStrictTest.isRunningNightlyBuild()) {
      throw new IllegalActionException(this,NonStrictTest.TRAINING_MODE_ERROR_MESSAGE);
    }
 else {
      System.err.println(""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    portTypes.setToken(actualPortTypes);
    parameterTypes.setToken(actualParameterTypes);
  }
 else {
    RecordToken correctPortTypes=(RecordToken)portTypes.getToken();
    RecordToken correctParameterTypes=(RecordToken)parameterTypes.getToken();
    for (Iterator actorNames=correctPortTypes.labelSet().iterator(); actorNames.hasNext(); ) {
      String actorName=(String)actorNames.next();
      RecordToken assignment=(RecordToken)correctPortTypes.get(actorName);
      for (Iterator names=assignment.labelSet().iterator(); names.hasNext(); ) {
        String name=(String)names.next();
        StringToken value=(StringToken)assignment.get(name);
        if (actualPortTypes == null) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
        if (actualPortTypes.get(actorName) == null) {
          throw new IllegalActionException(this,""String_Node_Str"" + actorName + ""String_Node_Str""+ ""String_Node_Str"");
        }
        StringToken actualValue=(StringToken)((RecordToken)actualPortTypes.get(actorName)).get(name);
        if (!value.equals(actualValue)) {
          throw new IllegalActionException(this,""String_Node_Str"" + ((CompositeEntity)getContainer()).getEntity(actorName).getFullName() + ""String_Node_Str""+ name+ ""String_Node_Str""+ value+ ""String_Node_Str""+ actualValue+ ""String_Node_Str"");
        }
      }
    }
    for (Iterator actorNames=correctParameterTypes.labelSet().iterator(); actorNames.hasNext(); ) {
      String actorName=(String)actorNames.next();
      RecordToken assignment=(RecordToken)correctParameterTypes.get(actorName);
      for (Iterator names=assignment.labelSet().iterator(); names.hasNext(); ) {
        String name=(String)names.next();
        StringToken value=(StringToken)assignment.get(name);
        StringToken actualValue=(StringToken)((RecordToken)actualParameterTypes.get(actorName)).get(name);
        if (!value.equals(actualValue)) {
          throw new IllegalActionException(this,""String_Node_Str"" + ((CompositeEntity)getContainer()).getEntity(actorName).getFullName() + ""String_Node_Str""+ name+ ""String_Node_Str""+ value+ ""String_Node_Str""+ actualValue+ ""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Initialize this actor.  If the types stored in the type parameters do not correspond to the types of corresponding typeable objects in the model, then throw an exception indicating a failed regression test.
 * @exception IllegalActionException If the test fails.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  ArrayList portActorNameList=new ArrayList();
  ArrayList parameterActorNameList=new ArrayList();
  ArrayList portAssignments=new ArrayList();
  ArrayList parameterAssignments=new ArrayList();
  List entityList=((CompositeEntity)getContainer()).entityList();
  for (Iterator i=entityList.iterator(); i.hasNext(); ) {
    ComponentEntity entity=(ComponentEntity)i.next();
    if (entity.equals(this)) {
      continue;
    }
    ArrayList portNames=new ArrayList();
    ArrayList portTypes=new ArrayList();
    for (Iterator ports=entity.portList().iterator(); ports.hasNext(); ) {
      TypedIOPort port=(TypedIOPort)ports.next();
      portNames.add(port.getName());
      portTypes.add(new StringToken(port.getType().toString()));
    }
    if (portNames.size() > 0) {
      portActorNameList.add(entity.getName());
      portAssignments.add(new RecordToken((String[])portNames.toArray(new String[portNames.size()]),(Token[])portTypes.toArray(new Token[portTypes.size()])));
    }
    ArrayList paramNames=new ArrayList();
    ArrayList paramTypes=new ArrayList();
    for (Iterator params=entity.attributeList(Parameter.class).iterator(); params.hasNext(); ) {
      Parameter param=(Parameter)params.next();
      paramNames.add(param.getName());
      paramTypes.add(new StringToken(param.getType().toString()));
    }
    if (paramNames.size() > 0) {
      parameterActorNameList.add(entity.getName());
      parameterAssignments.add(new RecordToken((String[])paramNames.toArray(new String[paramNames.size()]),(Token[])paramTypes.toArray(new Token[paramTypes.size()])));
    }
  }
  RecordToken actualPortTypes=new RecordToken((String[])portActorNameList.toArray(new String[portActorNameList.size()]),(Token[])portAssignments.toArray(new Token[portAssignments.size()]));
  RecordToken actualParameterTypes=new RecordToken((String[])parameterActorNameList.toArray(new String[parameterActorNameList.size()]),(Token[])parameterAssignments.toArray(new Token[parameterAssignments.size()]));
  if (((BooleanToken)trainingMode.getToken()).booleanValue()) {
    if (NonStrictTest.isRunningNightlyBuild()) {
      throw new IllegalActionException(this,NonStrictTest.TRAINING_MODE_ERROR_MESSAGE);
    }
 else {
      System.err.println(""String_Node_Str"" + this.getFullName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (actualPortTypes.length() > 0) {
      portTypes.setToken(actualPortTypes);
    }
 else {
      portTypes.setToken(null);
    }
    if (actualParameterTypes.length() > 0) {
      parameterTypes.setToken(actualParameterTypes);
    }
 else {
      parameterTypes.setToken(null);
    }
  }
 else {
    RecordToken correctPortTypes=(RecordToken)portTypes.getToken();
    RecordToken correctParameterTypes=(RecordToken)parameterTypes.getToken();
    if (correctPortTypes != null) {
      for (Iterator actorNames=correctPortTypes.labelSet().iterator(); actorNames.hasNext(); ) {
        String actorName=(String)actorNames.next();
        RecordToken assignment=(RecordToken)correctPortTypes.get(actorName);
        for (Iterator names=assignment.labelSet().iterator(); names.hasNext(); ) {
          String name=(String)names.next();
          StringToken value=(StringToken)assignment.get(name);
          if (actualPortTypes == null) {
            throw new IllegalActionException(this,""String_Node_Str"");
          }
          if (actualPortTypes.get(actorName) == null) {
            throw new IllegalActionException(this,""String_Node_Str"" + actorName + ""String_Node_Str""+ ""String_Node_Str"");
          }
          StringToken actualValue=(StringToken)((RecordToken)actualPortTypes.get(actorName)).get(name);
          if (!value.equals(actualValue)) {
            throw new IllegalActionException(this,""String_Node_Str"" + ((CompositeEntity)getContainer()).getEntity(actorName).getFullName() + ""String_Node_Str""+ name+ ""String_Node_Str""+ value+ ""String_Node_Str""+ actualValue+ ""String_Node_Str"");
          }
        }
      }
    }
    if (correctParameterTypes != null) {
      for (Iterator actorNames=correctParameterTypes.labelSet().iterator(); actorNames.hasNext(); ) {
        String actorName=(String)actorNames.next();
        RecordToken assignment=(RecordToken)correctParameterTypes.get(actorName);
        for (Iterator names=assignment.labelSet().iterator(); names.hasNext(); ) {
          String name=(String)names.next();
          StringToken value=(StringToken)assignment.get(name);
          StringToken actualValue=(StringToken)((RecordToken)actualParameterTypes.get(actorName)).get(name);
          if (!value.equals(actualValue)) {
            throw new IllegalActionException(this,""String_Node_Str"" + ((CompositeEntity)getContainer()).getEntity(actorName).getFullName() + ""String_Node_Str""+ name+ ""String_Node_Str""+ value+ ""String_Node_Str""+ actualValue+ ""String_Node_Str"");
          }
        }
      }
    }
  }
}"
75567,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the parameter public members to refer to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Clock newObject=(Clock)super.clone(workspace);
  ArrayType valuesArrayType=(ArrayType)newObject.values.getType();
  InequalityTerm elementTerm=valuesArrayType.getElementTypeTerm();
  newObject.output.setTypeAtLeast(elementTerm);
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the parameter public members to refer to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ContinuousClock newObject=(ContinuousClock)super.clone(workspace);
  ArrayType valuesArrayType=(ArrayType)newObject.values.getType();
  InequalityTerm elementTerm=valuesArrayType.getElementTypeTerm();
  newObject.output.setTypeAtLeast(elementTerm);
  return newObject;
}"
75568,"/** 
 * Override the base class and set the origin, the rotating angle and the type of interpolation to use.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the function is not recognized.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == interpolationType) {
    String typeName=interpolationType.getExpression();
    if (typeName.equals(""String_Node_Str"")) {
      _interpolationType=_BICUBIC;
    }
 else     if (typeName.equals(""String_Node_Str"")) {
      _interpolationType=_BICUBIC2;
    }
 else     if (typeName.equals(""String_Node_Str"")) {
      _interpolationType=_BILINEAR;
    }
 else     if (typeName.equals(""String_Node_Str"")) {
      _interpolationType=_NEARESTNEIGHBOR;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + typeName);
    }
  }
 else   if (attribute == subSampleBits) {
    _subSampleBits=((IntToken)subSampleBits.getToken()).intValue();
  }
 else   if (attribute == xOrigin) {
    _xOrigin=((IntToken)xOrigin.getToken()).intValue();
  }
 else   if (attribute == yOrigin) {
    _xOrigin=((IntToken)yOrigin.getToken()).intValue();
  }
 else   if (attribute == degrees) {
    _degrees=((DoubleToken)degrees.getToken()).doubleValue();
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Override the base class and set the origin, the rotating angle and the type of interpolation to use.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the function is not recognized.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == interpolationType) {
    String typeName=interpolationType.getExpression();
    if (typeName.equals(""String_Node_Str"")) {
      _interpolationType=_BICUBIC;
    }
 else     if (typeName.equals(""String_Node_Str"")) {
      _interpolationType=_BICUBIC2;
    }
 else     if (typeName.equals(""String_Node_Str"")) {
      _interpolationType=_BILINEAR;
    }
 else     if (typeName.equals(""String_Node_Str"")) {
      _interpolationType=_NEARESTNEIGHBOR;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + typeName);
    }
  }
 else   if (attribute == subSampleBits) {
    _subSampleBits=((IntToken)subSampleBits.getToken()).intValue();
  }
 else   if (attribute == xOrigin) {
    _xOrigin=((IntToken)xOrigin.getToken()).intValue();
  }
 else   if (attribute == yOrigin) {
    _yOrigin=((IntToken)yOrigin.getToken()).intValue();
  }
 else   if (attribute == degrees) {
    _degrees=((DoubleToken)degrees.getToken()).doubleValue();
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75569,"/** 
 * Output the current value of the clock.
 * @exception IllegalActionException Ifthe value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  double currentTime=getDirector().getCurrentTime();
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  if (_debugging)   _debug(""String_Node_Str"" + currentTime + ""String_Node_Str"");
  _updateTentativeValues();
  _tentativeNextFiringTime=Double.NEGATIVE_INFINITY;
  _tentativeCycleCountIncrement=0;
  if (_tentativeCycleCount > 0) {
    while (_tentativeCycleStartTime + periodValue <= currentTime) {
      _tentativeCycleStartTime+=periodValue;
    }
    if (currentTime >= _tentativeCycleStartTime + _offsets[_tentativePhase]) {
      if (_tPlus) {
        if (_debugging)         _debug(""String_Node_Str"");
        _tentativeCurrentValue=_getValue(_tentativePhase);
        _tentativePhase++;
        if (_tentativePhase >= _offsets.length) {
          _tentativePhase=0;
          _tentativeCycleStartTime+=periodValue;
          _tentativeCycleCountIncrement++;
        }
        if (_offsets[_tentativePhase] >= periodValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ _offsets[_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
        }
        _tMinus=!_tMinus;
        _tPlus=!_tPlus;
      }
 else       if (_tMinus) {
        if (_debugging)         _debug(""String_Node_Str"");
        _tMinus=!_tMinus;
        _tPlus=!_tPlus;
      }
      _tentativeNextFiringTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
      if (_debugging)       _debug(""String_Node_Str"" + _tentativeNextFiringTime);
    }
  }
  int cycleLimit=((IntToken)numberOfCycles.getToken()).intValue();
  if (cycleLimit > 0 && currentTime >= _tentativeStartTime + cycleLimit * periodValue) {
    _tentativeCurrentValue=_tentativeCurrentValue.zero();
  }
  output.send(0,_tentativeCurrentValue);
  if (_debugging)   _debug(""String_Node_Str"" + _tentativeCurrentValue + ""String_Node_Str"");
}","/** 
 * Output the current value of the clock.
 * @exception IllegalActionException Ifthe value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  double currentTime=getDirector().getCurrentTime();
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  if (_debugging)   _debug(""String_Node_Str"" + currentTime + ""String_Node_Str"");
  _updateTentativeValues();
  _tentativeNextFiringTime=Double.NEGATIVE_INFINITY;
  _tentativeCycleCountIncrement=0;
  if (_tentativeCycleCount > 0) {
    while (_tentativeCycleStartTime + periodValue <= currentTime) {
      _tentativeCycleStartTime+=periodValue;
    }
    if (currentTime + ((CTDirector)getDirector()).getTimeResolution() >= _tentativeCycleStartTime + _offsets[_tentativePhase]) {
      if (_tPlus) {
        if (_debugging)         _debug(""String_Node_Str"");
        _tentativeCurrentValue=_getValue(_tentativePhase);
        _tentativePhase++;
        if (_tentativePhase >= _offsets.length) {
          _tentativePhase=0;
          _tentativeCycleStartTime+=periodValue;
          _tentativeCycleCountIncrement++;
        }
        if (_offsets[_tentativePhase] >= periodValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ _offsets[_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
        }
        _tMinus=!_tMinus;
        _tPlus=!_tPlus;
      }
 else       if (_tMinus) {
        if (_debugging)         _debug(""String_Node_Str"");
        _tMinus=!_tMinus;
        _tPlus=!_tPlus;
      }
      _tentativeNextFiringTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
      if (_debugging)       _debug(""String_Node_Str"" + _tentativeNextFiringTime);
    }
  }
  int cycleLimit=((IntToken)numberOfCycles.getToken()).intValue();
  if (cycleLimit > 0 && currentTime >= _tentativeStartTime + cycleLimit * periodValue) {
    _tentativeCurrentValue=_tentativeCurrentValue.zero();
  }
  output.send(0,_tentativeCurrentValue);
  if (_debugging)   _debug(""String_Node_Str"" + _tentativeCurrentValue + ""String_Node_Str"");
}"
75570,"/** 
 * Preinitialize the actors associated with this director and initialize the number of iterations to zero.  The order in which the actors are preinitialized is non-deterministic.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _iteration=0;
}","/** 
 * Preinitialize the actors associated with this director and initialize the number of iterations to zero.  The order in which the actors are preinitialized is non-deterministic.
 * @exception IllegalActionException If the preinitialize() method ofone of the associated actors throws it.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  Scheduler scheduler=getScheduler();
  if (scheduler == null)   throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  if (_debugging)   _debug(""String_Node_Str"");
  try {
    Schedule sched=scheduler.getSchedule();
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
}"
75571,"/** 
 * Initialize all the actors associated with this director. Perform some internal initialization for this director.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _buildActorTable();
}","/** 
 * Initialize all the actors associated with this director. Perform some internal initialization for this director.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _buildActorTable();
  _iteration=0;
}"
75572,"/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>The graph is not acyclic <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return A Schedule type of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 */
protected Schedule _getSchedule(){
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  GRDirector director=(GRDirector)getContainer();
  if (director == null) {
    return null;
  }
  CompositeActor container=(CompositeActor)(director.getContainer());
  if (container == null) {
    return null;
  }
  CompositeActor castContainer=(CompositeActor)container;
  int count=0;
  List entities=castContainer.deepEntityList();
  Iterator actors=entities.iterator();
  int actorCount=entities.size();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    dag.addNodeWeight(actor);
  }
  actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    LinkedList successors=new LinkedList();
    Iterator outports=actor.outputPortList().iterator();
    while (outports.hasNext()) {
      IOPort outPort=(IOPort)outports.next();
      int referenceDepth=outPort.depthInHierarchy();
      Iterator inPorts=outPort.deepConnectedInPortList().iterator();
      while (inPorts.hasNext()) {
        IOPort inPort=(IOPort)inPorts.next();
        if (inPort.depthInHierarchy() < referenceDepth) {
          continue;
        }
        Actor post=(Actor)inPort.getContainer();
        if (!successors.contains(post)) {
          successors.addLast(post);
        }
      }
    }
    Iterator succeedingActors=successors.iterator();
    while (succeedingActors.hasNext()) {
      Actor connectedActor=(Actor)succeedingActors.next();
      dag.addEdge(actor,connectedActor);
    }
  }
  if (!dag.isAcyclic()) {
    Object[] cycleNodes=dag.cycleNodes();
    StringBuffer names=new StringBuffer();
    for (int i=0; i < cycleNodes.length; i++) {
      if (cycleNodes[i] instanceof Nameable) {
        if (i > 0)         names.append(""String_Node_Str"");
        names.append(((Nameable)cycleNodes[i]).getFullName());
      }
    }
    throw new NotSchedulableException(this,""String_Node_Str"" + names.toString());
  }
  if (dag.top() == null) {
  }
  Schedule schedule=new Schedule();
  Object[] sorted=dag.topologicalSort();
  for (int counter=0; counter < actorCount; counter++) {
    Firing firing=new Firing();
    schedule.add(firing);
    firing.setActor((Actor)sorted[counter]);
  }
  setValid(true);
  return schedule;
}","/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>The graph is not acyclic <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return A Schedule type of the deeply contained opaque entitiesin the firing order.
 * @exception NotSchedulableException If the CompositeActor is notschedulable.
 */
protected Schedule _getSchedule(){
  DirectedAcyclicGraph dag=new DirectedAcyclicGraph();
  GRDirector director=(GRDirector)getContainer();
  if (director == null) {
    return null;
  }
  int referenceDepth=director.depthInHierarchy();
  CompositeActor container=(CompositeActor)(director.getContainer());
  if (container == null) {
    return null;
  }
  CompositeActor castContainer=(CompositeActor)container;
  int count=0;
  List entities=castContainer.deepEntityList();
  Iterator actors=entities.iterator();
  int actorCount=entities.size();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    dag.addNodeWeight(actor);
  }
  actors=castContainer.deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    Set successors=new HashSet();
    Iterator outports=actor.outputPortList().iterator();
    while (outports.hasNext()) {
      IOPort outPort=(IOPort)outports.next();
      Iterator sinkPorts=outPort.sinkPortList().iterator();
      while (sinkPorts.hasNext()) {
        IOPort sinkPort=(IOPort)sinkPorts.next();
        if (sinkPort.isOutput()) {
          continue;
        }
        Actor sinkActor=(Actor)sinkPort.getContainer();
        successors.add(sinkActor);
      }
    }
    Iterator succeedingActors=successors.iterator();
    while (succeedingActors.hasNext()) {
      Actor connectedActor=(Actor)succeedingActors.next();
      dag.addEdge(actor,connectedActor);
    }
  }
  if (!dag.isAcyclic()) {
    Object[] cycleNodes=dag.cycleNodes();
    StringBuffer names=new StringBuffer();
    for (int i=0; i < cycleNodes.length; i++) {
      if (cycleNodes[i] instanceof Nameable) {
        if (i > 0)         names.append(""String_Node_Str"");
        names.append(((Nameable)cycleNodes[i]).getFullName());
      }
    }
    throw new NotSchedulableException(this,""String_Node_Str"" + names.toString());
  }
  if (dag.top() == null) {
  }
  Schedule schedule=new Schedule();
  Object[] sorted=dag.topologicalSort();
  for (int counter=0; counter < actorCount; counter++) {
    Firing firing=new Firing();
    schedule.add(firing);
    firing.setActor((Actor)sorted[counter]);
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(schedule.toString());
  }
  setValid(true);
  return schedule;
}"
75573,"/** 
 * Increase the count of stopped actors by one.  This method is called by instances of ProcessThread in response to a call to their stopThread method. This method may be overridden in derived classes to added domain specific functionality. Implementations of this method must be synchronized.
 */
protected synchronized void _actorHasStopped(){
  _stoppedActorCount++;
  notifyAll();
}","/** 
 * Increase the count of stopped actors by one.  This method is called by instances of ProcessThread in response to a call to their stopThread() method. This method may be overridden in derived classes to added domain specific functionality. Implementations of this method must be synchronized.
 */
protected synchronized void _actorHasStopped(){
  _stoppedActorCount++;
  notifyAll();
}"
75574,"/** 
 * Wait until a deadlock is detected. Then deal with the deadlock by calling the protected method _resolveDeadlock() and return. This method is synchronized on the director.
 * @exception IllegalActionException If a derived class throws it.
 */
public void fire() throws IllegalActionException {
  Workspace workspace=workspace();
synchronized (this) {
    while (!_areActorsDeadlocked() && !_areAllActorsStopped()) {
      workspace.wait(this);
    }
    if (_areActorsDeadlocked()) {
      _notDone=_resolveDeadlock();
    }
  }
}","/** 
 * Wait until a deadlock is detected. Then deal with the deadlock by calling the protected method _resolveDeadlock() and return. This method is synchronized on the director.
 * @exception IllegalActionException If a derived class throws it.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Workspace workspace=workspace();
synchronized (this) {
    while (!_areActorsDeadlocked() && !_areAllActorsStopped()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      workspace.wait(this);
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    if (_areActorsDeadlocked() && !_stopRequested) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _notDone=_resolveDeadlock();
    }
  }
}"
75575,"/** 
 * End the execution of the model under the control of this director. A flag is set in all the receivers that causes each process to terminate at the earliest communication point. Prior to setting receiver flags, this method wakes up the threads if they all are stopped.  If the container is not an instance of CompositeActor, then this method does nothing. <P> This method is not synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If an error occurs whileaccessing the receivers of all actors under the control of this director.
 */
public void wrapup() throws IllegalActionException {
  if (_debugging) {
    _debug(_name + ""String_Node_Str"");
  }
  Nameable container=getContainer();
  if (container instanceof CompositeActor) {
    Iterator actors=((CompositeActor)container).deepEntityList().iterator();
    Iterator actorPorts;
    ProcessReceiver nextReceiver;
    LinkedList receiversList=new LinkedList();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      actorPorts=actor.inputPortList().iterator();
      while (actorPorts.hasNext()) {
        IOPort port=(IOPort)actorPorts.next();
        Receiver[][] receivers=port.getReceivers();
        for (int i=0; i < receivers.length; i++) {
          for (int j=0; j < receivers[i].length; j++) {
            nextReceiver=(ProcessReceiver)receivers[i][j];
            nextReceiver.requestFinish();
            receiversList.addFirst(nextReceiver);
          }
        }
      }
    }
    (new NotifyThread(receiversList)).start();
  }
  return;
}","/** 
 * End the execution of the model under the control of this director. A flag is set in all the receivers that causes each process to terminate at the earliest communication point. Prior to setting receiver flags, this method wakes up the threads if they all are stopped.  If the container is not an instance of CompositeActor, then this method does nothing. <P> This method is not synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If an error occurs whileaccessing the receivers of all actors under the control of this director.
 */
public void wrapup() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Nameable container=getContainer();
  if (container instanceof CompositeActor) {
    Iterator actors=((CompositeActor)container).deepEntityList().iterator();
    Iterator actorPorts;
    ProcessReceiver nextReceiver;
    LinkedList receiversList=new LinkedList();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      actorPorts=actor.inputPortList().iterator();
      while (actorPorts.hasNext()) {
        IOPort port=(IOPort)actorPorts.next();
        Receiver[][] receivers=port.getReceivers();
        for (int i=0; i < receivers.length; i++) {
          for (int j=0; j < receivers[i].length; j++) {
            nextReceiver=(ProcessReceiver)receivers[i][j];
            nextReceiver.requestFinish();
            receiversList.addFirst(nextReceiver);
          }
        }
      }
    }
    (new NotifyThread(receiversList)).start();
  }
}"
75576,"/** 
 * Return false if the model has reached deadlock and can be terminated if desired. Return true otherwise. This flag is set on detection of a deadlock in the fire() method.
 * @return false if the director has detected a deadlock and can beterminated if desired.
 * @exception IllegalActionException If a derived class throws it.
 */
public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + _notDone);
    _debug(""String_Node_Str"" + _stopRequested);
  }
  _notDone=_notDone && !_stopRequested;
  if (_debugging) {
    _debug(_name + ""String_Node_Str"" + _notDone);
  }
  return _notDone;
}","/** 
 * Return false if a stop has been requested or if the model has reached deadlock. Return true otherwise.
 * @return False if the director has detected a deadlock ora stop has been requested.
 * @exception IllegalActionException If a derived class throws it.
 */
public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(""String_Node_Str"" + _notDone);
    _debug(""String_Node_Str"" + _stopRequested);
  }
  _notDone=_notDone && !_stopRequested;
  if (_debugging) {
    _debug(""String_Node_Str"" + _notDone);
  }
  return _notDone;
}"
75577,"/** 
 * Request that the director cease execution altogether. This causes a call to stop() on all actors contained by the container of this director, and a call to stopThread() on each of the process threads that contain actors controlled by this director. This also sets a flag so that the next call to postfire() returns false.
 */
public void stop(){
  Iterator threads=_actorThreadList.iterator();
  while (threads.hasNext()) {
    ProcessThread thread=(ProcessThread)threads.next();
    thread.stopThread();
    thread.getActor().stop();
  }
  _stopRequested=true;
}","/** 
 * Request that the director cease execution altogether. This causes a call to stop() on all actors contained by the container of this director, and a call to stopThread() on each of the process threads that contain actors controlled by this director. This also sets a flag so that the next call to postfire() returns false.
 */
public void stop(){
  _stopRequested=true;
  Iterator threads=_actorThreadList.iterator();
  while (threads.hasNext()) {
    ProcessThread thread=(ProcessThread)threads.next();
    thread.stopThread();
    thread.getActor().stop();
  }
  _stopRequested=true;
}"
75578,"/** 
 * Initialize the given actor.  This class overrides the base class to reset the flags for all of the receivers, and to create a new ProcessThread for each actor being controlled. This class does *NOT* directly call the initialize method of the actor. That method is instead called by the actor's thread itself. This allows actors in process domains to create tokens during initialization, since sending data in a process-based domain requires threads for each actor.
 * @exception IllegalActionException If the actor is notacceptable to the domain.  Not thrown in this base class.
 */
public void initialize(Actor actor) throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + ((NamedObj)actor).getName());
  }
  Iterator ports=actor.inputPortList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    Receiver[][] receivers=port.getReceivers();
    for (int i=0; i < receivers.length; i++) {
      for (int j=0; j < receivers[i].length; j++) {
        ((ProcessReceiver)receivers[i][j]).reset();
      }
    }
  }
  ProcessThread processThread=_getProcessThread(actor,this);
  _actorThreadList.addFirst(processThread);
  _newActorThreadList.addFirst(processThread);
}","/** 
 * Initialize the given actor.  This class overrides the base class to reset the flags for all of the receivers, and to create a new ProcessThread for each actor being controlled. This class does *NOT* directly call the initialize method of the actor. That method is instead called by the actor's thread itself. This allows actors in process domains to create tokens during initialization, since sending data in a process-based domain requires threads for each actor.
 * @exception IllegalActionException If the actor is notacceptable to the domain.  Not thrown in this base class.
 */
public void initialize(Actor actor) throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
  }
  Iterator ports=actor.inputPortList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    Receiver[][] receivers=port.getReceivers();
    for (int i=0; i < receivers.length; i++) {
      for (int j=0; j < receivers[i].length; j++) {
        ((ProcessReceiver)receivers[i][j]).reset();
      }
    }
  }
  ProcessThread processThread=_getProcessThread(actor,this);
  _actorThreadList.addFirst(processThread);
  _newActorThreadList.addFirst(processThread);
}"
75579,"/** 
 * End the execution of the actor under the control of this thread. Subclasses are encouraged to override this method as necessary for domain specific functionality.
 * @exception IllegalActionException If an error occurs whileending execution of the actor under the control of this thread.
 */
public void wrapup() throws IllegalActionException {
  _actor.wrapup();
}","/** 
 * End the execution of the actor under the control of this thread. Subclasses are encouraged to override this method as necessary for domain specific functionality.
 * @exception IllegalActionException If an error occurs whileending execution of the actor under the control of this thread.
 */
public void wrapup() throws IllegalActionException {
  _debug(""String_Node_Str"");
  _actor.wrapup();
}"
75580,"/** 
 * Initialize the actor, iterate it through the execution cycle until it terminates. At the end of the termination, calls wrapup on the actor.
 */
public void run(){
  Workspace workspace=_director.workspace();
  boolean iterate=true;
  try {
    _actor.initialize();
    while (iterate) {
      if (_threadStopRequested) {
        _director._actorHasStopped();
synchronized (_director) {
          while (_threadStopRequested) {
            workspace.wait(_director);
          }
        }
      }
      if (((Entity)_actor).getContainer() != null) {
        if (_actor.prefire()) {
          _actor.fire();
          iterate=_actor.postfire();
        }
      }
    }
  }
 catch (  TerminateProcessException t) {
  }
catch (  IllegalActionException e) {
    _manager.notifyListenersOfException(e);
  }
 finally {
    try {
      wrapup();
    }
 catch (    IllegalActionException e) {
      _manager.notifyListenersOfException(e);
    }
    _director._decreaseActiveCount();
  }
}","/** 
 * Initialize the actor, iterate it through the execution cycle until it terminates. At the end of the termination, calls wrapup on the actor.
 */
public void run(){
  _debug(""String_Node_Str"");
  Workspace workspace=_director.workspace();
  boolean iterate=true;
  try {
    _actor.initialize();
    while (iterate) {
      if (_director.isStopRequested()) {
        _debug(""String_Node_Str"");
        break;
      }
      if (_threadStopRequested) {
        _debug(""String_Node_Str"");
synchronized (_director) {
          _director._actorHasStopped();
          while (_threadStopRequested) {
            _debug(""String_Node_Str"");
            workspace.wait(_director);
          }
        }
        _debug(""String_Node_Str"");
      }
      if (((Entity)_actor).getContainer() != null) {
        if (_actor.prefire()) {
          _actor.fire();
          iterate=_actor.postfire();
        }
      }
    }
  }
 catch (  TerminateProcessException t) {
    _debug(""String_Node_Str"");
  }
catch (  IllegalActionException e) {
    _debug(""String_Node_Str"" + e);
    _manager.notifyListenersOfException(e);
  }
 finally {
    try {
      wrapup();
    }
 catch (    IllegalActionException e) {
      _debug(""String_Node_Str"" + e);
      _manager.notifyListenersOfException(e);
    }
 finally {
      _director._decreaseActiveCount();
      _debug(""String_Node_Str"");
    }
  }
}"
75581,"/** 
 * Request that execution of the actor controlled by this thread continue.  This is normally called by the ProcessDirector in the prefire method.
 */
public void cancelStopThread(){
  _threadStopRequested=false;
}","/** 
 * Request that execution of the actor controlled by this thread continue.  This is normally called by the ProcessDirector in the prefire method.
 */
public void cancelStopThread(){
  if (_threadStopRequested) {
    _debug(""String_Node_Str"");
  }
  _threadStopRequested=false;
}"
75582,"/** 
 * Construct a thread to be used for the execution of the iteration methods of the actor. This increases the count of active actors in the director.
 * @param actor The actor that needs to be executed.
 * @param director The director responsible for the execution of thisactor.
 */
public ProcessThread(Actor actor,ProcessDirector director){
  super();
  _actor=actor;
  _director=director;
  _manager=((CompositeActor)((NamedObj)actor).getContainer()).getManager();
  _director._increaseActiveCount();
  _name=((Nameable)_actor).getName();
  setName(((Nameable)_actor).getFullName());
}","/** 
 * Construct a thread to be used for the execution of the iteration methods of the actor. This increases the count of active actors in the director.
 * @param actor The actor that needs to be executed.
 * @param director The director responsible for the execution of thisactor.
 */
public ProcessThread(Actor actor,ProcessDirector director){
  super();
  _actor=actor;
  _director=director;
  _manager=((CompositeActor)((NamedObj)actor).getContainer()).getManager();
  _director._increaseActiveCount();
  if (_actor instanceof NamedObj) {
    _name=((NamedObj)_actor).getFullName();
    addDebugListener((NamedObj)_actor);
  }
 else {
    _name=""String_Node_Str"";
  }
  setName(_name);
}"
75583,"/** 
 * Request that execution of the actor controlled by this thread stop. Call stopFire() on all composite actors that are contained by the composite actor that contains this director.
 */
public void stopThread(){
  _threadStopRequested=true;
}","/** 
 * Request that execution of the actor controlled by this thread stop. Call stopFire() on all composite actors that are contained by the composite actor that contains this director.
 */
public void stopThread(){
  _threadStopRequested=true;
  _debug(""String_Node_Str"");
}"
75584,"/** 
 * Return the type constraints of this typed composite actor. The constraints have the form of a list of inequalities.  The constraints come from three sources, the contained actors, the contained Typeables, and (for opaque actors) the topology of connections between actors. To generate the constraints based on the topology, this method scans all the connections within this composite between opaque TypedIOPorts.  If the type of the ports on one or both ends of a connection is not declared, a type constraint is formed that requires the type of the port at the source end of the connection to be less than or equal to the type at the destination port.  To collect the type constraints from the contained actors, This method recursively calls the typeConstraintList() method of the contained actors and combine all the constraints together.  The type constraints from contained Typeables (ports and parameters) are collected by calling the typeConstraintList() method of all the contained Typeables.  <p> This method is read-synchronized on the workspace.
 * @return a list of instances of Inequality.
 * @exception IllegalActionException If the typeConstraintListof one of the deeply contained objects throws it.
 * @see ptolemy.graph.Inequality
 */
public List typeConstraintList() throws IllegalActionException {
  try {
    workspace().getReadAccess();
    List result=new LinkedList();
    if (isOpaque()) {
      Iterator entities=deepEntityList().iterator();
      while (entities.hasNext()) {
        TypedActor actor=(TypedActor)entities.next();
        Iterator ports=((Entity)actor).portList().iterator();
        while (ports.hasNext()) {
          TypedIOPort sourcePort=(TypedIOPort)ports.next();
          Receiver[][] receivers=sourcePort.getRemoteReceivers();
          List destinationPorts=_receiverToPort(receivers);
          result.addAll(_typeConstraintsFromTo(sourcePort,destinationPorts));
        }
      }
      Iterator boundaryPorts=portList().iterator();
      while (boundaryPorts.hasNext()) {
        TypedIOPort sourcePort=(TypedIOPort)boundaryPorts.next();
        Receiver[][] receivers=sourcePort.deepGetReceivers();
        List destinationPorts=_receiverToPort(receivers);
        result.addAll(_typeConstraintsFromTo(sourcePort,destinationPorts));
      }
    }
    Iterator entities=entityList().iterator();
    while (entities.hasNext()) {
      TypedActor actor=(TypedActor)entities.next();
      result.addAll(actor.typeConstraintList());
    }
    Iterator ports=portList().iterator();
    while (ports.hasNext()) {
      Typeable port=(Typeable)ports.next();
      result.addAll(port.typeConstraintList());
    }
    Iterator typeables=attributeList(Typeable.class).iterator();
    while (typeables.hasNext()) {
      Typeable typeable=(Typeable)typeables.next();
      result.addAll(typeable.typeConstraintList());
    }
    return result;
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Return the type constraints of this typed composite actor. The constraints have the form of a list of inequalities.  The constraints come from three sources, the contained actors, the contained Typeables, and (for opaque actors) the topology of connections between actors. To generate the constraints based on the topology, this method scans all the connections within this composite between opaque TypedIOPorts.  If the type of the ports on one or both ends of a connection is not declared, a type constraint is formed that requires the type of the port at the source end of the connection to be less than or equal to the type at the destination port.  To collect the type constraints from the contained actors, This method recursively calls the typeConstraintList() method of the contained actors and combine all the constraints together.  The type constraints from contained Typeables (ports and parameters) are collected by calling the typeConstraintList() method of all the contained Typeables.  <p> This method is read-synchronized on the workspace.
 * @return a list of instances of Inequality.
 * @exception IllegalActionException If the typeConstraintListof one of the deeply contained objects throws it.
 * @see ptolemy.graph.Inequality
 */
public List typeConstraintList() throws IllegalActionException {
  try {
    workspace().getReadAccess();
    List result=new LinkedList();
    if (isOpaque()) {
      Iterator entities=deepEntityList().iterator();
      while (entities.hasNext()) {
        TypedActor actor=(TypedActor)entities.next();
        Iterator ports=((Entity)actor).portList().iterator();
        while (ports.hasNext()) {
          TypedIOPort sourcePort=(TypedIOPort)ports.next();
          List destinationPorts=sourcePort.sinkPortList();
          result.addAll(_typeConstraintsFromTo(sourcePort,destinationPorts));
        }
      }
      Iterator boundaryPorts=portList().iterator();
      while (boundaryPorts.hasNext()) {
        TypedIOPort sourcePort=(TypedIOPort)boundaryPorts.next();
        List destinationPorts=sourcePort.insideSinkPortList();
        result.addAll(_typeConstraintsFromTo(sourcePort,destinationPorts));
      }
    }
    Iterator entities=entityList().iterator();
    while (entities.hasNext()) {
      TypedActor actor=(TypedActor)entities.next();
      result.addAll(actor.typeConstraintList());
    }
    Iterator ports=portList().iterator();
    while (ports.hasNext()) {
      Typeable port=(Typeable)ports.next();
      result.addAll(port.typeConstraintList());
    }
    Iterator typeables=attributeList(Typeable.class).iterator();
    while (typeables.hasNext()) {
      Typeable typeable=(Typeable)typeables.next();
      result.addAll(typeable.typeConstraintList());
    }
    return result;
  }
  finally {
    workspace().doneReading();
  }
}"
75585,"/** 
 * Create a new effigy in the given container by reading the <i>input</i> URL. If the <i>input</i> URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param input The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL input) throws Exception {
  if (input == null) {
    PtolemyEffigy effigy=_newEffigy(container,container.uniqueName(""String_Node_Str""));
    NamedObj entity=getEntity(""String_Node_Str"");
    NamedObj newModel;
    if (entity != null) {
      newModel=(NamedObj)entity.clone(new Workspace());
    }
 else {
      newModel=new TypedCompositeActor(new Workspace());
    }
    newModel.setName(""String_Node_Str"");
    effigy.setModel(newModel);
    return effigy;
  }
 else {
    String extension=getExtension(input);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      return null;
    }
    PtolemyEffigy effigy=_newEffigy(container,container.uniqueName(""String_Node_Str""));
    MoMLParser parser=new MoMLParser();
    NamedObj toplevel=null;
    try {
      try {
        try {
          toplevel=parser.parse(base,input);
        }
 catch (        IOException io) {
          URL anotherURL=JNLPUtilities.jarURLEntryResource(input.toString());
          if (anotherURL != null) {
            toplevel=parser.parse(base,anotherURL.openStream());
          }
 else {
            throw io;
          }
        }
        if (toplevel != null) {
          effigy.setModel(toplevel);
          effigy.setModified(MoMLParser.isModified());
          MoMLParser.setModified(false);
          URIAttribute uriAttribute=new URIAttribute(toplevel,""String_Node_Str"");
          URI inputURI=null;
          try {
            inputURI=new URI(input.toExternalForm());
          }
 catch (          java.net.URISyntaxException ex) {
            String inputExternalFormFixed=StringUtilities.substitute(input.toExternalForm(),""String_Node_Str"",""String_Node_Str"");
            try {
              inputURI=new URI(inputExternalFormFixed);
            }
 catch (            Exception ex2) {
              throw new Exception(""String_Node_Str"" + ""String_Node_Str"" + input.toExternalForm() + ""String_Node_Str""+ inputExternalFormFixed+ ""String_Node_Str"",ex);
            }
          }
          uriAttribute.setURI(inputURI);
          effigy.uri.setURI(inputURI);
          return effigy;
        }
 else {
          effigy.setContainer(null);
        }
      }
 catch (      Exception e) {
        ModelDirectory dir=(ModelDirectory)effigy.topEffigy().getContainer();
        List effigies=dir.entityList(Effigy.class);
        if (effigies.size() <= 2) {
          MessageHandler.error(""String_Node_Str"" + input,e);
        }
 else {
          throw e;
        }
      }
    }
  finally {
      if (toplevel == null) {
        effigy.setContainer(null);
      }
    }
    return null;
  }
}","/** 
 * Create a new effigy in the given container by reading the <i>input</i> URL. If the <i>input</i> URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param input The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL input) throws Exception {
  if (input == null) {
    PtolemyEffigy effigy=_newEffigy(container,container.uniqueName(""String_Node_Str""));
    NamedObj entity=getEntity(""String_Node_Str"");
    NamedObj newModel;
    if (entity != null) {
      newModel=(NamedObj)entity.clone(new Workspace());
    }
 else {
      newModel=new TypedCompositeActor(new Workspace());
    }
    newModel.setName(""String_Node_Str"");
    effigy.setModel(newModel);
    return effigy;
  }
 else {
    String extension=getExtension(input);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      return null;
    }
    PtolemyEffigy effigy=_newEffigy(container,container.uniqueName(""String_Node_Str""));
    MoMLParser parser=new MoMLParser();
    NamedObj toplevel=null;
    try {
      try {
        try {
          toplevel=parser.parse(base,input);
        }
 catch (        IOException io) {
          URL anotherURL=JNLPUtilities.jarURLEntryResource(input.toString());
          if (anotherURL != null) {
            toplevel=parser.parse(base,anotherURL.openStream());
          }
 else {
            throw io;
          }
        }
        if (toplevel != null) {
          effigy.setModel(toplevel);
          effigy.setModified(MoMLParser.isModified());
          MoMLParser.setModified(false);
          URIAttribute uriAttribute=new URIAttribute(toplevel,""String_Node_Str"");
          URI inputURI=null;
          try {
            inputURI=new URI(input.toExternalForm());
          }
 catch (          java.net.URISyntaxException ex) {
            String inputExternalFormFixed=StringUtilities.substitute(input.toExternalForm(),""String_Node_Str"",""String_Node_Str"");
            try {
              inputURI=new URI(inputExternalFormFixed);
            }
 catch (            Exception ex2) {
              throw new Exception(""String_Node_Str"" + ""String_Node_Str"" + input.toExternalForm() + ""String_Node_Str""+ inputExternalFormFixed+ ""String_Node_Str"",ex);
            }
          }
          uriAttribute.setURI(inputURI);
          effigy.uri.setURI(inputURI);
          return effigy;
        }
 else {
          effigy.setContainer(null);
        }
      }
 catch (      Exception e) {
        ModelDirectory dir=(ModelDirectory)effigy.topEffigy().getContainer();
        List effigies=dir.entityList(Effigy.class);
        if (effigies.size() <= 3) {
          MessageHandler.error(""String_Node_Str"" + input,e);
        }
 else {
          throw e;
        }
      }
    }
  finally {
      if (toplevel == null) {
        effigy.setContainer(null);
      }
    }
    return null;
  }
}"
75586,"/** 
 * Return the argument contained by this entity that is return. If there is no such argument, return null. This method is read-synchronized on the workspace.
 * @return the argument return, or null if none exists.
 */
public Argument getArgumentReturn(){
  try {
    _workspace.getReadAccess();
    Iterator arguments=argumentsList().iterator();
    Argument returnValue=null;
    while (arguments.hasNext()) {
      Argument argument=(Argument)arguments.next();
      if (argument != null && argument.isReturn()) {
        return (Argument)argument;
      }
    }
    return (Argument)returnValue;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Return the argument contained by this entity that is return. If there is no such argument, return null. This method is read-synchronized on the workspace.
 * @return the argument return, or null if none exists.
 */
public Argument getArgumentReturn(){
  try {
    _workspace.getReadAccess();
    Iterator arguments=this.argumentsList().iterator();
    Argument returnValue=null;
    while (arguments.hasNext()) {
      Argument argument=(Argument)arguments.next();
      if (argument != null && argument.isReturn()) {
        return (Argument)argument;
      }
    }
    return (Argument)returnValue;
  }
  finally {
    _workspace.doneReading();
  }
}"
75587,"/** 
 * For each Argument, a port of the same name is created, belonging to this argument.
 * @return void
 */
public void createPorts(){
  Iterator arguments=argumentsList().iterator();
  TypedIOPort port;
  boolean exist=false;
  while (arguments.hasNext()) {
    Argument argument=(Argument)arguments.next();
    port=(TypedIOPort)this.getPort(argument.getName());
    if (port == null) {
      if (argument.isReturn())       try {
        port=(TypedIOPort)this.newPort(argument.getName());
        port.setInput(false);
        port.setOutput(true);
        port.setTypeEquals(BaseType.GENERAL);
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"",ex);
      }
 else       if (argument.isInput() && argument.isOutput()) {
        try {
          port=(TypedIOPort)this.newPort(argument.getName() + ""String_Node_Str"");
          port.setInput(argument.isInput());
          port.setTypeEquals(BaseType.GENERAL);
          port=(TypedIOPort)this.newPort(argument.getName() + ""String_Node_Str"");
          port.setOutput(argument.isOutput());
          port.setTypeEquals(BaseType.GENERAL);
        }
 catch (        Exception ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else {
        try {
          port=(TypedIOPort)this.newPort(argument.getName());
          port.setInput(argument.isInput());
          port.setOutput(argument.isOutput());
          port.setTypeEquals(BaseType.GENERAL);
        }
 catch (        Exception ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
    }
 else {
      if (argument.isReturn()) {
        port.setInput(false);
        port.setOutput(true);
        port.setTypeEquals(BaseType.GENERAL);
      }
 else {
        port.setInput(argument.isInput());
        port.setOutput(argument.isOutput());
        port.setTypeEquals(BaseType.GENERAL);
      }
    }
  }
}","/** 
 * For each Argument, a port of the same name is created, belonging to this argument.
 * @return void
 */
public void createPorts(){
  Iterator arguments=this.argumentsList().iterator();
  TypedIOPort port;
  boolean exist=false;
  while (arguments.hasNext()) {
    Argument argument=(Argument)arguments.next();
    port=(TypedIOPort)this.getPort(argument.getName());
    if (port == null) {
      if (argument.isReturn())       try {
        port=(TypedIOPort)this.newPort(argument.getName());
        port.setInput(false);
        port.setOutput(true);
        port.setTypeEquals(BaseType.GENERAL);
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"",ex);
      }
 else       if (argument.isInput() && argument.isOutput()) {
        try {
          port=(TypedIOPort)this.newPort(argument.getName() + ""String_Node_Str"");
          port.setInput(argument.isInput());
          port.setTypeEquals(BaseType.GENERAL);
          port=(TypedIOPort)this.newPort(argument.getName() + ""String_Node_Str"");
          port.setOutput(argument.isOutput());
          port.setTypeEquals(BaseType.GENERAL);
        }
 catch (        Exception ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else {
        try {
          port=(TypedIOPort)this.newPort(argument.getName());
          port.setInput(argument.isInput());
          port.setOutput(argument.isOutput());
          port.setTypeEquals(BaseType.GENERAL);
        }
 catch (        Exception ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
    }
 else {
      if (argument.isReturn()) {
        port.setInput(false);
        port.setOutput(true);
        port.setTypeEquals(BaseType.GENERAL);
      }
 else {
        port.setInput(argument.isInput());
        port.setOutput(argument.isOutput());
        port.setTypeEquals(BaseType.GENERAL);
      }
    }
  }
}"
75588,"/** 
 * Read the argument of the function from the ports, call the native method throw the generated interface, and put the results on the corresponding ports
 * @exception IllegalActionException If a exception occured
 */
public void fire() throws IllegalActionException {
  Iterator ports=this.portList().iterator();
  Vector args=new Vector();
  while (ports.hasNext()) {
    Object object=ports.next();
    TypedIOPort port=(TypedIOPort)ports.next();
    if (port.isInput() && port.hasToken(0) && !(port.isOutput() && !port.isInput())) {
      Token tok=(Token)port.get(0);
      String typ=(String)_methods[_methodIndex].getParameterTypes()[args.size()].toString();
      if (typ.equals(""String_Node_Str"")) {
        args.add(new Boolean((boolean)((BooleanToken)tok).booleanValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        args.add(new Integer((int)((IntToken)tok).intValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        args.add(new Double((double)((DoubleToken)tok).doubleValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        int siz=((ArrayToken)tok).arrayValue().length;
        int[] tab=new int[siz];
        for (int j=0; j < siz; j++)         tab[j]=(int)((IntToken)(((ArrayToken)tok).arrayValue()[j])).intValue();
        args.add((Object)tab);
      }
 else {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  Object obj=null;
  Object ret=null;
  try {
    try {
      obj=_class.newInstance();
    }
 catch (    Error error) {
      String libraryPath=StringUtilities.getProperty(""String_Node_Str"");
      throw new Exception(""String_Node_Str"" + _class + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ libraryPath+ ""String_Node_Str""+ error.getMessage(),error);
    }
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  try {
    ret=_methods[_methodIndex].invoke(obj,args.toArray());
  }
 catch (  Throwable ex) {
    StringBuffer argumentsDescription=new StringBuffer(""String_Node_Str"");
    try {
      if (args.size() >= 1) {
        argumentsDescription.append(args.elementAt(0).toString());
        for (int i=1; i < args.size(); i++) {
          argumentsDescription.append(""String_Node_Str"" + args.elementAt(i).toString());
        }
      }
    }
 catch (    Exception ex2) {
    }
    throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"" + obj + ""String_Node_Str""+ args.size()+ ""String_Node_Str""+ argumentsDescription.toString());
  }
  Iterator arguments=argumentsList().iterator();
  while (arguments.hasNext()) {
    TypedIOPort port=(TypedIOPort)arguments.next();
    if (port.getName().equals(this.getArgumentReturn().getName())) {
      String typ=""String_Node_Str"";
      Field field=null;
      try {
        field=_class.getDeclaredField(""String_Node_Str"" + port.getName());
        typ=(String)field.getType().toString();
      }
 catch (      NoSuchFieldException e) {
        try {
          MessageHandler.warning(""String_Node_Str"");
        }
 catch (        Exception ex2) {
          getDirector().stop();
        }
      }
      if (typ.equals(""String_Node_Str"")) {
        port.send(0,(Token)new BooleanToken(((Boolean)ret).booleanValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        port.send(0,(Token)new DoubleToken(((Double)ret).doubleValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        port.send(0,(Token)new IntToken(((Integer)ret).intValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        port.send(0,(Token)new UnsignedByteToken(((Byte)ret).byteValue()));
      }
 else {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 else     if (port.isOutput() && !(port.getName().equals(this.getArgumentReturn().getName()))) {
      String typ=""String_Node_Str"";
      Field field=null;
      try {
        field=_class.getDeclaredField(""String_Node_Str"" + port.getName());
        typ=(String)field.getType().toString();
      }
 catch (      NoSuchFieldException ex) {
        try {
          field=_class.getDeclaredField(""String_Node_Str"" + port.getName().substring(0,port.getName().length() - 3));
          typ=(String)field.getType().toString();
        }
 catch (        Exception e) {
          try {
            MessageHandler.warning(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
          }
 catch (          Exception ex2) {
            getDirector().stop();
          }
        }
      }
      if (typ.equals(""String_Node_Str"")) {
        try {
          port.send(0,(Token)new BooleanToken(field.getBoolean(obj)));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else       if (typ.equals(""String_Node_Str"")) {
        try {
          port.send(0,(Token)new DoubleToken(field.getDouble(obj)));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else       if (typ.equals(""String_Node_Str"")) {
        try {
          port.send(0,(Token)new IntToken(field.getInt(obj)));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else       if (typ.equals(""String_Node_Str"")) {
        try {
          port.send(0,(Token)new UnsignedByteToken((char)field.getChar(obj)));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else       if (typ.equals(""String_Node_Str"")) {
        try {
          int[] tab=(int[])field.get(obj);
          Token[] toks=new Token[((int[])field.get(obj)).length];
          for (int j=0; j < ((int[])field.get(obj)).length; j++)           toks[j]=new IntToken(((int[])field.get(obj))[j]);
          port.send(0,new ArrayToken(toks));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}","/** 
 * Read the argument of the function from the ports, call the native method throw the generated interface, and put the results on the corresponding ports
 * @exception IllegalActionException If a exception occured
 */
public void fire() throws IllegalActionException {
  Iterator ports=this.portList().iterator();
  Vector args=new Vector();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (port.isInput() && port.hasToken(0) && !(port.isOutput() && !port.isInput())) {
      Token tok=(Token)port.get(0);
      String typ=(String)_methods[_methodIndex].getParameterTypes()[args.size()].toString();
      if (typ.equals(""String_Node_Str"")) {
        args.add(new Boolean((boolean)((BooleanToken)tok).booleanValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        args.add(new Integer((int)((IntToken)tok).intValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        args.add(new Double((double)((DoubleToken)tok).doubleValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        int siz=((ArrayToken)tok).arrayValue().length;
        int[] tab=new int[siz];
        for (int j=0; j < siz; j++)         tab[j]=(int)((IntToken)(((ArrayToken)tok).arrayValue()[j])).intValue();
        args.add((Object)tab);
      }
 else {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  Object obj=null;
  Object ret=null;
  try {
    try {
      obj=_class.newInstance();
    }
 catch (    Error error) {
      String libraryPath=StringUtilities.getProperty(""String_Node_Str"");
      throw new Exception(""String_Node_Str"" + _class + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ libraryPath+ ""String_Node_Str""+ error.getMessage(),error);
    }
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  try {
    ret=_methods[_methodIndex].invoke(obj,args.toArray());
  }
 catch (  Throwable ex) {
    StringBuffer argumentsDescription=new StringBuffer(""String_Node_Str"");
    try {
      if (args.size() >= 1) {
        argumentsDescription.append(args.elementAt(0).toString());
        for (int i=1; i < args.size(); i++) {
          argumentsDescription.append(""String_Node_Str"" + args.elementAt(i).toString());
        }
      }
    }
 catch (    Exception ex2) {
    }
    throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"" + obj + ""String_Node_Str""+ args.size()+ ""String_Node_Str""+ argumentsDescription.toString());
  }
  ports=portList().iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (port.getName().equals(this.getArgumentReturn().getName())) {
      String typ=""String_Node_Str"";
      Field field=null;
      try {
        field=_class.getDeclaredField(""String_Node_Str"" + port.getName());
        typ=(String)field.getType().toString();
      }
 catch (      NoSuchFieldException e) {
        try {
          MessageHandler.warning(""String_Node_Str"");
        }
 catch (        Exception ex2) {
          getDirector().stop();
        }
      }
      if (typ.equals(""String_Node_Str"")) {
        port.send(0,(Token)new BooleanToken(((Boolean)ret).booleanValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        port.send(0,(Token)new DoubleToken(((Double)ret).doubleValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        port.send(0,(Token)new IntToken(((Integer)ret).intValue()));
      }
 else       if (typ.equals(""String_Node_Str"")) {
        port.send(0,(Token)new UnsignedByteToken(((Byte)ret).byteValue()));
      }
 else {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
 else     if (port.isOutput() && !(port.getName().equals(this.getArgumentReturn().getName()))) {
      String typ=""String_Node_Str"";
      Field field=null;
      try {
        field=_class.getDeclaredField(""String_Node_Str"" + port.getName());
        typ=(String)field.getType().toString();
      }
 catch (      NoSuchFieldException ex) {
        try {
          field=_class.getDeclaredField(""String_Node_Str"" + port.getName().substring(0,port.getName().length() - 3));
          typ=(String)field.getType().toString();
        }
 catch (        Exception e) {
          try {
            MessageHandler.warning(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
          }
 catch (          Exception ex2) {
            getDirector().stop();
          }
        }
      }
      if (typ.equals(""String_Node_Str"")) {
        try {
          port.send(0,(Token)new BooleanToken(field.getBoolean(obj)));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else       if (typ.equals(""String_Node_Str"")) {
        try {
          port.send(0,(Token)new DoubleToken(field.getDouble(obj)));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else       if (typ.equals(""String_Node_Str"")) {
        try {
          port.send(0,(Token)new IntToken(field.getInt(obj)));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else       if (typ.equals(""String_Node_Str"")) {
        try {
          port.send(0,(Token)new UnsignedByteToken((char)field.getChar(obj)));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else       if (typ.equals(""String_Node_Str"")) {
        try {
          int[] tab=(int[])field.get(obj);
          Token[] toks=new Token[((int[])field.get(obj)).length];
          for (int j=0; j < ((int[])field.get(obj)).length; j++)           toks[j]=new IntToken(((int[])field.get(obj))[j]);
          port.send(0,new ArrayToken(toks));
        }
 catch (        IllegalAccessException ex) {
          MessageHandler.error(""String_Node_Str"",ex);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
}"
75589,"/** 
 * Return a new array of length <i>newLength</i> that is formed by either truncating or padding the input array. Elements from the input array are copied to the output array, starting from array[startIdx] until one of the following conditions is met : 1) The input array has no more elements to copy. 2) The output array has been completely filled. <i>startIdx</i> must index a valid entry in <i>array</i> unless the input array is of zero length or the output array is of zero length. If case 1) is met, the remainder of the output array is filled with new complex numbers with value 0. Copying here means shallow copying, i.e. pointers to Complex objects are copied instead of allocation of new copies. This works because Complex objects are immutable.
 * @param array An array of complex numbers.
 * @param newLength The desired size of the output array.
 * @param startIdx The starting index for the input array.
 * @return A new array of length <i>newLength</i> that is formed byeither truncating or padding <i>array</i>.
 */
public static final Complex[] resize(final Complex[] array,final int newLength,final int startIdx){
  Complex[] returnValue=new Complex[newLength];
  int copySize=Math.min(newLength,array.length - startIdx);
  if ((startIdx >= array.length) && (copySize >= 0)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (copySize > 0) {
    System.arraycopy(array,startIdx,returnValue,0,copySize);
  }
  for (int i=copySize; i < newLength; i++) {
    returnValue[i]=Complex.ZERO;
  }
  return returnValue;
}","/** 
 * Return a new array of length <i>newLength</i> that is formed by either truncating or padding the input array. Elements from the input array are copied to the output array, starting from array[startIdx] until one of the following conditions is met : 1) The input array has no more elements to copy. 2) The output array has been completely filled. <i>startIdx</i> must index a valid entry in <i>array</i> unless the input array is of zero length or the output array is of zero length. If case 1) is met, the remainder of the output array is filled with new complex numbers with value 0. Copying here means shallow copying, i.e. pointers to Complex objects are copied instead of allocation of new copies. This works because Complex objects are immutable.
 * @param array An array of complex numbers.
 * @param newLength The desired size of the output array.
 * @param startIdx The starting index for the input array.
 * @return A new array of length <i>newLength</i> that is formed byeither truncating or padding <i>array</i>.
 */
public static final Complex[] resize(final Complex[] array,final int newLength,final int startIdx){
  Complex[] returnValue=new Complex[newLength];
  int copySize=Math.min(newLength,array.length - startIdx);
  if ((startIdx >= array.length) && (copySize > 0)) {
    throw new IllegalArgumentException(""String_Node_Str"" + startIdx + ""String_Node_Str""+ array.length+ ""String_Node_Str""+ copySize+ ""String_Node_Str"");
  }
  if (copySize > 0) {
    System.arraycopy(array,startIdx,returnValue,0,copySize);
  }
  for (int i=copySize; i < newLength; i++) {
    returnValue[i]=Complex.ZERO;
  }
  return returnValue;
}"
75590,"/** 
 * If <i>trainingMode</i> is <i>true</i>, then take the collected training tokens and store them as an array in <i>correctValues</i>.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  boolean training=((BooleanToken)trainingMode.getToken()).booleanValue();
  if (training && _trainingTokens != null) {
    Object[] newValues=_trainingTokens.toArray();
    Token[] newTokens=new Token[newValues.length];
    for (int i=0; i < newValues.length; i++) {
      newTokens[i]=(Token)newValues[i];
    }
    correctValues.setToken(new ArrayToken(newTokens));
  }
}","/** 
 * If <i>trainingMode</i> is <i>true</i>, then take the collected training tokens and store them as an array in <i>correctValues</i>.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  boolean training=((BooleanToken)trainingMode.getToken()).booleanValue();
  if (training && _trainingTokens != null && _trainingTokens.size() > 0) {
    Object[] newValues=_trainingTokens.toArray();
    Token[] newTokens=new Token[newValues.length];
    for (int i=0; i < newValues.length; i++) {
      newTokens[i]=(Token)newValues[i];
    }
    correctValues.setToken(new ArrayToken(newTokens));
  }
}"
75591,"/** 
 * If the specified actor has not be prefired() in the current iteration, then prefire() it.
 * @param actor The actor to prefire().
 * @exception IllegalActionException If the actor returns false.
 */
protected void _prefireIfNecessary(Actor actor) throws IllegalActionException {
  CTDirector dir=(CTDirector)getContainer();
  if (dir.isPrefireComplete(actor)) {
    _debug(getFullName() + ""String_Node_Str"" + ((Nameable)actor).getName());
    dir.setPrefireComplete(actor);
    if (!actor.prefire()) {
      throw new IllegalActionException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}","/** 
 * If the specified actor has not be prefired() in the current iteration, then prefire() it.
 * @param actor The actor to prefire().
 * @exception IllegalActionException If the actor returns false.
 */
protected void _prefireIfNecessary(Actor actor) throws IllegalActionException {
  CTDirector dir=(CTDirector)getContainer();
  if (!dir.isPrefireComplete(actor)) {
    _debug(getFullName() + ""String_Node_Str"" + ((Nameable)actor).getName());
    dir.setPrefireComplete(actor);
    if (!actor.prefire()) {
      throw new IllegalActionException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}"
75592,"/** 
 * Return a MoML String that will delete the given node from the Ptolemy model.
 * @return A valid MoML string.
 */
public String getDeleteNodeMoML(Object node){
  ComponentRelation deleteObj=(ComponentRelation)((Vertex)node).getContainer();
  NamedObj container=_getChangeRequestParent(getPtolemyModel());
  System.out.println(""String_Node_Str"" + container.getFullName());
  String moml=""String_Node_Str"" + deleteObj.getName(container) + ""String_Node_Str"";
  return moml;
}","/** 
 * Return a MoML String that will delete the given node from the Ptolemy model.
 * @return A valid MoML string.
 */
public String getDeleteNodeMoML(Object node){
  ComponentRelation deleteObj=(ComponentRelation)((Vertex)node).getContainer();
  NamedObj container=_getChangeRequestParent(getPtolemyModel());
  String moml=""String_Node_Str"" + deleteObj.getName(container) + ""String_Node_Str"";
  return moml;
}"
75593,"private void _updateLinks(ComponentRelation relation){
  List linkedPortList=relation.linkedPortList();
  int allPortCount=linkedPortList.size();
  Iterator links=new LinkedList(_linkSet).iterator();
  while (links.hasNext()) {
    Link link=(Link)links.next();
    if (link.getRelation() != relation)     continue;
    Object tail=link.getTail();
    Object tailObj=getSemanticObject(tail);
    if (tailObj != null && linkedPortList.contains(tailObj)) {
      linkedPortList.remove(tailObj);
    }
 else {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
    Object head=link.getHead();
    Object headObj=getSemanticObject(head);
    if (headObj != null && linkedPortList.contains(headObj)) {
      linkedPortList.remove(headObj);
    }
 else {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
  }
  int unlinkedPortCount=linkedPortList.size();
  if (unlinkedPortCount == 0)   return;
  Iterator vertexes=relation.attributeList(Vertex.class).iterator();
  Vertex rootVertex=null;
  while (vertexes.hasNext()) {
    Vertex v=(Vertex)vertexes.next();
    if (v.getLinkedVertex() == null) {
      rootVertex=v;
    }
  }
  if (rootVertex == null && allPortCount == 2 && unlinkedPortCount == 2) {
    Port port1=(Port)linkedPortList.get(0);
    Port port2=(Port)linkedPortList.get(1);
    Object head=null;
    Object tail=null;
    if (port1.getContainer().equals(getRoot())) {
      head=_getLocation(port1);
    }
 else {
      head=port1;
    }
    if (port2.getContainer().equals(getRoot())) {
      tail=_getLocation(port2);
    }
 else {
      tail=port2;
    }
    Link link;
    try {
      link=new Link();
      _linkSet.add(link);
    }
 catch (    Exception e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
    }
    link.setRelation(relation);
    link.setHead(head);
    link.setTail(tail);
  }
 else {
    if (rootVertex == null) {
      try {
        rootVertex=new Vertex(relation,relation.uniqueName(""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
    }
    Iterator ports=linkedPortList.iterator();
    while (ports.hasNext()) {
      Port port=(Port)ports.next();
      Object head=null;
      if (port.getContainer().equals(getRoot())) {
        head=_getLocation(port);
      }
 else {
        head=port;
      }
      Link link;
      try {
        link=new Link();
        _linkSet.add(link);
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
      link.setRelation(relation);
      link.setHead(head);
      link.setTail(rootVertex);
    }
  }
}","private void _updateLinks(ComponentRelation relation){
  List linkedPortList=relation.linkedPortList();
  int allPortCount=linkedPortList.size();
  Iterator links=new LinkedList(_linkSet).iterator();
  while (links.hasNext()) {
    Link link=(Link)links.next();
    if (link.getRelation() != relation) {
      continue;
    }
    Object tail=link.getTail();
    Object tailObj=getSemanticObject(tail);
    if (tailObj != null && linkedPortList.contains(tailObj)) {
      linkedPortList.remove(tailObj);
    }
 else     if (tailObj != relation) {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
    Object head=link.getHead();
    Object headObj=getSemanticObject(head);
    if (headObj != null && linkedPortList.contains(headObj)) {
      linkedPortList.remove(headObj);
    }
 else     if (headObj != relation) {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
  }
  int unlinkedPortCount=linkedPortList.size();
  if (unlinkedPortCount == 0)   return;
  Iterator vertexes=relation.attributeList(Vertex.class).iterator();
  Vertex rootVertex=null;
  while (vertexes.hasNext()) {
    Vertex v=(Vertex)vertexes.next();
    if (v.getLinkedVertex() == null) {
      rootVertex=v;
    }
  }
  if (rootVertex == null && allPortCount == 2 && unlinkedPortCount == 2) {
    Port port1=(Port)linkedPortList.get(0);
    Port port2=(Port)linkedPortList.get(1);
    Object head=null;
    Object tail=null;
    if (port1.getContainer().equals(getRoot())) {
      head=_getLocation(port1);
    }
 else {
      head=port1;
    }
    if (port2.getContainer().equals(getRoot())) {
      tail=_getLocation(port2);
    }
 else {
      tail=port2;
    }
    Link link;
    try {
      link=new Link();
      _linkSet.add(link);
    }
 catch (    Exception e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
    }
    link.setRelation(relation);
    link.setHead(head);
    link.setTail(tail);
  }
 else {
    if (rootVertex == null) {
      try {
        rootVertex=new Vertex(relation,relation.uniqueName(""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
    }
    Iterator ports=linkedPortList.iterator();
    while (ports.hasNext()) {
      Port port=(Port)ports.next();
      Object head=null;
      if (port.getContainer().equals(getRoot())) {
        head=_getLocation(port);
      }
 else {
        head=port;
      }
      Link link;
      try {
        link=new Link();
        _linkSet.add(link);
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
      link.setRelation(relation);
      link.setHead(head);
      link.setTail(rootVertex);
    }
  }
}"
75594,"private void _updateLinks(ComponentRelation relation){
  List linkedPortList=relation.linkedPortList();
  int allPortCount=linkedPortList.size();
  Iterator links=_linkSet.iterator();
  while (links.hasNext()) {
    Link link=(Link)links.next();
    if (link.getRelation() != relation)     continue;
    Object tail=link.getTail();
    Object tailObj=getSemanticObject(tail);
    if (tailObj != null && linkedPortList.contains(tailObj)) {
      linkedPortList.remove(tailObj);
    }
    Object head=link.getHead();
    Object headObj=getSemanticObject(head);
    if (headObj != null && linkedPortList.contains(headObj)) {
      linkedPortList.remove(headObj);
    }
  }
  int unlinkedPortCount=linkedPortList.size();
  if (unlinkedPortCount == 0)   return;
  Iterator vertexes=relation.attributeList(Vertex.class).iterator();
  Vertex rootVertex=null;
  while (vertexes.hasNext()) {
    Vertex v=(Vertex)vertexes.next();
    if (v.getLinkedVertex() == null) {
      rootVertex=v;
    }
  }
  if (rootVertex == null && allPortCount == 2 && unlinkedPortCount == 2) {
    Port port1=(Port)linkedPortList.get(0);
    Port port2=(Port)linkedPortList.get(1);
    Object head=null;
    Object tail=null;
    if (port1.getContainer().equals(getRoot())) {
      head=_getLocation(port1);
    }
 else {
      head=port1;
    }
    if (port2.getContainer().equals(getRoot())) {
      tail=_getLocation(port2);
    }
 else {
      tail=port2;
    }
    Link link;
    try {
      link=new Link();
      _linkSet.add(link);
    }
 catch (    Exception e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
    }
    link.setRelation(relation);
    link.setHead(head);
    link.setTail(tail);
  }
 else {
    if (rootVertex == null) {
      try {
        rootVertex=new Vertex(relation,relation.uniqueName(""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
    }
    Iterator ports=linkedPortList.iterator();
    while (ports.hasNext()) {
      Port port=(Port)ports.next();
      Object head=null;
      if (port.getContainer().equals(getRoot())) {
        head=_getLocation(port);
      }
 else {
        head=port;
      }
      Link link;
      try {
        link=new Link();
        _linkSet.add(link);
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
      link.setRelation(relation);
      link.setHead(head);
      link.setTail(rootVertex);
    }
  }
}","private void _updateLinks(ComponentRelation relation){
  List linkedPortList=relation.linkedPortList();
  int allPortCount=linkedPortList.size();
  Iterator links=new LinkedList(_linkSet).iterator();
  while (links.hasNext()) {
    Link link=(Link)links.next();
    if (link.getRelation() != relation)     continue;
    Object tail=link.getTail();
    Object tailObj=getSemanticObject(tail);
    if (tailObj != null && linkedPortList.contains(tailObj)) {
      linkedPortList.remove(tailObj);
    }
 else {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
    Object head=link.getHead();
    Object headObj=getSemanticObject(head);
    if (headObj != null && linkedPortList.contains(headObj)) {
      linkedPortList.remove(headObj);
    }
 else {
      link.setHead(null);
      link.setTail(null);
      _linkSet.remove(link);
    }
  }
  int unlinkedPortCount=linkedPortList.size();
  if (unlinkedPortCount == 0)   return;
  Iterator vertexes=relation.attributeList(Vertex.class).iterator();
  Vertex rootVertex=null;
  while (vertexes.hasNext()) {
    Vertex v=(Vertex)vertexes.next();
    if (v.getLinkedVertex() == null) {
      rootVertex=v;
    }
  }
  if (rootVertex == null && allPortCount == 2 && unlinkedPortCount == 2) {
    Port port1=(Port)linkedPortList.get(0);
    Port port2=(Port)linkedPortList.get(1);
    Object head=null;
    Object tail=null;
    if (port1.getContainer().equals(getRoot())) {
      head=_getLocation(port1);
    }
 else {
      head=port1;
    }
    if (port2.getContainer().equals(getRoot())) {
      tail=_getLocation(port2);
    }
 else {
      tail=port2;
    }
    Link link;
    try {
      link=new Link();
      _linkSet.add(link);
    }
 catch (    Exception e) {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
    }
    link.setRelation(relation);
    link.setHead(head);
    link.setTail(tail);
  }
 else {
    if (rootVertex == null) {
      try {
        rootVertex=new Vertex(relation,relation.uniqueName(""String_Node_Str""));
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
    }
    Iterator ports=linkedPortList.iterator();
    while (ports.hasNext()) {
      Port port=(Port)ports.next();
      Object head=null;
      if (port.getContainer().equals(getRoot())) {
        head=_getLocation(port);
      }
 else {
        head=port;
      }
      Link link;
      try {
        link=new Link();
        _linkSet.add(link);
      }
 catch (      Exception e) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ e.getMessage());
      }
      link.setRelation(relation);
      link.setHead(head);
      link.setTail(rootVertex);
    }
  }
}"
75595,"/** 
 * Delete the currently selected objects from this document.
 */
public void delete(){
  GraphPane graphPane=_jgraph.getGraphPane();
  GraphController controller=(GraphController)graphPane.getGraphController();
  SelectionModel model=controller.getSelectionModel();
  AbstractBasicGraphModel graphModel=(AbstractBasicGraphModel)controller.getGraphModel();
  Object selection[]=model.getSelectionAsArray();
  Object userObjects[]=new Object[selection.length];
  for (int i=0; i < selection.length; i++) {
    userObjects[i]=((Figure)selection[i]).getUserObject();
    model.removeSelection(selection[i]);
  }
  HashSet namedObjNodeSet=new HashSet();
  HashSet namedObjEdgeSet=new HashSet();
  HashSet edgeSet=new HashSet();
  for (int i=0; i < selection.length; i++) {
    if (selection[i] instanceof Figure) {
      Object userObject=((Figure)selection[i]).getUserObject();
      if (graphModel.isEdge(userObject) || graphModel.isNode(userObject)) {
        NamedObj actual=(NamedObj)graphModel.getSemanticObject(userObject);
        if (actual != null) {
          if (graphModel.isEdge(userObject)) {
            namedObjEdgeSet.add(actual);
          }
 else {
            namedObjNodeSet.add(actual);
          }
        }
 else {
          edgeSet.add(userObject);
        }
      }
    }
  }
  LinkedHashSet namedObjList=new LinkedHashSet(namedObjEdgeSet);
  namedObjList.addAll(namedObjNodeSet);
  StringBuffer moml=new StringBuffer();
  moml.append(""String_Node_Str"");
  Iterator elements=namedObjList.iterator();
  while (elements.hasNext()) {
    NamedObj element=(NamedObj)elements.next();
    String deleteElemName=""String_Node_Str"";
    if (element instanceof Relation) {
      deleteElemName=""String_Node_Str"";
    }
 else     if (element instanceof Entity) {
      deleteElemName=""String_Node_Str"";
    }
 else     if (element instanceof Attribute) {
      deleteElemName=""String_Node_Str"";
    }
 else     if (element instanceof Port) {
      deleteElemName=""String_Node_Str"";
    }
 else {
    }
    if (deleteElemName.length() > 0) {
      moml.append(""String_Node_Str"" + deleteElemName + ""String_Node_Str""+ element.getName()+ ""String_Node_Str"");
    }
  }
  moml.append(""String_Node_Str"");
  try {
    graphModel.setDispatchEnabled(false);
    Iterator edges=edgeSet.iterator();
    while (edges.hasNext()) {
      Object nextEdge=edges.next();
      if (graphModel.isEdge(nextEdge)) {
        graphModel.disconnectEdge(this,nextEdge);
      }
    }
  }
  finally {
    graphModel.setDispatchEnabled(true);
  }
  try {
    CompositeEntity toplevel=(CompositeEntity)graphModel.getRoot();
    MoMLChangeRequest change=new MoMLChangeRequest(this,toplevel,moml.toString());
    change.setUndoable(true);
    toplevel.requestChange(change);
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"" + moml,ex);
  }
}","/** 
 * Delete the currently selected objects from this document.
 */
public void delete(){
  GraphPane graphPane=_jgraph.getGraphPane();
  GraphController controller=(GraphController)graphPane.getGraphController();
  SelectionModel model=controller.getSelectionModel();
  AbstractBasicGraphModel graphModel=(AbstractBasicGraphModel)controller.getGraphModel();
  Object selection[]=model.getSelectionAsArray();
  Object userObjects[]=new Object[selection.length];
  for (int i=0; i < selection.length; i++) {
    userObjects[i]=((Figure)selection[i]).getUserObject();
    model.removeSelection(selection[i]);
  }
  HashSet namedObjNodeSet=new HashSet();
  HashSet namedObjEdgeSet=new HashSet();
  HashSet edgeSet=new HashSet();
  StringBuffer moml=new StringBuffer();
  moml.append(""String_Node_Str"");
  for (int i=0; i < selection.length; i++) {
    Object userObject=userObjects[i];
    if (graphModel.isEdge(userObject)) {
      NamedObj actual=(NamedObj)graphModel.getSemanticObject(userObject);
      if (actual != null) {
        moml.append(graphModel.getDeleteEdgeMoML(userObject));
      }
 else {
        edgeSet.add(userObject);
      }
    }
  }
  for (int i=0; i < selection.length; i++) {
    Object userObject=userObjects[i];
    if (graphModel.isNode(userObject)) {
      moml.append(graphModel.getDeleteNodeMoML(userObject));
    }
  }
  moml.append(""String_Node_Str"");
  try {
    graphModel.setDispatchEnabled(false);
    Iterator edges=edgeSet.iterator();
    while (edges.hasNext()) {
      Object nextEdge=edges.next();
      if (graphModel.isEdge(nextEdge)) {
        graphModel.disconnectEdge(this,nextEdge);
      }
    }
  }
  finally {
    graphModel.setDispatchEnabled(true);
  }
  try {
    NamedObj object=(NamedObj)graphModel.getRoot();
    NamedObj container=MoMLChangeRequest.getDeferredToParent(object);
    if (container == null) {
      container=(NamedObj)object.getContainer();
    }
    if (container == null) {
      container=object;
    }
    CompositeEntity toplevel=(CompositeEntity)container;
    MoMLChangeRequest change=new MoMLChangeRequest(this,toplevel,moml.toString());
    change.setUndoable(true);
    toplevel.requestChange(change);
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"" + moml,ex);
  }
  graphModel.dispatchGraphEvent(new GraphEvent(this,GraphEvent.STRUCTURE_CHANGED,graphModel.getRoot()));
}"
75596,"/** 
 * Set the desired location of this node.  Throw an exception if the node can not be given a desired location.
 * @exception IllegalActionException Not thrown in this base class.
 */
public void setLocation(Object node,double[] location) throws IllegalActionException {
  if (node instanceof Locatable) {
    ((Locatable)node).setLocation(location);
  }
 else   throw new RuntimeException(""String_Node_Str"" + node + ""String_Node_Str"");
}","/** 
 * Set the desired location of this node.  Throw an exception if the node can not be given a desired location.
 * @exception IllegalActionException Not thrown in this base class.
 */
public void setLocation(Object node,double[] location) throws IllegalActionException {
  if (location != null && location.length != 2) {
    throw new RuntimeException(""String_Node_Str"" + location + ""String_Node_Str"");
  }
  if (node instanceof Locatable) {
    ((Locatable)node).setLocation(location);
  }
 else   throw new RuntimeException(""String_Node_Str"" + node + ""String_Node_Str"");
}"
75597,"/** 
 * Return true if the node is associated with a desired location. In this base class, return true if the the node's semantic object is an instance of Locatable.
 */
public boolean hasLocation(Object node){
  if (node instanceof Locatable) {
    Locatable object=(Locatable)node;
    double[] location=object.getLocation();
    if (location != null)     return true;
  }
  return false;
}","/** 
 * Return true if the node is associated with a desired location. In this base class, return true if the the node's semantic object is an instance of Locatable.
 */
public boolean hasLocation(Object node){
  if (node instanceof Locatable) {
    Locatable object=(Locatable)node;
    double[] location=object.getLocation();
    if (location != null && location.length == 2) {
      return true;
    }
  }
  return false;
}"
75598,"/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_skipElement <= 0) {
      if (_configureNesting > 0 || _docNesting > 0) {
        if (elementName.equals(""String_Node_Str"")) {
          _configureNesting++;
        }
 else         if (elementName.equals(""String_Node_Str"")) {
          _docNesting++;
        }
        _currentCharData.append(_getCurrentElement(elementName));
        _attributes.clear();
        _attributeNameList.clear();
        return;
      }
    }
    if (_skipRendition) {
      return;
    }
    if (_undoEnabled && _isUndoableElement(elementName)) {
      boolean childNodesUndoable=true;
      if (_undoContext != null) {
        _undoContexts.push(_undoContext);
        childNodesUndoable=_undoContext.hasUndoableChildren();
      }
      _undoContext=new UndoContext(childNodesUndoable);
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName);
      }
    }
    if (_skipElement > 0) {
      if (elementName.equals(_skipElementName)) {
        if (_skipElementIsNew) {
          _skipElementIsNew=false;
        }
 else {
          _skipElement++;
        }
      }
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      newEntity.getMoMLInfo().elementName=""String_Node_Str"";
      newEntity.getMoMLInfo().className=newEntity.getFullName();
      newEntity.getMoMLInfo().superclass=className;
      _current=newEntity;
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName,entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedPort;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedProp;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(deletedProp.exportMoML());
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedRelation;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      NamedObj container=_current;
      _pushContext();
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      ComponentEntity previous=_searchForEntity(entityName);
      boolean existedAlready=false;
      if (previous != null) {
        existedAlready=true;
      }
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      _current=newEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespaceTranslations.push(_namespaceTranslationTable);
        if (groupName.equals(""String_Node_Str"")) {
          _namespace=_AUTO_NAMESPACE;
          _namespaceTranslationTable=new HashMap();
        }
 else {
          _namespace=groupName;
        }
      }
 else {
        _namespaces.push(_DEFAULT_NAMESPACE);
        _namespaceTranslations.push(_namespaceTranslationTable);
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      boolean skip=false;
      if (inputFileNamesToSkip != null) {
        Iterator inputFileNames=inputFileNamesToSkip.iterator();
        while (inputFileNames.hasNext()) {
          String inputFileName=(String)inputFileNames.next();
          if (source.endsWith(inputFileName)) {
            skip=true;
            break;
          }
        }
      }
      if (!skip) {
        MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
        newParser.setContext(_current);
        newParser._propagating=_propagating;
        _parse(newParser,_base,source);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      String insertInsideAtSpec=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      int countArgs=0;
      if (insertAtSpec != null) {
        countArgs++;
      }
      if (insertInsideAtSpec != null) {
        countArgs++;
      }
      if (relationName != null) {
        countArgs++;
      }
      if (countArgs == 0) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      if (insertAtSpec != null && insertInsideAtSpec != null) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      int origNumOutsideLinks=port.numLinks();
      int origNumInsideLinks=port.numInsideLinks();
      ComponentRelation relation=null;
      if (relationName != null) {
        Relation tmpRelation=context.getRelation(relationName);
        _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
        relation=(ComponentRelation)tmpRelation;
      }
      int insertAt=-1;
      if (insertAtSpec != null) {
        insertAt=Integer.parseInt(insertAtSpec);
      }
      int insertInsideAt=-1;
      if (insertInsideAtSpec != null) {
        insertInsideAt=Integer.parseInt(insertInsideAtSpec);
      }
      if (insertAtSpec != null) {
        port.insertLink(insertAt,relation);
      }
 else       if (insertInsideAtSpec != null) {
        port.insertInsideLink(insertInsideAt,relation);
      }
 else {
        port.link(relation);
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (relation == null) {
          if (insertAt != -1) {
            if (port.numLinks() != origNumOutsideLinks) {
              _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ insertAtSpec+ ""String_Node_Str"");
            }
          }
 else {
            if (port.numInsideLinks() != origNumInsideLinks) {
              _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ insertInsideAtSpec+ ""String_Node_Str"");
            }
          }
        }
 else {
          if (port.numInsideLinks() != origNumInsideLinks) {
            if (insertInsideAt == -1) {
              insertInsideAt=port.numInsideLinks() - 1;
            }
            _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ insertInsideAt+ ""String_Node_Str"");
          }
 else           if (port.numLinks() != origNumOutsideLinks) {
            if (insertAt == -1) {
              insertAt=port.numLinks() - 1;
            }
            _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ insertAt+ ""String_Node_Str"");
          }
 else {
          }
        }
      }
      _recordLink(context,portName,relationName,insertAtSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null && !className.trim().equals(""String_Node_Str"")) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      boolean alreadyExisted=(port != null);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        if (newClass == null) {
          port=container.newPort(portName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
        }
        _recordNewObject(container,port);
      }
      _pushContext();
      _current=port;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          ioport.setOutput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
          ioport.setInput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      boolean isIOPort=(_current instanceof IOPort);
      if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        boolean previousValue=false;
        IOPort currentIOPort=(IOPort)_current;
        previousValue=currentIOPort.isMultiport();
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(false);
        }
        _pushContext();
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=_DEFAULT_NAMESPACE;
        if (_undoEnabled && _undoContext.isUndoable()) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + propertyName + ""String_Node_Str"");
          _undoContext.appendUndoMoML(previousValue + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        }
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        boolean previousValue=false;
        IOPort currentIOPort=(IOPort)_current;
        previousValue=currentIOPort.isOutput();
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(false);
        }
        _pushContext();
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=_DEFAULT_NAMESPACE;
        if (_undoEnabled && _undoContext.isUndoable()) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + propertyName + ""String_Node_Str"");
          _undoContext.appendUndoMoML(previousValue + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        }
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        boolean previousValue=false;
        IOPort currentIOPort=(IOPort)_current;
        previousValue=currentIOPort.isInput();
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(false);
        }
        _pushContext();
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=_DEFAULT_NAMESPACE;
        if (_undoEnabled && _undoContext.isUndoable()) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + propertyName + ""String_Node_Str"");
          _undoContext.appendUndoMoML(previousValue + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        }
      }
 else {
        NamedObj property=(Attribute)_current.getAttribute(propertyName);
        Class newClass=null;
        if (className != null) {
          try {
            newClass=Class.forName(className,true,_classLoader);
          }
 catch (          NoClassDefFoundError ex) {
            throw new XmlException(""String_Node_Str"" + className + ""String_Node_Str""+ KernelException.stackTraceToString(ex),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
          }
        }
        boolean createdNew=false;
        boolean previouslyExisted=(property != null);
        String oldClassName=null;
        String oldValue=null;
        if (previouslyExisted) {
          oldClassName=property.getClass().getName();
          if (property instanceof Settable) {
            Settable settable=(Settable)property;
            oldValue=settable.getExpression();
          }
        }
        if (property == null || (newClass != null && !newClass.isInstance(property))) {
          try {
            if (newClass == null) {
              newClass=Attribute.class;
            }
            Object[] arguments=new Object[2];
            arguments[0]=_current;
            arguments[1]=propertyName;
            property=_createInstance(newClass,arguments);
            if (value != null) {
              if (!(property instanceof Settable)) {
                throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + propertyName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
              }
              Settable settable=(Settable)property;
              settable.setExpression(value);
              _paramsToParse.add(property);
            }
            createdNew=true;
          }
 catch (          NameDuplicationException ex) {
          }
        }
        if (!createdNew) {
          if (value != null) {
            if (!(property instanceof Settable)) {
              throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
            }
            Settable settable=(Settable)property;
            settable.setExpression(value);
            _paramsToParse.add(property);
          }
        }
        _pushContext();
        _current=property;
        _namespace=_DEFAULT_NAMESPACE;
        if (_undoEnabled && _undoContext.isUndoable()) {
          if (!previouslyExisted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + propertyName + ""String_Node_Str"");
            _undoContext.setChildrenUndoable(false);
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + property.getName() + ""String_Node_Str"");
            _undoContext.appendUndoMoML(""String_Node_Str"" + oldClassName + ""String_Node_Str"");
            if (oldValue != null) {
              _undoContext.appendUndoMoML(""String_Node_Str"" + oldValue + ""String_Node_Str"");
            }
            _undoContext.appendUndoMoML(""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
            _undoContext.setChildrenUndoable(true);
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      boolean alreadyExisted=(relation != null);
      if (relation == null) {
        NamedObj newRelation=null;
        _pushContext();
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
        }
        _namespace=_DEFAULT_NAMESPACE;
        _recordNewObject(_current,newRelation);
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _pushContext();
        _current=relation;
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        String oldName=_current.getName();
        _current.setName(newName);
        if (_undoEnabled && _undoContext.isUndoable()) {
          try {
            UndoContext parentContext=(UndoContext)_undoContexts.peek();
            parentContext.applyRename(newName);
            _undoContext.appendUndoMoML(""String_Node_Str"" + oldName + ""String_Node_Str"");
            _undoContext.setChildrenUndoable(false);
          }
 catch (          Exception e) {
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      int countArgs=0;
      if (indexSpec != null)       countArgs++;
      if (insideIndexSpec != null)       countArgs++;
      if (relationName != null)       countArgs++;
      if (countArgs != 1) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      CompositeEntity container=(CompositeEntity)_current;
      if (relationName != null) {
        Relation tmpRelation=context.getRelation(relationName);
        _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
        ComponentRelation relation=(ComponentRelation)tmpRelation;
        if (_undoEnabled && _undoContext.isUndoable()) {
          ArrayList filter=new ArrayList(2);
          filter.add(relation);
          filter.add(port);
          String replicaLinkMoML=container.exportLinks(0,filter);
          _undoContext.appendUndoMoML(replicaLinkMoML);
        }
        port.unlink(relation);
      }
 else       if (indexSpec != null) {
        int index=Integer.parseInt(indexSpec);
        if (_undoEnabled && _undoContext.isUndoable()) {
          List linkedRelations=port.linkedRelationList();
          Relation r=(Relation)linkedRelations.get(index);
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ indexSpec+ ""String_Node_Str"");
          if (r != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + r.getName() + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
        }
        port.unlink(index);
      }
 else {
        int index=Integer.parseInt(insideIndexSpec);
        if (_undoEnabled && _undoContext.isUndoable()) {
          List linkedRelations=port.insideRelationList();
          Relation r=(Relation)linkedRelations.get(index);
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ index+ ""String_Node_Str"");
          if (r != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + r.getName() + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
        }
        port.unlinkInside(index);
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
      _recordUnlink(context,portName,relationName,indexSpec,insideIndexSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex previous=(Vertex)_current.getAttribute(vertexName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getExpression();
      }
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null) {
        vertex.setExpression(value);
        _paramsToParse.add(vertex);
      }
      _pushContext();
      _current=vertex;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + vertexName + ""String_Node_Str"");
        if (previousValue != null) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + previousValue + ""String_Node_Str"");
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
      }
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex.getTargetException());
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex.getTargetException());
  }
catch (  Exception ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex);
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex);
    }
  }
  _attributes.clear();
  _attributeNameList.clear();
}","/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_skipElement <= 0) {
      if (_configureNesting > 0 || _docNesting > 0) {
        if (elementName.equals(""String_Node_Str"")) {
          _configureNesting++;
        }
 else         if (elementName.equals(""String_Node_Str"")) {
          _docNesting++;
        }
        _currentCharData.append(_getCurrentElement(elementName));
        _attributes.clear();
        _attributeNameList.clear();
        return;
      }
    }
    if (_skipRendition) {
      return;
    }
    if (_undoEnabled && _isUndoableElement(elementName)) {
      boolean childNodesUndoable=true;
      if (_undoContext != null) {
        _undoContexts.push(_undoContext);
        childNodesUndoable=_undoContext.hasUndoableChildren();
      }
      _undoContext=new UndoContext(childNodesUndoable);
      if (_undoDebug) {
        System.out.println(""String_Node_Str"" + elementName);
      }
    }
    if (_skipElement > 0) {
      if (elementName.equals(_skipElementName)) {
        if (_skipElementIsNew) {
          _skipElementIsNew=false;
        }
 else {
          _skipElement++;
        }
      }
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      newEntity.getMoMLInfo().elementName=""String_Node_Str"";
      newEntity.getMoMLInfo().className=newEntity.getFullName();
      newEntity.getMoMLInfo().superclass=className;
      _current=newEntity;
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName,entityName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedPort;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedProp;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(deletedProp.exportMoML());
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _pushContext();
      }
      _current=deletedRelation;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      NamedObj container=_current;
      _pushContext();
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=_DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      ComponentEntity previous=_searchForEntity(entityName);
      boolean existedAlready=false;
      if (previous != null) {
        existedAlready=true;
      }
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _pushContext();
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
        if (_xmlFile != null) {
          URIAttribute attribute=new URIAttribute(_toplevel,""String_Node_Str"");
          attribute.setURL(_xmlFile);
        }
      }
      _current=newEntity;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (existedAlready) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + entityName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespaceTranslations.push(_namespaceTranslationTable);
        if (groupName.equals(""String_Node_Str"")) {
          _namespace=_AUTO_NAMESPACE;
          _namespaceTranslationTable=new HashMap();
        }
 else {
          _namespace=groupName;
        }
      }
 else {
        _namespaces.push(_DEFAULT_NAMESPACE);
        _namespaceTranslations.push(_namespaceTranslationTable);
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      boolean skip=false;
      if (inputFileNamesToSkip != null) {
        Iterator inputFileNames=inputFileNamesToSkip.iterator();
        while (inputFileNames.hasNext()) {
          String inputFileName=(String)inputFileNames.next();
          if (source.endsWith(inputFileName)) {
            skip=true;
            break;
          }
        }
      }
      if (!skip) {
        MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
        newParser.setContext(_current);
        newParser._propagating=_propagating;
        _parse(newParser,_base,source);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      String insertInsideAtSpec=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      int countArgs=0;
      if (insertAtSpec != null) {
        countArgs++;
      }
      if (insertInsideAtSpec != null) {
        countArgs++;
      }
      if (relationName != null) {
        countArgs++;
      }
      if (countArgs == 0) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      if (insertAtSpec != null && insertInsideAtSpec != null) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      int origNumOutsideLinks=port.numLinks();
      int origNumInsideLinks=port.numInsideLinks();
      ComponentRelation relation=null;
      if (relationName != null) {
        Relation tmpRelation=context.getRelation(relationName);
        _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
        relation=(ComponentRelation)tmpRelation;
      }
      int insertAt=-1;
      if (insertAtSpec != null) {
        insertAt=Integer.parseInt(insertAtSpec);
      }
      int insertInsideAt=-1;
      if (insertInsideAtSpec != null) {
        insertInsideAt=Integer.parseInt(insertInsideAtSpec);
      }
      if (insertAtSpec != null) {
        port.insertLink(insertAt,relation);
      }
 else       if (insertInsideAtSpec != null) {
        port.insertInsideLink(insertInsideAt,relation);
      }
 else {
        port.link(relation);
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (relation == null) {
          if (insertAt != -1) {
            if (port.numLinks() != origNumOutsideLinks) {
              _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ insertAtSpec+ ""String_Node_Str"");
            }
          }
 else {
            if (port.numInsideLinks() != origNumInsideLinks) {
              _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ insertInsideAtSpec+ ""String_Node_Str"");
            }
          }
        }
 else {
          if (port.numInsideLinks() != origNumInsideLinks) {
            if (insertInsideAt == -1) {
              insertInsideAt=port.numInsideLinks() - 1;
            }
            _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ insertInsideAt+ ""String_Node_Str"");
          }
 else           if (port.numLinks() != origNumOutsideLinks) {
            if (insertAt == -1) {
              insertAt=port.numLinks() - 1;
            }
            _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ insertAt+ ""String_Node_Str"");
          }
 else {
          }
        }
      }
      _recordLink(context,portName,relationName,insertAtSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null && !className.trim().equals(""String_Node_Str"")) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      boolean alreadyExisted=(port != null);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        if (newClass == null) {
          port=container.newPort(portName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
        }
        _recordNewObject(container,port);
      }
      _pushContext();
      _current=port;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          ioport.setOutput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
          ioport.setInput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      boolean isIOPort=(_current instanceof IOPort);
      if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        boolean previousValue=false;
        IOPort currentIOPort=(IOPort)_current;
        previousValue=currentIOPort.isMultiport();
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(false);
        }
        _pushContext();
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=_DEFAULT_NAMESPACE;
        if (_undoEnabled && _undoContext.isUndoable()) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + propertyName + ""String_Node_Str"");
          _undoContext.appendUndoMoML(previousValue + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        }
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        boolean previousValue=false;
        IOPort currentIOPort=(IOPort)_current;
        previousValue=currentIOPort.isOutput();
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(false);
        }
        _pushContext();
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=_DEFAULT_NAMESPACE;
        if (_undoEnabled && _undoContext.isUndoable()) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + propertyName + ""String_Node_Str"");
          _undoContext.appendUndoMoML(previousValue + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        }
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        boolean previousValue=false;
        IOPort currentIOPort=(IOPort)_current;
        previousValue=currentIOPort.isInput();
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(false);
        }
        _pushContext();
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=_DEFAULT_NAMESPACE;
        if (_undoEnabled && _undoContext.isUndoable()) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + propertyName + ""String_Node_Str"");
          _undoContext.appendUndoMoML(previousValue + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
        }
      }
 else {
        NamedObj property=(Attribute)_current.getAttribute(propertyName);
        Class newClass=null;
        if (className != null) {
          try {
            newClass=Class.forName(className,true,_classLoader);
          }
 catch (          NoClassDefFoundError ex) {
            throw new XmlException(""String_Node_Str"" + className + ""String_Node_Str""+ KernelException.stackTraceToString(ex),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
          }
        }
        boolean createdNew=false;
        boolean previouslyExisted=(property != null);
        String oldClassName=null;
        String oldValue=null;
        if (previouslyExisted) {
          oldClassName=property.getClass().getName();
          if (property instanceof Settable) {
            Settable settable=(Settable)property;
            oldValue=settable.getExpression();
          }
        }
        if (property == null || (newClass != null && !newClass.isInstance(property))) {
          try {
            if (newClass == null) {
              newClass=Attribute.class;
            }
            Object[] arguments=new Object[2];
            arguments[0]=_current;
            arguments[1]=propertyName;
            property=_createInstance(newClass,arguments);
            if (value != null) {
              if (!(property instanceof Settable)) {
                throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + propertyName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
              }
              Settable settable=(Settable)property;
              settable.setExpression(value);
              _paramsToParse.add(property);
            }
            createdNew=true;
          }
 catch (          NameDuplicationException ex) {
          }
        }
        if (!createdNew) {
          if (value != null) {
            if (!(property instanceof Settable)) {
              throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
            }
            Settable settable=(Settable)property;
            settable.setExpression(value);
            _paramsToParse.add(property);
          }
        }
        _pushContext();
        _current=property;
        _namespace=_DEFAULT_NAMESPACE;
        if (_undoEnabled && _undoContext.isUndoable()) {
          if (!previouslyExisted) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + propertyName + ""String_Node_Str"");
            _undoContext.setChildrenUndoable(false);
          }
 else {
            _undoContext.appendUndoMoML(""String_Node_Str"" + property.getName() + ""String_Node_Str"");
            _undoContext.appendUndoMoML(""String_Node_Str"" + oldClassName + ""String_Node_Str"");
            if (oldValue != null) {
              _undoContext.appendUndoMoML(""String_Node_Str"" + oldValue + ""String_Node_Str"");
            }
            _undoContext.appendUndoMoML(""String_Node_Str"");
            _undoContext.appendClosingUndoMoML(""String_Node_Str"");
            _undoContext.setChildrenUndoable(true);
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      boolean alreadyExisted=(relation != null);
      if (relation == null) {
        NamedObj newRelation=null;
        _pushContext();
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
        }
        _namespace=_DEFAULT_NAMESPACE;
        _recordNewObject(_current,newRelation);
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _pushContext();
        _current=relation;
        _namespace=_DEFAULT_NAMESPACE;
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        if (alreadyExisted) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          if (className != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + className + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
          _undoContext.appendClosingUndoMoML(""String_Node_Str"");
          _undoContext.setChildrenUndoable(true);
        }
 else {
          _undoContext.appendUndoMoML(""String_Node_Str"" + relationName + ""String_Node_Str"");
          _undoContext.setChildrenUndoable(false);
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        String oldName=_current.getName();
        _current.setName(newName);
        if (_undoEnabled && _undoContext.isUndoable()) {
          try {
            UndoContext parentContext=(UndoContext)_undoContexts.peek();
            parentContext.applyRename(newName);
            _undoContext.appendUndoMoML(""String_Node_Str"" + oldName + ""String_Node_Str"");
            _undoContext.setChildrenUndoable(false);
          }
 catch (          Exception e) {
          }
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      int countArgs=0;
      if (indexSpec != null) {
        countArgs++;
      }
      if (insideIndexSpec != null) {
        countArgs++;
      }
      if (relationName != null) {
        countArgs++;
      }
      if (countArgs != 1) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      CompositeEntity container=(CompositeEntity)_current;
      if (relationName != null) {
        Relation tmpRelation=context.getRelation(relationName);
        _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
        ComponentRelation relation=(ComponentRelation)tmpRelation;
        if (_undoEnabled && _undoContext.isUndoable()) {
          List linkedRelations=port.linkedRelationList();
          int index=linkedRelations.indexOf(tmpRelation);
          if (index != -1) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ index+ ""String_Node_Str""+ relationName+ ""String_Node_Str"");
          }
 else {
            List insideLinkedRelations=port.insideRelationList();
            index=insideLinkedRelations.indexOf(tmpRelation);
            _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ index+ ""String_Node_Str""+ relationName+ ""String_Node_Str"");
          }
        }
        port.unlink(relation);
      }
 else       if (indexSpec != null) {
        int index=Integer.parseInt(indexSpec);
        if (_undoEnabled && _undoContext.isUndoable()) {
          List linkedRelations=port.linkedRelationList();
          Relation r=(Relation)linkedRelations.get(index);
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ indexSpec+ ""String_Node_Str"");
          if (r != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + r.getName(context) + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
        }
        port.unlink(index);
      }
 else {
        int index=Integer.parseInt(insideIndexSpec);
        if (_undoEnabled && _undoContext.isUndoable()) {
          List linkedRelations=port.insideRelationList();
          Relation r=(Relation)linkedRelations.get(index);
          _undoContext.appendUndoMoML(""String_Node_Str"" + portName + ""String_Node_Str""+ index+ ""String_Node_Str"");
          if (r != null) {
            _undoContext.appendUndoMoML(""String_Node_Str"" + r.getName(context) + ""String_Node_Str"");
          }
          _undoContext.appendUndoMoML(""String_Node_Str"");
        }
        port.unlinkInside(index);
      }
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.setChildrenUndoable(false);
      }
      _recordUnlink(context,portName,relationName,indexSpec,insideIndexSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex previous=(Vertex)_current.getAttribute(vertexName);
      String previousValue=null;
      if (previous != null) {
        previousValue=previous.getExpression();
      }
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null) {
        vertex.setExpression(value);
        _paramsToParse.add(vertex);
      }
      _pushContext();
      _current=vertex;
      _namespace=_DEFAULT_NAMESPACE;
      if (_undoEnabled && _undoContext.isUndoable()) {
        _undoContext.appendUndoMoML(""String_Node_Str"" + vertexName + ""String_Node_Str"");
        if (previousValue != null) {
          _undoContext.appendUndoMoML(""String_Node_Str"" + previousValue + ""String_Node_Str"");
        }
        _undoContext.appendUndoMoML(""String_Node_Str"");
        _undoContext.setChildrenUndoable(true);
        _undoContext.appendClosingUndoMoML(""String_Node_Str"");
      }
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex.getTargetException());
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException(),_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex.getTargetException());
  }
catch (  Exception ex) {
    if (_handler != null) {
      int reply=_handler.handleError(_getCurrentElement(elementName),_current,ex);
      if (reply == ErrorHandler.CONTINUE) {
        _attributes.clear();
        _attributeNameList.clear();
        _skipElement=1;
        _skipElementName=elementName;
        return;
      }
 else       if (reply == ErrorHandler.CANCEL) {
        throw new XmlException(""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
    }
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      throw new XmlException(""String_Node_Str"" + elementName + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber(),ex);
    }
  }
  _attributes.clear();
  _attributeNameList.clear();
}"
75599,"public void initialize() throws IllegalActionException {
  super.initialize();
  if (_canvas == null) {
    place(_container);
  }
  if (_frame != null) {
    _frame.setVisible(true);
  }
  if (simpleUniverse == null) {
    simpleUniverse=new SimpleUniverse(_canvas);
  }
  Enumeration branches=simpleUniverse.getLocale().getAllBranchGraphs();
  while (branches.hasMoreElements()) {
    BranchGroup branchGroup=(BranchGroup)branches.nextElement();
    if (branchGroup.getCapability(BranchGroup.ALLOW_DETACH)) {
      if (!(branchGroup instanceof com.sun.j3d.utils.universe.ViewingPlatform)) {
        simpleUniverse.getLocale().removeBranchGraph(branchGroup);
      }
    }
  }
  branchRoot=new BranchGroup();
  branchRoot.setCapability(BranchGroup.ALLOW_DETACH);
  _userTransformation=new TransformGroup(_lastTransform);
  _userTransformation.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
  _userTransformation.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
  branchRoot.addChild(_userTransformation);
  bounds=new BoundingSphere(new Point3d(0.0,0.0,0.0),100.0);
  if (_isRotatable()) {
    mouseRotate=new MouseRotateView(this);
    mouseRotate.setTransformGroup(_userTransformation);
    mouseRotate.setSchedulingBounds(bounds);
    branchRoot.addChild(mouseRotate);
  }
  if (_isScalable()) {
    MouseZoom mouseZoom=new MouseZoom();
    mouseZoom.setTransformGroup(_userTransformation);
    mouseZoom.setSchedulingBounds(bounds);
    branchRoot.addChild(mouseZoom);
  }
  if (_isTranslatable()) {
    MouseTranslate mouseTranslate=new MouseTranslate();
    mouseTranslate.setTransformGroup(_userTransformation);
    _userTransformation.addChild(mouseTranslate);
    mouseTranslate.setSchedulingBounds(bounds);
  }
  if (_isIterationSynchronized()) {
    _iterationSynchronized=true;
  }
 else {
    _iterationSynchronized=false;
  }
  if (_shouldShowAxes()) {
    Sphere origin=new Sphere((float)0.05);
    _userTransformation.addChild(origin);
    Cylinder yAxis=new Cylinder((float)0.01,(float)6.0);
    _userTransformation.addChild(yAxis);
    Cylinder xAxis=new Cylinder((float)0.01,(float)6.0);
    Transform3D rotation=new Transform3D();
    Quat4d quat=new Quat4d();
    quat.set(new AxisAngle4d(0.0,0.0,1.0,Math.PI / 2.0));
    rotation.set(quat);
    TransformGroup xAxisGroup=new TransformGroup(rotation);
    xAxisGroup.addChild(xAxis);
    _userTransformation.addChild(xAxisGroup);
    Cylinder zAxis=new Cylinder((float)0.01,(float)6.0);
    Transform3D rotation2=new Transform3D();
    Quat4d quat2=new Quat4d();
    quat2.set(new AxisAngle4d(1.0,0.0,0.0,Math.PI / 2.0));
    rotation2.set(quat2);
    TransformGroup zAxisGroup=new TransformGroup(rotation2);
    zAxisGroup.addChild(zAxis);
    _userTransformation.addChild(zAxisGroup);
  }
  BranchGroup lightRoot=new BranchGroup();
  AmbientLight lightA=new AmbientLight(new Color3f(0.8f,0.8f,0.8f));
  lightA.setInfluencingBounds(bounds);
  lightRoot.addChild(lightA);
  DirectionalLight lightD1=new DirectionalLight();
  lightD1.setInfluencingBounds(bounds);
  Vector3f direction=new Vector3f(0.0f,-1.0f,-1.0f);
  direction.normalize();
  lightD1.setDirection(direction);
  lightD1.setColor(new Color3f(1.0f,1.0f,1.0f));
  lightRoot.addChild(lightD1);
  simpleUniverse.getViewer().getView().setLocalEyeLightingEnable(true);
  simpleUniverse.addBranchGraph(lightRoot);
  if (_iterationSynchronized) {
    if (_canvas != null)     _canvas.stopRenderer();
  }
}","/** 
 * This method creates the ViewScreen frame if it hasn't been created (_canvas != null).  It sets up the canvas and draws any 3D  shapes.
 */
public void initialize() throws IllegalActionException {
  boolean addLights=false;
  super.initialize();
  if (_canvas == null) {
    place(_container);
    addLights=true;
  }
  if (_frame != null) {
    _frame.setVisible(true);
  }
  if (simpleUniverse == null) {
    simpleUniverse=new SimpleUniverse(_canvas);
  }
  Enumeration branches=simpleUniverse.getLocale().getAllBranchGraphs();
  while (branches.hasMoreElements()) {
    BranchGroup branchGroup=(BranchGroup)branches.nextElement();
    if (branchGroup.getCapability(BranchGroup.ALLOW_DETACH)) {
      if (!(branchGroup instanceof com.sun.j3d.utils.universe.ViewingPlatform)) {
        simpleUniverse.getLocale().removeBranchGraph(branchGroup);
      }
    }
  }
  branchRoot=new BranchGroup();
  branchRoot.setCapability(BranchGroup.ALLOW_DETACH);
  _userTransformation=new TransformGroup(_lastTransform);
  _userTransformation.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
  _userTransformation.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
  branchRoot.addChild(_userTransformation);
  bounds=new BoundingSphere(new Point3d(0.0,0.0,0.0),100.0);
  if (_isRotatable()) {
    mouseRotate=new MouseRotateView(this);
    mouseRotate.setTransformGroup(_userTransformation);
    mouseRotate.setSchedulingBounds(bounds);
    branchRoot.addChild(mouseRotate);
  }
  if (_isScalable()) {
    MouseZoom mouseZoom=new MouseZoom();
    mouseZoom.setTransformGroup(_userTransformation);
    mouseZoom.setSchedulingBounds(bounds);
    branchRoot.addChild(mouseZoom);
  }
  if (_isTranslatable()) {
    MouseTranslate mouseTranslate=new MouseTranslate();
    mouseTranslate.setTransformGroup(_userTransformation);
    _userTransformation.addChild(mouseTranslate);
    mouseTranslate.setSchedulingBounds(bounds);
  }
  if (_isIterationSynchronized()) {
    _iterationSynchronized=true;
  }
 else {
    _iterationSynchronized=false;
  }
  if (_shouldShowAxes()) {
    Sphere origin=new Sphere((float)0.05);
    _userTransformation.addChild(origin);
    Cylinder yAxis=new Cylinder((float)0.01,(float)6.0);
    _userTransformation.addChild(yAxis);
    Cylinder xAxis=new Cylinder((float)0.01,(float)6.0);
    Transform3D rotation=new Transform3D();
    Quat4d quat=new Quat4d();
    quat.set(new AxisAngle4d(0.0,0.0,1.0,Math.PI / 2.0));
    rotation.set(quat);
    TransformGroup xAxisGroup=new TransformGroup(rotation);
    xAxisGroup.addChild(xAxis);
    _userTransformation.addChild(xAxisGroup);
    Cylinder zAxis=new Cylinder((float)0.01,(float)6.0);
    Transform3D rotation2=new Transform3D();
    Quat4d quat2=new Quat4d();
    quat2.set(new AxisAngle4d(1.0,0.0,0.0,Math.PI / 2.0));
    rotation2.set(quat2);
    TransformGroup zAxisGroup=new TransformGroup(rotation2);
    zAxisGroup.addChild(zAxis);
    _userTransformation.addChild(zAxisGroup);
  }
  if (addLights) {
    BranchGroup lightRoot=new BranchGroup();
    AmbientLight lightA=new AmbientLight(new Color3f(0.8f,0.8f,0.8f));
    lightA.setInfluencingBounds(bounds);
    lightRoot.addChild(lightA);
    DirectionalLight lightD1=new DirectionalLight();
    lightD1.setInfluencingBounds(bounds);
    Vector3f direction=new Vector3f(0.0f,-1.0f,-1.0f);
    direction.normalize();
    lightD1.setDirection(direction);
    lightD1.setColor(new Color3f(1.0f,1.0f,1.0f));
    lightRoot.addChild(lightD1);
    simpleUniverse.getViewer().getView().setLocalEyeLightingEnable(true);
    simpleUniverse.addBranchGraph(lightRoot);
  }
  if (_iterationSynchronized) {
    if (_canvas != null)     _canvas.stopRenderer();
  }
}"
75600,"/** 
 * Write out the C (.i, .h, interface Header) files. Sample option arguments: <code>-p wjtp.writeJimple1 outDir:jimple1</code>
 * @param phaseName The name of the phase, for example<code>wjtp.writeJimple2</code>.
 * @param options The options Map.  This method uses the<code>outdir</code> option to specify where the .jimple file should be written
 */
protected void internalTransform(String phaseName,Map options){
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  String outDir=Options.getString(options,""String_Node_Str"");
  String mainFile=Options.getString(options,""String_Node_Str"") + ""String_Node_Str"";
  OverriddenMethodGenerator.init();
  ArrayList classList=new ArrayList();
  for (Iterator classes=Scene.v().getApplicationClasses().iterator(); classes.hasNext(); classList.add(classes.next()))   ;
  StringBuffer sourcesList=new StringBuffer();
  for (Iterator sootClasses=classList.iterator(); sootClasses.hasNext(); ) {
    SootClass sootClass=(SootClass)sootClasses.next();
    String fileName;
    if (!outDir.equals(""String_Node_Str"")) {
      File outDirFile=new File(outDir);
      if (!outDirFile.isDirectory()) {
        outDirFile.mkdirs();
      }
      fileName=outDir + System.getProperty(""String_Node_Str"");
    }
 else {
      fileName=""String_Node_Str"";
    }
    fileName+=sootClass.getName();
    HeaderFileGenerator hGenerator=new HeaderFileGenerator();
    CodeFileGenerator cGenerator=new CodeFileGenerator();
    InterfaceFileGenerator iGenerator=new InterfaceFileGenerator();
    CNames.setup();
    System.out.println(""String_Node_Str"" + mainFile);
    System.out.println(""String_Node_Str"" + sootClass.getName());
    boolean isMainClass=false;
    MainFileGenerator mGenerator=null;
    if (mainFile.equals(sootClass.getName())) {
      isMainClass=true;
      mGenerator=new MainFileGenerator();
    }
    System.out.println(""String_Node_Str"" + fileName);
    String code=null;
    code=iGenerator.generate(sootClass);
    FileHandler.write(fileName + InterfaceFileGenerator.interfaceFileNameSuffix(),code);
    code=hGenerator.generate(sootClass);
    FileHandler.write(fileName + ""String_Node_Str"",code);
    code=cGenerator.generate(sootClass);
    FileHandler.write(fileName + ""String_Node_Str"",code);
    sourcesList.append(""String_Node_Str"" + fileName + ""String_Node_Str"");
    if (isMainClass) {
      code=mGenerator.generate(sootClass);
      FileHandler.write(fileName + ""String_Node_Str"",code);
    }
    System.out.println(""String_Node_Str"" + fileName);
  }
  MakefileWriter.addMakefileSubstitution(""String_Node_Str"",sourcesList.toString());
  _completedTransform=true;
}","/** 
 * Write out the C (.i, .h, interface Header) files. Sample option arguments: <code>-p wjtp.writeJimple1 outDir:jimple1</code>
 * @param phaseName The name of the phase, for example<code>wjtp.writeJimple2</code>.
 * @param options The options Map.  This method uses the<code>outdir</code> option to specify where the .jimple file should be written
 */
protected void internalTransform(String phaseName,Map options){
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  String outDir=Options.getString(options,""String_Node_Str"");
  String mainFile=Options.getString(options,""String_Node_Str"") + ""String_Node_Str"";
  OverriddenMethodGenerator.init();
  ArrayList classList=new ArrayList();
  for (Iterator classes=Scene.v().getApplicationClasses().iterator(); classes.hasNext(); classList.add(classes.next()))   ;
  StringBuffer sourcesList=new StringBuffer();
  for (Iterator sootClasses=classList.iterator(); sootClasses.hasNext(); ) {
    SootClass sootClass=(SootClass)sootClasses.next();
    String fileName;
    if (!outDir.equals(""String_Node_Str"")) {
      File outDirFile=new File(outDir);
      if (!outDirFile.isDirectory()) {
        outDirFile.mkdirs();
      }
      fileName=outDir + System.getProperty(""String_Node_Str"");
    }
 else {
      fileName=""String_Node_Str"";
    }
    fileName+=sootClass.getName();
    HeaderFileGenerator hGenerator=new HeaderFileGenerator();
    CodeFileGenerator cGenerator=new CodeFileGenerator();
    InterfaceFileGenerator iGenerator=new InterfaceFileGenerator();
    CNames.setup();
    RequiredFileGenerator RFG=new RequiredFileGenerator();
    String classPath=Scene.v().getSootClassPath();
    System.out.println(""String_Node_Str"" + classPath);
    RFG.init(classPath,sootClass.getName());
    System.out.println(""String_Node_Str"" + mainFile);
    System.out.println(""String_Node_Str"" + sootClass.getName());
    boolean isMainClass=false;
    MainFileGenerator mGenerator=null;
    if (mainFile.equals(sootClass.getName())) {
      isMainClass=true;
      mGenerator=new MainFileGenerator();
    }
    System.out.println(""String_Node_Str"" + fileName);
    String code=null;
    code=iGenerator.generate(sootClass);
    FileHandler.write(fileName + InterfaceFileGenerator.interfaceFileNameSuffix(),code);
    code=hGenerator.generate(sootClass);
    FileHandler.write(fileName + ""String_Node_Str"",code);
    code=cGenerator.generate(sootClass);
    FileHandler.write(fileName + ""String_Node_Str"",code);
    sourcesList.append(""String_Node_Str"" + fileName + ""String_Node_Str"");
    boolean verbose=true;
    String compileMode=""String_Node_Str"";
    try {
      RFG.generateTransitiveClosureOf(classPath,sootClass.getName(),compileMode,verbose);
    }
 catch (    IOException exception) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (isMainClass) {
      code=mGenerator.generate(sootClass);
      FileHandler.write(fileName + ""String_Node_Str"",code);
    }
    System.out.println(""String_Node_Str"" + fileName);
  }
  MakefileWriter.addMakefileSubstitution(""String_Node_Str"",sourcesList.toString());
  _completedTransform=true;
}"
75601,"/** 
 * Create the MakeFile.
 * @param classPath The classPath.
 * @param className The class for which the Makefile is to be generated.The makefile will have the name <i>className</i>.make.
 */
public static void generateMakeFile(String classPath,String className){
  StringBuffer code=new StringBuffer();
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + NativeMethodGenerator.nativeBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + OverriddenMethodGenerator.overriddenBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + System.getProperty(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
  HashSet libSources=RequiredFileGenerator.generateUserClasses(code);
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + InterfaceFileGenerator.interfaceFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + InterfaceFileGenerator.interfaceFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  FileHandler.write(className + ""String_Node_Str"",code.toString());
}","/** 
 * Create the MakeFile.
 * @param classPath The classPath.
 * @param className The class for which the Makefile is to be generated.The makefile will have the name <i>className</i>.make.
 */
public static void generateMakeFile(String classPath,String className){
  StringBuffer code=new StringBuffer();
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + NativeMethodGenerator.nativeBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + OverriddenMethodGenerator.overriddenBodyLib + ""String_Node_Str"");
  code.append(""String_Node_Str"" + System.getProperty(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
  HashSet libSources=RequiredFileGenerator.generateUserClasses(code);
  code.append(""String_Node_Str"");
  Iterator i=libSources.iterator();
  while (i.hasNext()) {
    code.append(""String_Node_Str"" + (String)i.next() + ""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + InterfaceFileGenerator.interfaceFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + InterfaceFileGenerator.interfaceFileNameSuffix() + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  FileHandler.write(className + ""String_Node_Str"",code.toString());
}"
75602,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Assertion(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  assertion=new Parameter(this,""String_Node_Str"");
  _errorTolerance=(double)Complex.episilon;
  errorTolerance=new Parameter(this,""String_Node_Str"",new DoubleToken(_errorTolerance));
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Assertion(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  assertion=new Parameter(this,""String_Node_Str"");
  _errorTolerance=(double)Complex.epsilon;
  errorTolerance=new Parameter(this,""String_Node_Str"",new DoubleToken(_errorTolerance));
}"
75603,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Assertion newObject=(Assertion)super.clone(workspace);
  newObject._tokenMap=null;
  newObject._errorTolerance=(double)Complex.episilon;
  newObject._parseTree=null;
  newObject._parseTreeEvaluator=null;
  newObject._scope=null;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Assertion newObject=(Assertion)super.clone(workspace);
  newObject._tokenMap=null;
  newObject._errorTolerance=(double)Complex.epsilon;
  newObject._parseTree=null;
  newObject._parseTreeEvaluator=null;
  newObject._scope=null;
  return newObject;
}"
75604,"/** 
 * Write the model to the specified file.  This method delegates to the top effigy containing the associated Tableau, if there is one, and otherwise throws an exception. This ensures that the data written is the description of the entire model, not just the portion within some composite actor.
 * @param file The file to write to.
 * @exception IOException If the write fails.
 */
protected void _writeFile(File file) throws IOException {
  Tableau tableau=getTableau();
  if (tableau != null) {
    Effigy effigy=(Effigy)tableau.getContainer();
    if (effigy != null) {
      effigy.topEffigy().writeFile(file);
      return;
    }
  }
  throw new IOException(""String_Node_Str"");
}","/** 
 * Write the model to the specified file.  This method delegates to the top effigy containing the associated Tableau, if there is one, and otherwise throws an exception. This ensures that the data written is the description of the entire model, not just the portion within some composite actor.   It also adjusts the URIAttribute in the model to match the specified file, if necessary, and creates one otherwise.
 * @param file The file to write to.
 * @exception IOException If the write fails.
 */
protected void _writeFile(File file) throws IOException {
  Tableau tableau=getTableau();
  if (tableau != null) {
    Effigy effigy=(Effigy)tableau.getContainer();
    if (effigy != null) {
      Effigy topEffigy=effigy.topEffigy();
      topEffigy.writeFile(file);
      if (topEffigy instanceof PtolemyEffigy) {
        NamedObj model=((PtolemyEffigy)topEffigy).getModel();
        try {
          URIAttribute uri=new URIAttribute(model,""String_Node_Str"");
          uri.setURI(file.toURI());
        }
 catch (        KernelException ex) {
          throw new InternalErrorException(""String_Node_Str"");
        }
      }
      return;
    }
  }
  throw new IOException(""String_Node_Str"");
}"
75605,"/** 
 * Push the rates calculated for this system up to the contained Actor, but only if the ports do not have a set rates. This allows the container to be properly scheduled if it is in a hierarchical system and the outside system is SDF.
 * @param externalRates A map from external port to the rate of thatport.
 * @exception IllegalActionException If any called method throws it.
 * @exception NotSchedulableException If an external port is bothan input and an output, or neither an input or an output, or connected on the inside to ports that have different tokenInitProduction.
 */
private void _setContainerRates(Map externalRates) throws NotSchedulableException, IllegalActionException {
  Director director=(Director)getContainer();
  CompositeActor container=(CompositeActor)director.getContainer();
  Iterator ports=container.portList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"" + port.getName());
    }
    Integer rate=(Integer)externalRates.get(port);
    if (port.isInput() && port.isOutput()) {
      throw new NotSchedulableException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (port.isInput()) {
      _setIfNotDefined(port,""String_Node_Str"",rate.intValue());
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + rate.intValue());
      }
    }
 else     if (port.isOutput()) {
      _setIfNotDefined(port,""String_Node_Str"",rate.intValue());
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + rate.intValue());
      }
      Iterator connectedPorts=port.insidePortList().iterator();
      IOPort foundOutputPort=null;
      while (connectedPorts.hasNext()) {
        IOPort connectedPort=(IOPort)connectedPorts.next();
        if (connectedPort.isOutput()) {
          if (foundOutputPort != null && getTokenInitProduction(foundOutputPort) != getTokenInitProduction(connectedPort)) {
            throw new NotSchedulableException(""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str""+ foundOutputPort+ ""String_Node_Str""+ connectedPort);
          }
          _setIfNotDefined(port,""String_Node_Str"",getTokenInitProduction(connectedPort));
          if (_debugging && VERBOSE) {
            _debug(""String_Node_Str"" + getTokenInitProduction(connectedPort));
          }
          foundOutputPort=connectedPort;
        }
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + rate);
      }
    }
 else {
      throw new NotSchedulableException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}","/** 
 * Push the rates calculated for this system up to the contained Actor, but only if the ports do not have a set rates. This allows the container to be properly scheduled if it is in a hierarchical system and the outside system is SDF.
 * @param externalRates A map from external port to the rate of thatport.
 * @exception IllegalActionException If any called method throws it.
 * @exception NotSchedulableException If an external port is bothan input and an output, or neither an input or an output, or connected on the inside to ports that have different tokenInitProduction.
 */
private void _setContainerRates(Map externalRates) throws NotSchedulableException, IllegalActionException {
  Director director=(Director)getContainer();
  CompositeActor container=(CompositeActor)director.getContainer();
  Iterator ports=container.portList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    if (_debugging && VERBOSE) {
      _debug(""String_Node_Str"" + port.getName());
    }
    Integer rate=(Integer)externalRates.get(port);
    if (port.isInput() && port.isOutput()) {
      throw new NotSchedulableException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
 else     if (port.isInput()) {
      _setIfNotDefined(port,""String_Node_Str"",rate.intValue());
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + rate.intValue());
      }
    }
 else     if (port.isOutput()) {
      _setIfNotDefined(port,""String_Node_Str"",rate.intValue());
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + rate.intValue());
      }
      Iterator connectedPorts=port.deepInsidePortList().iterator();
      IOPort foundOutputPort=null;
      while (connectedPorts.hasNext()) {
        IOPort connectedPort=(IOPort)connectedPorts.next();
        if (connectedPort.isOutput()) {
          if (foundOutputPort != null && getTokenInitProduction(foundOutputPort) != getTokenInitProduction(connectedPort)) {
            throw new NotSchedulableException(""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str""+ foundOutputPort+ ""String_Node_Str""+ connectedPort);
          }
          _setIfNotDefined(port,""String_Node_Str"",getTokenInitProduction(connectedPort));
          if (_debugging && VERBOSE) {
            _debug(""String_Node_Str"" + getTokenInitProduction(connectedPort));
          }
          foundOutputPort=connectedPort;
        }
      }
      if (_debugging && VERBOSE) {
        _debug(""String_Node_Str"" + rate);
      }
    }
 else {
      throw new NotSchedulableException(port,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}"
75606,"/** 
 * Simulate the consumption of tokens by the actor during execution of the given number of firings. The entries in the waitingTokens map will be modified to reflect the number of tokens still waiting after the actor has consumed the minimum required number of tokens for all firings. Also determine if enough tokens still remain at the inputs of the actor for it to fire again immediately.
 * @param currentActor The actor that is being simulated.
 * @param waitingTokens A map between each input IOPort and the number oftokens in the queue for that port.  This will be updated to reflect the new number of waiting tokens.
 * @param firingCount The number of firings to simulate.
 * @return true If the actor can fire again right awayafter it has consumed tokens.
 * @exception IllegalActionException If the rate parameters are invalid.
 */
private boolean _simulateInputConsumption(ComponentEntity currentActor,Map waitingTokens,int firingCount) throws IllegalActionException {
  boolean stillReadyToSchedule=true;
  Iterator inputPorts=((Actor)currentActor).inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    int[] tokens=(int[])waitingTokens.get(inputPort);
    int tokenRate=getTokenConsumptionRate(inputPort);
    for (int channel=0; channel < inputPort.getWidth(); channel++) {
      tokens[channel]-=tokenRate;
      if (tokens[channel] < tokenRate) {
        stillReadyToSchedule=false;
      }
    }
  }
  return stillReadyToSchedule;
}","/** 
 * Simulate the consumption of tokens by the actor during execution of the given number of firings. The entries in the waitingTokens map will be modified to reflect the number of tokens still waiting after the actor has consumed the minimum required number of tokens for all firings. Also determine if enough tokens still remain at the inputs of the actor for it to fire again immediately.
 * @param currentActor The actor that is being simulated.
 * @param waitingTokens A map between each input IOPort and the number oftokens in the queue for that port.  This will be updated to reflect the new number of waiting tokens.
 * @param firingCount The number of firings to simulate.
 * @return true If the actor can fire again right awayafter it has consumed tokens.
 * @exception IllegalActionException If the rate parameters are invalid.
 */
private boolean _simulateInputConsumption(ComponentEntity currentActor,Map waitingTokens,int firingCount) throws IllegalActionException {
  boolean stillReadyToSchedule=true;
  Iterator inputPorts=((Actor)currentActor).inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort inputPort=(IOPort)inputPorts.next();
    int[] tokens=(int[])waitingTokens.get(inputPort);
    int tokenRate=getTokenConsumptionRate(inputPort);
    for (int channel=0; channel < inputPort.getWidth(); channel++) {
      tokens[channel]-=(tokenRate * firingCount);
      if (tokens[channel] < tokenRate) {
        stillReadyToSchedule=false;
      }
    }
  }
  return stillReadyToSchedule;
}"
75607,"public void initialize() throws IllegalActionException {
  super.initialize();
  if (_canvas == null) {
    place(_container);
  }
  if (_frame != null) {
    _frame.setVisible(true);
  }
  if (simpleUniverse == null) {
    simpleUniverse=new SimpleUniverse(_canvas);
  }
  Enumeration branches=simpleUniverse.getLocale().getAllBranchGraphs();
  while (branches.hasMoreElements()) {
    BranchGroup branchGroup=(BranchGroup)branches.nextElement();
    if (branchGroup.getCapability(BranchGroup.ALLOW_DETACH)) {
      simpleUniverse.getLocale().removeBranchGraph(branchGroup);
    }
  }
  branchRoot=new BranchGroup();
  branchRoot.setCapability(BranchGroup.ALLOW_DETACH);
  _userTransformation=new TransformGroup(_lastTransform);
  _userTransformation.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
  _userTransformation.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
  branchRoot.addChild(_userTransformation);
  bounds=new BoundingSphere(new Point3d(0.0,0.0,0.0),100.0);
  if (_isRotatable()) {
    mouseRotate=new MouseRotateView(this);
    mouseRotate.setTransformGroup(_userTransformation);
    mouseRotate.setSchedulingBounds(bounds);
    branchRoot.addChild(mouseRotate);
  }
  if (_isScalable()) {
    MouseZoom mouseZoom=new MouseZoom();
    mouseZoom.setTransformGroup(_userTransformation);
    mouseZoom.setSchedulingBounds(bounds);
    branchRoot.addChild(mouseZoom);
  }
  if (_isTranslatable()) {
    MouseTranslate mouseTranslate=new MouseTranslate();
    mouseTranslate.setTransformGroup(_userTransformation);
    _userTransformation.addChild(mouseTranslate);
    mouseTranslate.setSchedulingBounds(bounds);
  }
  if (_isIterationSynchronized()) {
    _iterationSynchronized=true;
  }
 else {
    _iterationSynchronized=false;
  }
  if (_shouldShowAxes()) {
    Sphere origin=new Sphere((float)0.05);
    _userTransformation.addChild(origin);
    Cylinder yAxis=new Cylinder((float)0.01,(float)6.0);
    _userTransformation.addChild(yAxis);
    Cylinder xAxis=new Cylinder((float)0.01,(float)6.0);
    Transform3D rotation=new Transform3D();
    Quat4d quat=new Quat4d();
    quat.set(new AxisAngle4d(0.0,0.0,1.0,Math.PI / 2.0));
    rotation.set(quat);
    TransformGroup xAxisGroup=new TransformGroup(rotation);
    xAxisGroup.addChild(xAxis);
    _userTransformation.addChild(xAxisGroup);
    Cylinder zAxis=new Cylinder((float)0.01,(float)6.0);
    Transform3D rotation2=new Transform3D();
    Quat4d quat2=new Quat4d();
    quat2.set(new AxisAngle4d(1.0,0.0,0.0,Math.PI / 2.0));
    rotation2.set(quat2);
    TransformGroup zAxisGroup=new TransformGroup(rotation2);
    zAxisGroup.addChild(zAxis);
    _userTransformation.addChild(zAxisGroup);
  }
  BranchGroup lightRoot=new BranchGroup();
  AmbientLight lightA=new AmbientLight(new Color3f(0.8f,0.8f,0.8f));
  lightA.setInfluencingBounds(bounds);
  lightRoot.addChild(lightA);
  DirectionalLight lightD1=new DirectionalLight();
  lightD1.setInfluencingBounds(bounds);
  Vector3f direction=new Vector3f(0.0f,-1.0f,-1.0f);
  direction.normalize();
  lightD1.setDirection(direction);
  lightD1.setColor(new Color3f(1.0f,1.0f,1.0f));
  lightRoot.addChild(lightD1);
  simpleUniverse.getViewer().getView().setLocalEyeLightingEnable(true);
  simpleUniverse.addBranchGraph(lightRoot);
  if (_iterationSynchronized) {
    if (_canvas != null)     _canvas.stopRenderer();
  }
}","public void initialize() throws IllegalActionException {
  super.initialize();
  if (_canvas == null) {
    place(_container);
  }
  if (_frame != null) {
    _frame.setVisible(true);
  }
  if (simpleUniverse == null) {
    simpleUniverse=new SimpleUniverse(_canvas);
  }
  Enumeration branches=simpleUniverse.getLocale().getAllBranchGraphs();
  while (branches.hasMoreElements()) {
    BranchGroup branchGroup=(BranchGroup)branches.nextElement();
    if (branchGroup.getCapability(BranchGroup.ALLOW_DETACH)) {
      if (!(branchGroup instanceof com.sun.j3d.utils.universe.ViewingPlatform)) {
        simpleUniverse.getLocale().removeBranchGraph(branchGroup);
      }
    }
  }
  branchRoot=new BranchGroup();
  branchRoot.setCapability(BranchGroup.ALLOW_DETACH);
  _userTransformation=new TransformGroup(_lastTransform);
  _userTransformation.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
  _userTransformation.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
  branchRoot.addChild(_userTransformation);
  bounds=new BoundingSphere(new Point3d(0.0,0.0,0.0),100.0);
  if (_isRotatable()) {
    mouseRotate=new MouseRotateView(this);
    mouseRotate.setTransformGroup(_userTransformation);
    mouseRotate.setSchedulingBounds(bounds);
    branchRoot.addChild(mouseRotate);
  }
  if (_isScalable()) {
    MouseZoom mouseZoom=new MouseZoom();
    mouseZoom.setTransformGroup(_userTransformation);
    mouseZoom.setSchedulingBounds(bounds);
    branchRoot.addChild(mouseZoom);
  }
  if (_isTranslatable()) {
    MouseTranslate mouseTranslate=new MouseTranslate();
    mouseTranslate.setTransformGroup(_userTransformation);
    _userTransformation.addChild(mouseTranslate);
    mouseTranslate.setSchedulingBounds(bounds);
  }
  if (_isIterationSynchronized()) {
    _iterationSynchronized=true;
  }
 else {
    _iterationSynchronized=false;
  }
  if (_shouldShowAxes()) {
    Sphere origin=new Sphere((float)0.05);
    _userTransformation.addChild(origin);
    Cylinder yAxis=new Cylinder((float)0.01,(float)6.0);
    _userTransformation.addChild(yAxis);
    Cylinder xAxis=new Cylinder((float)0.01,(float)6.0);
    Transform3D rotation=new Transform3D();
    Quat4d quat=new Quat4d();
    quat.set(new AxisAngle4d(0.0,0.0,1.0,Math.PI / 2.0));
    rotation.set(quat);
    TransformGroup xAxisGroup=new TransformGroup(rotation);
    xAxisGroup.addChild(xAxis);
    _userTransformation.addChild(xAxisGroup);
    Cylinder zAxis=new Cylinder((float)0.01,(float)6.0);
    Transform3D rotation2=new Transform3D();
    Quat4d quat2=new Quat4d();
    quat2.set(new AxisAngle4d(1.0,0.0,0.0,Math.PI / 2.0));
    rotation2.set(quat2);
    TransformGroup zAxisGroup=new TransformGroup(rotation2);
    zAxisGroup.addChild(zAxis);
    _userTransformation.addChild(zAxisGroup);
  }
  BranchGroup lightRoot=new BranchGroup();
  AmbientLight lightA=new AmbientLight(new Color3f(0.8f,0.8f,0.8f));
  lightA.setInfluencingBounds(bounds);
  lightRoot.addChild(lightA);
  DirectionalLight lightD1=new DirectionalLight();
  lightD1.setInfluencingBounds(bounds);
  Vector3f direction=new Vector3f(0.0f,-1.0f,-1.0f);
  direction.normalize();
  lightD1.setDirection(direction);
  lightD1.setColor(new Color3f(1.0f,1.0f,1.0f));
  lightRoot.addChild(lightD1);
  simpleUniverse.getViewer().getView().setLocalEyeLightingEnable(true);
  simpleUniverse.addBranchGraph(lightRoot);
  if (_iterationSynchronized) {
    if (_canvas != null)     _canvas.stopRenderer();
  }
}"
75608,"/** 
 * Construct a frame to control code generation for the specified Ptolemy II model. After constructing this, it is necessary to call setVisible(true) to make the frame appear. This is typically accomplished by calling show() on enclosing tableau.
 * @param model The model to put in this frame, or null if none.
 * @param tableau The tableau responsible for this frame.
 * @exception IllegalActionException If the model rejects theconfiguration attribute.
 * @exception NameDuplicationException If a name collision occurs.
 */
public GeneratorFrame(final CompositeEntity model,Tableau tableau) throws IllegalActionException, NameDuplicationException {
  super(model,tableau);
  if (isModified()) {
    _save();
  }
  if (getEffigy() == null || getEffigy().uri == null || getEffigy().uri.getURI() == null) {
    throw new IllegalActionException(model,(Throwable)null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  JPanel caveatsPanel=new JPanel();
  caveatsPanel.setBorder(BorderFactory.createEmptyBorder(5,0,0,0));
  caveatsPanel.setLayout(new BoxLayout(caveatsPanel,BoxLayout.X_AXIS));
  JTextArea messageArea=new JTextArea(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",2,10);
  messageArea.setEditable(false);
  messageArea.setBorder(BorderFactory.createEtchedBorder());
  messageArea.setLineWrap(true);
  messageArea.setWrapStyleWord(true);
  caveatsPanel.add(messageArea);
  JButton moreInfoButton=new JButton(""String_Node_Str"");
  moreInfoButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      Configuration configuration=getConfiguration();
      URL infoURL=getClass().getResource(""String_Node_Str"");
      try {
        configuration.openModel(null,infoURL,infoURL.toExternalForm());
      }
 catch (      Exception ex) {
        throw new InternalErrorException(model,ex,""String_Node_Str"");
      }
    }
  }
);
  caveatsPanel.add(moreInfoButton);
  JPanel left=new JPanel();
  left.setLayout(new BoxLayout(left,BoxLayout.Y_AXIS));
  caveatsPanel.setMaximumSize(new Dimension(500,100));
  left.add(caveatsPanel);
  JPanel buttonPanel=new JPanel();
  buttonPanel.setLayout(new GridLayout(1,4));
  JButton parametersButton=new JButton(""String_Node_Str"");
  parametersButton.setToolTipText(""String_Node_Str"" + ""String_Node_Str"");
  buttonPanel.add(parametersButton);
  JButton goButton=new JButton(""String_Node_Str"");
  goButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(goButton);
  JButton stopButton=new JButton(""String_Node_Str"");
  stopButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(stopButton);
  JButton clearButton=new JButton(""String_Node_Str"");
  clearButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(clearButton);
  buttonPanel.setMaximumSize(new Dimension(500,50));
  left.add(buttonPanel);
  GeneratorAttribute attribute=(GeneratorAttribute)model.getAttribute(""String_Node_Str"",GeneratorAttribute.class);
  if (attribute == null) {
    attribute=new GeneratorAttribute(model,""String_Node_Str"");
  }
  attribute.sanityCheckAndUpdateParameters(getEffigy().uri.toString());
  Configurer configurer=new Configurer(attribute);
  final GeneratorAttribute options=attribute;
  JPanel controlPanel=new JPanel();
  controlPanel.add(configurer);
  JScrollPane scrollPane=new JScrollPane(controlPanel);
  left.add(scrollPane,BorderLayout.CENTER);
  final JTextAreaExec exec=new JTextAreaExec(""String_Node_Str"",false);
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,left,exec);
  splitPane.setOneTouchExpandable(true);
  Dimension preferred=left.getPreferredSize();
  splitPane.setDividerLocation((int)(preferred.width + 20));
  getContentPane().add(splitPane,BorderLayout.CENTER);
  parametersButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      try {
        options.sanityCheckAndUpdateParameters(null);
      }
 catch (      Exception ex) {
        exec.appendJTextArea(ex.toString());
      }
      exec.appendJTextArea(options.toString());
    }
  }
);
  stopButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      exec.cancel();
    }
  }
);
  clearButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      exec.clear();
    }
  }
);
  goButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      try {
        boolean decompile=false;
        boolean compile=((BooleanToken)((Parameter)options.getAttribute(""String_Node_Str"")).getToken()).booleanValue();
        boolean show=((BooleanToken)((Parameter)options.getAttribute(""String_Node_Str"")).getToken()).booleanValue();
        boolean run=((BooleanToken)((Parameter)options.getAttribute(""String_Node_Str"")).getToken()).booleanValue();
        String codeGenerator=getStringToken(options,""String_Node_Str"");
        String targetPath=getStringToken(options,""String_Node_Str"");
        String ptIIUserDirectory=getStringToken(options,""String_Node_Str"");
        File directory=new File(ptIIUserDirectory,targetPath);
        if (!directory.isDirectory()) {
          throw new IllegalActionException(model,""String_Node_Str"" + ptIIUserDirectory + ""String_Node_Str""+ targetPath+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        if (!directory.canWrite()) {
          throw new IllegalActionException(model,""String_Node_Str"" + ptIIUserDirectory + ""String_Node_Str""+ targetPath);
        }
        List execCommands=new LinkedList();
        List commands=null;
        if (codeGenerator.equals(""String_Node_Str"")) {
          try {
            commands=_generateCodeGeneratorCommands(model,options,""String_Node_Str"");
          }
 catch (          Exception ex) {
            throw new IllegalActionException(model,ex,null);
          }
        }
 else         if (codeGenerator.equals(""String_Node_Str"") && compile) {
          exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
          ptolemy.copernicus.c.Main.generate((CompositeActor)model,targetPath);
          exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
          decompile=true;
        }
 else         if (codeGenerator.equals(""String_Node_Str"")) {
          try {
            commands=_generateCodeGeneratorCommands(model,options,""String_Node_Str"");
            decompile=true;
          }
 catch (          Exception ex) {
            throw new IllegalActionException(model,ex,null);
          }
        }
 else         if (codeGenerator.equals(""String_Node_Str"")) {
          try {
            commands=_generateCodeGeneratorCommands(model,options,""String_Node_Str"");
          }
 catch (          Exception ex) {
            throw new IllegalActionException(model,ex,null);
          }
        }
 else         if (codeGenerator.equals(""String_Node_Str"") && compile) {
          exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
          ptolemy.copernicus.jhdl.Main.generate((CompositeActor)model,targetPath);
          exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
        }
 else         if (codeGenerator.equals(""String_Node_Str"")) {
          try {
            commands=_generateCodeGeneratorCommands(model,options,""String_Node_Str"");
          }
 catch (          Exception ex) {
            throw new IllegalActionException(model,ex,null);
          }
          decompile=true;
        }
 else {
          throw new IllegalActionException(model,""String_Node_Str"" + codeGenerator + ""String_Node_Str"");
        }
        if (compile && commands != null) {
          execCommands.add(commands.get(0));
        }
        if (show && decompile) {
          String targetPackage=getStringToken(options,""String_Node_Str"");
          String className=targetPackage;
          if (codeGenerator.equals(""String_Node_Str"")) {
            className=className + ""String_Node_Str"";
          }
 else {
            if (className.length() > 0 && !className.endsWith(""String_Node_Str"")) {
              className=className + '.' + ""String_Node_Str""+ model.getName();
            }
 else {
              className=""String_Node_Str"" + model.getName();
            }
          }
          String classPath=getStringToken(options,""String_Node_Str"");
          execCommands.add(""String_Node_Str"" + ""String_Node_Str"" + classPath + ""String_Node_Str""+ className);
        }
        if (run && commands != null) {
          execCommands.add(commands.get(1));
        }
        if (execCommands.size() > 0) {
          exec.setCommands(execCommands);
          exec.start();
        }
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"",ex);
      }
    }
  }
);
}","/** 
 * Construct a frame to control code generation for the specified Ptolemy II model. After constructing this, it is necessary to call setVisible(true) to make the frame appear. This is typically accomplished by calling show() on enclosing tableau.
 * @param model The model to put in this frame, or null if none.
 * @param tableau The tableau responsible for this frame.
 * @exception IllegalActionException If the model rejects theconfiguration attribute.
 * @exception NameDuplicationException If a name collision occurs.
 */
public GeneratorFrame(final CompositeEntity model,Tableau tableau) throws IllegalActionException, NameDuplicationException {
  super(model,tableau);
  if (isModified()) {
    _save();
  }
  if (getEffigy() == null || getEffigy().uri == null || getEffigy().uri.getURI() == null) {
    throw new IllegalActionException(model,(Throwable)null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  JPanel caveatsPanel=new JPanel();
  caveatsPanel.setBorder(BorderFactory.createEmptyBorder(5,0,0,0));
  caveatsPanel.setLayout(new BoxLayout(caveatsPanel,BoxLayout.X_AXIS));
  JTextArea messageArea=new JTextArea(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",2,10);
  messageArea.setEditable(false);
  messageArea.setBorder(BorderFactory.createEtchedBorder());
  messageArea.setLineWrap(true);
  messageArea.setWrapStyleWord(true);
  caveatsPanel.add(messageArea);
  JButton moreInfoButton=new JButton(""String_Node_Str"");
  moreInfoButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      Configuration configuration=getConfiguration();
      URL infoURL=getClass().getResource(""String_Node_Str"");
      try {
        configuration.openModel(null,infoURL,infoURL.toExternalForm());
      }
 catch (      Exception ex) {
        throw new InternalErrorException(model,ex,""String_Node_Str"");
      }
    }
  }
);
  caveatsPanel.add(moreInfoButton);
  JPanel left=new JPanel();
  left.setLayout(new BoxLayout(left,BoxLayout.Y_AXIS));
  caveatsPanel.setMaximumSize(new Dimension(500,100));
  left.add(caveatsPanel);
  JPanel buttonPanel=new JPanel();
  buttonPanel.setLayout(new GridLayout(1,4));
  JButton parametersButton=new JButton(""String_Node_Str"");
  parametersButton.setToolTipText(""String_Node_Str"" + ""String_Node_Str"");
  buttonPanel.add(parametersButton);
  JButton goButton=new JButton(""String_Node_Str"");
  goButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(goButton);
  JButton stopButton=new JButton(""String_Node_Str"");
  stopButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(stopButton);
  JButton clearButton=new JButton(""String_Node_Str"");
  clearButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(clearButton);
  buttonPanel.setMaximumSize(new Dimension(500,50));
  left.add(buttonPanel);
  GeneratorAttribute attribute=(GeneratorAttribute)model.getAttribute(""String_Node_Str"",GeneratorAttribute.class);
  if (attribute == null) {
    attribute=new GeneratorAttribute(model,""String_Node_Str"");
  }
  attribute.sanityCheckAndUpdateParameters(getEffigy().uri.getURI().toString());
  Configurer configurer=new Configurer(attribute);
  final GeneratorAttribute options=attribute;
  JPanel controlPanel=new JPanel();
  controlPanel.add(configurer);
  JScrollPane scrollPane=new JScrollPane(controlPanel);
  left.add(scrollPane,BorderLayout.CENTER);
  final JTextAreaExec exec=new JTextAreaExec(""String_Node_Str"",false);
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,left,exec);
  splitPane.setOneTouchExpandable(true);
  Dimension preferred=left.getPreferredSize();
  splitPane.setDividerLocation((int)(preferred.width + 20));
  getContentPane().add(splitPane,BorderLayout.CENTER);
  parametersButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      try {
        options.sanityCheckAndUpdateParameters(null);
      }
 catch (      Exception ex) {
        exec.appendJTextArea(ex.toString());
      }
      exec.appendJTextArea(options.toString());
    }
  }
);
  stopButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      exec.cancel();
    }
  }
);
  clearButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      exec.clear();
    }
  }
);
  goButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      try {
        boolean decompile=false;
        boolean compile=((BooleanToken)((Parameter)options.getAttribute(""String_Node_Str"")).getToken()).booleanValue();
        boolean show=((BooleanToken)((Parameter)options.getAttribute(""String_Node_Str"")).getToken()).booleanValue();
        boolean run=((BooleanToken)((Parameter)options.getAttribute(""String_Node_Str"")).getToken()).booleanValue();
        String codeGenerator=getStringToken(options,""String_Node_Str"");
        String targetPath=getStringToken(options,""String_Node_Str"");
        String ptIIUserDirectory=getStringToken(options,""String_Node_Str"");
        File directory=new File(ptIIUserDirectory,targetPath);
        if (!directory.isDirectory()) {
          throw new IllegalActionException(model,""String_Node_Str"" + ptIIUserDirectory + ""String_Node_Str""+ targetPath+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
        if (!directory.canWrite()) {
          throw new IllegalActionException(model,""String_Node_Str"" + ptIIUserDirectory + ""String_Node_Str""+ targetPath);
        }
        List execCommands=new LinkedList();
        List commands=null;
        if (codeGenerator.equals(""String_Node_Str"")) {
          try {
            commands=_generateCodeGeneratorCommands(model,options,""String_Node_Str"");
          }
 catch (          Exception ex) {
            throw new IllegalActionException(model,ex,null);
          }
        }
 else         if (codeGenerator.equals(""String_Node_Str"") && compile) {
          exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
          ptolemy.copernicus.c.Main.generate((CompositeActor)model,targetPath);
          exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
          decompile=true;
        }
 else         if (codeGenerator.equals(""String_Node_Str"")) {
          try {
            commands=_generateCodeGeneratorCommands(model,options,""String_Node_Str"");
            decompile=true;
          }
 catch (          Exception ex) {
            throw new IllegalActionException(model,ex,null);
          }
        }
 else         if (codeGenerator.equals(""String_Node_Str"")) {
          try {
            commands=_generateCodeGeneratorCommands(model,options,""String_Node_Str"");
          }
 catch (          Exception ex) {
            throw new IllegalActionException(model,ex,null);
          }
        }
 else         if (codeGenerator.equals(""String_Node_Str"") && compile) {
          exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
          ptolemy.copernicus.jhdl.Main.generate((CompositeActor)model,targetPath);
          exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
        }
 else         if (codeGenerator.equals(""String_Node_Str"")) {
          try {
            commands=_generateCodeGeneratorCommands(model,options,""String_Node_Str"");
          }
 catch (          Exception ex) {
            throw new IllegalActionException(model,ex,null);
          }
          decompile=true;
        }
 else {
          throw new IllegalActionException(model,""String_Node_Str"" + codeGenerator + ""String_Node_Str"");
        }
        if (compile && commands != null) {
          execCommands.add(commands.get(0));
        }
        if (show && decompile) {
          String targetPackage=getStringToken(options,""String_Node_Str"");
          String className=targetPackage;
          if (codeGenerator.equals(""String_Node_Str"")) {
            className=className + ""String_Node_Str"";
          }
 else {
            if (className.length() > 0 && !className.endsWith(""String_Node_Str"")) {
              className=className + '.' + ""String_Node_Str""+ model.getName();
            }
 else {
              className=""String_Node_Str"" + model.getName();
            }
          }
          String classPath=getStringToken(options,""String_Node_Str"");
          execCommands.add(""String_Node_Str"" + ""String_Node_Str"" + classPath + ""String_Node_Str""+ className);
        }
        if (run && commands != null) {
          execCommands.add(commands.get(1));
        }
        if (execCommands.size() > 0) {
          exec.setCommands(execCommands);
          exec.start();
        }
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"",ex);
      }
    }
  }
);
}"
75609,"/** 
 * Remove an edge from this graph if it exists in the graph. The edge may be hidden. An edge that is removed from a graph can be re-inserted into the graph at a later time (using   {@link #addEdge(Edge)}), provided that the incident nodes are still in the graph. <p>This is an <em>O(e)</em> operation. A similar operation can be performed in <em>O(1)</em> time using   {@link #hideEdge(Edge)}.
 * @param edge The edge to be removed.
 * @return True if the edge was removed.
 * @see #hideEdge(Edge)
 */
public boolean removeEdge(Edge edge){
  if (!_edges.contains(edge)) {
    return false;
  }
  _edges.remove(edge);
  if (!hidden(edge)) {
    _disconnectEdge(edge);
  }
  return true;
}","/** 
 * Remove an edge from this graph if it exists in the graph. The edge may be hidden. An edge that is removed from a graph can be re-inserted into the graph at a later time (using   {@link #addEdge(Edge)}), provided that the incident nodes are still in the graph. <p>This is an <em>O(e)</em> operation. A similar operation can be performed in <em>O(1)</em> time using   {@link #hideEdge(Edge)}.
 * @param edge The edge to be removed.
 * @return True if the edge was removed.
 * @see #hideEdge(Edge)
 */
public boolean removeEdge(Edge edge){
  if (!_edges.contains(edge)) {
    return false;
  }
  _edges.remove(edge);
  if (hidden(edge)) {
    _hiddenEdgeSet.remove(edge);
  }
 else {
    _disconnectEdge(edge);
  }
  return true;
}"
75610,"/** 
 * Remove an edge from this graph if it exists in the graph. The edge may be hidden. An edge that is removed from a graph can be re-inserted into the graph at a later time (using   {@link #addEdge(Edge)}), provided that the incident nodes are still in the graph. <p>This is an <em>O(e)</em> operation. A similar operation can be performed in <em>O(1)</em> time using   {@link #hideEdge(Edge)}.
 * @param edge The edge to be removed.
 * @return True if the edge was removed.
 * @see #hideEdge(Edge)
 */
public boolean removeEdge(Edge edge){
  if (!_edges.contains(edge)) {
    return false;
  }
  _edges.remove(edge);
  if (hidden(edge)) {
    _hiddenEdgeSet.remove(edge);
    return false;
  }
 else {
    _disconnectEdge(edge);
    return true;
  }
}","/** 
 * Remove an edge from this graph if it exists in the graph. The edge may be hidden. An edge that is removed from a graph can be re-inserted into the graph at a later time (using   {@link #addEdge(Edge)}), provided that the incident nodes are still in the graph. <p>This is an <em>O(e)</em> operation. A similar operation can be performed in <em>O(1)</em> time using   {@link #hideEdge(Edge)}.
 * @param edge The edge to be removed.
 * @return True if the edge was removed.
 * @see #hideEdge(Edge)
 */
public boolean removeEdge(Edge edge){
  if (!_edges.contains(edge)) {
    return false;
  }
  _edges.remove(edge);
  if (hidden(edge)) {
    _hiddenEdgeSet.remove(edge);
  }
 else {
    _disconnectEdge(edge);
  }
  return true;
}"
75611,"/** 
 * Restore an edge if the edge exists in the graph and is presently hidden. This is an <em>O(1)</em> operation.
 * @param edge The edge to restore.
 * @return true If the edge is in the graph and was hidden.
 * @exception IllegalArgumentException If the source node and sink nodeof the given edge are not both in the graph.
 * @see #hideEdge(Edge)
 */
public boolean restoreEdge(Edge edge){
  if (_hiddenEdgeSet.remove(edge)) {
    if (!containsNode(edge.source())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + _edgeDump(edge));
    }
    if (!containsNode(edge.sink())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + _edgeDump(edge));
    }
    _connectEdge(edge);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Restore an edge if the edge exists in the graph and is presently hidden. This is an <em>O(1)</em> operation.
 * @param edge The edge to restore.
 * @return True if the edge is in the graph and was hidden.
 * @exception IllegalArgumentException If the source node and sink nodeof the given edge are not both in the graph.
 * @see #hideEdge(Edge)
 */
public boolean restoreEdge(Edge edge){
  if (_hiddenEdgeSet.remove(edge)) {
    if (!containsNode(edge.source())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + _edgeDump(edge));
    }
    if (!containsNode(edge.sink())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + _edgeDump(edge));
    }
    _connectEdge(edge);
    return true;
  }
 else {
    return false;
  }
}"
75612,"/** 
 * Remove an edge from this graph if it exists in the graph. The edge may be hidden. An edge that is removed from a graph can be re-inserted into the graph at a later time (using   {@link #addEdge(Edge)}), provided that the incident nodes are still in the graph. <p>This is an <em>O(e)</em> operation. A similar operation can be performed in <em>O(1)</em> time using   {@link #hideEdge(Edge)}.
 * @param edge The edge to be removed.
 * @return True if the edge was removed.
 * @see #hideEdge(Edge)
 */
public boolean removeEdge(Edge edge){
  if (!_edges.contains(edge)) {
    return false;
  }
  _edges.remove(edge);
  if (hidden(edge)) {
    _hiddenEdgeSet.remove(edge);
  }
 else {
    _disconnectEdge(edge);
  }
  return true;
}","/** 
 * Remove an edge from this graph if it exists in the graph. The edge may be hidden. An edge that is removed from a graph can be re-inserted into the graph at a later time (using   {@link #addEdge(Edge)}), provided that the incident nodes are still in the graph. <p>This is an <em>O(e)</em> operation. A similar operation can be performed in <em>O(1)</em> time using   {@link #hideEdge(Edge)}.
 * @param edge The edge to be removed.
 * @return True if the edge was removed.
 * @see #hideEdge(Edge)
 */
public boolean removeEdge(Edge edge){
  if (!_edges.contains(edge)) {
    return false;
  }
  _edges.remove(edge);
  if (hidden(edge)) {
    _hiddenEdgeSet.remove(edge);
    return false;
  }
 else {
    _disconnectEdge(edge);
    return true;
  }
}"
75613,"public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  NamedObj target=getTarget();
  if (!(target instanceof State)) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  State state=(State)target;
  CompositeEntity immediateContainer=(CompositeEntity)state.getContainer();
  if (immediateContainer == null) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  final CompositeEntity container=(CompositeEntity)immediateContainer.getContainer();
  if (container == null) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  TypedActor[] refinements;
  try {
    refinements=state.getRefinement();
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
    return;
  }
  if (refinements == null || refinements.length < 1) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  String[] choices=new String[refinements.length];
  for (int i=0; i < refinements.length; i++) {
    choices[i]=((Nameable)refinements[i]).getName();
  }
  Query query=new Query();
  query.addChoice(""String_Node_Str"",""String_Node_Str"",choices,choices[0],false);
  ComponentDialog dialog=new ComponentDialog(null,""String_Node_Str"",query);
  if (!dialog.buttonPressed().equals(""String_Node_Str"")) {
    return;
  }
  String refinementName=query.getStringValue(""String_Node_Str"");
  StringBuffer newRefinements=new StringBuffer();
  String currentRefinements=state.refinementName.getExpression();
  StringTokenizer tokenizer=new StringTokenizer(currentRefinements,""String_Node_Str"");
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    if (!token.trim().equals(refinementName)) {
      if (newRefinements.length() > 0) {
        newRefinements.append(""String_Node_Str"");
      }
      newRefinements.append(token.trim());
    }
  }
  Iterator states=immediateContainer.entityList().iterator();
  boolean foundOne=false;
  while (states.hasNext()) {
    NamedObj other=(NamedObj)states.next();
    if (other != state && other instanceof State) {
      String refinementList=((State)other).refinementName.getExpression();
      if (refinementList == null)       continue;
      tokenizer=new StringTokenizer(refinementList,""String_Node_Str"");
      while (tokenizer.hasMoreTokens()) {
        String token=tokenizer.nextToken();
        if (token.equals(refinementName)) {
          foundOne=true;
          break;
        }
      }
      if (foundOne)       break;
    }
  }
  String removal=""String_Node_Str"";
  if (!foundOne) {
    removal=""String_Node_Str"" + refinementName + ""String_Node_Str"";
  }
  String moml=""String_Node_Str"" + state.getName(container) + ""String_Node_Str""+ newRefinements.toString()+ ""String_Node_Str""+ removal+ ""String_Node_Str"";
  MoMLChangeRequest change=new MoMLChangeRequest(this,container,moml);
  container.requestChange(change);
}","public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  NamedObj target=getTarget();
  if (!(target instanceof State)) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  State state=(State)target;
  CompositeEntity immediateContainer=(CompositeEntity)state.getContainer();
  if (immediateContainer == null) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  final CompositeEntity container=(CompositeEntity)immediateContainer.getContainer();
  if (container == null) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  TypedActor[] refinements;
  try {
    refinements=state.getRefinement();
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
    return;
  }
  if (refinements == null || refinements.length < 1) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  String[] choices=new String[refinements.length];
  for (int i=0; i < refinements.length; i++) {
    choices[i]=((Nameable)refinements[i]).getName();
  }
  Query query=new Query();
  query.addChoice(""String_Node_Str"",""String_Node_Str"",choices,choices[0],false);
  ComponentDialog dialog=new ComponentDialog(null,""String_Node_Str"",query);
  if (!dialog.buttonPressed().equals(""String_Node_Str"")) {
    return;
  }
  String refinementName=query.getStringValue(""String_Node_Str"");
  StringBuffer newRefinements=new StringBuffer();
  String currentRefinements=state.refinementName.getExpression();
  StringTokenizer tokenizer=new StringTokenizer(currentRefinements,""String_Node_Str"");
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    if (!token.trim().equals(refinementName)) {
      if (newRefinements.length() > 0) {
        newRefinements.append(""String_Node_Str"");
      }
      newRefinements.append(token.trim());
    }
  }
  Iterator states=immediateContainer.entityList().iterator();
  boolean foundOne=false;
  while (states.hasNext()) {
    NamedObj other=(NamedObj)states.next();
    if (other != state && other instanceof State) {
      String refinementList=((State)other).refinementName.getExpression();
      if (refinementList == null)       continue;
      tokenizer=new StringTokenizer(refinementList,""String_Node_Str"");
      while (tokenizer.hasMoreTokens()) {
        String token=tokenizer.nextToken();
        if (token.equals(refinementName)) {
          foundOne=true;
          break;
        }
      }
      if (foundOne)       break;
    }
  }
  if (!foundOne) {
    Iterator transitions=immediateContainer.relationList().iterator();
    while (transitions.hasNext()) {
      NamedObj other=(NamedObj)transitions.next();
      if (other instanceof Transition) {
        String refinementList=((Transition)other).refinementName.getExpression();
        if (refinementList == null)         continue;
        tokenizer=new StringTokenizer(refinementList,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String token=tokenizer.nextToken();
          if (token.equals(refinementName)) {
            foundOne=true;
            break;
          }
        }
        if (foundOne)         break;
      }
    }
  }
  String removal=""String_Node_Str"";
  if (!foundOne) {
    removal=""String_Node_Str"" + refinementName + ""String_Node_Str"";
  }
  String moml=""String_Node_Str"" + state.getName(container) + ""String_Node_Str""+ newRefinements.toString()+ ""String_Node_Str""+ removal+ ""String_Node_Str"";
  MoMLChangeRequest change=new MoMLChangeRequest(this,container,moml);
  container.requestChange(change);
}"
75614,"public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  NamedObj target=getTarget();
  if (!(target instanceof Transition)) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  Transition transition=(Transition)target;
  CompositeEntity immediateContainer=(CompositeEntity)transition.getContainer();
  if (immediateContainer == null) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  final CompositeEntity container=(CompositeEntity)immediateContainer.getContainer();
  if (container == null) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  TypedActor[] refinements;
  try {
    refinements=transition.getRefinement();
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
    return;
  }
  if (refinements == null || refinements.length < 1) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  String[] choices=new String[refinements.length];
  for (int i=0; i < refinements.length; i++) {
    choices[i]=((Nameable)refinements[i]).getName();
  }
  Query query=new Query();
  query.addChoice(""String_Node_Str"",""String_Node_Str"",choices,choices[0],false);
  ComponentDialog dialog=new ComponentDialog(null,""String_Node_Str"",query);
  if (!dialog.buttonPressed().equals(""String_Node_Str"")) {
    return;
  }
  String refinementName=query.getStringValue(""String_Node_Str"");
  StringBuffer newRefinements=new StringBuffer();
  String currentRefinements=transition.refinementName.getExpression();
  StringTokenizer tokenizer=new StringTokenizer(currentRefinements,""String_Node_Str"");
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    if (!token.trim().equals(refinementName)) {
      if (newRefinements.length() > 0) {
        newRefinements.append(""String_Node_Str"");
      }
      newRefinements.append(token.trim());
    }
  }
  Iterator transitions=immediateContainer.entityList().iterator();
  boolean foundOne=false;
  while (transitions.hasNext()) {
    NamedObj other=(NamedObj)transitions.next();
    if (other != transition && other instanceof Transition) {
      String refinementList=((Transition)other).refinementName.getExpression();
      if (refinementList == null)       continue;
      tokenizer=new StringTokenizer(refinementList,""String_Node_Str"");
      while (tokenizer.hasMoreTokens()) {
        String token=tokenizer.nextToken();
        if (token.equals(refinementName)) {
          foundOne=true;
          break;
        }
      }
      if (foundOne)       break;
    }
  }
  String removal=""String_Node_Str"";
  if (!foundOne) {
    removal=""String_Node_Str"" + refinementName + ""String_Node_Str"";
  }
  String moml=""String_Node_Str"" + transition.getName(container) + ""String_Node_Str""+ newRefinements.toString()+ ""String_Node_Str""+ removal+ ""String_Node_Str"";
  MoMLChangeRequest change=new MoMLChangeRequest(this,container,moml);
  container.requestChange(change);
}","public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  NamedObj target=getTarget();
  if (!(target instanceof Transition)) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  Transition transition=(Transition)target;
  CompositeEntity immediateContainer=(CompositeEntity)transition.getContainer();
  if (immediateContainer == null) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  final CompositeEntity container=(CompositeEntity)immediateContainer.getContainer();
  if (container == null) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  TypedActor[] refinements;
  try {
    refinements=transition.getRefinement();
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
    return;
  }
  if (refinements == null || refinements.length < 1) {
    MessageHandler.error(""String_Node_Str"");
    return;
  }
  String[] choices=new String[refinements.length];
  for (int i=0; i < refinements.length; i++) {
    choices[i]=((Nameable)refinements[i]).getName();
  }
  Query query=new Query();
  query.addChoice(""String_Node_Str"",""String_Node_Str"",choices,choices[0],false);
  ComponentDialog dialog=new ComponentDialog(null,""String_Node_Str"",query);
  if (!dialog.buttonPressed().equals(""String_Node_Str"")) {
    return;
  }
  String refinementName=query.getStringValue(""String_Node_Str"");
  StringBuffer newRefinements=new StringBuffer();
  String currentRefinements=transition.refinementName.getExpression();
  StringTokenizer tokenizer=new StringTokenizer(currentRefinements,""String_Node_Str"");
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    if (!token.trim().equals(refinementName)) {
      if (newRefinements.length() > 0) {
        newRefinements.append(""String_Node_Str"");
      }
      newRefinements.append(token.trim());
    }
  }
  Iterator transitions=immediateContainer.relationList().iterator();
  boolean foundOne=false;
  while (transitions.hasNext()) {
    NamedObj other=(NamedObj)transitions.next();
    if (other != transition && other instanceof Transition) {
      String refinementList=((Transition)other).refinementName.getExpression();
      if (refinementList == null)       continue;
      tokenizer=new StringTokenizer(refinementList,""String_Node_Str"");
      while (tokenizer.hasMoreTokens()) {
        String token=tokenizer.nextToken();
        if (token.equals(refinementName)) {
          foundOne=true;
          break;
        }
      }
      if (foundOne)       break;
    }
  }
  if (!foundOne) {
    Iterator states=immediateContainer.entityList().iterator();
    while (states.hasNext()) {
      NamedObj other=(NamedObj)states.next();
      if (other instanceof State) {
        String refinementList=((State)other).refinementName.getExpression();
        if (refinementList == null)         continue;
        tokenizer=new StringTokenizer(refinementList,""String_Node_Str"");
        while (tokenizer.hasMoreTokens()) {
          String token=tokenizer.nextToken();
          if (token.equals(refinementName)) {
            foundOne=true;
            break;
          }
        }
        if (foundOne)         break;
      }
    }
  }
  String removal=""String_Node_Str"";
  if (!foundOne) {
    removal=""String_Node_Str"" + refinementName + ""String_Node_Str"";
  }
  String moml=""String_Node_Str"" + transition.getName(container) + ""String_Node_Str""+ newRefinements.toString()+ ""String_Node_Str""+ removal+ ""String_Node_Str"";
  MoMLChangeRequest change=new MoMLChangeRequest(this,container,moml);
  container.requestChange(change);
}"
75615,"public void visitFunctionDefinitionNode(ASTPtFunctionDefinitionNode node) throws IllegalActionException {
  ParseTreeFreeVariableCollector collector=new ParseTreeFreeVariableCollector();
  Set freeVariableNames=collector.collectFreeVariables(node);
  Map map=new HashMap();
  Iterator variableNameIterator=freeVariableNames.iterator();
  while (variableNameIterator.hasNext()) {
    String name=(String)variableNameIterator.next();
    if (_scope != null) {
      ptolemy.data.Token value=_scope.get(name);
      if (value != null) {
        map.put(name,value);
        continue;
      }
    }
    throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  NamedConstantsScope constantsScope=new NamedConstantsScope(map);
  ExpressionFunction definedFunction=new ExpressionFunction(node.getArgumentNameList(),(ASTPtRootNode)node.jjtGetChild(0),constantsScope);
  FunctionToken result=new FunctionToken(definedFunction);
  node.setToken(result);
  return;
}","public void visitFunctionDefinitionNode(ASTPtFunctionDefinitionNode node) throws IllegalActionException {
  ParseTreeFreeVariableCollector collector=new ParseTreeFreeVariableCollector();
  Set freeVariableNames=collector.collectFreeVariables(node,_scope);
  Map map=new HashMap();
  Iterator variableNameIterator=freeVariableNames.iterator();
  while (variableNameIterator.hasNext()) {
    String name=(String)variableNameIterator.next();
    if (_scope != null) {
      ptolemy.data.Token value=_scope.get(name);
      if (value != null) {
        map.put(name,value);
        continue;
      }
    }
    throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  NamedConstantsScope constantsScope=new NamedConstantsScope(map);
  ExpressionFunction definedFunction=new ExpressionFunction(node.getArgumentNameList(),(ASTPtRootNode)node.jjtGetChild(0),constantsScope);
  FunctionToken result=new FunctionToken(definedFunction);
  node.setToken(result);
  return;
}"
75616,"/** 
 * Return the total number of edges in this graph.  Multiple connections between two nodes are counted multiple times.
 * @return The total number of edges in this graph.
 */
public int edgeCount(){
  return _edges.size();
}","/** 
 * Return the total number of edges in this graph.  Multiple connections between two nodes are counted multiple times. Hidden edges are not included in this count.
 * @return The total number of edges in this graph.
 */
public int edgeCount(){
  return _edges.size() - _hiddenEdgeSet.size();
}"
75617,"/** 
 * Called by _processInstanceFieldRef and _addLeftValue
 */
protected Node _createInstanceFieldRef(InstanceFieldRef ifr) throws JHDLUnsupportedException {
  InstanceFieldRef new_ifr=_getMatchingInstanceFieldRef(ifr);
  if (new_ifr == null)   new_ifr=ifr;
  if (DEBUG)   System.out.println(""String_Node_Str"" + System.identityHashCode(new_ifr));
  Node base=_processValue(new_ifr.getBase());
  Node n=addNodeWeight(new_ifr);
  _instanceFieldRefs.add(new_ifr,n);
  addBaseEdge(base,n);
  return n;
}","/** 
 * Called by _processInstanceFieldRef and _addLeftValue
 */
protected Node _createInstanceFieldRef(InstanceFieldRef ifr) throws JHDLUnsupportedException {
  InstanceFieldRef new_ifr=_getMatchingInstanceFieldRef(ifr);
  if (new_ifr == null)   new_ifr=ifr;
  if (DEBUG)   System.out.println(""String_Node_Str"" + System.identityHashCode(new_ifr));
  Node base=_processValue(new_ifr.getBase());
  Node n=addNodeWeight(new_ifr);
  _instanceFieldRefs.add(new_ifr,n);
  return n;
}"
75618,"protected DirectedGraph _extractDataFlow(DirectedGraph graph){
  Map requiredNodeMap=new HashMap();
  for (Iterator i=graph.nodes().iterator(); i.hasNext(); ) {
    GraphNode gn=(GraphNode)((Node)i.next()).getWeight();
    if (gn instanceof SuperBlock) {
      SuperBlock sb=(SuperBlock)gn;
      BlockDataFlowGraph bdfg=(BlockDataFlowGraph)sb.getGraph();
    }
  }
  DirectedGraph dg=new DirectedGraph();
  Set keys=requiredNodeMap.keySet();
  for (Iterator i=keys.iterator(); i.hasNext(); ) {
    Object requiredValue=i.next();
    GraphNode gn=(GraphNode)requiredNodeMap.get(requiredValue);
    System.out.println(""String_Node_Str"" + requiredValue + ""String_Node_Str""+ gn);
    gn.createDataFlow(dg,requiredValue);
  }
  return dg;
}","protected DirectedGraph _extractDataFlow(DirectedGraph graph){
  Map requiredNodeMap=new HashMap();
  for (Iterator i=graph.nodes().iterator(); i.hasNext(); ) {
    GraphNode gn=(GraphNode)((Node)i.next()).getWeight();
    if (gn instanceof SuperBlock) {
      SuperBlock sb=(SuperBlock)gn;
      RequiredBlockDataFlowGraph bdfg=(RequiredBlockDataFlowGraph)sb.getGraph();
      for (Iterator j=bdfg.getRequiredNodeSet().iterator(); j.hasNext(); ) {
        requiredNodeMap.put(j.next(),sb);
      }
    }
  }
  DirectedGraph dg=new DirectedGraph();
  Set keys=requiredNodeMap.keySet();
  for (Iterator i=keys.iterator(); i.hasNext(); ) {
    Object requiredValue=i.next();
    GraphNode gn=(GraphNode)requiredNodeMap.get(requiredValue);
    System.out.println(""String_Node_Str"" + requiredValue + ""String_Node_Str""+ gn);
    gn.createDataFlow(dg,requiredValue);
  }
  return dg;
}"
75619,"/** 
 * Restore an edge if the edge exists in the graph and is presently hidden. This is an <em>O(1)</em> operation.
 * @param edge The edge to restore.
 * @return true If the edge is in the graph and was hidden.
 * @exception IllegalArgumentException If the source node and sink nodeof the given edge are not both in the graph.
 * @see #hideEdge(Edge).
 */
public boolean restoreEdge(Edge edge){
  if (!containsEdge(edge)) {
    return false;
  }
  if (_hiddenEdgeSet.remove(edge)) {
    if (!containsNode(edge.source())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + _edgeDump(edge));
    }
    if (!containsNode(edge.sink())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + _edgeDump(edge));
    }
    _connectEdge(edge);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Restore an edge if the edge exists in the graph and is presently hidden. This is an <em>O(1)</em> operation.
 * @param edge The edge to restore.
 * @return true If the edge is in the graph and was hidden.
 * @exception IllegalArgumentException If the source node and sink nodeof the given edge are not both in the graph.
 * @see #hideEdge(Edge).
 */
public boolean restoreEdge(Edge edge){
  if (_hiddenEdgeSet.remove(edge)) {
    if (!containsNode(edge.source())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + _edgeDump(edge));
    }
    if (!containsNode(edge.sink())) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + _edgeDump(edge));
    }
    _connectEdge(edge);
    return true;
  }
 else {
    return false;
  }
}"
75620,"/** 
 * Return true if the given object is a valid node weight for this graph. An object is a valid node weight if it is meaningful to assign it as a node weight in this type of graph. If the given object is null this method returns true if it is valid to have an unweighted node in this type of graph. This base class method returns true unconditionally, even if the given object is null. In derived classes, the method should be  overridden to take into account any restrictions on node weights.
 * @param object The given object.
 * @return True if if the given object is a valid node weight for this graph.
 */
boolean validNodeWeight(Object object){
  return true;
}","/** 
 * Return true if the given object is a valid node weight for this graph. An object is a valid node weight if it is meaningful to assign it as a node weight in this type of graph. If the given object is null this method returns true if it is valid to have an unweighted node in this type of graph. This base class method returns true unconditionally, even if the given object is null. In derived classes, the method should be  overridden to take into account any restrictions on node weights.
 * @param object The given object.
 * @return True if if the given object is a valid node weight for this graph.
 */
public boolean validNodeWeight(Object object){
  return true;
}"
75621,"/** 
 * Return true if the given object is a valid edge weight for this graph. An object is a valid edge weight if it is meaningful to assign it as an edge weight in this type of graph. If the given object is null this method returns true if it is valid to have an unweighted edge in this type of graph. This base class method returns true unconditionally, even if the given object is null. In derived classes, the method should be  overridden to take into account any restrictions on edge weights.
 * @param object The given object.
 * @return True if if the given object is a valid edge weight for this graph.
 */
boolean validEdgeWeight(Object object){
  return true;
}","/** 
 * Return true if the given object is a valid edge weight for this graph. An object is a valid edge weight if it is meaningful to assign it as an edge weight in this type of graph. If the given object is null this method returns true if it is valid to have an unweighted edge in this type of graph. This base class method returns true unconditionally, even if the given object is null. In derived classes, the method should be  overridden to take into account any restrictions on edge weights.
 * @param object The given object.
 * @return True if if the given object is a valid edge weight for this graph.
 */
public boolean validEdgeWeight(Object object){
  return true;
}"
75622,"/** 
 * Register a new node in the graph. The node is assumed to be non-null and unique. This method performs updates of internal data structures that are required for every node that is added to the graph. Derived classes can override this method to perform additional updates of internal data structures. 
 * @param node The new node.
 * @exception RuntimeException if the weight of the given node isnot valid, as determined by  {@link #validNodeWeight(Object)}.
 * @see #_registerEdge(Node).
 */
protected void _registerNode(Node node){
  Object weight=node.hasWeight() ? node.weight() : null;
  if (!validNodeWeight(weight)) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ((weight == null) ? ""String_Node_Str"" : (""String_Node_Str"" + weight.toString() + ""String_Node_Str"")));
  }
  _nodes.add(node);
  _incidentEdgeMap.put(node,new ArrayList());
  if (node.hasWeight()) {
    ArrayList sameWeightList;
    try {
      sameWeightList=_sameWeightNodes(weight);
    }
 catch (    Exception exception) {
      sameWeightList=new ArrayList();
      _nodeWeightMap.put(weight,sameWeightList);
    }
    sameWeightList.add(node);
  }
  _registerChange();
}","/** 
 * Register a new node in the graph. The node is assumed to be non-null and unique. This method performs updates of internal data structures that are required for every node that is added to the graph. Derived classes can override this method to perform additional updates of internal data structures. 
 * @param node The new node.
 * @exception RuntimeException if the weight of the given node isnot valid, as determined by  {@link #validNodeWeight(Object)}.
 * @see #_registerEdge(Edge).
 */
protected void _registerNode(Node node){
  Object weight=node.hasWeight() ? node.weight() : null;
  if (!validNodeWeight(weight)) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + ((weight == null) ? ""String_Node_Str"" : (""String_Node_Str"" + weight.toString() + ""String_Node_Str"")));
  }
  _nodes.add(node);
  _incidentEdgeMap.put(node,new ArrayList());
  if (node.hasWeight()) {
    ArrayList sameWeightList;
    try {
      sameWeightList=_sameWeightNodes(weight);
    }
 catch (    Exception exception) {
      sameWeightList=new ArrayList();
      _nodeWeightMap.put(weight,sameWeightList);
    }
    sameWeightList.add(node);
  }
  _registerChange();
}"
75623,"/** 
 * If the histogram has not already been created, create it using place(). If configurations specified by a call to configure() have not yet been processed, process them.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (plot == null) {
    plot=_newPlot();
    plot.setTitle(getName());
    plot.setButtons(true);
  }
  if (_frame == null && _container == null) {
    Effigy containerEffigy=Configuration.findEffigy(toplevel());
    if (containerEffigy == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + toplevel().getFullName());
    }
    try {
      PlotEffigy plotEffigy=new PlotEffigy(containerEffigy,containerEffigy.uniqueName(""String_Node_Str""));
      plotEffigy.identifier.setExpression(getFullName());
      PlotWindowTableau tableau=new PlotWindowTableau(plotEffigy,""String_Node_Str"");
      _frame=tableau.frame;
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,null,ex,""String_Node_Str"");
    }
    _windowProperties.setProperties(_frame);
    _implementDeferredConfigurations();
    if (_plotSize != null) {
      _plotSize.setSize(plot);
    }
  }
 else {
    plot.clear(false);
    plot.repaint();
  }
  if (_frame != null) {
    _frame.show();
  }
}","/** 
 * If the histogram has not already been created, create it using place(). If configurations specified by a call to configure() have not yet been processed, process them.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (plot == null) {
    plot=_newPlot();
    plot.setTitle(getName());
    plot.setButtons(true);
  }
  if (_frame == null && _container == null) {
    Effigy containerEffigy=Configuration.findEffigy(toplevel());
    if (containerEffigy == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + toplevel().getFullName());
    }
    try {
      PlotEffigy plotEffigy=new PlotEffigy(containerEffigy,containerEffigy.uniqueName(""String_Node_Str""));
      plotEffigy.identifier.setExpression(getFullName());
      PlotWindowTableau tableau=new PlotWindowTableau(plotEffigy,""String_Node_Str"");
      _frame=tableau.frame;
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,null,ex,""String_Node_Str"");
    }
    _windowProperties.setProperties(_frame);
    _implementDeferredConfigurations();
    if (_plotSize != null) {
      _plotSize.setSize(plot);
    }
    _frame.show();
  }
 else {
    plot.clear(false);
    plot.repaint();
  }
}"
75624,"/** 
 * If the plot has not already been created, create it. If configurations specified by a call to configure() have not yet been processed, process them. Clear the data sets that this actor is responsible for (starting with the one indexed by <i>startingDataset</i>, up to <i>startingDataset</i> + <i>width</i> - 1, where <i>width</i> is the width of the input port.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (plot == null) {
    plot=_newPlot();
    plot.setTitle(getName());
    plot.setButtons(true);
  }
  if (_frame == null && _container == null) {
    Effigy containerEffigy=Configuration.findEffigy(toplevel());
    if (containerEffigy == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + toplevel().getFullName());
    }
    try {
      PlotEffigy plotEffigy=new PlotEffigy(containerEffigy,containerEffigy.uniqueName(""String_Node_Str""));
      plotEffigy.identifier.setExpression(getFullName());
      PlotWindowTableau tableau=new PlotWindowTableau(plotEffigy,""String_Node_Str"");
      _frame=tableau.frame;
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,null,ex,""String_Node_Str"");
    }
    _windowProperties.setProperties(_frame);
    _implementDeferredConfigurations();
    if (_plotSize != null) {
      _plotSize.setSize(plot);
    }
  }
 else {
    if (plot instanceof Plot) {
      int width=((Plot)plot).getNumDataSets();
      int offset=((IntToken)startingDataset.getToken()).intValue();
      for (int i=width - 1; i >= 0; i--) {
        ((Plot)plot).clear(i + offset);
      }
      plot.repaint();
    }
 else {
      plot.clear(false);
      plot.repaint();
    }
  }
  if (_frame != null) {
    _frame.show();
  }
}","/** 
 * If the plot has not already been created, create it. If configurations specified by a call to configure() have not yet been processed, process them. Clear the data sets that this actor is responsible for (starting with the one indexed by <i>startingDataset</i>, up to <i>startingDataset</i> + <i>width</i> - 1, where <i>width</i> is the width of the input port.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  if (plot == null) {
    plot=_newPlot();
    plot.setTitle(getName());
    plot.setButtons(true);
  }
  if (_frame == null && _container == null) {
    Effigy containerEffigy=Configuration.findEffigy(toplevel());
    if (containerEffigy == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + toplevel().getFullName());
    }
    try {
      PlotEffigy plotEffigy=new PlotEffigy(containerEffigy,containerEffigy.uniqueName(""String_Node_Str""));
      plotEffigy.identifier.setExpression(getFullName());
      PlotWindowTableau tableau=new PlotWindowTableau(plotEffigy,""String_Node_Str"");
      _frame=tableau.frame;
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,null,ex,""String_Node_Str"");
    }
    _windowProperties.setProperties(_frame);
    _implementDeferredConfigurations();
    if (_plotSize != null) {
      _plotSize.setSize(plot);
    }
    _frame.show();
  }
 else {
    if (plot instanceof Plot) {
      int width=((Plot)plot).getNumDataSets();
      int offset=((IntToken)startingDataset.getToken()).intValue();
      for (int i=width - 1; i >= 0; i--) {
        ((Plot)plot).clear(i + offset);
      }
      plot.repaint();
    }
 else {
      plot.clear(false);
      plot.repaint();
    }
  }
}"
75625,"/** 
 */
protected DirectedGraph _analyzeMethod(SootMethod method) throws IllegalActionException {
  Body body=method.retrieveActiveBody();
  MergedControlFlowGraph mcfg=new MergedControlFlowGraph(body);
  return mcfg;
}","/** 
 */
protected DirectedGraph _analyzeMethod(SootMethod method) throws IllegalActionException {
  Body body=method.retrieveActiveBody();
  DirectedGraph mcfg=new MergedControlFlowGraph(body);
  mcfg=_extractDataFlow(mcfg);
  return mcfg;
}"
75626,"/** 
 */
Object createDataFlow(DirectedGraph graph,Object value);","/** 
 */
Node createDataFlow(DirectedGraph graph,Object value);"
75627,"public MergedControlFlowGraph(Body body) throws IllegalActionException {
  super();
  _bbgraph=new BriefBlockGraph(body);
  _createGraph();
  _controlFlowAnalysis();
  _extractDataFlow(this);
}","public MergedControlFlowGraph(Body body) throws IllegalActionException {
  super();
  _bbgraph=new BriefBlockGraph(body);
  _createGraph();
  _controlFlowAnalysis();
}"
75628,"public Object createDataFlow(DirectedGraph graph,Object value){
  Object trueResult=_trueInput.createDataFlow(graph,value);
  Object falseResult=_falseInput.createDataFlow(graph,value);
  ConditionExpr cond=(ConditionExpr)_conditionBlock.getBlock().getTail();
  Object condResult=_conditionBlock.createDataFlow(graph,cond);
  MuxNode newMux=new MuxNode(trueResult,falseResult,condResult,1);
  graph.addNodeWeight(newMux);
  graph.addEdge(trueResult,newMux);
  graph.addEdge(falseResult,newMux);
  graph.addEdge(condResult,newMux);
  return newMux;
}","public Node createDataFlow(DirectedGraph graph,Object value){
  System.out.println(""String_Node_Str"");
  Node trueResult=_trueInput.createDataFlow(graph,value);
  System.out.println(""String_Node_Str"");
  Node falseResult=_falseInput.createDataFlow(graph,value);
  Object cond=((IfStmt)_conditionBlock.getBlock().getTail()).getCondition();
  System.out.println(""String_Node_Str"");
  Node condResult=_conditionBlock.createDataFlow(graph,cond);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + trueResult);
  System.out.println(""String_Node_Str"" + falseResult);
  System.out.println(""String_Node_Str"" + condResult);
  if (trueResult == null && falseResult == null)   return null;
  if (trueResult == null)   return falseResult;
  if (falseResult == null)   return trueResult;
  MuxNode newMux=new MuxNode(trueResult,falseResult,condResult,1);
  Node newMuxNode=graph.addNodeWeight(newMux);
  SynthesisToDotty.writeDotFile(""String_Node_Str"",graph);
  graph.addEdge(trueResult,newMuxNode);
  graph.addEdge(falseResult,newMuxNode);
  graph.addEdge(condResult,newMuxNode);
  return newMuxNode;
}"
75629,"public String toString(){
  return _block.toString();
}","public String toString(){
  return _block.toShortString();
}"
75630,"public Object createDataFlow(DirectedGraph graph,Object value){
  Collection c=_graph.nodes(value);
  Collection pred=_labels.keySet();
  GraphNode predecessor;
  if (pred.size() == 0) {
    predecessor=null;
  }
 else {
    predecessor=(GraphNode)pred.toArray()[0];
  }
  if (c.size() == 0) {
    if (predecessor == null)     return null;
    return predecessor.createDataFlow(graph,value);
  }
  Node nodes[]=new Node[c.size()];
  System.arraycopy(c.toArray(),0,nodes,0,c.size());
  Node lastDefinition=nodes[0];
  for (int i=1; i < nodes.length; i++) {
    if (graph.reachableNodes(lastDefinition).contains(nodes[i])) {
      lastDefinition=nodes[i];
    }
 else     if (!graph.reachableNodes(nodes[i]).contains(lastDefinition)) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  if (graph.sourceNodes().contains(lastDefinition)) {
    if (predecessor == null) {
      graph.addNode(lastDefinition);
      return lastDefinition;
    }
    Object gn=predecessor.createDataFlow(graph,value);
    if (gn == null) {
      graph.addNode(lastDefinition);
      return lastDefinition;
    }
 else {
      return gn;
    }
  }
  Collection sources=graph.sourceNodes();
  Vector currentBlockDefs=new Vector();
  Vector predecessorDefs=new Vector();
  currentBlockDefs.add(lastDefinition);
  for (int i=0; i < currentBlockDefs.size(); i++) {
    Node currNode=(Node)currentBlockDefs.elementAt(i);
    if (!graph.containsNode(currNode))     graph.addNode(currNode);
    for (Iterator j=graph.predecessors(currNode).iterator(); j.hasNext(); ) {
      Node predNode=(Node)j.next();
      if (sources.contains(predNode)) {
        predecessorDefs.add(predNode);
      }
 else {
        currentBlockDefs.add(predNode);
      }
      if (!graph.containsNode(predNode))       graph.addNode(predNode);
      graph.addEdge(predNode,currNode);
    }
  }
  for (Iterator i=predecessorDefs.iterator(); i.hasNext(); ) {
    Node n=(Node)i.next();
    Object result=predecessor.createDataFlow(graph,n.weight());
    if (result != null)     graph.addEdge(result,n);
  }
  return lastDefinition;
}","public Node createDataFlow(DirectedGraph graph,Object value){
  System.out.println(""String_Node_Str"" + this + ""String_Node_Str""+ value);
  System.out.println(""String_Node_Str"" + value.getClass());
  Collection pred=_labels.keySet();
  GraphNode predecessor;
  Node returnNode;
  if (pred.size() == 0) {
    predecessor=null;
  }
 else {
    predecessor=(GraphNode)pred.toArray()[0];
  }
  if (predecessor == this)   predecessor=null;
  if (!_graph.containsNodeWeight(value)) {
    if (predecessor == null)     return null;
    return predecessor.createDataFlow(graph,value);
  }
  Collection c=_graph.nodes(value);
  Set equalSet=new HashSet();
  for (Iterator i=c.iterator(); i.hasNext(); ) {
    Object o=i.next();
    equalSet.add(o);
  }
  if (equalSet.size() == 0) {
    if (predecessor == null)     return null;
    return predecessor.createDataFlow(graph,value);
  }
  Node nodes[]=new Node[equalSet.size()];
  System.arraycopy(equalSet.toArray(),0,nodes,0,equalSet.size());
  Node lastDefinition=nodes[0];
  for (int i=1; i < nodes.length; i++) {
    if (_graph.reachableNodes(lastDefinition).contains(nodes[i])) {
      lastDefinition=nodes[i];
    }
 else     if (!_graph.reachableNodes(nodes[i]).contains(lastDefinition)) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  if (_graph.sourceNodes().contains(lastDefinition)) {
    if (predecessor == null) {
      if (!graph.containsNode(lastDefinition)) {
        graph.addNode(lastDefinition);
      }
      return lastDefinition;
    }
    Node gn=predecessor.createDataFlow(graph,value);
    if (gn == null) {
      if (!graph.containsNode(lastDefinition)) {
        graph.addNode(lastDefinition);
      }
      return lastDefinition;
    }
 else {
      return gn;
    }
  }
  Collection sources=_graph.sourceNodes();
  Vector currentBlockDefs=new Vector();
  Vector predecessorDefs=new Vector();
  currentBlockDefs.add(lastDefinition);
  for (int i=0; i < currentBlockDefs.size(); i++) {
    Node currNode=(Node)currentBlockDefs.elementAt(i);
    System.out.println(""String_Node_Str"" + currNode);
    if (!graph.containsNode(currNode))     graph.addNode(currNode);
    for (Iterator j=_graph.predecessors(currNode).iterator(); j.hasNext(); ) {
      Node predNode=(Node)j.next();
      System.out.println(""String_Node_Str"" + predNode);
      if (sources.contains(predNode)) {
        predecessorDefs.add(predNode);
      }
 else {
        currentBlockDefs.add(predNode);
      }
      if (!graph.containsNode(predNode))       graph.addNode(predNode);
      graph.addEdge(predNode,currNode);
    }
  }
  if (predecessor != null) {
    for (Iterator i=predecessorDefs.iterator(); i.hasNext(); ) {
      Node n=(Node)i.next();
      System.out.println(""String_Node_Str"" + predecessor + ""String_Node_Str""+ n);
      Node result=predecessor.createDataFlow(graph,n.weight());
      if (result != null)       graph.addEdge(result,n);
    }
  }
  return lastDefinition;
}"
75631,"/** 
 * If the <i>stopTime</i> parameter is changed and the model is executing, then if the new value is greater than zero and greater than the current time, then ask the director to fire this actor at that time.  If the new value is less than the current time, then request refiring at the current time.
 * @exception IllegalActionException If the superclass throws it.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == stopTime) {
    double time=((DoubleToken)stopTime.getToken()).doubleValue();
    Manager manager=getManager();
    if (time > 0.0 && manager != null && manager.getState() != Manager.IDLE) {
      Director director=getDirector();
      if (director != null) {
        double currentTime=director.getCurrentTime();
        if (time > currentTime) {
          director.fireAt(this,time);
        }
 else {
          director.fireAt(this,currentTime);
        }
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the <i>stopTime</i> parameter is changed and the model is executing, then if the new value is greater than zero and greater than the current time, then ask the director to fire this actor at that time.  If the new value is less than the current time, then request refiring at the current time.
 * @exception IllegalActionException If the superclass throws it.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == stopTime && _executing) {
    double time=((DoubleToken)stopTime.getToken()).doubleValue();
    if (time > 0.0) {
      Director director=getDirector();
      if (director != null) {
        double currentTime=director.getCurrentTime();
        if (time > currentTime) {
          director.fireAt(this,time);
        }
 else {
          director.fireAt(this,currentTime);
        }
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75632,"/** 
 * Initialize the actor. Schedule a refiring of this actor at the stop time given by the <i>stopTime</i> parameter.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  double time=((DoubleToken)stopTime.getToken()).doubleValue();
  if (time > 0.0) {
    Director director=getDirector();
    if (director == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    double currentTime=director.getCurrentTime();
    director.fireAt(this,time);
  }
}","/** 
 * Initialize the actor. Schedule a refiring of this actor at the stop time given by the <i>stopTime</i> parameter.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  double time=((DoubleToken)stopTime.getToken()).doubleValue();
  if (time > 0.0) {
    Director director=getDirector();
    if (director == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    double currentTime=director.getCurrentTime();
    director.fireAt(this,time);
    _executing=true;
  }
}"
75633,"/** 
 * Create shadow variables for the port, if it is an input port, and otherwise do nothing. The shadow variables are contained by this actor and can be referenced in the guard and trigger expressions of transitions.  The shadow variables are lazy so that they are not evaluated until their values are needed, so the guard and trigger transitions should also be lazy. <p> If the given port is not a multiport, but is connected to something, then two variables are created: one is input status variable with name ""<i>portName</i>_isPresent""; the other is input value variable with name ""<i>portName</i>"". The input status variable always contains a BooleanToken. When this actor is fired, the status variable is set to <i>true</i> if the port has a token, and to <i>false</i> otherwise. The input value variable always contains the latest token received from the port. <p> If the given port is a multiport, a status variable and a value variable are created for each channel. The status variable is named ""<i>portName</i>_<i>channelIndex</i>_isPresent"". The value variable is named ""<i>portName</i>_<i>channelIndex</i>"". <p> If a variable to be created has the same name as an attribute already contained by this actor, that attribute will be removed from this actor by setting its container to null.
 * @param port The port for which to create a shadow variable.
 * @exception IllegalActionException If the port is not containedby this FSMActor.
 */
protected void _createInputVariables(IOPort port) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  if (_inputVariableMap.get(port) != null) {
    _removeInputVariables(port);
  }
  int width=port.getWidth();
  if (width == 0) {
    return;
  }
  Variable[][] shadowVariables=new Variable[width][2];
  String portName=port.getName();
  for (int channelIndex=0; channelIndex < width; ++channelIndex) {
    if (_stopRequested)     break;
    String shadowName=null;
    if (port.isMultiport()) {
      shadowName=portName + ""String_Node_Str"" + channelIndex;
    }
 else {
      shadowName=portName;
    }
    String predicateName=shadowName + ""String_Node_Str"";
    Attribute previousAttribute=getAttribute(predicateName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][0]=new Variable(this,predicateName);
      shadowVariables[channelIndex][0].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ portName+ ""String_Node_Str""+ ex.getMessage());
    }
    previousAttribute=getAttribute(shadowName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][1]=new Variable(this,shadowName);
      shadowVariables[channelIndex][1].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
  }
  _inputVariableMap.put(port,shadowVariables);
}","/** 
 * Create shadow variables for the port, if it is an input port, and otherwise do nothing. The shadow variables are contained by this actor and can be referenced in the guard and trigger expressions of transitions.  The shadow variables are lazy so that they are not evaluated until their values are needed, so the guard and trigger transitions should also be lazy. <p> If the given port is not a multiport, but is connected to something, then two variables are created: one is input status variable with name ""<i>portName</i>_isPresent""; the other is input value variable with name ""<i>portName</i>"". The input status variable always contains a BooleanToken. When this actor is fired, the status variable is set to <i>true</i> if the port has a token, and to <i>false</i> otherwise. The input value variable always contains the latest token received from the port. <p> If the given port is a multiport, a status variable and a value variable are created for each channel. The status variable is named ""<i>portName</i>_<i>channelIndex</i>_isPresent"". The value variable is named ""<i>portName</i>_<i>channelIndex</i>"". <p> If a variable to be created has the same name as an attribute already contained by this actor, that attribute will be removed from this actor by setting its container to null.
 * @param port The port for which to create a shadow variable.
 * @exception IllegalActionException If the port is not containedby this FSMActor.
 */
protected void _createInputVariables(IOPort port) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    return;
  }
  if (_inputVariableMap.get(port) != null) {
    _removeInputVariables(port);
  }
  int width=port.getWidth();
  if (width == 0) {
    return;
  }
  Variable[][] shadowVariables=new Variable[width][2];
  String portName=port.getName();
  for (int channelIndex=0; channelIndex < width; ++channelIndex) {
    String shadowName=null;
    if (port.isMultiport()) {
      shadowName=portName + ""String_Node_Str"" + channelIndex;
    }
 else {
      shadowName=portName;
    }
    String predicateName=shadowName + ""String_Node_Str"";
    Attribute previousAttribute=getAttribute(predicateName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][0]=new Variable(this,predicateName);
      shadowVariables[channelIndex][0].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ portName+ ""String_Node_Str""+ ex.getMessage());
    }
    previousAttribute=getAttribute(shadowName);
    try {
      if (previousAttribute != null) {
        previousAttribute.setContainer(null);
      }
      shadowVariables[channelIndex][1]=new Variable(this,shadowName);
      shadowVariables[channelIndex][1].setLazy(true);
    }
 catch (    NameDuplicationException ex) {
      throw new InvalidStateException(this,""String_Node_Str"" + ex.getMessage());
    }
  }
  _inputVariableMap.put(port,shadowVariables);
}"
75634,"/** 
 * Open a file dialog to identify a file to be opened, and then call _read() to open the file.
 */
protected void _open(){
  JFileChooser fileDialog=new JFileChooser();
  if (_fileFilter != null) {
    fileDialog.addChoosableFileFilter(_fileFilter);
  }
  fileDialog.setDialogTitle(""String_Node_Str"");
  if (_directory != null) {
    fileDialog.setCurrentDirectory(_directory);
  }
 else {
    String cwd=System.getProperty(""String_Node_Str"");
    if (cwd != null) {
      fileDialog.setCurrentDirectory(new File(cwd));
    }
  }
  if (fileDialog.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
    _directory=fileDialog.getCurrentDirectory();
    try {
      File file=fileDialog.getSelectedFile().getCanonicalFile();
      _read(file.toURL());
    }
 catch (    Exception ex) {
      if (!ex.getMessage().startsWith(""String_Node_Str"")) {
        report(""String_Node_Str"",ex);
      }
    }
  }
}","/** 
 * Open a file dialog to identify a file to be opened, and then call _read() to open the file.
 */
protected void _open(){
  JFileChooser fileDialog=new JFileChooser();
  if (_fileFilter != null) {
    fileDialog.addChoosableFileFilter(_fileFilter);
  }
  fileDialog.setDialogTitle(""String_Node_Str"");
  if (_directory != null) {
    fileDialog.setCurrentDirectory(_directory);
  }
 else {
    String cwd=System.getProperty(""String_Node_Str"");
    if (cwd != null) {
      fileDialog.setCurrentDirectory(new File(cwd));
    }
  }
  if (fileDialog.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
    _directory=fileDialog.getCurrentDirectory();
    try {
      File file=fileDialog.getSelectedFile().getCanonicalFile();
      _read(file.toURL());
    }
 catch (    Exception ex) {
      if (ex.getMessage() != null && !ex.getMessage().startsWith(""String_Node_Str"")) {
        report(""String_Node_Str"",ex);
      }
    }
  }
}"
75635,"/** 
 * Construct a UnsignedByteToken from the specified string.  The string is parsed by the parseByte() method of the Java Byte object.
 * @exception IllegalActionException If the token could notbe created from the given string.
 */
public UnsignedByteToken(String init) throws IllegalActionException {
  try {
    _value=Byte.parseByte(init);
  }
 catch (  NumberFormatException e) {
    throw new IllegalActionException(e.getMessage());
  }
}","/** 
 * Construct a UnsignedByteToken from the specified string.  The string is parsed by the parseByte() method of the Java Byte object.
 * @exception IllegalActionException If the token could notbe created from the given string.
 */
public UnsignedByteToken(String init) throws IllegalActionException {
  try {
    int value=Integer.parseInt(init);
    if (value > 255 || value < 0) {
      throw new IllegalActionException(""String_Node_Str"" + init + ""String_Node_Str"");
    }
    _value=(byte)value;
  }
 catch (  NumberFormatException e) {
    throw new IllegalActionException(e.getMessage());
  }
}"
75636,"/** 
 * Return the value of this token as a string that can be parsed by the expression language to recover a token with the same value. If this token has a unit, the return string also includes a unit string produced by the unitsString() method in the super class.
 * @return A String representing the byte value and the units (ifany) of this token.
 * @see ptolemy.data.ScalarToken#unitsString
 */
public String toString(){
  String unitString=""String_Node_Str"";
  if (!_isUnitless()) {
    unitString=""String_Node_Str"" + unitsString();
  }
  return Byte.toString(_value) + unitString;
}","/** 
 * Return the value of this token as a string that can be parsed by the expression language to recover a token with the same value. If this token has a unit, the return string also includes a unit string produced by the unitsString() method in the super class.
 * @return A String representing the byte value and the units (ifany) of this token.
 * @see ptolemy.data.ScalarToken#unitsString
 */
public String toString(){
  String unitString=""String_Node_Str"";
  if (!_isUnitless()) {
    unitString=""String_Node_Str"" + unitsString();
  }
  return Integer.toString(unsignedConvert(_value)) + unitString;
}"
75637,"final public void primaryElement() throws ParseException {
  int len;
  String tidied, x;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case COMPLEX:
    ASTPtLeafNode jjtn001=new ASTPtLeafNode(JJTPTLEAFNODE);
  boolean jjtc001=true;
jjtree.openNodeScope(jjtn001);
try {
jj_consume_token(COMPLEX);
jjtree.closeNodeScope(jjtn001,true);
jjtc001=false;
try {
  x=token.image.toLowerCase();
  len=x.length();
  Double imag=new Double(x.substring(0,len - 1));
  Complex value=new Complex(0,imag.doubleValue());
  jjtn001._ptToken=new ComplexToken(value);
  jjtn001._isConstant=true;
}
 catch (NumberFormatException ee) {
{
    if (true)     throw new ParseException(""String_Node_Str"" + token.image + ""String_Node_Str"");
  }
}
}
  finally {
if (jjtc001) {
  jjtree.closeNodeScope(jjtn001,true);
}
}
break;
case DOUBLE:
ASTPtLeafNode jjtn002=new ASTPtLeafNode(JJTPTLEAFNODE);
boolean jjtc002=true;
jjtree.openNodeScope(jjtn002);
try {
jj_consume_token(DOUBLE);
jjtree.closeNodeScope(jjtn002,true);
jjtc002=false;
try {
x=token.image.toLowerCase();
len=x.length();
if (x.endsWith(""String_Node_Str"") || x.endsWith(""String_Node_Str"")) {
Double value=new Double(x.substring(0,len - 1));
jjtn002._ptToken=new DoubleToken(value.doubleValue());
}
 else {
Double value=new Double(x);
jjtn002._ptToken=new DoubleToken(value.doubleValue());
}
jjtn002._isConstant=true;
}
 catch (NumberFormatException ee) {
{
if (true) throw new ParseException(""String_Node_Str"" + token.image + ""String_Node_Str"");
}
}
}
  finally {
if (jjtc002) {
jjtree.closeNodeScope(jjtn002,true);
}
}
break;
case INTEGER:
ASTPtLeafNode jjtn003=new ASTPtLeafNode(JJTPTLEAFNODE);
boolean jjtc003=true;
jjtree.openNodeScope(jjtn003);
try {
jj_consume_token(INTEGER);
jjtree.closeNodeScope(jjtn003,true);
jjtc003=false;
try {
x=token.image.toLowerCase();
len=x.length();
int radix;
boolean mustBeLong=x.endsWith(""String_Node_Str"");
boolean mustBeUnsignedByte=x.endsWith(""String_Node_Str"");
int prefixLength;
int suffixLength;
if (mustBeLong) {
suffixLength=1;
}
 else if (mustBeUnsignedByte) {
suffixLength=2;
}
 else {
suffixLength=0;
}
if (x.startsWith(""String_Node_Str"")) {
radix=16;
prefixLength=2;
}
 else if (x.startsWith(""String_Node_Str"") && (x.length() > 1)) {
radix=8;
prefixLength=1;
}
 else {
radix=10;
prefixLength=0;
}
x=x.substring(prefixLength,len - suffixLength);
if (mustBeLong) {
jjtn003._ptToken=new LongToken(Long.parseLong(x,radix));
}
 else if (mustBeUnsignedByte) {
jjtn003._ptToken=new UnsignedByteToken(Byte.parseByte(x,radix));
}
 else {
try {
jjtn003._ptToken=new IntToken(Integer.parseInt(x,radix));
}
 catch (NumberFormatException nfe) {
jjtn003._ptToken=new LongToken(Long.parseLong(x,radix));
}
}
jjtn003._isConstant=true;
}
 catch (NumberFormatException ee) {
{
if (true) throw new ParseException(""String_Node_Str"" + token.image + ""String_Node_Str"");
}
}
}
  finally {
if (jjtc003) {
jjtree.closeNodeScope(jjtn003,true);
}
}
break;
case STRING:
ASTPtLeafNode jjtn004=new ASTPtLeafNode(JJTPTLEAFNODE);
boolean jjtc004=true;
jjtree.openNodeScope(jjtn004);
try {
jj_consume_token(STRING);
jjtree.closeNodeScope(jjtn004,true);
jjtc004=false;
len=token.image.length();
tidied=token.image.substring(1,(len - 1));
StringTokenizer st=new StringTokenizer(tidied,""String_Node_Str"",true);
boolean escape=false;
x=new String();
while (st.hasMoreTokens()) {
String tok=st.nextToken();
if (escape) {
escape=false;
int trailingCharIndex=1;
switch (tok.charAt(0)) {
case 'n':
x+=""String_Node_Str"";
break;
case 't':
x+=""String_Node_Str"";
break;
case 'b':
x+=""String_Node_Str"";
break;
case 'r':
x+=""String_Node_Str"";
break;
case 'f':
x+=""String_Node_Str"";
break;
case '\\':
x+=""String_Node_Str"";
break;
case '\'':
x+=""String_Node_Str"";
break;
case '""':
x+=""String_Node_Str"";
break;
default :
int i;
for (i=0; i < tok.length(); i++) {
char c=tok.charAt(i);
if (!(c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7')) break;
}
trailingCharIndex=i;
int octVal=Integer.parseInt(tok.substring(0,trailingCharIndex),8);
x+=(char)octVal;
break;
}
if (trailingCharIndex < tok.length()) {
x+=tok.substring(trailingCharIndex);
}
}
 else if (tok.equals(""String_Node_Str"")) {
escape=true;
}
 else {
x+=tok;
}
}
jjtn004._ptToken=new StringToken(x);
jjtn004._isConstant=true;
}
  finally {
if (jjtc004) {
jjtree.closeNodeScope(jjtn004,true);
}
}
break;
case BOOLEAN:
ASTPtLeafNode jjtn005=new ASTPtLeafNode(JJTPTLEAFNODE);
boolean jjtc005=true;
jjtree.openNodeScope(jjtn005);
try {
jj_consume_token(BOOLEAN);
jjtree.closeNodeScope(jjtn005,true);
jjtc005=false;
if (token.image.equalsIgnoreCase(""String_Node_Str"")) {
jjtn005._ptToken=BooleanToken.TRUE;
}
 else if (token.image.equalsIgnoreCase(""String_Node_Str"")) {
jjtn005._ptToken=BooleanToken.FALSE;
}
jjtn005._isConstant=true;
}
  finally {
if (jjtc005) {
jjtree.closeNodeScope(jjtn005,true);
}
}
break;
case 47:
jj_consume_token(47);
funcIf();
jj_consume_token(49);
break;
default :
jj_la1[21]=jj_gen;
if (jj_2_1(2147483647)) {
matrixConstruct();
}
 else if (jj_2_2(2147483647)) {
recordConstruct();
}
 else if (jj_2_3(2147483647)) {
arrayConstruct();
}
 else if (jj_2_4(2147483647)) {
function();
}
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ID:
identifier();
break;
default :
jj_la1[22]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}
}
}","final public void primaryElement() throws ParseException {
  int len;
  String tidied, x;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case COMPLEX:
    ASTPtLeafNode jjtn001=new ASTPtLeafNode(JJTPTLEAFNODE);
  boolean jjtc001=true;
jjtree.openNodeScope(jjtn001);
try {
jj_consume_token(COMPLEX);
jjtree.closeNodeScope(jjtn001,true);
jjtc001=false;
try {
  x=token.image.toLowerCase();
  len=x.length();
  Double imag=new Double(x.substring(0,len - 1));
  Complex value=new Complex(0,imag.doubleValue());
  jjtn001._ptToken=new ComplexToken(value);
  jjtn001._isConstant=true;
}
 catch (NumberFormatException ee) {
{
    if (true)     throw new ParseException(""String_Node_Str"" + token.image + ""String_Node_Str"");
  }
}
}
  finally {
if (jjtc001) {
  jjtree.closeNodeScope(jjtn001,true);
}
}
break;
case DOUBLE:
ASTPtLeafNode jjtn002=new ASTPtLeafNode(JJTPTLEAFNODE);
boolean jjtc002=true;
jjtree.openNodeScope(jjtn002);
try {
jj_consume_token(DOUBLE);
jjtree.closeNodeScope(jjtn002,true);
jjtc002=false;
try {
x=token.image.toLowerCase();
len=x.length();
if (x.endsWith(""String_Node_Str"") || x.endsWith(""String_Node_Str"")) {
Double value=new Double(x.substring(0,len - 1));
jjtn002._ptToken=new DoubleToken(value.doubleValue());
}
 else {
Double value=new Double(x);
jjtn002._ptToken=new DoubleToken(value.doubleValue());
}
jjtn002._isConstant=true;
}
 catch (NumberFormatException ee) {
{
if (true) throw new ParseException(""String_Node_Str"" + token.image + ""String_Node_Str"");
}
}
}
  finally {
if (jjtc002) {
jjtree.closeNodeScope(jjtn002,true);
}
}
break;
case INTEGER:
ASTPtLeafNode jjtn003=new ASTPtLeafNode(JJTPTLEAFNODE);
boolean jjtc003=true;
jjtree.openNodeScope(jjtn003);
try {
jj_consume_token(INTEGER);
jjtree.closeNodeScope(jjtn003,true);
jjtc003=false;
try {
x=token.image.toLowerCase();
len=x.length();
int radix;
boolean mustBeLong=x.endsWith(""String_Node_Str"");
boolean mustBeUnsignedByte=x.endsWith(""String_Node_Str"");
int prefixLength;
int suffixLength;
if (mustBeLong) {
suffixLength=1;
}
 else if (mustBeUnsignedByte) {
suffixLength=2;
}
 else {
suffixLength=0;
}
if (x.startsWith(""String_Node_Str"")) {
radix=16;
prefixLength=2;
}
 else if (x.startsWith(""String_Node_Str"")) {
radix=8;
prefixLength=0;
}
 else {
radix=10;
prefixLength=0;
}
x=x.substring(prefixLength,len - suffixLength);
if (mustBeLong) {
jjtn003._ptToken=new LongToken(Long.parseLong(x,radix));
}
 else if (mustBeUnsignedByte) {
jjtn003._ptToken=new UnsignedByteToken(Integer.parseInt(x,radix));
}
 else {
try {
jjtn003._ptToken=new IntToken(Integer.parseInt(x,radix));
}
 catch (NumberFormatException nfe) {
jjtn003._ptToken=new LongToken(Long.parseLong(x,radix));
}
}
jjtn003._isConstant=true;
}
 catch (NumberFormatException ee) {
{
if (true) throw new ParseException(""String_Node_Str"" + token.image + ""String_Node_Str"");
}
}
}
  finally {
if (jjtc003) {
jjtree.closeNodeScope(jjtn003,true);
}
}
break;
case STRING:
ASTPtLeafNode jjtn004=new ASTPtLeafNode(JJTPTLEAFNODE);
boolean jjtc004=true;
jjtree.openNodeScope(jjtn004);
try {
jj_consume_token(STRING);
jjtree.closeNodeScope(jjtn004,true);
jjtc004=false;
len=token.image.length();
tidied=token.image.substring(1,(len - 1));
StringTokenizer st=new StringTokenizer(tidied,""String_Node_Str"",true);
boolean escape=false;
x=new String();
while (st.hasMoreTokens()) {
String tok=st.nextToken();
if (escape) {
escape=false;
int trailingCharIndex=1;
switch (tok.charAt(0)) {
case 'n':
x+=""String_Node_Str"";
break;
case 't':
x+=""String_Node_Str"";
break;
case 'b':
x+=""String_Node_Str"";
break;
case 'r':
x+=""String_Node_Str"";
break;
case 'f':
x+=""String_Node_Str"";
break;
case '\\':
x+=""String_Node_Str"";
break;
case '\'':
x+=""String_Node_Str"";
break;
case '""':
x+=""String_Node_Str"";
break;
default :
int i;
for (i=0; i < tok.length(); i++) {
char c=tok.charAt(i);
if (!(c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7')) break;
}
trailingCharIndex=i;
int octVal=Integer.parseInt(tok.substring(0,trailingCharIndex),8);
x+=(char)octVal;
break;
}
if (trailingCharIndex < tok.length()) {
x+=tok.substring(trailingCharIndex);
}
}
 else if (tok.equals(""String_Node_Str"")) {
escape=true;
}
 else {
x+=tok;
}
}
jjtn004._ptToken=new StringToken(x);
jjtn004._isConstant=true;
}
  finally {
if (jjtc004) {
jjtree.closeNodeScope(jjtn004,true);
}
}
break;
case BOOLEAN:
ASTPtLeafNode jjtn005=new ASTPtLeafNode(JJTPTLEAFNODE);
boolean jjtc005=true;
jjtree.openNodeScope(jjtn005);
try {
jj_consume_token(BOOLEAN);
jjtree.closeNodeScope(jjtn005,true);
jjtc005=false;
if (token.image.equalsIgnoreCase(""String_Node_Str"")) {
jjtn005._ptToken=BooleanToken.TRUE;
}
 else if (token.image.equalsIgnoreCase(""String_Node_Str"")) {
jjtn005._ptToken=BooleanToken.FALSE;
}
jjtn005._isConstant=true;
}
  finally {
if (jjtc005) {
jjtree.closeNodeScope(jjtn005,true);
}
}
break;
case 47:
jj_consume_token(47);
funcIf();
jj_consume_token(49);
break;
default :
jj_la1[21]=jj_gen;
if (jj_2_1(2147483647)) {
matrixConstruct();
}
 else if (jj_2_2(2147483647)) {
recordConstruct();
}
 else if (jj_2_3(2147483647)) {
arrayConstruct();
}
 else if (jj_2_4(2147483647)) {
function();
}
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case ID:
identifier();
break;
default :
jj_la1[22]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}
}
}"
75638,"/** 
 * Simulate the creation of tokens by the given output port when its actor fires.  If any actors that receive tokens are then ready to fire, given that only actors in the actor list are being scheduled, then add those actors to the list of actors that are ready to schedule. update the waiting tokens map with the tokens available on each channel of each port.
 * @param outputPort The port that is creating the tokens.
 * @param createdTokens The number of tokens to create.
 * @param actorList The list of actors that are being scheduled.
 * @param readyToScheduleActorList The list of actors that are readyto be scheduled.  This will be updated if any actors that receive tokens from outputPort are now ready to fire.
 * @param waitingTokens A map from port to an array of integersrepresenting the number of tokens in each receiver of an input port. This will be updated according to the tokens that are created.
 */
private void _simulateTokensCreated(IOPort outputPort,int createdTokens,LinkedList actorList,LinkedList readyToScheduleActorList,Map waitingTokens,Map minimumBufferSize) throws IllegalActionException {
  Receiver[][] receivers=outputPort.getRemoteReceivers();
  if (_debugging) {
    _debug(""String_Node_Str"" + createdTokens + ""String_Node_Str""+ outputPort.getFullName());
    _debug(""String_Node_Str"" + receivers.length);
  }
  int sourceChannel=0;
  Iterator relations=outputPort.linkedRelationList().iterator();
  while (relations.hasNext()) {
    IORelation relation=(IORelation)relations.next();
    if (relation == null) {
      continue;
    }
    Integer bufferSize=(Integer)minimumBufferSize.get(relation);
    int width=relation.getWidth();
    for (int i=0; i < width; i++, sourceChannel++) {
      if (_debugging) {
        _debug(""String_Node_Str"" + relation.getName() + ""String_Node_Str""+ sourceChannel+ ""String_Node_Str""+ receivers[sourceChannel].length);
      }
      for (int destinationIndex=0; destinationIndex < receivers[sourceChannel].length; destinationIndex++) {
        IOPort connectedPort=(IOPort)receivers[sourceChannel][destinationIndex].getContainer();
        ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
        int destinationChannel=_getChannel(connectedPort,receivers[sourceChannel][destinationIndex]);
        int[] tokens=(int[])waitingTokens.get(connectedPort);
        tokens[destinationChannel]+=createdTokens;
        if (bufferSize != null && tokens[destinationChannel] > bufferSize.intValue()) {
          bufferSize=new Integer(tokens[destinationChannel]);
        }
        if (_debugging) {
          _debug(""String_Node_Str"" + destinationChannel + ""String_Node_Str""+ connectedPort.getName());
        }
        if (actorList.contains(connectedActor)) {
          int inputCount=_countUnfulfilledInputs((Actor)connectedActor,actorList,waitingTokens);
          int firingsRemaining=_getFiringCount(connectedActor);
          if ((inputCount < 1) && (firingsRemaining > 0)) {
            readyToScheduleActorList.addLast(connectedActor);
          }
        }
      }
    }
    minimumBufferSize.put(relation,bufferSize);
  }
}","/** 
 * Simulate the creation of tokens by the given output port when its actor fires.  If any actors that receive tokens are then ready to fire, given that only actors in the actor list are being scheduled, then add those actors to the list of actors that are ready to schedule. update the waiting tokens map with the tokens available on each channel of each port.
 * @param outputPort The port that is creating the tokens.
 * @param createdTokens The number of tokens to create.
 * @param actorList The list of actors that are being scheduled.
 * @param readyToScheduleActorList The list of actors that are readyto be scheduled.  This will be updated if any actors that receive tokens from outputPort are now ready to fire.
 * @param waitingTokens A map from port to an array of integersrepresenting the number of tokens in each receiver of an input port. This will be updated according to the tokens that are created.
 */
private void _simulateTokensCreated(IOPort outputPort,int createdTokens,LinkedList actorList,LinkedList readyToScheduleActorList,Map waitingTokens,Map minimumBufferSize) throws IllegalActionException {
  Receiver[][] receivers=outputPort.getRemoteReceivers();
  if (_debugging) {
    _debug(""String_Node_Str"" + createdTokens + ""String_Node_Str""+ outputPort.getFullName());
    _debug(""String_Node_Str"" + receivers.length);
    _debug(""String_Node_Str"" + outputPort.getWidth());
  }
  int sourceChannel=0;
  Iterator relations=outputPort.linkedRelationList().iterator();
  while (relations.hasNext()) {
    IORelation relation=(IORelation)relations.next();
    if (relation == null) {
      continue;
    }
    Integer bufferSize=(Integer)minimumBufferSize.get(relation);
    int width=relation.getWidth();
    for (int i=0; i < width; i++, sourceChannel++) {
      if (receivers[sourceChannel] == null) {
        continue;
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + relation.getName() + ""String_Node_Str""+ sourceChannel+ ""String_Node_Str""+ receivers[sourceChannel].length);
      }
      for (int destinationIndex=0; destinationIndex < receivers[sourceChannel].length; destinationIndex++) {
        IOPort connectedPort=(IOPort)receivers[sourceChannel][destinationIndex].getContainer();
        ComponentEntity connectedActor=(ComponentEntity)connectedPort.getContainer();
        int destinationChannel=_getChannel(connectedPort,receivers[sourceChannel][destinationIndex]);
        int[] tokens=(int[])waitingTokens.get(connectedPort);
        tokens[destinationChannel]+=createdTokens;
        if (bufferSize != null && tokens[destinationChannel] > bufferSize.intValue()) {
          bufferSize=new Integer(tokens[destinationChannel]);
        }
        if (_debugging) {
          _debug(""String_Node_Str"" + destinationChannel + ""String_Node_Str""+ connectedPort.getName());
        }
        if (actorList.contains(connectedActor)) {
          int inputCount=_countUnfulfilledInputs((Actor)connectedActor,actorList,waitingTokens);
          int firingsRemaining=_getFiringCount(connectedActor);
          if ((inputCount < 1) && (firingsRemaining > 0)) {
            readyToScheduleActorList.addLast(connectedActor);
          }
        }
      }
    }
    minimumBufferSize.put(relation,bufferSize);
  }
}"
75639,"/** 
 * Return the epsilon-closure of the specified state. Epsilon-closure is defined in Definition 11 of the interface automaton paper. It is the set of states that can be reached from the specified state by taking only internal transitions.
 * @param state The state from which the espilon-closure is computed.
 * @return A set of instances of State.
 */
public Set epsilonClosure(State state){
  Set closure=new HashSet();
  Set frontier=new HashSet();
  closure.add(state);
  frontier.add(state);
  while (!frontier.isEmpty()) {
    Iterator iterator=frontier.iterator();
    State current=(State)iterator.next();
    frontier.remove(current);
    ComponentPort outPort=current.outgoingPort;
    Iterator transitions=outPort.linkedRelationList().iterator();
    while (transitions.hasNext()) {
      InterfaceAutomatonTransition transition=(InterfaceAutomatonTransition)transitions.next();
      int transitionType=transition.getType();
      if (transitionType == InterfaceAutomatonTransition._INTERNAL_TRANSITION) {
        State destinationState=transition.destinationState();
        if (!closure.contains(destinationState)) {
          closure.add(destinationState);
          closure.add(destinationState);
        }
      }
    }
  }
  return closure;
}","/** 
 * Return the epsilon-closure of the specified state. Epsilon-closure is defined in Definition 11 of the interface automaton paper. It is the set of states that can be reached from the specified state by taking only internal transitions.
 * @param state The state from which the espilon-closure is computed.
 * @return A set of instances of State.
 */
public Set epsilonClosure(State state){
  Set closure=new HashSet();
  Set frontier=new HashSet();
  closure.add(state);
  frontier.add(state);
  while (!frontier.isEmpty()) {
    Iterator iterator=frontier.iterator();
    State current=(State)iterator.next();
    frontier.remove(current);
    ComponentPort outPort=current.outgoingPort;
    Iterator transitions=outPort.linkedRelationList().iterator();
    while (transitions.hasNext()) {
      InterfaceAutomatonTransition transition=(InterfaceAutomatonTransition)transitions.next();
      int transitionType=transition.getType();
      if (transitionType == InterfaceAutomatonTransition._INTERNAL_TRANSITION) {
        State destinationState=transition.destinationState();
        if (!closure.contains(destinationState)) {
          closure.add(destinationState);
          frontier.add(destinationState);
        }
      }
    }
  }
  return closure;
}"
75640,"/** 
 * Transfer data from this port to the ports it is connected to on the outside. This port must be an opaque output port.  If any channel of this port has no data, then that channel is ignored. This method will transfer exactly one token on each output channel that has at least one token available.
 * @exception IllegalActionException If the port is not an opaqueoutput port.
 * @return True if at least one data token is transferred.
 * @deprecated domains should use getInside directly to implement theirtransferOutputs method.
 */
public boolean transferOutputs() throws IllegalActionException {
  if (!this.isOutput() || !this.isOpaque()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean wasTransferred=false;
  for (int i=0; i < getWidthInside(); i++) {
    try {
      if (isKnown(i)) {
        if (hasTokenInside(i)) {
          Token t=getInside(i);
          send(i,t);
          wasTransferred=true;
        }
 else {
          sendAbsent(i);
        }
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(this,ex,null);
    }
  }
  return wasTransferred;
}","/** 
 * Transfer data from this port to the ports it is connected to on the outside. This port must be an opaque output port.  If any channel of this port has no data, then that channel is ignored. This method will transfer exactly one token on each output channel that has at least one token available.
 * @exception IllegalActionException If the port is not an opaqueoutput port.
 * @return True if at least one data token is transferred.
 * @deprecated domains should use getInside directly to implement theirtransferOutputs method.
 */
public boolean transferOutputs() throws IllegalActionException {
  if (!this.isOutput() || !this.isOpaque()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  boolean wasTransferred=false;
  for (int i=0; i < getWidthInside(); i++) {
    try {
      if (isKnownInside(i)) {
        if (hasTokenInside(i)) {
          Token t=getInside(i);
          send(i,t);
          wasTransferred=true;
        }
 else {
          sendAbsent(i);
        }
      }
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(this,ex,null);
    }
  }
  return wasTransferred;
}"
75641,"protected void _reinitialize() throws IllegalActionException {
  if (_decimationPhaseValue >= _decimationValue) {
    throw new IllegalActionException(this,""String_Node_Str"" + _decimationPhaseValue + ""String_Node_Str""+ _decimationValue+ ""String_Node_Str"");
  }
  _phaseLength=(int)(_taps.length / _interpolationValue);
  if ((_taps.length % _interpolationValue) != 0)   _phaseLength++;
  int length=(int)Math.max(_phaseLength,_decimationValue);
  if (_data == null) {
    _data=new Token[length];
    for (int i=0; i < length; i++) {
      _data[i]=_zero;
    }
    _mostRecent=_phaseLength;
  }
 else   if (_data.length != length) {
    Token[] _oldData=_data;
    _data=new Token[length];
    for (int i=0; i < length; i++) {
      if (i < _oldData.length) {
        _data[i]=_oldData[i];
      }
 else {
        _data[i]=_zero;
      }
    }
    _mostRecent=_phaseLength;
  }
  _reinitializeNeeded=false;
}","protected void _reinitialize() throws IllegalActionException {
  if (_decimationPhaseValue >= _decimationValue) {
    throw new IllegalActionException(this,""String_Node_Str"" + _decimationPhaseValue + ""String_Node_Str""+ _decimationValue+ ""String_Node_Str"");
  }
  _phaseLength=(int)(_taps.length / _interpolationValue);
  if ((_taps.length % _interpolationValue) != 0)   _phaseLength++;
  int length=_phaseLength + _decimationValue;
  if (_data == null) {
    _data=new Token[length];
    for (int i=0; i < length; i++) {
      _data[i]=_zero;
    }
    _mostRecent=_phaseLength;
  }
 else   if (_data.length != length) {
    Token[] _oldData=_data;
    _data=new Token[length];
    for (int i=0; i < length; i++) {
      if (i < _oldData.length) {
        _data[i]=_oldData[i];
      }
 else {
        _data[i]=_zero;
      }
    }
    _mostRecent=_phaseLength;
  }
  _reinitializeNeeded=false;
}"
75642,"protected void _reinitialize() throws IllegalActionException {
  if (_decimationPhaseValue >= _decimationValue) {
    throw new IllegalActionException(this,""String_Node_Str"" + _decimationPhaseValue + ""String_Node_Str""+ _decimationValue+ ""String_Node_Str"");
  }
  _phaseLength=(int)(_taps.length / _interpolationValue);
  if ((_taps.length % _interpolationValue) != 0)   _phaseLength++;
  int length=(int)Math.max(_phaseLength,_decimationValue);
  if (_data == null || _data.length != length) {
    _data=new Token[length];
    for (int i=0; i < length; i++) {
      _data[i]=_zero;
    }
    _mostRecent=_phaseLength;
  }
  _reinitializeNeeded=false;
}","protected void _reinitialize() throws IllegalActionException {
  if (_decimationPhaseValue >= _decimationValue) {
    throw new IllegalActionException(this,""String_Node_Str"" + _decimationPhaseValue + ""String_Node_Str""+ _decimationValue+ ""String_Node_Str"");
  }
  _phaseLength=(int)(_taps.length / _interpolationValue);
  if ((_taps.length % _interpolationValue) != 0)   _phaseLength++;
  int length=(int)Math.max(_phaseLength,_decimationValue);
  if (_data == null) {
    _data=new Token[length];
    for (int i=0; i < length; i++) {
      _data[i]=_zero;
    }
    _mostRecent=_phaseLength;
  }
 else   if (_data.length != length) {
    Token[] _oldData=_data;
    _data=new Token[length];
    for (int i=0; i < length; i++) {
      if (i < _oldData.length) {
        _data[i]=_oldData[i];
      }
 else {
        _data[i]=_zero;
      }
    }
    _mostRecent=_phaseLength;
  }
  _reinitializeNeeded=false;
}"
75643,"/** 
 * Consume the inputs and produce the outputs of the FIR filter.
 * @exception IllegalActionException If parameter values are invalid,or if there is no director, or if runtime type conflicts occur.
 */
public void fire() throws IllegalActionException {
  if (newTaps.hasToken(0)) {
    ArrayToken tapsToken=(ArrayToken)(newTaps.get(0));
    _taps=tapsToken.arrayValue();
    _zero=_taps[0].zero();
    _reinitializeNeeded=true;
  }
  for (int i=0; i < _blockSizeValue; i++) {
    super.fire();
  }
}","/** 
 * Consume the inputs and produce the outputs of the FIR filter.
 * @exception IllegalActionException If parameter values are invalid,or if there is no director, or if runtime type conflicts occur.
 */
public void fire() throws IllegalActionException {
  if (newTaps.hasToken(0)) {
    ArrayToken tapsToken=(ArrayToken)(newTaps.get(0));
    _taps=tapsToken.arrayValue();
    _zero=_taps[0].zero();
    _reinitialize();
  }
  for (int i=0; i < _blockSizeValue; i++) {
    super.fire();
  }
}"
75644,"/** 
 * If the model is paused, resume execution.  This method must be called from a different thread than that controlling the execution, since the thread controlling the execution is suspended.
 */
public void resume(){
synchronized (_resumeNotify) {
    if (_resumeNotifyWaiting) {
      _resumeNotify.notifyAll();
      _resumeNotifyWaiting=false;
    }
  }
  if (_state == PAUSED) {
synchronized (this) {
      if (_state == PAUSED) {
        _pauseRequested=false;
        notifyAll();
      }
    }
  }
}","/** 
 * If the model is paused, resume execution.  This method must be called from a different thread than that controlling the execution, since the thread controlling the execution is suspended.
 */
public void resume(){
  if (_state == PAUSED) {
synchronized (this) {
      if (_state == PAUSED) {
        _pauseRequested=false;
        notifyAll();
      }
 else {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else   if (_state == PAUSED_ON_BREAKPOINT) {
synchronized (this) {
      if (_state == PAUSED_ON_BREAKPOINT) {
        if (_resumeNotifyWaiting) {
          _resumeNotifyWaiting=false;
          notifyAll();
        }
      }
    }
  }
}"
75645,"/** 
 * Construct a breakpoint configurer for the specified entity.
 * @param object The entity to configure.
 * @param graphController The associated graph controller for the object.
 */
public BreakpointConfigurer(Entity object,BasicGraphController graphController){
  super();
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  setTextWidth(15);
  if (object instanceof Actor) {
    _actor=(Actor)object;
  }
 else {
    throw new InternalErrorException(""String_Node_Str"");
  }
  _graphController=graphController;
  Director director=((Actor)_actor).getExecutiveDirector();
  if (director == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    DebugController debugController=(DebugController)director.getAttribute(_DEBUGCONTROLLER);
    _actorProfile=null;
    if (debugController != null) {
      _actorProfile=debugController.getDebug(_actor);
    }
    if (_actorProfile == null) {
      _actorProfile=new DebugProfile(_graphController);
    }
    for (int i=0; i < _firingEventTypes.length; i++) {
      if (_actorProfile.isListening(_firingEventTypes[i])) {
        addCheckBox(_firingEventTypeLabels[i],_firingEventTypeLabels[i],true);
      }
 else {
        addCheckBox(_firingEventTypeLabels[i],_firingEventTypeLabels[i],false);
      }
    }
  }
}","/** 
 * Construct a breakpoint configurer for the specified entity.
 * @param object The entity to configure.
 * @param graphController The associated graph controller for the object.
 */
public BreakpointConfigurer(Entity object,BasicGraphController graphController){
  super();
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  setTextWidth(15);
  if (object instanceof Actor) {
    _actor=(Actor)object;
  }
 else {
    throw new InternalErrorException(""String_Node_Str"");
  }
  _graphController=graphController;
  Director director=((Actor)_actor).getExecutiveDirector();
  if (director == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    DebugController debugController=(DebugController)director.getAttribute(_DEBUGCONTROLLER);
    _actorProfile=null;
    if (debugController != null) {
      _actorProfile=debugController.getDebugProfile(_actor);
    }
    if (_actorProfile == null) {
      _actorProfile=new DebugProfile(_graphController);
    }
    for (int i=0; i < _firingEventTypes.length; i++) {
      if (_actorProfile.isListening(_firingEventTypes[i])) {
        addCheckBox(_firingEventTypeLabels[i],_firingEventTypeLabels[i],true);
      }
 else {
        addCheckBox(_firingEventTypeLabels[i],_firingEventTypeLabels[i],false);
      }
    }
  }
}"
75646,"/** 
 * Set up and save the new breakpoint configuration for this actor.
 */
public void apply(){
  boolean breakpointsSelected=false;
  DebugProfile profile=new DebugProfile(_graphController);
  for (int i=0; i < _firingEventTypes.length; i++) {
    if (getBooleanValue(_firingEventTypeLabels[i])) {
      profile.listenForEvent(_firingEventTypes[i]);
      breakpointsSelected=true;
    }
 else {
      profile.unlistenForEvent(_firingEventTypes[i]);
    }
  }
  Director director=((Actor)_actor).getExecutiveDirector();
  DebugController debugController=(DebugController)director.getAttribute(_DEBUGCONTROLLER);
  if (breakpointsSelected) {
    if (debugController == null) {
      try {
        debugController=new DebugController(director,_DEBUGCONTROLLER);
      }
 catch (      NameDuplicationException exception) {
        throw new RuntimeException(""String_Node_Str"");
      }
catch (      IllegalActionException exception) {
        throw new RuntimeException(""String_Node_Str"");
      }
      director.addDebugListener(debugController);
    }
    debugController.setDebug(_actor,profile);
  }
 else {
    debugController.unsetDebug(_actor);
  }
}","/** 
 * Set up and save the new breakpoint configuration for this actor.
 */
public void apply(){
  boolean breakpointsSelected=false;
  _actorProfile=new DebugProfile(_graphController);
  for (int i=0; i < _firingEventTypes.length; i++) {
    if (getBooleanValue(_firingEventTypeLabels[i])) {
      _actorProfile.listenForEvent(_firingEventTypes[i]);
      breakpointsSelected=true;
    }
 else {
      _actorProfile.unlistenForEvent(_firingEventTypes[i]);
    }
  }
  Director director=((Actor)_actor).getExecutiveDirector();
  DebugController debugController=(DebugController)director.getAttribute(_DEBUGCONTROLLER);
  if (breakpointsSelected) {
    if (debugController != null) {
      debugController.putDebugProfile(_actor,_actorProfile);
    }
 else {
      String moml=""String_Node_Str"" + _DEBUGCONTROLLER + ""String_Node_Str"";
      ChangeRequest request=new MoMLChangeRequest(this,director,moml.toString());
      director.addChangeListener(this);
      director.requestChange(request);
    }
  }
 else {
    debugController.removeDebugProfile(_actor);
  }
}"
75647,"/** 
 * The thread that calls this method will wait until resume() has been called. Note: This method will block.  Should only be called from the executing thread (the thread that is executing the model).  Do not call this method from the same thread that will call resume(). FIXME: Added by celaine.  Review this.  Works with DebugController to resume execution after a breakpoint. FIXME: in PN this could be called multiple times.  make sure this still works with multiple threads.
 */
public void pauseOnBreakpoint(String breakpointMessage){
  try {
    if (_state == ITERATING) {
synchronized (this) {
        if (_state == ITERATING) {
          _setState(PAUSED_ON_BREAKPOINT);
          _resumeNotifyWaiting=true;
          while (_resumeNotifyWaiting) {
            wait();
          }
          _setState(ITERATING);
        }
 else {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  InterruptedException error) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * The thread that calls this method will wait until resume() has been called. Note: This method will block.  Should only be called from the executing thread (the thread that is executing the model).  Do not call this method from the same thread that will call resume(). FIXME: Added by celaine.  Review this.  Works with DebugController to resume execution after a breakpoint. FIXME: in PN this could be called multiple times.  make sure this still works with multiple threads.
 */
public void pauseOnBreakpoint(String breakpointMessage){
  try {
    if (_state == ITERATING) {
synchronized (this) {
        if (_state == ITERATING) {
          PAUSED_ON_BREAKPOINT.setDescription(""String_Node_Str"" + breakpointMessage + ""String_Node_Str"");
          _setState(PAUSED_ON_BREAKPOINT);
          _resumeNotifyWaiting=true;
          while (_resumeNotifyWaiting) {
            wait();
          }
          _setState(ITERATING);
        }
 else {
          throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 catch (  InterruptedException error) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
75648,"/** 
 * Set up and save the new breakpoint configuration for this actor.
 */
public void apply(){
  boolean breakpointsSelected=false;
  _actorProfile=new DebugProfile(_graphController);
  for (int i=0; i < _firingEventTypes.length; i++) {
    if (getBooleanValue(_firingEventTypeLabels[i])) {
      _actorProfile.listenForEvent(_firingEventTypes[i]);
      breakpointsSelected=true;
    }
 else {
      _actorProfile.unlistenForEvent(_firingEventTypes[i]);
    }
  }
  Director director=((Actor)_actor).getExecutiveDirector();
  DebugController debugController=(DebugController)director.getAttribute(_DEBUGCONTROLLER);
  if (breakpointsSelected) {
    if (debugController != null) {
      debugController.putDebugProfile(_actor,_actorProfile);
    }
 else {
      String moml=""String_Node_Str"" + _DEBUGCONTROLLER + ""String_Node_Str"";
      ChangeRequest request=new MoMLChangeRequest(this,director,moml.toString());
      director.addChangeListener(this);
      director.requestChange(request);
    }
  }
 else {
    debugController.removeDebugProfile(_actor);
  }
}","/** 
 * Set up and save the new breakpoint configuration for this actor.
 */
public void apply(){
  boolean breakpointsSelected=false;
  _actorProfile=new DebugProfile(_graphController);
  for (int i=0; i < _firingEventTypes.length; i++) {
    if (getBooleanValue(_firingEventTypeLabels[i])) {
      _actorProfile.listenForEvent(_firingEventTypes[i]);
      breakpointsSelected=true;
    }
 else {
      _actorProfile.unlistenForEvent(_firingEventTypes[i]);
    }
  }
  Director director=((Actor)_actor).getExecutiveDirector();
  DebugController debugController=(DebugController)director.getAttribute(_DEBUGCONTROLLER);
  if (breakpointsSelected) {
    if (debugController != null) {
      debugController.putDebugProfile(_actor,_actorProfile);
    }
 else {
      String moml=""String_Node_Str"" + _DEBUGCONTROLLER + ""String_Node_Str"";
      ChangeRequest request=new MoMLChangeRequest(this,director,moml.toString());
      request.addChangeListener(this);
      director.requestChange(request);
    }
  }
 else {
    debugController.removeDebugProfile(_actor);
  }
}"
75649,"/** 
 * Set the name of the ComponentEntity. If there is already a ComponentEntity of the container with the same name, throw an exception.
 * @exception IllegalActionException If the name has a period.
 * @exception NameDuplicationException If there already is an entityin the container with the same name.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    name=new String(""String_Node_Str"");
  }
  CompositeEntity container=(CompositeEntity)getContainer();
  if ((container != null)) {
    ComponentEntity another=(ComponentEntity)container.getEntity(name);
    if ((another != null) && (another != this)) {
      throw new NameDuplicationException(container,""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  super.setName(name);
}","/** 
 * Set the name of the ComponentEntity. If there is already a ComponentEntity of the container with the same name, throw an exception.
 * @exception IllegalActionException If the name has a period.
 * @exception NameDuplicationException If there already is an entityin the container with the same name.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    name=new String(""String_Node_Str"");
  }
  CompositeEntity container=(CompositeEntity)getContainer();
  if ((container != null)) {
    ComponentEntity another=(ComponentEntity)container.getEntity(name);
    if ((another != null) && (another != this)) {
      throw new NameDuplicationException(container,""String_Node_Str"" + name);
    }
  }
  super.setName(name);
}"
75650,"/** 
 * Set the name of the ComponentRelation. If there is already a ComponentRelation of the container with the same name, throw an exception.
 * @exception IllegalActionException If the name has a period.
 * @exception NameDuplicationException If there is already a relationwith the same name in the container.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    name=new String(""String_Node_Str"");
  }
  CompositeEntity container=(CompositeEntity)getContainer();
  if ((container != null)) {
    ComponentRelation another=container.getRelation(name);
    if ((another != null) && (another != this)) {
      throw new NameDuplicationException(container,""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  super.setName(name);
}","/** 
 * Set the name of the ComponentRelation. If there is already a ComponentRelation of the container with the same name, throw an exception.
 * @exception IllegalActionException If the name has a period.
 * @exception NameDuplicationException If there is already a relationwith the same name in the container.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    name=new String(""String_Node_Str"");
  }
  CompositeEntity container=(CompositeEntity)getContainer();
  if ((container != null)) {
    ComponentRelation another=container.getRelation(name);
    if ((another != null) && (another != this)) {
      throw new NameDuplicationException(container,""String_Node_Str"" + name);
    }
  }
  super.setName(name);
}"
75651,"/** 
 * Set the name of the port. If there is already an port of the container entity with the same name, then throw an exception.
 * @exception IllegalActionException If the name has a period.
 * @exception NameDuplicationException If there is already a portwith the same name in the container.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    name=new String(""String_Node_Str"");
  }
  Entity container=(Entity)getContainer();
  if ((container != null)) {
    Port another=container.getPort(name);
    if ((another != null) && (another != this)) {
      throw new NameDuplicationException(container,""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  super.setName(name);
}","/** 
 * Set the name of the port. If there is already an port of the container entity with the same name, then throw an exception.
 * @exception IllegalActionException If the name has a period.
 * @exception NameDuplicationException If there is already a portwith the same name in the container.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    name=new String(""String_Node_Str"");
  }
  Entity container=(Entity)getContainer();
  if ((container != null)) {
    Port another=container.getPort(name);
    if ((another != null) && (another != this)) {
      throw new NameDuplicationException(container,""String_Node_Str"" + name);
    }
  }
  super.setName(name);
}"
75652,"/** 
 * Return true if the current integration step is accurate. This is determined by asking all the step size control actors in the state transition schedule and output schedule.
 * @return True if the current step is accurate.
 */
public boolean isThisStepAccurate(){
  try {
    _debug(getName() + ""String_Node_Str"");
    if (!_isStateAccurate()) {
      _stateAcceptable=false;
      return false;
    }
 else     if (!_isOutputAccurate()) {
      _outputAcceptable=false;
      return false;
    }
 else {
      _stateAcceptable=true;
      _outputAcceptable=true;
      return true;
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Return true if the current integration step is accurate. This is determined by asking all the step size control actors in the state transition schedule and output schedule.
 * @return True if the current step is accurate.
 */
public boolean isThisStepAccurate(){
  try {
    _debug(getName() + ""String_Node_Str"");
    if (!_isStateAccurate()) {
      _stateAcceptable=false;
      return false;
    }
 else     if (!_isOutputAccurate()) {
      _stateAcceptable=true;
      _outputAcceptable=false;
      return false;
    }
 else {
      _stateAcceptable=true;
      _outputAcceptable=true;
      return true;
    }
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}"
75653,"/** 
 * Contruct a debug profile for an actor with the associated GraphController.
 */
public DebugProfile(BasicGraphController graphController){
  _graphController=graphController;
  _firingEventTypes=new HashSet();
}","/** 
 * Construct a debug profile for an actor with the associated GraphController.
 * @param graphController The GraphController.
 */
public DebugProfile(BasicGraphController graphController){
  _graphController=graphController;
  _firingEventTypes=new HashSet();
}"
75654,"/** 
 * Return a list of output ports connected to this port on the outside. NOTE: This method is not as useful as it might seem. In particular, it includes in the returned list output ports that are higher in the hierarchy to which this port is connected on the <i>inside</i>.  This can be confusing because such ports cannot send data to this port.  To get a list of the ports that can send data to this port, use the following sourcePortList() method.
 * @see ptolemy.kernel.ComponentPort#deepConnectedPorts
 * @return An enumeration of IOPort objects.
 */
public List deepConnectedOutPortList(){
  try {
    _workspace.getReadAccess();
    LinkedList result=new LinkedList();
    Iterator ports=deepConnectedPortList().iterator();
    int myDepth=depthInHierarchy();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      if (port.isOutput()) {
        result.addLast(port);
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Return a list of output ports connected to this port on the outside. NOTE: This method is not as useful as it might seem. In particular, it includes in the returned list output ports that are higher in the hierarchy to which this port is connected on the <i>inside</i>.  This can be confusing because such ports cannot send data to this port.  To get a list of the ports that can send data to this port, use the following sourcePortList() method.
 * @see ptolemy.kernel.ComponentPort#deepConnectedPorts
 * @return An enumeration of IOPort objects.
 */
public List deepConnectedOutPortList(){
  try {
    _workspace.getReadAccess();
    LinkedList result=new LinkedList();
    Iterator ports=deepConnectedPortList().iterator();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      if (port.isOutput()) {
        result.addLast(port);
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}"
75655,"/** 
 * Return a list of ports connected to this port on the outside that can send data to this port.  This includes output ports that are connected on the outside to this port, and input ports that are connected on the inside to this port.
 * @return A list of IOPort objects.
 */
public List sourcePortList(){
  try {
    _workspace.getReadAccess();
    Nameable container=getContainer();
    Director excDirector=((Actor)container).getExecutiveDirector();
    int depthOfDirector=excDirector.depthInHierarchy();
    LinkedList result=new LinkedList();
    Iterator ports=deepConnectedPortList().iterator();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      int depth=port.depthInHierarchy();
      if (port.isInput() && depth <= depthOfDirector) {
        result.addLast(port);
      }
 else       if (port.isOutput() && depth > depthOfDirector) {
        result.addLast(port);
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Return a list of ports connected to this port on the outside that can send data to this port.  This includes output ports that are connected on the outside to this port, and input ports that are connected on the inside to this port.
 * @return A list of IOPort objects.
 */
public List sourcePortList(){
  try {
    _workspace.getReadAccess();
    Nameable container=getContainer();
    Director excDirector=((Actor)container).getExecutiveDirector();
    int depthOfDirector=excDirector.depthInHierarchy();
    LinkedList result=new LinkedList();
    Iterator ports=deepConnectedPortList().iterator();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      int depth=((NamedObj)port.getContainer()).depthInHierarchy();
      if (port.isInput() && depth <= depthOfDirector) {
        result.addLast(port);
      }
 else       if (port.isOutput() && depth > depthOfDirector) {
        result.addLast(port);
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}"
75656,"/** 
 * Return a list of input ports connected to this port on the outside. NOTE: This method is not as useful as it might seem. In particular, it includes in the returned list input ports that are higher in the hierarchy to which this port is connected on the <i>inside</i>.  This can be confusing because such ports cannot receive data produced by this port.  To get a list of the ports that can receive data from this port, use the following sinkPortList() method:
 * @see ptolemy.kernel.ComponentPort#deepConnectedPortList
 * @return A list of IOPort objects.
 */
public List deepConnectedInPortList(){
  try {
    _workspace.getReadAccess();
    LinkedList result=new LinkedList();
    Iterator ports=deepConnectedPortList().iterator();
    int myDepth=depthInHierarchy();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      if (port.isInput()) {
        result.addLast(port);
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Return a list of input ports connected to this port on the outside. NOTE: This method is not as useful as it might seem. In particular, it includes in the returned list input ports that are higher in the hierarchy to which this port is connected on the <i>inside</i>.  This can be confusing because such ports cannot receive data produced by this port.  To get a list of the ports that can receive data from this port, use the following sinkPortList() method:
 * @see ptolemy.kernel.ComponentPort#deepConnectedPortList
 * @return A list of IOPort objects.
 */
public List deepConnectedInPortList(){
  try {
    _workspace.getReadAccess();
    LinkedList result=new LinkedList();
    Iterator ports=deepConnectedPortList().iterator();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      if (port.isInput()) {
        result.addLast(port);
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}"
75657,"/** 
 * Return a list of the ports connected to this port on the outside that can accept data from this port.  This include input ports that are connected on the outside to this port, and output ports that are connected on the inside to this one.
 * @return A list of IOPort objects.
 */
public List sinkPortList(){
  try {
    _workspace.getReadAccess();
    Nameable container=getContainer();
    Director excDirector=((Actor)container).getExecutiveDirector();
    int depthOfDirector=excDirector.depthInHierarchy();
    LinkedList result=new LinkedList();
    Iterator ports=deepConnectedPortList().iterator();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      int depth=port.depthInHierarchy();
      if (port.isInput() && depth >= depthOfDirector) {
        result.addLast(port);
      }
 else       if (port.isOutput() && depth < depthOfDirector) {
        result.addLast(port);
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Return a list of the ports connected to this port on the outside that can accept data from this port.  This include input ports that are connected on the outside to this port, and output ports that are connected on the inside to this one. If the port is an input port of an atomic actor, then return an empty list.
 * @return A list of IOPort objects.
 */
public List sinkPortList(){
  try {
    _workspace.getReadAccess();
    Nameable container=getContainer();
    Director excDirector=((Actor)container).getExecutiveDirector();
    int depthOfDirector=excDirector.depthInHierarchy();
    LinkedList result=new LinkedList();
    Iterator ports=deepConnectedPortList().iterator();
    while (ports.hasNext()) {
      IOPort port=(IOPort)ports.next();
      int depth=((NamedObj)port.getContainer()).depthInHierarchy();
      if (port.isInput() && depth >= depthOfDirector) {
        result.addLast(port);
      }
 else       if (port.isOutput() && depth < depthOfDirector) {
        result.addLast(port);
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}"
75658,"/** 
 * If the argument is the <i>initialState</i> parameters, check that it is a row vector; Other sanity checks, like whether a differential equation matches a state variable name, are done in preinitialize() and run time.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the numerator and thedenominator matrix is not a row vector.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == initialStates) {
    DoubleMatrixToken token=(DoubleMatrixToken)initialStates.getToken();
    if (token.getRowCount() != 1 || token.getColumnCount() < 1) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (getManager() != null && getManager().getState() == Manager.IDLE) {
      _requestInitialization();
    }
  }
 else   if (attribute instanceof Parameter) {
    super.attributeChanged(attribute);
    _requestInitialization();
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the argument is the <i>initialState</i> parameters, check that it is a row vector; Other sanity checks, like whether a differential equation matches a state variable name, are done in preinitialize() and run time.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the numerator and thedenominator matrix is not a row vector.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == initialStates) {
    DoubleMatrixToken token=(DoubleMatrixToken)initialStates.getToken();
    if (token == null) {
      return;
    }
    if (token.getRowCount() != 1 || token.getColumnCount() < 1) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (getManager() != null && getManager().getState() == Manager.IDLE) {
      _requestInitialization();
    }
  }
 else   if (attribute instanceof Parameter) {
    super.attributeChanged(attribute);
    _requestInitialization();
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75659,"public void visitMethodCallNode(ASTPtMethodCallNode node) throws IllegalActionException {
  int argCount=node.jjtGetNumChildren();
  _evaluateAllChildren(node);
  Class[] argTypes=new Class[argCount];
  Object[] argValues=new Object[argCount];
  for (int i=0; i < argCount; i++) {
    argValues[i]=(ptolemy.data.Token)node.jjtGetChild(i).getToken();
    argTypes[i]=argValues[i].getClass();
  }
  Object result=null;
  StringBuffer errorMessage=null;
  try {
    result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
  }
 catch (  IllegalActionException ex) {
    if (errorMessage == null)     errorMessage=new StringBuffer();
    errorMessage.append(""String_Node_Str"" + ex.toString());
  }
  ;
  if (result == null) {
    boolean anyArray=false;
    for (int i=0; i < argCount; i++) {
      ptolemy.data.Token child=(ptolemy.data.Token)argValues[i];
      if (child instanceof ArrayToken) {
        anyArray=true;
        argValues[i]=((ArrayToken)child).arrayValue();
        argTypes[i]=argValues[i].getClass();
      }
    }
    if (anyArray) {
      try {
        result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
      }
 catch (      IllegalActionException ex) {
        if (errorMessage == null)         errorMessage=new StringBuffer();
        errorMessage.append(""String_Node_Str"" + ex.toString());
      }
    }
  }
  if (result == null) {
    for (int i=1; i < argCount; i++) {
      ptolemy.data.Token child=(ptolemy.data.Token)argValues[i];
      Object[] javaArg=ASTPtFunctionNode.convertTokenToJavaType(child);
      argValues[i]=javaArg[0];
      argTypes[i]=(Class)javaArg[1];
    }
    try {
      result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
    }
 catch (    IllegalActionException ex) {
      if (errorMessage == null)       errorMessage=new StringBuffer();
      errorMessage.append(""String_Node_Str"" + ex.toString());
    }
  }
  if (result == null && argValues[0] instanceof ArrayToken) {
    argValues[0]=((ArrayToken)argValues[0]).arrayValue();
    argTypes[0]=argValues[0].getClass();
    result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
  }
  if (result == null) {
    ptolemy.data.Token child=(ptolemy.data.Token)argValues[0];
    Object[] javaArg=ASTPtFunctionNode.convertTokenToJavaType(child);
    argValues[0]=javaArg[0];
    argTypes[0]=(Class)javaArg[1];
    result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
  }
  if (result != null) {
    ptolemy.data.Token retval=ASTPtFunctionNode.convertJavaTypeToToken(result);
    if (retval == null) {
      throw new IllegalActionException(""String_Node_Str"" + result.getClass().toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    node.setToken(retval);
    return;
  }
  if (errorMessage == null)   errorMessage=new StringBuffer();
  for (int i=1; i < argCount; i++) {
    if (i == 1) {
      errorMessage.append(argValues[i].toString());
    }
 else {
      errorMessage.append(""String_Node_Str"" + argValues[i].toString());
    }
  }
  throw new IllegalActionException(""String_Node_Str"" + node.getMethodName() + ""String_Node_Str""+ errorMessage+ ""String_Node_Str"");
}","public void visitMethodCallNode(ASTPtMethodCallNode node) throws IllegalActionException {
  int argCount=node.jjtGetNumChildren();
  _evaluateAllChildren(node);
  Class[] argTypes=new Class[argCount];
  Object[] argValues=new Object[argCount];
  for (int i=0; i < argCount; i++) {
    argValues[i]=(ptolemy.data.Token)node.jjtGetChild(i).getToken();
    argTypes[i]=argValues[i].getClass();
  }
  Object result=null;
  StringBuffer errorMessage=null;
  try {
    result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
  }
 catch (  IllegalActionException ex) {
    if (errorMessage == null)     errorMessage=new StringBuffer();
    errorMessage.append(""String_Node_Str"" + ex.toString());
  }
  ;
  if (result == null) {
    boolean anyArray=false;
    for (int i=0; i < argCount; i++) {
      ptolemy.data.Token child=(ptolemy.data.Token)node.jjtGetChild(i).getToken();
      if (child instanceof ArrayToken) {
        anyArray=true;
        argValues[i]=((ArrayToken)child).arrayValue();
        argTypes[i]=argValues[i].getClass();
      }
    }
    if (anyArray) {
      try {
        result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
      }
 catch (      IllegalActionException ex) {
        if (errorMessage == null)         errorMessage=new StringBuffer();
        errorMessage.append(""String_Node_Str"" + ex.toString());
      }
    }
  }
  if (result == null) {
    argValues[0]=(ptolemy.data.Token)node.jjtGetChild(0).getToken();
    argTypes[0]=argValues[0].getClass();
    for (int i=1; i < argCount; i++) {
      ptolemy.data.Token child=(ptolemy.data.Token)node.jjtGetChild(i).getToken();
      Object[] javaArg=ASTPtFunctionNode.convertTokenToJavaType(child);
      argValues[i]=javaArg[0];
      argTypes[i]=(Class)javaArg[1];
    }
    try {
      result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
    }
 catch (    IllegalActionException ex) {
      if (errorMessage == null)       errorMessage=new StringBuffer();
      errorMessage.append(""String_Node_Str"" + ex.toString());
    }
  }
  if (result == null && argValues[0] instanceof ArrayToken) {
    argValues[0]=((ArrayToken)argValues[0]).arrayValue();
    argTypes[0]=argValues[0].getClass();
    result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
  }
  if (result == null) {
    ptolemy.data.Token child=(ptolemy.data.Token)node.jjtGetChild(0).getToken();
    Object[] javaArg=ASTPtFunctionNode.convertTokenToJavaType(child);
    argValues[0]=javaArg[0];
    argTypes[0]=(Class)javaArg[1];
    result=CachedMethod.findAndRunMethod(node.getMethodName(),argTypes,argValues,CachedMethod.METHOD);
  }
  if (result != null) {
    ptolemy.data.Token retval=ASTPtFunctionNode.convertJavaTypeToToken(result);
    if (retval == null) {
      throw new IllegalActionException(""String_Node_Str"" + result.getClass().toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    node.setToken(retval);
    return;
  }
  if (errorMessage == null)   errorMessage=new StringBuffer();
  for (int i=1; i < argCount; i++) {
    if (i == 1) {
      errorMessage.append(argValues[i].toString());
    }
 else {
      errorMessage.append(""String_Node_Str"" + argValues[i].toString());
    }
  }
  throw new IllegalActionException(""String_Node_Str"" + node.getMethodName() + ""String_Node_Str""+ errorMessage+ ""String_Node_Str"");
}"
75660,"/** 
 * Specify the container NamedObj, adding this attribute to the list of attributes in the container.  Notify parameters that depends on any parameter of this attribute about the change in scope.  If the container already contains an attribute with the same name, then throw an exception and do not make any changes.  Similarly, if the container is not in the same workspace as this attribute, throw an exception. If this attribute is already contained by the NamedObj, do nothing. This method is write-synchronized on the workspace and increments its version number.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 */
public void setContainer(NamedObj container) throws IllegalActionException, NameDuplicationException {
  Nameable oldContainer=getContainer();
  super.setContainer(container);
  if (oldContainer != container) {
    Iterator vars=attributeList(Variable.class).iterator();
    while (vars.hasNext()) {
      Variable var=(Variable)vars.next();
      var._notifyScopeChange();
    }
  }
}","/** 
 * Specify the container NamedObj, adding this attribute to the list of attributes in the container.  Notify parameters that depends on any parameter of this attribute about the change in scope.  If the container already contains an attribute with the same name, then throw an exception and do not make any changes.  Similarly, if the container is not in the same workspace as this attribute, throw an exception. If this attribute is already contained by the NamedObj, do nothing. This method is write-synchronized on the workspace and increments its version number.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 */
public void setContainer(NamedObj container) throws IllegalActionException, NameDuplicationException {
  Nameable oldContainer=getContainer();
  super.setContainer(container);
  if (oldContainer != container) {
    if (container != null) {
      _invalidateShadowedSettables((NamedObj)container.getContainer());
    }
    Iterator vars=attributeList(Variable.class).iterator();
    while (vars.hasNext()) {
      Variable var=(Variable)vars.next();
      var.validate();
    }
  }
}"
75661,"/** 
 * Create an entity controller associated with the specified graph controller.
 * @param controller The associated graph controller.
 * @param access The access level.
 */
public ActorController(GraphController controller,Access access){
  super(controller,access);
  if (access == FULL) {
    _portDialogFactory=new PortDialogFactory();
    _menuFactory.addMenuItemFactory(_portDialogFactory);
  }
  _menuFactory.addMenuItemFactory(new MenuActionFactory(new LookInsideAction()));
  _menuFactory.addMenuItemFactory(new MenuActionFactory(new ListenToActorAction()));
  if (access == FULL) {
    _breakpointDialogFactory=new BreakpointDialogFactory((BasicGraphController)getController());
    _menuFactory.addMenuItemFactory(_breakpointDialogFactory);
  }
  Filter portFilter=new Filter(){
    public boolean accept(    Object candidate){
      GraphModel model=getController().getGraphModel();
      if (candidate instanceof Port && model.getParent(candidate) instanceof Location) {
        return true;
      }
 else {
        return false;
      }
    }
  }
;
  GlobalLayout layout=new EntityLayout();
  controller.addGraphViewListener(new IncrementalLayoutListener(new IncrLayoutAdapter(layout),portFilter));
}","/** 
 * Create an entity controller associated with the specified graph controller.
 * @param controller The associated graph controller.
 * @param access The access level.
 */
public ActorController(GraphController controller,Access access){
  super(controller,access);
  if (access == FULL) {
    _portDialogFactory=new PortDialogFactory();
    _menuFactory.addMenuItemFactory(_portDialogFactory);
  }
  if (_configuration != null) {
    _menuFactory.addMenuItemFactory(new MenuActionFactory(new LookInsideAction()));
    _addedLookInsideAction=true;
  }
 else {
    _addedLookInsideAction=false;
  }
  _menuFactory.addMenuItemFactory(new MenuActionFactory(new ListenToActorAction()));
  if (access == FULL) {
    _breakpointDialogFactory=new BreakpointDialogFactory((BasicGraphController)getController());
    _menuFactory.addMenuItemFactory(_breakpointDialogFactory);
  }
  Filter portFilter=new Filter(){
    public boolean accept(    Object candidate){
      GraphModel model=getController().getGraphModel();
      if (candidate instanceof Port && model.getParent(candidate) instanceof Location) {
        return true;
      }
 else {
        return false;
      }
    }
  }
;
  GlobalLayout layout=new EntityLayout();
  controller.addGraphViewListener(new IncrementalLayoutListener(new IncrLayoutAdapter(layout),portFilter));
}"
75662,"/** 
 * Set the configuration.  This is used to open documentation files.
 * @param configuration The configuration.
 */
public void setConfiguration(Configuration configuration){
  super.setConfiguration(configuration);
  if (_portDialogFactory != null) {
    _portDialogFactory.setConfiguration(configuration);
  }
}","/** 
 * Set the configuration.  This is used to open documentation files.
 * @param configuration The configuration.
 */
public void setConfiguration(Configuration configuration){
  super.setConfiguration(configuration);
  if (_portDialogFactory != null) {
    _portDialogFactory.setConfiguration(configuration);
  }
  if (_configuration != null && !_addedLookInsideAction) {
    _menuFactory.addMenuItemFactory(new MenuActionFactory(new LookInsideAction()));
    _addedLookInsideAction=true;
  }
}"
75663,"/** 
 * Report an error, with an associated object and a descriptive message, for an unexpected code generation situation. The resulting message is pushed onto the top of the code stack.
 * @param object The associated object.
 * @param message The descriptive message.
 */
protected void _unexpectedCase(Object object,String message){
  _push(""String_Node_Str"" + object.getClass().getName() + ""String_Node_Str"");
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + message + ""String_Node_Str""+ object.getClass().getName());
}","/** 
 * Report an error, with an associated object and a descriptive message, for an unexpected code generation situation. The resulting message is pushed onto the top of the code stack.
 * @param object The associated object.
 * @param message The descriptive message.
 */
protected void _unexpectedCase(Object object,String message){
  _push(""String_Node_Str"" + object.getClass().getName() + ""String_Node_Str"");
}"
75664,"public void defaultCase(Object obj){
  if (obj instanceof Stmt) {
    _push(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
  }
 else   if (obj instanceof Expr) {
    _push(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
  }
 else {
    _push(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
}","public void defaultCase(Object obj){
  if (obj instanceof Stmt) {
    _push(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
  }
 else   if (obj instanceof Expr) {
    _push(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
  }
 else {
    _push(""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
  }
}"
75665,"/** 
 * Generate code for a method.
 * @param method The method.
 * @return The code.
 */
private String _generateMethod(SootMethod method){
  byte indentLevel;
  if (method.isConcrete() && !(method.isNative())) {
    StringBuffer code=new StringBuffer();
    String description=""String_Node_Str"" + method.getSubSignature();
    code.append(_comment(description));
    JimpleBody body=(JimpleBody)(method.retrieveActiveBody());
    CSwitch visitor=new CSwitch(_context);
    Type returnType=method.getReturnType();
    visitor.returnType=returnType;
    code.append(CNames.typeNameOf(returnType));
    _updateRequiredTypes(returnType);
    code.append(""String_Node_Str"");
    code.append(CNames.functionNameOf(method));
    code.append(""String_Node_Str"");
    int parameterIndex;
    int parameterCount=0;
    String thisLocalName=null;
    HashSet parameterAndThisLocals=new HashSet();
    if (!method.isStatic()) {
      parameterAndThisLocals.add(body.getThisLocal());
      thisLocalName=CNames.localNameOf(body.getThisLocal());
      code.append(CNames.instanceNameOf(method.getDeclaringClass()) + ""String_Node_Str"" + thisLocalName);
      parameterCount++;
    }
    for (parameterIndex=0; parameterIndex < method.getParameterCount(); parameterIndex++) {
      if (parameterCount++ > 0)       code.append(""String_Node_Str"");
      Local local=body.getParameterLocal(parameterIndex);
      parameterAndThisLocals.add(local);
      Type parameterType=local.getType();
      code.append(CNames.typeNameOf(parameterType) + ""String_Node_Str"" + CNames.localNameOf(local));
      _updateRequiredTypes(parameterType);
    }
    code.append(""String_Node_Str"");
    Iterator locals=body.getLocals().iterator();
    while (locals.hasNext()) {
      Local nextLocal=(Local)(locals.next());
      if (!parameterAndThisLocals.contains(nextLocal)) {
        code.append(_indent(1));
        Type localType=nextLocal.getType();
        code.append(CNames.typeNameOf(localType));
        code.append(""String_Node_Str"" + CNames.localNameOf(nextLocal) + ""String_Node_Str"");
        _updateRequiredTypes(localType);
      }
    }
    ExceptionTracker tracker=new ExceptionTracker();
    tracker.init(body);
    Iterator units=body.getUnits().iterator();
    while (units.hasNext()) {
      Unit unit=(Unit)(units.next());
      Unit target=null;
      if (unit instanceof GotoStmt) {
        target=((GotoStmt)unit).getTarget();
      }
 else       if (unit instanceof IfStmt) {
        target=((IfStmt)unit).getTarget();
      }
 else       if (tracker.isHandlerUnit(unit)) {
        target=unit;
      }
      if (target != null) {
        visitor.addTarget(target);
      }
    }
    if (thisLocalName != null)     visitor.setThisLocalName(thisLocalName);
    units=body.getUnits().iterator();
    if (!_context.getSingleClassMode()) {
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(""String_Node_Str"" + _indent(1) + ""String_Node_Str"");
      if (tracker.trapsExist()) {
        code.append(_indent(1) + ""String_Node_Str"");
        code.append(_indent(1) + ""String_Node_Str"");
        code.append(_indent(1) + ""String_Node_Str"");
      }
      if (tracker.trapsExist()) {
        indentLevel=2;
      }
 else {
        indentLevel=1;
      }
    }
 else {
      indentLevel=1;
    }
    visitor.indentLevel=indentLevel;
    boolean handle_exceptions=tracker.trapsExist() && (!_context.getSingleClassMode());
    while (units.hasNext()) {
      Unit unit=(Unit)(units.next());
      if (visitor.isTarget(unit)) {
        code.append(visitor.getLabel(unit) + ""String_Node_Str"");
      }
      if (handle_exceptions && tracker.isBeginUnit(unit)) {
        tracker.beginUnitEncountered(unit);
        code.append(_indent(2) + ""String_Node_Str"" + tracker.getEpc()+ ""String_Node_Str"");
        code.append(_indent(2) + ""String_Node_Str"" + tracker.beginIndexOf(unit)+ ""String_Node_Str"");
      }
      unit.apply(visitor);
      StringBuffer newCode=visitor.getCode();
      if (newCode.length() > 0) {
        code.append(_indent(indentLevel)).append(newCode).append(""String_Node_Str"");
      }
      if (handle_exceptions && tracker.isEndUnit(unit)) {
        code.append(_indent(2) + ""String_Node_Str"" + tracker.endIndexOf(unit)+ ""String_Node_Str"");
        tracker.endUnitEncountered(unit);
        code.append(_indent(2) + ""String_Node_Str"" + tracker.getEpc()+ ""String_Node_Str"");
      }
      if (handle_exceptions && tracker.isHandlerUnit(unit)) {
        code.append(_indent(2) + ""String_Node_Str"" + tracker.handlerIndexOf(unit)+ ""String_Node_Str"");
      }
    }
    if (tracker.trapsExist()) {
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      code.append(""String_Node_Str"" + _indent(2) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      for (int i=0; i <= (tracker.getEpc() - 1); i++) {
        code.append(_indent(3) + ""String_Node_Str"" + (i)+ ""String_Node_Str"");
        if (tracker.getHandlerUnitList(i).size() > 0) {
          Iterator j=tracker.getTrapsForEpc(i).listIterator();
          code.append(_indent(4));
          while (j.hasNext()) {
            Trap currentTrap=(Trap)j.next();
            code.append(""String_Node_Str"" + currentTrap.getException() + ""String_Node_Str"");
            code.append(_indent(4) + ""String_Node_Str"");
            code.append(_indent(5) + ""String_Node_Str"" + visitor.getLabel(currentTrap.getHandlerUnit())+ ""String_Node_Str"");
            code.append(_indent(4) + ""String_Node_Str"");
            code.append(_indent(4) + ""String_Node_Str"");
          }
          code.append(""String_Node_Str"" + _indent(4) + ""String_Node_Str"");
          code.append(_indent(5) + ""String_Node_Str"");
          code.append(_indent(5) + ""String_Node_Str"" + ""String_Node_Str"");
          code.append(_indent(4) + ""String_Node_Str"");
        }
 else {
          code.append(_indent(4) + ""String_Node_Str"");
        }
      }
      code.append(_indent(3) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
    }
    code.append(""String_Node_Str"");
    code.append(_comment(description));
    return code.toString();
  }
 else {
    return ""String_Node_Str"";
  }
}","/** 
 * Generate code for a method.
 * @param method The method.
 * @return The code.
 */
private String _generateMethod(SootMethod method){
  byte indentLevel;
  if (method.isConcrete() && !(method.isNative())) {
    StringBuffer code=new StringBuffer();
    String description=""String_Node_Str"" + method.getSubSignature();
    code.append(_comment(description));
    JimpleBody body=(JimpleBody)(method.retrieveActiveBody());
    CSwitch visitor=new CSwitch(_context);
    Type returnType=method.getReturnType();
    visitor.returnType=returnType;
    code.append(CNames.typeNameOf(returnType));
    _updateRequiredTypes(returnType);
    code.append(""String_Node_Str"");
    code.append(CNames.functionNameOf(method));
    code.append(""String_Node_Str"");
    int parameterIndex;
    int parameterCount=0;
    String thisLocalName=null;
    HashSet parameterAndThisLocals=new HashSet();
    if (!method.isStatic()) {
      parameterAndThisLocals.add(body.getThisLocal());
      thisLocalName=CNames.localNameOf(body.getThisLocal());
      code.append(CNames.instanceNameOf(method.getDeclaringClass()) + ""String_Node_Str"" + thisLocalName);
      parameterCount++;
    }
    for (parameterIndex=0; parameterIndex < method.getParameterCount(); parameterIndex++) {
      if (parameterCount++ > 0)       code.append(""String_Node_Str"");
      Local local=body.getParameterLocal(parameterIndex);
      parameterAndThisLocals.add(local);
      Type parameterType=local.getType();
      code.append(CNames.typeNameOf(parameterType) + ""String_Node_Str"" + CNames.localNameOf(local));
      _updateRequiredTypes(parameterType);
    }
    code.append(""String_Node_Str"");
    Iterator locals=body.getLocals().iterator();
    while (locals.hasNext()) {
      Local nextLocal=(Local)(locals.next());
      if (!parameterAndThisLocals.contains(nextLocal)) {
        code.append(_indent(1));
        Type localType=nextLocal.getType();
        code.append(CNames.typeNameOf(localType));
        code.append(""String_Node_Str"" + CNames.localNameOf(nextLocal) + ""String_Node_Str"");
        _updateRequiredTypes(localType);
      }
    }
    ExceptionTracker tracker=new ExceptionTracker();
    tracker.init(body);
    Iterator units=body.getUnits().iterator();
    while (units.hasNext()) {
      Unit unit=(Unit)(units.next());
      Unit target=null;
      if (unit instanceof GotoStmt) {
        target=((GotoStmt)unit).getTarget();
      }
 else       if (unit instanceof IfStmt) {
        target=((IfStmt)unit).getTarget();
      }
 else       if (tracker.isHandlerUnit(unit)) {
        target=unit;
      }
      if (target != null) {
        visitor.addTarget(target);
      }
    }
    if (thisLocalName != null)     visitor.setThisLocalName(thisLocalName);
    units=body.getUnits().iterator();
    if (!_context.getSingleClassMode()) {
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(""String_Node_Str"" + _indent(1) + ""String_Node_Str"");
      if (tracker.trapsExist()) {
        code.append(_indent(1) + ""String_Node_Str"");
        code.append(_indent(1) + ""String_Node_Str"");
        code.append(_indent(1) + ""String_Node_Str"");
      }
      if (tracker.trapsExist()) {
        indentLevel=2;
      }
 else {
        indentLevel=1;
      }
    }
 else {
      indentLevel=1;
    }
    visitor.indentLevel=indentLevel;
    boolean handle_exceptions=tracker.trapsExist() && (!_context.getSingleClassMode());
    while (units.hasNext()) {
      Unit unit=(Unit)(units.next());
      if (visitor.isTarget(unit)) {
        code.append(visitor.getLabel(unit) + ""String_Node_Str"");
      }
      if (handle_exceptions && tracker.isBeginUnit(unit)) {
        tracker.beginUnitEncountered(unit);
        code.append(_indent(2) + ""String_Node_Str"" + tracker.getEpc()+ ""String_Node_Str"");
        code.append(_indent(2) + ""String_Node_Str"" + tracker.beginIndexOf(unit)+ ""String_Node_Str"");
      }
      unit.apply(visitor);
      StringBuffer newCode=visitor.getCode();
      if (newCode.length() > 0) {
        code.append(_indent(indentLevel)).append(newCode).append(""String_Node_Str"");
      }
      if (handle_exceptions && tracker.isEndUnit(unit)) {
        code.append(_indent(2) + ""String_Node_Str"" + tracker.endIndexOf(unit)+ ""String_Node_Str"");
        tracker.endUnitEncountered(unit);
        code.append(_indent(2) + ""String_Node_Str"" + tracker.getEpc()+ ""String_Node_Str"");
      }
      if (handle_exceptions && tracker.isHandlerUnit(unit)) {
        code.append(_indent(2) + ""String_Node_Str"" + tracker.handlerIndexOf(unit)+ ""String_Node_Str"");
      }
    }
    if (tracker.trapsExist()) {
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"" + ""String_Node_Str"");
      code.append(""String_Node_Str"" + _indent(2) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      for (int i=0; i <= (tracker.getEpc() - 1); i++) {
        code.append(_indent(3) + ""String_Node_Str"" + (i)+ ""String_Node_Str"");
        if (tracker.getHandlerUnitList(i).size() > 0) {
          Iterator j=tracker.getTrapsForEpc(i).listIterator();
          code.append(_indent(4));
          while (j.hasNext()) {
            Trap currentTrap=(Trap)j.next();
            code.append(""String_Node_Str"" + currentTrap.getException() + ""String_Node_Str"");
            code.append(_indent(4) + ""String_Node_Str"");
            code.append(_indent(5) + ""String_Node_Str"" + visitor.getLabel(currentTrap.getHandlerUnit())+ ""String_Node_Str"");
            code.append(_indent(4) + ""String_Node_Str"");
            code.append(_indent(4) + ""String_Node_Str"");
          }
          code.append(""String_Node_Str"" + _indent(4) + ""String_Node_Str"");
          code.append(_indent(5) + ""String_Node_Str"");
          code.append(_indent(5) + ""String_Node_Str"" + ""String_Node_Str"");
          code.append(_indent(4) + ""String_Node_Str"");
        }
 else {
          code.append(_indent(4) + ""String_Node_Str"");
        }
      }
      code.append(_indent(3) + ""String_Node_Str"");
      code.append(_indent(2) + ""String_Node_Str"");
      code.append(_indent(1) + ""String_Node_Str"");
    }
    code.append(""String_Node_Str"");
    code.append(_comment(description));
    return code.toString();
  }
 else {
    return ""String_Node_Str"";
  }
}"
75666,"/** 
 * Generate C code for a class, including code (function declarations) for all of its methods, and for its initialization function.
 * @param source The class.
 * @return The code.
 */
public String generate(SootClass source){
  StringBuffer bodyCode=new StringBuffer();
  StringBuffer headerCode=new StringBuffer();
  _context.clear();
  source.setApplicationClass();
  _updateRequiredTypes(source.getType());
  _context.addIncludeFile(""String_Node_Str"");
  _context.addIncludeFile(""String_Node_Str"");
  _context.addIncludeFile(""String_Node_Str"");
  if (!_context.getSingleClassMode()) {
    _context.addIncludeFile(""String_Node_Str"");
  }
  int count=0;
  Iterator methods=source.getMethods().iterator();
  while (methods.hasNext()) {
    SootMethod method=(SootMethod)(methods.next());
    if (method.isPrivate()) {
      if (count++ == 0) {
        bodyCode.append(_comment(""String_Node_Str"" + ""String_Node_Str""));
      }
      if (method.isNative()) {
        bodyCode.append(""String_Node_Str"");
      }
      bodyCode.append(_generateMethodHeader(method) + ""String_Node_Str"");
    }
  }
  bodyCode.append(""String_Node_Str"");
  methods=source.getMethods().iterator();
  while (methods.hasNext()) {
    SootMethod thisMethod=(SootMethod)methods.next();
    String methodCode=_generateMethod(thisMethod);
    ;
    if (RequiredFileGenerator.isRequiredMethod(thisMethod)) {
      bodyCode.append(methodCode);
    }
    if (methodCode.length() != 0) {
      bodyCode.append(""String_Node_Str"");
    }
  }
  bodyCode.append(_comment(""String_Node_Str""));
  bodyCode.append(""String_Node_Str"" + CNames.classNameOf(source) + ""String_Node_Str""+ CNames.classStructureNameOf(source)+ ""String_Node_Str"");
  bodyCode.append(_generateClassInitialization(source));
  headerCode.append(_generateIncludeDirectives() + ""String_Node_Str"");
  headerCode.append(_declareConstants() + ""String_Node_Str"");
  headerCode.append(_generateArrayInstanceDeclarations());
  return (headerCode.append(bodyCode)).toString();
}","/** 
 * Generate C code for a class, including code (function declarations) for all of its methods, and for its initialization function.
 * @param source The class.
 * @return The code.
 */
public String generate(SootClass source){
  StringBuffer bodyCode=new StringBuffer();
  StringBuffer headerCode=new StringBuffer();
  _context.clear();
  headerCode.append(""String_Node_Str"" + ""String_Node_Str"");
  source.setApplicationClass();
  _updateRequiredTypes(source.getType());
  _context.addIncludeFile(""String_Node_Str"");
  _context.addIncludeFile(""String_Node_Str"");
  _context.addIncludeFile(""String_Node_Str"");
  if (!_context.getSingleClassMode()) {
    _context.addIncludeFile(""String_Node_Str"");
  }
  int count=0;
  Iterator methods=source.getMethods().iterator();
  while (methods.hasNext()) {
    SootMethod method=(SootMethod)(methods.next());
    if (method.isPrivate()) {
      if (count++ == 0) {
        bodyCode.append(_comment(""String_Node_Str"" + ""String_Node_Str""));
      }
      if (method.isNative()) {
        bodyCode.append(""String_Node_Str"");
      }
      bodyCode.append(_generateMethodHeader(method) + ""String_Node_Str"");
    }
  }
  bodyCode.append(""String_Node_Str"");
  methods=source.getMethods().iterator();
  while (methods.hasNext()) {
    SootMethod thisMethod=(SootMethod)methods.next();
    String methodCode=_generateMethod(thisMethod);
    ;
    if (RequiredFileGenerator.isRequiredMethod(thisMethod)) {
      bodyCode.append(methodCode);
    }
    if (methodCode.length() != 0) {
      bodyCode.append(""String_Node_Str"");
    }
  }
  bodyCode.append(_comment(""String_Node_Str""));
  bodyCode.append(""String_Node_Str"" + CNames.classNameOf(source) + ""String_Node_Str""+ CNames.classStructureNameOf(source)+ ""String_Node_Str"");
  bodyCode.append(_generateClassInitialization(source));
  headerCode.append(_generateIncludeDirectives() + ""String_Node_Str"");
  headerCode.append(_declareConstants() + ""String_Node_Str"");
  headerCode.append(_generateArrayInstanceDeclarations());
  return (headerCode.append(bodyCode)).toString();
}"
75667,"/** 
 * Generate code for a C header file that implements declarations associated with a class. Code for two struct-based type definitions is generated here. One type corresponds to the class itself (class variables, function pointers to methods, etc.), and the other type is for instances of the class.
 * @param source The class.
 * @return Header code for the class.
 */
public String generate(SootClass source){
  StringBuffer bodyCode=new StringBuffer();
  StringBuffer headerCode=new StringBuffer();
  StringBuffer footerCode=new StringBuffer();
  Iterator membersIter;
  String className=source.getName();
  String typeName=CNames.instanceNameOf(source);
  headerCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  headerCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  footerCode.append(""String_Node_Str"");
  headerCode.append(""String_Node_Str"");
  if (!_context.getSingleClassMode()) {
    headerCode.append(""String_Node_Str"");
  }
 else {
    headerCode.append(""String_Node_Str"");
  }
  bodyCode.append(_comment(""String_Node_Str"" + className));
  bodyCode.append(""String_Node_Str"" + CNames.classNameOf(source) + ""String_Node_Str"");
  bodyCode.append(_indent(1));
  if (source.hasSuperclass() && !_context.getSingleClassMode()) {
    bodyCode.append(_comment(""String_Node_Str""));
    bodyCode.append(_indent(1));
    bodyCode.append(CNames.classNameOf(source.getSuperclass()));
    bodyCode.append(""String_Node_Str"");
  }
 else {
    bodyCode.append(_comment(""String_Node_Str"" + ""String_Node_Str""));
    bodyCode.append(_indent(1));
    bodyCode.append(""String_Node_Str"");
  }
  bodyCode.append(CNames.superclassPointerName() + ""String_Node_Str"");
  bodyCode.append(_indent(1) + _comment(""String_Node_Str""));
  if (_context.getSingleClassMode()) {
    bodyCode.append(_indent(1) + _openComment);
  }
  bodyCode.append(_indent(1) + CNames.classNameOf(Scene.v().getSootClass(""String_Node_Str"")) + ""String_Node_Str"");
  if (_context.getSingleClassMode()) {
    bodyCode.append(_indent(1) + _closeComment);
  }
  bodyCode.append(""String_Node_Str"");
  if (_context.getSingleClassMode()) {
    _context.setDisableImports();
  }
  String inheritedMethods=_generateMethodPointers(MethodListGenerator.getInheritedMethods(source),""String_Node_Str"");
  _context.clearDisableImports();
  String introducedMethods=_generateMethodPointers(MethodListGenerator.getNewMethods(source),""String_Node_Str"") + _generateMethodPointers(MethodListGenerator.getConstructors(source),""String_Node_Str"") + _generateMethodPointers(MethodListGenerator.getPrivateMethods(source),""String_Node_Str"");
  if (((_context.getSingleClassMode()) || inheritedMethods.equals(""String_Node_Str"")) && introducedMethods.equals(""String_Node_Str"")) {
    bodyCode.append(_comment(""String_Node_Str""));
  }
 else {
    bodyCode.append(_indent(1) + ""String_Node_Str"");
    bodyCode.append(inheritedMethods + introducedMethods);
    bodyCode.append(""String_Node_Str"" + _indent(1) + ""String_Node_Str"");
  }
  String staticFields=_generateStaticFields(source);
  if (!staticFields.equals(""String_Node_Str"")) {
    bodyCode.append(""String_Node_Str"" + _indent(1) + ""String_Node_Str"");
    bodyCode.append(staticFields);
    bodyCode.append(""String_Node_Str"" + _indent(1) + ""String_Node_Str"");
  }
  bodyCode.append(""String_Node_Str"");
  bodyCode.append(_comment(""String_Node_Str"" + className));
  bodyCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + _indent(1) + CNames.classNameOf(source)+ ""String_Node_Str"");
  Iterator superClasses=_getSuperClasses(source).iterator();
  while (superClasses.hasNext()) {
    SootClass superClass=(SootClass)superClasses.next();
    bodyCode.append(_generateInheritedFields(source,superClass));
  }
  bodyCode.append(_generateFields(source));
  bodyCode.append(""String_Node_Str"");
  Iterator methods=source.getMethods().iterator();
  while (methods.hasNext()) {
    SootMethod method=(SootMethod)(methods.next());
    if (!method.isPrivate()) {
      bodyCode.append(""String_Node_Str"" + _comment(method.getSubSignature()));
      bodyCode.append(""String_Node_Str"" + _generateMethodHeader(method) + ""String_Node_Str"");
    }
  }
  bodyCode.append(""String_Node_Str"" + _comment(""String_Node_Str""));
  bodyCode.append(""String_Node_Str"" + CNames.classNameOf(source) + ""String_Node_Str""+ CNames.classStructureNameOf(source)+ ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + _comment(""String_Node_Str""));
  bodyCode.append(""String_Node_Str"" + CNames.initializerNameOf(source) + ""String_Node_Str""+ CNames.classNameOf(source)+ ""String_Node_Str"");
  _removeRequiredType(source);
  if (source.hasSuperclass()) {
    _updateRequiredTypes(source.getSuperclass().getType());
  }
  headerCode.append(""String_Node_Str"" + className.replace('.','/') + InterfaceFileGenerator.interfaceFileNameSuffix()+ ""String_Node_Str"");
  headerCode.append(_generateIncludeDirectives());
  headerCode.append(""String_Node_Str"" + _generateArrayInstanceDeclarations());
  headerCode.append(""String_Node_Str"");
  return (headerCode.append(bodyCode.append(footerCode))).toString();
}","/** 
 * Generate code for a C header file that implements declarations associated with a class. Code for two struct-based type definitions is generated here. One type corresponds to the class itself (class variables, function pointers to methods, etc.), and the other type is for instances of the class.
 * @param source The class.
 * @return Header code for the class.
 */
public String generate(SootClass source){
  StringBuffer bodyCode=new StringBuffer();
  StringBuffer headerCode=new StringBuffer();
  StringBuffer footerCode=new StringBuffer();
  Iterator membersIter;
  String className=source.getName();
  String typeName=CNames.instanceNameOf(source);
  headerCode.append(""String_Node_Str"" + ""String_Node_Str"");
  headerCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  headerCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  footerCode.append(""String_Node_Str"");
  headerCode.append(""String_Node_Str"");
  if (!_context.getSingleClassMode()) {
    headerCode.append(""String_Node_Str"");
  }
 else {
    headerCode.append(""String_Node_Str"");
  }
  bodyCode.append(_comment(""String_Node_Str"" + className));
  bodyCode.append(""String_Node_Str"" + CNames.classNameOf(source) + ""String_Node_Str"");
  bodyCode.append(_indent(1));
  if (source.hasSuperclass() && !_context.getSingleClassMode()) {
    bodyCode.append(_comment(""String_Node_Str""));
    bodyCode.append(_indent(1));
    bodyCode.append(CNames.classNameOf(source.getSuperclass()));
    bodyCode.append(""String_Node_Str"");
  }
 else {
    bodyCode.append(_comment(""String_Node_Str"" + ""String_Node_Str""));
    bodyCode.append(_indent(1));
    bodyCode.append(""String_Node_Str"");
  }
  bodyCode.append(CNames.superclassPointerName() + ""String_Node_Str"");
  bodyCode.append(_indent(1) + _comment(""String_Node_Str""));
  if (_context.getSingleClassMode()) {
    bodyCode.append(_indent(1) + _openComment);
  }
  bodyCode.append(_indent(1) + CNames.classNameOf(Scene.v().getSootClass(""String_Node_Str"")) + ""String_Node_Str"");
  if (_context.getSingleClassMode()) {
    bodyCode.append(_indent(1) + _closeComment);
  }
  bodyCode.append(""String_Node_Str"");
  if (_context.getSingleClassMode()) {
    _context.setDisableImports();
  }
  String inheritedMethods=_generateMethodPointers(MethodListGenerator.getInheritedMethods(source),""String_Node_Str"");
  _context.clearDisableImports();
  String introducedMethods=_generateMethodPointers(MethodListGenerator.getNewMethods(source),""String_Node_Str"") + _generateMethodPointers(MethodListGenerator.getConstructors(source),""String_Node_Str"") + _generateMethodPointers(MethodListGenerator.getPrivateMethods(source),""String_Node_Str"");
  if (((_context.getSingleClassMode()) || inheritedMethods.equals(""String_Node_Str"")) && introducedMethods.equals(""String_Node_Str"")) {
    bodyCode.append(_comment(""String_Node_Str""));
  }
 else {
    bodyCode.append(_indent(1) + ""String_Node_Str"");
    bodyCode.append(inheritedMethods + introducedMethods);
    bodyCode.append(""String_Node_Str"" + _indent(1) + ""String_Node_Str"");
  }
  String staticFields=_generateStaticFields(source);
  if (!staticFields.equals(""String_Node_Str"")) {
    bodyCode.append(""String_Node_Str"" + _indent(1) + ""String_Node_Str"");
    bodyCode.append(staticFields);
    bodyCode.append(""String_Node_Str"" + _indent(1) + ""String_Node_Str"");
  }
  bodyCode.append(""String_Node_Str"");
  bodyCode.append(_comment(""String_Node_Str"" + className));
  bodyCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + _indent(1) + CNames.classNameOf(source)+ ""String_Node_Str"");
  Iterator superClasses=_getSuperClasses(source).iterator();
  while (superClasses.hasNext()) {
    SootClass superClass=(SootClass)superClasses.next();
    bodyCode.append(_generateInheritedFields(source,superClass));
  }
  bodyCode.append(_generateFields(source));
  bodyCode.append(""String_Node_Str"");
  Iterator methods=source.getMethods().iterator();
  while (methods.hasNext()) {
    SootMethod method=(SootMethod)(methods.next());
    if (!method.isPrivate()) {
      bodyCode.append(""String_Node_Str"" + _comment(method.getSubSignature()));
      bodyCode.append(""String_Node_Str"" + _generateMethodHeader(method) + ""String_Node_Str"");
    }
  }
  bodyCode.append(""String_Node_Str"" + _comment(""String_Node_Str""));
  bodyCode.append(""String_Node_Str"" + CNames.classNameOf(source) + ""String_Node_Str""+ CNames.classStructureNameOf(source)+ ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + _comment(""String_Node_Str""));
  bodyCode.append(""String_Node_Str"" + CNames.initializerNameOf(source) + ""String_Node_Str""+ CNames.classNameOf(source)+ ""String_Node_Str"");
  _removeRequiredType(source);
  if (source.hasSuperclass()) {
    _updateRequiredTypes(source.getSuperclass().getType());
  }
  headerCode.append(""String_Node_Str"" + className.replace('.','/') + InterfaceFileGenerator.interfaceFileNameSuffix()+ ""String_Node_Str"");
  headerCode.append(_generateIncludeDirectives());
  headerCode.append(""String_Node_Str"" + _generateArrayInstanceDeclarations());
  headerCode.append(""String_Node_Str"");
  return (headerCode.append(bodyCode.append(footerCode))).toString();
}"
75668,"/** 
 * Generate code for an interface header file that implements declarations associated with a class.
 * @param source The class.
 * @return Interface header code for the class.
 */
public String generate(SootClass source){
  StringBuffer bodyCode=new StringBuffer();
  StringBuffer headerCode=new StringBuffer();
  StringBuffer footerCode=new StringBuffer();
  Iterator membersIter;
  String className=source.getName();
  String typeName=CNames.instanceNameOf(source);
  String objectName=CNames.classNameOf(source);
  headerCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  headerCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  footerCode.append(""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + typeName + ""String_Node_Str""+ typeName+ ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + className + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + objectName + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + className + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + objectName + ""String_Node_Str""+ objectName+ ""String_Node_Str"");
  return (headerCode.append(bodyCode.append(footerCode))).toString();
}","/** 
 * Generate code for an interface header file that implements declarations associated with a class.
 * @param source The class.
 * @return Interface header code for the class.
 */
public String generate(SootClass source){
  StringBuffer bodyCode=new StringBuffer();
  StringBuffer headerCode=new StringBuffer();
  StringBuffer footerCode=new StringBuffer();
  Iterator membersIter;
  String className=source.getName();
  String typeName=CNames.instanceNameOf(source);
  String objectName=CNames.classNameOf(source);
  headerCode.append(""String_Node_Str"" + ""String_Node_Str"");
  headerCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  headerCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  footerCode.append(""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + typeName + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + typeName + ""String_Node_Str""+ typeName+ ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + className + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + objectName + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + className + ""String_Node_Str"");
  bodyCode.append(""String_Node_Str"" + objectName + ""String_Node_Str""+ objectName+ ""String_Node_Str"");
  return (headerCode.append(bodyCode.append(footerCode))).toString();
}"
75669,"/** 
 * Given a class name, convert the specified class to C (.c and .h files).
 * @param classPath The classpath to use during the conversion.
 * @param className The name of the class to translate.
 * @param generateSingleClass Indicates whether (true) or not (false)""single class mode"" should be used during the conversion (see  {@link Context#getSingleClassMode()} for details).
 */
public static void convert(String classPath,String className,String compileMode,boolean verbose) throws IOException {
  boolean generateSingleClass=compileMode.equals(""String_Node_Str"");
  if (verbose) {
    System.out.println(""String_Node_Str"" + classPath);
    System.out.println(""String_Node_Str"" + generateSingleClass);
  }
  Scene.v().reset();
  Scene.v().setSootClassPath(classPath);
  Scene.v().loadClassAndSupport(className);
  RequiredFileGenerator RFG=new RequiredFileGenerator();
  if (!generateSingleClass) {
    RFG.init(classPath,className);
  }
  HeaderFileGenerator hGenerator=new HeaderFileGenerator();
  CodeFileGenerator cGenerator=new CodeFileGenerator();
  InterfaceFileGenerator iGenerator=new InterfaceFileGenerator();
  if (generateSingleClass) {
    cGenerator.setSingleClassMode();
    hGenerator.setSingleClassMode();
  }
  SootClass sootClass=Scene.v().getSootClass(className);
  CNames.setup();
  String code=iGenerator.generate(sootClass);
  FileHandler.write(className + InterfaceFileGenerator.interfaceFileNameSuffix(),code);
  code=hGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  code=cGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  if (!generateSingleClass) {
    RFG.generateTransitiveClosureOf(classPath,className,compileMode,verbose);
    MakeFileGenerator.generateMakeFile(classPath,className,RFG.getRequiredClasses(classPath,className));
  }
}","/** 
 * Given a class name, convert the specified class to C (.c and .h files).
 * @param classPath The classpath to use during the conversion.
 * @param className The name of the class to translate.
 * @param generateSingleClass Indicates whether (true) or not (false)""single class mode"" should be used during the conversion (see  {@link Context#getSingleClassMode()} for details).
 */
public static void convert(String classPath,String className,String compileMode,boolean verbose) throws IOException {
  boolean generateSingleClass=compileMode.equals(""String_Node_Str"");
  if (verbose) {
    System.out.println(""String_Node_Str"" + classPath);
    System.out.println(""String_Node_Str"" + generateSingleClass);
  }
  Scene.v().reset();
  Scene.v().setSootClassPath(classPath);
  Scene.v().loadClassAndSupport(className);
  RequiredFileGenerator RFG=new RequiredFileGenerator();
  if (!generateSingleClass) {
    RFG.init(classPath,className);
  }
  HeaderFileGenerator hGenerator=new HeaderFileGenerator();
  CodeFileGenerator cGenerator=new CodeFileGenerator();
  InterfaceFileGenerator iGenerator=new InterfaceFileGenerator();
  MainFileGenerator mGenerator=new MainFileGenerator();
  if (generateSingleClass) {
    cGenerator.setSingleClassMode();
    hGenerator.setSingleClassMode();
  }
  SootClass sootClass=Scene.v().getSootClass(className);
  CNames.setup();
  String code=iGenerator.generate(sootClass);
  FileHandler.write(className + InterfaceFileGenerator.interfaceFileNameSuffix(),code);
  code=hGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  code=cGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  if (!generateSingleClass) {
    RFG.generateTransitiveClosureOf(classPath,className,compileMode,verbose);
    MakeFileGenerator.generateMakeFile(classPath,className);
    code=mGenerator.generate(sootClass);
    FileHandler.write(className + ""String_Node_Str"",code);
  }
}"
75670,"/** 
 * Create the MakeFile.
 * @param classPath The classPath.
 * @param className The class for which the Makefile is to be generated.The makefile will have the name <i>className</i>.make.
 */
public static void generateMakeFile(String classPath,String className,Collection requiredClasses){
  StringBuffer code=new StringBuffer();
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + System.getProperty(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  Iterator i=requiredClasses.iterator();
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  while (i.hasNext()) {
    String name=_classNameToMakeFileName(((SootClass)i.next()).getName());
    code.append(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + InterfaceFileGenerator.interfaceFileNameSuffix() + ""String_Node_Str"");
  code.append(className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  FileHandler.write(className + ""String_Node_Str"",code.toString());
}","/** 
 * Create the MakeFile.
 * @param classPath The classPath.
 * @param className The class for which the Makefile is to be generated.The makefile will have the name <i>className</i>.make.
 */
public static void generateMakeFile(String classPath,String className){
  StringBuffer code=new StringBuffer();
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + System.getProperty(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
  Iterator i=RequiredFileGenerator.getRequiredClasses(classPath,className).iterator();
  while (i.hasNext()) {
    String name=_classNameToMakeFileName(((SootClass)i.next()).getName());
    code.append(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + InterfaceFileGenerator.interfaceFileNameSuffix() + ""String_Node_Str"");
  code.append(className + ""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + className + ""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"");
  code.append(""String_Node_Str"" + ""String_Node_Str"");
  FileHandler.write(className + ""String_Node_Str"",code.toString());
}"
75671,"private void _relationsAndLinks() throws IllegalActionException {
  try {
    if (_subAgents.size() == 0) {
      if (_transitions.size() == 0) {
        Integrator integrator=new Integrator(_container,""String_Node_Str"");
        Expression expression=new Expression(_container,""String_Node_Str"");
        expression.expression.setExpression(_expression);
        TypedIOPort expressionOutput=expression.output;
        TypedIOPort integratorInput=integrator.input;
        if (getInputs().size() == 0) {
          TypeAttribute ta=new TypeAttribute(expressionOutput,""String_Node_Str"");
          ta.setExpression(""String_Node_Str"");
        }
        Parameter signalType;
        TypedIORelation relation0=new TypedIORelation(_container,""String_Node_Str"");
        expressionOutput.link(relation0);
        integratorInput.link(relation0);
        integrator.initialState.setExpression(_initialState);
        ListIterator exprInputs=_expressionInputs.listIterator();
        while (exprInputs.hasNext()) {
          String inputPortName=(String)exprInputs.next();
          TypedIOPort expressionInput=new TypedIOPort(expression,inputPortName,true,false);
          if (_container instanceof Refinement) {
            signalType=new Parameter(expressionInput,""String_Node_Str"",new StringToken(""String_Node_Str""));
          }
        }
        if (_assertion != ""String_Node_Str"") {
          Assertion assertion=new Assertion(_container,""String_Node_Str"");
          assertion.assertion.setExpression(_assertion);
          ListIterator asserInputs=_assertionInputs.listIterator();
          while (asserInputs.hasNext()) {
            String inputPortName=(String)asserInputs.next();
            TypedIOPort expressionInput=new TypedIOPort(assertion,inputPortName,true,false);
            if (_container instanceof Refinement) {
              signalType=new Parameter(expressionInput,""String_Node_Str"",new StringToken(""String_Node_Str""));
            }
          }
        }
        ListIterator outputs=getOutputs().listIterator();
        if (getOutputs().size() > 1)         throw new IllegalActionException(""String_Node_Str"");
        while (outputs.hasNext()) {
          String outputStr=(String)outputs.next();
          TypedIOPort containerOutput=new TypedIOPort(_container,outputStr,false,true);
          TypedIORelation relation1=new TypedIORelation(_container,""String_Node_Str"");
          TypedIOPort integratorOutput=integrator.output;
          integratorOutput.link(relation1);
          containerOutput.link(relation1);
        }
        ListIterator inputs=getInputs().listIterator();
        while (inputs.hasNext()) {
          String inputStr=(String)inputs.next();
          TypedIOPort _containerInput=new TypedIOPort(_container,inputStr,true,false);
          TypedIOPort expressionInput=new TypedIOPort(expression,inputStr,true,false);
          if (_container instanceof Refinement) {
            signalType=new Parameter(expressionInput,""String_Node_Str"",new StringToken(""String_Node_Str""));
          }
        }
      }
 else {
        FSMActor controller=((FSMDirector)_container.getDirector()).getController();
        ListIterator transitions=_transitions.listIterator();
        int transitionIndex=0;
        while (transitions.hasNext()) {
          TxtTransition transition=(TxtTransition)transitions.next();
          System.out.println(""String_Node_Str"" + transition.getState() + ""String_Node_Str""+ transition.getNextState());
          try {
            State initState=controller.getInitialState();
          }
 catch (          IllegalActionException e) {
            controller.initialStateName.setExpression(transition.getState());
          }
          State state=_getState(controller,transition.getState());
          State nextState=_getState(controller,transition.getNextState());
          if (state.getRefinement() == null) {
            Refinement refinement=new Refinement(_container,transition.getState());
          }
          if (nextState.getRefinement() == null) {
            Refinement refinement=new Refinement(_container,transition.getNextState());
          }
          state.refinementName.setExpression(transition.getState());
          nextState.refinementName.setExpression(transition.getNextState());
          Agent modeState=(Agent)_searchAgent(transition.getState() + ""String_Node_Str"",CharonProcessor.modesList);
          Agent referMode=(Agent)_searchAgent(transition.getState() + ""String_Node_Str"",_subModes);
          Refinement stateRefinement=(Refinement)state.getRefinement()[0];
          if (modeState != null && referMode != null) {
            ListIterator parameters=modeState.getParameters().listIterator();
            ListIterator referParas=referMode.getParameters().listIterator();
            while (parameters.hasNext()) {
              String parameter=(String)parameters.next();
              String referPara=(String)referParas.next();
              Parameter para=new Parameter(state,parameter);
              Parameter refinementPara=new Parameter(stateRefinement,parameter);
              para.setExpression(referPara);
              refinementPara.setExpression(referPara);
            }
            modeState.setName(transition.getState());
            modeState.addMode(modeState.getContent());
            modeState.constructor(stateRefinement);
          }
          Transition fsmTransition=new Transition(controller,transition.getState() + ""String_Node_Str"" + transition.getNextState());
          fsmTransition.guardExpression.setExpression(transition.getCondition());
          fsmTransition.reset.setExpression(""String_Node_Str"");
          fsmTransition.setActions.setExpression(transition.getNextState() + ""String_Node_Str"" + getOutputs().get(0));
          state.outgoingPort.link(fsmTransition);
          nextState.incomingPort.link(fsmTransition);
        }
        ListIterator outputs=getOutputs().listIterator();
        while (outputs.hasNext()) {
          String outputStr=(String)outputs.next();
          ModalPort _containerOutput=(ModalPort)_container.newPort(outputStr);
          _containerOutput.setOutput(true);
        }
        ListIterator inputs=getInputs().listIterator();
        while (inputs.hasNext()) {
          String inputStr=(String)inputs.next();
          ModalPort _containerInput=(ModalPort)_container.newPort(inputStr);
          _containerInput.setInput(true);
        }
      }
    }
 else {
      ListIterator outputs=getOutputs().listIterator();
      if (getOutputs().size() > 1)       throw new IllegalActionException(""String_Node_Str"");
      while (outputs.hasNext()) {
        String outputStr=(String)outputs.next();
        TypedIOPort _containerOutput=new TypedIOPort(_container,outputStr,false,true);
      }
      ListIterator inputs=getInputs().listIterator();
      while (inputs.hasNext()) {
        String inputStr=(String)inputs.next();
        TypedIOPort _containerInput=new TypedIOPort(_container,inputStr,true,false);
      }
      ListIterator agents=_subAgents.listIterator();
      while (agents.hasNext()) {
        Agent subAgent=(Agent)agents.next();
        Agent agent=(Agent)_searchAgent(subAgent.getName(),CharonProcessor.agentsList);
        agent.constructor(_container);
      }
    }
    System.out.println(""String_Node_Str"");
    int relationIndex=2;
    ListIterator entities=_container.entityList().listIterator();
    while (entities.hasNext()) {
      Actor actor=(Actor)entities.next();
      System.out.println(""String_Node_Str"" + ((Nameable)actor).getFullName());
      ListIterator inputs=actor.inputPortList().listIterator();
      while (inputs.hasNext()) {
        TypedIOPort input=(TypedIOPort)inputs.next();
        System.out.println(""String_Node_Str"" + input.getFullName());
        if (input.linkedRelationList().size() > 0)         continue;
        TypedIOPort source=_searchSource(input);
        TypedIORelation relation;
        if (source != null) {
          List relations;
          if (((NamedObj)source.getContainer()).depthInHierarchy() == ((NamedObj)input.getContainer()).depthInHierarchy()) {
            relations=source.linkedRelationList();
          }
 else {
            relations=source.insideRelationList();
          }
          System.out.println(""String_Node_Str"" + source.getFullName() + ""String_Node_Str""+ relations.size());
          if (relations.size() > 1) {
            throw new IllegalActionException(""String_Node_Str"");
          }
 else           if (relations.size() == 1) {
            relation=(TypedIORelation)relations.get(0);
          }
 else {
            relation=new TypedIORelation(_container,""String_Node_Str"" + relationIndex);
            relationIndex++;
            source.link(relation);
          }
          input.link(relation);
        }
      }
    }
    if (_container instanceof ModalModel) {
      ListIterator containerOutputs=_container.outputPortList().listIterator();
      while (containerOutputs.hasNext()) {
        TypedIOPort containerOutput=(TypedIOPort)containerOutputs.next();
        TypedIORelation containerOutputRelation=(TypedIORelation)containerOutput.insideRelationList().get(0);
        entities=_container.entityList().listIterator();
        while (entities.hasNext()) {
          Actor actor=(Actor)entities.next();
          if (!(actor instanceof ModalController)) {
            System.out.println(""String_Node_Str"" + ((Nameable)actor).getFullName());
            ListIterator outputs=actor.outputPortList().listIterator();
            while (outputs.hasNext()) {
              TypedIOPort output=(TypedIOPort)outputs.next();
              System.out.println(""String_Node_Str"" + output.getFullName());
              if (output.linkedRelationList().size() > 0) {
                ListIterator orelations=output.linkedRelationList().listIterator();
                while (orelations.hasNext()) {
                  TypedIORelation tir=(TypedIORelation)orelations.next();
                  System.out.println(tir.linkedSourcePortList());
                }
              }
 else {
                output.link(containerOutputRelation);
              }
            }
          }
        }
      }
    }
 else {
      ListIterator sinks=_container.outputPortList().listIterator();
      while (sinks.hasNext()) {
        TypedIOPort sink=(TypedIOPort)sinks.next();
        System.out.println(""String_Node_Str"" + sink.getFullName());
        TypedIOPort source=_searchSource(sink);
        TypedIORelation relation;
        if (source != null) {
          List relations=source.linkedRelationList();
          System.out.println(""String_Node_Str"" + source.getFullName() + ""String_Node_Str""+ relations.size());
          if (relations.size() > 1) {
            throw new IllegalActionException(""String_Node_Str"");
          }
 else           if (relations.size() == 1) {
            relation=(TypedIORelation)relations.get(0);
            sink.link(relation);
          }
 else {
            List myRelations=sink.insideRelationList();
            System.out.println(sink.getName() + ""String_Node_Str"" + myRelations.size());
            if (myRelations.size() > 1) {
              throw new IllegalActionException(""String_Node_Str"");
            }
 else             if (myRelations.size() == 1) {
              relation=(TypedIORelation)myRelations.get(0);
            }
 else {
              relation=new TypedIORelation(_container,""String_Node_Str"" + relationIndex);
              relationIndex++;
              sink.link(relation);
            }
            source.link(relation);
          }
          relations=sink.insideRelationList();
          System.out.println(""String_Node_Str"" + sink.getName() + ""String_Node_Str""+ relations.size());
          System.out.println(""String_Node_Str"" + relation.linkedPortList().size());
        }
      }
    }
  }
 catch (  NameDuplicationException e) {
    throw new IllegalActionException(e.getMessage());
  }
}","private void _relationsAndLinks() throws IllegalActionException {
  try {
    if (_subAgents.size() == 0) {
      if (_transitions.size() == 0) {
        Integrator integrator=new Integrator(_container,""String_Node_Str"");
        Expression expression=new Expression(_container,""String_Node_Str"");
        expression.expression.setExpression(_expression);
        TypedIOPort expressionOutput=expression.output;
        TypedIOPort integratorInput=integrator.input;
        if (getInputs().size() == 0) {
          TypeAttribute ta=new TypeAttribute(expressionOutput,""String_Node_Str"");
          ta.setExpression(""String_Node_Str"");
        }
        Parameter signalType;
        TypedIORelation relation0=new TypedIORelation(_container,""String_Node_Str"");
        expressionOutput.link(relation0);
        integratorInput.link(relation0);
        integrator.initialState.setExpression(_initialState);
        ListIterator exprInputs=_expressionInputs.listIterator();
        while (exprInputs.hasNext()) {
          String inputPortName=(String)exprInputs.next();
          TypedIOPort expressionInput=new TypedIOPort(expression,inputPortName,true,false);
          if (_container instanceof Refinement) {
            signalType=new Parameter(expressionInput,""String_Node_Str"",new StringToken(""String_Node_Str""));
          }
        }
        if (_assertion != ""String_Node_Str"") {
          Assertion assertion=new Assertion(_container,""String_Node_Str"");
          assertion.assertion.setExpression(_assertion);
          ListIterator asserInputs=_assertionInputs.listIterator();
          while (asserInputs.hasNext()) {
            String inputPortName=(String)asserInputs.next();
            TypedIOPort expressionInput=new TypedIOPort(assertion,inputPortName,true,false);
            if (_container instanceof Refinement) {
              signalType=new Parameter(expressionInput,""String_Node_Str"",new StringToken(""String_Node_Str""));
            }
          }
        }
        ListIterator outputs=getOutputs().listIterator();
        if (getOutputs().size() > 1)         throw new IllegalActionException(""String_Node_Str"");
        while (outputs.hasNext()) {
          String outputStr=(String)outputs.next();
          TypedIOPort containerOutput=new TypedIOPort(_container,outputStr,false,true);
          TypedIORelation relation1=new TypedIORelation(_container,""String_Node_Str"");
          TypedIOPort integratorOutput=integrator.output;
          integratorOutput.link(relation1);
          containerOutput.link(relation1);
        }
        ListIterator inputs=getInputs().listIterator();
        while (inputs.hasNext()) {
          String inputStr=(String)inputs.next();
          TypedIOPort _containerInput=new TypedIOPort(_container,inputStr,true,false);
          TypedIOPort expressionInput=new TypedIOPort(expression,inputStr,true,false);
          if (_container instanceof Refinement) {
            signalType=new Parameter(expressionInput,""String_Node_Str"",new StringToken(""String_Node_Str""));
          }
        }
      }
 else {
        FSMActor controller=((FSMDirector)_container.getDirector()).getController();
        ListIterator transitions=_transitions.listIterator();
        int transitionIndex=0;
        while (transitions.hasNext()) {
          TxtTransition transition=(TxtTransition)transitions.next();
          System.out.println(""String_Node_Str"" + transition.getState() + ""String_Node_Str""+ transition.getNextState());
          try {
            State initState=controller.getInitialState();
          }
 catch (          IllegalActionException e) {
            controller.initialStateName.setExpression(transition.getState());
          }
          State state=_getState(controller,transition.getState());
          State nextState=_getState(controller,transition.getNextState());
          Agent modeState=(Agent)_searchAgent(transition.getState() + ""String_Node_Str"",CharonProcessor.modesList);
          Agent referMode=(Agent)_searchAgent(transition.getState() + ""String_Node_Str"",_subModes);
          if (modeState != null && referMode != null) {
            if (state.getRefinement() == null) {
              Refinement refinement=new Refinement(_container,transition.getState());
            }
            if (nextState.getRefinement() == null) {
              Refinement refinement=new Refinement(_container,transition.getNextState());
            }
            state.refinementName.setExpression(transition.getState());
            nextState.refinementName.setExpression(transition.getNextState());
            Refinement stateRefinement=(Refinement)state.getRefinement()[0];
            ListIterator parameters=modeState.getParameters().listIterator();
            ListIterator referParas=referMode.getParameters().listIterator();
            while (parameters.hasNext()) {
              String parameter=(String)parameters.next();
              String referPara=(String)referParas.next();
              Parameter para=new Parameter(state,parameter);
              Parameter refinementPara=new Parameter(stateRefinement,parameter);
              para.setExpression(referPara);
              refinementPara.setExpression(referPara);
            }
            modeState.setName(transition.getState());
            modeState.addMode(modeState.getContent());
            modeState.constructor(stateRefinement);
          }
          Transition fsmTransition=new Transition(controller,transition.getState() + ""String_Node_Str"" + transition.getNextState());
          fsmTransition.guardExpression.setExpression(transition.getCondition());
          fsmTransition.reset.setExpression(""String_Node_Str"");
          if (modeState != null) {
            System.out.println(""String_Node_Str"" + transition.getState());
            fsmTransition.setActions.setExpression(transition.getNextState() + ""String_Node_Str"" + getOutputs().get(0));
          }
          state.outgoingPort.link(fsmTransition);
          nextState.incomingPort.link(fsmTransition);
        }
        ListIterator outputs=getOutputs().listIterator();
        while (outputs.hasNext()) {
          String outputStr=(String)outputs.next();
          ModalPort _containerOutput=(ModalPort)_container.newPort(outputStr);
          _containerOutput.setOutput(true);
        }
        ListIterator inputs=getInputs().listIterator();
        while (inputs.hasNext()) {
          String inputStr=(String)inputs.next();
          ModalPort _containerInput=(ModalPort)_container.newPort(inputStr);
          _containerInput.setInput(true);
        }
      }
    }
 else {
      ListIterator outputs=getOutputs().listIterator();
      if (getOutputs().size() > 1)       throw new IllegalActionException(""String_Node_Str"");
      while (outputs.hasNext()) {
        String outputStr=(String)outputs.next();
        TypedIOPort _containerOutput=new TypedIOPort(_container,outputStr,false,true);
      }
      ListIterator inputs=getInputs().listIterator();
      while (inputs.hasNext()) {
        String inputStr=(String)inputs.next();
        TypedIOPort _containerInput=new TypedIOPort(_container,inputStr,true,false);
      }
      ListIterator agents=_subAgents.listIterator();
      while (agents.hasNext()) {
        Agent subAgent=(Agent)agents.next();
        Agent agent=(Agent)_searchAgent(subAgent.getName(),CharonProcessor.agentsList);
        agent.constructor(_container);
      }
    }
    System.out.println(""String_Node_Str"");
    int relationIndex=2;
    ListIterator entities=_container.entityList().listIterator();
    while (entities.hasNext()) {
      Actor actor=(Actor)entities.next();
      System.out.println(""String_Node_Str"" + ((Nameable)actor).getFullName());
      ListIterator inputs=actor.inputPortList().listIterator();
      while (inputs.hasNext()) {
        TypedIOPort input=(TypedIOPort)inputs.next();
        System.out.println(""String_Node_Str"" + input.getFullName());
        if (input.linkedRelationList().size() > 0)         continue;
        TypedIOPort source=_searchSource(input);
        TypedIORelation relation;
        if (source != null) {
          List relations;
          if (((NamedObj)source.getContainer()).depthInHierarchy() == ((NamedObj)input.getContainer()).depthInHierarchy()) {
            relations=source.linkedRelationList();
          }
 else {
            relations=source.insideRelationList();
          }
          System.out.println(""String_Node_Str"" + source.getFullName() + ""String_Node_Str""+ relations.size());
          if (relations.size() > 1) {
            throw new IllegalActionException(""String_Node_Str"");
          }
 else           if (relations.size() == 1) {
            relation=(TypedIORelation)relations.get(0);
          }
 else {
            relation=new TypedIORelation(_container,""String_Node_Str"" + relationIndex);
            relationIndex++;
            source.link(relation);
          }
          input.link(relation);
        }
      }
    }
    if (_container instanceof ModalModel) {
      ListIterator containerOutputs=_container.outputPortList().listIterator();
      while (containerOutputs.hasNext()) {
        TypedIOPort containerOutput=(TypedIOPort)containerOutputs.next();
        TypedIORelation containerOutputRelation=(TypedIORelation)containerOutput.insideRelationList().get(0);
        entities=_container.entityList().listIterator();
        while (entities.hasNext()) {
          Actor actor=(Actor)entities.next();
          if (!(actor instanceof ModalController)) {
            System.out.println(""String_Node_Str"" + ((Nameable)actor).getFullName());
            ListIterator outputs=actor.outputPortList().listIterator();
            while (outputs.hasNext()) {
              TypedIOPort output=(TypedIOPort)outputs.next();
              System.out.println(""String_Node_Str"" + output.getFullName());
              if (output.linkedRelationList().size() > 0) {
                ListIterator orelations=output.linkedRelationList().listIterator();
                while (orelations.hasNext()) {
                  TypedIORelation tir=(TypedIORelation)orelations.next();
                  System.out.println(tir.linkedSourcePortList());
                }
              }
 else {
                output.link(containerOutputRelation);
              }
            }
          }
        }
      }
    }
 else {
      ListIterator sinks=_container.outputPortList().listIterator();
      while (sinks.hasNext()) {
        TypedIOPort sink=(TypedIOPort)sinks.next();
        System.out.println(""String_Node_Str"" + sink.getFullName());
        TypedIOPort source=_searchSource(sink);
        TypedIORelation relation;
        if (source != null) {
          List relations=source.linkedRelationList();
          System.out.println(""String_Node_Str"" + source.getFullName() + ""String_Node_Str""+ relations.size());
          if (relations.size() > 1) {
            throw new IllegalActionException(""String_Node_Str"");
          }
 else           if (relations.size() == 1) {
            relation=(TypedIORelation)relations.get(0);
            sink.link(relation);
          }
 else {
            List myRelations=sink.insideRelationList();
            System.out.println(sink.getName() + ""String_Node_Str"" + myRelations.size());
            if (myRelations.size() > 1) {
              throw new IllegalActionException(""String_Node_Str"");
            }
 else             if (myRelations.size() == 1) {
              relation=(TypedIORelation)myRelations.get(0);
            }
 else {
              relation=new TypedIORelation(_container,""String_Node_Str"" + relationIndex);
              relationIndex++;
              sink.link(relation);
            }
            source.link(relation);
          }
          relations=sink.insideRelationList();
          System.out.println(""String_Node_Str"" + sink.getName() + ""String_Node_Str""+ relations.size());
          System.out.println(""String_Node_Str"" + relation.linkedPortList().size());
        }
      }
    }
  }
 catch (  NameDuplicationException e) {
    throw new IllegalActionException(e.getMessage());
  }
}"
75672,"/** 
 * Evaluate the assertion. If the evaluation returns false, throw a run-time IllegalActionException.
 * @exception IllegalActionException If the evaluation of the assertiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _time.setToken(new DoubleToken(director.getCurrentTime()));
  Iterator inputPorts=inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)(inputPorts.next());
    if (port.getWidth() > 0) {
      if (port.hasToken(0)) {
        Token inputToken=port.get(0);
        Variable var=(Variable)(getAttribute(port.getName()));
        var.setToken(inputToken);
      }
    }
  }
  BooleanToken result=(BooleanToken)assertion.getToken();
  if (result.booleanValue()) {
    throw new IllegalActionException(this,""String_Node_Str"" + assertion.getExpression());
  }
}","/** 
 * Evaluate the assertion. If the evaluation returns false, throw a run-time IllegalActionException.
 * @exception IllegalActionException If the evaluation of the assertiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _time.setToken(new DoubleToken(director.getCurrentTime()));
  Iterator inputPorts=inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)(inputPorts.next());
    if (port.getWidth() > 0) {
      if (port.hasToken(0)) {
        Token inputToken=port.get(0);
        Variable var=(Variable)(getAttribute(port.getName()));
        var.setToken(inputToken);
      }
    }
  }
  BooleanToken result=(BooleanToken)assertion.getToken();
  if (!result.booleanValue()) {
    throw new IllegalActionException(this,""String_Node_Str"" + assertion.getExpression());
  }
}"
75673,"/** 
 * Reset all receivers to allow a new firing of the director.
 */
private void _resetAllReceivers(){
  _debug(""String_Node_Str"");
  _currentNumberOfKnownReceivers=0;
  Iterator receiverIterator=_receivers.iterator();
  while (receiverIterator.hasNext()) {
    ((SRReceiver)receiverIterator.next()).reset();
  }
}","/** 
 * Reset all receivers to allow a new firing of the director.
 */
private void _resetAllReceivers(){
  _debug(""String_Node_Str"");
  _currentNumberOfKnownReceivers=0;
  if (_receivers == null) {
    return;
  }
  Iterator receiverIterator=_receivers.iterator();
  while (receiverIterator.hasNext()) {
    ((SRReceiver)receiverIterator.next()).reset();
  }
}"
75674,"/** 
 * Configure the FIR filter with a specified number of taps, tap values, delay line storage, interpolation value, decimation value, and decimation phase.
 * @param numberOfTaps The number of taps.
 * @param taps The tap values.
 * @param data The storage to use for the delay line (this is neededdue to the limited support for arrays in the current version of the C code generator).
 * @param interpolation The interpolation value.
 * @param decimation The decimation value.
 * @param decimationPhase The decimation phase.
 */
public void initialize(float taps[],int numberOfTaps,float data[],int interpolation,int decimation,int decimationPhase){
  _taps=taps;
  _numberOfTaps=numberOfTaps;
  _data=data;
  _interpolation=interpolation;
  _decimation=decimation;
  _decimationPhase=decimationPhase;
  _phaseLength=(int)(numberOfTaps / _interpolation);
  if ((numberOfTaps % _interpolation) != 0) {
    _phaseLength++;
  }
  for (int i=0; i < _phaseLength; i++) {
    _data[i]=0;
  }
  _dataLength=_phaseLength;
}","/** 
 * Configure the FIR filter with a specified number of taps, tap values, delay line storage, interpolation value, decimation value, and decimation phase.
 * @param numberOfTaps The number of taps.
 * @param taps The tap values.
 * @param data The storage to use for the delay line (this is neededdue to the limited support for arrays in the current version of the C code generator).
 * @param interpolation The interpolation value.
 * @param decimation The decimation value.
 * @param decimationPhase The decimation phase.
 */
public void initialize(float taps[],int numberOfTaps,float data[],int interpolation,int decimation,int decimationPhase){
  _taps=taps;
  _numberOfTaps=numberOfTaps;
  _data=data;
  _interpolation=interpolation;
  _decimation=decimation;
  _decimationPhase=decimationPhase;
  _mostRecent=0;
  _phaseLength=(int)(numberOfTaps / _interpolation);
  if ((numberOfTaps % _interpolation) != 0) {
    _phaseLength++;
  }
  for (int i=0; i < _phaseLength; i++) {
    _data[i]=0;
  }
  _dataLength=_phaseLength;
}"
75675,"/** 
 * Get the token contained by this variable.  The type of the returned token is always that returned by getType().  Calling this method will trigger evaluation of the expression, if the value has been given by setExpression(). Notice the evaluation of the expression can trigger an exception if the expression is not valid, or if the result of the expression violates type constraints specified by setTypeEquals() or setTypeAtMost(), or if the result of the expression is null and there are other variables that depend on this one. The returned value will be null if neither an expression nor a token has been set, or either has been set to null.
 * @return The token contained by this variable converted to thetype of this variable, or null if there is none.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if the result of evaluation violates type constraints, or if the result of evaluation is null and there are variables that depend on this one.
 */
public ptolemy.data.Token getToken() throws IllegalActionException {
  if (_isTokenUnknown)   throw new UnknownResultException(this);
  if (_needsEvaluation || _currentExpression != null && _parseTreeVersion != workspace().getVersion())   _evaluate();
  return _token;
}","/** 
 * Get the token contained by this variable.  The type of the returned token is always that returned by getType().  Calling this method will trigger evaluation of the expression, if the value has been given by setExpression(). Notice the evaluation of the expression can trigger an exception if the expression is not valid, or if the result of the expression violates type constraints specified by setTypeEquals() or setTypeAtMost(), or if the result of the expression is null and there are other variables that depend on this one. The returned value will be null if neither an expression nor a token has been set, or either has been set to null.
 * @return The token contained by this variable converted to thetype of this variable, or null if there is none.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if the result of evaluation violates type constraints, or if the result of evaluation is null and there are variables that depend on this one.
 */
public ptolemy.data.Token getToken() throws IllegalActionException {
  if (_isTokenUnknown)   throw new UnknownResultException(this);
  if (_needsEvaluation)   _evaluate();
  return _token;
}"
75676,"/** 
 * Get the token contained by this base unit.  Calling this method will trigger evaluation of the expression, if the value has been given by setExpression(). Notice the evaluation of the expression can trigger an exception if the expression is not valid, or if the result of the expression violates type constraints specified by setTypeEquals() or setTypeAtMost(), or if the result of the expression is null and there are other variables that depend on this one. The returned value will be null if neither an expression nor a token has been set, or either has been set to null.
 * @return The token contained by this variable converted to thetype of this variable, or null if there is none.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if the result of evaluation violates type constraints, or if the result of evaluation is null and there are variables that depend on this one.
 */
public Token getToken() throws IllegalActionException {
  Token token=super.getToken();
  if (token != _token) {
    Iterator attributes=attributeList(UnitCategory.class).iterator();
    if (attributes.hasNext()) {
      Attribute category=(Attribute)attributes.next();
      int index=UnitSystem.getUnitCategoryIndex(category.getName());
      if (index >= 0) {
        ((ScalarToken)token).setUnitCategory(index);
      }
    }
    _token=token;
  }
  return _token;
}","/** 
 * Get the token contained by this base unit.  The token contains the unit information specified by the unit category property. Calling this method will trigger evaluation of the expression, if the value has been given by setExpression(). Notice the evaluation of the expression can trigger an exception if the expression is not valid, or if the result of the expression violates type constraints specified by setTypeEquals() or setTypeAtMost(), or if the result of the expression is null and there are other variables that depend on this one. The returned value will be null if neither an expression nor a token has been set, or either has been set to null.
 * @return The token contained by this variable converted to thetype of this variable, or null if there is none.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if the result of evaluation violates type constraints, or if the result of evaluation is null and there are variables that depend on this one.
 */
public Token getToken() throws IllegalActionException {
  Token token=super.getToken();
  if (token != _token) {
    Iterator attributes=attributeList(UnitCategory.class).iterator();
    if (attributes.hasNext()) {
      UnitCategory category=(UnitCategory)attributes.next();
      int index=UnitSystem.getUnitCategoryIndex(category);
      if (index >= 0) {
        ((ScalarToken)token).setUnitCategory(index);
      }
    }
    _token=token;
  }
  return _token;
}"
75677,"/** 
 * Construct a unit category property with the given name contained by the specified entity. The container argument must not be null, or a NullPointerException will be thrown.  This attribute will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container, or if the name contains a period.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public UnitCategory(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  UnitSystem.addUnitCategory(name,container.getName());
}","/** 
 * Construct a unit category property with the given name contained by the specified entity. The container argument must not be null, or a NullPointerException will be thrown.  This attribute will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container, or if the name contains a period.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public UnitCategory(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  UnitSystem.addUnitCategory(this);
}"
75678,"/** 
 * Return the index assigned to the specified unit category.
 * @param categoryName The name of the unit category.
 * @return The index assigned to the category.
 */
public static int getUnitCategoryIndex(String categoryName){
  Integer index=(Integer)_indexTable.get(categoryName);
  if (index == null) {
    return -1;
  }
 else {
    return index.intValue();
  }
}","/** 
 * Return the index assigned to the specified unit category.
 * @param category The unit category.
 * @return The index assigned to the category.
 */
public static int getUnitCategoryIndex(UnitCategory category){
  Integer index=(Integer)_indexTable.get(category);
  if (index == null) {
    return -1;
  }
 else {
    return index.intValue();
  }
}"
75679,"/** 
 * Record the specified unit category, and the name of its base unit. If the category is not already recorded, assign a unique index for the category.
 * @param categoryName The name of the unit category.
 * @param baseUnitName The name of the base unit of the category.
 */
public static void addUnitCategory(String categoryName,String baseUnitName){
  Integer index=(Integer)_indexTable.get(categoryName);
  if (index != null) {
    _baseNames[index.intValue()]=baseUnitName;
  }
 else {
    String[] oldNames=_baseNames;
    int length=oldNames.length;
    _baseNames=new String[length + 1];
    System.arraycopy(oldNames,0,_baseNames,0,length);
    index=new Integer(length);
    _indexTable.put(categoryName,index);
    _baseNames[length]=baseUnitName;
  }
}","/** 
 * Register the specified unit category. If the category is not already registered, assign a unique index for the category.
 * @param category The unit category to be registered.
 */
public static void addUnitCategory(UnitCategory category){
  Integer index=(Integer)_indexTable.get(category);
  if (index != null) {
    return;
  }
 else {
    index=new Integer(_categories);
    _indexTable.put(category,index);
    ++_categories;
    _categoryVector.add(category);
  }
}"
75680,"/** 
 * Return the name of the base unit of the specified category.
 * @param categoryIndex The index of the unit category.
 * @return The name of the base unit of the category.
 */
public static String getBaseUnitName(int categoryIndex){
  if (categoryIndex < 0 || categoryIndex > _baseNames.length - 1) {
    return null;
  }
 else {
    return _baseNames[categoryIndex];
  }
}","/** 
 * Return the name of the base unit of the specified category.
 * @param categoryIndex The index of the unit category.
 * @return The name of the base unit of the category.
 */
public static String getBaseUnitName(int categoryIndex){
  if (categoryIndex < 0 || categoryIndex >= _categories) {
    return ""String_Node_Str"";
  }
 else {
    UnitCategory category=(UnitCategory)_categoryVector.elementAt(categoryIndex);
    if (category != null) {
      return ((BaseUnit)category.getContainer()).getName();
    }
 else {
      return ""String_Node_Str"";
    }
  }
}"
75681,"/** 
 * Return true if the mode controller is ready to fire. If this model is not at the top level and the current time of this director lags behind that of the executive director, update the current time to that of the executive director. Record whether the refinement of the current state of the mode controller is ready to fire.
 * @exception IllegalActionException If there is no controller.FIXME: Changed by liuj, not yet reviewed.
 */
public boolean prefire() throws IllegalActionException {
  super.prefire();
  FSMActor ctrl=getController();
  _firstFire=true;
  return getController().prefire();
}","/** 
 * Return true if the mode controller is ready to fire. If this model is not at the top level and the current time of this director lags behind that of the executive director, update the current time to that of the executive director. Record whether the refinement of the current state of the mode controller is ready to fire.
 * @exception IllegalActionException If there is no controller.FIXME: Changed by liuj, not yet reviewed.
 */
public boolean prefire() throws IllegalActionException {
  CompositeActor actor=(CompositeActor)getContainer();
  Iterator outputPorts=actor.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    IOPort p=(IOPort)outputPorts.next();
    Receiver[][] insideReceivers=p.getInsideReceivers();
    if (insideReceivers == null)     continue;
    for (int i=0; i < insideReceivers.length; i++) {
      if (insideReceivers[i] == null)       continue;
      for (int j=0; j < insideReceivers[i].length; j++) {
        try {
          if (insideReceivers[i][j].hasToken()) {
            insideReceivers[i][j].get();
          }
        }
 catch (        NoTokenException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
    }
  }
  super.prefire();
  _firstFire=true;
  FSMActor ctrl=getController();
  return getController().prefire();
}"
75682,"/** 
 * Return all the sink nodes in this graph in the form of a collection. Each element in the collection is a   {@link Node}.
 * @return The sink nodes in this graph.
 * @see #sinkNodeCount()
 */
public Collection sinkNodes(){
  if (_sinkNodeListener.obsolete()) {
    _sinkNodes=new ArrayList();
    Iterator nodes=nodes().iterator();
    while (nodes.hasNext()) {
      Node node=(Node)nodes.next();
      if (inputEdgeCount(node) == 0) {
        _sinkNodes.add(node);
      }
    }
    _sinkNodeListener.registerComputation();
  }
  return Collections.unmodifiableList(_sinkNodes);
}","/** 
 * Return all the sink nodes in this graph in the form of a collection. Each element in the collection is a   {@link Node}.
 * @return The sink nodes in this graph.
 * @see #sinkNodeCount()
 */
public Collection sinkNodes(){
  if (_sinkNodeListener.obsolete()) {
    _sinkNodes=new ArrayList();
    Iterator nodes=nodes().iterator();
    while (nodes.hasNext()) {
      Node node=(Node)nodes.next();
      if (outputEdgeCount(node) == 0) {
        _sinkNodes.add(node);
      }
    }
    _sinkNodeListener.registerComputation();
  }
  return Collections.unmodifiableList(_sinkNodes);
}"
75683,"/** 
 * Update the state of the actor and schedule the next firing, if appropriate.
 * @exception IllegalActionException If the director throws it whenscheduling the next firing.
 */
public boolean postfire() throws IllegalActionException {
  _cycleStartTime=_tentativeCycleStartTime;
  _currentValue=_tentativeCurrentValue;
  _phase=_tentativePhase;
  _oldTrigger=_trigger;
  if (_tentativeNextFiringTime != Double.NEGATIVE_INFINITY) {
    getDirector().fireAt(this,_tentativeNextFiringTime);
  }
  return super.postfire();
}","/** 
 * Update the state of the actor and schedule the next firing, if appropriate.
 * @exception IllegalActionException If the director throws it whenscheduling the next firing.
 */
public boolean postfire() throws IllegalActionException {
  _cycleStartTime=_tentativeCycleStartTime;
  _currentValue=_tentativeCurrentValue;
  _phase=_tentativePhase;
  if (_tentativeNextFiringTime != Double.NEGATIVE_INFINITY) {
    getDirector().fireAt(this,_tentativeNextFiringTime);
  }
  return super.postfire();
}"
75684,"/** 
 * Fire on a rise in trigger, don't on a fall. Fire on equal consecutive values Perform initialization for clock cycle
 */
public boolean prefire() throws IllegalActionException {
  double currentTime=getDirector().getCurrentTime();
  System.out.println(""String_Node_Str"" + currentTime);
  if (trigger.hasToken(0)) {
    System.out.println(""String_Node_Str"");
    _trigger=((BooleanToken)trigger.get(0)).booleanValue();
  }
  System.out.println(""String_Node_Str"" + _trigger);
  if (!_oldTrigger && _trigger) {
    _tentativeCycleStartTime=currentTime;
    _tentativePhase=0;
    _tentativeCurrentValue=_getValue(_phase);
    System.out.println(""String_Node_Str"");
    return super.prefire();
  }
 else   if (_oldTrigger && !_trigger) {
    _oldTrigger=_trigger;
    System.out.println(""String_Node_Str"");
    return false;
  }
 else {
    System.out.println(""String_Node_Str"");
    return super.prefire();
  }
}","public boolean prefire() throws IllegalActionException {
  return super.prefire();
}"
75685,"/** 
 * Output the current value of the clock.
 * @exception IllegalActionException If the <i>values</i> and<i>offsets</i> parameters do not have the same length, or if the value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  double currentTime=getDirector().getCurrentTime();
  System.out.println(""String_Node_Str"" + currentTime);
  if (_trigger == false) {
    System.out.println(""String_Node_Str"" + currentTime);
    _tentativeCycleStartTime=_cycleStartTime;
    _tentativePhase=_phase;
    _tentativeCurrentValue=_currentValue;
  }
  while (_tentativeCycleStartTime + periodValue <= currentTime) {
    _tentativeCycleStartTime+=periodValue;
  }
  _tentativeNextFiringTime=Double.NEGATIVE_INFINITY;
  ArrayToken val=(ArrayToken)(values.getToken());
  if (_offsets.length != val.length()) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _tentativeCurrentValue=_getValue(_tentativePhase);
  _tentativePhase++;
  if (_tentativePhase >= _offsets.length) {
    _tentativePhase=0;
    _tentativeCycleStartTime+=periodValue;
  }
  if (_offsets[_tentativePhase] >= periodValue) {
    throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ _offsets[_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
  }
  _tentativeNextFiringTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
  System.out.println(""String_Node_Str"" + _tentativeCycleStartTime);
  System.out.println(""String_Node_Str"" + _tentativePhase);
  System.out.println(""String_Node_Str"" + _tentativeNextFiringTime);
  output.send(0,_tentativeCurrentValue);
  System.out.println(_tentativeCurrentValue);
}","/** 
 * Output the current value of the clock.
 * @exception IllegalActionException If the <i>values</i> and<i>offsets</i> parameters do not have the same length, or if the value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  double currentTime=getDirector().getCurrentTime();
  System.out.println(""String_Node_Str"" + currentTime);
  if (!_trigger) {
    if (trigger.hasToken(0)) {
      System.out.println(""String_Node_Str"");
      _trigger=((BooleanToken)trigger.get(0)).booleanValue();
      System.out.println(""String_Node_Str"" + _trigger);
      if (_trigger) {
        _tentativeCycleStartTime=currentTime;
        _tentativePhase=0;
        _tentativeCurrentValue=_getValue(_phase);
        System.out.println(""String_Node_Str"");
        _trigger=true;
      }
    }
  }
 else {
    System.out.println(""String_Node_Str"" + currentTime);
    _tentativeCycleStartTime=_cycleStartTime;
    _tentativePhase=_phase;
    _tentativeCurrentValue=_currentValue;
  }
  while (_tentativeCycleStartTime + periodValue <= currentTime) {
    _tentativeCycleStartTime+=periodValue;
  }
  _tentativeNextFiringTime=Double.NEGATIVE_INFINITY;
  ArrayToken val=(ArrayToken)(values.getToken());
  if (_offsets.length != val.length()) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _tentativeCurrentValue=_getValue(_tentativePhase);
  _tentativePhase++;
  if (_tentativePhase >= _offsets.length) {
    _tentativePhase=0;
    _tentativeCycleStartTime+=periodValue;
  }
  if (_offsets[_tentativePhase] >= periodValue) {
    throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ _offsets[_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
  }
  _tentativeNextFiringTime=_tentativeCycleStartTime + _offsets[_tentativePhase];
  System.out.println(""String_Node_Str"" + _tentativeCycleStartTime);
  System.out.println(""String_Node_Str"" + _tentativePhase);
  System.out.println(""String_Node_Str"" + _tentativeNextFiringTime);
  output.send(0,_tentativeCurrentValue);
  System.out.println(_tentativeCurrentValue);
}"
75686,"/** 
 * Initialize trigger and oldtriggger.
 */
public void initialize() throws IllegalActionException {
  _trigger=false;
  _oldTrigger=false;
  super.initialize();
}","/** 
 * Initialize trigger
 */
public void initialize() throws IllegalActionException {
  _trigger=false;
  super.initialize();
}"
75687,"/** 
 * Generate code for the composite agent.
 * @param CompositeActor The composite agent generated code from.
 * @return The composite agent code.
 */
private String _compositeAgentCode(CompositeActor actor) throws IllegalActionException {
  if (FSMDirector.class.isInstance(actor.getDirector())) {
    return _agentCode(actor);
  }
  LinkedList subAgents=_agents(actor);
  if (subAgents.size() == 0)   return _agentCode(actor);
  String compositeCodeString=""String_Node_Str"";
  String subAgentCode=""String_Node_Str"";
  String privateVariables=""String_Node_Str"";
  ListIterator subAgentsIterator=subAgents.listIterator();
  while (subAgentsIterator.hasNext()) {
    String subAgentConnectionInputs=""String_Node_Str"";
    String subAgentConnectionOutputs=""String_Node_Str"";
    CompositeActor subAgent=(CompositeActor)subAgentsIterator.next();
    subAgentCode+=""String_Node_Str"" + subAgent.getName().toLowerCase() + ""String_Node_Str""+ subAgent.getName()+ ""String_Node_Str"";
    if (actor.depthInHierarchy() == 0) {
      subAgentCode+=_agentParameterTokens((NamedObj)subAgent);
    }
 else {
      subAgentCode+=_agentParameters((NamedObj)subAgent,false);
    }
    subAgentCode+=""String_Node_Str"" + _endLine;
    ListIterator subAgentInputs=subAgent.inputPortList().listIterator();
    while (subAgentInputs.hasNext()) {
      TypedIOPort input=(TypedIOPort)subAgentInputs.next();
      LinkedList sourceList=shallowSourcePortList(input);
      ListIterator sources=sourceList.listIterator();
      boolean privateVariable=true;
      while (sources.hasNext()) {
        TypedIOPort source=(TypedIOPort)sources.next();
        if (source.depthInHierarchy() != input.depthInHierarchy()) {
          privateVariable=false;
        }
        if (!(source.getName().equals(input.getName()))) {
          if (subAgentConnectionOutputs == ""String_Node_Str"") {
            subAgentConnectionOutputs+=source.getName();
            subAgentConnectionInputs+=input.getName();
          }
 else {
            subAgentConnectionOutputs+=""String_Node_Str"" + source.getName();
            subAgentConnectionInputs+=""String_Node_Str"" + input.getName();
          }
        }
      }
      if (privateVariable) {
        if (privateVariables == ""String_Node_Str"") {
          privateVariables+=""String_Node_Str"" + input.getName();
        }
 else {
          privateVariables+=""String_Node_Str"" + input.getName();
        }
      }
    }
    if (subAgentConnectionInputs.length() != 0) {
      subAgentCode+=""String_Node_Str"" + subAgentConnectionInputs + ""String_Node_Str""+ subAgentConnectionOutputs+ ""String_Node_Str""+ _endLine;
    }
    compositeCodeString+=_compositeAgentCode(subAgent);
  }
  compositeCodeString+=""String_Node_Str"";
  String parameterString=""String_Node_Str"";
  String inputString=""String_Node_Str"";
  String outputString=""String_Node_Str"";
  String initString=""String_Node_Str"";
  String modeString=""String_Node_Str"";
  String modeParameterString=""String_Node_Str"";
  LinkedList parameterList=(LinkedList)actor.attributeList(Parameter.class);
  int parameterNumber=parameterList.size();
  ListIterator parameters=parameterList.listIterator();
  _inPorts=actor.inputPortList().iterator();
  while (_inPorts.hasNext()) {
    if (inputString == ""String_Node_Str"") {
      inputString+=""String_Node_Str"" + ((NamedObj)_inPorts.next()).getName();
    }
 else {
      inputString+=""String_Node_Str"" + ((NamedObj)_inPorts.next()).getName();
    }
  }
  if (inputString != ""String_Node_Str"")   inputString+=""String_Node_Str"";
  _outPorts=actor.outputPortList().iterator();
  if (_outPorts.hasNext()) {
    String outportName=((NamedObj)_outPorts.next()).getName();
    if (outputString == ""String_Node_Str"") {
      outputString+=""String_Node_Str"" + outportName;
    }
 else {
      outputString+=""String_Node_Str"" + outportName;
    }
  }
  if (privateVariables.length() != 0)   privateVariables+=""String_Node_Str"";
  compositeCodeString+=""String_Node_Str"" + actor.getName() + ""String_Node_Str"";
  if (actor.depthInHierarchy() != 0)   compositeCodeString+=_agentParameters((NamedObj)actor,true);
  compositeCodeString+=""String_Node_Str"" + _endLine + ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ outputString+ _endLine+ ""String_Node_Str""+ inputString+ _endLine+ ""String_Node_Str""+ privateVariables+ _endLine+ subAgentCode+ _endLine+ ""String_Node_Str""+ _endLine;
  return compositeCodeString;
}","/** 
 * Generate code for the composite agent.
 * @param CompositeActor The composite agent generated code from.
 * @return The composite agent code.
 */
private String _compositeAgentCode(CompositeActor actor) throws IllegalActionException {
  if (FSMDirector.class.isInstance(actor.getDirector())) {
    return _agentCode(actor);
  }
  LinkedList subAgents=_agents(actor);
  if (subAgents.size() == 0)   return _agentCode(actor);
  String compositeCodeString=""String_Node_Str"";
  String subAgentCode=""String_Node_Str"";
  String privateVariables=""String_Node_Str"";
  ListIterator subAgentsIterator=subAgents.listIterator();
  List outputPorts=actor.outputPortList();
  ListIterator outputPortsIterator=actor.outputPortList().listIterator();
  if (outputPorts.size() > 1)   throw new IllegalActionException(""String_Node_Str"");
  String outputAgentName=""String_Node_Str"";
  String outputPortName=""String_Node_Str"";
  String sourceForOutputName=""String_Node_Str"";
  while (outputPortsIterator.hasNext()) {
    TypedIOPort output=(TypedIOPort)outputPortsIterator.next();
    outputPortName=output.getName();
    ListIterator sourcePorts=output.insidePortList().listIterator();
    TypedIOPort sourcePort=new TypedIOPort();
    while (sourcePorts.hasNext()) {
      TypedIOPort port=(TypedIOPort)sourcePorts.next();
      if (port.isOutput()) {
        if (sourcePort == null) {
          throw new IllegalActionException(""String_Node_Str"");
        }
 else {
          sourcePort=port;
          sourceForOutputName=sourcePort.getName();
          Nameable sourceContainer=sourcePort.getContainer();
          outputAgentName=sourceContainer.getName();
        }
      }
    }
  }
  while (subAgentsIterator.hasNext()) {
    String subAgentConnectionInputs=""String_Node_Str"";
    String subAgentConnectionOutputs=""String_Node_Str"";
    CompositeActor subAgent=(CompositeActor)subAgentsIterator.next();
    if (outputAgentName.equals(subAgent.getName())) {
      subAgentConnectionOutputs+=sourceForOutputName;
      subAgentConnectionInputs+=outputPortName;
    }
    subAgentCode+=""String_Node_Str"" + subAgent.getName().toLowerCase() + ""String_Node_Str""+ subAgent.getName()+ ""String_Node_Str"";
    if (actor.depthInHierarchy() == 0) {
      subAgentCode+=_agentParameterTokens((NamedObj)subAgent);
    }
 else {
      subAgentCode+=_agentParameters((NamedObj)subAgent,false);
    }
    subAgentCode+=""String_Node_Str"" + _endLine;
    ListIterator subAgentInputs=subAgent.inputPortList().listIterator();
    while (subAgentInputs.hasNext()) {
      TypedIOPort input=(TypedIOPort)subAgentInputs.next();
      LinkedList sourceList=_shallowSourcePortList(input);
      ListIterator sources=sourceList.listIterator();
      boolean privateVariable=true;
      while (sources.hasNext()) {
        TypedIOPort source=(TypedIOPort)sources.next();
        if (source.depthInHierarchy() != input.depthInHierarchy()) {
          privateVariable=false;
        }
        if (!(source.getName().equals(input.getName()))) {
          if (subAgentConnectionOutputs == ""String_Node_Str"") {
            subAgentConnectionOutputs+=source.getName();
            subAgentConnectionInputs+=input.getName();
          }
 else {
            subAgentConnectionOutputs+=""String_Node_Str"" + source.getName();
            subAgentConnectionInputs+=""String_Node_Str"" + input.getName();
          }
        }
      }
      if (privateVariable) {
        if (privateVariables == ""String_Node_Str"") {
          privateVariables+=""String_Node_Str"" + input.getName();
        }
 else {
          privateVariables+=""String_Node_Str"" + input.getName();
        }
      }
    }
    if (subAgentConnectionInputs.length() != 0) {
      subAgentCode+=""String_Node_Str"" + subAgentConnectionInputs + ""String_Node_Str""+ subAgentConnectionOutputs+ ""String_Node_Str""+ _endLine;
    }
    compositeCodeString+=_compositeAgentCode(subAgent);
  }
  compositeCodeString+=""String_Node_Str"";
  String parameterString=""String_Node_Str"";
  String inputString=""String_Node_Str"";
  String outputString=""String_Node_Str"";
  String initString=""String_Node_Str"";
  String modeString=""String_Node_Str"";
  String modeParameterString=""String_Node_Str"";
  LinkedList parameterList=(LinkedList)actor.attributeList(Parameter.class);
  int parameterNumber=parameterList.size();
  ListIterator parameters=parameterList.listIterator();
  _inPorts=actor.inputPortList().iterator();
  while (_inPorts.hasNext()) {
    if (inputString == ""String_Node_Str"") {
      inputString+=""String_Node_Str"" + ((NamedObj)_inPorts.next()).getName();
    }
 else {
      inputString+=""String_Node_Str"" + ((NamedObj)_inPorts.next()).getName();
    }
  }
  if (inputString != ""String_Node_Str"")   inputString+=""String_Node_Str"";
  _outPorts=actor.outputPortList().iterator();
  if (_outPorts.hasNext()) {
    String outportName=((NamedObj)_outPorts.next()).getName();
    if (outputString == ""String_Node_Str"") {
      outputString+=""String_Node_Str"" + outportName;
    }
 else {
      outputString+=""String_Node_Str"" + outportName;
    }
  }
  if (privateVariables.length() != 0)   privateVariables+=""String_Node_Str"";
  compositeCodeString+=""String_Node_Str"" + actor.getName() + ""String_Node_Str"";
  if (actor.depthInHierarchy() != 0)   compositeCodeString+=_agentParameters((NamedObj)actor,true);
  compositeCodeString+=""String_Node_Str"" + _endLine + ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ outputString+ _endLine+ ""String_Node_Str""+ inputString+ _endLine+ ""String_Node_Str""+ privateVariables+ _endLine+ subAgentCode+ _endLine+ ""String_Node_Str""+ _endLine;
  return compositeCodeString;
}"
75688,"/** 
 * Generate Giotto code for the _container model.
 * @return The Giotto code.
 */
public String generateCode() throws IllegalActionException {
  try {
    generatedCode=""String_Node_Str"";
    _modeCode=""String_Node_Str"";
    if (!_initialize()) {
      return ""String_Node_Str"";
    }
    String containerName=_container.getName();
    generatedCode+=_compositeAgentCode(_container) + _modeCode;
  }
 catch (  IllegalActionException ex) {
    System.out.println(ex.getMessage());
    throw new IllegalActionException(ex.getMessage());
  }
  return generatedCode;
}","/** 
 * Generate Charon code for the _container model.
 * @return The Charon code.
 */
public String generateCode() throws IllegalActionException {
  try {
    generatedCode=""String_Node_Str"";
    _modeCode=""String_Node_Str"";
    if (!_initialize()) {
      return ""String_Node_Str"";
    }
    String containerName=_container.getName();
    generatedCode+=_compositeAgentCode(_container) + _modeCode;
  }
 catch (  IllegalActionException ex) {
    System.out.println(ex.getMessage());
    throw new IllegalActionException(ex.getMessage());
  }
  return generatedCode;
}"
75689,"/** 
 * Generate code for the agent.
 * @param CompositeActor The agent generated code from.
 * @return The agent code.
 */
private String _agentCode(CompositeActor actor) throws IllegalActionException {
  String codeString=""String_Node_Str"";
  String parameterString=""String_Node_Str"";
  String inputString=""String_Node_Str"";
  String outputString=""String_Node_Str"";
  String initString=""String_Node_Str"";
  String modeString=""String_Node_Str"";
  String modeParameterString=""String_Node_Str"";
  String typedModeParameterString=""String_Node_Str"";
  String flowString=""String_Node_Str"";
  String invariantString=""String_Node_Str"";
  LinkedList parameterList=(LinkedList)actor.attributeList(Parameter.class);
  int parameterNumber=parameterList.size();
  ListIterator parameters=parameterList.listIterator();
  Parameter invariantPara=(Parameter)actor.getAttribute(""String_Node_Str"");
  if (invariantPara != null) {
    invariantString=""String_Node_Str"" + ((StringToken)invariantPara.getToken()).stringValue() + ""String_Node_Str"";
  }
  _inPorts=actor.inputPortList().iterator();
  while (_inPorts.hasNext()) {
    if (inputString == ""String_Node_Str"") {
      inputString+=""String_Node_Str"" + ((NamedObj)_inPorts.next()).getName();
    }
 else {
      inputString+=""String_Node_Str"" + ((NamedObj)_inPorts.next()).getName();
    }
  }
  if (inputString != ""String_Node_Str"")   inputString+=""String_Node_Str"";
  _outPorts=actor.outputPortList().iterator();
  int outportNumber=actor.outputPortList().size();
  boolean parameterForOutport=false;
  while (parameters.hasNext()) {
    String parameterName=((NamedObj)parameters.next()).getName();
    if (parameterName.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (parameters.nextIndex() >= (parameterNumber - outportNumber)) {
      parameterForOutport=true;
    }
    if (parameterString == ""String_Node_Str"") {
      parameterString+=""String_Node_Str"" + parameterName;
    }
 else {
      parameterString+=""String_Node_Str"" + parameterName;
    }
    if (parameterForOutport) {
      if (_outPorts.hasNext()) {
        String outportName=((NamedObj)_outPorts.next()).getName();
        if (outputString == ""String_Node_Str"") {
          outputString+=""String_Node_Str"" + outportName;
        }
 else {
          outputString+=""String_Node_Str"" + outportName;
        }
        initString+=outportName + ""String_Node_Str"" + parameterName+ ""String_Node_Str"";
      }
    }
 else {
      if (modeParameterString == ""String_Node_Str"") {
        modeParameterString+=parameterName;
        typedModeParameterString+=""String_Node_Str"" + parameterName;
      }
 else {
        modeParameterString+=""String_Node_Str"" + parameterName;
        typedModeParameterString+=""String_Node_Str"" + parameterName;
      }
    }
  }
  if (outputString != ""String_Node_Str"")   outputString+=""String_Node_Str"";
  initString=""String_Node_Str"" + initString + ""String_Node_Str"";
  modeString=""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ modeParameterString+ ""String_Node_Str"";
  codeString+=""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ parameterString+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ outputString+ _endLine+ ""String_Node_Str""+ inputString+ _endLine+ ""String_Node_Str""+ initString+ _endLine+ ""String_Node_Str""+ modeString+ _endLine+ ""String_Node_Str""+ _endLine;
  if (FSMDirector.class.isInstance(actor.getDirector())) {
    _modeCode+=""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ typedModeParameterString+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ outputString+ _endLine+ ""String_Node_Str""+ inputString+ _endLine;
    String subModeString=_fsmModeCode(((FSMDirector)actor.getDirector()).getController(),inputString,outputString);
    _modeCode+=""String_Node_Str"" + invariantString + _endLine+ ""String_Node_Str""+ _endLine+ subModeString;
  }
 else {
    flowString=_graphToText(actor);
    _modeCode+=""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ typedModeParameterString+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ outputString+ _endLine+ ""String_Node_Str""+ inputString+ _endLine+ ""String_Node_Str""+ flowString+ _endLine+ ""String_Node_Str""+ invariantString+ _endLine+ ""String_Node_Str""+ _endLine;
  }
  return codeString;
}","/** 
 * Generate code for the agent.
 * @param CompositeActor The agent generated code from.
 * @return The agent code.
 */
private String _agentCode(CompositeActor actor) throws IllegalActionException {
  String codeString=""String_Node_Str"";
  String parameterString=""String_Node_Str"";
  String inputString=""String_Node_Str"";
  String outputString=""String_Node_Str"";
  String initString=""String_Node_Str"";
  String modeString=""String_Node_Str"";
  String modeParameterString=""String_Node_Str"";
  String typedModeParameterString=""String_Node_Str"";
  String flowString=""String_Node_Str"";
  String invariantString=""String_Node_Str"";
  LinkedList parameterList=(LinkedList)actor.attributeList(Parameter.class);
  Parameter invariantPara=(Parameter)actor.getAttribute(""String_Node_Str"");
  if (invariantPara != null) {
    invariantString=""String_Node_Str"" + ((StringToken)invariantPara.getToken()).stringValue() + ""String_Node_Str"";
    parameterList.remove(invariantPara);
    ;
  }
  int parameterNumber=parameterList.size();
  ListIterator parameters=parameterList.listIterator();
  _inPorts=actor.inputPortList().iterator();
  while (_inPorts.hasNext()) {
    if (inputString == ""String_Node_Str"") {
      inputString+=""String_Node_Str"" + ((NamedObj)_inPorts.next()).getName();
    }
 else {
      inputString+=""String_Node_Str"" + ((NamedObj)_inPorts.next()).getName();
    }
  }
  if (inputString != ""String_Node_Str"")   inputString+=""String_Node_Str"";
  _outPorts=actor.outputPortList().iterator();
  int outportNumber=actor.outputPortList().size();
  boolean parameterForOutport=false;
  while (parameters.hasNext()) {
    String parameterName=((NamedObj)parameters.next()).getName();
    if (parameterName.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (parameters.nextIndex() > (parameterNumber - outportNumber)) {
      parameterForOutport=true;
    }
    if (parameterString == ""String_Node_Str"") {
      parameterString+=""String_Node_Str"" + parameterName;
    }
 else {
      parameterString+=""String_Node_Str"" + parameterName;
    }
    if (parameterForOutport) {
      if (_outPorts.hasNext()) {
        String outportName=((NamedObj)_outPorts.next()).getName();
        if (outputString == ""String_Node_Str"") {
          outputString+=""String_Node_Str"" + outportName;
        }
 else {
          outputString+=""String_Node_Str"" + outportName;
        }
        initString+=outportName + ""String_Node_Str"" + parameterName+ ""String_Node_Str"";
      }
    }
 else {
      if (modeParameterString == ""String_Node_Str"") {
        modeParameterString+=parameterName;
        typedModeParameterString+=""String_Node_Str"" + parameterName;
      }
 else {
        modeParameterString+=""String_Node_Str"" + parameterName;
        typedModeParameterString+=""String_Node_Str"" + parameterName;
      }
    }
  }
  if (outputString != ""String_Node_Str"")   outputString+=""String_Node_Str"";
  initString=""String_Node_Str"" + initString + ""String_Node_Str"";
  modeString=""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ modeParameterString+ ""String_Node_Str"";
  codeString+=""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ parameterString+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ outputString+ _endLine+ ""String_Node_Str""+ inputString+ _endLine+ ""String_Node_Str""+ initString+ _endLine+ ""String_Node_Str""+ modeString+ _endLine+ ""String_Node_Str""+ _endLine;
  if (FSMDirector.class.isInstance(actor.getDirector())) {
    _modeCode+=""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ typedModeParameterString+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ outputString+ _endLine+ ""String_Node_Str""+ inputString+ _endLine;
    String subModeString=_fsmModeCode(((FSMDirector)actor.getDirector()).getController(),inputString,outputString);
    _modeCode+=""String_Node_Str"" + invariantString + _endLine+ ""String_Node_Str""+ _endLine+ subModeString;
  }
 else {
    flowString=_graphToText(actor);
    _modeCode+=""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ ""String_Node_Str""+ typedModeParameterString+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ _endLine+ ""String_Node_Str""+ outputString+ _endLine+ ""String_Node_Str""+ inputString+ _endLine+ ""String_Node_Str""+ flowString+ _endLine+ ""String_Node_Str""+ invariantString+ _endLine+ ""String_Node_Str""+ _endLine;
  }
  return codeString;
}"
75690,"/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (histogram != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    histogram.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
 else   if (_configureSources != null) {
    Iterator sources=_configureSources.iterator();
    Iterator texts=_configureTexts.iterator();
    while (sources.hasNext()) {
      String source=(String)sources.next();
      String text=(String)texts.next();
      if (source != null && !source.trim().equals(""String_Node_Str"")) {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + source+ ""String_Node_Str"");
      }
 else {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
      }
      if (text != null) {
        output.write(text.trim() + ""String_Node_Str"");
      }
      output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
    }
  }
}","/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (histogram != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    histogram.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
 else   if (_configureSources != null) {
    Iterator sources=_configureSources.iterator();
    Iterator texts=_configureTexts.iterator();
    while (sources.hasNext()) {
      String source=(String)sources.next();
      String text=(String)texts.next();
      if (source != null && !source.trim().equals(""String_Node_Str"")) {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + source+ ""String_Node_Str"");
        if (text != null) {
          output.write(""String_Node_Str"");
        }
      }
 else {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
      }
      if (text != null) {
        output.write(text.trim() + ""String_Node_Str"");
        if (source != null && !source.trim().equals(""String_Node_Str"")) {
          output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
        }
      }
      output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
    }
  }
}"
75691,"/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (plot != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    plot.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
 else   if (_configureSources != null) {
    Iterator sources=_configureSources.iterator();
    Iterator texts=_configureTexts.iterator();
    while (sources.hasNext()) {
      String source=(String)sources.next();
      String text=(String)texts.next();
      if (source != null && !source.trim().equals(""String_Node_Str"")) {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + source+ ""String_Node_Str"");
      }
 else {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
      }
      if (text != null) {
        output.write(text.trim() + ""String_Node_Str"");
      }
      output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
    }
  }
}","/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (plot != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    plot.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
 else   if (_configureSources != null) {
    Iterator sources=_configureSources.iterator();
    Iterator texts=_configureTexts.iterator();
    while (sources.hasNext()) {
      String source=(String)sources.next();
      String text=(String)texts.next();
      if (source != null && !source.trim().equals(""String_Node_Str"")) {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + source+ ""String_Node_Str"");
        if (text != null) {
          output.write(""String_Node_Str"");
        }
      }
 else {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
      }
      if (text != null) {
        output.write(text.trim() + ""String_Node_Str"");
        if (source != null && !source.trim().equals(""String_Node_Str"")) {
          output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
        }
      }
      output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
    }
  }
}"
75692,"/** 
 * Request restoration of the user settable attribute values to what they were when this object was created.  The actual restoration occurs later, in the UI thread, in order to allow all pending changes to the attribute values to be processed first.
 */
public void restore(){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      Iterator entries=_originalValues.entrySet().iterator();
      while (entries.hasNext()) {
        Map.Entry entry=(Map.Entry)entries.next();
        Settable parameter=(Settable)_object.getAttribute((String)entry.getKey());
        try {
          parameter.setExpression((String)entry.getValue());
          if (parameter instanceof Variable) {
            ((Variable)parameter).getToken();
          }
        }
 catch (        IllegalActionException ex) {
        }
      }
    }
  }
);
}","/** 
 * Request restoration of the user settable attribute values to what they were when this object was created.  The actual restoration occurs later, in the UI thread, in order to allow all pending changes to the attribute values to be processed first.
 */
public void restore(){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      MoMLChangeRequest request=new MoMLChangeRequest(this,_parent,_restoreMoML,null);
      _object.requestChange(request);
    }
  }
);
}"
75693,"public void run(){
  Iterator entries=_originalValues.entrySet().iterator();
  while (entries.hasNext()) {
    Map.Entry entry=(Map.Entry)entries.next();
    Settable parameter=(Settable)_object.getAttribute((String)entry.getKey());
    try {
      parameter.setExpression((String)entry.getValue());
      if (parameter instanceof Variable) {
        ((Variable)parameter).getToken();
      }
    }
 catch (    IllegalActionException ex) {
    }
  }
}","public void run(){
  MoMLChangeRequest request=new MoMLChangeRequest(this,_parent,_restoreMoML,null);
  _object.requestChange(request);
}"
75694,"/** 
 * Construct a configurer for the specified object.  This stores the current values of any Settable attributes of the given object, and then defers to any editor pane factories contained by the given object to populate this panel with widgets that edit the attributes of the given object.  If there are no editor pane factories, then a default editor pane is created.
 * @param object The object to configure.
 */
public Configurer(final NamedObj object){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  _object=object;
  Iterator parameters=object.attributeList(Settable.class).iterator();
  while (parameters.hasNext()) {
    Settable parameter=(Settable)parameters.next();
    if (parameter.getVisibility() == Settable.FULL) {
      _originalValues.put(parameter.getName(),parameter.getExpression());
    }
  }
  boolean foundOne=false;
  Iterator editors=object.attributeList(EditorPaneFactory.class).iterator();
  while (editors.hasNext()) {
    foundOne=true;
    EditorPaneFactory editor=(EditorPaneFactory)editors.next();
    Component pane=editor.createEditorPane();
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
  if (!foundOne) {
    Component pane=EditorPaneFactory.createEditorPane(object);
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
}","/** 
 * Construct a configurer for the specified object.  This stores the current values of any Settable attributes of the given object, and then defers to any editor pane factories contained by the given object to populate this panel with widgets that edit the attributes of the given object.  If there are no editor pane factories, then a default editor pane is created.
 * @param object The object to configure.
 */
public Configurer(final NamedObj object){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  _object=object;
  NamedObj parent=MoMLChangeRequest.getDeferredToParent(object);
  if (parent == null) {
    parent=(NamedObj)object.getContainer();
  }
  _parent=parent;
  StringBuffer buffer=new StringBuffer();
  buffer.append(""String_Node_Str"");
  Iterator parameters=object.attributeList(Settable.class).iterator();
  while (parameters.hasNext()) {
    Settable parameter=(Settable)parameters.next();
    if (parameter.getVisibility() == Settable.FULL) {
      String oldExpression=parameter.getExpression();
      buffer.append(""String_Node_Str"");
      buffer.append(((NamedObj)parameter).getName(parent));
      buffer.append(""String_Node_Str"");
      buffer.append(StringUtilities.escapeForXML(oldExpression));
      buffer.append(""String_Node_Str"");
    }
  }
  buffer.append(""String_Node_Str"");
  _restoreMoML=buffer.toString();
  boolean foundOne=false;
  Iterator editors=object.attributeList(EditorPaneFactory.class).iterator();
  while (editors.hasNext()) {
    foundOne=true;
    EditorPaneFactory editor=(EditorPaneFactory)editors.next();
    Component pane=editor.createEditorPane();
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
  if (!foundOne) {
    Component pane=EditorPaneFactory.createEditorPane(object);
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
}"
75695,"/** 
 * Return false if the system has finished executing, either by reaching the iteration limit, or by having an actor in the model return false in postfire.
 * @return True if the execution is not finished.
 * @exception IllegalActionException If the iterations parameter doesnot have a valid token.
 */
public boolean postfire() throws IllegalActionException {
  int numberOfIterations=((IntToken)(iterations.getToken())).intValue();
  if (_debugging) {
    _debug(""String_Node_Str"" + _iterationCount);
  }
  _expectedNextIterationTime+=_unitTimeIncrement;
  if (_debugging) {
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  if ((numberOfIterations > 0) && (_iterationCount > numberOfIterations)) {
    _iterationCount=0;
    _transferOutputsOnly=false;
    if (_isEmbedded()) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    if ((numberOfIterations > 0) && (_iterationCount == numberOfIterations)) {
      _transferOutputsOnly=true;
    }
    if (_isEmbedded()) {
      _requestFiring();
    }
 else {
      setCurrentTime(_expectedNextIterationTime);
    }
  }
  return true;
}","/** 
 * Return false if the system has finished executing, either by reaching the iteration limit, or by having an actor in the model return false in postfire.
 * @return True if the execution is not finished.
 * @exception IllegalActionException If the iterations parameter doesnot have a valid token.
 */
public boolean postfire() throws IllegalActionException {
  _unitIndex++;
  if (_unitIndex >= _schedule.size()) {
    _unitIndex=0;
    if (_debugging) {
      _debug(""String_Node_Str"" + _iterationCount);
    }
    _iterationCount++;
  }
  int numberOfIterations=((IntToken)(iterations.getToken())).intValue();
  _expectedNextIterationTime+=_unitTimeIncrement;
  if (_debugging) {
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  if ((numberOfIterations > 0) && (_iterationCount >= numberOfIterations) && (_transferOutputsOnly == true)) {
    _iterationCount=0;
    _transferOutputsOnly=false;
    if (_isEmbedded()) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    if ((numberOfIterations > 0) && (_iterationCount == numberOfIterations)) {
      _transferOutputsOnly=true;
    }
    if (_isEmbedded()) {
      _requestFiring();
    }
 else {
      setCurrentTime(_expectedNextIterationTime);
    }
  }
  return true;
}"
75696,"/** 
 * Return true if the current time of the outside domain is greater than or equal to the current time.
 * @return True if the director is ready to run for one iteration.
 */
public boolean prefire() throws IllegalActionException {
  if (_isEmbedded()) {
    setCurrentTime((((CompositeActor)getContainer()).getExecutiveDirector()).getCurrentTime());
  }
  _expectedNextIterationTime=getCurrentTime();
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  Director upperDirector=((CompositeActor)getContainer()).getExecutiveDirector();
  if (upperDirector instanceof CTDirector) {
    if (Math.abs(getCurrentTime() - _expectedNextIterationTime) < ((CTDirector)upperDirector).getTimeResolution()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      return true;
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    return false;
  }
 else {
    if (getCurrentTime() < _expectedNextIterationTime) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      return false;
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    return true;
  }
}","/** 
 * Return true if the current time of the outside domain is greater than or equal to the current time.
 * @return True if the director is ready to run for one iteration.
 */
public boolean prefire() throws IllegalActionException {
  if (_isEmbedded()) {
    setCurrentTime((((CompositeActor)getContainer()).getExecutiveDirector()).getCurrentTime());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  Director upperDirector=((CompositeActor)getContainer()).getExecutiveDirector();
  if (upperDirector instanceof CTDirector) {
    if (Math.abs(getCurrentTime() - _expectedNextIterationTime) < ((CTDirector)upperDirector).getTimeResolution()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      return true;
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    return false;
  }
 else {
    if (getCurrentTime() < _expectedNextIterationTime) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      _expectedNextIterationTime=getCurrentTime();
      return false;
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    return true;
  }
}"
75697,"/** 
 * Iterate the actors in the next minor cycle of the schedule. After iterating the actors, increment time by the minor cycle time. Also, update the receivers that are destinations of all actors that will be invoked in the next minor cycle of the schedule. This works because all actors in Giotto are invoked periodically, and the ones that will be invoked in the next cycle are the ones that are completing invocation at the end of this cycle.
 * @exception IllegalActionException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  TypedCompositeActor container=(TypedCompositeActor)getContainer();
  if (container == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Schedule unitSchedule=(Schedule)_schedule.get(_unitIndex++);
  Iterator scheduleIterator=unitSchedule.iterator();
  if (_iterationCount != 0 || _transferOutputsOnly) {
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
      }
      List outputPortList=actor.outputPortList();
      Iterator outputPorts=outputPortList.iterator();
      while (outputPorts.hasNext()) {
        IOPort port=(IOPort)outputPorts.next();
        Receiver[][] channelArray=port.getRemoteReceivers();
        for (int i=0; i < channelArray.length; i++) {
          Receiver[] receiverArray=channelArray[i];
          for (int j=0; j < receiverArray.length; j++) {
            GiottoReceiver receiver=(GiottoReceiver)receiverArray[j];
            receiver.update();
          }
        }
      }
    }
  }
  if (!_transferOutputsOnly) {
    scheduleIterator=unitSchedule.iterator();
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      int actorFrequency=GiottoScheduler.getFrequency(actor);
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
      }
      if (actor.iterate(1) == STOP_ITERATING) {
      }
    }
  }
  if (_synchronizeToRealTime) {
    long elapsedTime=System.currentTimeMillis() - _realStartTime;
    double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
    if (_unitTimeIncrement > elapsedTimeInSeconds) {
      long timeToWait=(long)((_unitTimeIncrement - elapsedTimeInSeconds) * 1000.0);
      if (timeToWait > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"" + timeToWait);
        }
        Scheduler scheduler=getScheduler();
synchronized (scheduler) {
          try {
            scheduler.wait(timeToWait);
          }
 catch (          InterruptedException ex) {
          }
        }
      }
    }
  }
  if (_unitIndex >= _schedule.size()) {
    _unitIndex=0;
    _iterationCount++;
  }
}","/** 
 * Iterate the actors in the next minor cycle of the schedule. After iterating the actors, increment time by the minor cycle time. Also, update the receivers that are destinations of all actors that will be invoked in the next minor cycle of the schedule. This works because all actors in Giotto are invoked periodically, and the ones that will be invoked in the next cycle are the ones that are completing invocation at the end of this cycle.
 * @exception IllegalActionException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  TypedCompositeActor container=(TypedCompositeActor)getContainer();
  if (container == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Schedule unitSchedule=(Schedule)_schedule.get(_unitIndex);
  Iterator scheduleIterator=unitSchedule.iterator();
  if (!(_unitIndex == 0 && _iterationCount == 0) || _transferOutputsOnly) {
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
      }
      List outputPortList=actor.outputPortList();
      Iterator outputPorts=outputPortList.iterator();
      while (outputPorts.hasNext()) {
        IOPort port=(IOPort)outputPorts.next();
        Receiver[][] channelArray=port.getRemoteReceivers();
        for (int i=0; i < channelArray.length; i++) {
          Receiver[] receiverArray=channelArray[i];
          for (int j=0; j < receiverArray.length; j++) {
            GiottoReceiver receiver=(GiottoReceiver)receiverArray[j];
            receiver.update();
          }
        }
      }
    }
  }
  if (!_transferOutputsOnly) {
    scheduleIterator=unitSchedule.iterator();
    while (scheduleIterator.hasNext()) {
      Actor actor=((Firing)scheduleIterator.next()).getActor();
      int actorFrequency=GiottoScheduler.getFrequency(actor);
      if (_debugging) {
        _debug(""String_Node_Str"" + ((NamedObj)actor).getFullName());
      }
      if (actor.iterate(1) == STOP_ITERATING) {
      }
    }
  }
  if (_synchronizeToRealTime) {
    long elapsedTime=System.currentTimeMillis() - _realStartTime;
    double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
    if (_unitTimeIncrement > elapsedTimeInSeconds) {
      long timeToWait=(long)((_unitTimeIncrement - elapsedTimeInSeconds) * 1000.0);
      if (timeToWait > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"" + timeToWait);
        }
        Scheduler scheduler=getScheduler();
synchronized (scheduler) {
          try {
            scheduler.wait(timeToWait);
          }
 catch (          InterruptedException ex) {
          }
        }
      }
    }
  }
}"
75698,"/** 
 * Initialize the actors associated with this director. The order in which the actors are initialized is arbitrary.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  _iterationCount=0;
  _unitIndex=0;
  _expectedNextIterationTime=0.0;
  Iterator receivers=_receivers.iterator();
  while (receivers.hasNext()) {
    GiottoReceiver receiver=(GiottoReceiver)receivers.next();
    receiver.reset();
  }
  super.initialize();
  CompositeActor compositeActor=(CompositeActor)(getContainer());
  List actorList=compositeActor.deepEntityList();
  ListIterator actors=actorList.listIterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    List outputPortList=actor.outputPortList();
    Iterator outputPorts=outputPortList.iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      Parameter initialValueParameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
      if (initialValueParameter != null) {
        port.broadcast(initialValueParameter.getToken());
      }
    }
  }
  GiottoScheduler scheduler=(GiottoScheduler)getScheduler();
  _schedule=scheduler.getSchedule();
  _unitTimeIncrement=scheduler.getMinTimeStep(_periodValue);
  _realStartTime=System.currentTimeMillis();
}","/** 
 * Initialize the actors associated with this director. The order in which the actors are initialized is arbitrary.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  _iterationCount=0;
  _unitIndex=0;
  _expectedNextIterationTime=0.0;
  Iterator receivers=_receivers.iterator();
  while (receivers.hasNext()) {
    GiottoReceiver receiver=(GiottoReceiver)receivers.next();
    receiver.reset();
  }
  super.initialize();
  CompositeActor compositeActor=(CompositeActor)(getContainer());
  List actorList=compositeActor.deepEntityList();
  ListIterator actors=actorList.listIterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    List outputPortList=actor.outputPortList();
    Iterator outputPorts=outputPortList.iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      Parameter initialValueParameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
      if (initialValueParameter != null) {
        port.broadcast(initialValueParameter.getToken());
        Receiver[][] channelArray=port.getRemoteReceivers();
        for (int i=0; i < channelArray.length; i++) {
          Receiver[] receiverArray=channelArray[i];
          for (int j=0; j < receiverArray.length; j++) {
            GiottoReceiver receiver=(GiottoReceiver)receiverArray[j];
            receiver.update();
          }
        }
      }
    }
  }
  GiottoScheduler scheduler=(GiottoScheduler)getScheduler();
  _schedule=scheduler.getSchedule();
  _unitTimeIncrement=scheduler._getMinTimeStep(_periodValue);
  _realStartTime=System.currentTimeMillis();
}"
75699,"/** 
 * Compare two actors based on their <I>frequency</I> parameter. The frequency of an actor that does not have a <I>frequency</I> parameter is DEFAULT_GIOTTO_FREQUENCY.
 * @param actor1 The first actor to be compared.
 * @param actor2 The second actor to be compared.
 * @return -1 if the frequency of the first actor is strictly lessthan that of the second actor, 0 if the frequencies are equal, 1 otherwise.
 * @exception ClassCastException If an argument is null or not aninstance of Actor.
 */
public int compare(Object actor1,Object actor2){
  if (actor1 != null && actor1 instanceof Actor && actor2 != null && actor2 instanceof Actor) {
    if (getFrequency((Actor)actor1) < getFrequency((Actor)actor2))     return -1;
 else     if (getFrequency((Actor)actor1) == getFrequency((Actor)actor2))     return 0;
 else     return 1;
  }
 else   throw new ClassCastException();
}","/** 
 * Compare two actors based on their <I>frequency</I> parameter. The frequency of an actor that does not have a <I>frequency</I> parameter is _DEFAULT_GIOTTO_FREQUENCY.
 * @param actor1 The first actor to be compared.
 * @param actor2 The second actor to be compared.
 * @return -1 if the frequency of the first actor is strictly lessthan that of the second actor, 0 if the frequencies are equal, 1 otherwise.
 * @exception ClassCastException If an argument is null or not aninstance of Actor.
 */
public int compare(Object actor1,Object actor2){
  if (actor1 != null && actor1 instanceof Actor && actor2 != null && actor2 instanceof Actor) {
    if (getFrequency((Actor)actor1) < getFrequency((Actor)actor2))     return -1;
 else     if (getFrequency((Actor)actor1) == getFrequency((Actor)actor2))     return 0;
 else     return 1;
  }
 else   throw new ClassCastException();
}"
75700,"/** 
 * Return the frequency of the given actor. If the actor has a <I>frequency</I> parameter with a valid integer value, return that value. For actors without a <I>frequency</I> parameter, their frequency is DEFAULT_GIOTTO_FREQUENCY.
 * @param actor An actor.
 * @return The frequency of the actor.
 */
public static int getFrequency(Actor actor){
  try {
    Parameter parameter=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
    if (parameter != null) {
      IntToken intToken=(IntToken)parameter.getToken();
      return intToken.intValue();
    }
 else     return DEFAULT_GIOTTO_FREQUENCY;
  }
 catch (  ClassCastException ex) {
    return DEFAULT_GIOTTO_FREQUENCY;
  }
catch (  IllegalActionException ex) {
    return DEFAULT_GIOTTO_FREQUENCY;
  }
}","/** 
 * Return the frequency of the given actor. If the actor has a <I>frequency</I> parameter with a valid integer value, return that value. For actors without a <I>frequency</I> parameter, their frequency is _DEFAULT_GIOTTO_FREQUENCY.
 * @param actor An actor.
 * @return The frequency of the actor.
 */
public static int getFrequency(Actor actor){
  try {
    Parameter parameter=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
    if (parameter != null) {
      IntToken intToken=(IntToken)parameter.getToken();
      return intToken.intValue();
    }
 else     return _DEFAULT_GIOTTO_FREQUENCY;
  }
 catch (  ClassCastException ex) {
    return _DEFAULT_GIOTTO_FREQUENCY;
  }
catch (  IllegalActionException ex) {
    return _DEFAULT_GIOTTO_FREQUENCY;
  }
}"
75701,"/** 
 * Given a class name, convert the specified class to C (.c and .h files).
 * @param classPath The classpath to use during the conversion.
 * @param className The name of the class to translate.
 * @param generateSingleClass Indicates whether (true) or not (false)""single class mode"" should be used during the conversion (see  {@link Context#getSingleClassMode()} for details).
 */
public static void convert(String classPath,String className,String compileMode,boolean verbose) throws IOException {
  boolean generateSingleClass=compileMode.equals(""String_Node_Str"");
  if (verbose) {
    System.out.println(""String_Node_Str"" + classPath);
    System.out.println(""String_Node_Str"" + generateSingleClass);
  }
  Scene.v().setSootClassPath(classPath);
  Scene.v().loadClassAndSupport(className);
  RequiredFileGenerator RFG=new RequiredFileGenerator();
  if (!generateSingleClass) {
    RFG.init(classPath,className);
  }
  HeaderFileGenerator hGenerator=new HeaderFileGenerator();
  CodeFileGenerator cGenerator=new CodeFileGenerator();
  InterfaceFileGenerator iGenerator=new InterfaceFileGenerator();
  if (generateSingleClass) {
    cGenerator.setSingleClassMode();
    hGenerator.setSingleClassMode();
  }
  SootClass sootClass=Scene.v().getSootClass(className);
  CNames.setup();
  String code=iGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  code=hGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  code=cGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  if (!generateSingleClass) {
    RFG.generateTransitiveClosureOf(classPath,className,compileMode,verbose);
    MakeFileGenerator.generateMakeFile(classPath,className,RFG.getRequiredClasses(classPath,className));
  }
}","/** 
 * Given a class name, convert the specified class to C (.c and .h files).
 * @param classPath The classpath to use during the conversion.
 * @param className The name of the class to translate.
 * @param generateSingleClass Indicates whether (true) or not (false)""single class mode"" should be used during the conversion (see  {@link Context#getSingleClassMode()} for details).
 */
public static void convert(String classPath,String className,String compileMode,boolean verbose) throws IOException {
  boolean generateSingleClass=compileMode.equals(""String_Node_Str"");
  if (verbose) {
    System.out.println(""String_Node_Str"" + classPath);
    System.out.println(""String_Node_Str"" + generateSingleClass);
  }
  Scene.v().reset();
  Scene.v().setSootClassPath(classPath);
  Scene.v().loadClassAndSupport(className);
  RequiredFileGenerator RFG=new RequiredFileGenerator();
  if (!generateSingleClass) {
    RFG.init(classPath,className);
  }
  HeaderFileGenerator hGenerator=new HeaderFileGenerator();
  CodeFileGenerator cGenerator=new CodeFileGenerator();
  InterfaceFileGenerator iGenerator=new InterfaceFileGenerator();
  if (generateSingleClass) {
    cGenerator.setSingleClassMode();
    hGenerator.setSingleClassMode();
  }
  SootClass sootClass=Scene.v().getSootClass(className);
  CNames.setup();
  String code=iGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  code=hGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  code=cGenerator.generate(sootClass);
  FileHandler.write(className + ""String_Node_Str"",code);
  if (!generateSingleClass) {
    RFG.generateTransitiveClosureOf(classPath,className,compileMode,verbose);
    MakeFileGenerator.generateMakeFile(classPath,className,RFG.getRequiredClasses(classPath,className));
  }
}"
75702,"/** 
 * Fire this actor.  Optionally parse a received datagram into a token of arbitrary type.  Otherwise, assemble an integer array token by placing 1 or 4 bytes of the datagram into each integer in the array.  Broadcast the converted token on the output port.
 * @exception IllegalActionException If the data cannot beconverted into a token of the same type as the configured type of the output port.
 */
public void fire() throws IllegalActionException {
  for (int i=0; i < trigger.getWidth(); i++) {
    if (trigger.hasToken(i)) {
      trigger.get(i);
    }
  }
  boolean useDefaultOutput;
synchronized (_syncFireAndThread) {
    int bytesAvailable=0;
    byte[] dataBytes=new byte[0];
    while (_blockAwaitingDatagram && _packetsAlreadyAwaitingFire == 0) {
      try {
        _fireIsWaiting=true;
        _syncFireAndThread.wait();
        _fireIsWaiting=false;
      }
 catch (      InterruptedException ex) {
        System.out.println(this + ""String_Node_Str"");
        throw new RuntimeException(""String_Node_Str"");
      }
 finally {
        if (_stopFire) {
          _stopFire=false;
          if (_debugging)           _debug(""String_Node_Str"");
          return;
        }
      }
    }
    if (_packetsAlreadyAwaitingFire != 0) {
      useDefaultOutput=false;
      bytesAvailable=_broadcastPacket.getLength();
      dataBytes=_broadcastPacket.getData();
      _returnAddress=_broadcastPacket.getAddress().getHostAddress();
      _returnSocketNumber=_broadcastPacket.getPort();
      _packetsAlreadyAwaitingFire--;
    }
 else {
      useDefaultOutput=true;
    }
    if (!useDefaultOutput) {
      if (_decodeWithPtolemyParser) {
        String dataStr=new String(dataBytes,0,bytesAvailable);
        _evalVar.setExpression(dataStr);
        _outputToken=_evalVar.getToken();
        if (_outputToken == null) {
          if (_debugging)           _debug(""String_Node_Str"");
          _outputToken=new Token();
        }
 else {
          if (_debugging)           _debug(""String_Node_Str"");
        }
      }
 else       if (_decodeToIntegerArray) {
        int xs=bytesAvailable % _decodedBytesPerInteger;
        if (xs != 0) {
          if (_debugging)           _debug(xs + ""String_Node_Str"");
        }
        if (bytesAvailable / _decodedBytesPerInteger > 0) {
          Token[] dataIntTokens=new Token[bytesAvailable / _decodedBytesPerInteger];
          if (_decodedBytesPerInteger == 1) {
            for (int j=0; j < bytesAvailable; j++) {
              dataIntTokens[j]=new IntToken(dataBytes[j]);
            }
          }
 else           if (_decodedBytesPerInteger == 4) {
            for (int j=0; j < bytesAvailable / 4; j++) {
              dataIntTokens[j]=new IntToken(dataBytes[4 * j] + 256 * dataBytes[4 * j + 1] + 65536 * dataBytes[4 * j + 2] + 16777216 * dataBytes[4 * j + 3]);
            }
          }
 else {
          }
          if (_debugging)           _debug(""String_Node_Str"");
          _outputToken=new ArrayToken(dataIntTokens);
        }
 else {
          if (_debugging)           _debug(""String_Node_Str"");
          _outputToken=new ArrayToken(BaseType.INT);
        }
      }
 else {
        if (true)         System.out.println(""String_Node_Str"");
        throw new IllegalActionException(this,""String_Node_Str"" + _encoding);
      }
    }
    _syncFireAndThread.notifyAll();
  }
  if (!useDefaultOutput) {
    returnAddress.broadcast(new StringToken(_returnAddress));
    returnSocketNumber.broadcast(new IntToken(_returnSocketNumber));
    output.broadcast(_outputToken);
  }
 else {
    if (_defaultOutputToken == null) {
      if (_debugging)       _debug(""String_Node_Str"");
    }
 else {
      if (_debugging)       _debug(""String_Node_Str"");
synchronized (_syncDefaultOutputs) {
        returnAddress.broadcast(new StringToken(_defaultReturnAddress));
        returnSocketNumber.broadcast(new IntToken(_defaultReturnSocketNumber));
        output.broadcast(_defaultOutputToken);
      }
    }
  }
}","/** 
 * Fire this actor.  Optionally parse a received datagram into a token of arbitrary type.  Otherwise, assemble an integer array token by placing 1 or 4 bytes of the datagram into each integer in the array.  Broadcast the converted token on the output port.
 * @exception IllegalActionException If the data cannot beconverted into a token of the same type as the configured type of the output port.
 */
public void fire() throws IllegalActionException {
  for (int i=0; i < trigger.getWidth(); i++) {
    if (trigger.hasToken(i)) {
      trigger.get(i);
    }
  }
  boolean useDefaultOutput;
synchronized (_syncFireAndThread) {
    int bytesAvailable=0;
    byte[] dataBytes=new byte[0];
    while (_blockAwaitingDatagram && _packetsAlreadyAwaitingFire == 0) {
      try {
        _fireIsWaiting=true;
        _syncFireAndThread.wait();
        _fireIsWaiting=false;
      }
 catch (      InterruptedException ex) {
        System.out.println(this + ""String_Node_Str"");
        throw new RuntimeException(""String_Node_Str"");
      }
 finally {
        if (_stopFire) {
          _stopFire=false;
          if (_debugging)           _debug(""String_Node_Str"");
          return;
        }
      }
    }
    if (_packetsAlreadyAwaitingFire != 0) {
      useDefaultOutput=false;
      bytesAvailable=_broadcastPacket.getLength();
      dataBytes=_broadcastPacket.getData();
      _returnAddress=_broadcastPacket.getAddress().getHostAddress();
      _returnSocketNumber=_broadcastPacket.getPort();
      _packetsAlreadyAwaitingFire--;
    }
 else {
      useDefaultOutput=true;
    }
    if (!useDefaultOutput) {
      if (_decodeWithPtolemyParser) {
        String dataStr=new String(dataBytes,0,bytesAvailable);
        _evalVar.setExpression(dataStr);
        _outputToken=_evalVar.getToken();
        if (_outputToken == null) {
          if (_debugging)           _debug(""String_Node_Str"");
          _outputToken=new Token();
        }
 else {
          if (_debugging)           _debug(""String_Node_Str"");
        }
      }
 else       if (_decodeToIntegerArray) {
        int xs=bytesAvailable % _decodedBytesPerInteger;
        if (xs != 0) {
          if (_debugging)           _debug(xs + ""String_Node_Str"");
        }
        if (bytesAvailable / _decodedBytesPerInteger > 0) {
          Token[] dataIntTokens=new Token[bytesAvailable / _decodedBytesPerInteger];
          if (_decodedBytesPerInteger == 1) {
            for (int j=0; j < bytesAvailable; j++) {
              dataIntTokens[j]=new IntToken(dataBytes[j]);
            }
          }
 else           if (_decodedBytesPerInteger == 4) {
            for (int j=0; j < bytesAvailable / 4; j++) {
              if (false)               System.out.println(dataBytes[4 * j] + ""String_Node_Str"" + dataBytes[4 * j + 1]+ ""String_Node_Str""+ dataBytes[4 * j + 2]+ ""String_Node_Str""+ dataBytes[4 * j + 3]);
              dataIntTokens[j]=new IntToken((255 & dataBytes[4 * j]) | (255 & dataBytes[4 * j + 1]) << 8 | (255 & dataBytes[4 * j + 2]) << 16 | (255 & dataBytes[4 * j + 3]) << 24);
            }
          }
 else {
          }
          if (_debugging)           _debug(""String_Node_Str"");
          _outputToken=new ArrayToken(dataIntTokens);
        }
 else {
          if (_debugging)           _debug(""String_Node_Str"");
          _outputToken=new ArrayToken(BaseType.INT);
        }
      }
 else {
        if (true)         System.out.println(""String_Node_Str"");
        throw new IllegalActionException(this,""String_Node_Str"" + _encoding);
      }
    }
    _syncFireAndThread.notifyAll();
  }
  if (!useDefaultOutput) {
    returnAddress.broadcast(new StringToken(_returnAddress));
    returnSocketNumber.broadcast(new IntToken(_returnSocketNumber));
    output.broadcast(_outputToken);
  }
 else {
    if (_defaultOutputToken == null) {
      if (_debugging)       _debug(""String_Node_Str"");
    }
 else {
      if (_debugging)       _debug(""String_Node_Str"");
synchronized (_syncDefaultOutputs) {
        returnAddress.broadcast(new StringToken(_defaultReturnAddress));
        returnSocketNumber.broadcast(new IntToken(_defaultReturnSocketNumber));
        output.broadcast(_defaultOutputToken);
      }
    }
  }
}"
75703,"/** 
 * Does up to three things, in this order: Set new remote address value, Set new remote socket number, transmit data as a UDP packet over the ethernet.  The first two can, of course, affect where the datagram goes.  Any remote address/socket values supplied are saved and become the defaults for next time.
 */
public void fire() throws IllegalActionException {
  if (remoteAddress.getWidth() > 0 && remoteAddress.hasToken(0)) {
    String address=((StringToken)(remoteAddress.get(0))).stringValue();
    try {
      _address=InetAddress.getByName(address);
    }
 catch (    UnknownHostException ex) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
  }
  if (remoteSocketNumber.getWidth() > 0 && remoteSocketNumber.hasToken(0)) {
    _remoteSocketNumber=65535 & ((IntToken)remoteSocketNumber.get(0)).intValue();
  }
  if (data.hasToken(0)) {
    byte[] dataBytes=new byte[0];
    if (_encodeForPtolemyParser) {
      dataBytes=data.get(0).toString().getBytes();
    }
 else     if (_encodeFromIntegerArray) {
      ArrayToken dataIntArrayToken=(ArrayToken)data.get(0);
      int dataLengthInBytes=_encodedBytesPerInteger * dataIntArrayToken.length();
      dataBytes=new byte[dataLengthInBytes];
      for (int j=0; j < dataLengthInBytes; j+=_encodedBytesPerInteger) {
        IntToken dataIntOneToken=(IntToken)dataIntArrayToken.getElement(j);
        int oneIntValue=dataIntOneToken.intValue();
        if (_encodedBytesPerInteger == 1) {
          dataBytes[j]=(byte)oneIntValue;
        }
 else         if (_encodedBytesPerInteger == 4) {
          dataBytes[j]=(byte)(oneIntValue);
          dataBytes[j]=(byte)(oneIntValue >> 8);
          dataBytes[j]=(byte)(oneIntValue >> 16);
          dataBytes[j]=(byte)(oneIntValue >> 24);
        }
 else {
        }
      }
    }
 else {
      if (true)       System.out.println(""String_Node_Str"");
      throw new IllegalActionException(this,""String_Node_Str"" + _encoding);
    }
    DatagramPacket packet=new DatagramPacket(dataBytes,dataBytes.length,_address,_remoteSocketNumber);
    try {
      _socket.send(packet);
    }
 catch (    IOException ex) {
    }
    triggerOutput.broadcast(new Token());
  }
}","/** 
 * Does up to three things, in this order: Set new remote address value, Set new remote socket number, transmit data as a UDP packet over the ethernet.  The first two can, of course, affect where the datagram goes.  Any remote address/socket values supplied are saved and become the defaults for next time.
 */
public void fire() throws IllegalActionException {
  if (remoteAddress.getWidth() > 0 && remoteAddress.hasToken(0)) {
    String address=((StringToken)(remoteAddress.get(0))).stringValue();
    try {
      _address=InetAddress.getByName(address);
    }
 catch (    UnknownHostException ex) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
    }
  }
  if (remoteSocketNumber.getWidth() > 0 && remoteSocketNumber.hasToken(0)) {
    _remoteSocketNumber=65535 & ((IntToken)remoteSocketNumber.get(0)).intValue();
  }
  if (data.hasToken(0)) {
    byte[] dataBytes=new byte[0];
    if (_encodeForPtolemyParser) {
      dataBytes=data.get(0).toString().getBytes();
    }
 else     if (_encodeFromIntegerArray) {
      ArrayToken dataIntArrayToken=(ArrayToken)data.get(0);
      int dataLengthInBytes=_encodedBytesPerInteger * dataIntArrayToken.length();
      dataBytes=new byte[dataLengthInBytes];
      for (int j=0; j < dataIntArrayToken.length(); j++) {
        if (false) {
          System.out.println(""String_Node_Str"" + (null == dataIntArrayToken));
          System.out.println(""String_Node_Str"" + dataIntArrayToken.length());
          System.out.println(""String_Node_Str"" + j);
        }
        IntToken dataIntOneToken=(IntToken)dataIntArrayToken.getElement(j);
        int oneIntValue=dataIntOneToken.intValue();
        if (_encodedBytesPerInteger == 1) {
          dataBytes[j]=(byte)oneIntValue;
        }
 else         if (_encodedBytesPerInteger == 4) {
          int j4=j * _encodedBytesPerInteger;
          dataBytes[j4]=(byte)(oneIntValue);
          dataBytes[j4 + 1]=(byte)(oneIntValue >> 8);
          dataBytes[j4 + 2]=(byte)(oneIntValue >> 16);
          dataBytes[j4 + 3]=(byte)(oneIntValue >> 24);
        }
 else {
        }
      }
    }
 else {
      if (true)       System.out.println(""String_Node_Str"");
      throw new IllegalActionException(this,""String_Node_Str"" + _encoding);
    }
    DatagramPacket packet=new DatagramPacket(dataBytes,dataBytes.length,_address,_remoteSocketNumber);
    try {
      _socket.send(packet);
    }
 catch (    IOException ex) {
    }
    triggerOutput.broadcast(new Token());
  }
}"
75704,"/** 
 * Return false if the system has finished executing, either by reaching the iteration limit, or by having an actor in the model return false in postfire.
 * @return True if the execution is not finished.
 * @exception IllegalActionException If the iterations parameter doesnot have a valid token.
 */
public boolean postfire() throws IllegalActionException {
  int numberOfIterations=((IntToken)(iterations.getToken())).intValue();
  if (_debugging) {
    _debug(""String_Node_Str"" + _iterationCount);
  }
  _expectedNextIterationTime+=_unitTimeIncrement;
  if (_debugging) {
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  if ((numberOfIterations > 0) && (_iterationCount >= numberOfIterations)) {
    _iterationCount=0;
    return false;
  }
 else {
    if (_isEmbedded()) {
      _requestFiring();
    }
 else {
      setCurrentTime(_expectedNextIterationTime);
    }
  }
  return true;
}","/** 
 * Return false if the system has finished executing, either by reaching the iteration limit, or by having an actor in the model return false in postfire.
 * @return True if the execution is not finished.
 * @exception IllegalActionException If the iterations parameter doesnot have a valid token.
 */
public boolean postfire() throws IllegalActionException {
  int numberOfIterations=((IntToken)(iterations.getToken())).intValue();
  if (_debugging) {
    _debug(""String_Node_Str"" + _iterationCount);
  }
  _expectedNextIterationTime+=_unitTimeIncrement;
  if (_debugging) {
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  if ((numberOfIterations > 0) && (_iterationCount >= numberOfIterations)) {
    _iterationCount=0;
    if (_isEmbedded()) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    if (_isEmbedded()) {
      _requestFiring();
    }
 else {
      setCurrentTime(_expectedNextIterationTime);
    }
  }
  return true;
}"
75705,"/** 
 * Return true if the current time of the outside domain is greater than or equal to the current time.
 * @return True if the director is ready to run for one iteration.
 */
public boolean prefire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  if (_isEmbedded()) {
    setCurrentTime((((CompositeActor)getContainer()).getExecutiveDirector()).getCurrentTime());
  }
  Director upperDirector=((CompositeActor)getContainer()).getExecutiveDirector();
  if (upperDirector instanceof CTDirector) {
    if (Math.abs(getCurrentTime() - _expectedNextIterationTime) < ((CTDirector)upperDirector).getTimeResolution()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      return true;
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    return false;
  }
 else {
    if (getCurrentTime() < _expectedNextIterationTime) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      return false;
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    return true;
  }
}","/** 
 * Return true if the current time of the outside domain is greater than or equal to the current time.
 * @return True if the director is ready to run for one iteration.
 */
public boolean prefire() throws IllegalActionException {
  if (_isEmbedded()) {
    setCurrentTime((((CompositeActor)getContainer()).getExecutiveDirector()).getCurrentTime());
  }
  _expectedNextIterationTime=getCurrentTime();
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(""String_Node_Str"" + _expectedNextIterationTime);
  }
  Director upperDirector=((CompositeActor)getContainer()).getExecutiveDirector();
  if (upperDirector instanceof CTDirector) {
    if (Math.abs(getCurrentTime() - _expectedNextIterationTime) < ((CTDirector)upperDirector).getTimeResolution()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      return true;
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    return false;
  }
 else {
    if (getCurrentTime() < _expectedNextIterationTime) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      return false;
    }
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    return true;
  }
}"
75706,"/** 
 * Preinitialize this actor.  This method is used as a bookend with wrapup() being the other end.  Resources are allocated here and released in wrapup().  Create a new datagram socket and initialize the thread that reads from that socket.  Also create an evaluation variable <i>_evalVar</i>for the Ptolemy parser.  The thread will stay alive even if the socket is closed.  However, it terminates when the socket becomes null. Only wrapup() makes the socket null.
 * @exception IllegalActionException If the<i>localSocketNumber</i> parameter has a value outside 0..65535 or a socket could not be created.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  if (_debugging)   _debug(this + ""String_Node_Str"");
  _packetsAlreadyAwaitingFire=0;
  Variable var=(Variable)getAttribute(""String_Node_Str"");
  if (var == null) {
    try {
      var=new Variable(this,""String_Node_Str"");
    }
 catch (    NameDuplicationException ex) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  _evalVar=var;
  int portNumber=((IntToken)(localSocketNumber.getToken())).intValue();
  if (portNumber < 0 || portNumber > 65535) {
    throw new IllegalActionException(this,localSocketNumber + ""String_Node_Str"");
  }
  if (_debugging)   _debug(this + ""String_Node_Str"" + portNumber);
  try {
    if (false && _debugging) {
      _debug(""String_Node_Str"" + portNumber);
    }
    _socket=new DatagramSocket(portNumber);
    if (false && _debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  SocketException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex);
  }
  _listenerThread=new ListenerThread();
  _listenerThread.start();
  if (_debugging)   _debug(""String_Node_Str"");
  if (_debugging)   _debug(""String_Node_Str"");
  if (_debugging)   _debug(""String_Node_Str"");
}","/** 
 * Preinitialize this actor.  This method is used as a bookend with wrapup() being the other end.  Resources are allocated here and released in wrapup().  Create a new datagram socket and initialize the thread that reads from that socket.  Also create an evaluation variable <i>_evalVar</i>for the Ptolemy parser.  The thread will stay alive even if the socket is closed.  However, it terminates when the socket becomes null. Only wrapup() makes the socket null.
 * @exception IllegalActionException If the<i>localSocketNumber</i> parameter has a value outside 0..65535 or a socket could not be created.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  if (_debugging)   _debug(this + ""String_Node_Str"");
  _packetsAlreadyAwaitingFire=0;
  Variable var=(Variable)getAttribute(""String_Node_Str"");
  if (var == null) {
    try {
      var=new Variable(this,""String_Node_Str"");
    }
 catch (    NameDuplicationException ex) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  _evalVar=var;
  int portNumber=((IntToken)(localSocketNumber.getToken())).intValue();
  if (portNumber < 0 || portNumber > 65535) {
    throw new IllegalActionException(this,localSocketNumber + ""String_Node_Str"");
  }
  if (_debugging)   _debug(this + ""String_Node_Str"" + portNumber);
  try {
    if (false && _debugging) {
      _debug(""String_Node_Str"" + portNumber);
    }
    _socket=new DatagramSocket(portNumber);
    if (false && _debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  SocketException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex);
  }
  try {
    int socketSize=_socket.getReceiveBufferSize();
    System.out.println(""String_Node_Str"" + socketSize);
    if (platformBufferLength.getToken() != null) {
      _socket.setReceiveBufferSize(((IntToken)platformBufferLength.getToken()).intValue());
    }
    platformBufferLength.setToken(new IntToken(_socket.getReceiveBufferSize()));
    System.out.println(""String_Node_Str"" + _socket.getReceiveBufferSize());
  }
 catch (  SocketException sex) {
    System.out.println(""String_Node_Str"" + sex.toString());
  }
  _listenerThread=new ListenerThread();
  _listenerThread.start();
  if (_debugging)   _debug(""String_Node_Str"");
  if (_debugging)   _debug(""String_Node_Str"");
  if (_debugging)   _debug(""String_Node_Str"");
}"
75707,"/** 
 * React to a change of the given attribute.  Generally, this is called between firings of an actor.  However, this actor contains a separate thread of which the director is not aware. Any time the model is running, calls to this method typically happen while the thread is running.  Furthermore, the thread spends most of its time blocked in the DatagramSocket.receive() method or (if <i>overwrite</i> is false) waiting for fire() to notify it that space is available to receive another packet. Thus, some of the cases below will be given special handling.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute != _evalVar) {
    if (_debugging)     _debug(""String_Node_Str"" + attribute.toString().substring(28));
  }
  if (attribute == encoding) {
    if (!_encoding.equals(encoding.getExpression())) {
      _encoding=encoding.getExpression();
      if (_encoding.equals(""String_Node_Str"")) {
        _decodeWithPtolemyParser=true;
        _decodeToIntegerArray=false;
      }
 else       if (_encoding.equals(""String_Node_Str"")) {
        _decodeWithPtolemyParser=false;
        _decodeToIntegerArray=true;
        _decodedBytesPerInteger=1;
      }
 else       if (_encoding.equals(""String_Node_Str"")) {
        _decodeWithPtolemyParser=false;
        _decodeToIntegerArray=true;
        _decodedBytesPerInteger=4;
      }
 else {
        throw new IllegalActionException(this,""String_Node_Str"" + _encoding);
      }
      if (false) {
        if (_decodeWithPtolemyParser) {
          output.setTypeEquals(BaseType.GENERAL);
        }
 else         if (_decodeToIntegerArray) {
          output.setTypeEquals(new ArrayType(BaseType.INT));
        }
 else {
        }
      }
    }
  }
 else   if (attribute == defaultOutput) {
synchronized (_syncDefaultOutput) {
      _defaultOutputToken=defaultOutput.getToken();
      if (false)       System.out.println(_defaultOutputToken == null);
    }
  }
 else   if (attribute == overwrite) {
    _overwrite=((BooleanToken)(overwrite.getToken())).booleanValue();
    if (_overwrite) {
synchronized (_syncFireAndThread) {
        _syncFireAndThread.notifyAll();
      }
    }
  }
 else   if (attribute == blockAwaitingDatagram) {
    _blockAwaitingDatagram=((BooleanToken)(blockAwaitingDatagram.getToken())).booleanValue();
    if (!_blockAwaitingDatagram) {
synchronized (_syncFireAndThread) {
        _syncFireAndThread.notifyAll();
      }
    }
  }
 else   if (attribute == localSocketNumber) {
synchronized (this) {
      if (_socket != null) {
        if (_listenerThread == null) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
 else         if (!_listenerThread.isAlive()) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
        int newSktNum=((IntToken)(localSocketNumber.getToken())).intValue();
        if (newSktNum != _socket.getLocalPort()) {
synchronized (_syncSocket) {
            if (_inReceive) {
              try {
                _syncSocket.wait((long)444);
              }
 catch (              InterruptedException ex) {
                System.out.println(""String_Node_Str"");
                throw new IllegalActionException(this,""String_Node_Str"");
              }
            }
            _socket.close();
            try {
              _socket=new DatagramSocket(newSktNum);
            }
 catch (            SocketException ex) {
              System.out.println(""String_Node_Str"");
              throw new InternalErrorException(KernelException.stackTraceToString(ex));
            }
          }
        }
      }
    }
  }
 else   if (attribute == bufferLength) {
synchronized (_syncBufferLength) {
      _bufferLength=((IntToken)(bufferLength.getToken())).intValue();
    }
  }
 else {
    super.attributeChanged(attribute);
  }
  if (attribute != _evalVar) {
    if (_debugging)     _debug(this + ""String_Node_Str"");
    if (_debugging)     _debug(""String_Node_Str"" + attribute.toString().substring(28));
  }
}","/** 
 * React to a change of the given attribute.  Generally, this is called between firings of an actor.  However, this actor contains a separate thread of which the director is not aware. Any time the model is running, calls to this method typically happen while the thread is running.  Furthermore, the thread spends most of its time blocked in the DatagramSocket.receive() method or (if <i>overwrite</i> is false) waiting for fire() to notify it that space is available to receive another packet. Thus, some of the cases below will be given special handling.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute != _evalVar) {
    System.out.println(""String_Node_Str"" + attribute.toString().substring(28));
  }
  if (attribute == encoding) {
    if (!_encoding.equals(encoding.getExpression())) {
      _encoding=encoding.getExpression();
      if (_encoding.equals(""String_Node_Str"")) {
        _decodeWithPtolemyParser=true;
        _decodeToIntegerArray=false;
      }
 else       if (_encoding.equals(""String_Node_Str"")) {
        _decodeWithPtolemyParser=false;
        _decodeToIntegerArray=true;
        _decodedBytesPerInteger=1;
      }
 else       if (_encoding.equals(""String_Node_Str"")) {
        _decodeWithPtolemyParser=false;
        _decodeToIntegerArray=true;
        _decodedBytesPerInteger=4;
      }
 else {
        throw new IllegalActionException(this,""String_Node_Str"" + _encoding);
      }
      if (false) {
        if (_decodeWithPtolemyParser) {
          output.setTypeEquals(BaseType.GENERAL);
        }
 else         if (_decodeToIntegerArray) {
          output.setTypeEquals(new ArrayType(BaseType.INT));
        }
 else {
        }
      }
    }
  }
 else   if (attribute == defaultOutput) {
synchronized (_syncDefaultOutput) {
      _defaultOutputToken=defaultOutput.getToken();
      if (false)       System.out.println(_defaultOutputToken == null);
    }
  }
 else   if (attribute == overwrite) {
    _overwrite=((BooleanToken)(overwrite.getToken())).booleanValue();
    if (_overwrite) {
synchronized (_syncFireAndThread) {
        _syncFireAndThread.notifyAll();
      }
    }
  }
 else   if (attribute == blockAwaitingDatagram) {
    _blockAwaitingDatagram=((BooleanToken)(blockAwaitingDatagram.getToken())).booleanValue();
    if (!_blockAwaitingDatagram) {
synchronized (_syncFireAndThread) {
        _syncFireAndThread.notifyAll();
      }
    }
  }
 else   if (attribute == localSocketNumber) {
synchronized (this) {
      if (_socket != null) {
        if (_listenerThread == null) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
 else         if (!_listenerThread.isAlive()) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
        int newSktNum=((IntToken)(localSocketNumber.getToken())).intValue();
        if (newSktNum != _socket.getLocalPort()) {
synchronized (_syncSocket) {
            if (_inReceive) {
              try {
                _syncSocket.wait((long)444);
              }
 catch (              InterruptedException ex) {
                System.out.println(""String_Node_Str"");
                throw new IllegalActionException(this,""String_Node_Str"");
              }
            }
            _socket.close();
            try {
              _socket=new DatagramSocket(newSktNum);
            }
 catch (            SocketException ex) {
              System.out.println(""String_Node_Str"");
              throw new InternalErrorException(KernelException.stackTraceToString(ex));
            }
          }
        }
      }
    }
  }
 else   if (attribute == actorBufferLength) {
synchronized (_syncBufferLength) {
      _actorBufferLength=((IntToken)(actorBufferLength.getToken())).intValue();
    }
  }
 else   if (attribute == platformBufferLength && _socket != null) {
    if (platformBufferLength.getToken() != null) {
      int requestedValue=((IntToken)platformBufferLength.getToken()).intValue();
      int existingValue=0;
      try {
        System.out.println(""String_Node_Str"");
        existingValue=_socket.getReceiveBufferSize();
        System.out.println(""String_Node_Str"");
      }
 catch (      SocketException sex) {
        System.out.println(""String_Node_Str"" + sex.toString());
      }
      if (requestedValue != existingValue) {
        try {
          System.out.println(""String_Node_Str"");
          _socket.setReceiveBufferSize(requestedValue);
          System.out.println(""String_Node_Str"");
        }
 catch (        SocketException sex) {
          System.out.println(""String_Node_Str"" + sex.toString());
        }
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
  if (attribute != _evalVar) {
    if (_debugging)     _debug(this + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + attribute.toString().substring(28));
  }
}"
75708,"/** 
 * Run.  Run the thread.  This begins running when .start() is called on the thread.
 */
public void run(){
  while (true) {
synchronized (_syncBufferLength) {
      if (_receivePacket == null || _receiveAllocated != _bufferLength) {
        _receivePacket=new DatagramPacket(new byte[_bufferLength],0,_bufferLength);
        _receiveAllocated=_bufferLength;
      }
    }
    if (_broadcastPacket == null) {
synchronized (_syncBufferLength) {
        _broadcastPacket=new DatagramPacket(new byte[_bufferLength],0,_bufferLength);
        _broadcastAllocated=_bufferLength;
      }
    }
synchronized (_syncSocket) {
      _inReceive=true;
    }
    while (_inReceive) {
      _receivePacket.setLength(_bufferLength);
      try {
        _socket.receive(_receivePacket);
synchronized (_syncSocket) {
          _inReceive=false;
          _syncSocket.notifyAll();
        }
      }
 catch (      IOException ex) {
synchronized (_syncSocket) {
        }
      }
catch (      NullPointerException ex) {
        if (_debugging)         _debug(""String_Node_Str"" + (_socket == null));
        return;
      }
    }
    boolean fireAtWillBeCalled;
synchronized (_syncFireAndThread) {
      while (_packetsAlreadyAwaitingFire != 0 && !_overwrite) {
        try {
          _syncFireAndThread.wait();
        }
 catch (        InterruptedException ex) {
          System.out.println(""String_Node_Str"");
          System.out.println(ex.toString());
          throw new RuntimeException(""String_Node_Str"");
        }
      }
      DatagramPacket tmp=_broadcastPacket;
      _broadcastPacket=_receivePacket;
      _receivePacket=tmp;
      int tmpLength=_broadcastAllocated;
      _broadcastAllocated=_receiveAllocated;
      _receiveAllocated=tmpLength;
      if (_packetsAlreadyAwaitingFire != 0) {
        fireAtWillBeCalled=false;
      }
 else       if (_fireIsWaiting) {
        fireAtWillBeCalled=false;
        _syncFireAndThread.notifyAll();
        _packetsAlreadyAwaitingFire++;
      }
 else {
        fireAtWillBeCalled=true;
        _packetsAlreadyAwaitingFire++;
      }
    }
    if (fireAtWillBeCalled) {
      try {
        getDirector().fireAtCurrentTime(DatagramReader.this);
      }
 catch (      IllegalActionException ex) {
        System.out.println(this + ""String_Node_Str"");
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Run.  Run the thread.  This begins running when .start() is called on the thread.
 */
public void run(){
  while (true) {
synchronized (_syncBufferLength) {
      if (_receivePacket == null || _receiveAllocated != _actorBufferLength) {
        _receivePacket=new DatagramPacket(new byte[_actorBufferLength],0,_actorBufferLength);
        _receiveAllocated=_actorBufferLength;
      }
    }
    if (_broadcastPacket == null) {
synchronized (_syncBufferLength) {
        _broadcastPacket=new DatagramPacket(new byte[_actorBufferLength],0,_actorBufferLength);
        _broadcastAllocated=_actorBufferLength;
      }
    }
synchronized (_syncSocket) {
      _inReceive=true;
    }
    while (_inReceive) {
      _receivePacket.setLength(_actorBufferLength);
      try {
        _socket.receive(_receivePacket);
synchronized (_syncSocket) {
          _inReceive=false;
          _syncSocket.notifyAll();
        }
      }
 catch (      IOException ex) {
synchronized (_syncSocket) {
        }
      }
catch (      NullPointerException ex) {
        if (_debugging)         _debug(""String_Node_Str"" + (_socket == null));
        return;
      }
    }
    boolean fireAtWillBeCalled;
synchronized (_syncFireAndThread) {
      while (_packetsAlreadyAwaitingFire != 0 && !_overwrite) {
        try {
          _syncFireAndThread.wait();
        }
 catch (        InterruptedException ex) {
          System.out.println(""String_Node_Str"");
          System.out.println(ex.toString());
          throw new RuntimeException(""String_Node_Str"");
        }
      }
      DatagramPacket tmp=_broadcastPacket;
      _broadcastPacket=_receivePacket;
      _receivePacket=tmp;
      int tmpLength=_broadcastAllocated;
      _broadcastAllocated=_receiveAllocated;
      _receiveAllocated=tmpLength;
      if (_packetsAlreadyAwaitingFire != 0) {
        fireAtWillBeCalled=false;
      }
 else       if (_fireIsWaiting) {
        fireAtWillBeCalled=false;
        _syncFireAndThread.notifyAll();
        _packetsAlreadyAwaitingFire++;
      }
 else {
        fireAtWillBeCalled=true;
        _packetsAlreadyAwaitingFire++;
      }
    }
    if (fireAtWillBeCalled) {
      try {
        getDirector().fireAtCurrentTime(DatagramReader.this);
      }
 catch (      IllegalActionException ex) {
        System.out.println(this + ""String_Node_Str"");
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}"
75709,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DatagramReader(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  returnAddress=new TypedIOPort(this,""String_Node_Str"");
  returnAddress.setTypeEquals(BaseType.STRING);
  returnAddress.setOutput(true);
  returnSocketNumber=new TypedIOPort(this,""String_Node_Str"");
  returnSocketNumber.setTypeEquals(BaseType.INT);
  returnSocketNumber.setOutput(true);
  output=new TypedIOPort(this,""String_Node_Str"");
  output.setTypeEquals(BaseType.GENERAL);
  output.setOutput(true);
  trigger=new TypedIOPort(this,""String_Node_Str"",true,false);
  trigger.setTypeEquals(BaseType.GENERAL);
  trigger.setMultiport(true);
  localSocketNumber=new Parameter(this,""String_Node_Str"");
  localSocketNumber.setTypeEquals(BaseType.INT);
  localSocketNumber.setToken(new IntToken(4004));
  bufferLength=new Parameter(this,""String_Node_Str"");
  bufferLength.setTypeEquals(BaseType.INT);
  bufferLength.setToken(new IntToken(440));
  overwrite=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
  overwrite.setTypeEquals(BaseType.BOOLEAN);
  blockAwaitingDatagram=new Parameter(this,""String_Node_Str"");
  blockAwaitingDatagram.setTypeEquals(BaseType.BOOLEAN);
  blockAwaitingDatagram.setExpression(""String_Node_Str"");
  defaultOutput=new Parameter(this,""String_Node_Str"");
  defaultOutput.setTypeEquals(BaseType.GENERAL);
  defaultOutput.setExpression(""String_Node_Str"");
  encoding=new StringAttribute(this,""String_Node_Str"");
  encoding.setExpression(""String_Node_Str"");
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DatagramReader(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  returnAddress=new TypedIOPort(this,""String_Node_Str"");
  returnAddress.setTypeEquals(BaseType.STRING);
  returnAddress.setOutput(true);
  returnSocketNumber=new TypedIOPort(this,""String_Node_Str"");
  returnSocketNumber.setTypeEquals(BaseType.INT);
  returnSocketNumber.setOutput(true);
  output=new TypedIOPort(this,""String_Node_Str"");
  output.setTypeEquals(BaseType.GENERAL);
  output.setOutput(true);
  trigger=new TypedIOPort(this,""String_Node_Str"",true,false);
  trigger.setTypeEquals(BaseType.GENERAL);
  trigger.setMultiport(true);
  localSocketNumber=new Parameter(this,""String_Node_Str"");
  localSocketNumber.setTypeEquals(BaseType.INT);
  localSocketNumber.setToken(new IntToken(4004));
  actorBufferLength=new Parameter(this,""String_Node_Str"");
  actorBufferLength.setTypeEquals(BaseType.INT);
  actorBufferLength.setToken(new IntToken(440));
  platformBufferLength=new Parameter(this,""String_Node_Str"");
  platformBufferLength.setTypeEquals(BaseType.INT);
  overwrite=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
  overwrite.setTypeEquals(BaseType.BOOLEAN);
  blockAwaitingDatagram=new Parameter(this,""String_Node_Str"");
  blockAwaitingDatagram.setTypeEquals(BaseType.BOOLEAN);
  blockAwaitingDatagram.setExpression(""String_Node_Str"");
  defaultOutput=new Parameter(this,""String_Node_Str"");
  defaultOutput.setTypeEquals(BaseType.GENERAL);
  defaultOutput.setExpression(""String_Node_Str"");
  encoding=new StringAttribute(this,""String_Node_Str"");
  encoding.setExpression(""String_Node_Str"");
}"
75710,"public DatagramWriter(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  remoteAddress=new TypedIOPort(this,""String_Node_Str"");
  remoteAddress.setInput(true);
  remoteAddress.setMultiport(true);
  remoteAddress.setTypeEquals(BaseType.STRING);
  remoteSocketNumber=new TypedIOPort(this,""String_Node_Str"");
  remoteSocketNumber.setInput(true);
  remoteSocketNumber.setMultiport(true);
  remoteSocketNumber.setTypeEquals(BaseType.INT);
  data=new TypedIOPort(this,""String_Node_Str"");
  data.setInput(true);
  data.setTypeEquals(BaseType.GENERAL);
  defaultRemoteAddress=new StringAttribute(this,""String_Node_Str"");
  defaultRemoteAddress.setExpression(""String_Node_Str"");
  defaultRemoteSocketNumber=new Parameter(this,""String_Node_Str"");
  defaultRemoteSocketNumber.setTypeEquals(BaseType.INT);
  defaultRemoteSocketNumber.setExpression(""String_Node_Str"");
  localSocketNumber=new Parameter(this,""String_Node_Str"");
  localSocketNumber.setTypeEquals(BaseType.INT);
  localSocketNumber.setToken(new IntToken(4003));
  encoding=new StringAttribute(this,""String_Node_Str"");
  encoding.setExpression(""String_Node_Str"");
  triggerOutput=new TypedIOPort(this,""String_Node_Str"");
  triggerOutput.setTypeEquals(BaseType.GENERAL);
  triggerOutput.setOutput(true);
}","/** 
 * Construct a DatagramWriter actor with given name in the given container.  Set up ports, parameters and default values.  Two of the parameters are used in a funny way.  They give default values for the  <i>remoteAddress</i> and <i>remoteSocketNumber</i> ports in case no tokens are available there.
 * @param container The container.
 * @param name The name for this actor.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception IllegalActionException If the actor cannot be contained bythis container
 */
public DatagramWriter(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  remoteAddress=new TypedIOPort(this,""String_Node_Str"");
  remoteAddress.setInput(true);
  remoteAddress.setMultiport(true);
  remoteAddress.setTypeEquals(BaseType.STRING);
  remoteSocketNumber=new TypedIOPort(this,""String_Node_Str"");
  remoteSocketNumber.setInput(true);
  remoteSocketNumber.setMultiport(true);
  remoteSocketNumber.setTypeEquals(BaseType.INT);
  data=new TypedIOPort(this,""String_Node_Str"");
  data.setInput(true);
  data.setTypeEquals(BaseType.GENERAL);
  defaultRemoteAddress=new StringAttribute(this,""String_Node_Str"");
  defaultRemoteAddress.setExpression(""String_Node_Str"");
  defaultRemoteSocketNumber=new Parameter(this,""String_Node_Str"");
  defaultRemoteSocketNumber.setTypeEquals(BaseType.INT);
  defaultRemoteSocketNumber.setExpression(""String_Node_Str"");
  localSocketNumber=new Parameter(this,""String_Node_Str"");
  localSocketNumber.setTypeEquals(BaseType.INT);
  localSocketNumber.setToken(new IntToken(4003));
  encoding=new StringAttribute(this,""String_Node_Str"");
  encoding.setExpression(""String_Node_Str"");
  triggerOutput=new TypedIOPort(this,""String_Node_Str"");
  triggerOutput.setTypeEquals(BaseType.GENERAL);
  triggerOutput.setOutput(true);
}"
75711,"/** 
 * Consume the input token and the trigger token. The trigger token will be used for finding the zero crossing in the isThisStepAccurate() method to control the step size. The input token will be used in emitCurrentEvent() if the trigger is zero (within the given error tolerance). Notice that this method does not produce any output.
 * @exception IllegalActionException If no token is available.
 */
public void fire() throws IllegalActionException {
  CTDirector director=(CTDirector)getDirector();
  if (director.isDiscretePhase() && hasCurrentEvent()) {
    if (_debugging)     _debug(getFullName() + ""String_Node_Str"" + _inputToken.toString());
    if (_inputToken != null) {
      output.send(0,_inputToken);
    }
 else {
      output.send(0,defaultEventValue.getToken());
    }
    _eventNow=false;
  }
 else {
    _thisTrigger=((DoubleToken)trigger.get(0)).doubleValue();
    if (_debugging)     _debug(getFullName() + ""String_Node_Str"" + _thisTrigger);
    if ((input.getWidth() != 0) && input.hasToken(0)) {
      _inputToken=input.get(0);
    }
 else {
      _inputToken=null;
    }
  }
}","/** 
 * Consume the input token and the trigger token. The trigger token will be used for finding the zero crossing in the isThisStepAccurate() method to control the step size. The input token will be used in emitCurrentEvent() if the trigger is zero (within the given error tolerance). Notice that this method does not produce any output.
 * @exception IllegalActionException If no token is available.
 */
public void fire() throws IllegalActionException {
  CTDirector director=(CTDirector)getDirector();
  if (director.isDiscretePhase()) {
    if (hasCurrentEvent()) {
      if (_debugging)       _debug(getFullName() + ""String_Node_Str"" + _inputToken.toString());
      if (_inputToken != null) {
        output.send(0,_inputToken);
      }
 else {
        output.send(0,defaultEventValue.getToken());
      }
      _eventNow=false;
    }
  }
 else {
    _thisTrigger=((DoubleToken)trigger.get(0)).doubleValue();
    if (_debugging)     _debug(getFullName() + ""String_Node_Str"" + _thisTrigger);
    if ((input.getWidth() != 0) && input.hasToken(0)) {
      _inputToken=input.get(0);
    }
 else {
      _inputToken=null;
    }
  }
}"
75712,"/** 
 * Generate code for the modes.
 * @return The modes code.
 */
private String _modeCode(Actor modeContainer) throws IllegalActionException {
  String codeString=""String_Node_Str"";
  int actorFreq=0;
  int actFreq=0;
  int exitFreq=0;
  String outputName, actorName, modeName;
  Parameter period=((GiottoDirector)modeContainer.getDirector()).period;
  double periodValue=((DoubleToken)period.getToken()).doubleValue() * 1000;
  modeName=StringUtilities.sanitizeName(((NamedObj)modeContainer).getName());
  codeString+=""String_Node_Str"" + modeName + ""String_Node_Str""+ (new Double(periodValue)).intValue()+ ""String_Node_Str""+ _endLine;
  _outPorts=_container.outputPortList().iterator();
  while (_outPorts.hasNext()) {
    outputName=""String_Node_Str"";
    TypedIOPort port=(TypedIOPort)_outPorts.next();
    outputName=StringUtilities.sanitizeName(port.getName(_container));
    if (port.insidePortList().size() != 0) {
      Iterator portConnected=port.insidePortList().iterator();
      while (portConnected.hasNext()) {
        TypedIOPort outPort=(TypedIOPort)portConnected.next();
        if (!outPort.isOutput()) {
          continue;
        }
        Nameable actor=outPort.getContainer();
        if (actor instanceof Actor) {
          Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
          if (actorFreqPara == null) {
            actorFreq=1;
          }
 else {
            actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
          }
        }
        codeString+=""String_Node_Str"" + actorFreq + ""String_Node_Str""+ outputName+ ""String_Node_Str""+ outputName+ ""String_Node_Str""+ _endLine;
      }
    }
  }
  Iterator actors=_commActors.iterator();
  while (actors.hasNext()) {
    TypedActor actor=(TypedActor)actors.next();
    actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName(_container));
    Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
    if (actorFreqPara == null) {
      actorFreq=1;
    }
 else {
      actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
    }
    codeString+=""String_Node_Str"" + actorFreq + ""String_Node_Str""+ actorName+ ""String_Node_Str""+ ""String_Node_Str""+ actorName+ ""String_Node_Str""+ _endLine;
  }
  codeString+=""String_Node_Str"" + _endLine;
  return codeString;
}","/** 
 * Generate code for the modes.
 * @return The modes code.
 */
private String _modeCode() throws IllegalActionException {
  String codeString=""String_Node_Str"";
  int actorFreq=0;
  int actFreq=0;
  int exitFreq=0;
  String outputName, actorName, modeName;
  modeName=StringUtilities.sanitizeName(((NamedObj)_container).getName());
  int periodValue=((GiottoDirector)((CompositeActor)_container).getDirector()).getIntPeriod();
  codeString+=""String_Node_Str"" + modeName + ""String_Node_Str""+ periodValue+ ""String_Node_Str""+ _endLine;
  _outPorts=_container.outputPortList().iterator();
  while (_outPorts.hasNext()) {
    outputName=""String_Node_Str"";
    TypedIOPort port=(TypedIOPort)_outPorts.next();
    outputName=StringUtilities.sanitizeName(port.getName(_container));
    if (port.insidePortList().size() != 0) {
      Iterator portConnected=port.insidePortList().iterator();
      while (portConnected.hasNext()) {
        TypedIOPort outPort=(TypedIOPort)portConnected.next();
        if (!outPort.isOutput()) {
          continue;
        }
        Nameable actor=outPort.getContainer();
        if (actor instanceof Actor) {
          Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
          if (actorFreqPara == null) {
            actorFreq=1;
          }
 else {
            actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
          }
        }
        codeString+=""String_Node_Str"" + actorFreq + ""String_Node_Str""+ outputName+ ""String_Node_Str""+ outputName+ ""String_Node_Str""+ _endLine;
      }
    }
  }
  Iterator actors=_commActors.iterator();
  while (actors.hasNext()) {
    TypedActor actor=(TypedActor)actors.next();
    actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName(_container));
    Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
    if (actorFreqPara == null) {
      actorFreq=1;
    }
 else {
      actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
    }
    codeString+=""String_Node_Str"" + actorFreq + ""String_Node_Str""+ actorName+ ""String_Node_Str""+ ""String_Node_Str""+ actorName+ ""String_Node_Str""+ _endLine;
  }
  codeString+=""String_Node_Str"" + _endLine;
  return codeString;
}"
75713,"/** 
 * Generate Giotto code for the _container model.
 * @return The Giotto code.
 */
public String generateCode() throws IllegalActionException {
  try {
    generatedCode=""String_Node_Str"";
    _initialize();
    _currentDepth=depthInHierarchy();
    String containerName=_container.getName();
    generatedCode+=_sensorCode();
    generatedCode+=_actuatorCode();
    generatedCode+=_outputCode();
    generatedCode+=_tasksCode();
    generatedCode+=_driversCode();
    generatedCode+=""String_Node_Str"" + containerName + ""String_Node_Str""+ _endLine;
    if (_modeSwitchController != null) {
    }
 else {
      generatedCode+=_modeCode(_container);
    }
    generatedCode+=""String_Node_Str"" + _endLine;
  }
 catch (  IllegalActionException ex) {
    System.out.println(ex.getMessage());
    throw new IllegalActionException(ex.getMessage());
  }
  return generatedCode;
}","/** 
 * Generate Giotto code for the _container model.
 * @return The Giotto code.
 */
public String generateCode() throws IllegalActionException {
  try {
    generatedCode=""String_Node_Str"";
    if (!_initialize()) {
      return ""String_Node_Str"";
    }
    _currentDepth=depthInHierarchy();
    String containerName=_container.getName();
    generatedCode+=_sensorCode();
    generatedCode+=_actuatorCode();
    generatedCode+=_outputCode();
    generatedCode+=_tasksCode();
    generatedCode+=_driversCode();
    generatedCode+=""String_Node_Str"" + containerName + ""String_Node_Str""+ _endLine;
    generatedCode+=_modeCode();
    generatedCode+=""String_Node_Str"" + _endLine;
  }
 catch (  IllegalActionException ex) {
    System.out.println(ex.getMessage());
    throw new IllegalActionException(ex.getMessage());
  }
  return generatedCode;
}"
75714,"/** 
 * Topology analysis and initialization.
 */
private void _initialize() throws IllegalActionException {
  _commActors=new LinkedList();
  _modeList=new LinkedList();
  _container1=null;
  _modeSwitchController=null;
  Iterator actors=_container.deepEntityList().iterator();
  while (actors.hasNext()) {
    TypedActor actor=(TypedActor)actors.next();
    _commActors.addLast(actor);
  }
}","/** 
 * Topology analysis and initialization.
 * @ return Ture if in giotto domain, False if in other domains.
 */
private boolean _initialize() throws IllegalActionException {
  _commActors=new LinkedList();
  _modeList=new LinkedList();
  _container=(TypedCompositeActor)getContainer();
  Director director=((CompositeActor)_container).getDirector();
  if (!(director instanceof GiottoDirector))   return false;
  _modeSwitchController=null;
  Iterator actors=_container.deepEntityList().iterator();
  while (actors.hasNext()) {
    TypedActor actor=(TypedActor)actors.next();
    _commActors.addLast(actor);
  }
  return true;
}"
75715,"/** 
 * Construct a factory with the specified _container and name.
 * @param _container The _container.
 * @param name The name of the factory.
 * @exception IllegalActionException If the factory is not of anacceptable attribute for the _container.
 * @exception NameDuplicationException If the name coincides withan attribute already in the _container.
 */
public GiottoCodeGenerator(NamedObj _container,String name) throws IllegalActionException, NameDuplicationException {
  super(_container,name);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  new SingletonAttribute(this,""String_Node_Str"");
  new GiottoEditorFactory(this,""String_Node_Str"");
  this._container=(TypedCompositeActor)_container;
}","/** 
 * Construct a factory with the specified _container and name.
 * @param _container The _container.
 * @param name The name of the factory.
 * @exception IllegalActionException If the factory is not of anacceptable attribute for the _container.
 * @exception NameDuplicationException If the name coincides withan attribute already in the _container.
 */
public GiottoCodeGenerator(NamedObj _container,String name) throws IllegalActionException, NameDuplicationException {
  super(_container,name);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  new SingletonAttribute(this,""String_Node_Str"");
  new GiottoEditorFactory(this,""String_Node_Str"");
}"
75716,"/** 
 * Imeplementations of this method should return true if there is an event at the current time.
 * @return True if there is an event to emit now.
 */
public boolean hasCurrentEvent();","/** 
 * Implementations of this method should return true if there is an event at the current time.
 * @return True if there is an event to emit now.
 */
public boolean hasCurrentEvent();"
75717,"/** 
 * Override the base class and add the element to the Schedule. The reason of overriding this method is to use a more effiecient data structure to store the schedule.
 * @param element The scheduling element.
 */
public void add(ScheduleElement element){
  element.setParent(this);
  _incrementVersion();
  _schedule.add(element);
}","/** 
 * Override the base class and add the element to the Schedule. The reason of overriding this method is to use a more efficient data structure to store the schedule.
 * @param element The scheduling element.
 */
public void add(ScheduleElement element){
  element.setParent(this);
  _incrementVersion();
  _schedule.add(element);
}"
75718,"public Figure render(Object n){
  Location location=(Location)n;
  NamedObj object=(NamedObj)location.getContainer();
  Figure result=null;
  try {
    List iconList=object.attributeList(EditorIcon.class);
    if (iconList.size() == 0) {
      EditorIcon icon=new XMLIcon(object,""String_Node_Str"");
      result=icon.createFigure();
    }
 else     if (iconList.size() == 1) {
      EditorIcon icon=(EditorIcon)iconList.iterator().next();
      result=icon.createFigure();
    }
 else {
      Iterator icons=iconList.iterator();
      result=new CompositeFigure();
      while (icons.hasNext()) {
        EditorIcon icon=(EditorIcon)icons.next();
        ((CompositeFigure)result).add(icon.createFigure());
      }
    }
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(null,ex,""String_Node_Str"" + ""String_Node_Str"" + object + ""String_Node_Str""+ ""String_Node_Str"");
  }
  result.setToolTipText(object.getClass().getName());
  return result;
}","public Figure render(Object n){
  Location location=(Location)n;
  NamedObj object=(NamedObj)location.getContainer();
  Figure result=null;
  try {
    if (USE_CLASSFACTORYATTRIBUTE) {
      List classFactoryList=object.attributeList(VergilClassFactoryAttribute.class);
      Iterator classFactories=classFactoryList.iterator();
      result=new CompositeFigure();
      while (classFactories.hasNext()) {
        VergilClassFactoryAttribute classFactory=(VergilClassFactoryAttribute)classFactories.next();
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + classFactory);
        classFactory.instantiateWithDefaultContainerAndName();
      }
    }
    List iconList=object.attributeList(EditorIcon.class);
    if (iconList.size() == 0) {
      EditorIcon icon=new XMLIcon(object,""String_Node_Str"");
      result=icon.createFigure();
    }
 else     if (iconList.size() == 1) {
      EditorIcon icon=(EditorIcon)iconList.iterator().next();
      result=icon.createFigure();
    }
 else {
      Iterator icons=iconList.iterator();
      result=new CompositeFigure();
      while (icons.hasNext()) {
        EditorIcon icon=(EditorIcon)icons.next();
        ((CompositeFigure)result).add(icon.createFigure());
      }
    }
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(null,ex,""String_Node_Str"" + ""String_Node_Str"" + object + ""String_Node_Str""+ ""String_Node_Str"");
  }
  result.setToolTipText(object.getClass().getName());
  return result;
}"
75719,"/** 
 * Return a new node controller.  This base class returns an instance of IconController.  Derived classes can return some other class to customize the context menu.
 * @param controller The associated graph controller.
 * @return A new node controller.
 */
public NamedObjController create(GraphController controller){
  return new IconController(controller);
}","/** 
 * Return a new node controller.  This base class returns an instance of IconController.  Derived classes can return some other class to customize the context menu.
 * @param controller The associated graph controller.
 * @return A new node controller.
 */
public NamedObjController create(GraphController controller) throws IllegalActionException {
  if (!IconController.USE_CLASSFACTORYATTRIBUTE) {
    return new IconController(controller);
  }
  System.out.println(""String_Node_Str"" + controller + ""String_Node_Str"");
  Object[] args=new Object[1];
  args[0]=controller;
  return (NamedObjController)instantiate(args);
}"
75720,"/** 
 * Construct an attribute with the given name contained by the specified container. The container argument must not be null, or a NullPointerException will be thrown.  This attribute will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. The object is added to the directory of the workspace if the container is null. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container, or if the name contains a period.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public VergilClassFactoryAttribute(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","/** 
 * Construct an attribute with the given name contained by the specified container. The container argument must not be null, or a NullPointerException will be thrown.  This attribute will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. The object is added to the directory of the workspace if the container is null. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container, or if the name contains a period.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public VergilClassFactoryAttribute(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  System.out.println(""String_Node_Str"" + container + ""String_Node_Str""+ name+ ""String_Node_Str"");
}"
75721,"/** 
 * Initialize the execution.
 * @exception IllegalActionException If thrown by the super class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _first=true;
  _eventNow=false;
  if (_debugging)   _debug(getFullName() + ""String_Node_Str"");
}","/** 
 * Initialize the execution.
 * @exception IllegalActionException If thrown by the super class.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _first=true;
  _eventMissed=false;
  _enabled=false;
  _eventNow=false;
  if (_debugging)   _debug(getFullName() + ""String_Node_Str"");
}"
75722,"/** 
 * If the argument is the <i>reflectionCoefficients</i> parameter, then reallocate the arrays to use.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the base class throws it.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == reflectionCoefficients) {
    ArrayToken value=(ArrayToken)reflectionCoefficients.getToken();
    int valueLength=value.length();
    if (valueLength != _backward.length - 1) {
      _backward=new double[valueLength + 1];
      _forward=new double[valueLength + 1];
      _reflectionCoefs=new double[valueLength];
    }
    for (int i=0; i < valueLength; i++) {
      _reflectionCoefs[i]=((DoubleToken)value.getElement(i)).doubleValue();
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the argument is the <i>reflectionCoefficients</i> parameter, then reallocate the arrays to use.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the base class throws it.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == reflectionCoefficients) {
    ArrayToken value=(ArrayToken)reflectionCoefficients.getToken();
    int valueLength=value.length();
    if (_backward == null || valueLength != _backward.length - 1) {
      _backward=new double[valueLength + 1];
      _backwardCache=new double[valueLength + 1];
      _forward=new double[valueLength + 1];
      _forwardCache=new double[valueLength + 1];
      _reflectionCoefs=new double[valueLength];
    }
    for (int i=0; i < valueLength; i++) {
      _reflectionCoefs[i]=((DoubleToken)value.getElement(i)).doubleValue();
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75723,"/** 
 * Consume one input token, if there is one, and produce one output token.  If there is no input, the produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    DoubleToken in=(DoubleToken)input.get(0);
    double k;
    int M=_backward.length - 1;
    _forward[0]=in.doubleValue();
    for (int i=1; i <= M; i++) {
      k=_reflectionCoefs[M - i];
      _forward[i]=k * _backward[i] + _forward[i - 1];
    }
    output.broadcast(new DoubleToken(_forward[M]));
    for (int i=1; i < M; i++) {
      k=-_reflectionCoefs[M - 1 - i];
      _backward[i]=_backward[i + 1] + k * _forward[i + 1];
    }
    _backward[M]=_forward[M];
  }
}","/** 
 * Consume one input token, if there is one, and produce one output token.  If there is no input, then produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  if (input.hasToken(0)) {
    DoubleToken inputValue=(DoubleToken)input.get(0);
    double k;
    int M=_backward.length - 1;
    _forwardCache[0]=inputValue.doubleValue();
    for (int i=1; i <= M; i++) {
      k=_reflectionCoefs[M - i];
      _forwardCache[i]=k * _backwardCache[i] + _forwardCache[i - 1];
    }
    output.broadcast(new DoubleToken(_forwardCache[M]));
    for (int i=1; i < M; i++) {
      k=-_reflectionCoefs[M - 1 - i];
      _backwardCache[i]=_backwardCache[i + 1] + k * _forwardCache[i + 1];
    }
    _backwardCache[M]=_forwardCache[M];
  }
}"
75724,"/** 
 * Return a new array that is formed by applying an instance of a ComplexUnaryOperation to each element in the input matrix (op.operate(matrix[i][j])).
 */
public static final Complex[][] applyUnaryOperation(final ComplexUnaryOperation op,final Complex[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  Complex[][] returnValue=new Complex[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=op.operate(matrix[i][j]);
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by applying an instance of a ComplexUnaryOperation to each element in the input matrix (op.operate(matrix[i][j])).
 */
public static final Complex[][] applyUnaryOperation(final ComplexUnaryOperation op,final Complex[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  Complex[][] returnValue=new Complex[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=op.operate(matrix[i][j]);
    }
  }
  return returnValue;
}"
75725,"/** 
 * Return a new array that is formed by applying an instance of a ComplexBinaryOperation to the two matrices, element by element, using the elements of the first matrix as the left operands and the elements of the second matrix as the right operands. (op.operate(matrix1[i][j], matrix2[i][j])). If the matrices are not the same size, throw an IllegalArgumentException.
 */
public static final Complex[][] applyBinaryOperation(ComplexBinaryOperation op,final Complex[][] matrix1,final Complex[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  Complex[][] returnValue=new Complex[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=op.operate(matrix1[i][j],matrix2[i][j]);
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by applying an instance of a ComplexBinaryOperation to the two matrices, element by element, using the elements of the first matrix as the left operands and the elements of the second matrix as the right operands. (op.operate(matrix1[i][j], matrix2[i][j])). If the matrices are not the same size, throw an IllegalArgumentException.
 */
public static final Complex[][] applyBinaryOperation(ComplexBinaryOperation op,final Complex[][] matrix1,final Complex[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  Complex[][] returnValue=new Complex[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=op.operate(matrix1[i][j],matrix2[i][j]);
    }
  }
  return returnValue;
}"
75726,"/** 
 * Return the determinate of a square matrix. If the matrix is not square, throw an IllegalArgumentException. This algorithm uses LU decomposition, and is taken from [1]
 */
public static final double determinate(final double[][] matrix){
  _checkSquare(""String_Node_Str"",matrix);
  double[][] a;
  double det=1.0;
  int n=_rows(matrix);
  a=allocCopy(matrix);
  for (int pivot=0; pivot < n - 1; pivot++) {
    double big=Math.abs(a[pivot][pivot]);
    int swapRow=0;
    for (int row=pivot + 1; row < n; row++) {
      double absElement=Math.abs(a[row][pivot]);
      if (absElement > big) {
        swapRow=row;
        big=absElement;
      }
    }
    if (swapRow != 0) {
      double[] aPtr=a[pivot];
      a[pivot]=a[swapRow];
      a[swapRow]=aPtr;
      det*=-a[pivot][pivot];
    }
 else {
      det*=a[pivot][pivot];
    }
    if (Math.abs(det) <= 1E-50) {
      return det;
    }
    double pivotInverse=1.0 / a[pivot][pivot];
    for (int col=pivot + 1; col < n; col++) {
      a[pivot][col]*=pivotInverse;
    }
    for (int row=pivot + 1; row < n; row++) {
      double temp=a[row][pivot];
      for (int col=pivot + 1; col < n; col++) {
        a[row][col]-=a[pivot][col] * temp;
      }
    }
  }
  det*=a[n - 1][n - 1];
  return det;
}","/** 
 * Return the determinate of a square matrix. If the matrix is not square, throw an IllegalArgumentException. This algorithm uses LU decomposition, and is taken from [1]
 */
public static final double determinate(final double[][] matrix){
  _checkSquare(""String_Node_Str"",matrix);
  double[][] a;
  double det=1.0;
  int n=_rows(matrix);
  a=allocCopy(matrix);
  for (int pivot=0; pivot < n - 1; pivot++) {
    double big=Math.abs(a[pivot][pivot]);
    int swapRow=0;
    for (int row=pivot + 1; row < n; row++) {
      double absElement=Math.abs(a[row][pivot]);
      if (absElement > big) {
        swapRow=row;
        big=absElement;
      }
    }
    if (swapRow != 0) {
      double[] aPtr=a[pivot];
      a[pivot]=a[swapRow];
      a[swapRow]=aPtr;
      det*=-a[pivot][pivot];
    }
 else {
      det*=a[pivot][pivot];
    }
    if (Math.abs(det) <= Complex.epsilon) {
      return det;
    }
    double pivotInverse=1.0 / a[pivot][pivot];
    for (int col=pivot + 1; col < n; col++) {
      a[pivot][col]*=pivotInverse;
    }
    for (int row=pivot + 1; row < n; row++) {
      double temp=a[row][pivot];
      for (int col=pivot + 1; col < n; col++) {
        a[row][col]-=a[pivot][col] * temp;
      }
    }
  }
  det*=a[n - 1][n - 1];
  return det;
}"
75727,"/** 
 * Replace the first matrix argument's values, in the specified row and column range, with the second matrix argument's values, starting from specified row and column of the second matrix.
 * @param srcMatrix A matrix of doubles, used as the destination.
 * @param srcRowStart An int specifying the starting row of the source.
 * @param srcColStart An int specifying the starting column of thesource.
 * @param destMatrix A matrix of doubles, used as the destination.
 * @param destRowStart An int specifying the starting row of the dest.
 * @param destColStart An int specifying the starting column of thedest.
 * @param rowSpan An int specifying how many rows to copy.
 * @param colSpan An int specifying how many columns to copy.
 */
public static final void matrixCopy(final double[][] srcMatrix,final int srcRowStart,final int srcColStart,final double[][] destMatrix,final int destRowStart,final int destColStart,final int rowSpan,final int colSpan){
  for (int i=0; i < rowSpan; i++) {
    System.arraycopy(srcMatrix[srcRowStart + i],srcColStart,destMatrix[destRowStart + i],destColStart,colSpan);
  }
}","/** 
 * Replace the destinationMatrix argument's values, in the specified row and column range, with the sourceMatrix argument's values, starting from specified row and column of the second matrix.
 * @param sourceMatrix A matrix of doubles, used as the destination.
 * @param sourceRowStart An int specifying the starting row of the source.
 * @param sourceColStart An int specifying the starting column of thesource.
 * @param destinationMatrix A matrix of doubles, used as the destination.
 * @param destinationRowStart An int specifying the starting row of thedestination. 
 * @param destinationColumnStart An int specifying the starting columnof the destination.
 * @param rowSpan An int specifying how many rows to copy.
 * @param columnSpan An int specifying how many columns to copy.
 */
public static final void matrixCopy(final double[][] sourceMatrix,final int sourceRowStart,final int sourceColStart,final double[][] destinationMatrix,final int destinationRowStart,final int destinationColumnStart,final int rowSpan,final int columnSpan){
  for (int i=0; i < rowSpan; i++) {
    System.arraycopy(sourceMatrix[sourceRowStart + i],sourceColStart,destinationMatrix[destinationRowStart + i],destinationColumnStart,columnSpan);
  }
}"
75728,"/** 
 * Return a new array that is formed by applying an instance of a FloatUnaryOperation to each element in the input matrix (op.operate(matrix[i][j])).
 */
public static final float[][] applyUnaryOperation(final FloatUnaryOperation op,final float[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  float[][] returnValue=new float[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=op.operate(matrix[i][j]);
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by applying an instance of a FloatUnaryOperation to each element in the input matrix (op.operate(matrix[i][j])).
 */
public static final float[][] applyUnaryOperation(final FloatUnaryOperation op,final float[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  float[][] returnValue=new float[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=op.operate(matrix[i][j]);
    }
  }
  return returnValue;
}"
75729,"/** 
 * Return a new array that is formed by applying an instance of a FloatBinaryOperation to the two matrices, element by element, using the elements of the first matrix as the left operands and the elements of the second matrix as the right operands. (op.operate(matrix1[i][j], matrix2[i][j])).  If the matrices are not the same size, throw an IllegalArgumentException.
 */
public static final float[][] applyBinaryOperation(FloatBinaryOperation op,final float[][] matrix1,final float[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  float[][] returnValue=new float[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=op.operate(matrix1[i][j],matrix2[i][j]);
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by applying an instance of a FloatBinaryOperation to the two matrices, element by element, using the elements of the first matrix as the left operands and the elements of the second matrix as the right operands. (op.operate(matrix1[i][j], matrix2[i][j])).  If the matrices are not the same size, throw an IllegalArgumentException.
 */
public static final float[][] applyBinaryOperation(FloatBinaryOperation op,final float[][] matrix1,final float[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  float[][] returnValue=new float[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=op.operate(matrix1[i][j],matrix2[i][j]);
    }
  }
  return returnValue;
}"
75730,"/** 
 * Return a new array that formed by the bitwise complement of each element in the input matrix (~matrix[i][j]).
 */
public static final int[][] bitwiseComplement(final int[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=~matrix[i][j];
    }
  }
  return returnValue;
}","/** 
 * Return a new array that formed by the bitwise complement of each element in the input matrix (~matrix[i][j]).
 */
public static final int[][] bitwiseComplement(final int[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=~matrix[i][j];
    }
  }
  return returnValue;
}"
75731,"/** 
 * Return a new array that is the element-by-element bitwise XOR of the two input matrices (matrix1[i][j] & matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final int[][] bitwiseXor(final int[][] matrix1,final int[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=matrix1[i][j] ^ matrix2[i][j];
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is the element-by-element bitwise XOR of the two input matrices (matrix1[i][j] & matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final int[][] bitwiseXor(final int[][] matrix1,final int[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=matrix1[i][j] ^ matrix2[i][j];
    }
  }
  return returnValue;
}"
75732,"/** 
 * Return a new array that is formed by applying an instance of a IntegerUnaryOperation to each element in the input matrix (op.operate(matrix[i][j])).
 */
public static final int[][] applyUnaryOperation(final IntegerUnaryOperation op,final int[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=op.operate(matrix[i][j]);
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by applying an instance of a IntegerUnaryOperation to each element in the input matrix (op.operate(matrix[i][j])).
 */
public static final int[][] applyUnaryOperation(final IntegerUnaryOperation op,final int[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=op.operate(matrix[i][j]);
    }
  }
  return returnValue;
}"
75733,"/** 
 * Return a new array that is the element-by-element bitwise AND of the two input matrices (matrix1[i][j] & matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final int[][] bitwiseAnd(final int[][] matrix1,final int[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=matrix1[i][j] & matrix2[i][j];
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is the element-by-element bitwise AND of the two input matrices (matrix1[i][j] & matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final int[][] bitwiseAnd(final int[][] matrix1,final int[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=matrix1[i][j] & matrix2[i][j];
    }
  }
  return returnValue;
}"
75734,"/** 
 * Return a new array that is formed by applying an instance of a IntegerBinaryOperation to the two matrices, element by element, using the elements of the first matrix as the left operands and the elements of the second matrix as the right operands.  (op.operate(matrix1[i][j], matrix2[i][j])).  If the matrices are not the same size, throw an IllegalArgumentException.
 */
public static final int[][] applyBinaryOperation(IntegerBinaryOperation op,final int[][] matrix1,final int[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=op.operate(matrix1[i][j],matrix2[i][j]);
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by applying an instance of a IntegerBinaryOperation to the two matrices, element by element, using the elements of the first matrix as the left operands and the elements of the second matrix as the right operands.  (op.operate(matrix1[i][j], matrix2[i][j])).  If the matrices are not the same size, throw an IllegalArgumentException.
 */
public static final int[][] applyBinaryOperation(IntegerBinaryOperation op,final int[][] matrix1,final int[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=op.operate(matrix1[i][j],matrix2[i][j]);
    }
  }
  return returnValue;
}"
75735,"/** 
 * Return a new array that is the element-by-element bitwise OR of the two input matrices (matrix1[i][j] | matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final int[][] bitwiseOr(final int[][] matrix1,final int[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=matrix1[i][j] | matrix2[i][j];
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is the element-by-element bitwise OR of the two input matrices (matrix1[i][j] | matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final int[][] bitwiseOr(final int[][] matrix1,final int[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  int[][] returnValue=new int[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=matrix1[i][j] | matrix2[i][j];
    }
  }
  return returnValue;
}"
75736,"/** 
 * Return a new array that formed by the bitwise complement of each element in the input matrix (~matrix[i][j]).
 */
public static final long[][] bitwiseComplement(final long[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=~matrix[i][j];
    }
  }
  return returnValue;
}","/** 
 * Return a new array that formed by the bitwise complement of each element in the input matrix (~matrix[i][j]).
 */
public static final long[][] bitwiseComplement(final long[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=~matrix[i][j];
    }
  }
  return returnValue;
}"
75737,"/** 
 * Return a new array that is the element-by-element bitwise XOR of the two input matrices (matrix1[i][j] & matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final long[][] bitwiseXor(final long[][] matrix1,final long[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=matrix1[i][j] ^ matrix2[i][j];
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is the element-by-element bitwise XOR of the two input matrices (matrix1[i][j] & matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final long[][] bitwiseXor(final long[][] matrix1,final long[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=matrix1[i][j] ^ matrix2[i][j];
    }
  }
  return returnValue;
}"
75738,"/** 
 * Return a new array that is formed by applying an instance of a LongUnaryOperation to each element in the input matrix (op.operate(matrix[i][j])).
 */
public static final long[][] applyUnaryOperation(final LongUnaryOperation op,final long[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=op.operate(matrix[i][j]);
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by applying an instance of a LongUnaryOperation to each element in the input matrix (op.operate(matrix[i][j])).
 */
public static final long[][] applyUnaryOperation(final LongUnaryOperation op,final long[][] matrix){
  int rows=_rows(matrix);
  int columns=_columns(matrix);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=op.operate(matrix[i][j]);
    }
  }
  return returnValue;
}"
75739,"/** 
 * Return a new array that is the element-by-element bitwise AND of the two input matrices (matrix1[i][j] & matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final long[][] bitwiseAnd(final long[][] matrix1,final long[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=matrix1[i][j] & matrix2[i][j];
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is the element-by-element bitwise AND of the two input matrices (matrix1[i][j] & matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final long[][] bitwiseAnd(final long[][] matrix1,final long[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=matrix1[i][j] & matrix2[i][j];
    }
  }
  return returnValue;
}"
75740,"/** 
 * Return a new array that is formed by applying an instance of a LongBinaryOperation to the two matrices, element by element, using the elements of the first matrix as the left operands and the elements of the second matrix as the right operands. (op.operate(matrix1[i][j], matrix2[i][j])).  If the matrices are not the same size, throw an IllegalArgumentException.
 */
public static final long[][] applyBinaryOperation(LongBinaryOperation op,final long[][] matrix1,final long[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=op.operate(matrix1[i][j],matrix2[i][j]);
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is formed by applying an instance of a LongBinaryOperation to the two matrices, element by element, using the elements of the first matrix as the left operands and the elements of the second matrix as the right operands. (op.operate(matrix1[i][j], matrix2[i][j])).  If the matrices are not the same size, throw an IllegalArgumentException.
 */
public static final long[][] applyBinaryOperation(LongBinaryOperation op,final long[][] matrix1,final long[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=op.operate(matrix1[i][j],matrix2[i][j]);
    }
  }
  return returnValue;
}"
75741,"/** 
 * Return a new array that is the element-by-element bitwise OR of the two input matrices (matrix1[i][j] | matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final long[][] bitwiseOr(final long[][] matrix1,final long[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; i < columns; j++) {
      returnValue[i][j]=matrix1[i][j] | matrix2[i][j];
    }
  }
  return returnValue;
}","/** 
 * Return a new array that is the element-by-element bitwise OR of the two input matrices (matrix1[i][j] | matrix2[i][j]).  If the two matrices are not the same size, throw an IllegalArgumentException.
 */
public static final long[][] bitwiseOr(final long[][] matrix1,final long[][] matrix2){
  int rows=_rows(matrix1);
  int columns=_columns(matrix1);
  _checkSameDimension(""String_Node_Str"",matrix1,matrix2);
  long[][] returnValue=new long[rows][columns];
  for (int i=0; i < rows; i++) {
    for (int j=0; j < columns; j++) {
      returnValue[i][j]=matrix1[i][j] | matrix2[i][j];
    }
  }
  return returnValue;
}"
75742,"/** 
 * Advance current time to the next event in the event queue, and fire one or more actors that have events at that time. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the time stamp of the event. Each actor is iterated repeatedly (prefire(), fire(), postfire()), until either it has no more input tokens at the current time, or its prefire() method returns false. If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter.  If it is false, then this thread will stall until events become available on the event queue.  Otherwise, time will advance to the stop time and the execution will halt.
 * @exception IllegalActionException If the firing actor throws it.
 */
public void fire() throws IllegalActionException {
  while (true) {
    _stopRequested=false;
    Actor actorToFire=_dequeueEvents();
    if (actorToFire == null) {
      if (_debugging)       _debug(""String_Node_Str"");
      _noMoreActorsToFire=true;
      return;
    }
    if (actorToFire == getContainer()) {
      return;
    }
    boolean refire;
    do {
      refire=false;
      if (_debugging) {
        if (((Nameable)actorToFire).getContainer() == null) {
          _debug(""String_Node_Str"");
          _disableActor(actorToFire);
          break;
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
        if (!actorToFire.prefire()) {
          _debug(""String_Node_Str"");
          break;
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
        actorToFire.fire();
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
        if (!actorToFire.postfire()) {
          _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
          _disableActor(actorToFire);
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
      }
 else {
        if (((Nameable)actorToFire).getContainer() == null) {
          _disableActor(actorToFire);
          break;
        }
        if (!actorToFire.prefire()) {
          break;
        }
        actorToFire.fire();
        if (!actorToFire.postfire()) {
          _disableActor(actorToFire);
        }
      }
      Iterator inputPorts=actorToFire.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort port=(IOPort)inputPorts.next();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.hasToken(i)) {
            refire=true;
            break;
          }
        }
        if (refire == true)         break;
      }
    }
 while (refire);
synchronized (_eventQueue) {
      if (!_eventQueue.isEmpty()) {
        DEEvent next=_eventQueue.get();
        if (next.timeStamp() > getCurrentTime()) {
          break;
        }
 else         if (next.timeStamp() < getCurrentTime()) {
          throw new InternalErrorException(""String_Node_Str"" + next.timeStamp() + ""String_Node_Str""+ ""String_Node_Str""+ getCurrentTime()+ ""String_Node_Str"");
        }
      }
 else {
        break;
      }
    }
  }
}","/** 
 * Advance current time to the next event in the event queue, and fire one or more actors that have events at that time. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the time stamp of the event. Each actor is iterated repeatedly (prefire(), fire(), postfire()), until either it has no more input tokens at the current time, or its prefire() method returns false. If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter.  If it is false, then this thread will stall until events become available on the event queue.  Otherwise, time will advance to the stop time and the execution will halt.
 * @exception IllegalActionException If the firing actor throws it.
 */
public void fire() throws IllegalActionException {
  _stopRequested=false;
  while (true) {
    Actor actorToFire=_dequeueEvents();
    if (actorToFire == null) {
      if (_debugging)       _debug(""String_Node_Str"");
      _noMoreActorsToFire=true;
      return;
    }
    if (actorToFire == getContainer()) {
      return;
    }
    boolean refire;
    do {
      refire=false;
      if (_debugging) {
        if (((Nameable)actorToFire).getContainer() == null) {
          _debug(""String_Node_Str"");
          _disableActor(actorToFire);
          break;
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
        if (!actorToFire.prefire()) {
          _debug(""String_Node_Str"");
          break;
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
        actorToFire.fire();
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
        _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
        if (!actorToFire.postfire()) {
          _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
          _disableActor(actorToFire);
        }
        _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
      }
 else {
        if (((Nameable)actorToFire).getContainer() == null) {
          _disableActor(actorToFire);
          break;
        }
        if (!actorToFire.prefire()) {
          break;
        }
        actorToFire.fire();
        if (!actorToFire.postfire()) {
          _disableActor(actorToFire);
        }
      }
      Iterator inputPorts=actorToFire.inputPortList().iterator();
      while (inputPorts.hasNext()) {
        IOPort port=(IOPort)inputPorts.next();
        for (int i=0; i < port.getWidth(); i++) {
          if (port.hasToken(i)) {
            refire=true;
            break;
          }
        }
        if (refire == true)         break;
      }
    }
 while (refire);
synchronized (_eventQueue) {
      if (!_eventQueue.isEmpty()) {
        DEEvent next=_eventQueue.get();
        if (next.timeStamp() > getCurrentTime()) {
          break;
        }
 else         if (next.timeStamp() < getCurrentTime()) {
          throw new InternalErrorException(""String_Node_Str"" + next.timeStamp() + ""String_Node_Str""+ ""String_Node_Str""+ getCurrentTime()+ ""String_Node_Str"");
        }
      }
 else {
        break;
      }
    }
  }
}"
75743,"/** 
 * Dequeue the events from the event queue that have the smallest time stamp and depth. Advance the model time to their time stamp, and mark the destination actor for firing. If the time stamp is greater than the stop time then return null. If there are no events on the event queue, and _stopWhenQueueIsEmpty flag is true (which is set to true by default) then return null, which will have the effect of stopping the simulation. If _stopWhenQueueIsEmpty is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are events available.  If _synchronizeToRealTime is true, then this method may suspend the calling thread using Object.wait(long) to let elapsed real time catch up with the current event.
 * @return The next actor to fire.
 */
protected Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  if (_eventQueue == null)   return null;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Thread.currentThread().yield();
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
synchronized (_eventQueue) {
          if (_eventQueue.isEmpty()) {
            try {
              if (_debugging) {
                _debug(""String_Node_Str"");
              }
              _eventQueue.wait();
              if (_debugging) {
                _debug(""String_Node_Str"");
              }
            }
 catch (            InterruptedException e) {
              if (_debugging) {
                _debug(""String_Node_Str"" + ""String_Node_Str"");
              }
              break;
            }
catch (            Exception e) {
              if (_debugging) {
                _debug(""String_Node_Str"");
              }
            }
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      double currentTime;
      if (!_synchronizeToRealTime) {
        currentEvent=(DEEvent)_eventQueue.get();
        currentTime=currentEvent.timeStamp();
      }
 else {
synchronized (_eventQueue) {
          while (true) {
            currentEvent=(DEEvent)_eventQueue.get();
            currentTime=currentEvent.timeStamp();
            long elapsedTime=System.currentTimeMillis() - _realStartTime;
            double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
            if (currentTime <= elapsedTimeInSeconds) {
              break;
            }
            long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
            if (timeToWait > 0) {
              if (_debugging) {
                _debug(""String_Node_Str"" + timeToWait);
              }
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
synchronized (_eventQueue) {
        currentEvent=(DEEvent)_eventQueue.take();
        currentTime=currentEvent.timeStamp();
        actorToFire=currentEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging)           _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          actorToFire=null;
          continue;
        }
        try {
          setCurrentTime(currentTime);
        }
 catch (        IllegalActionException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getFullName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}","/** 
 * Dequeue the events from the event queue that have the smallest time stamp and depth. Advance the model time to their time stamp, and mark the destination actor for firing. If the time stamp is greater than the stop time then return null. If there are no events on the event queue, and _stopWhenQueueIsEmpty flag is true (which is set to true by default) then return null, which will have the effect of stopping the simulation. If _stopWhenQueueIsEmpty is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are events available.  If _synchronizeToRealTime is true, then this method may suspend the calling thread using Object.wait(long) to let elapsed real time catch up with the current event.
 * @return The next actor to fire.
 */
protected Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  if (_eventQueue == null)   return null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Thread.currentThread().yield();
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
synchronized (_eventQueue) {
          if (_eventQueue.isEmpty()) {
            try {
              if (_debugging) {
                _debug(""String_Node_Str"");
              }
              _eventQueue.wait();
              if (_debugging) {
                _debug(""String_Node_Str"");
              }
            }
 catch (            InterruptedException e) {
              if (_debugging) {
                _debug(""String_Node_Str"" + ""String_Node_Str"");
              }
              break;
            }
catch (            Exception e) {
              if (_debugging) {
                _debug(""String_Node_Str"");
              }
            }
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      double currentTime;
      if (!_synchronizeToRealTime) {
        currentEvent=(DEEvent)_eventQueue.get();
        currentTime=currentEvent.timeStamp();
      }
 else {
synchronized (_eventQueue) {
          while (true) {
            currentEvent=(DEEvent)_eventQueue.get();
            currentTime=currentEvent.timeStamp();
            long elapsedTime=System.currentTimeMillis() - _realStartTime;
            double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
            if (currentTime <= elapsedTimeInSeconds) {
              break;
            }
            long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
            if (timeToWait > 0) {
              if (_debugging) {
                _debug(""String_Node_Str"" + timeToWait);
              }
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
synchronized (_eventQueue) {
        currentEvent=(DEEvent)_eventQueue.take();
        currentTime=currentEvent.timeStamp();
        actorToFire=currentEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging)           _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          actorToFire=null;
          continue;
        }
        try {
          setCurrentTime(currentTime);
        }
 catch (        IllegalActionException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getFullName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}"
75744,"/** 
 * Get the BigDecimal which is the 2^exponent. If the value is already calculated, return this cached value, else calculate the value.
 * @param number the exponent.
 * @return the BigDecimal representing 2^exponent.
 */
private BigDecimal _getTwoRaisedTo(int number){
  if (number <= 128 || number >= 0) {
    return _twoRaisedTo[number];
  }
 else {
    BigInteger two=_two.toBigInteger();
    return new BigDecimal(two.pow(number));
  }
}","/** 
 * Get the BigDecimal which is the 2^exponent. If the value is already calculated, return this cached value, else calculate the value.
 * @param number the exponent.
 * @return the BigDecimal representing 2^exponent.
 */
private BigDecimal _getTwoRaisedTo(int number){
  if (number <= _twoRaisedTo.length && number >= 0) {
    return _twoRaisedTo[number];
  }
 else {
    BigInteger two=_two.toBigInteger();
    return new BigDecimal(two.pow(number));
  }
}"
75745,"/** 
 * Construct a new analysis
 */
public CircuitAnalysis(Entity entity,SootClass theClass){
  HashMutableDirectedGraph graph=new HashMutableDirectedGraph(){
    public String toString(){
      String string=""String_Node_Str"" + getNodes();
      for (Iterator nodes=getNodes().iterator(); nodes.hasNext(); ) {
        Object source=nodes.next();
        string+=""String_Node_Str"" + source + ""String_Node_Str"";
        for (Iterator succs=getSuccsOf(source).iterator(); succs.hasNext(); ) {
          string+=succs.next() + ""String_Node_Str"";
        }
      }
      return string;
    }
  }
;
  _graph=graph;
  System.out.println(""String_Node_Str"" + entity.getClass().getName());
  if (entity.getClass().getName().equals(""String_Node_Str"")) {
    Port input=entity.getPort(""String_Node_Str"");
    Port output=entity.getPort(""String_Node_Str"");
    String delay=""String_Node_Str"" + count++;
    graph.addNode(input);
    graph.addNode(output);
    graph.addNode(delay);
    graph.addEdge(input,delay);
    graph.addEdge(delay,output);
    return;
  }
  Set requiredNodeSet=new HashSet();
  if (theClass.declaresMethodByName(""String_Node_Str"")) {
    _analyze(graph,requiredNodeSet,theClass.getMethodByName(""String_Node_Str""));
  }
  if (theClass.declaresMethodByName(""String_Node_Str"")) {
    _analyze(graph,requiredNodeSet,theClass.getMethodByName(""String_Node_Str""));
  }
  if (theClass.declaresMethodByName(""String_Node_Str"")) {
    _analyze(graph,requiredNodeSet,theClass.getMethodByName(""String_Node_Str""));
  }
  boolean changed=true;
  while (changed) {
    changed=false;
    for (Iterator nodes=graph.getNodes().iterator(); nodes.hasNext(); ) {
      Object node=nodes.next();
      if (requiredNodeSet.contains(node)) {
        continue;
      }
      HashSet set=new HashSet(graph.getSuccsOf(node));
      set.retainAll(requiredNodeSet);
      if (set.isEmpty()) {
        continue;
      }
      requiredNodeSet.add(node);
      changed=true;
    }
  }
  System.out.println(""String_Node_Str"" + graph);
  Set removeSet=new HashSet();
  for (Iterator nodes=graph.getNodes().iterator(); nodes.hasNext(); ) {
    Object node=nodes.next();
    if (node instanceof Local || node instanceof SootField || !requiredNodeSet.contains(node)) {
      for (Iterator preds=graph.getPredsOf(node).iterator(); preds.hasNext(); ) {
        Object pred=preds.next();
        for (Iterator succs=graph.getSuccsOf(node).iterator(); succs.hasNext(); ) {
          Object succ=succs.next();
          graph.addEdge(pred,succ);
        }
      }
      removeSet.add(node);
    }
  }
  for (Iterator nodes=removeSet.iterator(); nodes.hasNext(); ) {
    Object node=nodes.next();
    List predList=new LinkedList(graph.getPredsOf(node));
    for (Iterator preds=predList.iterator(); preds.hasNext(); ) {
      Object pred=preds.next();
      graph.removeEdge(pred,node);
    }
    List succList=new LinkedList(graph.getSuccsOf(node));
    for (Iterator succs=succList.iterator(); succs.hasNext(); ) {
      Object succ=succs.next();
      graph.removeEdge(node,succ);
    }
    graph.removeNode(node);
  }
  System.out.println(""String_Node_Str"" + graph);
}","/** 
 * Construct a new analysis
 */
public CircuitAnalysis(Entity entity,SootClass theClass){
  HashMutableDirectedGraph graph=new HashMutableDirectedGraph(){
    public String toString(){
      String string=""String_Node_Str"" + getNodes();
      for (Iterator nodes=getNodes().iterator(); nodes.hasNext(); ) {
        Object source=nodes.next();
        string+=""String_Node_Str"" + source + ""String_Node_Str"";
        for (Iterator succs=getSuccsOf(source).iterator(); succs.hasNext(); ) {
          string+=succs.next() + ""String_Node_Str"";
        }
      }
      return string;
    }
  }
;
  _graph=graph;
  System.out.println(""String_Node_Str"" + entity.getClass().getName());
  if (entity.getClass().getName().equals(""String_Node_Str"")) {
    Port input=entity.getPort(""String_Node_Str"");
    Port output=entity.getPort(""String_Node_Str"");
    String delay=""String_Node_Str"" + count++;
    graph.addNode(input);
    graph.addNode(output);
    graph.addNode(delay);
    graph.addEdge(input,delay);
    graph.addEdge(delay,output);
    return;
  }
 else   if (entity.getClass().getName().equals(""String_Node_Str"")) {
    Port input=entity.getPort(""String_Node_Str"");
    Port output=entity.getPort(""String_Node_Str"");
    String delay=""String_Node_Str"" + count++;
    graph.addNode(input);
    graph.addNode(output);
    graph.addNode(delay);
    graph.addEdge(input,delay);
    graph.addEdge(delay,output);
    return;
  }
  Set requiredNodeSet=new HashSet();
  if (theClass.declaresMethodByName(""String_Node_Str"")) {
    _analyze(graph,requiredNodeSet,theClass.getMethodByName(""String_Node_Str""));
  }
  if (theClass.declaresMethodByName(""String_Node_Str"")) {
    _analyze(graph,requiredNodeSet,theClass.getMethodByName(""String_Node_Str""));
  }
  if (theClass.declaresMethodByName(""String_Node_Str"")) {
    _analyze(graph,requiredNodeSet,theClass.getMethodByName(""String_Node_Str""));
  }
  boolean changed=true;
  while (changed) {
    changed=false;
    for (Iterator nodes=graph.getNodes().iterator(); nodes.hasNext(); ) {
      Object node=nodes.next();
      if (requiredNodeSet.contains(node)) {
        continue;
      }
      HashSet set=new HashSet(graph.getSuccsOf(node));
      set.retainAll(requiredNodeSet);
      if (set.isEmpty()) {
        continue;
      }
      requiredNodeSet.add(node);
      changed=true;
    }
  }
  System.out.println(""String_Node_Str"" + graph);
  Set removeSet=new HashSet();
  for (Iterator nodes=graph.getNodes().iterator(); nodes.hasNext(); ) {
    Object node=nodes.next();
    if (node instanceof Local || node instanceof SootField || !requiredNodeSet.contains(node)) {
      for (Iterator preds=graph.getPredsOf(node).iterator(); preds.hasNext(); ) {
        Object pred=preds.next();
        for (Iterator succs=graph.getSuccsOf(node).iterator(); succs.hasNext(); ) {
          Object succ=succs.next();
          graph.addEdge(pred,succ);
        }
      }
      removeSet.add(node);
    }
  }
  for (Iterator nodes=removeSet.iterator(); nodes.hasNext(); ) {
    Object node=nodes.next();
    List predList=new LinkedList(graph.getPredsOf(node));
    for (Iterator preds=predList.iterator(); preds.hasNext(); ) {
      Object pred=preds.next();
      graph.removeEdge(pred,node);
    }
    List succList=new LinkedList(graph.getSuccsOf(node));
    for (Iterator succs=succList.iterator(); succs.hasNext(); ) {
      Object succ=succs.next();
      graph.removeEdge(node,succ);
    }
    graph.removeNode(node);
  }
  System.out.println(""String_Node_Str"" + graph);
}"
75746,"public static void create(HashMutableDirectedGraph operatorGraph,String outDir,String packageName,String className) throws IOException {
  String fileName=outDir + ""String_Node_Str"" + className+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + fileName);
  File outputFile=new File(fileName);
  FileWriter writer=new FileWriter(outputFile);
  write_header(writer,packageName,className);
  for (Iterator nodes=operatorGraph.getNodes().iterator(); nodes.hasNext(); ) {
    Object node=nodes.next();
    writer.write(""String_Node_Str"" + _getWireName(node) + ""String_Node_Str"");
  }
  for (Iterator nodes=operatorGraph.getNodes().iterator(); nodes.hasNext(); ) {
    Object node=nodes.next();
    if (node.toString().startsWith(""String_Node_Str"")) {
      Object pred=operatorGraph.getPredsOf(node).iterator().next();
      write_reg(writer,pred,node);
    }
 else     if (node.toString().startsWith(""String_Node_Str"")) {
      Iterator preds=operatorGraph.getPredsOf(node).iterator();
      Object in1=preds.next();
      Object in2=preds.next();
      write_add(writer,in1,in2,node);
    }
 else     if (node.toString().startsWith(""String_Node_Str"")) {
      Object pred=operatorGraph.getPredsOf(node).iterator().next();
      write_buf(writer,pred);
    }
 else {
      try {
        write_const(writer,node.toString(),Integer.parseInt(node.toString()));
      }
 catch (      Exception ex) {
      }
    }
  }
  write_footer(writer);
  writer.close();
}","public static void create(HashMutableDirectedGraph operatorGraph,String outDir,String packageName,String className) throws IOException {
  String fileName=outDir + ""String_Node_Str"" + className+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + fileName);
  File outputFile=new File(fileName);
  FileWriter writer=new FileWriter(outputFile);
  write_header(writer,packageName,className);
  for (Iterator nodes=operatorGraph.getNodes().iterator(); nodes.hasNext(); ) {
    Object node=nodes.next();
    writer.write(""String_Node_Str"" + _getWireName(node) + ""String_Node_Str"");
  }
  for (Iterator nodes=operatorGraph.getNodes().iterator(); nodes.hasNext(); ) {
    Object node=nodes.next();
    if (node.toString().startsWith(""String_Node_Str"")) {
      Object pred=operatorGraph.getPredsOf(node).iterator().next();
      write_reg(writer,pred,node);
    }
 else     if (node.toString().startsWith(""String_Node_Str"")) {
      Object pred=operatorGraph.getPredsOf(node).iterator().next();
      write_fir(writer,pred,node);
    }
 else     if (node.toString().startsWith(""String_Node_Str"")) {
      Iterator preds=operatorGraph.getPredsOf(node).iterator();
      Object in1=preds.next();
      Object in2=preds.next();
      write_add(writer,in1,in2,node);
    }
 else     if (node.toString().startsWith(""String_Node_Str"")) {
      Object pred=operatorGraph.getPredsOf(node).iterator().next();
      write_buf(writer,pred);
    }
 else {
      try {
        write_const(writer,node.toString(),Integer.parseInt(node.toString()));
      }
 catch (      Exception ex) {
      }
    }
  }
  write_footer(writer);
  writer.close();
}"
75747,"/** 
 * Constructs an Exception with a detail message that includes the name of the first argument.
 * @param obj The object.
 * @param detail The message.
 */
public IllegalOutputException(Nameable obj,String detail){
  super(obj,detail);
}","/** 
 * Constructs an Exception with a detail message that includes the name of the first argument.
 * @param object The object.
 * @param detail The message.
 */
public IllegalOutputException(Nameable object,String detail){
  super(object,detail);
}"
75748,"/** 
 * Initialize the firing of the director by resetting state variables and obtaining the current time from an outside director if one exists.
 */
private void _initFiring() throws IllegalActionException {
  _actorsAllowedToFire=null;
  _actorsFired=null;
  _cachedAllInputsKnown=null;
  _cachedAllOutputsKnown=null;
  _lastNumOfActorsAllowedToFire=-1;
  _lastNumOfKnownReceivers=-1;
  CompositeActor container=(CompositeActor)getContainer();
  Director outsideDirector=container.getExecutiveDirector();
  if (outsideDirector != null) {
    setCurrentTime(outsideDirector.getCurrentTime());
  }
}","/** 
 * Initialize the firing of the director by resetting state variables and obtaining the current time from an outside director if one exists.
 */
private void _initFiring() throws IllegalActionException {
  _actorsAllowedToFire=null;
  _actorsFired=null;
  _cachedAllInputsKnown=null;
  _cachedAllOutputsKnown=null;
  _lastNumberOfActorsAllowedToFire=-1;
  _lastNumberOfKnownReceivers=-1;
  CompositeActor container=(CompositeActor)getContainer();
  Director outsideDirector=container.getExecutiveDirector();
  if (outsideDirector != null) {
    setCurrentTime(outsideDirector.getCurrentTime());
  }
}"
75749,"/** 
 * Reset all receivers to allow a new firing of the director.
 */
private void _resetAllReceivers(){
  _debug(""String_Node_Str"");
  _currentNumOfKnownReceivers=0;
  Iterator receiverIterator=_receivers.iterator();
  while (receiverIterator.hasNext()) {
    ((SRReceiver)receiverIterator.next()).reset();
  }
}","/** 
 * Reset all receivers to allow a new firing of the director.
 */
private void _resetAllReceivers(){
  _debug(""String_Node_Str"");
  _currentNumberOfKnownReceivers=0;
  Iterator receiverIterator=_receivers.iterator();
  while (receiverIterator.hasNext()) {
    ((SRReceiver)receiverIterator.next()).reset();
  }
}"
75750,"/** 
 * Return true if this iteration has converged.  The iteration has converged if both the number of known receivers has converged and the number of actors to fire has converged.
 */
private boolean _hasIterationConverged(){
  int previousNumOfActorsAllowedToFire=_lastNumOfActorsAllowedToFire;
  int previousNumOfKnownReceivers=_lastNumOfKnownReceivers;
  int currentNumOfActorsAllowedToFire=_numOfActorsAllowedToFire();
  int currentNumOfKnownReceivers=_currentNumOfKnownReceivers;
  if (_debugging) {
    _debug(""String_Node_Str"",String.valueOf(previousNumOfActorsAllowedToFire));
    _debug(""String_Node_Str"",String.valueOf(currentNumOfActorsAllowedToFire));
    _debug(""String_Node_Str"",String.valueOf(previousNumOfKnownReceivers));
    _debug(""String_Node_Str"",String.valueOf(currentNumOfKnownReceivers));
  }
  _lastNumOfActorsAllowedToFire=currentNumOfActorsAllowedToFire;
  _lastNumOfKnownReceivers=_currentNumOfKnownReceivers;
  if (previousNumOfKnownReceivers == -1) {
    return false;
  }
  if (previousNumOfActorsAllowedToFire != currentNumOfActorsAllowedToFire) {
    return false;
  }
  if (previousNumOfKnownReceivers != currentNumOfKnownReceivers) {
    return false;
  }
  return true;
}","/** 
 * Return true if this iteration has converged.  The iteration has converged if both the number of known receivers has converged and the number of actors to fire has converged.
 */
private boolean _hasIterationConverged(){
  int previousNumberOfActorsAllowedToFire=_lastNumberOfActorsAllowedToFire;
  int previousNumberOfKnownReceivers=_lastNumberOfKnownReceivers;
  int currentNumberOfActorsAllowedToFire=_NumberOfActorsAllowedToFire();
  int currentNumberOfKnownReceivers=_currentNumberOfKnownReceivers;
  if (_debugging) {
    _debug(""String_Node_Str"",String.valueOf(previousNumberOfActorsAllowedToFire));
    _debug(""String_Node_Str"",String.valueOf(currentNumberOfActorsAllowedToFire));
    _debug(""String_Node_Str"",String.valueOf(previousNumberOfKnownReceivers));
    _debug(""String_Node_Str"",String.valueOf(currentNumberOfKnownReceivers));
  }
  _lastNumberOfActorsAllowedToFire=currentNumberOfActorsAllowedToFire;
  _lastNumberOfKnownReceivers=_currentNumberOfKnownReceivers;
  if (previousNumberOfKnownReceivers == -1) {
    return false;
  }
  if (previousNumberOfActorsAllowedToFire != currentNumberOfActorsAllowedToFire) {
    return false;
  }
  if (previousNumberOfKnownReceivers != currentNumberOfKnownReceivers) {
    return false;
  }
  return true;
}"
75751,"/** 
 * React to the change in receiver status by incrementing the count of known receivers.
 */
public void receiverChanged(Receiver receiver){
  _currentNumOfKnownReceivers++;
}","/** 
 * React to the change in receiver status by incrementing the count of known receivers.
 */
public void receiverChanged(Receiver receiver){
  _currentNumberOfKnownReceivers++;
}"
75752,"/** 
 * Constructs an Exception with a detail message that includes the name of the first argument.
 * @param obj The object.
 * @param detail The message.
 */
public UnknownTokenException(Nameable obj,String detail){
  super(obj,detail);
}","/** 
 * Constructs an Exception with a detail message that includes the name of the first argument.
 * @param object The object.
 * @param detail The message.
 */
public UnknownTokenException(Nameable object,String detail){
  super(object,detail);
}"
75753,"private void _updateDestinations() throws IllegalActionException {
  try {
    workspace().getReadAccess();
    FSMActor fsm=(FSMActor)getContainer().getContainer();
    if (_destinationNames != null) {
      _destinations=new LinkedList();
      Iterator destinationNames=_destinationNames.iterator();
      while (destinationNames.hasNext()) {
        String destinationName=(String)destinationNames.next();
        NamedObj destination=_getDestination(destinationName);
        _destinations.add(destination);
      }
    }
    if (_variables != null) {
      Iterator vars=_variables.iterator();
      _variables=new LinkedList();
      while (vars.hasNext()) {
        Variable var=(Variable)vars.next();
        Transition container=(Transition)getContainer();
        _variables.add(container.getAttribute(var.getName()));
      }
    }
    _destinationsListVersion=workspace().getVersion();
  }
  finally {
    workspace().doneReading();
  }
}","private void _updateDestinations() throws IllegalActionException {
  try {
    workspace().getReadAccess();
    FSMActor fsm=(FSMActor)getContainer().getContainer();
    if (_destinationNames != null) {
      _destinations=new LinkedList();
      Iterator destinationNames=_destinationNames.iterator();
      while (destinationNames.hasNext()) {
        String destinationName=(String)destinationNames.next();
        NamedObj destination=_getDestination(destinationName);
        _destinations.add(destination);
      }
    }
    if (_variables != null) {
      Iterator variables=_variables.iterator();
      _variables=new LinkedList();
      while (variables.hasNext()) {
        Variable variable=(Variable)variables.next();
        Transition container=(Transition)getContainer();
        _variables.add(container.getAttribute(variable.getName()));
      }
    }
    _destinationsListVersion=workspace().getVersion();
  }
  finally {
    workspace().doneReading();
  }
}"
75754,"/** 
 * Set the action and notify the container that the action has changed by calling attributeChanged(), and notify any listeners that have been registered using addValueListener().
 * @param expression The action.
 * @exception IllegalActionException If the change is not acceptableto the container, or if the action is syntactically incorrect.
 */
public void setExpression(String expression) throws IllegalActionException {
  super.setExpression(expression);
  if (expression == null)   return;
  _destinationNames=new LinkedList();
  _numbers=new LinkedList();
  _variables=new LinkedList();
  _destinationsListVersion=-1;
  StringTokenizer commands=new StringTokenizer(expression,""String_Node_Str"");
  while (commands.hasMoreTokens()) {
    String command=commands.nextToken();
    int equalSign=command.indexOf(""String_Node_Str"");
    if (equalSign < 1 || equalSign >= command.length() - 1) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + command);
    }
    String completeDestinationSpec=command.substring(0,equalSign).trim();
    int openParen=completeDestinationSpec.indexOf(""String_Node_Str"");
    if (openParen > 0) {
      int closeParen=completeDestinationSpec.indexOf(""String_Node_Str"");
      if (closeParen < openParen) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + command);
      }
      _destinationNames.add(completeDestinationSpec.substring(0,openParen).trim());
      String channelSpec=completeDestinationSpec.substring(openParen + 1,closeParen);
      try {
        _numbers.add(new Integer(channelSpec));
      }
 catch (      NumberFormatException ex) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + command);
      }
    }
 else {
      _destinationNames.add(completeDestinationSpec);
      _numbers.add(null);
    }
    Transition transition=(Transition)getContainer();
    String variableName=""String_Node_Str"" + getName() + ""String_Node_Str""+ completeDestinationSpec.replace('(','_').replace(')','_').replace('.','_');
    Variable evalVariable=null;
    if (transition == null) {
      evalVariable=new Variable(workspace());
      try {
        evalVariable.setName(variableName);
      }
 catch (      NameDuplicationException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
 else {
      Attribute attr=transition.getAttribute(variableName);
      if (attr instanceof Variable) {
        evalVariable=(Variable)attr;
      }
 else {
        try {
          if (attr != null) {
            attr.setContainer(null);
          }
          evalVariable=new Variable(transition,variableName);
        }
 catch (        NameDuplicationException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
    }
    evalVariable.setExpression(command.substring(equalSign + 1).trim());
    _variables.add(evalVariable);
  }
}","/** 
 * Set the action and notify the container that the action has changed by calling attributeChanged(), and notify any listeners that have been registered using addValueListener().
 * @param expression The action.
 * @exception IllegalActionException If the change is not acceptableto the container, or if the action is syntactically incorrect.
 */
public void setExpression(String expression) throws IllegalActionException {
  super.setExpression(expression);
  if (expression == null)   return;
  _destinationNames=new LinkedList();
  _numbers=new LinkedList();
  _variables=new LinkedList();
  _destinationsListVersion=-1;
  StringTokenizer commands=new StringTokenizer(expression,""String_Node_Str"");
  while (commands.hasMoreTokens()) {
    String command=commands.nextToken();
    int equalSign=command.indexOf(""String_Node_Str"");
    if (equalSign < 1 || equalSign >= command.length() - 1) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + command);
    }
    String completeDestinationSpec=command.substring(0,equalSign).trim();
    int openParen=completeDestinationSpec.indexOf(""String_Node_Str"");
    if (openParen > 0) {
      int closeParen=completeDestinationSpec.indexOf(""String_Node_Str"");
      if (closeParen < openParen) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + command);
      }
      _destinationNames.add(completeDestinationSpec.substring(0,openParen).trim());
      String channelSpec=completeDestinationSpec.substring(openParen + 1,closeParen);
      try {
        _numbers.add(new Integer(channelSpec));
      }
 catch (      NumberFormatException ex) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + command);
      }
    }
 else {
      _destinationNames.add(completeDestinationSpec);
      _numbers.add(null);
    }
    Transition transition=(Transition)getContainer();
    String variableName=""String_Node_Str"" + getName() + ""String_Node_Str""+ completeDestinationSpec.replace('(','_').replace(')','_').replace('.','_');
    Variable evalVariable=null;
    if (transition == null) {
      evalVariable=new Variable(workspace());
      try {
        evalVariable.setName(variableName);
      }
 catch (      NameDuplicationException ex) {
        throw new InternalErrorException(this,ex,null);
      }
    }
 else {
      Attribute attribute=transition.getAttribute(variableName);
      if (attribute instanceof Variable) {
        evalVariable=(Variable)attribute;
      }
 else {
        try {
          if (attribute != null) {
            attribute.setContainer(null);
          }
          evalVariable=new Variable(transition,variableName);
        }
 catch (        NameDuplicationException ex) {
          throw new InternalErrorException(this,ex,null);
        }
      }
    }
    evalVariable.setExpression(command.substring(equalSign + 1).trim());
    _variables.add(evalVariable);
  }
}"
75755,"/** 
 * Send tokens to the designated outputs.  Each token is determined by evaluating the expression portion of the action.
 * @exception IllegalActionException If expression evaluation fails,or the specified port is not found, or sending to one of the channels of the port throws a NoRoomException.
 */
public void execute() throws IllegalActionException {
  super.execute();
  if (_destinations != null) {
    Iterator destinations=_destinations.iterator();
    Iterator channels=_numbers.iterator();
    Iterator variables=_variables.iterator();
    while (destinations.hasNext()) {
      Variable variable=(Variable)variables.next();
      NamedObj nextDestination=(NamedObj)destinations.next();
      Integer channel=(Integer)channels.next();
      if (nextDestination instanceof IOPort) {
        IOPort destination=(IOPort)nextDestination;
        try {
          Token tok=variable.getToken();
          if (channel != null) {
            if (tok == null) {
              destination.sendAbsent(channel.intValue());
            }
 else {
              destination.send(channel.intValue(),tok);
            }
          }
 else {
            if (tok == null) {
              destination.broadcastAbsent();
            }
 else {
              destination.broadcast(tok);
            }
          }
        }
 catch (        NoRoomException ex) {
          throw new IllegalActionException(this,""String_Node_Str"" + ex.getMessage());
        }
catch (        UnknownResultException ex) {
        }
      }
 else       if (nextDestination instanceof Variable) {
        Variable destination=(Variable)nextDestination;
        try {
          destination.setToken(variable.getToken());
          destination.validate();
        }
 catch (        UnknownResultException ex) {
          destination.setUnknown(true);
        }
      }
 else {
        throw new IllegalActionException(this,""String_Node_Str"" + nextDestination.getFullName());
      }
    }
  }
}","/** 
 * Send tokens to the designated outputs.  Each token is determined by evaluating the expression portion of the action.
 * @exception IllegalActionException If expression evaluation fails,or the specified port is not found, or sending to one of the channels of the port throws a NoRoomException.
 */
public void execute() throws IllegalActionException {
  super.execute();
  if (_destinations != null) {
    Iterator destinations=_destinations.iterator();
    Iterator channels=_numbers.iterator();
    Iterator variables=_variables.iterator();
    while (destinations.hasNext()) {
      Variable variable=(Variable)variables.next();
      NamedObj nextDestination=(NamedObj)destinations.next();
      Integer channel=(Integer)channels.next();
      if (nextDestination instanceof IOPort) {
        IOPort destination=(IOPort)nextDestination;
        try {
          Token token=variable.getToken();
          if (channel != null) {
            if (token == null) {
              destination.sendAbsent(channel.intValue());
            }
 else {
              destination.send(channel.intValue(),token);
            }
          }
 else {
            if (token == null) {
              destination.broadcastAbsent();
            }
 else {
              destination.broadcast(token);
            }
          }
        }
 catch (        NoRoomException ex) {
          throw new IllegalActionException(this,""String_Node_Str"" + ex.getMessage());
        }
catch (        UnknownResultException ex) {
        }
      }
 else       if (nextDestination instanceof Variable) {
        Variable destination=(Variable)nextDestination;
        try {
          destination.setToken(variable.getToken());
          destination.validate();
        }
 catch (        UnknownResultException ex) {
          destination.setUnknown(true);
        }
      }
 else {
        throw new IllegalActionException(this,""String_Node_Str"" + nextDestination.getFullName());
      }
    }
  }
}"
75756,"/** 
 * Given a destination name, return a NamedObj that matches that destination.
 * @param name The name of the destination, or null if none is found.
 * @return An object (like a port or a variable) with the specified name.
 * @exception IllegalActionException If the associated FSMActordoes not have a destination with the specified name.
 */
protected NamedObj _getDestination(String name) throws IllegalActionException {
  Transition transition=(Transition)getContainer();
  if (transition == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Entity fsm=(Entity)transition.getContainer();
  if (fsm == null) {
    throw new IllegalActionException(this,transition,""String_Node_Str"");
  }
  IOPort port=(IOPort)fsm.getPort(name);
  if (port == null) {
    Attribute var=fsm.getAttribute(name);
    if (var == null) {
      int period=name.indexOf(""String_Node_Str"");
      if (period > 0) {
        String refinementName=name.substring(0,period);
        String entryName=name.substring(period + 1);
        Nameable fsmContainer=fsm.getContainer();
        if (fsmContainer instanceof CompositeEntity) {
          Entity refinement=((CompositeEntity)fsmContainer).getEntity(refinementName);
          if (refinement != null) {
            Attribute entry=refinement.getAttribute(entryName);
            if (entry instanceof Variable) {
              return entry;
            }
          }
        }
      }
      throw new IllegalActionException(fsm,this,""String_Node_Str"" + name);
    }
 else {
      if (!(var instanceof Variable)) {
        throw new IllegalActionException(fsm,this,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      }
      return var;
    }
  }
 else {
    if (!port.isOutput()) {
      throw new IllegalActionException(fsm,this,""String_Node_Str"" + name);
    }
    return port;
  }
}","/** 
 * Given a destination name, return a NamedObj that matches that destination.
 * @param name The name of the destination, or null if none is found.
 * @return An object (like a port or a variable) with the specified name.
 * @exception IllegalActionException If the associated FSMActordoes not have a destination with the specified name.
 */
protected NamedObj _getDestination(String name) throws IllegalActionException {
  Transition transition=(Transition)getContainer();
  if (transition == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Entity fsm=(Entity)transition.getContainer();
  if (fsm == null) {
    throw new IllegalActionException(this,transition,""String_Node_Str"");
  }
  IOPort port=(IOPort)fsm.getPort(name);
  if (port == null) {
    Attribute variable=fsm.getAttribute(name);
    if (variable == null) {
      int period=name.indexOf(""String_Node_Str"");
      if (period > 0) {
        String refinementName=name.substring(0,period);
        String entryName=name.substring(period + 1);
        Nameable fsmContainer=fsm.getContainer();
        if (fsmContainer instanceof CompositeEntity) {
          Entity refinement=((CompositeEntity)fsmContainer).getEntity(refinementName);
          if (refinement != null) {
            Attribute entry=refinement.getAttribute(entryName);
            if (entry instanceof Variable) {
              return entry;
            }
          }
        }
      }
      throw new IllegalActionException(fsm,this,""String_Node_Str"" + name);
    }
 else {
      if (!(variable instanceof Variable)) {
        throw new IllegalActionException(fsm,this,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      }
      return variable;
    }
  }
 else {
    if (!port.isOutput()) {
      throw new IllegalActionException(fsm,this,""String_Node_Str"" + name);
    }
    return port;
  }
}"
75757,"/** 
 * Wrapup execution of this actor.  Interrupt the thread that was created to read from the socket and close the socket.
 * @exception IllegalActionException If the thread or the socketwas not created.
 */
public void wrapup() throws IllegalActionException {
  if (_listenerThread != null) {
    _listenerThread.interrupt();
    _listenerThread=null;
  }
 else {
  }
  if (socket != null) {
    socket.close();
    socket=null;
  }
 else {
  }
}","/** 
 * Wrapup execution of this actor.  Interrupt the thread that was created to read from the socket and close the socket.
 * @exception IllegalActionException If the thread or the socketwas not created.
 */
public void wrapup() throws IllegalActionException {
  if (_listenerThread != null) {
    _listenerThread.interrupt();
    _listenerThread=null;
  }
 else {
    if (false)     System.out.println(""String_Node_Str"");
  }
  if (socket != null) {
    socket.close();
    socket=null;
  }
 else {
    if (false)     System.out.println(""String_Node_Str"");
  }
}"
75758,"/** 
 * Preinitialize this actor.  Create a new datagram socket and initialize the thread that reads from the socket.  The thread will stay alive until the socket is closed.
 * @exception IllegalActionException If the<i>localSocketNumber</i> parameter has a value of -1, or a socket could not be created.
 * @exception NameDuplicationException Not throw in this base class.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _overwrite=((BooleanToken)(overwrite.getToken())).booleanValue();
  Variable var=(Variable)getAttribute(""String_Node_Str"");
  if (var == null) {
    try {
      var=new Variable(this,""String_Node_Str"");
    }
 catch (    NameDuplicationException ex) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  _evalVar=var;
  int portNumber=((IntToken)(localSocketNumber.getToken())).intValue();
  if (portNumber == -1) {
    if (_debugging)     _debug(""String_Node_Str"");
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  try {
    if (_debugging) {
      _debug(""String_Node_Str"" + portNumber);
    }
    socket=new DatagramSocket(portNumber);
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  SocketException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex);
  }
  _listenerThread=new ListenerThread();
  _listenerThread.start();
  if (_debugging)   _debug(""String_Node_Str"");
}","/** 
 * Preinitialize this actor.  Create a new datagram socket and initialize the thread that reads from the socket.  The thread will stay alive until the socket is closed.
 * @exception IllegalActionException If the<i>localSocketNumber</i> parameter has a value of -1, or a socket could not be created.
 * @exception NameDuplicationException Not throw in this base class.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  _packetsAlreadyAwaitingFire=0;
  _overwrite=((BooleanToken)(overwrite.getToken())).booleanValue();
  Variable var=(Variable)getAttribute(""String_Node_Str"");
  if (var == null) {
    try {
      var=new Variable(this,""String_Node_Str"");
    }
 catch (    NameDuplicationException ex) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  _evalVar=var;
  int portNumber=((IntToken)(localSocketNumber.getToken())).intValue();
  if (portNumber == -1) {
    if (false && _debugging)     _debug(""String_Node_Str"");
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  try {
    if (false && _debugging) {
      _debug(""String_Node_Str"" + portNumber);
    }
    socket=new DatagramSocket(portNumber);
    if (false && _debugging) {
      _debug(""String_Node_Str"");
    }
  }
 catch (  SocketException ex) {
    throw new IllegalActionException(this,""String_Node_Str"" + ex);
  }
  _listenerThread=new ListenerThread();
  _listenerThread.start();
  if (_debugging)   _debug(""String_Node_Str"");
}"
75759,"/** 
 * React to the change of the given acttribute. If the parameter changed is <i>localSocketNumber</i> and the model is running (i.e. socket != null), then replace the current socket with a socket on the new number.  This involves interrupting the thread reading from the socket, creating a new socket, and restarting the thread.  This is done even if the port number has not actually changed.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == overwrite) {
    _overwrite=((BooleanToken)(overwrite.getToken())).booleanValue();
  }
 else   if (attribute == localSocketNumber) {
synchronized (this) {
      if (socket != null) {
        _listenerThread.interrupt();
        if (_debugging)         _debug(""String_Node_Str"" + socket.getLocalPort());
        socket.close();
        int portNum=((IntToken)(localSocketNumber.getToken())).intValue();
        if (_debugging)         _debug(""String_Node_Str"" + portNum);
        try {
          if (_debugging)           _debug(""String_Node_Str"" + portNum);
          socket=new DatagramSocket(portNum);
          if (_debugging)           _debug(""String_Node_Str"");
        }
 catch (        SocketException ex) {
          throw new InternalErrorException(KernelException.stackTraceToString(ex));
        }
        _listenerThread.start();
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * React to the change of the given acttribute. If the parameter changed is <i>localSocketNumber</i> and the model is running (i.e. socket != null), then replace the current socket with a socket on the new number.  This involves interrupting the thread reading from the socket, creating a new socket, and restarting the thread.  This is done even if the port number has not actually changed.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == overwrite) {
    _overwrite=((BooleanToken)(overwrite.getToken())).booleanValue();
  }
 else   if (attribute == localSocketNumber) {
synchronized (this) {
      if (socket != null) {
        _listenerThread.interrupt();
        if (_debugging)         _debug(""String_Node_Str"" + socket.getLocalPort());
        socket.close();
        int portNum=((IntToken)(localSocketNumber.getToken())).intValue();
        if (false && _debugging)         _debug(""String_Node_Str"" + portNum);
        try {
          if (_debugging)           _debug(""String_Node_Str"" + portNum);
          socket=new DatagramSocket(portNum);
          if (false && _debugging)           _debug(""String_Node_Str"");
        }
 catch (        SocketException ex) {
          throw new InternalErrorException(KernelException.stackTraceToString(ex));
        }
        _listenerThread.start();
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75760,"/** 
 * Fire this actor.  Optionally parse a received datagram into a token of arbitrary type.  Otherwise, assemble an integer array token by placing one byte of the datagram into each integer in the array.  Broadcast the converted token on the output port.
 * @exception IllegalActionException If the data cannot beconverted into a token of the same type as the configured type of the output port.
 */
public void fire() throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"");
synchronized (_syncFireAndThread) {
    if (((BooleanToken)(blockAwaitingDatagram.getToken())).booleanValue()) {
      while (packetsAlreadyAwaitingFire == 0) {
        try {
          _syncFireAndThread.wait();
        }
 catch (        InterruptedException ex) {
        }
      }
    }
 else {
    }
    if (packetsAlreadyAwaitingFire != 0) {
      boolean forParser=((BooleanToken)(decodeWithPtolemyParser.getToken())).booleanValue();
      if (forParser) {
        _length=_broadcastPacket.getLength();
        _dataStr=new String(_broadcastPacket.getData(),0,_length);
        _evalVar.setExpression(_dataStr);
        _outputToken=_evalVar.getToken();
      }
 else {
        int bytesAvailable=_broadcastPacket.getLength();
        Token[] dataIntTokens=new Token[bytesAvailable];
        byte[] dataBytes=_broadcastPacket.getData();
        for (int j=0; j < bytesAvailable; j++) {
          dataIntTokens[j]=new IntToken(dataBytes[j]);
        }
        _outputToken=new ArrayToken(dataIntTokens);
      }
      packetsAlreadyAwaitingFire--;
      _syncFireAndThread.notifyAll();
    }
 else {
      _outputToken=defaultOutput.getToken();
    }
    output.broadcast(_outputToken);
  }
}","/** 
 * Fire this actor.  Optionally parse a received datagram into a token of arbitrary type.  Otherwise, assemble an integer array token by placing one byte of the datagram into each integer in the array.  Broadcast the converted token on the output port.
 * @exception IllegalActionException If the data cannot beconverted into a token of the same type as the configured type of the output port.
 */
public void fire() throws IllegalActionException {
  if (false)   System.out.println(this + ""String_Node_Str"");
  if (false && _debugging)   _debug(""String_Node_Str"");
synchronized (_syncFireAndThread) {
    if (false)     System.out.println(this + ""String_Node_Str"");
    if (((BooleanToken)(blockAwaitingDatagram.getToken())).booleanValue()) {
      if (false)       System.out.println(this + ""String_Node_Str"");
      while (_packetsAlreadyAwaitingFire == 0) {
        try {
          if (false)           System.out.println(this + ""String_Node_Str"");
          _syncFireAndThread.wait();
          if (false)           System.out.println(this + ""String_Node_Str"");
        }
 catch (        InterruptedException ex) {
          if (false)           System.out.println(this + ""String_Node_Str"");
        }
      }
    }
 else {
      if (false)       System.out.println(this + ""String_Node_Str"");
    }
    if (false)     System.out.println(this + ""String_Node_Str"");
    if (_packetsAlreadyAwaitingFire != 0) {
      if (false)       System.out.println(this + ""String_Node_Str"");
      boolean forParser=((BooleanToken)(decodeWithPtolemyParser.getToken())).booleanValue();
      if (forParser) {
        _length=_broadcastPacket.getLength();
        _dataStr=new String(_broadcastPacket.getData(),0,_length);
        _evalVar.setExpression(_dataStr);
        _outputToken=_evalVar.getToken();
      }
 else {
        int bytesAvailable=_broadcastPacket.getLength();
        Token[] dataIntTokens=new Token[bytesAvailable];
        byte[] dataBytes=_broadcastPacket.getData();
        for (int j=0; j < bytesAvailable; j++) {
          dataIntTokens[j]=new IntToken(dataBytes[j]);
        }
        _outputToken=new ArrayToken(dataIntTokens);
      }
      _packetsAlreadyAwaitingFire--;
      _syncFireAndThread.notifyAll();
    }
 else {
      if (false)       System.out.println(this + ""String_Node_Str"");
      _outputToken=defaultOutput.getToken();
    }
    if (false)     System.out.println(this + ""String_Node_Str"");
    if (false)     System.out.println(this + ""String_Node_Str"" + _outputToken.toString());
    output.broadcast(_outputToken);
    if (false)     System.out.println(this + ""String_Node_Str"");
  }
}"
75761,"public void run(){
  while (true) {
    if (this.interrupted()) {
      return;
    }
    try {
      if (_debugging)       _debug(""String_Node_Str"");
      _receivePacket.setLength(440);
      socket.receive(_receivePacket);
      if (_debugging)       _debug(""String_Node_Str"");
    }
 catch (    IOException ex) {
      if (_debugging)       _debug(""String_Node_Str"");
      return;
    }
synchronized (_syncFireAndThread) {
      if (packetsAlreadyAwaitingFire != 0 && !_overwrite) {
        try {
          _syncFireAndThread.wait();
        }
 catch (        InterruptedException ex) {
        }
      }
      DatagramPacket tmp=_broadcastPacket;
      _broadcastPacket=_receivePacket;
      _receivePacket=tmp;
      if (packetsAlreadyAwaitingFire == 0) {
        packetsAlreadyAwaitingFire++;
        try {
          getDirector().fireAtCurrentTime(DatagramReceiver.this);
        }
 catch (        IllegalActionException ex) {
          if (_debugging)           _debug(""String_Node_Str"");
        }
      }
      _syncFireAndThread.notifyAll();
    }
  }
}","public void run(){
  while (true) {
    if (this.interrupted()) {
      return;
    }
    try {
      if (false && _debugging)       _debug(""String_Node_Str"");
      _receivePacket.setLength(440);
      if (false)       System.out.println(this + ""String_Node_Str"");
      socket.receive(_receivePacket);
      if (false)       System.out.println(this + ""String_Node_Str"");
      if (false && _debugging)       _debug(""String_Node_Str"");
    }
 catch (    IOException ex) {
      if (false)       System.out.println(this + ""String_Node_Str"");
      if (false && _debugging)       _debug(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
synchronized (_syncFireAndThread) {
      if (false)       System.out.println(this + ""String_Node_Str"");
      if (_packetsAlreadyAwaitingFire != 0 && !_overwrite) {
        try {
          _syncFireAndThread.wait();
        }
 catch (        InterruptedException ex) {
          if (false)           System.out.println(this + ""String_Node_Str"");
        }
      }
      DatagramPacket tmp=_broadcastPacket;
      _broadcastPacket=_receivePacket;
      _receivePacket=tmp;
      if (_packetsAlreadyAwaitingFire == 0) {
        _packetsAlreadyAwaitingFire++;
        try {
          if (false)           System.out.println(this + ""String_Node_Str"");
          getDirector().fireAtCurrentTime(DatagramReceiver.this);
          if (false)           System.out.println(this + ""String_Node_Str"");
        }
 catch (        IllegalActionException ex) {
          if (false)           System.out.println(this + ""String_Node_Str"");
          if (false && _debugging)           _debug(""String_Node_Str"");
        }
      }
      _syncFireAndThread.notifyAll();
      if (false)       System.out.println(this + ""String_Node_Str"");
    }
  }
}"
75762,"/** 
 * Incremement the index number.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  _index++;
  return super.postfire();
}","/** 
 * Increment the index number.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  _index++;
  return super.postfire();
}"
75763,"/** 
 * Remove the listeners we have created when the frame closes. Remove our panner-updating listener from the entity. Also remove the listeners our graph model has created.
 */
protected boolean _close(){
  getModel().removeChangeListener(this);
  GraphModel gm=_jgraph.getGraphPane().getGraphModel();
  if (gm instanceof AbstractBasicGraphModel) {
    ((AbstractBasicGraphModel)gm).removeListeners();
  }
  return super._close();
}","/** 
 * Override the base class to remove the listeners we have created when the frame closes.  Specifically, remove our panner-updating listener from the entity. Also remove the listeners our graph model has created.
 * @return True if the close completes, and false otherwise.
 */
protected boolean _close(){
  boolean result=super._close();
  if (result) {
    getModel().removeChangeListener(this);
    GraphModel gm=_jgraph.getGraphPane().getGraphModel();
    if (gm instanceof AbstractBasicGraphModel) {
      ((AbstractBasicGraphModel)gm).removeListeners();
    }
  }
  return result;
}"
75764,"/** 
 * Generate Giotto code for this model. NOTE: This is highly preliminary.
 */
public void generateGiottoCode() throws IllegalActionException {
  try {
    String file=((StringToken)filename.getToken()).stringValue();
    FileOutputStream fout=new FileOutputStream(file);
    PrintStream pout=new PrintStream(fout);
    pout.println(""String_Node_Str"");
    TypedCompositeActor container=(TypedCompositeActor)getContainer();
    Iterator inPorts=container.inputPortList().iterator();
    while (inPorts.hasNext()) {
      TypedIOPort port=(TypedIOPort)inPorts.next();
      String driverName=port.getName() + ""String_Node_Str"";
      pout.println(""String_Node_Str"" + port.getType() + ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ driverName+ ""String_Node_Str"");
    }
    pout.println(""String_Node_Str"");
    Iterator outPorts=container.outputPortList().iterator();
    while (outPorts.hasNext()) {
      TypedIOPort port=(TypedIOPort)outPorts.next();
      String driverName=port.getName() + ""String_Node_Str"";
      pout.println(""String_Node_Str"" + port.getType() + ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ driverName+ ""String_Node_Str"");
    }
    pout.println(""String_Node_Str"");
    Iterator actors=container.deepEntityList().iterator();
    while (actors.hasNext()) {
      TypedActor actor=(TypedActor)actors.next();
      outPorts=actor.outputPortList().iterator();
      while (outPorts.hasNext()) {
        TypedIOPort port=(TypedIOPort)outPorts.next();
        String sanitizedPortName=StringUtilities.sanitizeName(port.getName(container));
        pout.println(""String_Node_Str"" + port.getType() + ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str"");
      }
    }
    actors=container.deepEntityList().iterator();
    while (actors.hasNext()) {
      TypedActor actor=(TypedActor)actors.next();
      String taskName=StringUtilities.sanitizeName(((NamedObj)actor).getName(container));
      pout.print(""String_Node_Str"" + taskName + ""String_Node_Str"");
      inPorts=actor.inputPortList().iterator();
      String inPortsNames=""String_Node_Str"";
      String outPortsNames=""String_Node_Str"";
      while (inPorts.hasNext()) {
        TypedIOPort port=(TypedIOPort)inPorts.next();
        inPortsNames+=port.getName();
        pout.print(port.getName());
        if (inPorts.hasNext()) {
          inPortsNames+=""String_Node_Str"";
          pout.print(""String_Node_Str"");
        }
      }
      pout.print(""String_Node_Str"");
      outPorts=actor.outputPortList().iterator();
      while (outPorts.hasNext()) {
        TypedIOPort port=(TypedIOPort)outPorts.next();
        String sanitizedPortName=StringUtilities.sanitizeName(port.getName(container));
        outPortsNames+=sanitizedPortName;
        pout.print(sanitizedPortName);
        if (outPorts.hasNext()) {
          outPortsNames+=""String_Node_Str"";
          pout.print(""String_Node_Str"");
        }
      }
      pout.println(""String_Node_Str"");
      pout.println(""String_Node_Str"" + taskName + ""String_Node_Str""+ inPortsNames+ ""String_Node_Str""+ outPortsNames+ ""String_Node_Str"");
      pout.println(""String_Node_Str"");
    }
    actors=container.deepEntityList().iterator();
    String driverParas, outParas, typedOutParas;
    String actorName;
    Director director=((Actor)container).getDirector();
    while (actors.hasNext()) {
      driverParas=""String_Node_Str"";
      outParas=""String_Node_Str"";
      typedOutParas=""String_Node_Str"";
      actorName=""String_Node_Str"";
      TypedActor actor=(TypedActor)actors.next();
      actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName(container));
      pout.print(""String_Node_Str"" + actorName + ""String_Node_Str"");
      inPorts=actor.inputPortList().iterator();
      while (inPorts.hasNext()) {
        IOPort thisPort=(IOPort)inPorts.next();
        int directorDepth=((IOPort)thisPort).depthOfDirector(director);
        String sanitizedPortName=StringUtilities.sanitizeName(thisPort.getName(container));
        Iterator sourcePorts=thisPort.sourcePortList(directorDepth).iterator();
        while (sourcePorts.hasNext()) {
          IOPort port=(IOPort)sourcePorts.next();
          sanitizedPortName=StringUtilities.sanitizeName(port.getName(container));
          if (driverParas.length() == 0) {
            driverParas+=sanitizedPortName;
          }
 else {
            driverParas+=""String_Node_Str"" + sanitizedPortName;
          }
        }
      }
      inPorts=actor.inputPortList().iterator();
      while (inPorts.hasNext()) {
        TypedIOPort port=(TypedIOPort)inPorts.next();
        if (outParas == ""String_Node_Str"") {
          typedOutParas+=port.getType() + ""String_Node_Str"" + port.getName();
          outParas+=port.getName();
        }
 else {
          typedOutParas+=""String_Node_Str"" + port.getType() + ""String_Node_Str""+ port.getName();
          outParas+=""String_Node_Str"" + port.getName();
        }
      }
      pout.println(driverParas + ""String_Node_Str"" + typedOutParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"" + actorName + ""String_Node_Str""+ driverParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"" + actorName + ""String_Node_Str""+ driverParas+ ""String_Node_Str""+ outParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"");
    }
    Iterator topOutPorts=container.outputPortList().iterator();
    String outputName=""String_Node_Str"";
    String sanitizedPortName=""String_Node_Str"";
    while (topOutPorts.hasNext()) {
      driverParas=""String_Node_Str"";
      outParas=""String_Node_Str"";
      typedOutParas=""String_Node_Str"";
      outputName=""String_Node_Str"";
      TypedIOPort port=(TypedIOPort)topOutPorts.next();
      outputName=StringUtilities.sanitizeName(port.getName(container));
      pout.print(""String_Node_Str"" + outputName + ""String_Node_Str"");
      outParas+=port.getName();
      typedOutParas+=port.getType() + ""String_Node_Str"" + port.getName();
      Iterator portConnected=port.deepInsidePortList().iterator();
      if (port.deepInsidePortList().size() != 0) {
        while (portConnected.hasNext()) {
          TypedIOPort outPort=(TypedIOPort)portConnected.next();
          sanitizedPortName=StringUtilities.sanitizeName(outPort.getName(container));
          if (outPort.isOutput()) {
            if (driverParas.length() == 0) {
              driverParas+=sanitizedPortName;
            }
 else {
              driverParas+=""String_Node_Str"" + sanitizedPortName;
            }
          }
        }
      }
      pout.println(driverParas + ""String_Node_Str"" + typedOutParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"" + outputName + ""String_Node_Str""+ driverParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"" + outputName + ""String_Node_Str""+ driverParas+ ""String_Node_Str""+ outParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"");
    }
    String containerName=container.getName();
    double periodValue=((DoubleToken)period.getToken()).doubleValue();
    int actorFreq=0;
    int actFreq=0;
    pout.println(""String_Node_Str"" + containerName + ""String_Node_Str"");
    pout.println(""String_Node_Str"" + containerName + ""String_Node_Str""+ periodValue+ ""String_Node_Str"");
    topOutPorts=container.outputPortList().iterator();
    while (topOutPorts.hasNext()) {
      outputName=""String_Node_Str"";
      TypedIOPort port=(TypedIOPort)topOutPorts.next();
      outputName=StringUtilities.sanitizeName(port.getName(container));
      Iterator portConnected=port.deepInsidePortList().iterator();
      if (port.deepInsidePortList().size() != 0) {
        while (portConnected.hasNext()) {
          TypedIOPort outPort=(TypedIOPort)portConnected.next();
          actorFreq=1;
          pout.println(""String_Node_Str"" + actorFreq + ""String_Node_Str""+ outputName+ ""String_Node_Str""+ outputName+ ""String_Node_Str"");
        }
      }
    }
    actors=container.deepEntityList().iterator();
    while (actors.hasNext()) {
      TypedActor actor=(TypedActor)actors.next();
      actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName(container));
      Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
      actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
      pout.println(""String_Node_Str"" + actorFreq + ""String_Node_Str""+ actorName+ ""String_Node_Str""+ actorName+ ""String_Node_Str"");
    }
    pout.println(""String_Node_Str"");
    pout.println(""String_Node_Str"");
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex.getMessage());
  }
}","/** 
 * Generate Giotto code for this model. NOTE: This is highly preliminary.
 */
public void generateGiottoCode() throws IllegalActionException {
  try {
    String file=((StringToken)filename.getToken()).stringValue();
    FileOutputStream fout=new FileOutputStream(file);
    PrintStream pout=new PrintStream(fout);
    pout.println(""String_Node_Str"");
    TypedCompositeActor container=(TypedCompositeActor)getContainer();
    Iterator inPorts=container.inputPortList().iterator();
    while (inPorts.hasNext()) {
      TypedIOPort port=(TypedIOPort)inPorts.next();
      String driverName=port.getName() + ""String_Node_Str"";
      pout.println(""String_Node_Str"" + port.getType() + ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ driverName+ ""String_Node_Str"");
    }
    pout.println(""String_Node_Str"");
    Iterator outPorts=container.outputPortList().iterator();
    while (outPorts.hasNext()) {
      TypedIOPort port=(TypedIOPort)outPorts.next();
      String driverName=port.getName() + ""String_Node_Str"";
      pout.println(""String_Node_Str"" + port.getType() + ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ driverName+ ""String_Node_Str"");
    }
    pout.println(""String_Node_Str"");
    Iterator actors=container.deepEntityList().iterator();
    while (actors.hasNext()) {
      TypedActor actor=(TypedActor)actors.next();
      outPorts=actor.outputPortList().iterator();
      while (outPorts.hasNext()) {
        TypedIOPort port=(TypedIOPort)outPorts.next();
        String sanitizedPortName=StringUtilities.sanitizeName(port.getName(container));
        pout.println(""String_Node_Str"" + port.getType() + ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str""+ sanitizedPortName+ ""String_Node_Str"");
      }
    }
    actors=container.deepEntityList().iterator();
    while (actors.hasNext()) {
      TypedActor actor=(TypedActor)actors.next();
      String taskName=StringUtilities.sanitizeName(((NamedObj)actor).getName(container));
      pout.print(""String_Node_Str"" + taskName + ""String_Node_Str"");
      inPorts=actor.inputPortList().iterator();
      String inPortsNames=""String_Node_Str"";
      String outPortsNames=""String_Node_Str"";
      while (inPorts.hasNext()) {
        TypedIOPort port=(TypedIOPort)inPorts.next();
        inPortsNames+=port.getName();
        pout.print(port.getName());
        if (inPorts.hasNext()) {
          inPortsNames+=""String_Node_Str"";
          pout.print(""String_Node_Str"");
        }
      }
      pout.print(""String_Node_Str"");
      outPorts=actor.outputPortList().iterator();
      while (outPorts.hasNext()) {
        TypedIOPort port=(TypedIOPort)outPorts.next();
        String sanitizedPortName=StringUtilities.sanitizeName(port.getName(container));
        outPortsNames+=sanitizedPortName;
        pout.print(sanitizedPortName);
        if (outPorts.hasNext()) {
          outPortsNames+=""String_Node_Str"";
          pout.print(""String_Node_Str"");
        }
      }
      pout.println(""String_Node_Str"");
      pout.println(""String_Node_Str"" + taskName + ""String_Node_Str""+ inPortsNames+ ""String_Node_Str""+ outPortsNames+ ""String_Node_Str"");
      pout.println(""String_Node_Str"");
    }
    actors=container.deepEntityList().iterator();
    String driverParas, outParas, typedOutParas;
    String actorName;
    while (actors.hasNext()) {
      driverParas=""String_Node_Str"";
      outParas=""String_Node_Str"";
      typedOutParas=""String_Node_Str"";
      actorName=""String_Node_Str"";
      TypedActor actor=(TypedActor)actors.next();
      actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName(container));
      pout.print(""String_Node_Str"" + actorName + ""String_Node_Str"");
      inPorts=actor.inputPortList().iterator();
      while (inPorts.hasNext()) {
        IOPort thisPort=(IOPort)inPorts.next();
        String sanitizedPortName=StringUtilities.sanitizeName(thisPort.getName(container));
        Iterator sourcePorts=thisPort.sourcePortList().iterator();
        while (sourcePorts.hasNext()) {
          IOPort port=(IOPort)sourcePorts.next();
          sanitizedPortName=StringUtilities.sanitizeName(port.getName(container));
          if (driverParas.length() == 0) {
            driverParas+=sanitizedPortName;
          }
 else {
            driverParas+=""String_Node_Str"" + sanitizedPortName;
          }
        }
      }
      inPorts=actor.inputPortList().iterator();
      while (inPorts.hasNext()) {
        TypedIOPort port=(TypedIOPort)inPorts.next();
        if (outParas == ""String_Node_Str"") {
          typedOutParas+=port.getType() + ""String_Node_Str"" + port.getName();
          outParas+=port.getName();
        }
 else {
          typedOutParas+=""String_Node_Str"" + port.getType() + ""String_Node_Str""+ port.getName();
          outParas+=""String_Node_Str"" + port.getName();
        }
      }
      pout.println(driverParas + ""String_Node_Str"" + typedOutParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"" + actorName + ""String_Node_Str""+ driverParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"" + actorName + ""String_Node_Str""+ driverParas+ ""String_Node_Str""+ outParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"");
    }
    Iterator topOutPorts=container.outputPortList().iterator();
    String outputName=""String_Node_Str"";
    String sanitizedPortName=""String_Node_Str"";
    while (topOutPorts.hasNext()) {
      driverParas=""String_Node_Str"";
      outParas=""String_Node_Str"";
      typedOutParas=""String_Node_Str"";
      outputName=""String_Node_Str"";
      TypedIOPort port=(TypedIOPort)topOutPorts.next();
      outputName=StringUtilities.sanitizeName(port.getName(container));
      pout.print(""String_Node_Str"" + outputName + ""String_Node_Str"");
      outParas+=port.getName();
      typedOutParas+=port.getType() + ""String_Node_Str"" + port.getName();
      Iterator portConnected=port.deepInsidePortList().iterator();
      if (port.deepInsidePortList().size() != 0) {
        while (portConnected.hasNext()) {
          TypedIOPort outPort=(TypedIOPort)portConnected.next();
          sanitizedPortName=StringUtilities.sanitizeName(outPort.getName(container));
          if (outPort.isOutput()) {
            if (driverParas.length() == 0) {
              driverParas+=sanitizedPortName;
            }
 else {
              driverParas+=""String_Node_Str"" + sanitizedPortName;
            }
          }
        }
      }
      pout.println(driverParas + ""String_Node_Str"" + typedOutParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"" + outputName + ""String_Node_Str""+ driverParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"" + outputName + ""String_Node_Str""+ driverParas+ ""String_Node_Str""+ outParas+ ""String_Node_Str"");
      pout.println(""String_Node_Str"");
    }
    String containerName=container.getName();
    double periodValue=((DoubleToken)period.getToken()).doubleValue();
    int actorFreq=0;
    int actFreq=0;
    pout.println(""String_Node_Str"" + containerName + ""String_Node_Str"");
    pout.println(""String_Node_Str"" + containerName + ""String_Node_Str""+ periodValue+ ""String_Node_Str"");
    topOutPorts=container.outputPortList().iterator();
    while (topOutPorts.hasNext()) {
      outputName=""String_Node_Str"";
      TypedIOPort port=(TypedIOPort)topOutPorts.next();
      outputName=StringUtilities.sanitizeName(port.getName(container));
      Iterator portConnected=port.deepInsidePortList().iterator();
      if (port.deepInsidePortList().size() != 0) {
        while (portConnected.hasNext()) {
          TypedIOPort outPort=(TypedIOPort)portConnected.next();
          Nameable actor=outPort.getContainer();
          if (actor instanceof Actor) {
            Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
            actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
          }
          pout.println(""String_Node_Str"" + actorFreq + ""String_Node_Str""+ outputName+ ""String_Node_Str""+ outputName+ ""String_Node_Str"");
        }
      }
    }
    actors=container.deepEntityList().iterator();
    while (actors.hasNext()) {
      TypedActor actor=(TypedActor)actors.next();
      actorName=StringUtilities.sanitizeName(((NamedObj)actor).getName(container));
      Parameter actorFreqPara=(Parameter)((NamedObj)actor).getAttribute(""String_Node_Str"");
      actorFreq=((IntToken)actorFreqPara.getToken()).intValue();
      pout.println(""String_Node_Str"" + actorFreq + ""String_Node_Str""+ actorName+ ""String_Node_Str""+ actorName+ ""String_Node_Str"");
    }
    pout.println(""String_Node_Str"");
    pout.println(""String_Node_Str"");
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex.getMessage());
  }
}"
75765,"/** 
 * Save the model as an applet. <p>For example, if the model is called MyModel, and this phase is called with: <pre> -p wjtp.appletWriter targetPackage:foo.bar </pre> Then we will create the directory $PTII/foo/bar/MyModel and place MyModel.xml, MyModel.htm, MyModelVergil.htm in that directory.
 * @param phaseName The name of the phase, for example <code>wjtp.appletWriter</code>.
 * @param options The options Map.  This method uses the<code>targetPackage</code> option to specify package to generate code in.
 */
protected void internalTransform(String phaseName,Map options){
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  _ptIIDirectory=null;
  try {
    _ptIIDirectory=System.getProperty(""String_Node_Str"");
  }
 catch (  SecurityException security) {
    throw new InternalErrorException(this,security,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  _targetPackage=Options.getString(options,""String_Node_Str"");
  int start=_targetPackage.indexOf('.');
  StringBuffer buffer=new StringBuffer(""String_Node_Str"");
  while (start != -1) {
    buffer.append(""String_Node_Str"");
    start=_targetPackage.indexOf('.',start + 1);
  }
  _codeBase=buffer.toString();
  System.out.println(""String_Node_Str"" + _model);
  Director director=_model.getDirector();
  System.out.println(""String_Node_Str"" + director);
  String directorPackage=director.getClass().getPackage().getName();
  if (!directorPackage.endsWith(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + directorPackage);
  }
  String directorPackageDomain=directorPackage.substring(0,directorPackage.lastIndexOf(""String_Node_Str""));
  String directorDomain=directorPackageDomain.substring(directorPackageDomain.lastIndexOf(""String_Node_Str"") + 1);
  _domainJar=StringUtilities.substitute(directorPackageDomain,""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + directorDomain+ ""String_Node_Str"";
  _sanitizedModelName=SootUtilities.sanitizeName(_model.getName());
  _modelDirectory=_ptIIDirectory + ""String_Node_Str"" + StringUtilities.substitute(_targetPackage,""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str"";
  File modelDirectoryFile=new File(_modelDirectory);
  if (modelDirectoryFile.isDirectory()) {
    System.out.println(""String_Node_Str"" + modelDirectoryFile + ""String_Node_Str"");
  }
  modelDirectoryFile.mkdirs();
  _substituteMap=new HashMap();
  _substituteMap.put(""String_Node_Str"",_codeBase);
  _substituteMap.put(""String_Node_Str"",_domainJar);
  _substituteMap.put(""String_Node_Str"",_modelDirectory);
  _substituteMap.put(""String_Node_Str"",_sanitizedModelName);
  _substituteMap.put(""String_Node_Str"",_ptIIDirectory);
  Iterator keys=_substituteMap.keySet().iterator();
  while (keys.hasNext()) {
    String key=(String)keys.next();
    System.out.println(""String_Node_Str"" + key + ""String_Node_Str""+ (String)_substituteMap.get(key)+ ""String_Node_Str"");
  }
  String modelFileName=_modelDirectory + _sanitizedModelName + ""String_Node_Str"";
  try {
    Writer modelFileWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(modelFileName)));
    _model.exportMoML(modelFileWriter);
    modelFileWriter.close();
  }
 catch (  IOException ex) {
    throw new InternalErrorException(""String_Node_Str"" + modelFileName + ""String_Node_Str""+ ex);
  }
  _templateDirectory=StringUtilities.substitute(Options.getString(options,""String_Node_Str""),""String_Node_Str"",_ptIIDirectory);
  try {
    substitute(_templateDirectory + ""String_Node_Str"",_substituteMap,_modelDirectory + ""String_Node_Str"");
    substitute(_templateDirectory + ""String_Node_Str"",_substituteMap,_modelDirectory + _sanitizedModelName + ""String_Node_Str"");
    substitute(_templateDirectory + ""String_Node_Str"",_substituteMap,_modelDirectory + _sanitizedModelName + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex);
  }
}","/** 
 * Save the model as an applet. <p>For example, if the model is called MyModel, and this phase is called with: <pre> -p wjtp.appletWriter targetPackage:foo.bar </pre> Then we will create the directory $PTII/foo/bar/MyModel and place MyModel.xml, MyModel.htm, MyModelVergil.htm in that directory.
 * @param phaseName The name of the phase, for example <code>wjtp.appletWriter</code>.
 * @param options The options Map.  This method uses the<code>targetPackage</code> option to specify package to generate code in.
 */
protected void internalTransform(String phaseName,Map options){
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  _ptIIDirectory=null;
  try {
    _ptIIDirectory=System.getProperty(""String_Node_Str"");
  }
 catch (  SecurityException security) {
    throw new InternalErrorException(null,security,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  _targetPackage=Options.getString(options,""String_Node_Str"");
  int start=_targetPackage.indexOf('.');
  StringBuffer buffer=new StringBuffer(""String_Node_Str"");
  while (start != -1) {
    buffer.append(""String_Node_Str"");
    start=_targetPackage.indexOf('.',start + 1);
  }
  _codeBase=buffer.toString();
  System.out.println(""String_Node_Str"" + _model);
  Director director=_model.getDirector();
  System.out.println(""String_Node_Str"" + director);
  String directorPackage=director.getClass().getPackage().getName();
  if (!directorPackage.endsWith(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + directorPackage);
  }
  String directorPackageDomain=directorPackage.substring(0,directorPackage.lastIndexOf(""String_Node_Str""));
  String directorDomain=directorPackageDomain.substring(directorPackageDomain.lastIndexOf(""String_Node_Str"") + 1);
  _domainJar=StringUtilities.substitute(directorPackageDomain,""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"" + directorDomain+ ""String_Node_Str"";
  _sanitizedModelName=SootUtilities.sanitizeName(_model.getName());
  _modelDirectory=_ptIIDirectory + ""String_Node_Str"" + StringUtilities.substitute(_targetPackage,""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str"";
  File modelDirectoryFile=new File(_modelDirectory);
  if (modelDirectoryFile.isDirectory()) {
    System.out.println(""String_Node_Str"" + modelDirectoryFile + ""String_Node_Str"");
  }
  modelDirectoryFile.mkdirs();
  _substituteMap=new HashMap();
  _substituteMap.put(""String_Node_Str"",_codeBase);
  _substituteMap.put(""String_Node_Str"",_domainJar);
  _substituteMap.put(""String_Node_Str"",_modelDirectory);
  _substituteMap.put(""String_Node_Str"",_sanitizedModelName);
  _substituteMap.put(""String_Node_Str"",_ptIIDirectory);
  Iterator keys=_substituteMap.keySet().iterator();
  while (keys.hasNext()) {
    String key=(String)keys.next();
    System.out.println(""String_Node_Str"" + key + ""String_Node_Str""+ (String)_substituteMap.get(key)+ ""String_Node_Str"");
  }
  String modelFileName=_modelDirectory + _sanitizedModelName + ""String_Node_Str"";
  try {
    Writer modelFileWriter=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(modelFileName)));
    _model.exportMoML(modelFileWriter);
    modelFileWriter.close();
  }
 catch (  IOException ex) {
    throw new InternalErrorException(""String_Node_Str"" + modelFileName + ""String_Node_Str""+ ex);
  }
  _templateDirectory=StringUtilities.substitute(Options.getString(options,""String_Node_Str""),""String_Node_Str"",_ptIIDirectory);
  try {
    substitute(_templateDirectory + ""String_Node_Str"",_substituteMap,_modelDirectory + ""String_Node_Str"");
    substitute(_templateDirectory + ""String_Node_Str"",_substituteMap,_modelDirectory + _sanitizedModelName + ""String_Node_Str"");
    substitute(_templateDirectory + ""String_Node_Str"",_substituteMap,_modelDirectory + _sanitizedModelName + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex);
  }
}"
75766,"/** 
 * Create receivers and input variables for the input ports of this actor, and validate attributes. Set current state to the initial state. Throw an exception if this actor does not contain a state with name specified by the <i>initialStateName</i> attribute.
 * @exception IllegalActionException If this actor does not contain astate with name specified by the <i>initialStateName</i> attribute.
 */
public void preinitialize() throws IllegalActionException {
  _createReceivers();
  Iterator inputPorts=inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inport=(TypedIOPort)inputPorts.next();
    _removeInputVariables(inport);
  }
  Iterator attributes=attributeList(Settable.class).iterator();
  while (attributes.hasNext()) {
    Settable attribute=(Settable)attributes.next();
    attribute.validate();
  }
  _createInputVariables();
  _gotoInitialState();
}","/** 
 * Create receivers and input variables for the input ports of this actor, and validate attributes. Set current state to the initial state. Throw an exception if this actor does not contain a state with name specified by the <i>initialStateName</i> attribute.
 * @exception IllegalActionException If this actor does not contain astate with name specified by the <i>initialStateName</i> attribute.
 */
public void preinitialize() throws IllegalActionException {
  _createReceivers();
  Iterator inputPorts=inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inport=(TypedIOPort)inputPorts.next();
    _removeInputVariables(inport);
  }
  _createInputVariables();
  Iterator attributes=attributeList(Settable.class).iterator();
  while (attributes.hasNext()) {
    Settable attribute=(Settable)attributes.next();
    attribute.validate();
  }
  _gotoInitialState();
}"
75767,"protected void _reinitialize() throws IllegalActionException {
  if (_decPhase >= _dec) {
    throw new IllegalActionException(this,""String_Node_Str"" + _decPhase + ""String_Node_Str""+ _dec+ ""String_Node_Str"");
  }
  _phaseLength=(int)(_taps.length / _interp);
  if ((_taps.length % _interp) != 0)   _phaseLength++;
  if (_data == null || _data.length != _phaseLength) {
    _data=new Token[_phaseLength];
    for (int i=0; i < _phaseLength; i++) {
      _data[i]=_zero;
    }
    _mostRecent=_phaseLength;
  }
  _reinitializeNeeded=false;
}","protected void _reinitialize() throws IllegalActionException {
  if (_decPhase >= _dec) {
    throw new IllegalActionException(this,""String_Node_Str"" + _decPhase + ""String_Node_Str""+ _dec+ ""String_Node_Str"");
  }
  _phaseLength=(int)(_taps.length / _interp);
  if ((_taps.length % _interp) != 0)   _phaseLength++;
  int length=(int)Math.max(_phaseLength,_dec);
  if (_data == null || _data.length != length) {
    _data=new Token[_phaseLength];
    for (int i=0; i < _phaseLength; i++) {
      _data[i]=_zero;
    }
    _mostRecent=_phaseLength;
  }
  _reinitializeNeeded=false;
}"
75768,"/** 
 * Consume the inputs and produce the outputs of the FIR filter.
 * @exception IllegalActionException If parameter values are invalid,or if there is no director, or if runtime type conflicts occur.
 */
public void fire() throws IllegalActionException {
  int phase=_dec - _decPhase - 1;
  for (int inC=1; inC <= _dec; inC++) {
    if (--_mostRecent < 0)     _mostRecent=_data.length - 1;
    _data[_mostRecent]=input.get(0);
    while (phase < _interp) {
      _outToken=_zero;
      for (int i=0; i < _phaseLength; i++) {
        int tapsIndex=i * _interp + phase;
        int dataIndex=(_mostRecent + _dec - inC + i) % (_data.length);
        if (tapsIndex < _taps.length) {
          _tapItem=_taps[tapsIndex];
          _dataItem=_data[dataIndex];
          _dataItem=_tapItem.multiply(_dataItem);
          _outToken=_outToken.add(_dataItem);
        }
      }
      output.send(0,_outToken);
      phase+=_dec;
    }
    phase-=_interp;
  }
}","/** 
 * Consume the inputs and produce the outputs of the FIR filter.
 * @exception IllegalActionException If parameter values are invalid,or if there is no director, or if runtime type conflicts occur.
 */
public void fire() throws IllegalActionException {
  int phase=_dec - _decPhase - 1;
  for (int inC=1; inC <= _dec; inC++) {
    if (--_mostRecent < 0)     _mostRecent=_data.length - 1;
    _data[_mostRecent]=input.get(0);
  }
  for (int inC=1; inC <= _dec; inC++) {
    while (phase < _interp) {
      _outToken=_zero;
      for (int i=0; i < _phaseLength; i++) {
        int tapsIndex=i * _interp + phase;
        int dataIndex=(_mostRecent + _dec - inC + i) % (_data.length);
        if (tapsIndex < _taps.length) {
          _tapItem=_taps[tapsIndex];
          _dataItem=_data[dataIndex];
          _dataItem=_tapItem.multiply(_dataItem);
          _outToken=_outToken.add(_dataItem);
        }
      }
      output.send(0,_outToken);
      phase+=_dec;
    }
    phase-=_interp;
  }
}"
75769,"protected void flowThrough(Object inValue,Object d,Object outValue){
  GraphFlow in=(GraphFlow)inValue;
  GraphFlow out=(GraphFlow)outValue;
  Stmt unit=(Stmt)d;
  copy(inValue,outValue);
  if (_debug)   System.out.println(""String_Node_Str"" + d);
  Integer i=(Integer)_countMap.get(d);
  if (i == null) {
    _countMap.put(d,new Integer(1));
  }
 else {
    _countMap.put(d,new Integer(i.intValue() + 1));
  }
  if (unit.containsInvokeExpr()) {
    for (Iterator nodes=out.getNodes().iterator(); nodes.hasNext(); ) {
      Object node=nodes.next();
      if (node instanceof SootField) {
        SootField field=(SootField)node;
        boolean targetsAreInDifferentClass=true;
        if (field.isPrivate() && targetsAreInDifferentClass) {
          continue;
        }
 else         if (Modifier.isFinal(field.getModifiers())) {
          continue;
        }
 else {
          if (_debug) {
            System.out.println(""String_Node_Str"" + unit + ""String_Node_Str""+ field);
          }
          _setCanPointToAnything(out,node);
        }
      }
    }
  }
  if (unit instanceof DefinitionStmt) {
    DefinitionStmt assignStmt=(DefinitionStmt)unit;
    Value lvalue=assignStmt.getLeftOp();
    Value rvalue=assignStmt.getRightOp();
    if (_debug) {
    }
    if (_isAliasableType(lvalue.getType())) {
      Object lobject=_getAliasObject(lvalue,out);
      Object robject=_getAliasObject(rvalue,out);
      if (!out.containsNode(lobject)) {
        out.addNode(lobject);
      }
      if (!out.containsNode(robject) && robject != null) {
        out.addNode(robject);
      }
      if (robject == null) {
      }
 else {
        _setCanPointTo(out,lobject,robject);
      }
    }
  }
  if (_debug)   System.out.println(""String_Node_Str"" + out);
}","protected void flowThrough(Object inValue,Object d,Object outValue){
  GraphFlow in=(GraphFlow)inValue;
  GraphFlow out=(GraphFlow)outValue;
  Stmt unit=(Stmt)d;
  copy(inValue,outValue);
  if (_debug)   System.out.println(""String_Node_Str"" + d);
  if (_debug) {
    Integer i=(Integer)_countMap.get(d);
    if (i == null) {
      _countMap.put(d,new Integer(1));
    }
 else {
      _countMap.put(d,new Integer(i.intValue() + 1));
    }
  }
  if (unit.containsInvokeExpr()) {
    for (Iterator nodes=out.getNodes().iterator(); nodes.hasNext(); ) {
      Object node=nodes.next();
      if (node instanceof SootField) {
        SootField field=(SootField)node;
        if (field.isPrivate()) {
          continue;
        }
        if (Modifier.isFinal(field.getModifiers())) {
          continue;
        }
        if (_debug) {
          System.out.println(""String_Node_Str"" + unit + ""String_Node_Str""+ field);
        }
        _setCanPointToAnything(out,node);
      }
    }
  }
  if (unit instanceof DefinitionStmt) {
    DefinitionStmt assignStmt=(DefinitionStmt)unit;
    Value lvalue=assignStmt.getLeftOp();
    Value rvalue=assignStmt.getRightOp();
    if (_debug) {
    }
    if (_isAliasableType(lvalue.getType())) {
      Object lobject=_getAliasObject(lvalue,out);
      Object robject=_getAliasObject(rvalue,out);
      if (!out.containsNode(lobject)) {
        out.addNode(lobject);
      }
      if (!out.containsNode(robject) && robject != null) {
        out.addNode(robject);
      }
      if (robject == null) {
      }
 else {
        _setCanPointTo(out,lobject,robject);
      }
    }
  }
  if (_debug)   System.out.println(""String_Node_Str"" + out);
}"
75770,"/** 
 * Create a new analysis based on the given invoke graph and side effect information. 
 */
public MaybeAliasAnalysis(UnitGraph g,InvokeGraph invokeGraph,SideEffectAnalysis sideEffectAnalysis){
  super(g);
  _invokeGraph=invokeGraph;
  _sideEffectAnalysis=sideEffectAnalysis;
  _countMap=new HashMap();
  int index=0;
  _constructorMap=new HashMap();
  for (Iterator units=g.getBody().getUnits().iterator(); units.hasNext(); ) {
    Stmt stmt=(Stmt)units.next();
    if (stmt instanceof DefinitionStmt) {
      Value rvalue=((DefinitionStmt)stmt).getRightOp();
      if (!_isAliasableType(rvalue.getType())) {
        continue;
      }
      if (rvalue instanceof NewExpr || rvalue instanceof NewArrayExpr) {
        Object object=new String(""String_Node_Str"" + index++ + ""String_Node_Str""+ rvalue.toString());
        _constructorMap.put(rvalue,object);
      }
 else       if (rvalue instanceof Constant) {
        Object object=new String(""String_Node_Str"" + index++ + ""String_Node_Str""+ rvalue.toString());
        _constructorMap.put(rvalue,object);
      }
    }
  }
  doAnalysis();
  if (_debug) {
    for (Iterator units=g.getBody().getUnits().iterator(); units.hasNext(); ) {
      Stmt stmt=(Stmt)units.next();
      System.out.println(""String_Node_Str"" + _countMap.get(stmt) + ""String_Node_Str""+ stmt);
    }
  }
  _invokeGraph=null;
  _sideEffectAnalysis=null;
  _countMap=null;
}","/** 
 * Create a new analysis based on the given invoke graph and side effect information. 
 */
public MaybeAliasAnalysis(UnitGraph g,InvokeGraph invokeGraph,SideEffectAnalysis sideEffectAnalysis){
  super(g);
  _invokeGraph=invokeGraph;
  _sideEffectAnalysis=sideEffectAnalysis;
  if (_debug) {
    _countMap=new HashMap();
  }
  int index=0;
  _constructorMap=new HashMap();
  for (Iterator units=g.getBody().getUnits().iterator(); units.hasNext(); ) {
    Stmt stmt=(Stmt)units.next();
    if (stmt instanceof DefinitionStmt) {
      Value rvalue=((DefinitionStmt)stmt).getRightOp();
      if (!_isAliasableType(rvalue.getType())) {
        continue;
      }
      if (rvalue instanceof NewExpr || rvalue instanceof NewArrayExpr) {
        Object object=new String(""String_Node_Str"" + index++ + ""String_Node_Str""+ rvalue.toString());
        _constructorMap.put(rvalue,object);
      }
 else       if (rvalue instanceof Constant) {
        Object object=new String(""String_Node_Str"" + index++ + ""String_Node_Str""+ rvalue.toString());
        _constructorMap.put(rvalue,object);
      }
    }
  }
  doAnalysis();
  if (_debug) {
    for (Iterator units=g.getBody().getUnits().iterator(); units.hasNext(); ) {
      Stmt stmt=(Stmt)units.next();
      System.out.println(""String_Node_Str"" + _countMap.get(stmt) + ""String_Node_Str""+ stmt);
    }
  }
  _invokeGraph=null;
  _sideEffectAnalysis=null;
  _countMap=null;
}"
75771,"private void _setCanPointToAnything(GraphFlow graph,Object object){
  graph.addEdge(object,_universeRepresentative);
  for (Iterator constructors=_constructorMap.keySet().iterator(); constructors.hasNext(); ) {
    Value constructor=(Value)constructors.next();
    if (object instanceof SootField) {
      SootField field=(SootField)object;
      if (constructor.getType() instanceof RefType && field.getType() instanceof RefType) {
        if (constructor.getType().merge(field.getType(),Scene.v()).equals(constructor.getType())) {
          continue;
        }
      }
    }
    Object target=_constructorMap.get(constructor);
    if (graph.containsNode(target)) {
      graph.addEdge(object,target);
    }
  }
}","private void _setCanPointToAnything(GraphFlow graph,Object object){
  graph.addEdge(object,_universeRepresentative);
  for (Iterator constructors=_constructorMap.keySet().iterator(); constructors.hasNext(); ) {
    Value constructor=(Value)constructors.next();
    if (object instanceof SootField) {
      SootField field=(SootField)object;
      Type constructorType=constructor.getType();
      Type fieldType=field.getType();
      if (!_isCompatibileAliasAssignment(constructorType,fieldType)) {
        continue;
      }
    }
    Object target=_constructorMap.get(constructor);
    if (graph.containsNode(target)) {
      graph.addEdge(object,target);
    }
  }
}"
75772,"/** 
 * Return a Token from the matlab engine.
 * @param name Matlab variable name used to initialize the returned Token
 * @return PtolemyII Token.
 * @exception IllegalActionException If the matlab engine is not opened, orif the matlab variable was not found in the engine. In this case, the matlab engine's stdout is included in the exception message.
 * @see Engine
 */
public Token get(String name) throws IllegalActionException {
}","/** 
 * Return a Token from the matlab engine.
 * @param name Matlab variable name used to initialize the returned Token
 * @return PtolemyII Token.
 * @exception IllegalActionException If the matlab engine is not opened, orif the matlab variable was not found in the engine. In this case, the matlab engine's stdout is included in the exception message.
 * @see Engine
 */
public Token get(String name) throws IllegalActionException {
  Token retval=null;
synchronized (semaphore) {
    if (eng == 0) {
      throw new IllegalActionException(""String_Node_Str"" + errNotOpened);
    }
    long ma=ptmatlabEngGetArray(eng,name);
    if (ma == 0) {
      throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ name+ ""String_Node_Str""+ getOutput().stringValue());
    }
    retval=_convertMxArrayToToken(ma);
    ptmatlabDestroy(ma,name);
    if (debug > 0) {
      System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ retval.toString());
    }
  }
  return retval;
}"
75773,"private Token _convertMxArrayToToken(long ma) throws IllegalActionException {
  String maClassStr=ptmatlabGetClassName(ma);
  int[] dims=ptmatlabGetDimensions(ma);
  int nRows=dims[0];
  int nCols=dims[1];
  boolean scalar=nCols == 1 && nRows == 1;
  Token retval=null;
  if (maClassStr.equals(""String_Node_Str"")) {
    if (ptmatlabIsComplex(ma)) {
      Complex[][] a=ptmatlabGetComplexMatrix(ma,nRows,nCols);
      if (a == null) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      if (scalar) {
        retval=new ComplexToken(a[0][0]);
      }
 else {
        retval=new ComplexMatrixToken(a);
      }
    }
 else {
      double[][] a=ptmatlabGetDoubleMatrix(ma,nRows,nCols);
      if (a == null) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      if (scalar) {
        double tmp=a[0][0];
        if (tmp == Math.floor(tmp) && Math.abs(tmp) <= Integer.MAX_VALUE)         retval=new IntToken((int)tmp);
 else         retval=new DoubleToken(tmp);
      }
 else {
        retval=new DoubleMatrixToken(a);
      }
    }
  }
 else   if (maClassStr.equals(""String_Node_Str"")) {
    int nfields=ptmatlabGetNumberOfFields(ma);
    Token[] ta=new Token[nCols];
    Token[] tr=new Token[nRows];
    String[] fieldNames=new String[nfields];
    for (int k=0; k < nfields; k++) {
      fieldNames[k]=ptmatlabGetFieldNameByNumber(ma,k);
    }
    Token[] fieldValues=new Token[nfields];
    for (int n=0; n < nRows; n++) {
      for (int m=0; m < nCols; m++) {
        for (int k=0; k < nfields; k++) {
          long fma=ptmatlabGetFieldByNumber(ma,k,n,m);
          if (fma != 0) {
            fieldValues[k]=_convertMxArrayToToken(fma);
          }
 else {
            throw new IllegalActionException(""String_Node_Str"" + fieldNames[k] + +""String_Node_Str""+ ""String_Node_Str""+ nRows+ ""String_Node_Str""+ nCols);
          }
        }
        ta[m]=new RecordToken(fieldNames,fieldValues);
      }
      tr[n]=new ArrayToken(ta);
    }
    if (scalar) {
      retval=((ArrayToken)tr[0]).getElement(0);
    }
 else {
      retval=new ArrayToken(tr);
    }
  }
 else   if (maClassStr.equals(""String_Node_Str"")) {
    Token[] ta=new Token[nCols];
    Token[] tr=new Token[nRows];
    for (int n=0; n < nRows; n++) {
      for (int m=0; m < nCols; m++) {
        long cma=ptmatlabGetCell(ma,n,m);
        if (cma != 0) {
          ta[m]=_convertMxArrayToToken(cma);
        }
      }
      tr[n]=new ArrayToken(ta);
    }
    if (scalar) {
      retval=((ArrayToken)tr[0]).getElement(0);
    }
 else     if (nRows == 1) {
      retval=tr[0];
    }
 else {
      retval=new ArrayToken(tr);
    }
  }
 else   if (maClassStr.equals(""String_Node_Str"")) {
    if (nRows == 1)     retval=new StringToken(ptmatlabGetString(ma,0));
 else {
      Token[] ta=new Token[nRows];
      for (int n=0; n < nRows; n++) {
        ta[n]=new StringToken(ptmatlabGetString(ma,n));
      }
      retval=new ArrayToken(ta);
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + maClassStr + ""String_Node_Str""+ dims[0]+ ""String_Node_Str""+ dims[1]);
  }
  return retval;
}","private Token _convertMxArrayToToken(long ma) throws IllegalActionException {
  String maClassStr=ptmatlabGetClassName(ma);
  int[] dims=ptmatlabGetDimensions(ma);
  int nRows=dims[0];
  int nCols=dims[1];
  boolean scalar=nCols == 1 && nRows == 1;
  Token retval=null;
  if (maClassStr.equals(""String_Node_Str"")) {
    if (ptmatlabIsComplex(ma)) {
      Complex[][] a=ptmatlabGetComplexMatrix(ma,nRows,nCols);
      if (a == null) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      if (scalar) {
        retval=new ComplexToken(a[0][0]);
      }
 else {
        retval=new ComplexMatrixToken(a);
      }
    }
 else {
      double[][] a=ptmatlabGetDoubleMatrix(ma,nRows,nCols);
      if (a == null) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      if (scalar) {
        double tmp=a[0][0];
        if (tmp == Math.floor(tmp) && Math.abs(tmp) <= Integer.MAX_VALUE)         retval=new IntToken((int)tmp);
 else         retval=new DoubleToken(tmp);
      }
 else {
        retval=new DoubleMatrixToken(a);
      }
    }
  }
 else   if (maClassStr.equals(""String_Node_Str"")) {
    int nfields=ptmatlabGetNumberOfFields(ma);
    Token[] ta=new Token[nCols];
    Token[] tr=new Token[nRows];
    String[] fieldNames=new String[nfields];
    for (int k=0; k < nfields; k++) {
      fieldNames[k]=ptmatlabGetFieldNameByNumber(ma,k);
    }
    Token[] fieldValues=new Token[nfields];
    for (int n=0; n < nRows; n++) {
      for (int m=0; m < nCols; m++) {
        for (int k=0; k < nfields; k++) {
          long fma=ptmatlabGetFieldByNumber(ma,k,n,m);
          if (fma != 0) {
            fieldValues[k]=_convertMxArrayToToken(fma);
          }
 else {
            throw new IllegalActionException(""String_Node_Str"" + fieldNames[k] + ""String_Node_Str""+ ""String_Node_Str""+ nRows+ ""String_Node_Str""+ nCols);
          }
        }
        ta[m]=new RecordToken(fieldNames,fieldValues);
      }
      tr[n]=new ArrayToken(ta);
    }
    if (scalar) {
      retval=((ArrayToken)tr[0]).getElement(0);
    }
 else {
      retval=new ArrayToken(tr);
    }
  }
 else   if (maClassStr.equals(""String_Node_Str"")) {
    Token[] ta=new Token[nCols];
    Token[] tr=new Token[nRows];
    for (int n=0; n < nRows; n++) {
      for (int m=0; m < nCols; m++) {
        long cma=ptmatlabGetCell(ma,n,m);
        if (cma != 0) {
          ta[m]=_convertMxArrayToToken(cma);
        }
      }
      tr[n]=new ArrayToken(ta);
    }
    if (scalar) {
      retval=((ArrayToken)tr[0]).getElement(0);
    }
 else     if (nRows == 1) {
      retval=tr[0];
    }
 else {
      retval=new ArrayToken(tr);
    }
  }
 else   if (maClassStr.equals(""String_Node_Str"")) {
    if (nRows == 1)     retval=new StringToken(ptmatlabGetString(ma,0));
 else {
      Token[] ta=new Token[nRows];
      for (int n=0; n < nRows; n++) {
        ta[n]=new StringToken(ptmatlabGetString(ma,n));
      }
      retval=new ArrayToken(ta);
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + maClassStr + ""String_Node_Str""+ dims[0]+ ""String_Node_Str""+ dims[1]);
  }
  return retval;
}"
75774,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Expression(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException, java.lang.Exception {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  expression=new StringAttribute(this,""String_Node_Str"");
  _iteration=new Variable(this,""String_Node_Str"",new IntToken(1));
  TransientSingletonConfigurableAttribute iconDescription=new TransientSingletonConfigurableAttribute(this,""String_Node_Str"");
  iconDescription.configure(null,null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  matlabEngine=new Engine();
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Expression(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException, java.lang.Exception {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  expression=new StringAttribute(this,""String_Node_Str"");
  _iteration=new Variable(this,""String_Node_Str"",new IntToken(1));
  TransientSingletonConfigurableAttribute iconDescription=new TransientSingletonConfigurableAttribute(this,""String_Node_Str"");
  matlabEngine=new Engine();
}"
75775,"/** 
 * Return true if the receiver containing this boundary detector is contained on the outside of a boundary port. A boundary port is an opaque port that is contained by a composite actor. If the containing receiver is contained on the outside of a boundary port then return true; otherwise return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is contained on theoutside of a boundary port; return false otherwise.
 */
public boolean isOutsideBoundary(){
  if (_outsideBoundaryCacheIsOn) {
    return _isInsideBoundaryValue;
  }
 else {
    IOPort innerPort=(IOPort)_rcvr.getContainer();
    if (innerPort == null) {
      _outsideBoundaryCacheIsOn=false;
      _isOutsideBoundaryValue=false;
      return _isOutsideBoundaryValue;
    }
    ComponentEntity innerEntity=(ComponentEntity)innerPort.getContainer();
    if (!innerEntity.isAtomic() && innerPort.isOpaque()) {
      if (innerPort.isOutput() && !innerPort.isInput()) {
        _isOutsideBoundaryValue=false;
      }
 else       if (!innerPort.isOutput() && innerPort.isInput()) {
        _isOutsideBoundaryValue=true;
      }
 else       if (!innerPort.isOutput() && !innerPort.isInput()) {
        _isOutsideBoundaryValue=false;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      _outsideBoundaryCacheIsOn=true;
      return _isOutsideBoundaryValue;
    }
    _outsideBoundaryCacheIsOn=true;
    _isOutsideBoundaryValue=false;
    return _isOutsideBoundaryValue;
  }
}","/** 
 * Return true if the receiver containing this boundary detector is contained on the outside of a boundary port. A boundary port is an opaque port that is contained by a composite actor. If the containing receiver is contained on the outside of a boundary port then return true; otherwise return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is contained on theoutside of a boundary port; return false otherwise.
 */
public boolean isOutsideBoundary(){
  if (_outsideBoundaryCacheIsOn) {
    return _isInsideBoundaryValue;
  }
 else {
    IOPort innerPort=(IOPort)_receiver.getContainer();
    if (innerPort == null) {
      _outsideBoundaryCacheIsOn=false;
      _isOutsideBoundaryValue=false;
      return _isOutsideBoundaryValue;
    }
    ComponentEntity innerEntity=(ComponentEntity)innerPort.getContainer();
    if (!innerEntity.isAtomic() && innerPort.isOpaque()) {
      if (innerPort.isOutput() && !innerPort.isInput()) {
        _isOutsideBoundaryValue=false;
      }
 else       if (!innerPort.isOutput() && innerPort.isInput()) {
        _isOutsideBoundaryValue=true;
      }
 else       if (!innerPort.isOutput() && !innerPort.isInput()) {
        _isOutsideBoundaryValue=false;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      _outsideBoundaryCacheIsOn=true;
      return _isOutsideBoundaryValue;
    }
    _outsideBoundaryCacheIsOn=true;
    _isOutsideBoundaryValue=false;
    return _isOutsideBoundaryValue;
  }
}"
75776,"/** 
 * Return true if the receiver containing this boundary detector is connected to the inside of an input boundary port; return false otherwise. A boundary port is an opaque port that is contained by a composite actor. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is connected to theinside of a boundary port; return false otherwise.
 */
public boolean isConnectedToBoundaryInside(){
  if (_connectedInsideOfBoundaryCacheIsOn) {
    return _isConnectedInsideOfBoundaryValue;
  }
 else {
    IOPort contPort=(IOPort)_rcvr.getContainer();
    if (contPort == null) {
      _connectedInsideOfBoundaryCacheIsOn=false;
      _isConnectedInsideOfBoundaryValue=false;
      return _isConnectedInsideOfBoundaryValue;
    }
    ComponentEntity contEntity=(ComponentEntity)contPort.getContainer();
    IOPort connectedPort=null;
    ComponentEntity connectedEntity=null;
    Iterator ports=contPort.connectedPortList().iterator();
    int cnt=0;
    while (ports.hasNext()) {
      connectedPort=(IOPort)ports.next();
      connectedEntity=(ComponentEntity)connectedPort.getContainer();
      if (connectedEntity == contEntity.getContainer() && connectedPort.isInput()) {
        try {
          Receiver[][] rcvrs=connectedPort.deepGetReceivers();
          for (int i=0; i < rcvrs.length; i++) {
            for (int j=0; j < rcvrs[i].length; j++) {
              if (_rcvr == rcvrs[i][j]) {
                _connectedInsideOfBoundaryCacheIsOn=true;
                _isConnectedInsideOfBoundaryValue=true;
                return true;
              }
            }
          }
        }
 catch (        IllegalActionException e) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
    _connectedInsideOfBoundaryCacheIsOn=true;
    _isConnectedInsideOfBoundaryValue=false;
    return _isConnectedInsideOfBoundaryValue;
  }
}","/** 
 * Return true if the receiver containing this boundary detector is connected to the inside of an input boundary port; return false otherwise. A boundary port is an opaque port that is contained by a composite actor. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is connected to theinside of a boundary port; return false otherwise.
 */
public boolean isConnectedToBoundaryInside(){
  if (_connectedInsideOfBoundaryCacheIsOn) {
    return _isConnectedInsideOfBoundaryValue;
  }
 else {
    IOPort contPort=(IOPort)_receiver.getContainer();
    if (contPort == null) {
      _connectedInsideOfBoundaryCacheIsOn=false;
      _isConnectedInsideOfBoundaryValue=false;
      return _isConnectedInsideOfBoundaryValue;
    }
    ComponentEntity contEntity=(ComponentEntity)contPort.getContainer();
    IOPort connectedPort=null;
    ComponentEntity connectedEntity=null;
    Iterator ports=contPort.connectedPortList().iterator();
    while (ports.hasNext()) {
      connectedPort=(IOPort)ports.next();
      connectedEntity=(ComponentEntity)connectedPort.getContainer();
      if (connectedEntity == contEntity.getContainer() && connectedPort.isInput()) {
        try {
          Receiver[][] receivers=connectedPort.deepGetReceivers();
          for (int i=0; i < receivers.length; i++) {
            for (int j=0; j < receivers[i].length; j++) {
              if (_receiver == receivers[i][j]) {
                _connectedInsideOfBoundaryCacheIsOn=true;
                _isConnectedInsideOfBoundaryValue=true;
                return true;
              }
            }
          }
        }
 catch (        IllegalActionException e) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
    _connectedInsideOfBoundaryCacheIsOn=true;
    _isConnectedInsideOfBoundaryValue=false;
    return _isConnectedInsideOfBoundaryValue;
  }
}"
75777,"/** 
 * Return true if the receiver containing this boundary detector is connected to the outside of an output boundary port; return false otherwise. A boundary port is an opaque port that is contained by a composite actor. If the receiver containing this boundary detector is contained on the inside of a boundary port, then return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is connected to theoutside of a boundary port; return false otherwise.
 */
public boolean isConnectedToBoundaryOutside(){
  if (_connectedOutsideOfBoundaryCacheIsOn) {
    return _isConnectedOutsideOfBoundaryValue;
  }
 else {
    IOPort contPort=(IOPort)_rcvr.getContainer();
    if (contPort == null) {
      _connectedOutsideOfBoundaryCacheIsOn=false;
      _isConnectedOutsideOfBoundaryValue=false;
      return _isConnectedOutsideOfBoundaryValue;
    }
    ComponentEntity contEntity=(ComponentEntity)contPort.getContainer();
    IOPort connectedPort=null;
    ComponentEntity connectedEntity=null;
    Iterator ports=contPort.connectedPortList().iterator();
    int cnt=0;
    while (ports.hasNext()) {
      connectedPort=(IOPort)ports.next();
      connectedEntity=(ComponentEntity)connectedPort.getContainer();
      if (connectedPort.isOpaque() && !connectedEntity.isAtomic() && connectedPort.isOutput()) {
        Receiver[][] rcvrs=connectedPort.getRemoteReceivers();
        for (int i=0; i < rcvrs.length; i++) {
          for (int j=0; j < rcvrs[i].length; j++) {
            if (_rcvr == rcvrs[i][j]) {
              _connectedOutsideOfBoundaryCacheIsOn=true;
              _isConnectedOutsideOfBoundaryValue=true;
              return true;
            }
          }
        }
      }
    }
    _connectedOutsideOfBoundaryCacheIsOn=true;
    _isConnectedOutsideOfBoundaryValue=false;
    return _isConnectedOutsideOfBoundaryValue;
  }
}","/** 
 * Return true if the receiver containing this boundary detector is connected to the outside of an output boundary port; return false otherwise. A boundary port is an opaque port that is contained by a composite actor. If the receiver containing this boundary detector is contained on the inside of a boundary port, then return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is connected to theoutside of a boundary port; return false otherwise.
 */
public boolean isConnectedToBoundaryOutside(){
  if (_connectedOutsideOfBoundaryCacheIsOn) {
    return _isConnectedOutsideOfBoundaryValue;
  }
 else {
    IOPort contPort=(IOPort)_receiver.getContainer();
    if (contPort == null) {
      _connectedOutsideOfBoundaryCacheIsOn=false;
      _isConnectedOutsideOfBoundaryValue=false;
      return _isConnectedOutsideOfBoundaryValue;
    }
    ComponentEntity contEntity=(ComponentEntity)contPort.getContainer();
    IOPort connectedPort=null;
    ComponentEntity connectedEntity=null;
    Iterator ports=contPort.connectedPortList().iterator();
    while (ports.hasNext()) {
      connectedPort=(IOPort)ports.next();
      connectedEntity=(ComponentEntity)connectedPort.getContainer();
      if (connectedPort.isOpaque() && !connectedEntity.isAtomic() && connectedPort.isOutput()) {
        Receiver[][] receivers=connectedPort.getRemoteReceivers();
        for (int i=0; i < receivers.length; i++) {
          for (int j=0; j < receivers[i].length; j++) {
            if (_receiver == receivers[i][j]) {
              _connectedOutsideOfBoundaryCacheIsOn=true;
              _isConnectedOutsideOfBoundaryValue=true;
              return true;
            }
          }
        }
      }
    }
    _connectedOutsideOfBoundaryCacheIsOn=true;
    _isConnectedOutsideOfBoundaryValue=false;
    return _isConnectedOutsideOfBoundaryValue;
  }
}"
75778,"/** 
 * Construct a BoundaryDetector with the specified containing receiver.
 * @param rcvr The receiver containing this BoundaryDetector.
 */
public BoundaryDetector(Receiver rcvr){
  _rcvr=rcvr;
}","/** 
 * Construct a BoundaryDetector with the specified containing receiver.
 * @param receiver The receiver containing this BoundaryDetector.
 */
public BoundaryDetector(Receiver receiver){
  _receiver=receiver;
}"
75779,"/** 
 * Return true if the receiver containing this boundary detector is connected to a boundary port. A boundary port is an opaque port that is contained by a composite actor. If the containing receiver is connected to a boundary port, then return true; otherwise return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is connected toboundary port; return false otherwise.
 */
public boolean isConnectedToBoundary(){
  if (_connectedBoundaryCacheIsOn) {
    return _isConnectedBoundaryValue;
  }
 else {
    IOPort contPort=(IOPort)_rcvr.getContainer();
    if (contPort == null) {
      _connectedBoundaryCacheIsOn=false;
      _isConnectedBoundaryValue=false;
      return _isConnectedBoundaryValue;
    }
    ComponentEntity contEntity=(ComponentEntity)contPort.getContainer();
    IOPort connectedPort=null;
    ComponentEntity connectedEntity=null;
    Iterator ports=contPort.connectedPortList().iterator();
    int cnt=0;
    while (ports.hasNext()) {
      connectedPort=(IOPort)ports.next();
      connectedEntity=(ComponentEntity)connectedPort.getContainer();
      if (connectedEntity == contEntity.getContainer() && connectedPort.isInput()) {
        try {
          Receiver[][] rcvrs=connectedPort.deepGetReceivers();
          for (int i=0; i < rcvrs.length; i++) {
            for (int j=0; j < rcvrs[i].length; j++) {
              if (_rcvr == rcvrs[i][j]) {
                _connectedBoundaryCacheIsOn=true;
                _isConnectedBoundaryValue=true;
                return true;
              }
            }
          }
        }
 catch (        IllegalActionException e) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else       if (connectedPort.isOpaque() && !connectedEntity.isAtomic() && connectedPort.isOutput()) {
        Receiver[][] rcvrs=connectedPort.getRemoteReceivers();
        for (int i=0; i < rcvrs.length; i++) {
          for (int j=0; j < rcvrs[i].length; j++) {
            if (_rcvr == rcvrs[i][j]) {
              _connectedBoundaryCacheIsOn=true;
              _isConnectedBoundaryValue=true;
              return true;
            }
          }
        }
      }
    }
    _connectedBoundaryCacheIsOn=true;
    _isConnectedBoundaryValue=false;
    return _isConnectedBoundaryValue;
  }
}","/** 
 * Return true if the receiver containing this boundary detector is connected to a boundary port. A boundary port is an opaque port that is contained by a composite actor. If the containing receiver is connected to a boundary port, then return true; otherwise return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is connected toboundary port; return false otherwise.
 */
public boolean isConnectedToBoundary(){
  if (_connectedBoundaryCacheIsOn) {
    return _isConnectedBoundaryValue;
  }
 else {
    IOPort contPort=(IOPort)_receiver.getContainer();
    if (contPort == null) {
      _connectedBoundaryCacheIsOn=false;
      _isConnectedBoundaryValue=false;
      return _isConnectedBoundaryValue;
    }
    ComponentEntity contEntity=(ComponentEntity)contPort.getContainer();
    IOPort connectedPort=null;
    ComponentEntity connectedEntity=null;
    Iterator ports=contPort.connectedPortList().iterator();
    while (ports.hasNext()) {
      connectedPort=(IOPort)ports.next();
      connectedEntity=(ComponentEntity)connectedPort.getContainer();
      if (connectedEntity == contEntity.getContainer() && connectedPort.isInput()) {
        try {
          Receiver[][] receivers=connectedPort.deepGetReceivers();
          for (int i=0; i < receivers.length; i++) {
            for (int j=0; j < receivers[i].length; j++) {
              if (_receiver == receivers[i][j]) {
                _connectedBoundaryCacheIsOn=true;
                _isConnectedBoundaryValue=true;
                return true;
              }
            }
          }
        }
 catch (        IllegalActionException e) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
 else       if (connectedPort.isOpaque() && !connectedEntity.isAtomic() && connectedPort.isOutput()) {
        Receiver[][] receivers=connectedPort.getRemoteReceivers();
        for (int i=0; i < receivers.length; i++) {
          for (int j=0; j < receivers[i].length; j++) {
            if (_receiver == receivers[i][j]) {
              _connectedBoundaryCacheIsOn=true;
              _isConnectedBoundaryValue=true;
              return true;
            }
          }
        }
      }
    }
    _connectedBoundaryCacheIsOn=true;
    _isConnectedBoundaryValue=false;
    return _isConnectedBoundaryValue;
  }
}"
75780,"/** 
 * Return true if the receiver containing this boundary detector is contained on the inside of a boundary port. A boundary port is an opaque port that is contained by a composite actor. If the containing receiver is contained on the inside of a boundary port then return true; otherwise return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is contained on theinside of a boundary port; return false otherwise.
 */
public boolean isInsideBoundary(){
  if (_insideBoundaryCacheIsOn) {
    return _isInsideBoundaryValue;
  }
 else {
    IOPort innerPort=(IOPort)_rcvr.getContainer();
    if (innerPort == null) {
      _insideBoundaryCacheIsOn=false;
      _isInsideBoundaryValue=false;
      return _isInsideBoundaryValue;
    }
    ComponentEntity innerEntity=(ComponentEntity)innerPort.getContainer();
    if (!innerEntity.isAtomic() && innerPort.isOpaque()) {
      if (innerPort.isOutput() && !innerPort.isInput()) {
        _isInsideBoundaryValue=true;
      }
 else       if (!innerPort.isOutput() && innerPort.isInput()) {
        _isInsideBoundaryValue=false;
      }
 else       if (!innerPort.isOutput() && !innerPort.isInput()) {
        _isInsideBoundaryValue=false;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      _insideBoundaryCacheIsOn=true;
      return _isInsideBoundaryValue;
    }
    _insideBoundaryCacheIsOn=true;
    _isInsideBoundaryValue=false;
    return _isInsideBoundaryValue;
  }
}","/** 
 * Return true if the receiver containing this boundary detector is contained on the inside of a boundary port. A boundary port is an opaque port that is contained by a composite actor. If the containing receiver is contained on the inside of a boundary port then return true; otherwise return false. This method is not synchronized so the caller should be.
 * @return True if the containing receiver is contained on theinside of a boundary port; return false otherwise.
 */
public boolean isInsideBoundary(){
  if (_insideBoundaryCacheIsOn) {
    return _isInsideBoundaryValue;
  }
 else {
    IOPort innerPort=(IOPort)_receiver.getContainer();
    if (innerPort == null) {
      _insideBoundaryCacheIsOn=false;
      _isInsideBoundaryValue=false;
      return _isInsideBoundaryValue;
    }
    ComponentEntity innerEntity=(ComponentEntity)innerPort.getContainer();
    if (!innerEntity.isAtomic() && innerPort.isOpaque()) {
      if (innerPort.isOutput() && !innerPort.isInput()) {
        _isInsideBoundaryValue=true;
      }
 else       if (!innerPort.isOutput() && innerPort.isInput()) {
        _isInsideBoundaryValue=false;
      }
 else       if (!innerPort.isOutput() && !innerPort.isInput()) {
        _isInsideBoundaryValue=false;
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
      }
      _insideBoundaryCacheIsOn=true;
      return _isInsideBoundaryValue;
    }
    _insideBoundaryCacheIsOn=true;
    _isInsideBoundaryValue=false;
    return _isInsideBoundaryValue;
  }
}"
75781,"/** 
 * Return the producer receiver that this branch gets data from.
 * @return The producer receiver that this branch gets data from.
 * @see ptolemy.actor.process.BoundaryDetector
 */
public ProcessReceiver getProdReceiver(){
  return _prodRcvr;
}","/** 
 * Return the producer receiver that this branch gets data from.
 * @return The producer receiver that this branch gets data from.
 * @see ptolemy.actor.process.BoundaryDetector
 */
public ProcessReceiver getProdReceiver(){
  return _producerReceiver;
}"
75782,"/** 
 * Construct a branch object with a producer receiver, a consumer receiver and a branch controller.
 * @param prodRcvr The producer receiver assigned to this branch.
 * @param consRcvr The consumer receiver assigned to this branch.
 * @param cntlr The branch controller assigned to this branch.
 * @exception IllegalActionException If the receivers assigned tothis branch are null or improperly configured.
 */
public Branch(ProcessReceiver prodRcvr,ProcessReceiver consRcvr,BranchController cntlr) throws IllegalActionException {
  _controller=cntlr;
  if (prodRcvr == null || consRcvr == null) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!prodRcvr.isProducerReceiver()) {
    String name=((Nameable)consRcvr.getContainer()).getName();
    throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  _prodRcvr=prodRcvr;
  if (!consRcvr.isConsumerReceiver()) {
    String name=((Nameable)consRcvr.getContainer()).getName();
    throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  _consRcvr=consRcvr;
}","/** 
 * Construct a branch object with a producer receiver, a consumer receiver and a branch controller.
 * @param producerReceiver The producer receiver assigned to this branch.
 * @param consumerReceiver The consumer receiver assigned to this branch.
 * @param controller The branch controller assigned to this branch.
 * @exception IllegalActionException If the receivers assigned tothis branch are null or improperly configured.
 */
public Branch(ProcessReceiver producerReceiver,ProcessReceiver consumerReceiver,BranchController controller) throws IllegalActionException {
  _controller=controller;
  if (producerReceiver == null || consumerReceiver == null) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!producerReceiver.isProducerReceiver()) {
    String name=((Nameable)consumerReceiver.getContainer()).getName();
    throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  _producerReceiver=producerReceiver;
  if (!consumerReceiver.isConsumerReceiver()) {
    String name=((Nameable)consumerReceiver.getContainer()).getName();
    throw new IllegalActionException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  _consumerReceiver=consumerReceiver;
}"
75783,"/** 
 * Transfer a single token from the producer receiver to the consumer receiver. If either the producer receiver or consumer receiver is null then return without attempting token transfer.
 */
public void transferToken(){
  if (_prodRcvr == null) {
    return;
  }
 else   if (_consRcvr == null) {
    return;
  }
  Token token=_prodRcvr.get(this);
  _consRcvr.put(token,this);
}","/** 
 * Transfer a single token from the producer receiver to the consumer receiver. If either the producer receiver or consumer receiver is null then return without attempting token transfer.
 */
public void transferToken(){
  if (_producerReceiver == null) {
    return;
  }
 else   if (_consumerReceiver == null) {
    return;
  }
  Token token=_producerReceiver.get(this);
  _consumerReceiver.put(token,this);
}"
75784,"/** 
 * Return the consumer receiver that this branch puts data into.
 * @return The consumer receiver that this branch puts data into.
 * @see ptolemy.actor.process.BoundaryDetector
 */
public ProcessReceiver getConsReceiver(){
  return _consRcvr;
}","/** 
 * Return the consumer receiver that this branch puts data into.
 * @return The consumer receiver that this branch puts data into.
 * @see ptolemy.actor.process.BoundaryDetector
 */
public ProcessReceiver getConsReceiver(){
  return _consumerReceiver;
}"
75785,"/** 
 * Register that the receiver controlled by this branch is no longer blocked.
 * @param rcvr The receiver assigned to this branch forwhich a block is being removed.
 */
public void registerRcvrUnBlocked(ProcessReceiver rcvr){
  if (_rcvrBlocked) {
    _rcvrBlocked=false;
    _controller._branchUnBlocked(rcvr);
  }
}","/** 
 * Register that the receiver controlled by this branch is no longer blocked.
 * @param receiver The receiver assigned to this branch forwhich a block is being removed.
 */
public void registerRcvrUnBlocked(ProcessReceiver receiver){
  if (_receiverBlocked) {
    _receiverBlocked=false;
    _controller._branchUnBlocked(receiver);
  }
}"
75786,"/** 
 * Register that the receiver controlled by this branch is blocked. The blocked receiver, either the producer or consumer receiver (but not both) are passed as an argument according to which one is blocked.
 * @param rcvr The receiver assigned to this branch thatis blocked.
 */
public void registerRcvrBlocked(ProcessReceiver rcvr){
  if (!_rcvrBlocked) {
    _rcvrBlocked=true;
    _controller._branchBlocked(rcvr);
  }
}","/** 
 * Register that the receiver controlled by this branch is blocked. The blocked receiver, either the producer or consumer receiver (but not both) are passed as an argument according to which one is blocked.
 * @param receiver The receiver assigned to this branch thatis blocked.
 */
public void registerRcvrBlocked(ProcessReceiver receiver){
  if (!_receiverBlocked) {
    _receiverBlocked=true;
    _controller._branchBlocked(receiver);
  }
}"
75787,"/** 
 * Remove the specified entity, and if there are no more tableaux contained, then remove this object from its container.
 * @param entity The tableau to remove.
 */
protected void _removeEntity(ComponentEntity entity){
  super._removeEntity(entity);
  if (entityList(Tableau.class).size() == 0) {
    try {
      setContainer(null);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      throw new InternalErrorException(""String_Node_Str"");
    }
  }
}","/** 
 * Remove the specified entity, and if there are no remaining tableaux contained by this effigy or any effigy it contains, then remove this object from its container.
 * @param entity The tableau to remove.
 */
protected void _removeEntity(ComponentEntity entity){
  super._removeEntity(entity);
  if (numberOfOpenTableaux() == 0) {
    try {
      setContainer(null);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      throw new InternalErrorException(""String_Node_Str"");
    }
  }
}"
75788,"private void _entities(JimpleBody body,Local thisLocal,CompositeEntity composite,EntitySootClass modelClass,Map options){
  for (Iterator entities=composite.entityList().iterator(); entities.hasNext(); ) {
    Entity entity=(Entity)entities.next();
    System.out.println(""String_Node_Str"" + entity);
    String className;
    if (Options.getBoolean(options,""String_Node_Str"")) {
      className=ActorTransformer.getInstanceClassName(entity,options);
    }
 else {
      className=entity.getClass().getName();
    }
    String entityName=getFieldNameForEntity(entity);
    Local local=PtolemyUtilities.createNamedObjAndLocal(body,className,thisLocal,entityName);
    _entityLocalMap.put(entity,local);
    if (entity instanceof CompositeEntity) {
      _composite(body,local,(CompositeEntity)entity,modelClass,options);
    }
 else {
      _ports(body,thisLocal,composite,local,entity,modelClass);
    }
    if (Options.getBoolean(options,""String_Node_Str"")) {
      SootUtilities.createAndSetFieldFromLocal(body,local,modelClass,PtolemyUtilities.actorType,entityName);
    }
 else {
      createFieldsForAttributes(body,composite,thisLocal,entity,local,modelClass);
    }
  }
}","private void _entities(JimpleBody body,Local thisLocal,CompositeEntity composite,EntitySootClass modelClass,Map options){
  for (Iterator entities=composite.entityList().iterator(); entities.hasNext(); ) {
    Entity entity=(Entity)entities.next();
    System.out.println(""String_Node_Str"" + entity);
    String className;
    if (Options.getBoolean(options,""String_Node_Str"")) {
      className=ActorTransformer.getInstanceClassName(entity,options);
    }
 else {
      className=entity.getClass().getName();
    }
    Local local=PtolemyUtilities.createNamedObjAndLocal(body,className,thisLocal,entity.getName());
    _entityLocalMap.put(entity,local);
    if (entity instanceof CompositeEntity) {
      _composite(body,local,(CompositeEntity)entity,modelClass,options);
    }
 else {
      _ports(body,thisLocal,composite,local,entity,modelClass);
    }
    if (Options.getBoolean(options,""String_Node_Str"")) {
      String entityFieldName=getFieldNameForEntity(entity);
      SootUtilities.createAndSetFieldFromLocal(body,local,modelClass,PtolemyUtilities.actorType,entityFieldName);
    }
 else {
      createFieldsForAttributes(body,composite,thisLocal,entity,local,modelClass);
    }
  }
}"
75789,"/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public SingleEvent(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  time=new Parameter(this,""String_Node_Str"",new DoubleToken(0.0));
  value=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
  output.setTypeSameAs(value);
}","/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public SingleEvent(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  time=new Parameter(this,""String_Node_Str"",new DoubleToken(0.0));
  time.setTypeEquals(BaseType.DOUBLE);
  value=new Parameter(this,""String_Node_Str"",new BooleanToken(true));
  output.setTypeSameAs(value);
}"
75790,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then links the type of the <i>value</i> parameter to the output.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class hashas an attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  SingleEvent newObject=(SingleEvent)super.clone(workspace);
  newObject.output.setTypeSameAs(value);
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then links the type of the <i>value</i> parameter to the output.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class hashas an attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  SingleEvent newObject=(SingleEvent)super.clone(workspace);
  newObject.output.setTypeSameAs(newObject.value);
  return newObject;
}"
75791,"/** 
 * Return the CTSchedule. Caching of the schedule is done in the director class, so this method does not test for the validation of the schedule.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  CTSchedule ctSchedule=new CTSchedule();
  SignalTypes signalTypes=new SignalTypes();
  LinkedList sinkActors=new LinkedList();
  LinkedList dynamicActors=new LinkedList();
  LinkedList discreteActors=new LinkedList();
  LinkedList arithmeticActors=new LinkedList();
  LinkedList eventGenerators=new LinkedList();
  LinkedList waveformGenerators=new LinkedList();
  LinkedList continuousActors=new LinkedList();
  Schedule discreteActorSchedule=new Schedule();
  Schedule continuousActorSchedule=new Schedule();
  Schedule dynamicActorSchedule=new Schedule();
  Schedule eventGeneratorSchedule=new Schedule();
  Schedule outputSchedule=new Schedule();
  Schedule outputSSCActors=new Schedule();
  Schedule stateTransitionSchedule=new Schedule();
  Schedule statefulActors=new Schedule();
  Schedule stateSSCActors=new Schedule();
  Schedule waveformGeneratorSchedule=new Schedule();
  CompositeActor container=(CompositeActor)getContainer().getContainer();
  continuousActors=(LinkedList)((LinkedList)container.deepEntityList()).clone();
  Iterator allActors=container.deepEntityList().iterator();
  while (allActors.hasNext()) {
    Actor a=(Actor)allActors.next();
    if (a instanceof CTStatefulActor) {
      statefulActors.add(new Firing(a));
    }
    if (a instanceof CTWaveformGenerator) {
      waveformGenerators.add(a);
    }
    if (a instanceof CTEventGenerator) {
      eventGenerators.add(a);
    }
    if (a instanceof CTDynamicActor) {
      dynamicActors.addLast(a);
    }
 else     if (!(a instanceof CTWaveformGenerator)) {
      arithmeticActors.add(a);
    }
    if (a instanceof SequenceActor) {
      if (predecessorList(a).isEmpty()) {
        throw new NotSchedulableException(((Nameable)a).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        signalTypes.setType(port,DISCRETE);
        if (port.isOutput()) {
          signalTypes.propagateType(port);
        }
      }
    }
 else     if ((a instanceof TypedCompositeActor) && !(a instanceof CTStepSizeControlActor)) {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        signalTypes.setType(port,DISCRETE);
        if (port.isOutput()) {
          signalTypes.propagateType(port);
        }
      }
    }
 else {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        Parameter signalType=(Parameter)port.getAttribute(""String_Node_Str"");
        if (signalType != null) {
          String type=((StringToken)signalType.getToken()).stringValue();
          type=type.trim().toUpperCase();
          if (type.equals(""String_Node_Str"")) {
            signalTypes.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              signalTypes.propagateType(port);
            }
          }
 else           if (type.equals(""String_Node_Str"")) {
            signalTypes.setType(port,DISCRETE);
            if (port.isOutput()) {
              signalTypes.propagateType(port);
            }
          }
 else {
            throw new InvalidStateException(port,""String_Node_Str"");
          }
        }
 else         if (a instanceof CTCompositeActor) {
          signalTypes.setType(port,CONTINUOUS);
          if (port.isOutput()) {
            signalTypes.propagateType(port);
          }
        }
      }
      if (predecessorList(a).isEmpty()) {
        ports=((Entity)a).portList().iterator();
        while (ports.hasNext()) {
          IOPort port=(IOPort)ports.next();
          if (signalTypes.getType(port).equals(UNKNOWN)) {
            signalTypes.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              signalTypes.propagateType(port);
            }
          }
        }
      }
    }
  }
  DirectedAcyclicGraph arithmeticGraph=_toGraph(arithmeticActors);
  if (!arithmeticGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  DirectedAcyclicGraph dynamicGraph=_toGraph(dynamicActors);
  if (!dynamicGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  Object[] sortedArithmeticActors=arithmeticGraph.topologicalSort();
  for (int i=0; i < sortedArithmeticActors.length; i++) {
    Actor actor=(Actor)sortedArithmeticActors[i];
    Iterator inputPorts=actor.inputPortList().iterator();
    Integer knownType=UNKNOWN;
    boolean needManuallySetType=true;
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      if (port.getWidth() != 0) {
        Integer type=signalTypes.getType(port);
        if (type.equals(UNKNOWN)) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName());
        }
 else         if (knownType == UNKNOWN) {
          knownType=type;
          needManuallySetType=false;
        }
 else         if (!knownType.equals(type)) {
          needManuallySetType=true;
          break;
        }
      }
    }
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      Integer type=signalTypes.getType(port);
      if (type.equals(UNKNOWN)) {
        if (needManuallySetType) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName());
        }
 else {
          signalTypes.setType(port,knownType);
        }
      }
      signalTypes.propagateType(port);
    }
  }
  discreteActors=signalTypes.getDiscreteActors();
  continuousActors=signalTypes.getContinuousActors();
  DirectedAcyclicGraph discreteGraph=_toGraph(discreteActors);
  Object[] discreteSorted=discreteGraph.topologicalSort();
  for (int i=0; i < discreteSorted.length; i++) {
    discreteActorSchedule.add(new Firing((Actor)discreteSorted[i]));
  }
  Iterator continuousIterator=continuousActors.iterator();
  while (continuousIterator.hasNext()) {
    Actor actor=(Actor)continuousIterator.next();
    if ((actor instanceof SequenceActor) || ((actor instanceof CompositeActor) && (!(actor instanceof CTStepSizeControlActor)))) {
      throw new NotSchedulableException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"");
    }
    continuousActorSchedule.add(new Firing(actor));
    if (actor instanceof CTEventGenerator) {
      sinkActors.add(actor);
    }
 else {
      List successorList=successorList(actor);
      if (successorList.isEmpty()) {
        sinkActors.add(actor);
      }
 else {
        Iterator successors=successorList.iterator();
        boolean isSink=true;
        while (successors.hasNext()) {
          Actor successor=(Actor)successors.next();
          if (continuousActors.contains(successor)) {
            isSink=false;
            break;
          }
        }
        if (isSink) {
          sinkActors.add(actor);
        }
      }
    }
  }
  Iterator generators=waveformGenerators.iterator();
  while (generators.hasNext()) {
    Actor generator=(Actor)generators.next();
    waveformGeneratorSchedule.add(new Firing(generator));
  }
  if (!eventGenerators.isEmpty()) {
    DirectedAcyclicGraph eventGraph=_toGraph(eventGenerators);
    Object[] eventSorted=eventGraph.topologicalSort();
    for (int i=0; i < eventSorted.length; i++) {
      eventGeneratorSchedule.add(new Firing((Actor)eventSorted[i]));
    }
  }
  arithmeticGraph=_toArithmeticGraph(continuousActors);
  if (!dynamicActors.isEmpty()) {
    Object[] dynamicArray=dynamicActors.toArray();
    Object[] xSorted=dynamicGraph.topologicalSort(dynamicArray);
    for (int i=0; i < xSorted.length; i++) {
      Actor a=(Actor)xSorted[i];
      dynamicActorSchedule.add(0,new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
    Object[] fx=arithmeticGraph.backwardReachableNodes(dynamicArray);
    Object[] fxSorted=arithmeticGraph.topologicalSort(fx);
    for (int i=0; i < fxSorted.length; i++) {
      Actor a=(Actor)fxSorted[i];
      stateTransitionSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
  }
  if (!sinkActors.isEmpty()) {
    Object[] sinkArray=sinkActors.toArray();
    Object[] gx=arithmeticGraph.backwardReachableNodes(sinkArray);
    Object[] gxSorted=arithmeticGraph.topologicalSort(gx);
    for (int i=0; i < gxSorted.length; i++) {
      Actor a=(Actor)gxSorted[i];
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
    Iterator sinks=sinkActors.iterator();
    while (sinks.hasNext()) {
      Actor a=(Actor)sinks.next();
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
  }
  ctSchedule.add(discreteActorSchedule);
  ctSchedule.add(continuousActorSchedule);
  ctSchedule.add(dynamicActorSchedule);
  ctSchedule.add(eventGeneratorSchedule);
  ctSchedule.add(outputSchedule);
  ctSchedule.add(outputSSCActors);
  ctSchedule.add(stateTransitionSchedule);
  ctSchedule.add(statefulActors);
  ctSchedule.add(stateSSCActors);
  ctSchedule.add(waveformGeneratorSchedule);
  setValid(true);
  return ctSchedule;
}","/** 
 * Return the CTSchedule. Caching of the schedule is done in the director class, so this method does not test for the validation of the schedule.
 */
protected Schedule _getSchedule() throws NotSchedulableException, IllegalActionException {
  CTSchedule ctSchedule=new CTSchedule();
  SignalTypes signalTypes=new SignalTypes();
  LinkedList sinkActors=new LinkedList();
  LinkedList dynamicActors=new LinkedList();
  LinkedList discreteActors=new LinkedList();
  LinkedList arithmeticActors=new LinkedList();
  LinkedList eventGenerators=new LinkedList();
  LinkedList waveformGenerators=new LinkedList();
  LinkedList continuousActors=new LinkedList();
  Schedule discreteActorSchedule=new Schedule();
  Schedule continuousActorSchedule=new Schedule();
  Schedule dynamicActorSchedule=new Schedule();
  Schedule eventGeneratorSchedule=new Schedule();
  Schedule outputSchedule=new Schedule();
  Schedule outputSSCActors=new Schedule();
  Schedule stateTransitionSchedule=new Schedule();
  Schedule statefulActors=new Schedule();
  Schedule stateSSCActors=new Schedule();
  Schedule waveformGeneratorSchedule=new Schedule();
  CompositeActor container=(CompositeActor)getContainer().getContainer();
  continuousActors=(LinkedList)((LinkedList)container.deepEntityList()).clone();
  Iterator allActors=container.deepEntityList().iterator();
  while (allActors.hasNext()) {
    Actor a=(Actor)allActors.next();
    System.out.println(""String_Node_Str"" + ((Nameable)a).getFullName());
    if (a instanceof CTStatefulActor) {
      statefulActors.add(new Firing(a));
    }
    if (a instanceof CTWaveformGenerator) {
      waveformGenerators.add(a);
    }
    if (a instanceof CTEventGenerator) {
      eventGenerators.add(a);
    }
    if (a instanceof CTDynamicActor) {
      dynamicActors.addLast(a);
    }
 else     if (!(a instanceof CTWaveformGenerator)) {
      arithmeticActors.add(a);
    }
    if (a instanceof SequenceActor) {
      if (predecessorList(a).isEmpty()) {
        throw new NotSchedulableException(((Nameable)a).getName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        signalTypes.setType(port,DISCRETE);
        if (port.isOutput()) {
          signalTypes.propagateType(port);
        }
      }
    }
 else     if ((a instanceof TypedCompositeActor) && !(a instanceof CTStepSizeControlActor)) {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        signalTypes.setType(port,DISCRETE);
        if (port.isOutput()) {
          signalTypes.propagateType(port);
        }
      }
    }
 else {
      Iterator ports=((Entity)a).portList().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        Parameter signalType=(Parameter)port.getAttribute(""String_Node_Str"");
        if (signalType != null) {
          String type=((StringToken)signalType.getToken()).stringValue();
          type=type.trim().toUpperCase();
          if (type.equals(""String_Node_Str"")) {
            signalTypes.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              signalTypes.propagateType(port);
            }
          }
 else           if (type.equals(""String_Node_Str"")) {
            signalTypes.setType(port,DISCRETE);
            if (port.isOutput()) {
              signalTypes.propagateType(port);
            }
          }
 else {
            throw new InvalidStateException(port,""String_Node_Str"");
          }
        }
 else         if (a instanceof CTCompositeActor) {
          signalTypes.setType(port,CONTINUOUS);
          if (port.isOutput()) {
            signalTypes.propagateType(port);
          }
        }
      }
      if (predecessorList(a).isEmpty()) {
        ports=((Entity)a).portList().iterator();
        while (ports.hasNext()) {
          IOPort port=(IOPort)ports.next();
          if (signalTypes.getType(port).equals(UNKNOWN)) {
            signalTypes.setType(port,CONTINUOUS);
            if (port.isOutput()) {
              signalTypes.propagateType(port);
            }
          }
        }
      }
    }
  }
  DirectedAcyclicGraph arithmeticGraph=_toGraph(arithmeticActors);
  if (!arithmeticGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"");
  }
  DirectedAcyclicGraph dynamicGraph=_toGraph(dynamicActors);
  if (!dynamicGraph.isAcyclic()) {
    throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  Object[] sortedArithmeticActors=arithmeticGraph.topologicalSort();
  for (int i=0; i < sortedArithmeticActors.length; i++) {
    Actor actor=(Actor)sortedArithmeticActors[i];
    Iterator inputPorts=actor.inputPortList().iterator();
    Integer knownType=UNKNOWN;
    boolean needManuallySetType=true;
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      if (port.getWidth() != 0) {
        Integer type=signalTypes.getType(port);
        if (type.equals(UNKNOWN)) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName());
        }
 else         if (knownType == UNKNOWN) {
          knownType=type;
          needManuallySetType=false;
        }
 else         if (!knownType.equals(type)) {
          needManuallySetType=true;
          break;
        }
      }
    }
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      Integer type=signalTypes.getType(port);
      if (type.equals(UNKNOWN)) {
        if (needManuallySetType) {
          throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"" + port.getFullName());
        }
 else {
          signalTypes.setType(port,knownType);
        }
      }
      signalTypes.propagateType(port);
    }
  }
  discreteActors=signalTypes.getDiscreteActors();
  continuousActors=signalTypes.getContinuousActors();
  DirectedAcyclicGraph discreteGraph=_toGraph(discreteActors);
  Object[] discreteSorted=discreteGraph.topologicalSort();
  for (int i=0; i < discreteSorted.length; i++) {
    discreteActorSchedule.add(new Firing((Actor)discreteSorted[i]));
  }
  Iterator continuousIterator=continuousActors.iterator();
  while (continuousIterator.hasNext()) {
    Actor actor=(Actor)continuousIterator.next();
    if ((actor instanceof SequenceActor) || ((actor instanceof CompositeActor) && (!(actor instanceof CTStepSizeControlActor)))) {
      throw new NotSchedulableException((Nameable)actor,""String_Node_Str"" + ""String_Node_Str"");
    }
    continuousActorSchedule.add(new Firing(actor));
    if (actor instanceof CTEventGenerator) {
      sinkActors.add(actor);
    }
 else {
      List successorList=successorList(actor);
      if (successorList.isEmpty()) {
        sinkActors.add(actor);
      }
 else {
        Iterator successors=successorList.iterator();
        boolean isSink=true;
        while (successors.hasNext()) {
          Actor successor=(Actor)successors.next();
          if (continuousActors.contains(successor)) {
            isSink=false;
            break;
          }
        }
        if (isSink) {
          sinkActors.add(actor);
        }
      }
    }
  }
  Iterator generators=waveformGenerators.iterator();
  while (generators.hasNext()) {
    Actor generator=(Actor)generators.next();
    waveformGeneratorSchedule.add(new Firing(generator));
  }
  if (!eventGenerators.isEmpty()) {
    DirectedAcyclicGraph eventGraph=_toGraph(eventGenerators);
    Object[] eventSorted=eventGraph.topologicalSort();
    for (int i=0; i < eventSorted.length; i++) {
      eventGeneratorSchedule.add(new Firing((Actor)eventSorted[i]));
    }
  }
  arithmeticGraph=_toArithmeticGraph(continuousActors);
  if (!dynamicActors.isEmpty()) {
    Object[] dynamicArray=dynamicActors.toArray();
    Object[] xSorted=dynamicGraph.topologicalSort(dynamicArray);
    for (int i=0; i < xSorted.length; i++) {
      Actor a=(Actor)xSorted[i];
      dynamicActorSchedule.add(0,new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
    Object[] fx=arithmeticGraph.backwardReachableNodes(dynamicArray);
    Object[] fxSorted=arithmeticGraph.topologicalSort(fx);
    for (int i=0; i < fxSorted.length; i++) {
      Actor a=(Actor)fxSorted[i];
      stateTransitionSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        stateSSCActors.add(new Firing(a));
      }
    }
  }
  if (!sinkActors.isEmpty()) {
    Object[] sinkArray=sinkActors.toArray();
    Object[] gx=arithmeticGraph.backwardReachableNodes(sinkArray);
    Object[] gxSorted=arithmeticGraph.topologicalSort(gx);
    for (int i=0; i < gxSorted.length; i++) {
      Actor a=(Actor)gxSorted[i];
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
    Iterator sinks=sinkActors.iterator();
    while (sinks.hasNext()) {
      Actor a=(Actor)sinks.next();
      outputSchedule.add(new Firing(a));
      if (a instanceof CTStepSizeControlActor) {
        outputSSCActors.add(new Firing(a));
      }
    }
  }
  ctSchedule.add(discreteActorSchedule);
  ctSchedule.add(continuousActorSchedule);
  ctSchedule.add(dynamicActorSchedule);
  ctSchedule.add(eventGeneratorSchedule);
  ctSchedule.add(outputSchedule);
  ctSchedule.add(outputSSCActors);
  ctSchedule.add(stateTransitionSchedule);
  ctSchedule.add(statefulActors);
  ctSchedule.add(stateSSCActors);
  ctSchedule.add(waveformGeneratorSchedule);
  setValid(true);
  return ctSchedule;
}"
75792,"public void setType(IOPort port,Integer type) throws NotSchedulableException {
  if (!_map.containsKey(port)) {
    _map.put(port,type);
    Entity actor=(Entity)port.getContainer();
    if (type.equals(CONTINUOUS) && !_continuousActors.contains(actor)) {
      _continuousActors.add(actor);
    }
    if (type.equals(DISCRETE) && !_discreteActors.contains(actor)) {
      _discreteActors.add(actor);
    }
  }
 else {
    Integer previousType=(Integer)_map.get(port);
    if (!previousType.equals(type)) {
      throw new NotSchedulableException(port.getFullName() + ""String_Node_Str"");
    }
  }
}","public void setType(IOPort port,Integer type) throws NotSchedulableException {
  if (!_map.containsKey(port)) {
    _map.put(port,type);
    Entity actor=(Entity)port.getContainer();
    if (type.equals(CONTINUOUS) && actor != CTScheduler.this.getContainer().getContainer() && !_continuousActors.contains(actor)) {
      _continuousActors.add(actor);
    }
    if (type.equals(DISCRETE) && actor != CTScheduler.this.getContainer().getContainer() && !_discreteActors.contains(actor)) {
      _discreteActors.add(actor);
    }
  }
 else {
    Integer previousType=(Integer)_map.get(port);
    if (!previousType.equals(type)) {
      throw new NotSchedulableException(port.getFullName() + ""String_Node_Str"");
    }
  }
}"
75793,"protected void _execute() throws Exception {
  super._execute();
  Entity entity=container.getEntity(newName);
  Iterator ports=container.portList().iterator();
  while (ports.hasNext()) {
    Port port=(Port)ports.next();
    try {
      if (entity instanceof Refinement) {
        ((Refinement)entity)._mirrorDisable=true;
      }
 else       if (entity instanceof ModalController) {
        ((ModalController)entity)._mirrorDisable=true;
      }
      Port newPort=entity.newPort(port.getName());
      if (newPort instanceof RefinementPort && port instanceof IOPort) {
        try {
          ((RefinementPort)newPort)._mirrorDisable=true;
          if (((IOPort)port).isInput()) {
            ((RefinementPort)newPort).setInput(true);
          }
          if (((IOPort)port).isOutput()) {
            ((RefinementPort)newPort).setOutput(true);
          }
          if (((IOPort)port).isMultiport()) {
            ((RefinementPort)newPort).setMultiport(true);
          }
        }
  finally {
          ((RefinementPort)newPort)._mirrorDisable=false;
        }
      }
    }
  finally {
      if (entity instanceof Refinement) {
        ((Refinement)entity)._mirrorDisable=false;
      }
 else       if (entity instanceof ModalController) {
        ((ModalController)entity)._mirrorDisable=false;
      }
    }
  }
  if (_configuration != null) {
    _configuration.openModel(entity);
  }
}","protected void _execute() throws Exception {
  super._execute();
  Entity entity=container.getEntity(newName);
  Iterator ports=container.portList().iterator();
  while (ports.hasNext()) {
    Port port=(Port)ports.next();
    try {
      if (entity instanceof Refinement) {
        ((Refinement)entity)._mirrorDisable=true;
      }
 else       if (entity instanceof ModalController) {
        ((ModalController)entity)._mirrorDisable=true;
      }
      Port newPort=entity.newPort(port.getName());
      if (newPort instanceof RefinementPort && port instanceof IOPort) {
        try {
          ((RefinementPort)newPort)._mirrorDisable=true;
          if (((IOPort)port).isInput()) {
            ((RefinementPort)newPort).setInput(true);
          }
          if (((IOPort)port).isOutput()) {
            ((RefinementPort)newPort).setOutput(true);
          }
          if (((IOPort)port).isMultiport()) {
            ((RefinementPort)newPort).setMultiport(true);
          }
          if (port instanceof TypedIOPort && newPort instanceof TypedIOPort) {
            ((TypedIOPort)newPort).setTypeSameAs((TypedIOPort)port);
          }
        }
  finally {
          ((RefinementPort)newPort)._mirrorDisable=false;
        }
      }
    }
  finally {
      if (entity instanceof Refinement) {
        ((Refinement)entity)._mirrorDisable=false;
      }
 else       if (entity instanceof ModalController) {
        ((ModalController)entity)._mirrorDisable=false;
      }
    }
  }
  if (_configuration != null) {
    _configuration.openModel(entity);
  }
}"
75794,"/** 
 * Create a new port with the specified name in this entity, the controller, and all the refinements.  Link these ports so that if the new port is set to be an input, output, or multiport, then the change is mirrored in the other ports.  The new port will be an instance of ModalPort, which extends TypedIOPort. This method is write-synchronized on the workspace, and increments its version number.
 * @param name The name to assign to the newly created port.
 * @return The new port.
 * @exception NameDuplicationException If the entity already has a portwith the specified name.
 */
public Port newPort(String name) throws NameDuplicationException {
  try {
    _workspace.getWriteAccess();
    Port port=new ModalPort(this,name);
    Iterator entities=entityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      if (entity instanceof ModalController) {
        if (entity.getPort(name) == null) {
          try {
            ((ModalController)entity)._mirrorDisable=true;
            entity.newPort(name);
          }
  finally {
            ((ModalController)entity)._mirrorDisable=false;
          }
        }
      }
 else       if (entity instanceof Refinement) {
        if (entity.getPort(name) == null) {
          try {
            ((Refinement)entity)._mirrorDisable=true;
            entity.newPort(name);
          }
  finally {
            ((Refinement)entity)._mirrorDisable=false;
          }
        }
      }
    }
    return port;
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _workspace.doneWriting();
  }
}","/** 
 * Create a new port with the specified name in this entity, the controller, and all the refinements.  Link these ports so that if the new port is set to be an input, output, or multiport, then the change is mirrored in the other ports.  The new port will be an instance of ModalPort, which extends TypedIOPort. This method is write-synchronized on the workspace, and increments its version number.
 * @param name The name to assign to the newly created port.
 * @return The new port.
 * @exception NameDuplicationException If the entity already has a portwith the specified name.
 */
public Port newPort(String name) throws NameDuplicationException {
  try {
    _workspace.getWriteAccess();
    ModalPort port=new ModalPort(this,name);
    Iterator entities=entityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      if (entity instanceof ModalController) {
        if (entity.getPort(name) == null) {
          try {
            ((ModalController)entity)._mirrorDisable=true;
            Port newPort=entity.newPort(name);
            if (newPort instanceof TypedIOPort) {
              ((TypedIOPort)newPort).setTypeSameAs(port);
            }
          }
  finally {
            ((ModalController)entity)._mirrorDisable=false;
          }
        }
      }
 else       if (entity instanceof Refinement) {
        if (entity.getPort(name) == null) {
          try {
            ((Refinement)entity)._mirrorDisable=true;
            Port newPort=entity.newPort(name);
            if (newPort instanceof TypedIOPort) {
              ((TypedIOPort)newPort).setTypeSameAs(port);
            }
          }
  finally {
            ((Refinement)entity)._mirrorDisable=false;
          }
        }
      }
    }
    return port;
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _workspace.doneWriting();
  }
}"
75795,"/** 
 * If the argument is true, make the port an output port. If the argument is false, make the port not an output port. This method overrides the base class to make the same change on the mirror ports in the controller and state refinments. This method invalidates the schedule and resolved types of the director of the container, if there is one. It is write-synchronized on the workspace, and increments the version of the workspace.
 * @param isOutput True to make the port an output.
 */
public void setOutput(boolean isOutput){
  try {
    _workspace.getWriteAccess();
    super.setOutput(isOutput);
    ModalModel container=(ModalModel)getContainer();
    Iterator entities=container.entityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      Port mirrorPort=entity.getPort(getName());
      if (mirrorPort instanceof RefinementPort) {
        RefinementPort castPort=(RefinementPort)mirrorPort;
        boolean disableStatus=castPort._mirrorDisable;
        try {
          castPort._mirrorDisable=true;
          castPort.setOutput(isOutput);
        }
  finally {
          castPort._mirrorDisable=disableStatus;
        }
      }
    }
  }
  finally {
    _workspace.doneWriting();
  }
}","/** 
 * If the argument is true, make the port an output port. If the argument is false, make the port not an output port. This method overrides the base class to make the same change on the mirror ports in the controller and state refinments. This method invalidates the schedule and resolved types of the director of the container, if there is one. It is write-synchronized on the workspace, and increments the version of the workspace.
 * @param isOutput True to make the port an output.
 */
public void setOutput(boolean isOutput){
  try {
    _workspace.getWriteAccess();
    super.setOutput(isOutput);
    ModalModel container=(ModalModel)getContainer();
    Iterator entities=container.entityList().iterator();
    while (entities.hasNext()) {
      Entity entity=(Entity)entities.next();
      Port mirrorPort=entity.getPort(getName());
      if (mirrorPort instanceof RefinementPort) {
        RefinementPort castPort=(RefinementPort)mirrorPort;
        boolean disableStatus=castPort._mirrorDisable;
        try {
          castPort._mirrorDisable=true;
          castPort.setOutput(isOutput);
        }
  finally {
          castPort._mirrorDisable=disableStatus;
        }
        if (entity.getName().equals(""String_Node_Str"")) {
          boolean controlPortStatus=castPort._mirrorDisable;
          try {
            castPort._mirrorDisable=true;
            castPort.setInput(true);
          }
  finally {
            castPort._mirrorDisable=controlPortStatus;
          }
        }
      }
    }
  }
  finally {
    _workspace.doneWriting();
  }
}"
75796,"/** 
 * If the argument is true, make the port an output port. If the argument is false, make the port not an output port. In addition, if the container is an instance of Refinement, and the argument is true, find the corresponding port of the controller and make it an input and not an output.  This makes it possible for the controller to see the outputs of the refinements. This method overrides the base class to make the same change on the mirror ports in the controller and state refinments. This method invalidates the schedule and resolved types of the director of the container, if there is one. It is write-synchronized on the workspace, and increments the version of the workspace.
 * @param isOutput True to make the port an output.
 */
public void setOutput(boolean isOutput){
  boolean disableStatus=_mirrorDisable;
  try {
    _workspace.getWriteAccess();
    if (_mirrorDisable || getContainer() == null) {
      super.setOutput(isOutput);
    }
 else {
      _mirrorDisable=true;
      boolean success=false;
      Nameable container=getContainer();
      if (container != null) {
        Nameable modal=container.getContainer();
        if (modal instanceof ModalModel) {
          Port port=((ModalModel)modal).getPort(getName());
          if (port instanceof IOPort) {
            ((IOPort)port).setOutput(isOutput);
            success=true;
          }
          if (isOutput && container instanceof Refinement) {
            ModalController controller=(ModalController)((ModalModel)modal).getEntity(""String_Node_Str"");
            if (controller != null) {
              RefinementPort controlPort=(RefinementPort)controller.getPort(getName());
              if (controlPort != null) {
                boolean controlPortStatus=controlPort._mirrorDisable;
                try {
                  controlPort._mirrorDisable=true;
                  controlPort.setInput(true);
                }
  finally {
                  controlPort._mirrorDisable=controlPortStatus;
                }
              }
            }
          }
        }
      }
      if (!success)       super.setOutput(isOutput);
    }
  }
  finally {
    _mirrorDisable=disableStatus;
    _workspace.doneWriting();
  }
}","/** 
 * If the argument is true, make the port an output port. If the argument is false, make the port not an output port. In addition, if the container is an instance of Refinement, and the argument is true, find the corresponding port of the controller and make it an input and not an output.  This makes it possible for the controller to see the outputs of the refinements. This method overrides the base class to make the same change on the mirror ports in the controller and state refinments. This method invalidates the schedule and resolved types of the director of the container, if there is one. It is write-synchronized on the workspace, and increments the version of the workspace.
 * @param isOutput True to make the port an output.
 */
public void setOutput(boolean isOutput){
  boolean disableStatus=_mirrorDisable;
  try {
    _workspace.getWriteAccess();
    if (_mirrorDisable || getContainer() == null) {
      super.setOutput(isOutput);
    }
 else {
      _mirrorDisable=true;
      boolean success=false;
      Nameable container=getContainer();
      if (container != null) {
        Nameable modal=container.getContainer();
        if (modal instanceof ModalModel) {
          Port port=((ModalModel)modal).getPort(getName());
          if (port instanceof IOPort) {
            ((IOPort)port).setOutput(isOutput);
            success=true;
          }
        }
      }
      if (!success)       super.setOutput(isOutput);
    }
  }
  finally {
    _mirrorDisable=disableStatus;
    _workspace.doneWriting();
  }
}"
75797,"/** 
 * Generate code for a special invoke expression.
 * @param v the expression.
 * @return the code.
 */
public void caseSpecialInvokeExpr(SpecialInvokeExpr v){
  SootClass methodClass=v.getMethod().getDeclaringClass();
  SootMethod method=v.getMethod();
  if (!(v.getBase().getType() instanceof RefType)) {
    _unexpectedCase(v,""String_Node_Str"");
  }
 else {
    SootClass baseClass=((RefType)(v.getBase().getType())).getSootClass();
    if (baseClass == methodClass) {
      if (method.isStatic()) {
        _unexpectedCase(v,""String_Node_Str"");
      }
 else {
        _generateInstanceInvokeExpression(v);
      }
    }
 else     if ((!baseClass.hasSuperclass()) || (baseClass.getSuperclass() != methodClass)) {
      _unexpectedCase(v,""String_Node_Str"");
    }
 else     if (_context.getSingleClassMode()) {
      return;
    }
 else {
      v.getBase().apply(this);
      StringBuffer baseCode=_pop();
      _push(CNames.classStructureNameOf(methodClass) + ""String_Node_Str"" + CNames.methodNameOf(method)+ ""String_Node_Str""+ baseCode+ ""String_Node_Str""+ _generateArguments(v,1)+ ""String_Node_Str"");
    }
  }
}","/** 
 * Generate code for a special invoke expression.
 * @param v the expression.
 * @return the code.
 */
public void caseSpecialInvokeExpr(SpecialInvokeExpr v){
  SootClass methodClass=v.getMethod().getDeclaringClass();
  SootMethod method=v.getMethod();
  if (!(v.getBase().getType() instanceof RefType)) {
    _unexpectedCase(v,""String_Node_Str"");
  }
 else {
    SootClass baseClass=((RefType)(v.getBase().getType())).getSootClass();
    if (baseClass == methodClass) {
      if (method.isStatic()) {
        _unexpectedCase(v,""String_Node_Str"");
      }
 else {
        _generateInstanceInvokeExpression(v);
      }
    }
 else     if ((!baseClass.hasSuperclass()) || (baseClass.getSuperclass() != methodClass)) {
      _unexpectedCase(v,""String_Node_Str"");
    }
 else     if (_context.getSingleClassMode()) {
      return;
    }
 else {
      v.getBase().apply(this);
      StringBuffer baseCode=_pop();
      _push(CNames.classStructureNameOf(methodClass) + ""String_Node_Str"" + CNames.methodNameOf(method)+ ""String_Node_Str""+ baseCode+ _generateArguments(v,1)+ ""String_Node_Str"");
    }
  }
}"
75798,"public void caseNullConstant(NullConstant v){
  defaultCase(v);
}","public void caseNullConstant(NullConstant v){
  _push(""String_Node_Str"");
}"
75799,"/** 
 * Create a graph model for the specified Ptolemy II model.
 * @param composite The Ptolemy II model.
 */
public AbstractPtolemyGraphModel(CompositeEntity composite){
  super(composite);
  _composite=composite;
  composite.addChangeListener(new GraphChangeListener());
}","/** 
 * Create a graph model for the specified Ptolemy II model.
 * @param composite The Ptolemy II model.
 */
public AbstractPtolemyGraphModel(CompositeEntity composite){
  super(composite);
  _composite=composite;
  _graphChangeListener=new GraphChangeListener();
  composite.addChangeListener(_graphChangeListener);
}"
75800,"public List typeConstraintList(){
  try {
    _workspace.getReadAccess();
    List result=new LinkedList();
    Iterator inPorts=inputPortList().iterator();
    while (inPorts.hasNext()) {
      TypedIOPort inport=(TypedIOPort)inPorts.next();
      boolean isUndeclared=inport.getTypeTerm().isSettable();
      if (isUndeclared) {
        Iterator outPorts=outputPortList().iterator();
        while (outPorts.hasNext()) {
          TypedIOPort outport=(TypedIOPort)outPorts.next();
          isUndeclared=outport.getTypeTerm().isSettable();
          if (isUndeclared && inport != outport) {
            Inequality ineq=new Inequality(inport.getTypeTerm(),outport.getTypeTerm());
            result.add(ineq);
          }
        }
      }
    }
    Iterator ports=portList().iterator();
    while (ports.hasNext()) {
      Typeable port=(Typeable)ports.next();
      result.addAll(port.typeConstraintList());
    }
    Iterator attrib=attributeList(Typeable.class).iterator();
    while (attrib.hasNext()) {
      Typeable att=(Typeable)attrib.next();
      result.addAll(att.typeConstraintList());
    }
    Iterator trs=relationList().iterator();
    while (trs.hasNext()) {
      Relation tr=(Relation)trs.next();
      attrib=tr.attributeList(Typeable.class).iterator();
      while (attrib.hasNext()) {
        Typeable att=(Typeable)attrib.next();
        result.addAll(att.typeConstraintList());
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}","public List typeConstraintList(){
  try {
    _workspace.getReadAccess();
    List result=new LinkedList();
    Iterator inPorts=inputPortList().iterator();
    while (inPorts.hasNext()) {
      TypedIOPort inport=(TypedIOPort)inPorts.next();
      boolean isUndeclared=inport.getTypeTerm().isSettable();
      if (isUndeclared) {
        Iterator outPorts=outputPortList().iterator();
        while (outPorts.hasNext()) {
          TypedIOPort outport=(TypedIOPort)outPorts.next();
          isUndeclared=outport.getTypeTerm().isSettable();
          if (isUndeclared && inport != outport) {
            Inequality ineq=new Inequality(inport.getTypeTerm(),outport.getTypeTerm());
            result.add(ineq);
          }
        }
      }
    }
    Iterator ports=portList().iterator();
    while (ports.hasNext()) {
      Typeable port=(Typeable)ports.next();
      result.addAll(port.typeConstraintList());
    }
    Iterator attributes=attributeList(Typeable.class).iterator();
    while (attributes.hasNext()) {
      Typeable attribute=(Typeable)attributes.next();
      result.addAll(attribute.typeConstraintList());
    }
    Iterator transitionRelations=relationList().iterator();
    while (transitionRelations.hasNext()) {
      Relation transitionRelation=(Relation)transitionRelations.next();
      attributes=transitionRelation.attributeList(Typeable.class).iterator();
      while (attributes.hasNext()) {
        Typeable attribute=(Typeable)attributes.next();
        result.addAll(attribute.typeConstraintList());
      }
    }
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}"
75801,"/** 
 * decreaseTemporaryMarking() is to decrease the _tempoararyMarking by i 
 */
public void decreaseTemporaryMarking(int i){
  _temporaryMarking=_temporaryMarking - i;
}","/** 
 * decreaseTemporaryMarking() is to decrease the _temporaryMarking by i 
 */
public void decreaseTemporaryMarking(int i){
  _temporaryMarking=_temporaryMarking - i;
}"
75802,"/** 
 * setTemporaryMarking() is to set the _tempoararyMarking to i 
 */
public void setTemporaryMarking(int i){
  _temporaryMarking=i;
}","/** 
 * setTemporaryMarking() is to set the _temporaryMarking to i 
 */
public void setTemporaryMarking(int i){
  _temporaryMarking=i;
}"
75803,"/** 
 * Prefire is similar with fire. It checks all the input places to see whether the marking in that place is bigger than the weight on the arc or not. We assume the petrinet is specified by arcs connecting places and transitions. Arcs can be marked by Weight attribute, or it can be unmarked.  multiple arcs can be between a place and a transition.  Unmarked arcs are treated as weight 1. To monitor the multiple links, we use the temporaryMarking varialbe.  TemporaryMarking starts with the same marking as the currentMarking.  Each time a link is seen, the temporaryMarking decreases the value of the weight on the link. If at the end, the temporaryMarking is less than 0, then the sum of the weights of all links between the place and the transition is bigger than the marking in the place the transition is not ready to fire.
 */
public boolean prefire() throws IllegalActionException {
  int k=input.getWidth();
  boolean readyToFire=true;
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + k);
  Iterator inRelations=input.linkedRelationList().iterator();
  while (inRelations.hasNext()) {
    IORelation inWeights=(IORelation)inRelations.next();
    if (inWeights != null) {
      Iterator temporaryPlacePorts=inWeights.linkedSourcePortList().iterator();
      while (temporaryPlacePorts.hasNext()) {
        IOPort temporaryPlacePort=(IOPort)temporaryPlacePorts.next();
        Place temporaryPlace=(Place)temporaryPlacePort.getContainer();
        int i=temporaryPlace.getMarking();
        temporaryPlace.setTemporaryMarking(i);
      }
    }
  }
  Iterator relations=input.linkedRelationList().iterator();
  while (relations.hasNext()) {
    IORelation weights=(IORelation)relations.next();
    if (weights != null) {
      Iterator placePorts=weights.linkedSourcePortList().iterator();
      while (placePorts.hasNext()) {
        IOPort placePort=(IOPort)placePorts.next();
        Place place=(Place)placePort.getContainer();
        int i=place.getMarking();
        System.out.print(""String_Node_Str"" + place.getFullName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ place.getTemporaryMarking());
        Attribute temporaryAttribute=(Attribute)weights.getAttribute(""String_Node_Str"");
        if (temporaryAttribute == null) {
          place.decreaseTemporaryMarking(1);
          System.out.println(""String_Node_Str"");
        }
 else         if (temporaryAttribute instanceof Variable) {
          Variable tAttribute=(Variable)temporaryAttribute;
          Token weightToken=(Token)tAttribute.getToken();
          if (weightToken instanceof ScalarToken) {
            ScalarToken wToken=(ScalarToken)weightToken;
            int j=wToken.intValue();
            System.out.println(""String_Node_Str"" + j);
            place.decreaseTemporaryMarking(j);
          }
        }
        if (place.getTemporaryMarking() < 0) {
          System.out.print(""String_Node_Str"");
          System.out.println(""String_Node_Str"" + place.getTemporaryMarking());
          return false;
        }
      }
    }
 else     System.out.println(""String_Node_Str"");
  }
  return readyToFire;
}","/** 
 * Prefire is similar with fire. It checks all the input places to see whether the marking in that place is bigger than the weight on the arc or not. We assume the petrinet is specified by arcs connecting places and transitions. Arcs can be marked by Weight attribute, or it can be unmarked.  multiple arcs can be between a place and a transition.  Unmarked arcs are treated as weight 1. To monitor the multiple links, we use the temporaryMarking variable.  TemporaryMarking starts with the same marking as the currentMarking.  Each time a link is seen, the temporaryMarking decreases the value of the weight on the link. If at the end, the temporaryMarking is less than 0, then the sum of the weights of all links between the place and the transition is bigger than the marking in the place the transition is not ready to fire.
 */
public boolean prefire() throws IllegalActionException {
  int k=input.getWidth();
  boolean readyToFire=true;
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + k);
  Iterator inRelations=input.linkedRelationList().iterator();
  while (inRelations.hasNext()) {
    IORelation inWeights=(IORelation)inRelations.next();
    if (inWeights != null) {
      Iterator temporaryPlacePorts=inWeights.linkedSourcePortList().iterator();
      while (temporaryPlacePorts.hasNext()) {
        IOPort temporaryPlacePort=(IOPort)temporaryPlacePorts.next();
        Place temporaryPlace=(Place)temporaryPlacePort.getContainer();
        int i=temporaryPlace.getMarking();
        temporaryPlace.setTemporaryMarking(i);
      }
    }
  }
  Iterator relations=input.linkedRelationList().iterator();
  while (relations.hasNext()) {
    IORelation weights=(IORelation)relations.next();
    if (weights != null) {
      Iterator placePorts=weights.linkedSourcePortList().iterator();
      while (placePorts.hasNext()) {
        IOPort placePort=(IOPort)placePorts.next();
        Place place=(Place)placePort.getContainer();
        int i=place.getMarking();
        System.out.print(""String_Node_Str"" + place.getFullName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ place.getTemporaryMarking());
        Attribute temporaryAttribute=(Attribute)weights.getAttribute(""String_Node_Str"");
        if (temporaryAttribute == null) {
          place.decreaseTemporaryMarking(1);
          System.out.println(""String_Node_Str"");
        }
 else         if (temporaryAttribute instanceof Variable) {
          Variable tAttribute=(Variable)temporaryAttribute;
          Token weightToken=(Token)tAttribute.getToken();
          if (weightToken instanceof ScalarToken) {
            ScalarToken wToken=(ScalarToken)weightToken;
            int j=wToken.intValue();
            System.out.println(""String_Node_Str"" + j);
            place.decreaseTemporaryMarking(j);
          }
        }
        if (place.getTemporaryMarking() < 0) {
          System.out.print(""String_Node_Str"");
          System.out.println(""String_Node_Str"" + place.getTemporaryMarking());
          return false;
        }
      }
    }
 else     System.out.println(""String_Node_Str"");
  }
  return readyToFire;
}"
75804,"/** 
 * Generate Ptolemy II Java code to instantiate a component, and for a composite component, the code to instantiate and connect all components that are nested within the component.
 * @param model The component for which code is to be generated.
 * @return The generated Ptolemy II Java code for implementingthe component.
 */
protected String _generateComponents(ComponentEntity model) throws IllegalActionException {
  String code=new String();
  String className=_getClassName(model);
  String sanitizedName=_name(model);
  CompositeEntity container;
  String containerName;
  String nameAsContainer;
  if ((container=((CompositeEntity)(model.getContainer()))) != null) {
    if (container.getContainer() == null)     containerName=""String_Node_Str"";
 else     containerName=_name(container);
    nameAsContainer=sanitizedName;
    code+=_indent(3) + className + ""String_Node_Str""+ sanitizedName+ ""String_Node_Str""+ className+ ""String_Node_Str""+ containerName+ ""String_Node_Str""+ sanitizedName+ ""String_Node_Str"";
    code+=_generatePorts(model);
    code+=_generateAttributes(model);
  }
 else   nameAsContainer=""String_Node_Str"";
  if (!model.isAtomic()) {
    Iterator components=((CompositeEntity)model).entityList().iterator();
    while (components.hasNext()) {
      code+=_generateComponents((ComponentEntity)(components.next()));
    }
    Iterator relations=((CompositeEntity)model).relationList().iterator();
    while (relations.hasNext()) {
      Relation relation=(Relation)(relations.next());
      Iterator ports=relation.linkedPortList().iterator();
      String relationAttributes=_generateAttributes(relation);
      if ((relation.numLinks() == 2) && (relationAttributes.length() == 0)) {
        Port port1=(Port)ports.next();
        Port port2=(Port)ports.next();
        code+=_indent(3);
        if (container != null)         code+=sanitizedName + ""String_Node_Str"";
        code+=""String_Node_Str"" + _name(port1) + ""String_Node_Str""+ _name(port2)+ ""String_Node_Str"";
      }
 else {
        String relationClassName=_getClassName(relation);
        code+=_indent(3) + relationClassName + ""String_Node_Str""+ _name(relation);
        code+=""String_Node_Str"" + relationClassName + ""String_Node_Str""+ nameAsContainer;
        code+=""String_Node_Str"" + _name(relation) + ""String_Node_Str"";
        code+=relationAttributes;
        while (ports.hasNext()) {
          Port p=(Port)ports.next();
          code+=_indent(3) + _name(p) + ""String_Node_Str""+ _name(relation)+ ""String_Node_Str"";
        }
      }
    }
  }
  return code;
}","/** 
 * Generate Ptolemy II Java code to instantiate a component, and for a composite component, the code to instantiate and connect all components that are nested within the component.
 * @param model The component for which code is to be generated.
 * @return The generated Ptolemy II Java code for implementingthe component.
 */
protected String _generateComponents(ComponentEntity model) throws IllegalActionException {
  String code=new String();
  String className=_getClassName(model);
  String sanitizedName=_name(model);
  CompositeEntity container;
  String containerName;
  String nameAsContainer;
  if ((container=((CompositeEntity)(model.getContainer()))) != null) {
    if (container.getContainer() == null) {
      containerName=""String_Node_Str"";
    }
 else {
      containerName=_name(container);
    }
    nameAsContainer=sanitizedName;
    code+=_indent(3) + className + ""String_Node_Str""+ sanitizedName+ ""String_Node_Str""+ className+ ""String_Node_Str""+ containerName+ ""String_Node_Str""+ sanitizedName+ ""String_Node_Str"";
    code+=_generatePorts(model);
    code+=_generateAttributes(model);
  }
 else   nameAsContainer=""String_Node_Str"";
  if (!model.isAtomic()) {
    Iterator components=((CompositeEntity)model).entityList().iterator();
    while (components.hasNext()) {
      code+=_generateComponents((ComponentEntity)(components.next()));
    }
    Iterator relations=((CompositeEntity)model).relationList().iterator();
    while (relations.hasNext()) {
      Relation relation=(Relation)(relations.next());
      Iterator ports=relation.linkedPortList().iterator();
      String relationAttributes=_generateAttributes(relation);
      if ((relation.numLinks() == 2) && (relationAttributes.length() == 0)) {
        Port port1=(Port)ports.next();
        Port port2=(Port)ports.next();
        code+=_indent(3);
        if (container != null) {
          code+=sanitizedName + ""String_Node_Str"";
        }
        code+=""String_Node_Str"" + _name(port1) + ""String_Node_Str""+ _name(port2)+ ""String_Node_Str"";
      }
 else {
        String relationClassName=_getClassName(relation);
        code+=_indent(3) + relationClassName + ""String_Node_Str""+ _name(relation);
        code+=""String_Node_Str"" + relationClassName + ""String_Node_Str""+ nameAsContainer;
        code+=""String_Node_Str"" + _name(relation) + ""String_Node_Str"";
        code+=relationAttributes;
        while (ports.hasNext()) {
          Port p=(Port)ports.next();
          code+=_indent(3) + _name(p) + ""String_Node_Str""+ _name(relation)+ ""String_Node_Str"";
        }
      }
    }
  }
  return code;
}"
75805,"/** 
 * Return the java code associated with a top level Ptolemy II object and all of its descendants.
 * @param toplevel The root object of the topology to be saved.
 * @return The generated java code.
 */
public String generate(NamedObj toplevel) throws IllegalActionException {
  String className=toplevel.getClass().getName();
  String code=new String();
  String importCode=new String();
  CompositeEntity compositeModel;
  _importList=new LinkedList();
  if (!(toplevel instanceof CompositeEntity)) {
    throw new IllegalActionException(toplevel,""String_Node_Str"");
  }
  compositeModel=(CompositeEntity)toplevel;
  String sanitizedName=_name(compositeModel);
  code+=""String_Node_Str"" + sanitizedName + ""String_Node_Str""+ _getClassName(compositeModel)+ ""String_Node_Str""+ _indent(1)+ ""String_Node_Str""+ sanitizedName+ ""String_Node_Str""+ ""String_Node_Str""+ _indent(2)+ ""String_Node_Str""+ _indent(2)+ ""String_Node_Str"";
  code+=_indent(2) + ""String_Node_Str"" + _getClassName(compositeModel)+ ""String_Node_Str"";
  code+=_generateAttributes(compositeModel);
  code+=_generateComponents(compositeModel);
  code+=_indent(2) + ""String_Node_Str"" + _indent(3)+ ""String_Node_Str""+ _indent(2)+ ""String_Node_Str""+ _indent(1)+ ""String_Node_Str""+ ""String_Node_Str"";
  _insertIfUnique(""String_Node_Str"",_importList);
  _insertIfUnique(""String_Node_Str"",_importList);
  _insertIfUnique(""String_Node_Str"",_importList);
  try {
    Iterator iter=_importList.iterator();
    while (iter.hasNext()) {
      String p=(String)(iter.next());
      importCode+=""String_Node_Str"" + p + ""String_Node_Str"";
    }
    code=importCode + ""String_Node_Str"" + code;
  }
 catch (  Exception ex) {
    throw new IllegalActionException(ex.getMessage() + ""String_Node_Str"" + importCode+ ""String_Node_Str"");
  }
  return code;
}","/** 
 * Return the java code associated with a top level Ptolemy II object and all of its descendants.
 * @param toplevel The root object of the topology to be saved.
 * @return The generated java code.
 */
public String generate(NamedObj toplevel) throws IllegalActionException {
  String className=toplevel.getClass().getName();
  String code=new String();
  String importCode=new String();
  CompositeEntity compositeModel;
  _importList=new LinkedList();
  if (!(toplevel instanceof CompositeEntity)) {
    throw new IllegalActionException(toplevel,""String_Node_Str"");
  }
  compositeModel=(CompositeEntity)toplevel;
  String sanitizedName=_name(compositeModel);
  code+=""String_Node_Str"" + sanitizedName + ""String_Node_Str""+ _getClassName(compositeModel)+ ""String_Node_Str""+ _indent(1)+ ""String_Node_Str""+ sanitizedName+ ""String_Node_Str""+ ""String_Node_Str""+ _indent(2)+ ""String_Node_Str""+ _indent(2)+ ""String_Node_Str"";
  code+=_indent(2) + ""String_Node_Str"" + _getClassName(compositeModel)+ ""String_Node_Str"";
  code+=_generateAttributes(compositeModel);
  code+=_generateComponents(compositeModel);
  code+=_indent(2) + ""String_Node_Str"" + _indent(3)+ ""String_Node_Str""+ _indent(2)+ ""String_Node_Str""+ _indent(1)+ ""String_Node_Str""+ ""String_Node_Str"";
  _insertIfUnique(""String_Node_Str"",_importList);
  _insertIfUnique(""String_Node_Str"",_importList);
  _insertIfUnique(""String_Node_Str"",_importList);
  try {
    Iterator iter=_importList.iterator();
    while (iter.hasNext()) {
      String p=(String)(iter.next());
      importCode+=""String_Node_Str"" + p + ""String_Node_Str"";
    }
    code=importCode + ""String_Node_Str"" + code;
  }
 catch (  Exception ex) {
    throw new IllegalActionException(ex.getMessage() + ""String_Node_Str"" + ""String_Node_Str""+ importCode+ ""String_Node_Str"");
  }
  return code;
}"
75806,"/** 
 * Ensure that the source code for this ClassDecl is loaded, and pass 0 resolution is completed on it. If the source already has been loaded, do nothing.  Otherwise, if the class is a JVM system class, or a Ptolemy class, or we can load  the class file using a class loader, then attempt to perform shallow loading of the AST (we must first ensure that the class file can be loaded in case we need to perform shallow-to-deep conversion later). If we cannot load the class file, parse the Java source to obtain a full AST.
 * @exception IOException If we can't get the canonicalname of the test library.
 * @exception FileNotFoundException If we can't find the source file.
 */
public void loadSource() throws IOException {
  if (_source == null) {
    _source=AbsentTreeNode.instance;
    String fileName=fullName('.');
    if (SearchPath.systemClassSet.contains(fileName) || SearchPath.ptolemyCoreClassSet.contains(fileName)) {
      if (StaticResolution.traceLoading) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fileName + ""String_Node_Str"");
      }
      StaticResolution.loadClassName(fileName,0);
      if (_source == AbsentTreeNode.instance) {
        throw new RuntimeException(""String_Node_Str"" + fullName());
      }
    }
 else {
      if (StaticResolution.traceLoading)       System.out.println(""String_Node_Str"" + fullName());
      Class loadedClass=null;
      if (StaticResolution.shallowLoadingEnabled() && StaticResolution.enableDeepUserASTs) {
        try {
          loadedClass=Class.forName(fullName());
        }
 catch (        Exception exception) {
        }
        if (loadedClass == null) {
          JavaClassLoader classLoader=new JavaClassLoader();
          if (StaticResolution.traceLoading)           System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fullName() + ""String_Node_Str""+ ""String_Node_Str"");
          try {
            loadedClass=classLoader.loadClass(fullName());
          }
 catch (          ClassNotFoundException exception) {
            System.out.println(""String_Node_Str"");
          }
        }
        if (loadedClass != null) {
          CompileUnitNode loadedAST=ASTReflect.ASTCompileUnitNode(loadedClass);
          _source=NodeUtil.getDefinedType(loadedAST);
          if (loadedAST == null)           throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"" + fullName() + ""String_Node_Str""+ ""String_Node_Str""+ loadedClass.getClass().getName()+ ""String_Node_Str"");
 else {
            _source=NodeUtil.getDefinedType(loadedAST);
            loadedAST.setProperty(IDENT_KEY,fullName());
            JavaParserManip.allParsedMap.put(fullName(),loadedAST);
            StaticResolution.loadCompileUnit(loadedAST,0);
          }
        }
      }
      if (loadedClass == null) {
        if (StaticResolution.traceLoading)         System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fullName());
        File file=_pickLibrary(_container).openSource(fileName);
        StaticResolution.loadFile(file,0,fullName());
      }
      if ((_source == null) || (_source == AbsentTreeNode.instance)) {
        throw new RuntimeException(""String_Node_Str"" + fileName + ""String_Node_Str""+ fullName());
      }
    }
    if (StaticResolution.traceLoading)     System.out.println(""String_Node_Str"" + fullName());
  }
}","/** 
 * Ensure that the source code for this ClassDecl is loaded, and pass 0 resolution is completed on it. If the source already has been loaded, do nothing.  Otherwise, if the class is a JVM system class, or a Ptolemy class, or we can load  the class file using a class loader, then attempt to perform shallow loading of the AST (we must first ensure that the class file can be loaded in case we need to perform shallow-to-deep conversion later). If we cannot load the class file, parse the Java source to obtain a full AST.
 * @exception IOException If we can't get the canonicalname of the test library.
 * @exception FileNotFoundException If we can't find the source file.
 */
public void loadSource() throws IOException {
  if (_source == null) {
    _source=AbsentTreeNode.instance;
    String fileName=fullName('.');
    if (SearchPath.systemClassSet.contains(fileName) || SearchPath.ptolemyCoreClassSet.contains(fileName)) {
      if (StaticResolution.traceLoading) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fileName + ""String_Node_Str"");
      }
      StaticResolution.loadClassName(fileName,0);
      if (_source == AbsentTreeNode.instance) {
        throw new RuntimeException(""String_Node_Str"" + fullName());
      }
    }
 else {
      if (StaticResolution.traceLoading)       System.out.println(""String_Node_Str"" + fullName());
      Class loadedClass=null;
      if (StaticResolution.shallowLoadingEnabled() && StaticResolution.enableDeepUserASTs) {
        try {
          loadedClass=Class.forName(fullName());
        }
 catch (        Exception exception) {
        }
        if (loadedClass == null) {
          JavaClassLoader classLoader=new JavaClassLoader();
          if (StaticResolution.traceLoading)           System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fullName() + ""String_Node_Str""+ ""String_Node_Str"");
          try {
            loadedClass=classLoader.loadClass(fullName());
          }
 catch (          ClassNotFoundException exception) {
            System.out.println(""String_Node_Str"");
          }
        }
        if (loadedClass != null) {
          CompileUnitNode loadedAST=ASTReflect.ASTCompileUnitNode(loadedClass);
          if (loadedAST == null)           throw new NullPointerException(""String_Node_Str"" + ""String_Node_Str"" + fullName() + ""String_Node_Str""+ ""String_Node_Str""+ loadedClass.getClass().getName()+ ""String_Node_Str"");
 else {
            _source=NodeUtil.getSingleDefinedType(loadedAST);
            loadedAST.setProperty(IDENT_KEY,fullName());
            JavaParserManip.allParsedMap.put(fullName(),loadedAST);
            StaticResolution.loadCompileUnit(loadedAST,0);
          }
        }
      }
      if (loadedClass == null) {
        if (StaticResolution.traceLoading)         System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fullName());
        File file=_pickLibrary(_container).openSource(fileName);
        StaticResolution.loadFile(file,0,fullName());
      }
      if ((_source == null) || (_source == AbsentTreeNode.instance)) {
        throw new RuntimeException(""String_Node_Str"" + fileName + ""String_Node_Str""+ fullName());
      }
    }
    if (StaticResolution.traceLoading)     System.out.println(""String_Node_Str"" + fullName());
  }
}"
75807,"/** 
 * Given an AST TypedDecl, return the class or interface declaration (ClassDecl) associated with the declared entity's type, if one exists.  For example, if this method is called on a field declaration of the form 'myClass myField;', it will return the declaration of 'myClass'.
 * @param typedNode The AST TypedNode.
 * @return The declaration associated with the type of the AST TypedNode.Return null if we cannot resolve the desired declaration.
 */
public static ClassDecl typedDeclToClassDecl(TypedDecl typedDecl){
  if (typedDecl == null) {
    return null;
  }
  TypeNode type=((TypedDecl)typedDecl).getType();
  if (!(type instanceof TypeNameNode)) {
    return null;
  }
  JavaDecl declaration=JavaDecl.getDecl((TreeNode)type);
  if (!(declaration instanceof ClassDecl)) {
    return null;
  }
  return (ClassDecl)declaration;
}","/** 
 * Given an AST TypedDecl, return the class or interface declaration (ClassDecl) associated with the declared entity's type, if one exists.  For example, if this method is called on a field declaration of the form 'myClass myField;', it will return the declaration of 'myClass'.
 * @param typedDecl The AST TypedNode.
 * @return The declaration associated with the type of the AST TypedNode.Return null if we cannot resolve the desired declaration.
 */
public static ClassDecl typedDeclToClassDecl(TypedDecl typedDecl){
  if (typedDecl == null) {
    return null;
  }
  TypeNode type=((TypedDecl)typedDecl).getType();
  if (!(type instanceof TypeNameNode)) {
    return null;
  }
  JavaDecl declaration=JavaDecl.getDecl((TreeNode)type);
  if (!(declaration instanceof ClassDecl)) {
    return null;
  }
  return (ClassDecl)declaration;
}"
75808,"/** 
 * Return a string representation of the list of loaded classes and interfaces,  the associated hash map keys, and the loading statuses. This is useful for diagnostic purposes.
 * @return The string representation of loaded classes and interfaces.
 */
public static String getLoadedASTNames(){
  StringBuffer names=new StringBuffer(""String_Node_Str"");
  Iterator keys=allPass0ResolvedMap.keySet().iterator();
  while (keys.hasNext()) {
    Object nextKey=keys.next();
    CompileUnitNode unit=(CompileUnitNode)allPass0ResolvedMap.get(nextKey);
    UserTypeDeclNode declaration=NodeUtil.getDefinedType(unit);
    names.append(nextKey + ""String_Node_Str"" + ASTReflect.getFullyQualifiedName(declaration)+ ""String_Node_Str""+ ASTReflect.getLoadingMode(declaration)+ ""String_Node_Str"");
  }
  return names.toString();
}","/** 
 * Return a string representation of the list of loaded classes and interfaces,  the associated hash map keys, and the loading statuses. This is useful for diagnostic purposes. Note that if a given compile unit contains multiple user type definitions (e.g., an interface and a class definition), then there will accordingly be multiple listings with the same hash map key.
 * @return The string representation of loaded classes and interfaces.
 */
public static String getLoadedASTNames(){
  StringBuffer names=new StringBuffer(""String_Node_Str"");
  Iterator keys=allPass0ResolvedMap.keySet().iterator();
  while (keys.hasNext()) {
    Object nextKey=keys.next();
    CompileUnitNode unit=(CompileUnitNode)allPass0ResolvedMap.get(nextKey);
    Iterator definedTypes=NodeUtil.getDefinedTypes(unit);
    while (definedTypes.hasNext()) {
      UserTypeDeclNode declaration=(UserTypeDeclNode)(definedTypes.next());
      names.append(nextKey + ""String_Node_Str"" + ASTReflect.getFullyQualifiedName(declaration)+ ""String_Node_Str""+ ASTReflect.getLoadingMode(declaration)+ ""String_Node_Str"");
    }
  }
  return names.toString();
}"
75809,"private Object _visitVarInitDeclNode(VarInitDeclNode node){
  if (_debug) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ node);
  }
  TypeNode type=node.getDefType();
  TypedDecl typedDecl=(TypedDecl)JavaDecl.getDecl((NamedNode)node);
  InequalityTerm term=_makeVariableTerm(type,typedDecl);
  InequalityTerm initExprTerm=(InequalityTerm)node.getInitExpr().accept(this,null);
  if (_debug) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + node + ""String_Node_Str""+ term+ ""String_Node_Str""+ type+ ""String_Node_Str""+ typedDecl+ ""String_Node_Str""+ initExprTerm);
  }
  if (term != null) {
    _declToTermMap.put(typedDecl,term);
    if (_debug) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    _solver.addInequality(new Inequality(term,_makeConstantTerm(type,null)));
    if (initExprTerm != null) {
      if (_debug) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      _solver.addInequality(new Inequality(initExprTerm,term));
    }
  }
  return null;
}","private Object _visitVarInitDeclNode(VarInitDeclNode node){
  if (_debug) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ node);
  }
  TypeNode type=node.getDefType();
  TypedDecl typedDecl=(TypedDecl)JavaDecl.getDecl((NamedNode)node);
  InequalityTerm term=_makeVariableTerm(type,typedDecl);
  InequalityTerm initExprTerm=(InequalityTerm)node.getInitExpr().accept(this,null);
  if (_debug) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + node + ""String_Node_Str""+ term+ ""String_Node_Str""+ type+ ""String_Node_Str""+ typedDecl+ ""String_Node_Str""+ initExprTerm);
  }
  if (term != null) {
    _declToTermMap.put(typedDecl,term);
    if (_debug) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    _solver.addInequality(new Inequality(term,_makeConstantTerm(type,null)));
    if (initExprTerm != null) {
      if (_debug) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      try {
        term.setValue((ClassDecl)initExprTerm.getValue());
      }
 catch (      IllegalActionException e) {
        throw new RuntimeException(""String_Node_Str"" + e);
      }
      _solver.addInequality(new Inequality(initExprTerm,term));
    }
  }
  return null;
}"
75810,"/** 
 * Make a list of CompileUnitNodes that contain the superclasses of the given className, while is found in the given fileName. Also make a list of strings that are the corresponding (primary) class names. Return both these lists in an array. The lists should start from the class that immediately extends a known actor class (such as TypedAtomicActor), and goes to the class given by the argument className. The CompileUnitNodes are cloned from the ones returned by StaticResolution so that they may be modified.
 */
protected LinkedList[] _makeUnitList(String fileName,String className){
  LinkedList nodeList=new LinkedList();
  CompileUnitNode unitNode=(CompileUnitNode)StaticResolution.loadFileName(fileName,2).clone();
  nodeList.addFirst(unitNode);
  LinkedList classNameList=new LinkedList();
  classNameList.addFirst(ASTReflect.getFullyQualifiedName(unitNode));
  do {
    ClassDecl superDecl=(ClassDecl)unitNode.accept(new FindSuperClassDecl(className),null);
    if ((superDecl == StaticResolution.OBJECT_DECL) || (superDecl == null)) {
      return new LinkedList[]{nodeList,classNameList};
    }
 else {
      int superKind=_typeID.kindOfClassDecl(superDecl);
      if (_typeID.isSupportedActorKind(superKind)) {
        return new LinkedList[]{nodeList,classNameList};
      }
      fileName=superDecl.fullName(File.separatorChar);
      File file;
      try {
        file=SearchPath.NAMED_PATH.openSource(fileName);
      }
 catch (      IOException e) {
        throw new RuntimeException(""String_Node_Str"" + fileName + ""String_Node_Str""+ e);
      }
      unitNode=(CompileUnitNode)StaticResolution.loadFile(file,2).clone();
      nodeList.addFirst(unitNode);
      className=superDecl.getName();
      classNameList.addFirst(ASTReflect.getFullyQualifiedName(unitNode));
    }
  }
 while (true);
}","/** 
 * Make a list of CompileUnitNodes that contain the superclasses of the given className, while is found in the given fileName. Also make a list of strings that are the corresponding (primary) class names. Return both these lists in an array. The lists should start from the class that immediately extends a known actor class (such as TypedAtomicActor), and goes to the class given by the argument className. The CompileUnitNodes are cloned from the ones returned by StaticResolution so that they may be modified.
 */
protected LinkedList[] _makeUnitList(String fileName,String className){
  LinkedList nodeList=new LinkedList();
  CompileUnitNode unitNode=(CompileUnitNode)StaticResolution.loadFileName(fileName,2,className).clone();
  nodeList.addFirst(unitNode);
  LinkedList classNameList=new LinkedList();
  classNameList.addFirst(ASTReflect.getFullyQualifiedName(unitNode));
  do {
    ClassDecl superDecl=(ClassDecl)unitNode.accept(new FindSuperClassDecl(className),null);
    if ((superDecl == StaticResolution.OBJECT_DECL) || (superDecl == null)) {
      return new LinkedList[]{nodeList,classNameList};
    }
 else {
      int superKind=_typeID.kindOfClassDecl(superDecl);
      if (_typeID.isSupportedActorKind(superKind)) {
        return new LinkedList[]{nodeList,classNameList};
      }
      fileName=superDecl.fullName(File.separatorChar);
      File file;
      try {
        file=SearchPath.NAMED_PATH.openSource(fileName);
      }
 catch (      IOException e) {
        throw new RuntimeException(""String_Node_Str"" + fileName + ""String_Node_Str""+ e);
      }
      if (StaticResolution.traceLoading)       System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ ASTReflect.getLoadingStatus(true,false));
      unitNode=(CompileUnitNode)StaticResolution.loadFile(file,2,superDecl.fullName()).clone();
      nodeList.addFirst(unitNode);
      className=superDecl.getName();
      classNameList.addFirst(ASTReflect.getFullyQualifiedName(unitNode));
    }
  }
 while (true);
}"
75811,"/** 
 * Do pass 3 transformation of actor with the given filename (renamed after pass 1). Pass 3 is the conversion of Extended Java to ordinary Java.
 */
public void pass3(String sourceName){
  File sourceFile;
  try {
    sourceFile=SearchPath.NAMED_PATH.openSource(sourceName);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + sourceName + ""String_Node_Str""+ e);
  }
  String filename=sourceFile.toString();
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filename + ""String_Node_Str"");
  TypeVisitor oldTypeVisitor=StaticResolution.getDefaultTypeVisitor();
  StaticResolution.setDefaultTypeVisitor(new TypeVisitor(new ExtendedJavaTypePolicy()));
  LinkedList[] listArray=_makeUnitList(filename,StringManip.unqualifiedPart(sourceName));
  LinkedList unitList=listArray[0];
  Iterator unitItr=unitList.iterator();
  CompileUnitNode unitNode;
  ExtendedJavaConverter ejConverter=new ExtendedJavaConverter();
  while (unitItr.hasNext()) {
    unitNode=(CompileUnitNode)unitItr.next();
    unitNode.accept(ejConverter,null);
  }
  LinkedList classNameList=listArray[1];
  _rewriteSources(unitList,classNameList);
  _invalidateSources(classNameList,2);
  StaticResolution.setDefaultTypeVisitor(oldTypeVisitor);
  Iterator classNameItr=classNameList.iterator();
  LinkedList importFilteredList=new LinkedList();
  while (classNameItr.hasNext()) {
    String className=(String)classNameItr.next();
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
    File file;
    try {
      file=SearchPath.NAMED_PATH.openSource(className);
    }
 catch (    IOException e) {
      throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str""+ e);
    }
    unitNode=StaticResolution.loadFile(file,2);
    unitNode.accept(new FindExtraImportsVisitor(true,null),null);
    importFilteredList.add(unitNode);
  }
  _rewriteSources(importFilteredList,classNameList);
  _invalidateSources(classNameList,2);
}","/** 
 * Do pass 3 transformation of actor with the given filename (renamed after pass 1). Pass 3 is the conversion of Extended Java to ordinary Java.
 */
public void pass3(String sourceName){
  File sourceFile;
  try {
    sourceFile=SearchPath.NAMED_PATH.openSource(sourceName);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + sourceName + ""String_Node_Str""+ e);
  }
  String filename=sourceFile.toString();
  System.out.println(""String_Node_Str"" + ""String_Node_Str"" + filename + ""String_Node_Str"");
  TypeVisitor oldTypeVisitor=StaticResolution.getDefaultTypeVisitor();
  StaticResolution.setDefaultTypeVisitor(new TypeVisitor(new ExtendedJavaTypePolicy()));
  LinkedList[] listArray=_makeUnitList(filename,StringManip.unqualifiedPart(sourceName));
  LinkedList unitList=listArray[0];
  Iterator unitItr=unitList.iterator();
  CompileUnitNode unitNode;
  ExtendedJavaConverter ejConverter=new ExtendedJavaConverter();
  while (unitItr.hasNext()) {
    unitNode=(CompileUnitNode)unitItr.next();
    unitNode.accept(ejConverter,null);
  }
  LinkedList classNameList=listArray[1];
  _rewriteSources(unitList,classNameList);
  _invalidateSources(classNameList,2);
  StaticResolution.setDefaultTypeVisitor(oldTypeVisitor);
  Iterator classNameItr=classNameList.iterator();
  LinkedList importFilteredList=new LinkedList();
  while (classNameItr.hasNext()) {
    String className=(String)classNameItr.next();
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + className + ""String_Node_Str"");
    File file;
    try {
      file=SearchPath.NAMED_PATH.openSource(className);
    }
 catch (    IOException e) {
      throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str""+ e);
    }
    unitNode=StaticResolution.loadFile(file,2,className);
    unitNode.accept(new FindExtraImportsVisitor(true,null),null);
    importFilteredList.add(unitNode);
  }
  _rewriteSources(importFilteredList,classNameList);
  _invalidateSources(classNameList,2);
}"
75812,"/** 
 * Call the sendAbsent() method of each of the output ports of the specified actor if the actor is strict.
 */
private void _sendAbsentToAllUnknownOutputsOf(Actor actor) throws IllegalActionException {
  if ((!_isNonStrict(actor)) || (!_isFinishedFiring(actor))) {
    _debug(""String_Node_Str"",""String_Node_Str"",_getNameOf(actor));
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      for (int j=0; j < outputPort.getWidth(); j++) {
        if (!outputPort.isKnown(j))         outputPort.sendAbsent(j);
      }
    }
  }
}","/** 
 * Call the sendAbsent() method of each of the output ports of the specified actor if the actor is strict.
 */
private void _sendAbsentToAllUnknownOutputsOf(Actor actor) throws IllegalActionException {
  if ((!_isNonStrict(actor)) && (!_isFinishedFiring(actor))) {
    _debug(""String_Node_Str"",""String_Node_Str"",_getNameOf(actor));
    Iterator outputPorts=actor.outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      for (int j=0; j < outputPort.getWidth(); j++) {
        if (!outputPort.isKnown(j))         outputPort.sendAbsent(j);
      }
    }
  }
}"
75813,"/** 
 * Set the input variables for the channel of the port.
 * @param port An input port of this actor.
 * @param channel A channel of the input port.
 * @exception IllegalActionException If the port is not contained bythis actor, or if the port is not an input port, or if the value variable cannot take the token read from the channel.
 */
protected void _setInputVariables(TypedIOPort port,int channel) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_debugging) {
    _debug(this.getFullName(),""String_Node_Str"",port.getName());
  }
  int width=port.getWidth();
  Variable[][] pVars=(Variable[][])_inputVariableMap.get(port);
  if (pVars == null) {
    throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  Token tok;
  boolean t;
  while (t=port.hasToken(channel)) {
    if (_debugging) {
      _debug(port.getName(),""String_Node_Str"" + t);
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ t);
    }
    tok=t ? BooleanToken.TRUE : BooleanToken.FALSE;
    pVars[channel][0].setToken(tok);
    tok=port.get(channel);
    if (_debugging) {
      _debug(port.getName(),""String_Node_Str"",tok.toString());
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ tok.toString());
    }
    pVars[channel][1].setToken(tok);
  }
}","/** 
 * Set the input variables for the channel of the port.
 * @param port An input port of this actor.
 * @param channel A channel of the input port.
 * @param firings The number of times this actor has been fired in thecurrent iteration - 1. If the firing count of this actor is M, then the value of this parameter ranges from 0 to M-1.
 * @param firingsPerIteration The firing count of this actorin the current iteration.
 * @exception IllegalActionException If the port is not contained bythis actor, or if the port is not an input port, or if the value variable cannot take the token read from the channel.
 */
protected void _setInputVariables(TypedIOPort port,int channel,int firings,int firingsPerIteration) throws IllegalActionException {
  if (port.getContainer() != this) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!port.isInput()) {
    throw new IllegalActionException(this,port,""String_Node_Str"" + ""String_Node_Str"");
  }
  if (_debug_info) {
    System.out.println(this.getFullName() + ""String_Node_Str"" + port.getName());
  }
  int width=port.getWidth();
  Variable[][] pVars=(Variable[][])_inputVariableMap.get(port);
  if (pVars == null) {
    throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  Variable[][] hdfVars=(Variable[][])_hdfInputVariableMap.get(port);
  if (hdfVars == null) {
    throw new InternalErrorException(getName() + ""String_Node_Str"" + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  Token tok;
  boolean t;
  int currentTokenIndex=0;
  while (t=port.hasToken(channel)) {
    if (_debug_info) {
      System.out.println(port.getName() + ""String_Node_Str"" + t);
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ t);
    }
    tok=t ? BooleanToken.TRUE : BooleanToken.FALSE;
    pVars[channel][0].setToken(tok);
    tok=port.get(channel);
    if (_debug_info) {
      System.out.println(port.getName() + ""String_Node_Str"" + tok.toString());
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ tok.toString());
    }
    pVars[channel][1].setToken(tok);
    int portRate=SDFScheduler.getTokenConsumptionRate(port);
    int index=firingsPerIteration * portRate - 1 - (firings * portRate + currentTokenIndex);
    int historySize=((IntToken)(tokenHistorySize.getToken())).intValue();
    if (index < historySize) {
      hdfVars[channel][index].setToken(tok);
    }
    currentTokenIndex++;
  }
}"
75814,"/** 
 * Create an HDFFSMActor in the specified container with the specified name. The name must be unique within the container or an exception is thrown. The container argument must not be null, or a NullPointerException will be thrown.
 * @param container The container.
 * @param name The name of this actor within the container.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container (see the setContainer() method).
 * @exception NameDuplicationException If the name coincides withan entity already in the container.
 */
public HDFFSMActor(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","/** 
 * Create an HDFFSMActor in the specified container with the specified name. The name must be unique within the container or an exception is thrown. The container argument must not be null, or a NullPointerException will be thrown.
 * @param container The container.
 * @param name The name of this actor within the container.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container (see the setContainer() method).
 * @exception NameDuplicationException If the name coincides withan entity already in the container.
 */
public HDFFSMActor(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _init();
}"
75815,"/** 
 * Dequeue the events from the event queue that have the smallest time stamp and depth. Advance the model time to their time stamp, and mark the destination actor for firing. If the time stamp is greater than the stop time then return null. If there are no events on the event queue, and _stopWhenQueueIsEmpty flag is true (which is set to true by default) then return null, which will have the effect of stopping the simulation. If _stopWhenQueueIsEmpty is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are events available.  If _synchronizeToRealTime is true, then this method may suspend the calling thread using Object.wait(long) to let elapsed real time catch up with the current event.
 * @return The next actor to fire.
 */
protected Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  if (_eventQueue == null)   return null;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Thread.currentThread().yield();
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      _eventQueue.take();
      currentEvent=nextEvent;
      actorToFire=currentEvent.actor();
      if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
        if (_debugging)         _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      double currentTime=currentEvent.timeStamp();
      if (_synchronizeToRealTime) {
        long elapsedTime=System.currentTimeMillis() - _realStartTime;
        double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
        if (currentTime > elapsedTimeInSeconds) {
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (timeToWait > 0) {
            if (_debugging) {
              _debug(""String_Node_Str"" + timeToWait);
            }
synchronized (_eventQueue) {
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
      if (_debugging)       _debug(""String_Node_Str"",Double.toString(currentTime));
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getFullName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}","/** 
 * Dequeue the events from the event queue that have the smallest time stamp and depth. Advance the model time to their time stamp, and mark the destination actor for firing. If the time stamp is greater than the stop time then return null. If there are no events on the event queue, and _stopWhenQueueIsEmpty flag is true (which is set to true by default) then return null, which will have the effect of stopping the simulation. If _stopWhenQueueIsEmpty is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are events available.  If _synchronizeToRealTime is true, then this method may suspend the calling thread using Object.wait(long) to let elapsed real time catch up with the current event.
 * @return The next actor to fire.
 */
protected Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  if (_eventQueue == null)   return null;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        Thread.currentThread().yield();
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      currentEvent=nextEvent;
      double currentTime=currentEvent.timeStamp();
      if (_synchronizeToRealTime) {
        long elapsedTime=System.currentTimeMillis() - _realStartTime;
        double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
        if (currentTime > elapsedTimeInSeconds) {
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (timeToWait > 0) {
            if (_debugging) {
              _debug(""String_Node_Str"" + timeToWait);
            }
synchronized (_eventQueue) {
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
      currentEvent=(DEEvent)_eventQueue.take();
      currentTime=currentEvent.timeStamp();
      actorToFire=currentEvent.actor();
      if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
        if (_debugging)         _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      if (_debugging)       _debug(""String_Node_Str"",Double.toString(currentTime));
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getFullName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}"
75816,"/** 
 * Compute the SCC decomposition of a graph.
 * @return An array of instances of DirectedGraph which representthe SCCs of the graph in topological order.
 */
public DirectedGraph[] sccDecomposition(){
  _computeTransitiveClosure();
  int N=getNodeCount();
  if (_transitiveClosure.length != N)   throw new InternalErrorException(""String_Node_Str"");
  boolean addedToAnSCC[]=new boolean[N];
  for (int i=0; i < N; i++) {
    addedToAnSCC[i]=false;
  }
  ArrayList sccNodeLists=new ArrayList();
  ArrayList sccRepresentatives=new ArrayList();
  for (int i=0; i < N; i++) {
    if (!addedToAnSCC[i]) {
      ArrayList nodeList=new ArrayList();
      sccNodeLists.add(nodeList);
      Object node=_getNodeObject(i);
      nodeList.add(node);
      sccRepresentatives.add(node);
      addedToAnSCC[i]=true;
      for (int j=i + 1; j < N; j++) {
        if (!addedToAnSCC[j]) {
          if (_transitiveClosure[i][j] && _transitiveClosure[j][i]) {
            nodeList.add(_getNodeObject(j));
            addedToAnSCC[j]=true;
          }
        }
      }
    }
  }
  int numberOfSCCs=sccNodeLists.size();
  Object sortedSCCRepresentatives[];
  try {
    sortedSCCRepresentatives=attemptTopologicalSort(sccRepresentatives.toArray());
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  ArrayList sortedSCCNodeLists=new ArrayList();
  for (int i=0; i < numberOfSCCs; i++) {
    Object sccRepresentative=sortedSCCRepresentatives[i];
    for (int j=0; j < numberOfSCCs; j++) {
      ArrayList nodeList=(ArrayList)(sccNodeLists.get(j));
      if (nodeList.get(0) == sccRepresentative)       sortedSCCNodeLists.add(nodeList);
    }
  }
  ArrayList sccs=new ArrayList(numberOfSCCs);
  for (int i=0; i < numberOfSCCs; i++) {
    ArrayList nodeList=(ArrayList)(sortedSCCNodeLists.get(i));
    sccs.add(subgraph(nodeList.toArray()));
  }
  return ((DirectedGraph[])(sccs.toArray()));
}","/** 
 * Compute the SCC decomposition of a graph.
 * @return An array of instances of DirectedGraph which representthe SCCs of the graph in topological order.
 */
public DirectedGraph[] sccDecomposition(){
  _computeTransitiveClosure();
  int N=getNodeCount();
  if (_transitiveClosure.length != N)   throw new InternalErrorException(""String_Node_Str"");
  boolean addedToAnSCC[]=new boolean[N];
  for (int i=0; i < N; i++) {
    addedToAnSCC[i]=false;
  }
  ArrayList sccNodeLists=new ArrayList();
  ArrayList sccRepresentatives=new ArrayList();
  for (int i=0; i < N; i++) {
    if (!addedToAnSCC[i]) {
      ArrayList nodeList=new ArrayList();
      sccNodeLists.add(nodeList);
      Object node=_getNodeObject(i);
      nodeList.add(node);
      sccRepresentatives.add(node);
      addedToAnSCC[i]=true;
      for (int j=i + 1; j < N; j++) {
        if (!addedToAnSCC[j]) {
          if (_transitiveClosure[i][j] && _transitiveClosure[j][i]) {
            nodeList.add(_getNodeObject(j));
            addedToAnSCC[j]=true;
          }
        }
      }
    }
  }
  int numberOfSCCs=sccNodeLists.size();
  Object sortedSCCRepresentatives[];
  try {
    sortedSCCRepresentatives=attemptTopologicalSort(sccRepresentatives.toArray());
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
  ArrayList sortedSCCNodeLists=new ArrayList();
  for (int i=0; i < numberOfSCCs; i++) {
    Object sccRepresentative=sortedSCCRepresentatives[i];
    for (int j=0; j < numberOfSCCs; j++) {
      ArrayList nodeList=(ArrayList)(sccNodeLists.get(j));
      if (nodeList.get(0) == sccRepresentative)       sortedSCCNodeLists.add(nodeList);
    }
  }
  DirectedGraph sccs[]=new DirectedGraph[numberOfSCCs];
  for (int i=0; i < numberOfSCCs; i++) {
    ArrayList nodeList=(ArrayList)(sortedSCCNodeLists.get(i));
    sccs[i]=subgraph(nodeList.toArray());
  }
  return sccs;
}"
75817,"/** 
 * Notify this that an attribute has changed.  If either parameter is changed, then this actor updates the configuration of the visible plot.
 * @exception IllegalActionException If the expression of theattribute cannot be parsed or cannot be evaluated.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == width && plot != null) {
    double xUnitValue=((DoubleToken)xInit.getToken()).doubleValue();
    int widthValue=((IntToken)width.getToken()).intValue();
    plot.setXRange(0.0,xUnitValue * widthValue);
  }
 else   if (attribute == persistence && plot != null) {
    int persValue=((IntToken)persistence.getToken()).intValue();
    plot.setPointsPersistence(persValue);
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Notify this that an attribute has changed.  If either parameter is changed, then this actor updates the configuration of the visible plot.
 * @exception IllegalActionException If the expression of theattribute cannot be parsed or cannot be evaluated.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if ((attribute == width || attribute == xUnit || attribute == xInit) && plot != null) {
    super.attributeChanged(attribute);
    int widthValue=((IntToken)width.getToken()).intValue();
    plot.setXRange(_xInit,_xUnit * widthValue + _xInit);
  }
 else   if (attribute == persistence && plot != null) {
    int persValue=((IntToken)persistence.getToken()).intValue();
    plot.setPointsPersistence(persValue);
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75818,"/** 
 * Initialize this actor.  This method configures the visible plot using the current parameter values.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  double xUnitValue=((DoubleToken)xUnit.getToken()).doubleValue();
  int widthValue=((IntToken)width.getToken()).intValue();
  plot.setXRange(0.0,xUnitValue * widthValue);
  plot.setWrap(true);
  int persValue=((IntToken)persistence.getToken()).intValue();
  plot.setPointsPersistence(persValue);
  if (plot.getMarksStyle().equals(""String_Node_Str"")) {
    plot.setMarksStyle(""String_Node_Str"");
  }
  plot.repaint();
}","/** 
 * Initialize this actor.  This method configures the visible plot using the current parameter values.
 * @exception IllegalActionException If the parent class throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  int widthValue=((IntToken)width.getToken()).intValue();
  plot.setXRange(_xInit,_xUnit * widthValue + _xInit);
  plot.setWrap(true);
  int persValue=((IntToken)persistence.getToken()).intValue();
  plot.setPointsPersistence(persValue);
  if (plot.getMarksStyle().equals(""String_Node_Str"")) {
    plot.setMarksStyle(""String_Node_Str"");
  }
  plot.repaint();
}"
75819,"/** 
 * Return the text string that represents the current configuration of this object.  Note that any configuration that was previously specified using the source attribute need not be returned here.
 */
public String getText(){
  if (plot == null) {
    return ""String_Node_Str"";
  }
 else {
    String header=""String_Node_Str"" + ""String_Node_Str"";
    StringBuffer buffer=new StringBuffer();
    buffer.append(header);
    buffer.append(""String_Node_Str"");
    PrintWriter print=new PrintWriter(new StringWriter());
    plot.writeFormat(print);
    buffer.append(print.toString());
    return buffer.toString();
  }
}","/** 
 * Return the text string that represents the current configuration of this object.  Note that any configuration that was previously specified using the source attribute need not be returned here.
 */
public String getText(){
  if (plot == null) {
    return ""String_Node_Str"";
  }
 else {
    String header=""String_Node_Str"" + ""String_Node_Str"";
    StringWriter writer=new StringWriter();
    PrintWriter print=new PrintWriter(writer);
    print.write(""String_Node_Str"");
    plot.writeFormat(print);
    print.write(""String_Node_Str"");
    return writer.toString();
  }
}"
75820,"/** 
 * Consume a single IntToken on the input. Produce 32 consecutive BooleanTokens on the output port which is the bitwise representation of the input IntToken. The most significant bit is the first boolean token send out. The least significant bit is the last boolean token send out.
 * @exception IllegalActionException If there is no director.
 */
public final void fire() throws IllegalActionException {
  int i;
  int integer, remainder;
  IntToken token;
  BooleanToken[] bits;
  bits=new BooleanToken[32];
  token=(IntToken)(input.get(0));
  integer=token.intValue();
  for (i=31; i >= 0; i--) {
    remainder=integer % 2;
    integer=integer / 2;
    if (remainder == 0)     bits[i]=new BooleanToken(false);
 else     bits[i]=new BooleanToken(true);
  }
  output.send(0,bits,bits.length);
}","/** 
 * Consume a single IntToken on the input. Produce 32 consecutive BooleanTokens on the output port which is the bitwise representation of the input IntToken. The most significant bit is the first boolean token send out. The least significant bit is the last boolean token send out.
 * @exception IllegalActionException If there is no director.
 */
public final void fire() throws IllegalActionException {
  int i;
  int integer, remainder;
  IntToken token;
  BooleanToken[] bits;
  bits=new BooleanToken[32];
  token=(IntToken)(input.get(0));
  integer=token.intValue();
  if (integer < 0) {
    bits[0]=new BooleanToken(true);
    integer=(int)(2147483648L + integer);
  }
 else {
    bits[0]=new BooleanToken(false);
  }
  for (i=31; i >= 1; i--) {
    remainder=integer % 2;
    integer=integer / 2;
    if (remainder == 0)     bits[i]=new BooleanToken(false);
 else     bits[i]=new BooleanToken(true);
  }
  output.send(0,bits,bits.length);
}"
75821,"/** 
 * Initialize the firing of the director by resetting state variables and resetting all receivers to have unknown status.
 */
private void _initFiring(){
  _postfireReturns=false;
  _actorsAllowedToFire=null;
  _actorsFired=null;
  _cachedAllInputsKnown=null;
  _cachedAllOutputsKnown=null;
  _lastNumOfActorsAllowedToFire=-1;
  _lastNumOfKnownReceivers=-1;
  _resetAllReceivers();
  _currentNumOfKnownReceivers=0;
}","/** 
 * Initialize the firing of the director by resetting state variables and resetting all receivers to have unknown status.
 */
private void _initFiring(){
  _postfireReturns=false;
  _actorsAllowedToFire=null;
  _actorsFired=null;
  _cachedAllInputsKnown=null;
  _cachedAllOutputsKnown=null;
  _lastNumOfActorsAllowedToFire=-1;
  _lastNumOfKnownReceivers=-1;
}"
75822,"/** 
 * Reset all receivers to allow a new firing of the director.
 */
private void _resetAllReceivers(){
  Iterator i=_receivers.iterator();
  while (i.hasNext()) {
    ((SRReceiver)i.next()).reset();
  }
}","/** 
 * Reset all receivers to allow a new firing of the director.
 */
private void _resetAllReceivers(){
  _currentNumOfKnownReceivers=0;
  Iterator i=_receivers.iterator();
  while (i.hasNext()) {
    ((SRReceiver)i.next()).reset();
  }
}"
75823,"/** 
 * Return false if the system has finished executing, either by reaching the iteration limit, or if no actors in the model return true in postfire.
 * @return True if the execution is not finished.
 * @exception IllegalActionException If the iterations parameter doesnot have a valid token.
 */
public boolean postfire() throws IllegalActionException {
  int numberOfIterations=getIterations();
  _iteration++;
  _debug(""String_Node_Str"",String.valueOf(_iteration - 1),""String_Node_Str"");
  if ((numberOfIterations > 0) && (_iteration >= numberOfIterations)) {
    _iteration=0;
    return false;
  }
  return _postfireReturns;
}","/** 
 * Return false if the system has finished executing, either by reaching the iteration limit, or if no actors in the model return true in postfire.
 * @return True if the execution is not finished.
 * @exception IllegalActionException If the iterations parameter doesnot have a valid token.
 */
public boolean postfire() throws IllegalActionException {
  int numberOfIterations=getIterations();
  _iteration++;
  _debug(""String_Node_Str"",String.valueOf(_iteration - 1),""String_Node_Str"");
  _resetAllReceivers();
  if ((numberOfIterations > 0) && (_iteration >= numberOfIterations)) {
    _iteration=0;
    return false;
  }
  return _postfireReturns;
}"
75824,"/** 
 * Initialize the director and invoke the initialize() methods of all  actors deeply contained by the container.
 * @exception IllegalActionException If the superclass throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _iteration=0;
  _actorsNotAllowedToIterate=null;
  _getSchedule();
}","/** 
 * Initialize the director and invoke the initialize() methods of all  actors deeply contained by the container.
 * @exception IllegalActionException If the superclass throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _iteration=0;
  _actorsNotAllowedToIterate=null;
  _resetAllReceivers();
  _getSchedule();
}"
75825,"private void _updateOutputTokenProductionRates(TypedCompositeActor actor) throws IllegalActionException {
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ actor.getName());
  CompositeActor refineOutPortContainer=(CompositeActor)actor.getContainer();
  List containerPortList=refineOutPortContainer.outputPortList();
  Iterator containerPorts=containerPortList.iterator();
  while (containerPorts.hasNext()) {
    IOPort containerPort=(IOPort)containerPorts.next();
    _setTokenProductionRate(refineOutPortContainer,containerPort,0);
  }
  Iterator refineOutPorts=actor.outputPortList().iterator();
  while (refineOutPorts.hasNext()) {
    IOPort refineOutPort=(IOPort)refineOutPorts.next();
    if (_debug_info) {
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refineOutPort.getFullName()+ ""String_Node_Str""+ SDFScheduler.getTokenProductionRate(refineOutPort));
    }
    Iterator outPortsOutside=refineOutPort.deepConnectedOutPortList().iterator();
    if (!outPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (outPortsOutside.hasNext()) {
      IOPort outputPortOutside=(IOPort)outPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ outputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)outputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineOutPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ outputPortOutside.getFullName());
        int portRateToSet=SDFScheduler.getTokenProductionRate(refineOutPort);
        SDFScheduler.setTokenProductionRate(outputPortOutside,portRateToSet);
      }
    }
  }
}","private void _updateOutputTokenProductionRates(TypedCompositeActor actor) throws IllegalActionException {
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ actor.getName());
  CompositeActor refineOutPortContainer=(CompositeActor)actor.getContainer();
  List containerPortList=refineOutPortContainer.outputPortList();
  Iterator containerPorts=containerPortList.iterator();
  while (containerPorts.hasNext()) {
    IOPort containerPort=(IOPort)containerPorts.next();
    _setTokenProductionRate(refineOutPortContainer,containerPort,0);
  }
  Iterator refineOutPorts=actor.outputPortList().iterator();
  while (refineOutPorts.hasNext()) {
    IOPort refineOutPort=(IOPort)refineOutPorts.next();
    if (_debug_info) {
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refineOutPort.getFullName()+ ""String_Node_Str""+ SDFScheduler.getTokenProductionRate(refineOutPort));
    }
    Iterator outPortsOutside=refineOutPort.deepConnectedOutPortList().iterator();
    while (outPortsOutside.hasNext()) {
      IOPort outputPortOutside=(IOPort)outPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ outputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)outputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineOutPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ outputPortOutside.getFullName());
        int portRateToSet=SDFScheduler.getTokenProductionRate(refineOutPort);
        SDFScheduler.setTokenProductionRate(outputPortOutside,portRateToSet);
      }
    }
  }
}"
75826,"/** 
 * Return true if the transition is enabled, that is the guard is true.
 * @return True if the transition is enabled.
 * @exception IllegalActionException If thrown when evaluating the guard.
 */
public boolean isEnabled() throws IllegalActionException {
  try {
    Token tok=_guard.getToken();
    return ((BooleanToken)tok).booleanValue();
  }
 catch (  UnknownResultException ex) {
    return false;
  }
}","/** 
 * Return true if the transition is enabled, that is the guard is true.
 * @return True if the transition is enabled.
 * @exception IllegalActionException If thrown when evaluating the guard.
 */
public boolean isEnabled() throws IllegalActionException {
  try {
    Token tok=_guard.getToken();
    if (tok == null)     return false;
    return ((BooleanToken)tok).booleanValue();
  }
 catch (  UnknownResultException ex) {
    return false;
  }
}"
75827,"/** 
 * Initialize the director by creating the scheduler and the parameters.
 */
private void _init(){
  try {
    SRScheduler scheduler=new SRScheduler(this,uniqueName(""String_Node_Str""));
    setScheduler(scheduler);
  }
 catch (  Exception ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
  try {
    iterations=new Parameter(this,""String_Node_Str"",new IntToken(0));
    iterations.setTypeEquals(BaseType.INT);
    setCurrentTime(0.0);
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Initialize the director by creating the scheduler and the parameters.
 */
private void _init(){
  try {
    SRScheduler scheduler=new SRScheduler(this,uniqueName(""String_Node_Str""));
    setScheduler(scheduler);
  }
 catch (  Exception ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
  try {
    iterations=new Parameter(this,""String_Node_Str"",new IntToken(0));
    iterations.setTypeEquals(BaseType.INT);
    setCurrentTime(0.0);
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ex.getMessage());
  }
  _receivers=new LinkedList();
}"
75828,"/** 
 * Reset all receivers to allow a new firing of the director.
 */
private void _resetAllReceivers(){
  _currentNumOfKnownReceivers=0;
  Iterator i=_receivers.iterator();
  while (i.hasNext()) {
    ((SRReceiver)i.next()).reset();
  }
}","/** 
 * Reset all receivers to allow a new firing of the director.
 */
private void _resetAllReceivers(){
  _debug(""String_Node_Str"");
  _currentNumOfKnownReceivers=0;
  Iterator i=_receivers.iterator();
  while (i.hasNext()) {
    ((SRReceiver)i.next()).reset();
  }
}"
75829,"/** 
 * Fire contained actors until the iteration converges.  This method also calls the prefire() method of an actor before it is fired for the first time, and at the end, calls the postfire() methods of all  actors that were fired.
 * @exception IllegalActionException If an actor attempts to modifya known value.
 */
public void fire() throws IllegalActionException {
  Schedule schedule=_getSchedule();
  Iterator firingIterator;
  _initFiring();
  do {
    firingIterator=schedule.firingIterator();
    while (firingIterator.hasNext()) {
      Firing firing=(Firing)firingIterator.next();
      Actor actor=firing.getActor();
      if (_isIterationAllowed(actor)) {
        _fireActor(actor);
      }
 else {
        _sendAbsentToAllUnknownOutputsOf(actor);
      }
    }
  }
 while (!_hasIterationConverged());
  firingIterator=schedule.firingIterator();
  while (firingIterator.hasNext()) {
    Firing firing=(Firing)firingIterator.next();
    Actor actor=firing.getActor();
    if (_isIterationAllowed(actor)) {
      if (_postfireActor(actor)) {
        _postfireReturns=true;
      }
 else {
        _doNotAllowIterationOf(actor);
      }
    }
  }
}","/** 
 * Fire contained actors until the iteration converges.  This method also calls the prefire() method of an actor before it is fired for the first time, and at the end, calls the postfire() methods of all  actors that were fired.
 * @exception IllegalActionException If an actor attempts to modifya known value.
 */
public void fire() throws IllegalActionException {
  Schedule schedule=_getSchedule();
  Iterator firingIterator;
  _initFiring();
  do {
    firingIterator=schedule.firingIterator();
    while (firingIterator.hasNext()) {
      Firing firing=(Firing)firingIterator.next();
      Actor actor=firing.getActor();
      if (_isIterationAllowed(actor)) {
        _fireActor(actor);
      }
 else {
        _sendAbsentToAllUnknownOutputsOf(actor);
      }
    }
  }
 while (!_hasIterationConverged());
}"
75830,"/** 
 * Return a new receiver consistent with the SR domain.
 * @return A new SRReceiver.
 */
public Receiver newReceiver(){
  if (_receivers == null)   _receivers=new LinkedList();
  Receiver receiver=new SRReceiver(this);
  _receivers.add(receiver);
  return receiver;
}","/** 
 * Return a new receiver consistent with the SR domain.
 * @return A new SRReceiver.
 */
public Receiver newReceiver(){
  if (_receivers == null)   _receivers=new LinkedList();
  Receiver receiver=new SRReceiver(this);
  _receivers.add(receiver);
  _debug(""String_Node_Str"" + _receivers.size());
  return receiver;
}"
75831,"/** 
 * Initialize the internal receiver list and invoke the preinitialize()  methods of all deeply contained actors.
 * @exception IllegalActionException If the superclass throws it.
 */
public void preinitialize() throws IllegalActionException {
  _receivers=new LinkedList();
  super.preinitialize();
}","/** 
 * Initialize the internal receiver list and invoke the preinitialize()  methods of all deeply contained actors.
 * @exception IllegalActionException If the superclass throws it.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
}"
75832,"/** 
 * Return false if the system has finished executing, either by reaching the iteration limit, or if no actors in the model return true in postfire.
 * @return True if the execution is not finished.
 * @exception IllegalActionException If the iterations parameter doesnot have a valid token.
 */
public boolean postfire() throws IllegalActionException {
  int numberOfIterations=getIterations();
  _iteration++;
  _debug(""String_Node_Str"",String.valueOf(_iteration - 1),""String_Node_Str"");
  _resetAllReceivers();
  if ((numberOfIterations > 0) && (_iteration >= numberOfIterations)) {
    _iteration=0;
    return false;
  }
  return _postfireReturns;
}","/** 
 * Return false if the system has finished executing, either by reaching the iteration limit, or if no actors in the model return true in postfire.
 * @return True if the execution is not finished.
 * @exception IllegalActionException If the iterations parameter doesnot have a valid token.
 */
public boolean postfire() throws IllegalActionException {
  Schedule schedule=_getSchedule();
  Iterator firingIterator=schedule.firingIterator();
  while (firingIterator.hasNext()) {
    Firing firing=(Firing)firingIterator.next();
    Actor actor=firing.getActor();
    if (_isIterationAllowed(actor)) {
      if (_postfireActor(actor)) {
        _postfireReturns=true;
      }
 else {
        _doNotAllowIterationOf(actor);
      }
    }
  }
  int numberOfIterations=getIterations();
  _iteration++;
  _debug(""String_Node_Str"",String.valueOf(_iteration - 1),""String_Node_Str"");
  _resetAllReceivers();
  if ((numberOfIterations > 0) && (_iteration >= numberOfIterations)) {
    _iteration=0;
    return false;
  }
  return _postfireReturns;
}"
75833,"/** 
 * Initialize the object. In this case, we give the HDFDirector a default scheduler of the class HDFScheduler.
 */
private void _init(){
  try {
    SDFScheduler scheduler=new SDFScheduler(this,uniqueName(""String_Node_Str""));
    setScheduler(scheduler);
  }
 catch (  Exception e) {
    throw new InternalErrorException(""String_Node_Str"" + e.getMessage());
  }
  try {
    int cacheSize=100;
    scheduleCacheSize=new Parameter(this,""String_Node_Str"",new IntToken(cacheSize));
    _scheduleCache=new HashMap();
    _scheduleKeyList=new ArrayList(cacheSize);
  }
 catch (  Exception e) {
    throw new InternalErrorException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Initialize the object. In this case, we give the HDFDirector a default scheduler of the class HDFScheduler.
 */
private void _init(){
  try {
    SDFScheduler scheduler=new SDFScheduler(this,uniqueName(""String_Node_Str""));
    setScheduler(scheduler);
  }
 catch (  Exception e) {
    throw new InternalErrorException(""String_Node_Str"" + e.getMessage());
  }
  try {
    int cacheSize=100;
    _cacheSize=cacheSize;
    scheduleCacheSize=new Parameter(this,""String_Node_Str"",new IntToken(cacheSize));
    _scheduleCache=new HashMap();
    _scheduleKeyList=new ArrayList(cacheSize);
  }
 catch (  Exception e) {
    throw new InternalErrorException(""String_Node_Str"" + e.getMessage());
  }
}"
75834,"/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method maintains a schedule cache and will attempt to return a cached version of the schedule. If the cache does not contain the schedule for the current hdf graph, then the schedule will be computed by calling the getSchedule() method of the SDFScheduler. <p> The schedule cache uses a least-recently-used replacement policy. The size of the cache is specified by the scheduleCacheSize parameter. The default cache size is 100.
 * @return The Schedule for the current hdf graph.
 * @exception IllegalActionException If there is a problem gettingthe schedule.
 */
public Schedule getSchedule() throws IllegalActionException {
  Scheduler scheduler=getScheduler();
  Schedule schedule;
  if (isScheduleValid()) {
    schedule=scheduler.getSchedule();
  }
 else {
    if (_inputPortList == null) {
      _inputPortList=_getInputPortList();
    }
    if (_outputPortList == null) {
      _outputPortList=_getOutputPortList();
    }
    Iterator inputPorts=_inputPortList.iterator();
    String rates=new String();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      int rate=SDFScheduler.getTokenConsumptionRate(inputPort);
      rates=rates + String.valueOf(rate);
    }
    Iterator outputPorts=_outputPortList.iterator();
    while (inputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      int rate=SDFScheduler.getTokenProductionRate(outputPort);
      rates=rates + String.valueOf(rate);
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + rates);
    }
    String rateKey=rates;
    int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
    if (_scheduleCache.containsKey(rateKey)) {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=(Schedule)_scheduleCache.get(rateKey);
    }
 else {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        while (_scheduleKeyList.size() >= cacheSize) {
          Object object=_scheduleKeyList.get(cacheSize - 1);
          _scheduleKeyList.remove(cacheSize - 1);
          _scheduleCache.remove(object);
        }
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=scheduler.getSchedule();
      _scheduleCache.put(rateKey,schedule);
    }
  }
  return schedule;
}","/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method maintains a schedule cache and will attempt to return a cached version of the schedule. If the cache does not contain the schedule for the current hdf graph, then the schedule will be computed by calling the getSchedule() method of the SDFScheduler. <p> The schedule cache uses a least-recently-used replacement policy. The size of the cache is specified by the scheduleCacheSize parameter. The default cache size is 100.
 * @return The Schedule for the current hdf graph.
 * @exception IllegalActionException If there is a problem gettingthe schedule.
 */
public Schedule getSchedule() throws IllegalActionException {
  Scheduler scheduler=getScheduler();
  Schedule schedule;
  if (isScheduleValid()) {
    schedule=scheduler.getSchedule();
  }
 else {
    if (_inputPortList == null) {
      _inputPortList=_getInputPortList();
    }
    if (_outputPortList == null) {
      _outputPortList=_getOutputPortList();
    }
    Iterator inputPorts=_inputPortList.iterator();
    String rates=new String();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      int rate=SDFScheduler.getTokenConsumptionRate(inputPort);
      rates=rates + String.valueOf(rate);
    }
    Iterator outputPorts=_outputPortList.iterator();
    while (inputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      int rate=SDFScheduler.getTokenProductionRate(outputPort);
      rates=rates + String.valueOf(rate);
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + rates);
    }
    String rateKey=rates;
    int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
    if (cacheSize != _cacheSize) {
      _scheduleCache=new HashMap();
      _scheduleKeyList=new ArrayList(cacheSize);
      _cacheSize=cacheSize;
    }
    if (_scheduleCache.containsKey(rateKey)) {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=(Schedule)_scheduleCache.get(rateKey);
    }
 else {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        while (_scheduleKeyList.size() >= cacheSize) {
          Object object=_scheduleKeyList.get(cacheSize - 1);
          _scheduleKeyList.remove(cacheSize - 1);
          _scheduleCache.remove(object);
        }
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=scheduler.getSchedule();
      _scheduleCache.put(rateKey,schedule);
    }
  }
  return schedule;
}"
75835,"/** 
 * Return the firing count of the specified actor in the schedule. The specified actor must be director contained by this director. Otherwise an exception will occur.
 * @param actor The actor to return the firing count for.
 * @exception IllegalActionException I
 */
public int getFiringCount(Actor actor) throws IllegalActionException {
  Schedule schedule=getSchedule();
  Iterator firings=schedule.firingIterator();
  int occurrence=0;
  while (firings.hasNext()) {
    Firing firing=(Firing)firings.next();
    Actor actorInSchedule=(Actor)(firing.getActor());
    String actorInScheduleName=((Nameable)actorInSchedule).getName();
    String actorName=((Nameable)actor).getName();
    if (actorInScheduleName.equals(actorName)) {
      occurrence+=firing.getIterationCount();
    }
    if (_debug_info) {
      System.out.println(getName() + ""String_Node_Str"" + ((Nameable)actor).getName());
      System.out.println(getName() + ""String_Node_Str"" + occurrence);
    }
  }
  return occurrence;
}","/** 
 * Return the firing count of the specified actor in the schedule. The specified actor must be director contained by this director. Otherwise an exception will occur.
 * @param actor The actor to return the firing count for.
 * @exception IllegalActionException If there is a problem computingthe firing count.
 */
public int getFiringCount(Actor actor) throws IllegalActionException {
  Schedule schedule=getSchedule();
  Iterator firings=schedule.firingIterator();
  int occurrence=0;
  while (firings.hasNext()) {
    Firing firing=(Firing)firings.next();
    Actor actorInSchedule=(Actor)(firing.getActor());
    String actorInScheduleName=((Nameable)actorInSchedule).getName();
    String actorName=((Nameable)actor).getName();
    if (actorInScheduleName.equals(actorName)) {
      occurrence+=firing.getIterationCount();
    }
    if (_debug_info) {
    }
  }
  return occurrence;
}"
75836,"/** 
 * @exception IllegalActionException If fixme.
 */
public Schedule getSchedule() throws IllegalActionException {
  Scheduler scheduler=getScheduler();
  if (scheduler == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  Schedule schedule;
  if (isScheduleValid()) {
    schedule=scheduler.getSchedule();
  }
 else {
    CompositeActor container=(CompositeActor)getContainer();
    String momlKey=container.exportMoML();
    if (_scheduleCache.containsKey(momlKey)) {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      _scheduleKeyList.remove(momlKey);
      _scheduleKeyList.add(0,momlKey);
      schedule=(Schedule)_scheduleCache.get(momlKey);
    }
 else {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      _scheduleKeyList.add(0,momlKey);
      int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
      if (_scheduleCache.size() >= cacheSize) {
        _scheduleKeyList.remove(cacheSize - 1);
        _scheduleCache.remove(momlKey);
      }
      schedule=scheduler.getSchedule();
      _scheduleCache.put(momlKey,schedule);
    }
  }
  return schedule;
}","/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method maintains a schedule cache and will attempt to return a cached version of the schedule. If the cache does not contain the schedule for the current hdf graph, then the schedule will be computed by calling the getSchedule() method of the SDFScheduler. <p> The schedule cache uses a least-recently-used replacement policy. The size of the cache is specified by the scheduleCacheSize parameter. The default cache size is 100.
 * @return The Schedule for the current hdf graph.
 * @exception IllegalActionException If there is a problem gettingthe schedule.
 */
public Schedule getSchedule() throws IllegalActionException {
  Scheduler scheduler=getScheduler();
  Schedule schedule;
  if (isScheduleValid()) {
    schedule=scheduler.getSchedule();
  }
 else {
    if (_inputPortList == null) {
      _inputPortList=_getInputPortList();
    }
    if (_outputPortList == null) {
      _outputPortList=_getOutputPortList();
    }
    Iterator inputPorts=_inputPortList.iterator();
    String rates=new String();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      int rate=SDFScheduler.getTokenConsumptionRate(inputPort);
      rates=rates + String.valueOf(rate);
    }
    Iterator outputPorts=_outputPortList.iterator();
    while (inputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      int rate=SDFScheduler.getTokenProductionRate(outputPort);
      rates=rates + String.valueOf(rate);
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + rates);
    }
    String rateKey=rates;
    int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
    if (_scheduleCache.containsKey(rateKey)) {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=(Schedule)_scheduleCache.get(rateKey);
    }
 else {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        while (_scheduleKeyList.size() >= cacheSize) {
          Object object=_scheduleKeyList.get(cacheSize - 1);
          _scheduleKeyList.remove(cacheSize - 1);
          _scheduleCache.remove(object);
        }
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=scheduler.getSchedule();
      _scheduleCache.put(rateKey,schedule);
    }
  }
  return schedule;
}"
75837,"/** 
 * Calculate the current schedule, if necessary, and iterate the  contained actors in the order given by the schedule. This  method differes from the fire() method of SDFDirector in that  this method uses cached schedules when possible. This leads to  more efficient execution. The cache size to use is set by the scheduleCacheSize parameter.   <p> Iterating an actor involves calling the actor's iterate() method, which is equivalent to calling the actor's  prefire(), fire() and postfire() methods in succession.  If iterate() returns NOT_READY, indicating that the actor is not ready to execute, then an IllegalActionException will be thrown. The values returned from iterate() are recorded and are used to determine the value that postfire() will return at the end of the director's iteration.
 * @exception IllegalActionException If any actor executed by thisactor return false in prefire.
 * @exception InvalidStateException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  TypedCompositeActor container=((TypedCompositeActor)getContainer());
  if (container == null) {
    throw new InvalidStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
 else {
    Schedule sched=getSchedule();
    Iterator firings=sched.firingIterator();
    while (firings.hasNext()) {
      Firing firing=(Firing)firings.next();
      Actor actor=(Actor)firing.getActor();
      int iterationCount=firing.getIterationCount();
      if (_debugging) {
        _debug(new FiringEvent(this,actor,FiringEvent.ITERATE));
      }
      int factor=((IntToken)(vectorizationFactor.getToken())).intValue();
      if (factor < 1) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ factor);
      }
      int returnVal=actor.iterate(factor * iterationCount);
      if (returnVal == COMPLETED) {
        _postfirereturns=_postfirereturns && true;
      }
 else       if (returnVal == NOT_READY) {
        throw new IllegalActionException(this,(ComponentEntity)actor,""String_Node_Str"" + ""String_Node_Str"");
      }
 else       if (returnVal == STOP_ITERATING) {
        _postfirereturns=false;
      }
    }
  }
}","/** 
 * Calculate the current schedule, if necessary, and iterate the  contained actors in the order given by the schedule. This  method differes from the fire() method of SDFDirector in that  this method uses cached schedules when possible. This leads to  more efficient execution. The cache size to use is set by the scheduleCacheSize parameter.   <p> Iterating an actor involves calling the actor's iterate() method, which is equivalent to calling the actor's  prefire(), fire() and postfire() methods in succession.  If iterate() returns NOT_READY, indicating that the actor is not ready to execute, then an IllegalActionException will be thrown. The values returned from iterate() are recorded and are used to determine the value that postfire() will return at the end of the director's iteration.
 * @exception IllegalActionException If any actor executed by thisactor return false in prefire.
 * @exception InvalidStateException If this director does not have acontainer.
 */
public void fire() throws IllegalActionException {
  if (_debug_info) {
    System.out.println(getName() + ""String_Node_Str"");
  }
  TypedCompositeActor container=((TypedCompositeActor)getContainer());
  if (container == null) {
    throw new InvalidStateException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
 else {
    if (_debug_info) {
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str"");
      Schedule tSched=getSchedule();
      Iterator tFirings=tSched.firingIterator();
      while (tFirings.hasNext()) {
        Firing firing=(Firing)tFirings.next();
        Actor actor=(Actor)firing.getActor();
        System.out.println(""String_Node_Str"" + ((NamedObj)actor).getName() + ""String_Node_Str"");
      }
    }
    Schedule sched=getSchedule();
    Iterator firings=sched.firingIterator();
    while (firings.hasNext()) {
      Firing firing=(Firing)firings.next();
      Actor actor=(Actor)firing.getActor();
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ((NamedObj)actor).getName());
      }
      int iterationCount=firing.getIterationCount();
      if (_debugging) {
        _debug(new FiringEvent(this,actor,FiringEvent.ITERATE));
      }
      int factor=((IntToken)(vectorizationFactor.getToken())).intValue();
      if (factor < 1) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ factor);
      }
      int returnVal=actor.iterate(factor * iterationCount);
      if (returnVal == COMPLETED) {
        _postfirereturns=_postfirereturns && true;
      }
 else       if (returnVal == NOT_READY) {
        throw new IllegalActionException(this,(ComponentEntity)actor,""String_Node_Str"" + ""String_Node_Str"");
      }
 else       if (returnVal == STOP_ITERATING) {
        _postfirereturns=false;
      }
    }
  }
}"
75838,"/** 
 * Return a list of all the input ports contained by the deeply contained entities of the container of this director.
 * @return The list of input ports.
 */
private List _getInputPortList(){
  CompositeActor container=(CompositeActor)getContainer();
  List actors=container.deepEntityList();
  Iterator actorIterator=actors.iterator();
  List inputPortList=new LinkedList();
  ;
  List inputPortRateList=new LinkedList();
  while (actorIterator.hasNext()) {
    Actor containedActor=(Actor)actorIterator.next();
    List temporaryInputPortList=containedActor.inputPortList();
    Iterator inputPortIterator=temporaryInputPortList.iterator();
    while (inputPortIterator.hasNext()) {
      IOPort inputPort=(IOPort)inputPortIterator.next();
      inputPortList.add(inputPort);
    }
  }
  return inputPortList;
}","/** 
 * Return a list of all the input ports contained by the deeply contained entities of the container of this director.
 * @return The list of input ports.
 */
private List _getInputPortList(){
  CompositeActor container=(CompositeActor)getContainer();
  List actors=container.deepEntityList();
  Iterator actorIterator=actors.iterator();
  List inputPortList=new LinkedList();
  ;
  List inputPortRateList=new LinkedList();
  while (actorIterator.hasNext()) {
    Actor containedActor=(Actor)actorIterator.next();
    List temporaryInputPortList=containedActor.inputPortList();
    Iterator inputPortIterator=temporaryInputPortList.iterator();
    while (inputPortIterator.hasNext()) {
      IOPort inputPort=(IOPort)inputPortIterator.next();
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"" + inputPort.getName());
      }
      inputPortList.add(inputPort);
    }
  }
  return inputPortList;
}"
75839,"/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method maintains a schedule cache and will attempt to return a cached version of the schedule. If the cache does not contain the schedule for the current hdf graph, then the schedule will be computed by calling the getSchedule() method of the SDFScheduler. <p> The schedule cache uses a least-recently-used replacement policy. The size of the cache is specified by the scheduleCacheSize parameter. The default cache size is 100.
 * @return The Schedule for the current hdf graph.
 * @exception IllegalActionException If there is a problem gettingthe schedule.
 */
public Schedule getSchedule() throws IllegalActionException {
  Scheduler scheduler=getScheduler();
  Schedule schedule;
  if (isScheduleValid()) {
    schedule=scheduler.getSchedule();
  }
 else {
    if (_inputPortList == null) {
      _inputPortList=_getInputPortList();
    }
    if (_outputPortList == null) {
      _outputPortList=_getOutputPortList();
    }
    Iterator inputPorts=_inputPortList.iterator();
    String rates=new String();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      int rate=SDFScheduler.getTokenConsumptionRate(inputPort);
      rates=rates + String.valueOf(rate);
    }
    Iterator outputPorts=_outputPortList.iterator();
    while (inputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      int rate=SDFScheduler.getTokenProductionRate(outputPort);
      rates=rates + String.valueOf(rate);
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + rates);
    }
    String rateKey=rates;
    int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
    if (cacheSize != _cacheSize) {
      _scheduleCache=new HashMap();
      _scheduleKeyList=new ArrayList(cacheSize);
      _cacheSize=cacheSize;
    }
    if (_scheduleCache.containsKey(rateKey)) {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=(Schedule)_scheduleCache.get(rateKey);
    }
 else {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        while (_scheduleKeyList.size() >= cacheSize) {
          Object object=_scheduleKeyList.get(cacheSize - 1);
          _scheduleKeyList.remove(cacheSize - 1);
          _scheduleCache.remove(object);
        }
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=scheduler.getSchedule();
      _scheduleCache.put(rateKey,schedule);
    }
  }
  return schedule;
}","/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method maintains a schedule cache and will attempt to return a cached version of the schedule. If the cache does not contain the schedule for the current hdf graph, then the schedule will be computed by calling the getSchedule() method of the SDFScheduler. <p> The schedule cache uses a least-recently-used replacement policy. The size of the cache is specified by the scheduleCacheSize parameter. The default cache size is 100.
 * @return The Schedule for the current hdf graph.
 * @exception IllegalActionException If there is a problem gettingthe schedule.
 */
public Schedule getSchedule() throws IllegalActionException {
  Scheduler scheduler=getScheduler();
  Schedule schedule;
  if (isScheduleValid()) {
    schedule=scheduler.getSchedule();
  }
 else {
    if (_inputPortList == null) {
      _inputPortList=_getInputPortList();
    }
    if (_outputPortList == null) {
      _outputPortList=_getOutputPortList();
    }
    Iterator inputPorts=_inputPortList.iterator();
    String rates=new String();
    while (inputPorts.hasNext()) {
      IOPort inputPort=(IOPort)inputPorts.next();
      int rate=SDFScheduler.getTokenConsumptionRate(inputPort);
      rates=rates + String.valueOf(rate);
    }
    Iterator outputPorts=_outputPortList.iterator();
    while (outputPorts.hasNext()) {
      IOPort outputPort=(IOPort)outputPorts.next();
      int rate=SDFScheduler.getTokenProductionRate(outputPort);
      rates=rates + String.valueOf(rate);
    }
    if (_debug_info) {
      System.out.println(""String_Node_Str"" + rates);
    }
    String rateKey=rates;
    int cacheSize=((IntToken)(scheduleCacheSize.getToken())).intValue();
    if (cacheSize != _cacheSize) {
      _scheduleCache=new HashMap();
      _scheduleKeyList=new ArrayList(cacheSize);
      _cacheSize=cacheSize;
    }
    if (_scheduleCache.containsKey(rateKey)) {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        _scheduleKeyList.remove(rateKey);
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=(Schedule)_scheduleCache.get(rateKey);
    }
 else {
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"");
      }
      if (cacheSize > 0) {
        while (_scheduleKeyList.size() >= cacheSize) {
          Object object=_scheduleKeyList.get(cacheSize - 1);
          _scheduleKeyList.remove(cacheSize - 1);
          _scheduleCache.remove(object);
        }
        _scheduleKeyList.add(0,rateKey);
      }
      schedule=scheduler.getSchedule();
      _scheduleCache.put(rateKey,schedule);
    }
  }
  return schedule;
}"
75840,"/** 
 * Return a list of all the output ports contained by the deeply contained entities of the container of this director.
 * @return The list of output ports.
 */
private List _getOutputPortList(){
  CompositeActor container=(CompositeActor)getContainer();
  List actors=container.deepEntityList();
  Iterator actorIterator2=actors.iterator();
  List outputPortList=new LinkedList();
  ;
  List outputPortRateList=new LinkedList();
  while (actorIterator2.hasNext()) {
    Actor containedActor=(Actor)actorIterator2.next();
    List temporaryOutputPortList=containedActor.outputPortList();
    Iterator outputPortIterator=temporaryOutputPortList.iterator();
    while (outputPortIterator.hasNext()) {
      IOPort outputPort=(IOPort)outputPortIterator.next();
      outputPortList.add(outputPort);
    }
  }
  return outputPortList;
}","/** 
 * Return a list of all the output ports contained by the deeply contained entities of the container of this director.
 * @return The list of output ports.
 */
private List _getOutputPortList(){
  CompositeActor container=(CompositeActor)getContainer();
  List actors=container.deepEntityList();
  Iterator actorIterator2=actors.iterator();
  List outputPortList=new LinkedList();
  ;
  List outputPortRateList=new LinkedList();
  while (actorIterator2.hasNext()) {
    Actor containedActor=(Actor)actorIterator2.next();
    List temporaryOutputPortList=containedActor.outputPortList();
    Iterator outputPortIterator=temporaryOutputPortList.iterator();
    while (outputPortIterator.hasNext()) {
      IOPort outputPort=(IOPort)outputPortIterator.next();
      if (_debug_info) {
        System.out.println(getName() + ""String_Node_Str"" + outputPort.getName());
      }
      outputPortList.add(outputPort);
    }
  }
  return outputPortList;
}"
75841,"private void _updateInputTokenConsumptionRates(TypedCompositeActor actor) throws IllegalActionException {
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ actor.getFullName());
  CompositeActor refineInPortContainer=(CompositeActor)actor.getContainer();
  List containerPortList=refineInPortContainer.inputPortList();
  Iterator containerPorts=containerPortList.iterator();
  while (containerPorts.hasNext()) {
    IOPort containerPort=(IOPort)containerPorts.next();
    _setTokenConsumptionRate(refineInPortContainer,containerPort,0);
  }
  Iterator refineInPorts=actor.inputPortList().iterator();
  while (refineInPorts.hasNext()) {
    IOPort refineInPort=(IOPort)refineInPorts.next();
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refineInPort.getFullName());
    Iterator inPortsOutside=refineInPort.deepConnectedInPortList().iterator();
    if (!inPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (inPortsOutside.hasNext()) {
      IOPort inputPortOutside=(IOPort)inPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ inputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)inputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineInPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ inputPortOutside.getFullName());
        List listOfPorts=refineInPort.insidePortList();
        int refineInPortRate;
        if (listOfPorts.isEmpty()) {
          refineInPortRate=0;
        }
 else {
          IOPort portWithRateInfo=(IOPort)listOfPorts.get(0);
          refineInPortRate=_getTokenConsumptionRate(portWithRateInfo);
        }
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + refineInPort.getFullName()+ ""String_Node_Str""+ _getTokenConsumptionRate(refineInPort));
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refineInPortRate);
        _setTokenConsumptionRate(refineInPortContainer,inputPortOutside,refineInPortRate);
      }
    }
  }
}","private void _updateInputTokenConsumptionRates(TypedCompositeActor actor) throws IllegalActionException {
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ actor.getFullName());
  CompositeActor refineInPortContainer=(CompositeActor)actor.getContainer();
  List containerPortList=refineInPortContainer.inputPortList();
  Iterator containerPorts=containerPortList.iterator();
  while (containerPorts.hasNext()) {
    IOPort containerPort=(IOPort)containerPorts.next();
    _setTokenConsumptionRate(refineInPortContainer,containerPort,0);
  }
  Iterator refineInPorts=actor.inputPortList().iterator();
  while (refineInPorts.hasNext()) {
    IOPort refineInPort=(IOPort)refineInPorts.next();
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refineInPort.getFullName());
    Iterator inPortsOutside=refineInPort.deepConnectedInPortList().iterator();
    if (!inPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (inPortsOutside.hasNext()) {
      IOPort inputPortOutside=(IOPort)inPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ inputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)inputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineInPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ inputPortOutside.getFullName());
        int portRateToSet=SDFScheduler.getTokenConsumptionRate(refineInPort);
        SDFScheduler.setTokenConsumptionRate(inputPortOutside,portRateToSet);
      }
    }
  }
}"
75842,"private void _updateOutputTokenProductionRates(TypedCompositeActor actor) throws IllegalActionException {
  CompositeActor refineOutPortContainer=(CompositeActor)actor.getContainer();
  List containerPortList=refineOutPortContainer.outputPortList();
  Iterator containerPorts=containerPortList.iterator();
  while (containerPorts.hasNext()) {
    IOPort containerPort=(IOPort)containerPorts.next();
    _setTokenProductionRate(refineOutPortContainer,containerPort,0);
  }
  Iterator refineOutPorts=actor.outputPortList().iterator();
  while (refineOutPorts.hasNext()) {
    IOPort refineOutPort=(IOPort)refineOutPorts.next();
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refineOutPort.getFullName());
    Iterator outPortsOutside=refineOutPort.deepConnectedOutPortList().iterator();
    if (!outPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (outPortsOutside.hasNext()) {
      IOPort outputPortOutside=(IOPort)outPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ outputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)outputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineOutPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ outputPortOutside.getFullName());
        List listOfPorts=refineOutPort.insidePortList();
        int refineOutPortRate;
        if (listOfPorts.isEmpty()) {
          refineOutPortRate=0;
        }
 else {
          IOPort portWithRateInfo=(IOPort)listOfPorts.get(0);
          refineOutPortRate=_getTokenProductionRate(portWithRateInfo);
        }
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refineOutPortRate);
        _setTokenProductionRate(refineOutPortContainer,outputPortOutside,refineOutPortRate);
      }
    }
  }
}","private void _updateOutputTokenProductionRates(TypedCompositeActor actor) throws IllegalActionException {
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ actor.getName());
  CompositeActor refineOutPortContainer=(CompositeActor)actor.getContainer();
  List containerPortList=refineOutPortContainer.outputPortList();
  Iterator containerPorts=containerPortList.iterator();
  while (containerPorts.hasNext()) {
    IOPort containerPort=(IOPort)containerPorts.next();
    _setTokenProductionRate(refineOutPortContainer,containerPort,0);
  }
  Iterator refineOutPorts=actor.outputPortList().iterator();
  while (refineOutPorts.hasNext()) {
    IOPort refineOutPort=(IOPort)refineOutPorts.next();
    if (_debug_info) {
      System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ refineOutPort.getFullName()+ ""String_Node_Str""+ SDFScheduler.getTokenProductionRate(refineOutPort));
    }
    Iterator outPortsOutside=refineOutPort.deepConnectedOutPortList().iterator();
    if (!outPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (outPortsOutside.hasNext()) {
      IOPort outputPortOutside=(IOPort)outPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ outputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)outputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineOutPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ outputPortOutside.getFullName());
        int portRateToSet=SDFScheduler.getTokenProductionRate(refineOutPort);
        SDFScheduler.setTokenProductionRate(outputPortOutside,portRateToSet);
      }
    }
  }
}"
75843,"/** 
 * Initialize the firing of the director by resetting state variables and resetting all receivers to have unknown status.
 */
private void _initFiring(){
  _postfireReturns=false;
  _actorsAllowedToFire=null;
  _cachedAllInputsKnown=null;
  _cachedAllOutputsKnown=null;
  _lastNumOfActorsAllowedToFire=-1;
  _lastNumOfKnownReceivers=-1;
  _resetAllReceivers();
  _currentNumOfKnownReceivers=0;
}","/** 
 * Initialize the firing of the director by resetting state variables and resetting all receivers to have unknown status.
 */
private void _initFiring(){
  _postfireReturns=false;
  _actorsAllowedToFire=null;
  _actorsFired=null;
  _cachedAllInputsKnown=null;
  _cachedAllOutputsKnown=null;
  _lastNumOfActorsAllowedToFire=-1;
  _lastNumOfKnownReceivers=-1;
  _resetAllReceivers();
  _currentNumOfKnownReceivers=0;
}"
75844,"/** 
 * Return true if the specified actor is finished firing.  An actor  has finished firing if it is strict and has defined all of its outputs.
 */
private boolean _isFinishedFiring(Actor actor) throws IllegalActionException {
  if (_isNonStrict(actor))   return false;
  return _areAllOutputsKnown(actor);
}","/** 
 * Return true if the specified actor is finished firing.  An actor  has finished firing if it is strict and has defined all of its outputs.
 */
private boolean _isFinishedFiring(Actor actor) throws IllegalActionException {
  if (_isNonStrict(actor))   return false;
  if (_actorsFired == null)   return false;
  if (!_actorsFired.contains(actor))   return false;
  return _areAllOutputsKnown(actor);
}"
75845,"/** 
 * Fire the specified actor if the actor is ready to fire.  If the  prefire() method of this actor has not returned true in the current  iteration, the prefire() method will be called first.
 */
private void _fireActor(Actor actor) throws IllegalActionException {
  if (_isReadyToFire(actor)) {
    if (_isFiringAllowed(actor)) {
      if (!_isFinishedFiring(actor)) {
        _debug(""String_Node_Str"",_getNameOf(actor));
        boolean allInputsKnownBeforeFiring=_areAllInputsKnown(actor);
        actor.fire();
        if (allInputsKnownBeforeFiring)         _sendAbsentToAllUnknownOutputsOf(actor);
      }
    }
 else {
      _debug(""String_Node_Str"",_getNameOf(actor));
      if (actor.prefire()) {
        _doAllowFiringOf(actor);
        _fireActor(actor);
      }
    }
  }
}","/** 
 * Fire the specified actor if the actor is ready to fire.  If the  prefire() method of this actor has not returned true in the current  iteration, the prefire() method will be called first.
 */
private void _fireActor(Actor actor) throws IllegalActionException {
  if (_isReadyToFire(actor)) {
    if (_isFiringAllowed(actor)) {
      if (!_isFinishedFiring(actor)) {
        _debug(""String_Node_Str"",_getNameOf(actor));
        boolean allInputsKnownBeforeFiring=_areAllInputsKnown(actor);
        actor.fire();
        if (_actorsFired == null)         _actorsFired=new HashSet();
        _actorsFired.add(actor);
        if (allInputsKnownBeforeFiring)         _sendAbsentToAllUnknownOutputsOf(actor);
      }
    }
 else {
      _debug(""String_Node_Str"",_getNameOf(actor));
      if (actor.prefire()) {
        _doAllowFiringOf(actor);
        _fireActor(actor);
      }
    }
  }
}"
75846,"/** 
 * Read one RecordToken from the input port and send its fields to the output ports. If the input does not have a token, suspend firing and return.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (input.hasToken(0)) {
    RecordToken record=(RecordToken)input.get(0);
    Iterator labels=record.labelSet().iterator();
    while (labels.hasNext()) {
      String label=(String)labels.next();
      Token value=record.get(label);
      IOPort port=(IOPort)getPort(label);
      port.send(0,value);
    }
  }
}","/** 
 * Read one RecordToken from the input port and send its fields to the output ports. If the input does not have a token, suspend firing and return.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (input.hasToken(0)) {
    RecordToken record=(RecordToken)input.get(0);
    Iterator labels=record.labelSet().iterator();
    while (labels.hasNext()) {
      String label=(String)labels.next();
      Token value=record.get(label);
      IOPort port=(IOPort)getPort(label);
      if (port != null) {
        port.send(0,value);
      }
    }
  }
}"
75847,"/** 
 * Consume the inputs and produce the outputs of the FIR filter.
 * @exception IllegalActionException If parameter values are invalid,or if there is no director, or if runtime type conflicts occur.
 */
public void fire() throws IllegalActionException {
  int phase=_dec - _decPhase - 1;
  if (--_mostRecent < 0)   _mostRecent=_data.length - 1;
  _data[_mostRecent]=input.get(0);
  for (int inC=1; inC <= _dec; inC++) {
    while (phase < _interp) {
      _outToken=_zero;
      for (int i=0; i < _phaseLength; i++) {
        int tapsIndex=i * _interp + phase;
        int dataIndex=(_mostRecent + _dec - inC + i) % (_data.length);
        if (tapsIndex < _taps.length) {
          _tapItem=_taps[tapsIndex];
          _dataItem=_data[dataIndex];
          _dataItem=_tapItem.multiply(_dataItem);
          _outToken=_outToken.add(_dataItem);
        }
      }
      output.send(0,_outToken);
      phase+=_dec;
    }
    phase-=_interp;
  }
}","/** 
 * Consume the inputs and produce the outputs of the FIR filter.
 * @exception IllegalActionException If parameter values are invalid,or if there is no director, or if runtime type conflicts occur.
 */
public void fire() throws IllegalActionException {
  int phase=_dec - _decPhase - 1;
  for (int inC=1; inC <= _dec; inC++) {
    if (--_mostRecent < 0)     _mostRecent=_data.length - 1;
    _data[_mostRecent]=input.get(0);
    while (phase < _interp) {
      _outToken=_zero;
      for (int i=0; i < _phaseLength; i++) {
        int tapsIndex=i * _interp + phase;
        int dataIndex=(_mostRecent + _dec - inC + i) % (_data.length);
        if (tapsIndex < _taps.length) {
          _tapItem=_taps[tapsIndex];
          _dataItem=_data[dataIndex];
          _dataItem=_tapItem.multiply(_dataItem);
          _outToken=_outToken.add(_dataItem);
        }
      }
      output.send(0,_outToken);
      phase+=_dec;
    }
    phase-=_interp;
  }
}"
75848,"/** 
 * Reset the receiver by removing any contained token and setting the state of this receiver to be unknown.  Should be called only by the director.
 */
protected void reset(){
}","/** 
 * Reset the receiver by removing any contained token and setting the state of this receiver to be unknown.  Should be called only by the director.
 */
protected void reset(){
  if (isKnown()) {
    if (hasToken())     super.get();
    _known=false;
  }
}"
75849,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets up the type constraints.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Server newObject=(Server)(super.clone(workspace));
  ArrayType dataType=(ArrayType)newObject.data.getType();
  InequalityTerm elemTerm=dataType.getElementTypeTerm();
  newObject.output.setTypeAtLeast(elemTerm);
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets up the type constraints.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Server newObject=(Server)(super.clone(workspace));
  ArrayType dataType=(ArrayType)data.getType();
  InequalityTerm elemTerm=dataType.getElementTypeTerm();
  newObject.output.setTypeAtLeast(elemTerm);
  return newObject;
}"
75850,"/** 
 * Consume at most one input token from each input channel, and produce a token on the output port if it can be determined. If there is no input on any channel, then produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  BooleanToken value=null;
  BooleanToken in=null;
  for (int i=0; i < input.getWidth(); i++) {
    if (input.hasToken(i)) {
      in=(BooleanToken)(input.get(i));
      if (in != null)       value=_updateFunction(in,value);
    }
  }
  value=_nullifyIncompleteResults(value);
  if (value != null) {
    if (_negate)     value=value.not();
    output.send(0,(BooleanToken)value);
  }
}","/** 
 * Consume at most one input token from each input channel, and produce a token on the output port if it can be determined. If there is no input on any channel, then produce no output.
 * @exception IllegalActionException If there is no director.
 */
public void fire() throws IllegalActionException {
  BooleanToken value=null;
  BooleanToken in=null;
  for (int i=0; i < input.getWidth(); i++) {
    if (input.hasToken(i)) {
      in=(BooleanToken)(input.get(i));
      if (in != null)       value=_updateFunction(in,value);
    }
  }
  if (value != null)   value=_nullifyIncompleteResults(value);
  if (value != null) {
    if (_negate)     value=value.not();
    output.send(0,(BooleanToken)value);
  }
}"
75851,"protected void _updateInputTokenConsumptionRates(TypedCompositeActor actor) throws IllegalActionException {
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ actor.getFullName());
  Iterator refineInPorts=actor.inputPortList().iterator();
  ComponentEntity refineInPortContainer=(ComponentEntity)actor.getContainer();
  while (refineInPorts.hasNext()) {
    IOPort refineInPort=(IOPort)refineInPorts.next();
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + refineInPort.getFullName());
    Iterator inPortsOutside=refineInPort.deepConnectedInPortList().iterator();
    if (!inPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (inPortsOutside.hasNext()) {
      IOPort inputPortOutside=(IOPort)inPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ inputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)inputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineInPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ inputPortOutside.getFullName());
        List listOfPorts=refineInPort.insidePortList();
        int refineInPortRate;
        if (listOfPorts.isEmpty()) {
          refineInPortRate=1;
        }
 else {
          IOPort portWithRateInfo=(IOPort)listOfPorts.get(0);
          refineInPortRate=_getTokenConsumptionRate(portWithRateInfo);
        }
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + refineInPort.getFullName()+ ""String_Node_Str""+ _getTokenConsumptionRate(refineInPort));
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + refineInPortRate);
        _setTokenConsumptionRate(refineInPortContainer,inputPortOutside,refineInPortRate);
      }
    }
  }
}","protected void _updateInputTokenConsumptionRates(TypedCompositeActor actor) throws IllegalActionException {
  if (_debug_info)   System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ actor.getFullName());
  CompositeActor refineInPortContainer=(CompositeActor)actor.getContainer();
  List containerPortList=refineInPortContainer.inputPortList();
  Iterator containerPorts=containerPortList.iterator();
  while (containerPorts.hasNext()) {
    IOPort containerPort=(IOPort)containerPorts.next();
    _setTokenConsumptionRate(refineInPortContainer,containerPort,0);
  }
  Iterator refineInPorts=actor.inputPortList().iterator();
  while (refineInPorts.hasNext()) {
    IOPort refineInPort=(IOPort)refineInPorts.next();
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + refineInPort.getFullName());
    Iterator inPortsOutside=refineInPort.deepConnectedInPortList().iterator();
    if (!inPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (inPortsOutside.hasNext()) {
      IOPort inputPortOutside=(IOPort)inPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ inputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)inputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineInPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ inputPortOutside.getFullName());
        List listOfPorts=refineInPort.insidePortList();
        int refineInPortRate;
        if (listOfPorts.isEmpty()) {
          refineInPortRate=0;
        }
 else {
          IOPort portWithRateInfo=(IOPort)listOfPorts.get(0);
          refineInPortRate=_getTokenConsumptionRate(portWithRateInfo);
        }
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + refineInPort.getFullName()+ ""String_Node_Str""+ _getTokenConsumptionRate(refineInPort));
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + refineInPortRate);
        _setTokenConsumptionRate(refineInPortContainer,inputPortOutside,refineInPortRate);
      }
    }
  }
}"
75852,"protected void _updateOutputTokenProductionRates(TypedCompositeActor actor) throws IllegalActionException {
  Iterator refineOutPorts=actor.outputPortList().iterator();
  ComponentEntity refineOutPortContainer=(ComponentEntity)actor.getContainer();
  while (refineOutPorts.hasNext()) {
    IOPort refineOutPort=(IOPort)refineOutPorts.next();
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + refineOutPort.getFullName());
    Iterator outPortsOutside=refineOutPort.deepConnectedOutPortList().iterator();
    if (!outPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (outPortsOutside.hasNext()) {
      IOPort outputPortOutside=(IOPort)outPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ outputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)outputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineOutPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ outputPortOutside.getFullName());
        List listOfPorts=refineOutPort.insidePortList();
        int refineOutPortRate;
        if (listOfPorts.isEmpty()) {
          refineOutPortRate=1;
        }
 else {
          IOPort portWithRateInfo=(IOPort)listOfPorts.get(0);
          refineOutPortRate=_getTokenProductionRate(portWithRateInfo);
        }
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + refineOutPortRate);
        _setTokenProductionRate(refineOutPortContainer,outputPortOutside,refineOutPortRate);
      }
    }
  }
}","protected void _updateOutputTokenProductionRates(TypedCompositeActor actor) throws IllegalActionException {
  CompositeActor refineOutPortContainer=(CompositeActor)actor.getContainer();
  List containerPortList=refineOutPortContainer.outputPortList();
  Iterator containerPorts=containerPortList.iterator();
  while (containerPorts.hasNext()) {
    IOPort containerPort=(IOPort)containerPorts.next();
    _setTokenProductionRate(refineOutPortContainer,containerPort,0);
  }
  Iterator refineOutPorts=actor.outputPortList().iterator();
  while (refineOutPorts.hasNext()) {
    IOPort refineOutPort=(IOPort)refineOutPorts.next();
    if (_debug_info)     System.out.println(getName() + ""String_Node_Str"" + refineOutPort.getFullName());
    Iterator outPortsOutside=refineOutPort.deepConnectedOutPortList().iterator();
    if (!outPortsOutside.hasNext()) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
    while (outPortsOutside.hasNext()) {
      IOPort outputPortOutside=(IOPort)outPortsOutside.next();
      if (_debug_info)       System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ outputPortOutside.getFullName());
      ComponentEntity thisPortContainer=(ComponentEntity)outputPortOutside.getContainer();
      if (thisPortContainer.getFullName() == refineOutPortContainer.getFullName()) {
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + ""String_Node_Str""+ outputPortOutside.getFullName());
        List listOfPorts=refineOutPort.insidePortList();
        int refineOutPortRate;
        if (listOfPorts.isEmpty()) {
          refineOutPortRate=0;
        }
 else {
          IOPort portWithRateInfo=(IOPort)listOfPorts.get(0);
          refineOutPortRate=_getTokenProductionRate(portWithRateInfo);
        }
        if (_debug_info)         System.out.println(getName() + ""String_Node_Str"" + refineOutPortRate);
        _setTokenProductionRate(refineOutPortContainer,outputPortOutside,refineOutPortRate);
      }
    }
  }
}"
75853,"/** 
 * Check if the value of this token is strictly less than that of the argument token.
 * @param arg A ScalarToken.
 * @return A BooleanToken with value true if this token is strictlyless than the argument.
 * @exception IllegalActionException If the type of the argument tokenis incomparable with the type of this token.
 */
public BooleanToken isLessThan(ScalarToken arg) throws IllegalActionException {
  int typeInfo=TypeLattice.compare(this,arg);
  if (typeInfo == CPO.INCOMPARABLE) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ arg.getType());
  }
  if (typeInfo == CPO.LOWER) {
    return arg.isLessThan(this);
  }
  ScalarToken intArg=arg;
  if (typeInfo == CPO.HIGHER) {
    intArg=(ScalarToken)convert(arg);
  }
  if (_value < intArg.intValue()) {
    return new BooleanToken(true);
  }
  return new BooleanToken(false);
}","/** 
 * Check if the value of this token is strictly less than that of the argument token.
 * @param arg A ScalarToken.
 * @return A BooleanToken with value true if this token is strictlyless than the argument.
 * @exception IllegalActionException If the type of the argument tokenis incomparable with the type of this token.
 */
public BooleanToken isLessThan(ScalarToken arg) throws IllegalActionException {
  int typeInfo=TypeLattice.compare(this,arg);
  if (typeInfo == CPO.INCOMPARABLE) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ arg.getType());
  }
  if (typeInfo == CPO.LOWER) {
    return arg.isLessThan(this).not();
  }
  ScalarToken intArg=arg;
  if (typeInfo == CPO.HIGHER) {
    intArg=(ScalarToken)convert(arg);
  }
  if (_value < intArg.intValue()) {
    return new BooleanToken(true);
  }
  return new BooleanToken(false);
}"
75854,"public void insertClock() throws ChangeFailedException {
  ChangeRequest change=new ChangeRequest(_top,""String_Node_Str""){
    public void _execute() throws ChangeFailedException {
      try {
        _clock.output.unlinkAll();
        _rec.input.unlinkAll();
        Clock clock2=new Clock(_top,""String_Node_Str"");
        clock2.values.setExpression(""String_Node_Str"");
        clock2.offsets.setExpression(""String_Node_Str"");
        clock2.period.setExpression(""String_Node_Str"");
        Merge merge=new Merge(_top,""String_Node_Str"");
        _top.connect(_clock.output,merge.input);
        _top.connect(clock2.output,merge.input);
        _top.connect(merge.output,_rec.input);
        _rec.input.createReceivers();
      }
 catch (      IllegalActionException ex) {
        throw new ChangeFailedException(this,ex);
      }
catch (      NameDuplicationException ex) {
        throw new ChangeFailedException(this,ex);
      }
    }
  }
;
  manager.requestChange(change);
}","public void insertClock(){
  ChangeRequest change=new ChangeRequest(_top,""String_Node_Str""){
    public void _execute() throws IllegalActionException, NameDuplicationException {
      _clock.output.unlinkAll();
      _rec.input.unlinkAll();
      Clock clock2=new Clock(_top,""String_Node_Str"");
      clock2.values.setExpression(""String_Node_Str"");
      clock2.offsets.setExpression(""String_Node_Str"");
      clock2.period.setExpression(""String_Node_Str"");
      Merge merge=new Merge(_top,""String_Node_Str"");
      _top.connect(_clock.output,merge.input);
      _top.connect(clock2.output,merge.input);
      _top.connect(merge.output,_rec.input);
      _rec.input.createReceivers();
      _director.invalidateSchedule();
    }
  }
;
  _top.requestChange(change);
}"
75855,"public void _execute() throws ChangeFailedException {
  try {
    _clock.output.unlinkAll();
    _rec.input.unlinkAll();
    Clock clock2=new Clock(_top,""String_Node_Str"");
    clock2.values.setExpression(""String_Node_Str"");
    clock2.offsets.setExpression(""String_Node_Str"");
    clock2.period.setExpression(""String_Node_Str"");
    Merge merge=new Merge(_top,""String_Node_Str"");
    _top.connect(_clock.output,merge.input);
    _top.connect(clock2.output,merge.input);
    _top.connect(merge.output,_rec.input);
    _rec.input.createReceivers();
  }
 catch (  IllegalActionException ex) {
    throw new ChangeFailedException(this,ex);
  }
catch (  NameDuplicationException ex) {
    throw new ChangeFailedException(this,ex);
  }
}","public void _execute() throws IllegalActionException, NameDuplicationException {
  _clock.output.unlinkAll();
  _rec.input.unlinkAll();
  Clock clock2=new Clock(_top,""String_Node_Str"");
  clock2.values.setExpression(""String_Node_Str"");
  clock2.offsets.setExpression(""String_Node_Str"");
  clock2.period.setExpression(""String_Node_Str"");
  Merge merge=new Merge(_top,""String_Node_Str"");
  _top.connect(_clock.output,merge.input);
  _top.connect(clock2.output,merge.input);
  _top.connect(merge.output,_rec.input);
  _rec.input.createReceivers();
  _director.invalidateSchedule();
}"
75856,"protected void _createModel() throws IllegalActionException {
}","protected void _createModel() throws IllegalActionException {
  QuadArray plane=new QuadArray(4,GeometryArray.COORDINATES | QuadArray.NORMALS | GeometryArray.TEXTURE_COORDINATE_2);
  Point3f p=new Point3f(-1.0f,1.0f,0.0f);
  plane.setCoordinate(0,p);
  p.set(-1.0f,-1.0f,0.0f);
  plane.setCoordinate(1,p);
  p.set(1.0f,-1.0f,0.0f);
  plane.setCoordinate(2,p);
  p.set(1.0f,1.0f,0.0f);
  plane.setCoordinate(3,p);
  Point2f[] qq=new Point2f[4];
  qq[0]=new Point2f(0.0f,1.0f);
  qq[1]=new Point2f(0.0f,0.0f);
  qq[2]=new Point2f(1.0f,0.0f);
  qq[3]=new Point2f(1.0f,1.0f);
  plane.setTextureCoordinate(0,0,new TexCoord2f(qq[0]));
  plane.setTextureCoordinate(0,1,new TexCoord2f(qq[1]));
  plane.setTextureCoordinate(0,2,new TexCoord2f(qq[2]));
  plane.setTextureCoordinate(0,3,new TexCoord2f(qq[3]));
  Appearance appear=new Appearance();
  String fileName=(String)((StringToken)filename.getToken()).stringValue();
  TextureLoader loader=new TextureLoader(fileName,((ViewScreen)_root).getCanvas());
  ImageComponent2D image=loader.getImage();
  System.out.println(""String_Node_Str"" + image);
  if (image == null) {
    System.out.println(""String_Node_Str"" + filename);
    Texture2D texture=new Texture2D(Texture.BASE_LEVEL,Texture.RGBA,image.getWidth(),image.getHeight());
    texture.setImage(0,image);
    appear.setTexture(texture);
    appear.setTransparencyAttributes(new TransparencyAttributes(TransparencyAttributes.FASTEST,0.1f));
    top=new BranchGroup();
    _containedNode=new Shape3D(plane,appear);
    top.addChild(_containedNode);
  }
}"
75857,"/** 
 * Return the function result.
 * @return A Type.
 */
public Object getValue(){
  TypedIOPort recordInput=(TypedIOPort)_updater.getPort(""String_Node_Str"");
  Type inputType=recordInput.getType();
  if (inputType == BaseType.UNKNOWN) {
    return BaseType.UNKNOWN;
  }
  if (!(inputType instanceof RecordType)) {
    throw new InvalidStateException(_updater,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ inputType);
  }
  RecordType recordType=(RecordType)inputType;
  Map outputMap=new HashMap();
  Set recordLabels=recordType.labelSet();
  Iterator iter=recordLabels.iterator();
  while (iter.hasNext()) {
    String label=(String)iter.next();
    Type type=recordType.get(label);
    outputMap.put(label,type);
  }
  List inputPorts=inputPortList();
  iter=inputPorts.iterator();
  TypedIOPort recordPort=(TypedIOPort)_updater.getPort(""String_Node_Str"");
  while (iter.hasNext()) {
    TypedIOPort port=(TypedIOPort)iter.next();
    if (port != recordPort) {
      outputMap.put(port.getName(),port.getType());
    }
  }
  Object[] labelsObj=outputMap.keySet().toArray();
  String[] labels=new String[labelsObj.length];
  Type[] types=new Type[labelsObj.length];
  for (int i=0; i < labels.length; i++) {
    labels[i]=(String)labelsObj[i];
    types[i]=(Type)outputMap.get(labels[i]);
  }
  return new RecordType(labels,types);
}","/** 
 * Return the function result.
 * @return A Type.
 */
public Object getValue(){
  TypedIOPort recordInput=(TypedIOPort)_updater.getPort(""String_Node_Str"");
  Type inputType=recordInput.getType();
  if (inputType == BaseType.UNKNOWN) {
    return BaseType.UNKNOWN;
  }
  if (!(inputType instanceof RecordType)) {
    throw new InvalidStateException(_updater,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ inputType);
  }
  RecordType recordType=(RecordType)inputType;
  Map outputMap=new HashMap();
  Set recordLabels=recordType.labelSet();
  Iterator iter=recordLabels.iterator();
  while (iter.hasNext()) {
    String label=(String)iter.next();
    Type type=recordType.get(label);
    outputMap.put(label,type);
  }
  List inputPorts=_updater.inputPortList();
  iter=inputPorts.iterator();
  while (iter.hasNext()) {
    TypedIOPort port=(TypedIOPort)iter.next();
    if (port != recordInput) {
      outputMap.put(port.getName(),port.getType());
    }
  }
  Object[] labelsObj=outputMap.keySet().toArray();
  String[] labels=new String[labelsObj.length];
  Type[] types=new Type[labelsObj.length];
  for (int i=0; i < labels.length; i++) {
    labels[i]=(String)labelsObj[i];
    types[i]=(Type)outputMap.get(labels[i]);
  }
  return new RecordType(labels,types);
}"
75858,"/** 
 * Return all the InequalityTerms for all input ports in an array.
 * @return An array of InequalityTerm.
 */
public InequalityTerm[] getVariables(){
  List inputPorts=inputPortList();
  Object[] portsObj=inputPorts.toArray();
  InequalityTerm[] variables=new InequalityTerm[portsObj.length];
  for (int i=0; i < variables.length; i++) {
    TypedIOPort port=(TypedIOPort)portsObj[i];
    variables[i]=port.getTypeTerm();
  }
  return variables;
}","/** 
 * Return all the InequalityTerms for all input ports in an array.
 * @return An array of InequalityTerm.
 */
public InequalityTerm[] getVariables(){
  List inputPorts=_updater.inputPortList();
  Object[] portsObj=inputPorts.toArray();
  InequalityTerm[] variables=new InequalityTerm[portsObj.length];
  for (int i=0; i < variables.length; i++) {
    TypedIOPort port=(TypedIOPort)portsObj[i];
    variables[i]=port.getTypeTerm();
  }
  return variables;
}"
75859,"protected void _createModel() throws IllegalActionException {
  QuadArray plane=new QuadArray(4,GeometryArray.COORDINATES | QuadArray.NORMALS | GeometryArray.TEXTURE_COORDINATE_2);
  Point3f p=new Point3f(-1.0f,1.0f,0.0f);
  plane.setCoordinate(0,p);
  p.set(-1.0f,-1.0f,0.0f);
  plane.setCoordinate(1,p);
  p.set(1.0f,-1.0f,0.0f);
  plane.setCoordinate(2,p);
  p.set(1.0f,1.0f,0.0f);
  plane.setCoordinate(3,p);
  Point2f[] qq=new Point2f[4];
  qq[0]=new Point2f(0.0f,1.0f);
  qq[1]=new Point2f(0.0f,0.0f);
  qq[2]=new Point2f(1.0f,0.0f);
  qq[3]=new Point2f(1.0f,1.0f);
  plane.setTextureCoordinate(0,0,new TexCoord2f(qq[0]));
  plane.setTextureCoordinate(0,1,new TexCoord2f(qq[1]));
  plane.setTextureCoordinate(0,2,new TexCoord2f(qq[2]));
  plane.setTextureCoordinate(0,3,new TexCoord2f(qq[3]));
  Appearance appear=new Appearance();
  String fileName=(String)((StringToken)filename.getToken()).stringValue();
  TextureLoader loader=new TextureLoader(fileName,((ViewScreen)_root).getCanvas());
  ImageComponent2D image=loader.getImage();
  System.out.println(""String_Node_Str"" + image);
  if (image == null) {
    System.out.println(""String_Node_Str"" + filename);
    Texture2D texture=new Texture2D(Texture.BASE_LEVEL,Texture.RGBA,image.getWidth(),image.getHeight());
    texture.setImage(0,image);
    appear.setTexture(texture);
    appear.setTransparencyAttributes(new TransparencyAttributes(TransparencyAttributes.FASTEST,0.1f));
    top=new BranchGroup();
    _containedNode=new Shape3D(plane,appear);
    top.addChild(_containedNode);
  }
}","protected void _createModel() throws IllegalActionException {
  QuadArray plane=new QuadArray(4,GeometryArray.COORDINATES | QuadArray.NORMALS | GeometryArray.TEXTURE_COORDINATE_2);
  Point3f p=new Point3f(-1.0f,1.0f,0.0f);
  plane.setCoordinate(0,p);
  p.set(-1.0f,-1.0f,0.0f);
  plane.setCoordinate(1,p);
  p.set(1.0f,-1.0f,0.0f);
  plane.setCoordinate(2,p);
  p.set(1.0f,1.0f,0.0f);
  plane.setCoordinate(3,p);
  Point2f[] qq=new Point2f[4];
  qq[0]=new Point2f(0.0f,1.0f);
  qq[1]=new Point2f(0.0f,0.0f);
  qq[2]=new Point2f(1.0f,0.0f);
  qq[3]=new Point2f(1.0f,1.0f);
  plane.setTextureCoordinate(0,0,new TexCoord2f(qq[0]));
  plane.setTextureCoordinate(0,1,new TexCoord2f(qq[1]));
  plane.setTextureCoordinate(0,2,new TexCoord2f(qq[2]));
  plane.setTextureCoordinate(0,3,new TexCoord2f(qq[3]));
  Appearance appear=new Appearance();
  String fileName=(String)((StringToken)filename.getToken()).stringValue();
  TextureLoader loader=new TextureLoader(fileName,((ViewScreen)_root).getCanvas());
  ImageComponent2D image=loader.getImage();
  System.out.println(""String_Node_Str"" + image);
  if (image == null) {
    System.out.println(""String_Node_Str"" + filename);
  }
  Texture2D texture=new Texture2D(Texture.BASE_LEVEL,Texture.RGBA,image.getWidth(),image.getHeight());
  texture.setImage(0,image);
  appear.setTexture(texture);
  appear.setTransparencyAttributes(new TransparencyAttributes(TransparencyAttributes.FASTEST,0.1f));
  top=new BranchGroup();
  _containedNode=new Shape3D(plane,appear);
  top.addChild(_containedNode);
}"
75860,"/** 
 * Override the base class to reinitialize the state if either the <i>step</i> or the <i>init</i> parameter is changed.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException Not thrown in this base class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == step) {
    _step=step.getToken();
    _stateToken=init.getToken();
  }
 else   if (attribute == init) {
    _stateToken=init.getToken();
  }
}","/** 
 * Override the base class to reinitialize the state if either the <i>step</i> or the <i>init</i> parameter is changed.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException Not thrown in this base class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == step) {
    _step=step.getToken();
    _stateToken=init.getToken();
  }
 else   if (attribute == init) {
    _stateToken=init.getToken();
  }
 else   super.attributeChanged(attribute);
}"
75861,"/** 
 * Invoke a specified number of iterations of this actor. Each iteration updates the state of the actor by adding the value of the <i>step</i> parameter to the state and sending the value of the state to the output. The iteration count is also incremented by the value of <i>count</i>, and if the result is greater than or equal to <i>firingCountLimit</i> then return STOP_ITERATING. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, if the maximum iteration count has been reached, return STOP_ITERATING.
 * @exception IllegalActionException If iterating cannot beperformed.
 */
public int iterate(int count) throws IllegalActionException {
  super.iterate(count);
  if (count > _resultArray.length) {
    _resultArray=new Token[count];
  }
  for (int i=0; i < count; i++) {
    _resultArray[i]=_stateToken;
    try {
      _stateToken=_stateToken.add(_step);
    }
 catch (    IllegalActionException ex) {
      throw new InternalErrorException(ex.getMessage());
    }
  }
  output.send(0,_resultArray,count);
  if (_firingCountLimit != 0) {
    _iterationCount+=count;
    if (_iterationCount >= _firingCountLimit) {
      return STOP_ITERATING;
    }
  }
  return COMPLETED;
}","/** 
 * Invoke a specified number of iterations of this actor. Each iteration updates the state of the actor by adding the value of the <i>step</i> parameter to the state and sending the value of the state to the output. The iteration count is also incremented by the value of <i>count</i>, and if the result is greater than or equal to <i>firingCountLimit</i> then return STOP_ITERATING. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, if the maximum iteration count has been reached, return STOP_ITERATING.
 * @exception IllegalActionException If iterating cannot beperformed.
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _resultArray.length) {
    _resultArray=new Token[count];
  }
  for (int i=0; i < count; i++) {
    _resultArray[i]=_stateToken;
    try {
      _stateToken=_stateToken.add(_step);
    }
 catch (    IllegalActionException ex) {
      throw new InternalErrorException(ex.getMessage());
    }
  }
  output.send(0,_resultArray,count);
  if (_firingCountLimit != 0) {
    _iterationCount+=count;
    if (_iterationCount >= _firingCountLimit) {
      return STOP_ITERATING;
    }
  }
  return COMPLETED;
}"
75862,"/** 
 * Return true if get() will succeed in returning a token the given number of times.
 * @return A boolean indicating whether there are the given number oftokens in this receiver.
 * @exception IllegalArgumentException If the argument is lessthan one.  This is a runtime exception, so it need not be declared explicitly by the caller.
 */
public boolean hasToken(int tokens) throws IllegalArgumentException {
  if (tokens < 1)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  return _queue.size() >= tokens;
}","/** 
 * Return true if get() will succeed in returning a token the given number of times.
 * @return A boolean indicating whether there are the given number oftokens in this receiver.
 * @exception IllegalArgumentException If the argument is lessthan one.  This is a runtime exception, so it need not be declared explicitly by the caller.
 */
public boolean hasToken(int tokens) throws IllegalArgumentException {
  if (tokens < 0)   throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  return _queue.size() >= tokens;
}"
75863,"/** 
 * Return the function result.
 * @return A Type.
 */
public Object getValue(){
  Type inputType=_port.getType();
  if (inputType == BaseType.COMPLEX) {
    return BaseType.DOUBLE;
  }
 else   if (inputType == BaseType.COMPLEX_MATRIX) {
    return BaseType.INT_MATRIX;
  }
 else {
    return inputType;
  }
}","/** 
 * Return the function result.
 * @return A Type.
 */
public Object getValue(){
  Type inputType=_port.getType();
  if (inputType == BaseType.COMPLEX) {
    return BaseType.DOUBLE;
  }
 else   if (inputType == BaseType.COMPLEX_MATRIX) {
    return BaseType.DOUBLE_MATRIX;
  }
 else {
    return inputType;
  }
}"
75864,"/** 
 * Initialize/Reinitialize audio resources. First stop playback, and. Then reread all parameters, and start audio capture. <p> This method is synchronized since it is not safe to call LiveSound methods while this method is executing.
 * @exception IllegalActionException If there is a problem initializingaudio capture.
 */
private synchronized void _initializeCapture() throws IllegalActionException, IOException {
  if (_debugInfo) {
    System.out.println(""String_Node_Str"");
  }
  if (LiveSound.isCaptureActive()) {
    LiveSound.stopCapture(this);
  }
  int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
  int bitsPerSampleInt=((IntToken)bitsPerSample.getToken()).intValue();
  int channelsInt=((IntToken)channels.getToken()).intValue();
  if (LiveSound.getSampleRate() != sampleRateInt) {
    LiveSound.setSampleRate(sampleRateInt);
  }
  if (LiveSound.getBitsPerSample() != bitsPerSampleInt) {
    LiveSound.setBitsPerSample(bitsPerSampleInt);
  }
  if (LiveSound.getChannels() != channelsInt) {
    LiveSound.setChannels(channelsInt);
  }
  if (LiveSound.getBufferSize() != 4096) {
    LiveSound.setBufferSize(4096);
  }
  if (LiveSound.getTransferSize() != 128) {
    LiveSound.setTransferSize(128);
  }
  try {
    LiveSound.startCapture(this);
  }
 catch (  IOException ex) {
    throw new IllegalActionException(""String_Node_Str"" + ex);
  }
}","/** 
 * Initialize audio resources. Reread all parameters, and start  audio capture. <p> This method is synchronized since it is not safe to call LiveSound methods while this method is executing.
 * @exception IllegalActionException If there is a problem initializingaudio capture.
 */
private synchronized void _initializeCapture() throws IllegalActionException, IOException {
  if (_debugInfo) {
    System.out.println(""String_Node_Str"");
  }
  if (LiveSound.isCaptureActive()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
  int bitsPerSampleInt=((IntToken)bitsPerSample.getToken()).intValue();
  int channelsInt=((IntToken)channels.getToken()).intValue();
  if (LiveSound.getSampleRate() != sampleRateInt) {
    LiveSound.setSampleRate(sampleRateInt);
  }
  if (LiveSound.getBitsPerSample() != bitsPerSampleInt) {
    LiveSound.setBitsPerSample(bitsPerSampleInt);
  }
  if (LiveSound.getChannels() != channelsInt) {
    LiveSound.setChannels(channelsInt);
  }
  if (LiveSound.getBufferSize() != 4096) {
    LiveSound.setBufferSize(4096);
  }
  if (LiveSound.getTransferSize() != 128) {
    LiveSound.setTransferSize(128);
  }
  try {
    LiveSound.startCapture(this);
  }
 catch (  IOException ex) {
    throw new IllegalActionException(""String_Node_Str"" + ex);
  }
}"
75865,"/** 
 * Initialize/Reinitialize audio resources. First stop playback, and close any open sound files, if necessary. Then reread all parameters, create a new SoundPlayback object, and start playback of audio. <p> This method is synchronized since it is not safe to call SoundPlayback methods while this method is executing.
 * @exception IllegalActionException If there is a problem initializingaudio playback.
 */
private synchronized void _initializePlayback() throws IllegalActionException, IOException {
  if (_debugging)   _debug(""String_Node_Str"");
  if (LiveSound.isPlaybackActive()) {
    LiveSound.stopPlayback(this);
  }
  if (_debugInfo) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _putSampleSize);
  }
  for (int i=0; i < _channels; i++) {
    _audioPutArray[i]=new double[_putSampleSize];
  }
  int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
  int bitsPerSampleInt=((IntToken)bitsPerSample.getToken()).intValue();
  int channelsInt=((IntToken)channels.getToken()).intValue();
  if (LiveSound.getSampleRate() != sampleRateInt) {
    LiveSound.setSampleRate(sampleRateInt);
  }
  if (LiveSound.getBitsPerSample() != bitsPerSampleInt) {
    LiveSound.setBitsPerSample(bitsPerSampleInt);
  }
  if (LiveSound.getChannels() != channelsInt) {
    LiveSound.setChannels(channelsInt);
  }
  if (LiveSound.getBufferSize() != 4096) {
    LiveSound.setBufferSize(4096);
  }
  if (LiveSound.getTransferSize() != _putSampleSize) {
    LiveSound.setTransferSize(_putSampleSize);
  }
  LiveSound.startPlayback(this);
  _curElement=0;
}","/** 
 * Initialize/Reinitialize audio resources. First stop playback, and close any open sound files, if necessary. Then reread all parameters, create a new SoundPlayback object, and start playback of audio. <p> This method is synchronized since it is not safe to call SoundPlayback methods while this method is executing.
 * @exception IllegalActionException If there is a problem initializingaudio playback.
 */
private synchronized void _initializePlayback() throws IllegalActionException, IOException {
  if (_debugging)   _debug(""String_Node_Str"");
  if (LiveSound.isPlaybackActive()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (_debugInfo) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _putSampleSize);
  }
  for (int i=0; i < _channels; i++) {
    _audioPutArray[i]=new double[_putSampleSize];
  }
  int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
  int bitsPerSampleInt=((IntToken)bitsPerSample.getToken()).intValue();
  int channelsInt=((IntToken)channels.getToken()).intValue();
  if (LiveSound.getSampleRate() != sampleRateInt) {
    LiveSound.setSampleRate(sampleRateInt);
  }
  if (LiveSound.getBitsPerSample() != bitsPerSampleInt) {
    LiveSound.setBitsPerSample(bitsPerSampleInt);
  }
  if (LiveSound.getChannels() != channelsInt) {
    LiveSound.setChannels(channelsInt);
  }
  if (LiveSound.getBufferSize() != 4096) {
    LiveSound.setBufferSize(4096);
  }
  if (LiveSound.getTransferSize() != _putSampleSize) {
    LiveSound.setTransferSize(_putSampleSize);
  }
  LiveSound.startPlayback(this);
  _curElement=0;
}"
75866,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ArrayAppend newObject=(ArrayAppend)(super.clone(workspace));
  newObject.output.setTypeAtLeast(input);
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ArrayAppend newObject=(ArrayAppend)(super.clone(workspace));
  newObject.output.setTypeAtLeast(newObject.input);
  return newObject;
}"
75867,"/** 
 * Invoke a specified number of iterations of this actor. Each iteration updates the state of the actor by adding the value of the <i>step</i> parameter to the state and sending the value of the state to the output. The iteration count is also incremented by the value of <i>count</i>, and if the result is greater than or equal to <i>firingCountLimit</i> then return STOP_ITERATING. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, if the maximum iteration count has been reached, return STOP_ITERATING.
 * @exception IllegalActionException If iterating cannot beperformed.
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _resultArray.length) {
    _resultArray=new Token[count];
  }
  for (int i=0; i < count; i++) {
    _resultArray[i]=_stateToken;
    try {
      _stateToken=_stateToken.add(_step);
    }
 catch (    IllegalActionException ex) {
      throw new InternalErrorException(ex.getMessage());
    }
  }
  output.send(0,_resultArray,count);
  if (_firingCountLimit != 0) {
    _iterationCount+=count;
    if (_iterationCount >= _firingCountLimit) {
      return STOP_ITERATING;
    }
  }
  return COMPLETED;
}","/** 
 * Invoke a specified number of iterations of this actor. Each iteration updates the state of the actor by adding the value of the <i>step</i> parameter to the state and sending the value of the state to the output. The iteration count is also incremented by the value of <i>count</i>, and if the result is greater than or equal to <i>firingCountLimit</i> then return STOP_ITERATING. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, if the maximum iteration count has been reached, return STOP_ITERATING.
 * @exception IllegalActionException If iterating cannot beperformed.
 */
public int iterate(int count) throws IllegalActionException {
  super.iterate(count);
  if (count > _resultArray.length) {
    _resultArray=new Token[count];
  }
  for (int i=0; i < count; i++) {
    _resultArray[i]=_stateToken;
    try {
      _stateToken=_stateToken.add(_step);
    }
 catch (    IllegalActionException ex) {
      throw new InternalErrorException(ex.getMessage());
    }
  }
  output.send(0,_resultArray,count);
  if (_firingCountLimit != 0) {
    _iterationCount+=count;
    if (_iterationCount >= _firingCountLimit) {
      return STOP_ITERATING;
    }
  }
  return COMPLETED;
}"
75868,"/** 
 * Start audio playback. The specified object will be given an exclusive lock on the audio playback resources until the stopPlayback() method is called with the same object reference. After this method returns, the putSamples() method may be repeatedly invoked (using the object reference as a parameter) to playback audio. <p> If audio playback is already active, then an exception will occur.
 * @param consumer The object to be given exclusive accessto the playback audio resources.
 * @exception IllegalStateException If this method is calledwhile audio playback is already active.
 */
public static void startPlayback(Object producer) throws IOException, IllegalStateException {
  _startPlayback();
  _playbackIsActive=true;
}","/** 
 * Start audio playback. The specified object will be given an exclusive lock on the audio playback resources until the stopPlayback() method is called with the same object reference. After this method returns, the putSamples() method may be repeatedly invoked (using the object reference as a parameter) to playback audio. <p> If audio playback is already active, then an exception will occur.
 * @param consumer The object to be given exclusive accessto the playback audio resources.
 * @exception IllegalStateException If this method is calledwhile audio playback is already active.
 */
public static void startPlayback(Object producer) throws IOException, IllegalStateException {
  if (_debug) {
    System.out.println(""String_Node_Str"");
  }
  _startPlayback();
  _playbackIsActive=true;
}"
75869,"/** 
 * Play an array of audio samples. There will be a delay before the audio data is actually heard, since the audio data in <i>samplesArray</i> is queued to an internal audio buffer. The size of the internal buffer is set by the setTransferSize() method. A lower bound on the latency is given by (<i>bufferSize</i> / <i>sampleRate</i>) seconds. This method should be invoked often enough to prevent underflow of the internal audio buffer. Underflow is undesirable since it will cause audible gaps in audio playback, but no exception or error condition will occur. If the caller attempts to write more data than can be written, this method blocks until the data can be written to the internal audio buffer. <p> The samples should be in the range (-1,1). Samples that are outside ths range will be hard-clipped so that they fall within this range. <p> The first index of the specified array represents the channel number (0 for first channel, 1 for second channel, etc.). The number of channels is set by the setChannels() method. The second index represents the sample index within a channel. For example, putSamplesArray[n][m] contains the (m+1)th sample of the (n+1)th channel. samplesArray should be a rectangular array such that samplesArray.length() gives the number of channels and samplesArray[n].length() is equal to <i>samplesArray</i>, for all channels n. This is not actually checked, however. <p> Note that only the object with the exclusive lock on the playback audio resources is allowed to invoked this method. An exception will occur if the specifed object does not have the lock on the playback audio resources.
 * @param producer The object that has an exclusive lock onthe playback audio resources.
 * @param samplesArray A two dimensional array containingthe samples to play or write to a file.
 * @exception IOException If there is a problem playing audio.
 * @exception IllegalStateException If audio playback is currentlyinactive. That is, If startPlayback() has not yet been called or if stopPlayback() has already been called.
 */
public static void putSamples(Object producer,double[][] samplesArray) throws IOException, IllegalStateException {
  _data=_doubleArrayToByteArray(samplesArray,_bytesPerSample,_channels);
  _sourceLine.write(_data,0,_transferSize * _frameSizeInBytes);
}","/** 
 * Play an array of audio samples. There will be a delay before the audio data is actually heard, since the audio data in <i>samplesArray</i> is queued to an internal audio buffer. The size of the internal buffer is set by the setTransferSize() method. A lower bound on the latency is given by (<i>bufferSize</i> / <i>sampleRate</i>) seconds. This method should be invoked often enough to prevent underflow of the internal audio buffer. Underflow is undesirable since it will cause audible gaps in audio playback, but no exception or error condition will occur. If the caller attempts to write more data than can be written, this method blocks until the data can be written to the internal audio buffer. <p> The samples should be in the range (-1,1). Samples that are outside ths range will be hard-clipped so that they fall within this range. <p> The first index of the specified array represents the channel number (0 for first channel, 1 for second channel, etc.). The number of channels is set by the setChannels() method. The second index represents the sample index within a channel. For example, putSamplesArray[n][m] contains the (m+1)th sample of the (n+1)th channel. samplesArray should be a rectangular array such that samplesArray.length() gives the number of channels and samplesArray[n].length() is equal to <i>samplesArray</i>, for all channels n. This is not actually checked, however. <p> Note that only the object with the exclusive lock on the playback audio resources is allowed to invoked this method. An exception will occur if the specifed object does not have the lock on the playback audio resources.
 * @param producer The object that has an exclusive lock onthe playback audio resources.
 * @param samplesArray A two dimensional array containingthe samples to play or write to a file.
 * @exception IOException If there is a problem playing audio.
 * @exception IllegalStateException If audio playback is currentlyinactive. That is, If startPlayback() has not yet been called or if stopPlayback() has already been called.
 */
public static void putSamples(Object producer,double[][] samplesArray) throws IOException, IllegalStateException {
  if (_debug) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _transferSize);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _bytesPerSample);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _channels);
  }
  _data=_doubleArrayToByteArray(samplesArray,_bytesPerSample,_channels);
  if (_debug) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _data.length);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _transferSize);
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + _frameSizeInBytes);
  }
  _sourceLine.write(_data,0,_transferSize * _frameSizeInBytes);
  if (_debug) {
    System.out.println(""String_Node_Str"");
  }
}"
75870,"/** 
 * Get the array length (in samples per channel) to use for capturing and playing samples via the putSamples() and getSamples() methods. This method gets the size of the 2nd dimension of the 2-dimensional array used by the putSamples() and getSamples() methods. This method returns the value that was set by the  setTransferSize(). If setTransferSize() was not invoked, the default value of 64 is returns. <p> This method should only be called while audio capture and playback are inactive. Otherwise an exception will occur.
 * @return The size of the 2nd dimension of the 2-dimensional array used by the putSamples() and getSamples() methods.
 */
public static int getTransferSize(){
  return _transferSize;
}","/** 
 * Get the array length (in samples per channel) to use for capturing and playing samples via the putSamples() and getSamples() methods. This method gets the size of the 2nd dimension of the 2-dimensional array used by the putSamples() and getSamples() methods. This method returns the value that was set by the  setTransferSize(). If setTransferSize() was not invoked, the default value of 128 is returns. <p> This method should only be called while audio capture and playback are inactive. Otherwise an exception will occur.
 * @return The size of the 2nd dimension of the 2-dimensional array used by the putSamples() and getSamples() methods.
 */
public static int getTransferSize(){
  return _transferSize;
}"
75871,"/** 
 * Stop audio playback. If the specified object has the lock on audio playback when this method is invoked, then stop audio playback. Otherwise an exception will occur.
 * @param producer The object that held on exclusivelock on the playback audio resources when this method was invoked.
 * @exception IllegalStateException If the specifiedobject did not hold an exclusive lock on the playback audio resources when this method was invoked.
 */
public static void stopPlayback(Object producer) throws IOException, IllegalStateException {
  if (_sourceLine != null) {
    _sourceLine.drain();
    _sourceLine.stop();
    _sourceLine.close();
  }
  _sourceLine=null;
  _playbackIsActive=false;
}","/** 
 * Stop audio playback. If the specified object has the lock on audio playback when this method is invoked, then stop audio playback. Otherwise an exception will occur.
 * @param producer The object that held on exclusivelock on the playback audio resources when this method was invoked.
 * @exception IllegalStateException If the specifiedobject did not hold an exclusive lock on the playback audio resources when this method was invoked.
 */
public static void stopPlayback(Object producer) throws IOException, IllegalStateException {
  if (_debug) {
    System.out.println(""String_Node_Str"");
  }
  if (_sourceLine != null) {
    _sourceLine.drain();
    _sourceLine.stop();
    _sourceLine.close();
  }
  _sourceLine=null;
  _playbackIsActive=false;
}"
75872,"/** 
 * Set the number of bits per sample to use for audio capture and playback. Allowable values include 8 and 16 bits. If this method is not invoked, then the default value of 8 bits is used. <p> This method should only be called while audio capture and playback are inactive. Otherwise an exception will occur.
 * @param bitsPerSample The number of bits per sample.
 * @exception IllegalStateException If this method is calledwhile audio capture or playback are active.
 */
public static void setBitsPerSample(int bitsPerSample) throws IllegalStateException {
  if ((_captureIsActive) || (_playbackIsActive)) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    _bitsPerSample=bitsPerSample;
  }
}","/** 
 * Set the number of bits per sample to use for audio capture and playback. Allowable values include 8 and 16 bits. If this method is not invoked, then the default value of 16 bits is used. <p> This method should only be called while audio capture and playback are inactive. Otherwise an exception will occur.
 * @param bitsPerSample The number of bits per sample.
 * @exception IllegalStateException If this method is calledwhile audio capture or playback are active.
 */
public static void setBitsPerSample(int bitsPerSample) throws IllegalStateException {
  if ((_captureIsActive) || (_playbackIsActive)) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    _bitsPerSample=bitsPerSample;
  }
}"
75873,"/** 
 * Set the array length (in samples per channel) to use for capturing and playing samples via the putSamples() and getSamples() methods. This method sets the size of the 2nd dimension of the 2-dimensional array used by the putSamples() and getSamples() methods. If this method is not invoked, the default value of 64 is used. <p> This method should only be called while audio capture and playback are inactive. Otherwise an exception will occur.
 * @param transferSize The  size of the 2nd dimension of the 2-dimensional array used by the putSamples() and  getSamples() methods
 * @exception IllegalStateException If this method is calledwhile audio capture or playback are active.
 */
public static void setTransferSize(int transferSize) throws IllegalStateException {
  if (_debug) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + transferSize);
  }
  if ((_captureIsActive) || (_playbackIsActive)) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    _transferSize=transferSize;
  }
}","/** 
 * Set the array length (in samples per channel) to use for capturing and playing samples via the putSamples() and getSamples() methods. This method sets the size of the 2nd dimension of the 2-dimensional array used by the putSamples() and getSamples() methods. If this method is not invoked, the default value of 128 is used. <p> This method should only be called while audio capture and playback are inactive. Otherwise an exception will occur.
 * @param transferSize The  size of the 2nd dimension of the 2-dimensional array used by the putSamples() and  getSamples() methods
 * @exception IllegalStateException If this method is calledwhile audio capture or playback are active.
 */
public static void setTransferSize(int transferSize) throws IllegalStateException {
  if (_debug) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + transferSize);
  }
  if ((_captureIsActive) || (_playbackIsActive)) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    _transferSize=transferSize;
  }
}"
75874,"/** 
 * Return the number of bits per audio sample, which is set by the setBitsPerSample() method. The default value of this parameter is 8 bits.
 * @return The sample size in bits. 
 */
public static int getBitsPerSample(){
  return _bitsPerSample;
}","/** 
 * Return the number of bits per audio sample, which is set by the setBitsPerSample() method. The default value of this parameter is 16 bits.
 * @return The sample size in bits. 
 */
public static int getBitsPerSample(){
  return _bitsPerSample;
}"
75875,"private static void _startPlayback() throws IOException {
  boolean signed=true;
  boolean bigEndian=true;
  AudioFormat format=new AudioFormat((float)_sampleRate,_bitsPerSample,_channels,signed,bigEndian);
  _frameSizeInBytes=format.getFrameSize();
  DataLine.Info sourceInfo=new DataLine.Info(SourceDataLine.class,format,AudioSystem.NOT_SPECIFIED);
  try {
    _sourceLine=(SourceDataLine)AudioSystem.getLine(sourceInfo);
    _sourceLine.open(format,_bufferSize * _frameSizeInBytes);
  }
 catch (  LineUnavailableException ex) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + ex);
  }
  _data=new byte[_transferSize * _frameSizeInBytes * _channels];
  _sourceLine.start();
}","private static void _startPlayback() throws IOException {
  boolean signed=true;
  boolean bigEndian=true;
  AudioFormat format=new AudioFormat((float)_sampleRate,_bitsPerSample,_channels,signed,bigEndian);
  _frameSizeInBytes=format.getFrameSize();
  DataLine.Info sourceInfo=new DataLine.Info(SourceDataLine.class,format,AudioSystem.NOT_SPECIFIED);
  try {
    _sourceLine=(SourceDataLine)AudioSystem.getLine(sourceInfo);
    _sourceLine.open(format,_bufferSize * _frameSizeInBytes);
  }
 catch (  LineUnavailableException ex) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + ex);
  }
  _data=new byte[_transferSize * _frameSizeInBytes * _channels];
  _bytesPerSample=_bitsPerSample / 8;
  _sourceLine.start();
}"
75876,"/** 
 * Return an array of captured audio samples. This method should be repeatedly called to obtain audio data. The returned audio samples will have values in the range [-1, 1], regardless of the audio bit resolution (bits per sample). When capturing from the computer's audio input port (mic or line-in), this method should be called often enough to prevent overflow of the internal audio buffer. If overflow occurs, some audio data will be lost but no exception or other error condition will occur. If the audio data is not yet available, then this method will block until the data is available. When capturing from a sound file, it is not possible for overflow to occur. <p> The array size is set by the <i>getSamplesSize</i> parameter in the constructor. For the case where audio is captured from the computer's audio-in port (mic or line-in), this method should be called often enough to prevent overflow of the internal audio buffer, the size of which is set in the constructor.
 * @return Two dimensional array of captured audio samples.Return null if end of audio file is reached A null return value is only possible when capturing from a sound file. The first index represents the channel number (0 for first channel, 1 for second channel, etc.). The second index represents the sample index within a channel. For example, <i>returned array</i>[n][m] contains the (m+1)th sample of the (n+1)th channel. For each channel, n, the length of <i>returned array</i>[n] is equal to <i>getSamplesSize</i>.
 * @exception IOException If there is a problem capturing audio.
 * @exception IllegalStateException If audio capture is currentlyinactive. That is, If startCapture() has not yet been called or if stopCapture() has already been called.
 */
public double[][] getSamples() throws IOException, IllegalStateException {
  if (_isAudioCaptureActive == true) {
    int numBytesRead;
    if (_isRealTime == true) {
      numBytesRead=_targetLine.read(_data,0,_productionRate * _frameSizeInBytes);
    }
 else {
      numBytesRead=_properFormatAudioInputStream.read(_data);
    }
    if (numBytesRead == _data.length) {
      _audioInDoubleArray=_byteArrayToDoubleArray(_data,_bytesPerSample,_channels);
      return _audioInDoubleArray;
    }
 else     if (numBytesRead != _data.length) {
      return null;
    }
 else     if (numBytesRead == -1) {
      return null;
    }
    return null;
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
}","/** 
 * Return an array of captured audio samples. This method should be repeatedly called to obtain audio data. The returned audio samples will have values in the range [-1, 1], regardless of the audio bit resolution (bits per sample). When capturing from the computer's audio input port (mic or line-in), this method should be called often enough to prevent overflow of the internal audio buffer. If overflow occurs, some audio data will be lost but no exception or other error condition will occur. If the audio data is not yet available, then this method will block until the data is available. When capturing from a sound file, it is not possible for overflow to occur. <p> The array size is set by the <i>getSamplesSize</i> parameter in the constructor. For the case where audio is captured from the computer's audio-in port (mic or line-in), this method should be called often enough to prevent overflow of the internal audio buffer, the size of which is set in the constructor.
 * @return Two dimensional array of captured audio samples.Return null if end of audio file is reached. A null return value is only possible when capturing from a sound file. The first index represents the channel number (0 for first channel, 1 for second channel, etc.). The second index represents the sample index within a channel. For example, <i>returned array</i>[n][m] contains the (m+1)th sample of the (n+1)th channel. For each channel, n, the length of <i>returned array</i>[n] is equal to <i>getSamplesSize</i>.
 * @exception IOException If there is a problem capturing audio.
 * @exception IllegalStateException If audio capture is currentlyinactive. That is, If startCapture() has not yet been called or if stopCapture() has already been called.
 */
public double[][] getSamples() throws IOException, IllegalStateException {
  if (_isAudioCaptureActive == true) {
    int numBytesRead;
    if (_isRealTime == true) {
      numBytesRead=_targetLine.read(_data,0,_productionRate * _frameSizeInBytes);
    }
 else {
      numBytesRead=_properFormatAudioInputStream.read(_data);
    }
    if (numBytesRead == _data.length) {
      _audioInDoubleArray=_byteArrayToDoubleArray(_data,_bytesPerSample,_channels);
      return _audioInDoubleArray;
    }
 else     if (numBytesRead != _data.length) {
      _audioInDoubleArray=_byteArrayToDoubleArray(_data,_bytesPerSample,_channels);
      return _audioInDoubleArray;
    }
 else     if (numBytesRead == -1) {
      return null;
    }
    return null;
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  }
}"
75877,"/** 
 * Stop capturing audio. This method should be called when no more calls to getSamples(). are required, so that the system resources involved in the audio capture may be freed.
 * @exception IOException If there is a problem closing theaudio resources.
 */
public void stopCapture() throws IOException {
  _isAudioCaptureActive=false;
  if (_audioInputStream != null) {
    _audioInputStream.close();
  }
  if (_properFormatAudioInputStream != null) {
    _properFormatAudioInputStream.close();
  }
  if (_targetLine != null) {
    if (_targetLine.isOpen() == true) {
      _targetLine.stop();
      _targetLine.close();
      _targetLine=null;
    }
  }
}","/** 
 * Stop capturing audio. This method should be called when no more calls to getSamples(). are required, so that the system resources involved in the audio capture may be freed.
 * @exception IOException If there is a problem closing theaudio resources.
 */
public void stopCapture() throws IOException {
  if (_isAudioCaptureActive == true) {
    if (_audioInputStream != null) {
      _audioInputStream.close();
      _audioInputStream=null;
    }
    if (_properFormatAudioInputStream != null) {
      _properFormatAudioInputStream.close();
      _properFormatAudioInputStream=null;
    }
    if (_targetLine != null) {
      if (_targetLine.isOpen() == true) {
        _targetLine.stop();
        _targetLine.close();
        _targetLine=null;
      }
    }
  }
  _isAudioCaptureActive=false;
}"
75878,"/** 
 * Stop playing/writing audio. This method should be called when no more calls to putSamples(). are required, so that the system resources involved in the audio playback may be freed. <p> If the ""write audio data to file"" constructor was used, then the sound file specified by the constructor is saved and closed.
 * @exception IOException If there is a problem closing theaudio resources, or if the ""write audio data to file"" constructor was used  and the sound file has an unsupported format.
 */
public void stopPlayback() throws IOException {
  _isAudioPlaybackActive=false;
  if (_playbackMode == ""String_Node_Str"") {
    if (_sourceLine != null) {
      _sourceLine.drain();
      _sourceLine.stop();
      _sourceLine.close();
    }
    _sourceLine=null;
  }
 else   if (_playbackMode == ""String_Node_Str"") {
    _stopPlaybackToFile();
  }
 else {
  }
}","/** 
 * Stop playing/writing audio. This method should be called when no more calls to putSamples(). are required, so that the system resources involved in the audio playback may be freed. <p> If the ""write audio data to file"" constructor was used, then the sound file specified by the constructor is saved and closed.
 * @exception IOException If there is a problem closing theaudio resources, or if the ""write audio data to file"" constructor was used  and the sound file has an unsupported format.
 */
public void stopPlayback() throws IOException {
  if (_isAudioPlaybackActive == true) {
    if (_playbackMode == ""String_Node_Str"") {
      if (_sourceLine != null) {
        _sourceLine.drain();
        _sourceLine.stop();
        _sourceLine.close();
      }
      _sourceLine=null;
    }
 else     if (_playbackMode == ""String_Node_Str"") {
      _stopPlaybackToFile();
    }
 else {
    }
  }
  _isAudioPlaybackActive=false;
}"
75879,"/** 
 * Send a token to all connected receivers. Tokens are in general immutable, so each receiver is given a reference to the same token and no clones are made. The transfer is accomplished by calling getRemoteReceivers() to determine the number of channels with valid receivers and then calling send on the appropriate channels. It would probably be faster to call put() directly on the receivers. If there are no destination receivers, then nothing is sent. If the port is not connected to anything, or receivers have not been created in the remote port, then just return. This method is read-synchronized on the workspace.
 * @param token The token to send
 * @exception IllegalActionException If the port is not an output.
 * @exception NoRoomException If a send to one of the channels throwsit.
 */
public void broadcast(Token token) throws IllegalActionException, NoRoomException {
  try {
    _workspace.getReadAccess();
    Receiver farReceivers[][]=getRemoteReceivers();
    if (farReceivers == null) {
      return;
    }
    for (int j=0; j < farReceivers.length; j++) {
      send(j,token);
    }
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Send the specified portion of a token array to all receivers connected to this port. The first <i>vectorLength</i> tokens of the token array are sent. <p> Tokens are in general immutable, so each receiver is given a reference to the same token and no clones are made. If the port is not connected to anything, or receivers have not been created in the remote port, or the channel index is out of range, or the port is not an output port, then just silently return.  This behavior makes it easy to leave output ports unconnected when you are not interested in the output.  The transfer is accomplished by calling the vectorized put() method of the remote receivers. If the port is not connected to anything, or receivers have not been created in the remote port, then just return. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a put, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling put.
 * @param tokenArray The token array to send
 * @param vectorLength The number of elements of of the tokenarray to send.
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException Not thrown in this base class.
 */
public void broadcast(Token[] tokenArray,int vectorLength) throws IllegalActionException, NoRoomException {
  Receiver[][] farReceivers;
  try {
    _workspace.getReadAccess();
    farReceivers=getRemoteReceivers();
    if (farReceivers == null) {
      return;
    }
  }
  finally {
    _workspace.doneReading();
  }
  try {
    for (int i=0; i < farReceivers.length; i++) {
      if (farReceivers[i] == null)       continue;
      for (int j=0; j < farReceivers[i].length; j++) {
        farReceivers[i][j].putArray(tokenArray,vectorLength);
      }
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
}"
75880,"/** 
 * Given a CompileUnitNode, return the complete package name.
 * @param loadedAST The CompileUnitNode of the class
 * @return The full package name of the class
 */
public static String getPackageName(CompileUnitNode loadedAST){
  StringBuffer packageBuffer=new StringBuffer(((UserTypeDeclNode)loadedAST.getDefTypes().get(0)).getName().getIdent());
  NameNode packageNode=(NameNode)loadedAST.getPkg();
  while (packageNode.getQualifier() != AbsentTreeNode.instance) {
    packageBuffer.insert(0,packageNode.getIdent() + '.');
    packageNode=(NameNode)packageNode.getQualifier();
  }
  packageBuffer.insert(0,packageNode.getIdent() + '.');
  return packageBuffer.toString();
}","/** 
 * Given a CompileUnitNode, return the complete package name. If no package name is associated with the CompileUnitNode, then return the default package name for code generation. 
 * @param loadedAST The CompileUnitNode of the class
 * @return The full package name of the class
 */
public static String getPackageName(CompileUnitNode loadedAST){
  StringBuffer packageBuffer=new StringBuffer(((UserTypeDeclNode)loadedAST.getDefTypes().get(0)).getName().getIdent());
  Object packageReturnValue=loadedAST.getPkg();
  if (!(packageReturnValue instanceof NameNode))   return (JavaStaticSemanticConstants.DEFAULT_PACKAGE_NAME);
 else {
    NameNode packageNode=(NameNode)packageReturnValue;
    while (packageNode.getQualifier() != AbsentTreeNode.instance) {
      packageBuffer.insert(0,packageNode.getIdent() + '.');
      packageNode=(NameNode)packageNode.getQualifier();
    }
    packageBuffer.insert(0,packageNode.getIdent() + '.');
    return packageBuffer.toString();
  }
}"
75881,"/** 
 * Connect the given edge to the given tail node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param tail The new tail for the edge, which is assumed tobe a location representing a port, a port or a vertex.
 */
public void setTail(final Object edge,final Object newLinkTail){
  final Link link=(Link)edge;
  final NamedObj linkHead=(NamedObj)link.getHead();
  final NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final CompositeEntity container=(CompositeEntity)getChangeRequestParent(getToplevel());
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(container,moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(container,moml,failmoml,linkHead,(NamedObj)newLinkTail);
  }
 catch (  Exception ex) {
    _linkSet.remove(link);
    link.setHead(null);
    link.setTail(null);
    dispatchGraphEvent(new GraphEvent(PtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,container,moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setTail(newLinkTail);
      if (relationNameToAdd != null) {
        ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
        link.setRelation(relation);
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new LinkChangeListener(link,container,failmoml));
  container.requestChange(request);
}","/** 
 * Connect the given edge to the given tail node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param tail The new tail for the edge, which is assumed tobe a location representing a port, a port or a vertex.
 */
public void setTail(final Object edge,final Object newLinkTail){
  final Link link=(Link)edge;
  final NamedObj linkHead=(NamedObj)link.getHead();
  final NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final CompositeEntity container=(CompositeEntity)getChangeRequestParent(getToplevel());
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(container,moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(container,moml,failmoml,linkHead,(NamedObj)newLinkTail);
  }
 catch (  Exception ex) {
    _linkSet.remove(link);
    link.setHead(null);
    link.setTail(null);
    dispatchGraphEvent(new GraphEvent(PtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,container,moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setTail(newLinkTail);
      if (relationNameToAdd != null) {
        ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
        if (relation == null)         throw new InternalErrorException(""String_Node_Str"" + relationNameToAdd + ""String_Node_Str""+ container);
        link.setRelation(relation);
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new LinkChangeListener(link,container,failmoml));
  container.requestChange(request);
}"
75882,"protected void _execute() throws Exception {
  super._execute();
  link.setTail(newLinkTail);
  if (relationNameToAdd != null) {
    ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
    link.setRelation(relation);
  }
 else {
    link.setRelation(null);
  }
}","protected void _execute() throws Exception {
  super._execute();
  link.setTail(newLinkTail);
  if (relationNameToAdd != null) {
    ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
    if (relation == null)     throw new InternalErrorException(""String_Node_Str"" + relationNameToAdd + ""String_Node_Str""+ container);
    link.setRelation(relation);
  }
 else {
    link.setRelation(null);
  }
}"
75883,"/** 
 * Connect the given edge to the given head node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param head The new head for the edge, which is assumed tobe a location representing a port, a port or a vertex.	 
 */
public void setHead(final Object edge,final Object newLinkHead){
  final Link link=(Link)edge;
  final NamedObj linkHead=(NamedObj)link.getHead();
  final NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final CompositeEntity container=(CompositeEntity)getChangeRequestParent(getToplevel());
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(container,moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(container,moml,failmoml,(NamedObj)newLinkHead,linkTail);
  }
 catch (  Exception ex) {
    _linkSet.remove(link);
    link.setHead(null);
    link.setTail(null);
    dispatchGraphEvent(new GraphEvent(PtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,container,moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setHead(newLinkHead);
      if (relationNameToAdd != null) {
        ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
        link.setRelation(relation);
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new LinkChangeListener(link,container,failmoml));
  container.requestChange(request);
}","/** 
 * Connect the given edge to the given head node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param head The new head for the edge, which is assumed tobe a location representing a port, a port or a vertex.	 
 */
public void setHead(final Object edge,final Object newLinkHead){
  final Link link=(Link)edge;
  final NamedObj linkHead=(NamedObj)link.getHead();
  final NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final CompositeEntity container=(CompositeEntity)getChangeRequestParent(getToplevel());
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(container,moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(container,moml,failmoml,(NamedObj)newLinkHead,linkTail);
  }
 catch (  Exception ex) {
    _linkSet.remove(link);
    link.setHead(null);
    link.setTail(null);
    dispatchGraphEvent(new GraphEvent(PtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,container,moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setHead(newLinkHead);
      if (relationNameToAdd != null) {
        ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
        if (relation == null)         throw new InternalErrorException(""String_Node_Str"" + relationNameToAdd + ""String_Node_Str""+ container);
        link.setRelation(relation);
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new LinkChangeListener(link,container,failmoml));
  container.requestChange(request);
}"
75884,"/** 
 * Append moml to the given buffer that connects a link with the given head, tail, and relation.  Names in the returned moml will be relative to the given container.  This may require adding an anonymous relation to the ptolemy model.  If this is required, the name of the relation <b>relative to the toplevel object of this graph model</b> is returned. If no relation need be added, then null is returned.
 */
private String _linkMoML(NamedObj container,StringBuffer moml,StringBuffer failmoml,NamedObj linkHead,NamedObj linkTail) throws Exception {
  if (linkHead != null && linkTail != null) {
    NamedObj head=(NamedObj)getSemanticObject(linkHead);
    NamedObj tail=(NamedObj)getSemanticObject(linkTail);
    if (head instanceof ComponentPort && tail instanceof ComponentPort) {
      ComponentPort headPort=(ComponentPort)head;
      ComponentPort tailPort=(ComponentPort)tail;
      String relationName=getToplevel().uniqueName(""String_Node_Str"");
      if (getToplevel() != container) {
        String contextString=""String_Node_Str"" + getToplevel().getName(container) + ""String_Node_Str"";
        moml.append(contextString);
        failmoml.append(contextString);
      }
      moml.append(""String_Node_Str"" + relationName + ""String_Node_Str"");
      moml.append(""String_Node_Str"" + headPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      moml.append(""String_Node_Str"" + tailPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + headPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + tailPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + relationName + ""String_Node_Str"");
      if (getToplevel() != container) {
        moml.append(""String_Node_Str"");
        failmoml.append(""String_Node_Str"");
      }
      return relationName;
    }
 else     if (head instanceof ComponentPort && linkTail instanceof Vertex) {
      moml.append(""String_Node_Str"" + head.getName(container) + ""String_Node_Str""+ tail.getName(container)+ ""String_Node_Str"");
      return tail.getName(container);
    }
 else     if (tail instanceof ComponentPort && linkHead instanceof Vertex) {
      moml.append(""String_Node_Str"" + tail.getName(container) + ""String_Node_Str""+ head.getName(container)+ ""String_Node_Str"");
      return head.getName(container);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + head + ""String_Node_Str""+ tail);
    }
  }
 else {
    return null;
  }
}","/** 
 * Append moml to the given buffer that connects a link with the given head, tail, and relation.  Names in the returned moml will be relative to the given container.  This may require adding an anonymous relation to the ptolemy model.   If no relation need be added, then null is returned.
 */
private String _linkMoML(NamedObj container,StringBuffer moml,StringBuffer failmoml,NamedObj linkHead,NamedObj linkTail) throws Exception {
  if (linkHead != null && linkTail != null) {
    NamedObj head=(NamedObj)getSemanticObject(linkHead);
    NamedObj tail=(NamedObj)getSemanticObject(linkTail);
    if (head instanceof ComponentPort && tail instanceof ComponentPort) {
      ComponentPort headPort=(ComponentPort)head;
      ComponentPort tailPort=(ComponentPort)tail;
      String relationName=getToplevel().uniqueName(""String_Node_Str"");
      if (getToplevel() != container) {
        String contextString=""String_Node_Str"" + getToplevel().getName(container) + ""String_Node_Str"";
        moml.append(contextString);
        failmoml.append(contextString);
      }
      moml.append(""String_Node_Str"" + relationName + ""String_Node_Str"");
      moml.append(""String_Node_Str"" + headPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      moml.append(""String_Node_Str"" + tailPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + headPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + tailPort.getName(getToplevel()) + ""String_Node_Str""+ relationName+ ""String_Node_Str"");
      failmoml.append(""String_Node_Str"" + relationName + ""String_Node_Str"");
      if (getToplevel() != container) {
        moml.append(""String_Node_Str"");
        failmoml.append(""String_Node_Str"");
      }
      if (getToplevel() != container) {
        return getToplevel().getName(container) + ""String_Node_Str"" + relationName;
      }
 else {
        return relationName;
      }
    }
 else     if (head instanceof ComponentPort && linkTail instanceof Vertex) {
      moml.append(""String_Node_Str"" + head.getName(container) + ""String_Node_Str""+ tail.getName(container)+ ""String_Node_Str"");
      return tail.getName(container);
    }
 else     if (tail instanceof ComponentPort && linkHead instanceof Vertex) {
      moml.append(""String_Node_Str"" + tail.getName(container) + ""String_Node_Str""+ head.getName(container)+ ""String_Node_Str"");
      return head.getName(container);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + head + ""String_Node_Str""+ tail);
    }
  }
 else {
    return null;
  }
}"
75885,"/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator ainputports=a.inputPortList().iterator();
      while (ainputports.hasNext()) {
        IOPort ainputport=(IOPort)ainputports.next();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator aoutputports=a.outputPortList().iterator();
      while (aoutputports.hasNext()) {
        IOPort aOutputPort=(IOPort)aoutputports.next();
        int count=getTokenInitProduction(aOutputPort);
        if (_debugging)         _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
    CompositeActor ca=(CompositeActor)(dir.getContainer());
    Iterator inputPorts=ca.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      _simulateExternalInputs(port,actorList,waitingTokens);
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      if (_debugging)       _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        int tokencount[]=(int[])waitingTokens.get(port);
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getFullName());
          _debug(""String_Node_Str"" + tokencount.length);
        }
        for (int channel=0; channel < tokencount.length; channel++)         if (_debugging)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
        Iterator actorsLeft=readyToScheduleActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
        _debug(""String_Node_Str"");
        actorsLeft=unscheduledActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      if (_debugging) {
        _debug(""String_Node_Str"" + currentActor.getName());
      }
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Iterator aOutputPorts=((Actor)currentActor).outputPortList().iterator();
      while (aOutputPorts.hasNext()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.next();
        int count=getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,unscheduledActorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      if (_debugging) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          _debug(""String_Node_Str"" + currentActor);
          while (readyToScheduleActorList.remove(currentActor))           ;
          while (unscheduledActorList.remove(currentActor))           ;
          _debug(""String_Node_Str"");
          Iterator actorsLeft=readyToScheduleActorList.iterator();
          while (actorsLeft.hasNext()) {
            Entity e=(Entity)actorsLeft.next();
            if (_debugging)             _debug(e.getFullName());
          }
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1 && unscheduledActorList.contains(currentActor))           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    if (_debugging)     _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  if (_debugging) {
    _debug(""String_Node_Str"");
    while (eschedule.hasNext()) {
      _debug(((ComponentEntity)eschedule.next()).toString());
    }
  }
  return newSchedule;
}","/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator ainputports=a.inputPortList().iterator();
      while (ainputports.hasNext()) {
        IOPort ainputport=(IOPort)ainputports.next();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator aoutputports=a.outputPortList().iterator();
      while (aoutputports.hasNext()) {
        IOPort aOutputPort=(IOPort)aoutputports.next();
        int count=getTokenInitProduction(aOutputPort);
        if (_debugging)         _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
    CompositeActor ca=(CompositeActor)(dir.getContainer());
    Iterator inputPorts=ca.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      _simulateExternalInputs(port,actorList,waitingTokens);
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      if (_debugging)       _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        int tokencount[]=(int[])waitingTokens.get(port);
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getFullName());
          _debug(""String_Node_Str"" + tokencount.length);
        }
        for (int channel=0; channel < tokencount.length; channel++)         if (_debugging)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
        Iterator actorsLeft=readyToScheduleActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
        _debug(""String_Node_Str"");
        actorsLeft=unscheduledActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      if (_debugging) {
        _debug(""String_Node_Str"" + currentActor.getName());
      }
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Iterator aOutputPorts=((Actor)currentActor).outputPortList().iterator();
      while (aOutputPorts.hasNext()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.next();
        int count=getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,unscheduledActorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      if (_debugging) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          if (_debugging) {
            _debug(""String_Node_Str"" + currentActor);
          }
          while (readyToScheduleActorList.remove(currentActor))           ;
          while (unscheduledActorList.remove(currentActor))           ;
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          Iterator actorsLeft=readyToScheduleActorList.iterator();
          while (actorsLeft.hasNext()) {
            Entity e=(Entity)actorsLeft.next();
            if (_debugging)             _debug(e.getFullName());
          }
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1 && unscheduledActorList.contains(currentActor))           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    if (_debugging)     _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  if (_debugging) {
    _debug(""String_Node_Str"");
    while (eschedule.hasNext()) {
      _debug(((ComponentEntity)eschedule.next()).toString());
    }
  }
  return newSchedule;
}"
75886,"/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>No integer solution exists for the balance equations. <li>The graph contains cycles without delays (deadlock). <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return An Enumeration of the deeply contained opaque entitiesin the firing order.
 * @exception NotScheduleableException If the CompositeActor is notschedulable.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  LinkedList AllActors=new LinkedList();
  Iterator entities=ca.deepEntityList().iterator();
  while (entities.hasNext()) {
    ComponentEntity a=(ComponentEntity)entities.next();
    if (a instanceof Actor)     AllActors.addLast(a);
  }
  Map firings=null;
  try {
    firings=_solveBalanceEquations(AllActors);
    List deadActors=new LinkedList();
    Iterator allActor=AllActors.iterator();
    while (allActor.hasNext()) {
      ComponentEntity anActor=(ComponentEntity)allActor.next();
      Fraction theFiring=(Fraction)firings.get(anActor);
      _debug(""String_Node_Str"" + anActor.getName());
      _debug(""String_Node_Str"" + theFiring.getNumerator());
      if (theFiring.getNumerator() == 0) {
        _debug(""String_Node_Str"");
        deadActors.add(anActor);
      }
    }
    Iterator removeIt=deadActors.iterator();
    while (removeIt.hasNext()) {
      ComponentEntity actorToRemove=(ComponentEntity)removeIt.next();
      _debug(""String_Node_Str"" + actorToRemove.getName() + ""String_Node_Str"");
      firings.remove(actorToRemove);
      AllActors.remove(actorToRemove);
    }
    _debug(""String_Node_Str"" + firings.toString());
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
  }
  _normalizeFirings(firings);
  _setFiringVector(firings);
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(firings.toString());
  }
  LinkedList result=_scheduleConnectedActors(AllActors);
  _setFiringVector(firings);
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(firings.toString());
  }
  try {
    _setContainerRates();
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  setValid(true);
  return Collections.enumeration(result);
}","/** 
 * Return the scheduling sequence.  An exception will be thrown if the graph is not schedulable.  This occurs in the following circumstances: <ul> <li>The graph is not a connected graph. <li>No integer solution exists for the balance equations. <li>The graph contains cycles without delays (deadlock). <li>Multiple output ports are connected to the same broadcast relation. (equivalent to a non-deterministic merge) </ul>
 * @return An Enumeration of the deeply contained opaque entitiesin the firing order.
 * @exception NotScheduleableException If the CompositeActor is notschedulable.
 */
protected Enumeration _schedule() throws NotSchedulableException {
  StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
  CompositeActor ca=(CompositeActor)(dir.getContainer());
  LinkedList AllActors=new LinkedList();
  Iterator entities=ca.deepEntityList().iterator();
  while (entities.hasNext()) {
    ComponentEntity a=(ComponentEntity)entities.next();
    if (a instanceof Actor)     AllActors.addLast(a);
  }
  Map firings=null;
  try {
    firings=_solveBalanceEquations(AllActors);
    List deadActors=new LinkedList();
    Iterator allActor=AllActors.iterator();
    while (allActor.hasNext()) {
      ComponentEntity anActor=(ComponentEntity)allActor.next();
      Fraction theFiring=(Fraction)firings.get(anActor);
      if (_debugging) {
        _debug(""String_Node_Str"" + anActor.getName());
        _debug(""String_Node_Str"" + theFiring.getNumerator());
      }
      if (theFiring.getNumerator() == 0) {
        if (_debugging) {
          _debug(""String_Node_Str"" + ""String_Node_Str"");
        }
        deadActors.add(anActor);
      }
    }
    Iterator removeIt=deadActors.iterator();
    while (removeIt.hasNext()) {
      ComponentEntity actorToRemove=(ComponentEntity)removeIt.next();
      if (_debugging) {
        _debug(""String_Node_Str"" + actorToRemove.getName() + ""String_Node_Str"");
      }
      firings.remove(actorToRemove);
      AllActors.remove(actorToRemove);
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + firings.toString());
    }
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
  }
  _normalizeFirings(firings);
  _setFiringVector(firings);
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(firings.toString());
  }
  LinkedList result=_scheduleConnectedActors(AllActors);
  _setFiringVector(firings);
  if (_debugging) {
    _debug(""String_Node_Str"");
    _debug(firings.toString());
  }
  try {
    _setContainerRates();
  }
 catch (  IllegalActionException ex) {
    throw new NotSchedulableException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  setValid(true);
  return Collections.enumeration(result);
}"
75887,"/** 
 * Connect the given edge to the given tail node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param tail The new tail for the edge, which is assumed tobe a location representing a port, a port or a vertex.
 */
public void setTail(final Object edge,final Object newLinkTail){
  final Link link=(Link)edge;
  final NamedObj linkHead=(NamedObj)link.getHead();
  final NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final CompositeEntity container=(CompositeEntity)getChangeRequestParent(getToplevel());
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(container,moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(container,moml,failmoml,linkHead,(NamedObj)newLinkTail);
  }
 catch (  Exception ex) {
    _linkSet.remove(link);
    link.setHead(null);
    link.setTail(null);
    dispatchGraphEvent(new GraphEvent(PtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,container,moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setTail(newLinkTail);
      if (relationNameToAdd != null) {
        link.setRelation(getToplevel().getRelation(relationNameToAdd));
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new LinkChangeListener(link,container,failmoml));
  container.requestChange(request);
}","/** 
 * Connect the given edge to the given tail node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param tail The new tail for the edge, which is assumed tobe a location representing a port, a port or a vertex.
 */
public void setTail(final Object edge,final Object newLinkTail){
  final Link link=(Link)edge;
  final NamedObj linkHead=(NamedObj)link.getHead();
  final NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final CompositeEntity container=(CompositeEntity)getChangeRequestParent(getToplevel());
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(container,moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(container,moml,failmoml,linkHead,(NamedObj)newLinkTail);
  }
 catch (  Exception ex) {
    _linkSet.remove(link);
    link.setHead(null);
    link.setTail(null);
    dispatchGraphEvent(new GraphEvent(PtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,container,moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setTail(newLinkTail);
      if (relationNameToAdd != null) {
        ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
        link.setRelation(relation);
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new LinkChangeListener(link,container,failmoml));
  container.requestChange(request);
}"
75888,"protected void _execute() throws Exception {
  super._execute();
  link.setTail(newLinkTail);
  if (relationNameToAdd != null) {
    link.setRelation(getToplevel().getRelation(relationNameToAdd));
  }
 else {
    link.setRelation(null);
  }
}","protected void _execute() throws Exception {
  super._execute();
  link.setTail(newLinkTail);
  if (relationNameToAdd != null) {
    ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
    link.setRelation(relation);
  }
 else {
    link.setRelation(null);
  }
}"
75889,"/** 
 * Connect the given edge to the given head node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param head The new head for the edge, which is assumed tobe a location representing a port, a port or a vertex.	 
 */
public void setHead(final Object edge,final Object newLinkHead){
  final Link link=(Link)edge;
  final NamedObj linkHead=(NamedObj)link.getHead();
  final NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final CompositeEntity container=(CompositeEntity)getChangeRequestParent(getToplevel());
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(container,moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(container,moml,failmoml,(NamedObj)newLinkHead,linkTail);
  }
 catch (  Exception ex) {
    _linkSet.remove(link);
    link.setHead(null);
    link.setTail(null);
    dispatchGraphEvent(new GraphEvent(PtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,container,moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setHead(newLinkHead);
      if (relationNameToAdd != null) {
        ComponentRelation relation=(ComponentRelation)getToplevel().getRelation(relationNameToAdd);
        link.setRelation(relation);
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new LinkChangeListener(link,container,failmoml));
  container.requestChange(request);
}","/** 
 * Connect the given edge to the given head node. This class queues a new change request with the ptolemy model to make this modification.
 * @param edge The edge, which is assumed to be a link.
 * @param head The new head for the edge, which is assumed tobe a location representing a port, a port or a vertex.	 
 */
public void setHead(final Object edge,final Object newLinkHead){
  final Link link=(Link)edge;
  final NamedObj linkHead=(NamedObj)link.getHead();
  final NamedObj linkTail=(NamedObj)link.getTail();
  Relation linkRelation=(Relation)link.getRelation();
  final StringBuffer moml=new StringBuffer();
  final StringBuffer failmoml=new StringBuffer();
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final CompositeEntity container=(CompositeEntity)getChangeRequestParent(getToplevel());
  String relationName=""String_Node_Str"";
  try {
    _unlinkMoML(container,moml,linkHead,linkTail,linkRelation);
    relationName=_linkMoML(container,moml,failmoml,(NamedObj)newLinkHead,linkTail);
  }
 catch (  Exception ex) {
    _linkSet.remove(link);
    link.setHead(null);
    link.setTail(null);
    dispatchGraphEvent(new GraphEvent(PtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
  }
  moml.append(""String_Node_Str"");
  failmoml.append(""String_Node_Str"");
  final String relationNameToAdd=relationName;
  ChangeRequest request=new MoMLChangeRequest(PtolemyGraphModel.this,container,moml.toString()){
    protected void _execute() throws Exception {
      super._execute();
      link.setHead(newLinkHead);
      if (relationNameToAdd != null) {
        ComponentRelation relation=(ComponentRelation)container.getRelation(relationNameToAdd);
        link.setRelation(relation);
      }
 else {
        link.setRelation(null);
      }
    }
  }
;
  request.addChangeListener(new LinkChangeListener(link,container,failmoml));
  container.requestChange(request);
}"
75890,"public Object visitIfExprNode(IfExprNode node,LinkedList args){
  LinkedList e1StringList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_EXPR1);
  LinkedList e2StringList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_EXPR2);
  LinkedList e3StringList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_EXPR3);
  e1StringList=_parenExpr(node.getExpr1(),e1StringList);
  e2StringList=_parenExpr(node.getExpr2(),e2StringList);
  e3StringList=_parenExpr(node.getExpr3(),e2StringList);
  return TNLManip.arrayToList(new Object[]{e1StringList,""String_Node_Str"",e2StringList,""String_Node_Str"",e3StringList});
}","public Object visitIfExprNode(IfExprNode node,LinkedList args){
  LinkedList e1StringList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_EXPR1);
  LinkedList e2StringList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_EXPR2);
  LinkedList e3StringList=(LinkedList)node.childReturnValueAt(node.CHILD_INDEX_EXPR3);
  e1StringList=_parenExpr(node.getExpr1(),e1StringList);
  e2StringList=_parenExpr(node.getExpr2(),e2StringList);
  e3StringList=_parenExpr(node.getExpr3(),e3StringList);
  return TNLManip.arrayToList(new Object[]{e1StringList,""String_Node_Str"",e2StringList,""String_Node_Str"",e3StringList});
}"
75891,"/** 
 * Initialize/Reinitialize audio resources. First stop playback, and close any open sound files, if necessary. Then reread all parameters, create a new SoundPlayback object, and start playback of audio. <p> This method is synchronized since it is not safe to call SoundCapture methods while this method is executing.
 * @exception IllegalActionException If there is a problem initializingaudio playback.
 */
private synchronized void _initializeCapture() throws IllegalActionException {
  if (_soundCapture != null) {
    try {
      _soundCapture.stopCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
  String modeStr=((StringToken)pathName.getToken()).stringValue();
  if (modeStr.equals(""String_Node_Str"")) {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,_getSampleSize);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
 else {
    String theURL=((StringToken)pathName.getToken()).stringValue();
    _soundCapture=new SoundCapture(theURL,_getSampleSize);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
    _channels=_soundCapture.getChannels();
    channels.setToken(new IntToken(_channels));
  }
}","/** 
 * Initialize/Reinitialize audio resources. First stop playback, and close any open sound files, if necessary. Then reread all parameters, create a new SoundPlayback object, and start playback of audio. <p> This method is synchronized since it is not safe to call SoundCapture methods while this method is executing.
 * @exception IllegalActionException If there is a problem initializingaudio playback.
 */
private synchronized void _initializeCapture() throws IllegalActionException {
  if (_soundCapture != null) {
    try {
      _soundCapture.stopCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
  String modeStr=((StringToken)pathName.getToken()).stringValue();
  if (modeStr.equals(""String_Node_Str"")) {
    int sampleRateInt=((IntToken)sampleRate.getToken()).intValue();
    int sampleSizeInBitsInt=((IntToken)sampleSizeInBits.getToken()).intValue();
    int channelsInt=((IntToken)channels.getToken()).intValue();
    int bufferSizeInt=((IntToken)bufferSize.getToken()).intValue();
    _soundCapture=new SoundCapture((float)sampleRateInt,sampleSizeInBitsInt,channelsInt,bufferSizeInt,_getSampleSize);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex.getMessage());
    }
  }
 else {
    String theURL=((StringToken)pathName.getToken()).stringValue();
    _soundCapture=new SoundCapture(theURL,_getSampleSize);
    try {
      _soundCapture.startCapture();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(""String_Node_Str"" + ex);
    }
    _channels=_soundCapture.getChannels();
  }
}"
75892,"public void method1(){
  int var1=5;
  int var2=7;
  float y=2;
  var1=var1 + var2;
  var2=var2 - var1;
  _privatevar1=var1 * var2;
  _privatevar2=var2 / var1;
}","public void method1(){
  int var1=5;
  int var2=7;
  float y=2;
  var1=var1 + var2 + y;
  var2=var2 - var1;
  _privatevar1=var1 * var2;
  _privatevar2=var2 / var1;
}"
75893,"/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_configureNesting > 0 || _docNesting > 0) {
      if (elementName.equals(""String_Node_Str"")) {
        _configureNesting++;
      }
 else       if (elementName.equals(""String_Node_Str"")) {
        _docNesting++;
      }
      _currentCharData.append(""String_Node_Str"" + elementName);
      Iterator attributes=_attributes.entrySet().iterator();
      while (attributes.hasNext()) {
        Map.Entry entry=(Map.Entry)attributes.next();
        if (entry.getValue() != null) {
          _currentCharData.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"");
        }
      }
      _attributes.clear();
      _currentCharData.append(""String_Node_Str"");
      return;
    }
    if (_skipRendition) {
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
      }
      newEntity.getMoMLInfo().elementName=""String_Node_Str"";
      newEntity.getMoMLInfo().className=newEntity.getFullName();
      newEntity.getMoMLInfo().superclass=className;
      _current=newEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedPort;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedProp;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedRelation;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      NamedObj container=_current;
      _containers.push(_current);
      _namespaces.push(_namespace);
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
      }
      _current=newEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespace=groupName;
      }
 else {
        _namespaces.push(DEFAULT_NAMESPACE);
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
      newParser.setContext(_current);
      newParser._propagating=_propagating;
      _parse(newParser,_base,source);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      Relation tmpRelation=context.getRelation(relationName);
      _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
      ComponentRelation relation=(ComponentRelation)tmpRelation;
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      if (insertAtSpec == null) {
        port.link(relation);
      }
 else {
        int insertAt=Integer.parseInt(insertAtSpec);
        port.insertLink(insertAt,relation);
      }
      _recordLink(context,portName,relationName,insertAtSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        if (className == null) {
          port=container.newPort(portName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
        }
        _recordNewObject(container,port);
      }
      _containers.push(_current);
      _namespaces.push(_namespace);
      _current=port;
      _namespace=DEFAULT_NAMESPACE;
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          ioport.setOutput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
          ioport.setInput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      boolean isIOPort=(_current instanceof IOPort);
      if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else {
        NamedObj property=(Attribute)_current.getAttribute(propertyName);
        String className=(String)_attributes.get(""String_Node_Str"");
        Class newClass=null;
        if (className != null) {
          newClass=Class.forName(className,true,_classLoader);
        }
        boolean createdNew=false;
        if (property == null || (className != null && !property.getClass().getName().equals(className))) {
          try {
            if (newClass == null) {
              newClass=Attribute.class;
            }
            Object[] arguments=new Object[2];
            arguments[0]=_current;
            arguments[1]=propertyName;
            property=_createInstance(newClass,arguments);
            if (value != null) {
              if (!(property instanceof Settable)) {
                throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
              }
              Settable settable=(Settable)property;
              settable.setExpression(value);
              _paramsToParse.add(property);
            }
            createdNew=true;
          }
 catch (          NameDuplicationException ex) {
          }
        }
        if (!createdNew) {
          if (value != null) {
            if (!(property instanceof Settable)) {
              throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
            }
            Settable settable=(Settable)property;
            settable.setExpression(value);
            _paramsToParse.add(property);
          }
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=property;
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      if (relation == null) {
        NamedObj newRelation=null;
        _containers.push(_current);
        _namespaces.push(_namespace);
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
        }
        _namespace=DEFAULT_NAMESPACE;
        _recordNewObject(_current,newRelation);
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=relation;
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        _current.setName(newName);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      int countArgs=0;
      if (indexSpec != null)       countArgs++;
      if (insideIndexSpec != null)       countArgs++;
      if (relationName != null)       countArgs++;
      if (countArgs != 1) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      if (relationName != null) {
        Relation tmpRelation=context.getRelation(relationName);
        _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
        ComponentRelation relation=(ComponentRelation)tmpRelation;
        port.unlink(relation);
      }
 else       if (indexSpec != null) {
        int index=Integer.parseInt(indexSpec);
        port.unlink(index);
      }
 else {
        int index=Integer.parseInt(insideIndexSpec);
        port.unlinkInside(index);
      }
      _recordUnlink(context,portName,relationName,indexSpec,insideIndexSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null) {
        vertex.setExpression(value);
        _paramsToParse.add(vertex);
      }
      _containers.push(_current);
      _namespaces.push(_namespace);
      _current=vertex;
      _namespace=DEFAULT_NAMESPACE;
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException().toString();
    throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
catch (  Exception ex) {
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.toString();
      throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
    }
  }
  _attributes.clear();
}","/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  try {
    if (_configureNesting > 0 || _docNesting > 0) {
      if (elementName.equals(""String_Node_Str"")) {
        _configureNesting++;
      }
 else       if (elementName.equals(""String_Node_Str"")) {
        _docNesting++;
      }
      _currentCharData.append(""String_Node_Str"" + elementName);
      Iterator attributes=_attributes.entrySet().iterator();
      while (attributes.hasNext()) {
        Map.Entry entry=(Map.Entry)attributes.next();
        if (entry.getValue() != null) {
          _currentCharData.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ StringUtilities.escapeForXML((String)entry.getValue())+ ""String_Node_Str"");
        }
      }
      _attributes.clear();
      _currentCharData.append(""String_Node_Str"");
      return;
    }
    if (_skipRendition) {
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
      }
      newEntity.getMoMLInfo().elementName=""String_Node_Str"";
      newEntity.getMoMLInfo().className=newEntity.getFullName();
      newEntity.getMoMLInfo().superclass=className;
      _current=newEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedPort;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedProp;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedRelation;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      NamedObj container=_current;
      _containers.push(_current);
      _namespaces.push(_namespace);
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
      }
      _current=newEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespace=groupName;
      }
 else {
        _namespaces.push(DEFAULT_NAMESPACE);
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
      newParser.setContext(_current);
      newParser._propagating=_propagating;
      _parse(newParser,_base,source);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      Relation tmpRelation=context.getRelation(relationName);
      _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
      ComponentRelation relation=(ComponentRelation)tmpRelation;
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      if (insertAtSpec == null) {
        port.link(relation);
      }
 else {
        int insertAt=Integer.parseInt(insertAtSpec);
        port.insertLink(insertAt,relation);
      }
      _recordLink(context,portName,relationName,insertAtSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        if (className == null) {
          port=container.newPort(portName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
        }
        _recordNewObject(container,port);
      }
      _containers.push(_current);
      _namespaces.push(_namespace);
      _current=port;
      _namespace=DEFAULT_NAMESPACE;
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          ioport.setOutput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
          ioport.setInput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      boolean isIOPort=(_current instanceof IOPort);
      if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else {
        NamedObj property=(Attribute)_current.getAttribute(propertyName);
        String className=(String)_attributes.get(""String_Node_Str"");
        Class newClass=null;
        if (className != null) {
          newClass=Class.forName(className,true,_classLoader);
        }
        boolean createdNew=false;
        if (property == null || (className != null && !property.getClass().getName().equals(className))) {
          try {
            if (newClass == null) {
              newClass=Attribute.class;
            }
            Object[] arguments=new Object[2];
            arguments[0]=_current;
            arguments[1]=propertyName;
            property=_createInstance(newClass,arguments);
            if (value != null) {
              if (!(property instanceof Settable)) {
                throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
              }
              Settable settable=(Settable)property;
              settable.setExpression(value);
              _paramsToParse.add(property);
            }
            createdNew=true;
          }
 catch (          NameDuplicationException ex) {
          }
        }
        if (!createdNew) {
          if (value != null) {
            if (!(property instanceof Settable)) {
              throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
            }
            Settable settable=(Settable)property;
            settable.setExpression(value);
            _paramsToParse.add(property);
          }
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=property;
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      if (relation == null) {
        NamedObj newRelation=null;
        _containers.push(_current);
        _namespaces.push(_namespace);
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
        }
        _namespace=DEFAULT_NAMESPACE;
        _recordNewObject(_current,newRelation);
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=relation;
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        _current.setName(newName);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      int countArgs=0;
      if (indexSpec != null)       countArgs++;
      if (insideIndexSpec != null)       countArgs++;
      if (relationName != null)       countArgs++;
      if (countArgs != 1) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      if (relationName != null) {
        Relation tmpRelation=context.getRelation(relationName);
        _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
        ComponentRelation relation=(ComponentRelation)tmpRelation;
        port.unlink(relation);
      }
 else       if (indexSpec != null) {
        int index=Integer.parseInt(indexSpec);
        port.unlink(index);
      }
 else {
        int index=Integer.parseInt(insideIndexSpec);
        port.unlinkInside(index);
      }
      _recordUnlink(context,portName,relationName,indexSpec,insideIndexSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null) {
        vertex.setExpression(value);
        _paramsToParse.add(vertex);
      }
      _containers.push(_current);
      _namespaces.push(_namespace);
      _current=vertex;
      _namespace=DEFAULT_NAMESPACE;
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException().toString();
    throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
catch (  Exception ex) {
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.toString();
      throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
    }
  }
  _attributes.clear();
}"
75894,"/** 
 * Put an array of objects in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put any of the object in the queue and return false. The specified number of objects from the array will be put in the queue.
 * @param element An array of objects to be put in the queue.
 * @param count The number of objects to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean putArray(Object element[],int count){
  if (_queueArray.length - _queueSize >= count) {
    int i;
    if (count <= (_queueArray.length - _queueFront)) {
      System.arraycopy(element,0,_queueArray,_queueFront,count);
      _queueFront+=count;
      if (_queueFront >= _queueArray.length)       _queueFront=_queueFront % _queueArray.length;
      _queueSize+=count;
    }
 else {
      System.arraycopy(element,0,_queueArray,_queueFront,_queueArray.length - _queueFront);
      System.arraycopy(element,_queueArray.length - _queueFront,_queueArray,0,count - (_queueArray.length - _queueFront));
      _queueFront+=count;
      if (_queueFront >= _queueArray.length)       _queueFront=_queueFront % _queueArray.length;
      _queueSize+=count;
    }
    return true;
  }
 else {
    if (_queueMaxCapacity == INFINITE_CAPACITY) {
      try {
        _resizeArray(_queueArray.length * 2);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      return putArray(element);
    }
 else     return false;
  }
}","/** 
 * Put an array of objects in the queue and return true if this will not cause the capacity to be exceeded. Otherwise, do not put any of the object in the queue and return false. The specified number of objects from the array will be put in the queue.
 * @param element An array of objects to be put in the queue.
 * @param count The number of objects to be put in the queue.
 * @return A boolean indicating success.
 */
public boolean putArray(Object element[],int count){
  if (_queueArray.length - _queueSize >= count) {
    int i;
    if (count <= (_queueArray.length - _queueFront)) {
      System.arraycopy(element,0,_queueArray,_queueFront,count);
      _queueFront+=count;
      if (_queueFront >= _queueArray.length)       _queueFront=_queueFront % _queueArray.length;
      _queueSize+=count;
    }
 else {
      System.arraycopy(element,0,_queueArray,_queueFront,_queueArray.length - _queueFront);
      System.arraycopy(element,_queueArray.length - _queueFront,_queueArray,0,count - (_queueArray.length - _queueFront));
      _queueFront+=count;
      if (_queueFront >= _queueArray.length)       _queueFront=_queueFront % _queueArray.length;
      _queueSize+=count;
    }
    return true;
  }
 else {
    if (_queueMaxCapacity == INFINITE_CAPACITY) {
      try {
        _resizeArray(_queueArray.length * 2);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      return putArray(element,count);
    }
 else     return false;
  }
}"
75895,"/** 
 * Construct the composite actor with a name and a container. This constructor creates the ports, parameters, and the icon.
 * @param container The container.
 * @param name The name.
 * @exception NameDuplicationException If another entity already hadthis name.
 * @exception IllegalActionException If there was an internal problem.
 */
public LinearStateSpace(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setMultiport(true);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setMultiport(true);
  _opaque=true;
  double[][] one={{1.0}};
  double[][] zero={{0.0}};
  A=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(one));
  A.setTypeEquals(BaseType.DOUBLE_MATRIX);
  B=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(one));
  B.setTypeEquals(BaseType.DOUBLE_MATRIX);
  C=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(one));
  C.setTypeEquals(BaseType.DOUBLE_MATRIX);
  D=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(zero));
  D.setTypeEquals(BaseType.DOUBLE_MATRIX);
  initialStates=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(zero));
  initialStates.setTypeEquals(BaseType.DOUBLE_MATRIX);
  getMoMLInfo().className=""String_Node_Str"";
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Construct the composite actor with a name and a container. This constructor creates the ports, parameters, and the icon.
 * @param container The container.
 * @param name The name.
 * @exception NameDuplicationException If another entity already hadthis name.
 * @exception IllegalActionException If there was an internal problem.
 */
public LinearStateSpace(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setMultiport(true);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setMultiport(true);
  _opaque=true;
  double[][] one={{1.0}};
  double[][] zero={{0.0}};
  A=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(one));
  A.setTypeEquals(BaseType.DOUBLE_MATRIX);
  B=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(one));
  B.setTypeEquals(BaseType.DOUBLE_MATRIX);
  C=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(one));
  C.setTypeEquals(BaseType.DOUBLE_MATRIX);
  D=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(zero));
  D.setTypeEquals(BaseType.DOUBLE_MATRIX);
  initialStates=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(zero));
  initialStates.setTypeEquals(BaseType.DOUBLE_MATRIX);
  getMoMLInfo().className=""String_Node_Str"";
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
75896,"/** 
 * Sanity check the parameters; if the parameters are legal create a continuous-time subsystem that implement the model, preinitialize all the actors in the subsystem, and set the opaqueness of this actor to true. This method need the write access on the workspace.
 * @exception IllegalActionException If there is no CTDirector,or any contained actors throw it in its preinitialize() method.
 */
public void preinitialize() throws IllegalActionException {
  _checkParameters();
  DoubleMatrixToken a=(DoubleMatrixToken)A.getToken();
  int n=a.getRowCount();
  DoubleMatrixToken b=(DoubleMatrixToken)B.getToken();
  int m=b.getColumnCount();
  DoubleMatrixToken c=(DoubleMatrixToken)C.getToken();
  int r=c.getRowCount();
  DoubleMatrixToken d=(DoubleMatrixToken)D.getToken();
  DoubleMatrixToken x0=(DoubleMatrixToken)initialStates.getToken();
  try {
    _workspace.getWriteAccess();
    removeAllEntities();
    removeAllRelations();
    Integrator[] integrators=new Integrator[n];
    IORelation[] states=new IORelation[n];
    AddSubtract[] stateAdders=new AddSubtract[n];
    for (int i=0; i < n; i++) {
      integrators[i]=new Integrator(this,""String_Node_Str"" + i);
      states[i]=new TypedIORelation(this,""String_Node_Str"" + i);
      integrators[i].output.link(states[i]);
      stateAdders[i]=new AddSubtract(this,""String_Node_Str"" + i);
      connect(stateAdders[i].output,integrators[i].input);
    }
    Scale[][] feedback=new Scale[n][n];
    for (int i=0; i < n; i++) {
      for (int j=0; j < n; j++) {
        Token tokenIJ=a.getElementAsToken(i,j);
        if (!(tokenIJ.isEqualTo(tokenIJ.zero())).booleanValue()) {
          feedback[i][j]=new Scale(this,""String_Node_Str"" + i + ""String_Node_Str""+ j);
          feedback[i][j].factor.setToken(tokenIJ);
          feedback[i][j].input.link(states[i]);
          connect(feedback[i][j].output,stateAdders[j].plus);
        }
      }
    }
    Scale[][] inputScales=new Scale[n][m];
    IORelation[] inputs=new IORelation[m];
    for (int j=0; j < m; j++) {
      inputs[j]=new TypedIORelation(this,""String_Node_Str"" + j);
      input.link(inputs[j]);
      for (int i=0; i < n; i++) {
        inputScales[i][j]=new Scale(this,""String_Node_Str"" + i + ""String_Node_Str""+ j);
        inputScales[i][j].factor.setToken(b.getElementAsToken(i,j));
        inputScales[i][j].input.link(inputs[j]);
        connect(inputScales[i][j].output,stateAdders[i].plus);
      }
    }
    AddSubtract[] outputAdders=new AddSubtract[r];
    Scale[][] outputScales=new Scale[r][n];
    for (int l=0; l < r; l++) {
      outputAdders[l]=new AddSubtract(this,""String_Node_Str"" + l);
      connect(outputAdders[l].output,output);
      for (int i=0; i < n; i++) {
        outputScales[l][i]=new Scale(this,""String_Node_Str"" + l + ""String_Node_Str""+ i);
        outputScales[l][i].factor.setToken(c.getElementAsToken(l,i));
        outputScales[l][i].input.link(states[i]);
        connect(outputScales[l][i].output,outputAdders[l].plus);
      }
    }
    Scale[][] feedThrough=new Scale[r][m];
    for (int l=0; l < r; l++) {
      for (int j=0; j < m; j++) {
        Token tokenLJ=d.getElementAsToken(l,j);
        if (!(tokenLJ.isEqualTo(tokenLJ.zero())).booleanValue()) {
          feedThrough[l][j]=new Scale(this,""String_Node_Str"" + l + ""String_Node_Str""+ j);
          feedThrough[l][j].factor.setToken(tokenLJ);
          feedThrough[l][j].input.link(inputs[j]);
          connect(feedThrough[l][j].output,outputAdders[l].plus);
        }
      }
    }
    _opaque=false;
    _workspace.incrVersion();
    System.out.println(""String_Node_Str"");
  }
 catch (  NameDuplicationException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _workspace.doneWriting();
  }
  for (Iterator i=deepEntityList().iterator(); i.hasNext(); ) {
    Actor actor=(Actor)i.next();
    actor.preinitialize();
  }
}","/** 
 * Sanity check the parameters; if the parameters are legal create a continuous-time subsystem that implement the model, preinitialize all the actors in the subsystem, and set the opaqueness of this actor to true. This method need the write access on the workspace.
 * @exception IllegalActionException If there is no CTDirector,or any contained actors throw it in its preinitialize() method.
 */
public void preinitialize() throws IllegalActionException {
  _checkParameters();
  DoubleMatrixToken a=(DoubleMatrixToken)A.getToken();
  int n=a.getRowCount();
  DoubleMatrixToken b=(DoubleMatrixToken)B.getToken();
  int m=b.getColumnCount();
  DoubleMatrixToken c=(DoubleMatrixToken)C.getToken();
  int r=c.getRowCount();
  DoubleMatrixToken d=(DoubleMatrixToken)D.getToken();
  DoubleMatrixToken x0=(DoubleMatrixToken)initialStates.getToken();
  try {
    _workspace.getWriteAccess();
    removeAllEntities();
    removeAllRelations();
    Integrator[] integrators=new Integrator[n];
    IORelation[] states=new IORelation[n];
    AddSubtract[] stateAdders=new AddSubtract[n];
    for (int i=0; i < n; i++) {
      integrators[i]=new Integrator(this,""String_Node_Str"" + i);
      states[i]=new TypedIORelation(this,""String_Node_Str"" + i);
      integrators[i].output.link(states[i]);
      stateAdders[i]=new AddSubtract(this,""String_Node_Str"" + i);
      connect(stateAdders[i].output,integrators[i].input);
    }
    Scale[][] feedback=new Scale[n][n];
    for (int i=0; i < n; i++) {
      for (int j=0; j < n; j++) {
        Token tokenIJ=a.getElementAsToken(i,j);
        if (!(tokenIJ.isEqualTo(tokenIJ.zero())).booleanValue()) {
          feedback[i][j]=new Scale(this,""String_Node_Str"" + i + ""String_Node_Str""+ j);
          feedback[i][j].factor.setToken(tokenIJ);
          feedback[i][j].input.link(states[j]);
          connect(feedback[i][j].output,stateAdders[i].plus);
        }
      }
    }
    Scale[][] inputScales=new Scale[n][m];
    IORelation[] inputs=new IORelation[m];
    for (int j=0; j < m; j++) {
      inputs[j]=new TypedIORelation(this,""String_Node_Str"" + j);
      input.link(inputs[j]);
      for (int i=0; i < n; i++) {
        inputScales[i][j]=new Scale(this,""String_Node_Str"" + i + ""String_Node_Str""+ j);
        inputScales[i][j].factor.setToken(b.getElementAsToken(i,j));
        inputScales[i][j].input.link(inputs[j]);
        connect(inputScales[i][j].output,stateAdders[i].plus);
      }
    }
    AddSubtract[] outputAdders=new AddSubtract[r];
    Scale[][] outputScales=new Scale[r][n];
    for (int l=0; l < r; l++) {
      outputAdders[l]=new AddSubtract(this,""String_Node_Str"" + l);
      connect(outputAdders[l].output,output);
      for (int i=0; i < n; i++) {
        Token tokenLI=c.getElementAsToken(l,i);
        if (!(tokenLI.isEqualTo(tokenLI.zero())).booleanValue()) {
          outputScales[l][i]=new Scale(this,""String_Node_Str"" + l + ""String_Node_Str""+ i);
          outputScales[l][i].factor.setToken(tokenLI);
          outputScales[l][i].input.link(states[i]);
          connect(outputScales[l][i].output,outputAdders[l].plus);
        }
      }
    }
    Scale[][] feedThrough=new Scale[r][m];
    for (int l=0; l < r; l++) {
      for (int j=0; j < m; j++) {
        Token tokenLJ=d.getElementAsToken(l,j);
        if (!(tokenLJ.isEqualTo(tokenLJ.zero())).booleanValue()) {
          feedThrough[l][j]=new Scale(this,""String_Node_Str"" + l + ""String_Node_Str""+ j);
          feedThrough[l][j].factor.setToken(tokenLJ);
          feedThrough[l][j].input.link(inputs[j]);
          connect(feedThrough[l][j].output,outputAdders[l].plus);
        }
      }
    }
    _opaque=false;
    _workspace.incrVersion();
    System.out.println(""String_Node_Str"");
  }
 catch (  NameDuplicationException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _workspace.doneWriting();
  }
  for (Iterator i=deepEntityList().iterator(); i.hasNext(); ) {
    Actor actor=(Actor)i.next();
    actor.preinitialize();
  }
}"
75897,"/** 
 * Clone the actor into the specified workspace. This calls the base class and sets the public variables to point to the new ports.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Switch newObject=(Switch)super.clone(workspace);
  newObject.select=(TypedIOPort)newObject.getPort(""String_Node_Str"");
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and sets the public variables to point to the new ports.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Switch3D newObject=(Switch3D)super.clone(workspace);
  newObject.select=(TypedIOPort)newObject.getPort(""String_Node_Str"");
  return newObject;
}"
75898,"/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator ainputports=a.inputPortList().iterator();
      while (ainputports.hasNext()) {
        IOPort ainputport=(IOPort)ainputports.next();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator aoutputports=a.outputPortList().iterator();
      while (aoutputports.hasNext()) {
        IOPort aOutputPort=(IOPort)aoutputports.next();
        int count=getTokenInitProduction(aOutputPort);
        if (_debugging)         _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      if (_debugging)       _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        int tokencount[]=(int[])waitingTokens.get(port);
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getFullName());
          _debug(""String_Node_Str"" + tokencount.length);
        }
        for (int channel=0; channel < tokencount.length; channel++)         if (_debugging)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
        Iterator actorsLeft=readyToScheduleActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
        _debug(""String_Node_Str"");
        actorsLeft=unscheduledActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      if (_debugging) {
        _debug(""String_Node_Str"" + currentActor.getName());
      }
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Iterator aOutputPorts=((Actor)currentActor).outputPortList().iterator();
      while (aOutputPorts.hasNext()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.next();
        int count=getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,unscheduledActorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      if (_debugging) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          _debug(""String_Node_Str"" + currentActor);
          while (readyToScheduleActorList.remove(currentActor))           ;
          while (unscheduledActorList.remove(currentActor))           ;
          _debug(""String_Node_Str"");
          Iterator actorsLeft=readyToScheduleActorList.iterator();
          while (actorsLeft.hasNext()) {
            Entity e=(Entity)actorsLeft.next();
            if (_debugging)             _debug(e.getFullName());
          }
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1 && unscheduledActorList.contains(currentActor))           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    if (_debugging)     _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  if (_debugging) {
    _debug(""String_Node_Str"");
    while (eschedule.hasNext()) {
      _debug(((ComponentEntity)eschedule.next()).toString());
    }
  }
  return newSchedule;
}","/** 
 * Create a schedule for a set of UnscheduledActors.  Given a valid firing vector, simulate the scheduling of the actors until the end of one synchronous dataflow iteration. Each actor will appear in the schedule exactly the number of times that minimally solves the balance equations and in an order where each actor has sufficient tokens on its inputs to fire.   Note that no claim is made that this is an optimal solution in any other sense.
 * @param UnscheduledActors The Actors that need to be scheduled.
 * @return A LinkedList of the Actors in the order they should fire.
 * @exception NotSchedulableException If the algorithm encounters an SDFgraph that is not consistent with the firing vector, or detects an inconsistent internal state, or detects a graph that cannot be scheduled.
 */
private LinkedList _scheduleConnectedActors(LinkedList actorList) throws NotSchedulableException {
  LinkedList readyToScheduleActorList=new LinkedList();
  LinkedList newSchedule=new LinkedList();
  Map waitingTokens=new TreeMap(new NamedObjComparator());
  Map firingsRemainingVector=new TreeMap(new NamedObjComparator());
  firingsRemainingVector.putAll(_firingvector);
  LinkedList unscheduledActorList=new LinkedList();
  unscheduledActorList.addAll(actorList);
  try {
    Iterator schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator ainputports=a.inputPortList().iterator();
      while (ainputports.hasNext()) {
        IOPort ainputport=(IOPort)ainputports.next();
        int[] tokencount=new int[ainputport.getWidth()];
        for (int channel=0; channel < tokencount.length; channel++)         tokencount[channel]=0;
        waitingTokens.put(ainputport,tokencount);
      }
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      Iterator aoutputports=a.outputPortList().iterator();
      while (aoutputports.hasNext()) {
        IOPort aOutputPort=(IOPort)aoutputports.next();
        int count=getTokenInitProduction(aOutputPort);
        if (_debugging)         _debug(""String_Node_Str"" + count + ""String_Node_Str""+ aOutputPort);
        if (count > 0) {
          _simulateTokensCreated(aOutputPort,count,actorList,readyToScheduleActorList,waitingTokens);
        }
      }
    }
    StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
    CompositeActor ca=(CompositeActor)(dir.getContainer());
    Iterator inputPorts=ca.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      _simulateExternalInputs(port,actorList,waitingTokens);
    }
    schedulableEntities=actorList.iterator();
    while (schedulableEntities.hasNext()) {
      Actor a=(Actor)schedulableEntities.next();
      int inputCount=_countUnfulfilledInputs(a,actorList,waitingTokens);
      if (inputCount == 0)       readyToScheduleActorList.addFirst((ComponentEntity)a);
      if (_debugging)       _debug(""String_Node_Str"" + ((ComponentEntity)a).getName() + ""String_Node_Str""+ inputCount+ ""String_Node_Str"");
    }
    while (readyToScheduleActorList.size() > 0) {
      if (_debugging)       _debug(""String_Node_Str"");
      Iterator ports=waitingTokens.keySet().iterator();
      while (ports.hasNext()) {
        IOPort port=(IOPort)ports.next();
        int tokencount[]=(int[])waitingTokens.get(port);
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getFullName());
          _debug(""String_Node_Str"" + tokencount.length);
        }
        for (int channel=0; channel < tokencount.length; channel++)         if (_debugging)         _debug(""String_Node_Str"" + channel + ""String_Node_Str""+ tokencount[channel]+ ""String_Node_Str"");
      }
      if (_debugging) {
        _debug(""String_Node_Str"");
        Iterator actorsLeft=readyToScheduleActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
        _debug(""String_Node_Str"");
        actorsLeft=unscheduledActorList.iterator();
        while (actorsLeft.hasNext()) {
          Entity e=(Entity)actorsLeft.next();
          _debug(e.getFullName());
        }
      }
      ComponentEntity currentActor=(ComponentEntity)readyToScheduleActorList.getFirst();
      while (readyToScheduleActorList.remove(currentActor))       ;
      if (_debugging) {
        _debug(""String_Node_Str"" + currentActor.getName());
      }
      _simulateInputConsumption(currentActor,waitingTokens);
      newSchedule.addLast(currentActor);
      Iterator aOutputPorts=((Actor)currentActor).outputPortList().iterator();
      while (aOutputPorts.hasNext()) {
        IOPort aOutputPort=(IOPort)aOutputPorts.next();
        int count=getTokenProductionRate(aOutputPort);
        _simulateTokensCreated(aOutputPort,count,unscheduledActorList,readyToScheduleActorList,waitingTokens);
      }
      int firingsRemaining=((Integer)firingsRemainingVector.get(currentActor)).intValue();
      firingsRemaining-=1;
      firingsRemainingVector.put(currentActor,new Integer(firingsRemaining));
      if (_debugging) {
        _debug(currentActor.getName() + ""String_Node_Str"" + firingsRemaining+ ""String_Node_Str"");
      }
      if (firingsRemaining < 0)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
 else {
        if (firingsRemaining == 0) {
          _debug(""String_Node_Str"" + currentActor);
          while (readyToScheduleActorList.remove(currentActor))           ;
          while (unscheduledActorList.remove(currentActor))           ;
          _debug(""String_Node_Str"");
          Iterator actorsLeft=readyToScheduleActorList.iterator();
          while (actorsLeft.hasNext()) {
            Entity e=(Entity)actorsLeft.next();
            if (_debugging)             _debug(e.getFullName());
          }
        }
 else {
          int inputCount=_countUnfulfilledInputs((Actor)currentActor,unscheduledActorList,waitingTokens);
          if (inputCount < 1 && unscheduledActorList.contains(currentActor))           readyToScheduleActorList.addLast(currentActor);
        }
      }
    }
  }
 catch (  IllegalActionException iae) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + iae.getMessage());
  }
 finally {
    if (_debugging)     _debug(""String_Node_Str"");
  }
  if (unscheduledActorList.size() > 0) {
    String s=new String(""String_Node_Str"");
    Iterator actors=unscheduledActorList.iterator();
    while (actors.hasNext()) {
      Entity actor=(Entity)actors.next();
      s+=actor.getFullName() + ""String_Node_Str"";
    }
    throw new NotSchedulableException(s);
  }
  Iterator eschedule=newSchedule.iterator();
  if (_debugging) {
    _debug(""String_Node_Str"");
    while (eschedule.hasNext()) {
      _debug(((ComponentEntity)eschedule.next()).toString());
    }
  }
  return newSchedule;
}"
75899,"/** 
 * Initialize the local data members of this object.  
 */
protected void _localMemberInitialize(){
  _firingvector=new TreeMap(new NamedObjComparator());
  _firingvectorvalid=true;
}","/** 
 * Initialize the local data members of this object.  
 */
protected void _localMemberInitialize(){
  _firingvector=new TreeMap(new NamedObjComparator());
  _firingvectorvalid=true;
  addDebugListener(new StreamListener());
}"
75900,"/** 
 * Count the number of inputports in the Actor that must be fulfilled before the actor can fire.  Ports that are connected to actors that we are not scheduling right now are assumed to be fulfilled.  Ports that have more tokens waiting on each of their channels than their input consumption rate are also already fulfilled.  All other ports are considered to be unfulfilled.
 * @param a The actor
 * @param unscheduledactors The set of actors that we are scheduling.
 * @param waitingTokens The Map of tokens currently waiting on all theinput ports.
 * @return The number of unfulfilled inputs of a.
 * @exception IllegalActionException If any called method throws it.
 */
private int _countUnfulfilledInputs(Actor a,LinkedList actorList,Map waitingTokens) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + ((Entity)a).getFullName());
  Iterator ainputPorts=a.inputPortList().iterator();
  int inputCount=0;
  while (ainputPorts.hasNext()) {
    IOPort ainputPort=(IOPort)ainputPorts.next();
    if (_debugging)     _debug(""String_Node_Str"" + ainputPort.getFullName());
    Iterator cports=ainputPort.deepConnectedOutPortList().iterator();
    boolean isOnlyExternalPort=true;
    while (cports.hasNext()) {
      IOPort cport=(IOPort)cports.next();
      if (actorList.contains(cport.getContainer()))       isOnlyExternalPort=false;
    }
    int threshold=getTokenConsumptionRate(ainputPort);
    if (_debugging)     _debug(""String_Node_Str"" + threshold);
    int[] tokens=(int[])waitingTokens.get(ainputPort);
    boolean isAlreadyFulfilled=true;
    int channel;
    for (channel=0; channel < ainputPort.getWidth(); channel++) {
      if (_debugging) {
        _debug(""String_Node_Str"" + channel);
        _debug(""String_Node_Str"" + tokens[channel]);
      }
      if (tokens[channel] < threshold)       isAlreadyFulfilled=false;
    }
    if (!isOnlyExternalPort && !isAlreadyFulfilled)     inputCount++;
  }
  return inputCount;
}","/** 
 * Count the number of inputports in the Actor that must be fulfilled before the actor can fire.  Ports that are connected to actors that we are not scheduling right now are assumed to be fulfilled.  Ports that have more tokens waiting on each of their channels than their input consumption rate are also already fulfilled.  All other ports are considered to be unfulfilled.
 * @param a The actor
 * @param unscheduledactors The set of actors that we are scheduling.
 * @param waitingTokens The Map of tokens currently waiting on all theinput ports.
 * @return The number of unfulfilled inputs of a.
 * @exception IllegalActionException If any called method throws it.
 */
private int _countUnfulfilledInputs(Actor a,LinkedList actorList,Map waitingTokens) throws IllegalActionException {
  if (_debugging)   _debug(""String_Node_Str"" + ((Entity)a).getFullName());
  Iterator ainputPorts=a.inputPortList().iterator();
  int inputCount=0;
  while (ainputPorts.hasNext()) {
    IOPort ainputPort=(IOPort)ainputPorts.next();
    if (_debugging)     _debug(""String_Node_Str"" + ainputPort.getFullName());
    int threshold=getTokenConsumptionRate(ainputPort);
    if (_debugging)     _debug(""String_Node_Str"" + threshold);
    int[] tokens=(int[])waitingTokens.get(ainputPort);
    boolean isFulfilled=true;
    int channel;
    for (channel=0; channel < ainputPort.getWidth() && isFulfilled; channel++) {
      if (_debugging) {
        _debug(""String_Node_Str"" + channel);
        _debug(""String_Node_Str"" + tokens[channel]);
      }
      if (tokens[channel] < threshold)       isFulfilled=false;
    }
    if (!isFulfilled)     inputCount++;
  }
  return inputCount;
}"
75901,"/** 
 * Called when a connector end is dropped--attach or detach the edge as appropriate.
 */
public void connectorDropped(ConnectorEvent evt){
  Connector c=evt.getConnector();
  Figure f=evt.getTarget();
  Object edge=c.getUserObject();
  Object node=(f == null) ? null : f.getUserObject();
  FSMGraphModel model=(FSMGraphModel)getController().getGraphModel();
switch (evt.getEnd()) {
case ConnectorEvent.HEAD_END:
    model.getArcModel().setHead(edge,node);
  break;
case ConnectorEvent.TAIL_END:
model.getArcModel().setTail(edge,node);
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","/** 
 * Called when a connector end is dropped--attach or detach the edge as appropriate.
 */
public void connectorDropped(ConnectorEvent evt){
  Connector c=evt.getConnector();
  Figure f=evt.getTarget();
  Object edge=c.getUserObject();
  Object node=(f == null) ? null : f.getUserObject();
  FSMGraphModel model=(FSMGraphModel)getController().getGraphModel();
switch (evt.getEnd()) {
case ConnectorEvent.HEAD_END:
    model.getArcModel().setHead(edge,node);
  break;
case ConnectorEvent.TAIL_END:
model.getArcModel().setTail(edge,node);
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
getController().rerenderEdge(edge);
}"
75902,"/** 
 * Render a visual representation of the given edge.
 */
public Connector render(Object edge,Site tailSite,Site headSite){
  AbstractConnector c=new ArcConnector(tailSite,headSite);
  c.setHeadEnd(new Arrowhead());
  c.setLineWidth((float)2.0);
  c.setUserObject(edge);
  Arc arc=(Arc)edge;
  Transition transition=(Transition)arc.getRelation();
  if (transition != null) {
    c.setToolTipText(transition.getName());
    StringBuffer buffer=new StringBuffer();
    if (transition.guardExpression != null && transition.guardExpression.getExpression() != null) {
      buffer.append(transition.guardExpression.getExpression());
    }
    String action=transition.actions.getExpression();
    if (action != null && !action.trim().equals(""String_Node_Str"")) {
      buffer.append(""String_Node_Str"");
      buffer.append(action);
    }
    LabelFigure label=new LabelFigure(buffer.toString(),_labelFont);
    label.setFillPaint(Color.blue);
    c.setLabelFigure(label);
  }
  return c;
}","/** 
 * Render a visual representation of the given edge.
 */
public Connector render(Object edge,Site tailSite,Site headSite){
  AbstractConnector c=new ArcConnector(tailSite,headSite);
  c.setHeadEnd(new Arrowhead());
  c.setLineWidth((float)2.0);
  c.setUserObject(edge);
  Arc arc=(Arc)edge;
  Transition transition=(Transition)arc.getRelation();
  if (transition != null) {
    c.setToolTipText(transition.getName());
    StringBuffer buffer=new StringBuffer();
    boolean aLabel=false;
    String guard=transition.guardExpression.getExpression();
    if (guard != null) {
      buffer.append(guard);
      aLabel=true;
    }
    String action=transition.actions.getExpression();
    if (action != null && !action.trim().equals(""String_Node_Str"")) {
      if (aLabel)       buffer.append(""String_Node_Str"");
      buffer.append(action);
      aLabel=true;
    }
    if (aLabel) {
      LabelFigure label=new LabelFigure(buffer.toString(),_labelFont);
      label.setFillPaint(Color.blue);
      c.setLabelFigure(label);
    }
  }
  return c;
}"
75903,"/** 
 * Resolves the Token to be stored in the node. When this method is called by resolveTree, the tokens in each of the children have been resolved. This method is concerned with evaluating both the value and type of the ptToken to be stored.
 * @return The ptolemy.data.Token to be stored in this node.
 * @exception IllegalArgumentException If an error occurstrying to evaluate the PtToken type and/or value to be stored.
 */
protected ptolemy.data.Token _resolveNode() throws IllegalActionException {
  int num=jjtGetNumChildren();
  if (num == 1)   return _childTokens[0];
  Class[] argTypes=new Class[num - 1];
  Object[] argValues=new Object[num - 1];
  try {
    for (int i=1; i < num; i++) {
      argValues[i - 1]=(ptolemy.data.Token)_childTokens[i];
      argTypes[i - 1]=Class.forName(""String_Node_Str"");
    }
    Class destTokenClass=_childTokens[0].getClass();
    Method m=destTokenClass.getMethod(_methodName,argTypes);
    Object result=m.invoke(_childTokens[0],argValues);
    if (result instanceof ptolemy.data.Token) {
      return (ptolemy.data.Token)result;
    }
 else {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
 catch (  java.lang.NoSuchMethodException ex) {
    throw new IllegalActionException(_generateExceptionMessage(ex));
  }
catch (  java.lang.IllegalAccessException ex) {
    throw new IllegalActionException(_generateExceptionMessage(ex));
  }
catch (  java.lang.reflect.InvocationTargetException ex) {
    throw new IllegalActionException(_generateExceptionMessage(ex));
  }
catch (  java.lang.ClassNotFoundException ex) {
    throw new IllegalActionException(_generateExceptionMessage(ex));
  }
}","/** 
 * Resolves the Token to be stored in the node. When this method is called by resolveTree, the tokens in each of the children have been resolved. This method is concerned with evaluating both the value and type of the ptToken to be stored.
 * @return The ptolemy.data.Token to be stored in this node.
 * @exception IllegalArgumentException If an error occurstrying to evaluate the PtToken type and/or value to be stored.
 */
protected ptolemy.data.Token _resolveNode() throws IllegalActionException {
  int num=jjtGetNumChildren();
  Class[] argTypes=new Class[num - 1];
  Object[] argValues=new Object[num - 1];
  try {
    for (int i=1; i < num; i++) {
      argValues[i - 1]=(ptolemy.data.Token)_childTokens[i];
      argTypes[i - 1]=Class.forName(""String_Node_Str"");
    }
    Class destTokenClass=_childTokens[0].getClass();
    Method m=destTokenClass.getMethod(_methodName,argTypes);
    Object result=m.invoke(_childTokens[0],argValues);
    if (result instanceof ptolemy.data.Token) {
      return (ptolemy.data.Token)result;
    }
 else {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
 catch (  java.lang.NoSuchMethodException ex) {
    throw new IllegalActionException(_generateExceptionMessage(ex));
  }
catch (  java.lang.IllegalAccessException ex) {
    throw new IllegalActionException(_generateExceptionMessage(ex));
  }
catch (  java.lang.reflect.InvocationTargetException ex) {
    throw new IllegalActionException(_generateExceptionMessage(ex));
  }
catch (  java.lang.ClassNotFoundException ex) {
    throw new IllegalActionException(_generateExceptionMessage(ex));
  }
}"
75904,"/** 
 * Return a new token whose value is the product of this token and the argument. The type of the specified token must be lower than ComplexMatrixToken.
 * @param t The token to multiply this Token by.
 * @return A new token containing the result.
 * @exception IllegalActionException If the type of the specifiedtoken is not lower than ComplexMatrixToken.
 */
public final Token multiplyReverse(final Token t) throws IllegalActionException {
  int compare=TypeLattice.compare(this,t);
  if (!(compare == CPO.HIGHER)) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + t.getClass().getName() + ""String_Node_Str""+ getClass().getName());
  }
  if (t instanceof ScalarToken) {
    return multiply(t);
  }
 else {
    ComplexMatrixToken tem=(ComplexMatrixToken)this.convert(t);
    return new ComplexMatrixToken(ComplexMatrixMath.multiply(tem._getInternalComplexMatrix(),_value),DO_NOT_COPY);
  }
}","/** 
 * Return a new token whose value is the product of this token and the argument. The type of the specified token must be lower than ComplexMatrixToken.
 * @param t The token to multiply this Token by.
 * @return A new token containing the result.
 * @exception IllegalActionException If the type of the specifiedtoken is not lower than ComplexMatrixToken.
 */
public final Token multiplyReverse(final Token t) throws IllegalActionException {
  int compare=TypeLattice.compare(this,t);
  if (!(compare == CPO.HIGHER)) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + t.getClass().getName() + ""String_Node_Str""+ getClass().getName());
  }
  if (t instanceof ScalarToken) {
    return multiply(t);
  }
 else {
    ComplexMatrixToken tem=(ComplexMatrixToken)this.convert(t);
    if (tem.getColumnCount() != _rowCount) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + tem.getColumnCount() + ""String_Node_Str""+ _rowCount+ ""String_Node_Str"");
    }
    return new ComplexMatrixToken(ComplexMatrixMath.multiply(tem._getInternalComplexMatrix(),_value),DO_NOT_COPY);
  }
}"
75905,"/** 
 * Return a new token whose value is the product of this token and the argument. The type of the specified token must be such that either it can be converted to the type of this token, or the type of this token can be converted to the type of the specified token, without loss of information. The type of the returned token is one of the above two types that allows lossless conversion from the other. If the specified token is a matrix, its number of rows should be the same as this token's number of columns.
 * @param t The token to add to this token.
 * @return A new token containing the result.
 * @exception IllegalActionException If the specified token isnot of a type that can be added to this token in a lossless fashion.
 */
public final Token multiply(final Token t) throws IllegalActionException {
  int compare=TypeLattice.compare(this,t);
  if (compare == CPO.INCOMPARABLE) {
    String msg=""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ t.getClass().getName();
    throw new IllegalActionException(msg);
  }
 else   if (compare == CPO.LOWER) {
    return t.multiplyReverse(this);
  }
 else {
    Complex[][] result=null;
    if (t.getType() == BaseType.COMPLEX) {
      Complex c=((ComplexToken)t).complexValue();
      result=ComplexMatrixMath.multiply(_value,c);
    }
 else     if (t instanceof ScalarToken) {
      double scalar=((ScalarToken)t).doubleValue();
      result=ComplexMatrixMath.multiply(_value,scalar);
    }
 else {
      ComplexMatrixToken tem=(ComplexMatrixToken)this.convert(t);
      if (tem.getRowCount() != _columnCount) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + _columnCount + ""String_Node_Str""+ tem.getRowCount()+ ""String_Node_Str"");
      }
      result=ComplexMatrixMath.multiply(tem._getInternalComplexMatrix(),_value);
    }
    return new ComplexMatrixToken(result,DO_NOT_COPY);
  }
}","/** 
 * Return a new token whose value is the product of this token and the argument. The type of the specified token must be such that either it can be converted to the type of this token, or the type of this token can be converted to the type of the specified token, without loss of information. The type of the returned token is one of the above two types that allows lossless conversion from the other. If the specified token is a matrix, its number of rows should be the same as this token's number of columns.
 * @param t The token to add to this token.
 * @return A new token containing the result.
 * @exception IllegalActionException If the specified token isnot of a type that can be added to this token in a lossless fashion.
 */
public final Token multiply(final Token t) throws IllegalActionException {
  int compare=TypeLattice.compare(this,t);
  if (compare == CPO.INCOMPARABLE) {
    String msg=""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ t.getClass().getName();
    throw new IllegalActionException(msg);
  }
 else   if (compare == CPO.LOWER) {
    return t.multiplyReverse(this);
  }
 else {
    Complex[][] result=null;
    if (t.getType() == BaseType.COMPLEX) {
      Complex c=((ComplexToken)t).complexValue();
      result=ComplexMatrixMath.multiply(_value,c);
    }
 else     if (t instanceof ScalarToken) {
      double scalar=((ScalarToken)t).doubleValue();
      result=ComplexMatrixMath.multiply(_value,scalar);
    }
 else {
      ComplexMatrixToken tem=(ComplexMatrixToken)this.convert(t);
      if (tem.getRowCount() != _columnCount) {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + _columnCount + ""String_Node_Str""+ tem.getRowCount()+ ""String_Node_Str"");
      }
      result=ComplexMatrixMath.multiply(_value,tem._getInternalComplexMatrix());
    }
    return new ComplexMatrixToken(result,DO_NOT_COPY);
  }
}"
75906,"/** 
 * Given a destination name, return a NamedObj that matches that destination.
 * @param name The name of the destination, or null if none is found.
 * @return An object (like a port or a variable) with the specified name.
 * @exception IllegalActionException If the associated FSMActordoes not have a destination with the specified name.
 */
protected NamedObj _getDestination(String name) throws IllegalActionException {
  Transition transition=(Transition)getContainer();
  if (transition == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Entity fsm=(Entity)transition.getContainer();
  if (fsm == null) {
    throw new IllegalActionException(this,transition,""String_Node_Str"");
  }
  IOPort port=(IOPort)fsm.getPort(name);
  if (port == null) {
    Attribute var=fsm.getAttribute(name);
    if (var == null) {
      int period=name.indexOf(""String_Node_Str"");
      if (period > 0) {
        String refinementName=name.substring(0,period);
        String entryName=name.substring(period + 1);
        Nameable fsmContainer=fsm.getContainer();
        if (fsmContainer instanceof CompositeEntity) {
          Entity refinement=((CompositeEntity)fsmContainer).getEntity(refinementName);
          if (refinement != null) {
            Attribute entry=refinement.getAttribute(refinementName);
            if (entry instanceof Variable) {
              return entry;
            }
          }
        }
      }
      throw new IllegalActionException(fsm,this,""String_Node_Str"" + name);
    }
 else {
      if (!(var instanceof Variable)) {
        throw new IllegalActionException(fsm,this,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      }
      return var;
    }
  }
 else {
    if (!port.isOutput()) {
      throw new IllegalActionException(fsm,this,""String_Node_Str"" + name);
    }
    return port;
  }
}","/** 
 * Given a destination name, return a NamedObj that matches that destination.
 * @param name The name of the destination, or null if none is found.
 * @return An object (like a port or a variable) with the specified name.
 * @exception IllegalActionException If the associated FSMActordoes not have a destination with the specified name.
 */
protected NamedObj _getDestination(String name) throws IllegalActionException {
  Transition transition=(Transition)getContainer();
  if (transition == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Entity fsm=(Entity)transition.getContainer();
  if (fsm == null) {
    throw new IllegalActionException(this,transition,""String_Node_Str"");
  }
  IOPort port=(IOPort)fsm.getPort(name);
  if (port == null) {
    Attribute var=fsm.getAttribute(name);
    if (var == null) {
      int period=name.indexOf(""String_Node_Str"");
      if (period > 0) {
        String refinementName=name.substring(0,period);
        String entryName=name.substring(period + 1);
        Nameable fsmContainer=fsm.getContainer();
        if (fsmContainer instanceof CompositeEntity) {
          Entity refinement=((CompositeEntity)fsmContainer).getEntity(refinementName);
          if (refinement != null) {
            Attribute entry=refinement.getAttribute(entryName);
            if (entry instanceof Variable) {
              return entry;
            }
          }
        }
      }
      throw new IllegalActionException(fsm,this,""String_Node_Str"" + name);
    }
 else {
      if (!(var instanceof Variable)) {
        throw new IllegalActionException(fsm,this,""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
      }
      return var;
    }
  }
 else {
    if (!port.isOutput()) {
      throw new IllegalActionException(fsm,this,""String_Node_Str"" + name);
    }
    return port;
  }
}"
75907,"/** 
 * Return the refinement of this state. The name of the refinement is specified by the <i>refinementName</i> attribute. The refinement must be a TypedActor and have the same container as the FSMActor containing this state, otherwise an exception is thrown. This method is read-synchronized on the workspace.
 * @return The refinement of this state.
 * @exception IllegalActionException If the specified refinementcannot be found.
 */
public TypedActor getRefinement() throws IllegalActionException {
  if (_refinementVersion == workspace().getVersion()) {
    return _refinement;
  }
  try {
    workspace().getReadAccess();
    String name=refinementName.getExpression();
    if (name != null && name != ""String_Node_Str"") {
      Nameable cont=getContainer();
      TypedCompositeActor contContainer=(TypedCompositeActor)cont.getContainer();
      _refinement=(TypedActor)contContainer.getEntity(name);
      if (_refinement == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ contContainer.getFullName());
      }
    }
 else {
      _refinement=null;
    }
    _refinementVersion=workspace().getVersion();
    return _refinement;
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Return the refinement of this state. The name of the refinement is specified by the <i>refinementName</i> attribute. The refinement must be a TypedActor and have the same container as the FSMActor containing this state, otherwise an exception is thrown. This method is read-synchronized on the workspace.
 * @return The refinement of this state.
 * @exception IllegalActionException If the specified refinementcannot be found.
 */
public TypedActor getRefinement() throws IllegalActionException {
  if (_refinementVersion == workspace().getVersion()) {
    return _refinement;
  }
  try {
    workspace().getReadAccess();
    String name=refinementName.getExpression();
    if (name != null && !name.trim().equals(""String_Node_Str"")) {
      Nameable cont=getContainer();
      TypedCompositeActor contContainer=(TypedCompositeActor)cont.getContainer();
      _refinement=(TypedActor)contContainer.getEntity(name);
      if (_refinement == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ contContainer.getFullName());
      }
    }
 else {
      _refinement=null;
    }
    _refinementVersion=workspace().getVersion();
    return _refinement;
  }
  finally {
    workspace().doneReading();
  }
}"
75908,"/** 
 * Read the model from the <i>modelURL</i> applet parameter.
 * @param workspace The workspace in which to create the model.
 * @return A model.
 * @throws Exception If something goes wrong.
 */
protected CompositeActor _createModel(Workspace workspace) throws Exception {
  String modelURL=getParameter(""String_Node_Str"");
  if (modelURL == null) {
    modelURL=getParameter(""String_Node_Str"");
    if (modelURL == null) {
      throw new Exception(""String_Node_Str"");
    }
  }
  MoMLParser parser=new MoMLParser();
  URL docBase=getDocumentBase();
  URL xmlFile=new URL(docBase,modelURL);
  _manager=null;
  CompositeActor result=null;
  NamedObj toplevel=parser.parse(docBase,xmlFile);
  _workspace=toplevel.workspace();
  if (toplevel instanceof CompositeActor) {
    result=(CompositeActor)toplevel;
    _manager=result.getManager();
    if (_manager == null) {
      _manager=new Manager(_workspace,""String_Node_Str"");
      result.setManager(_manager);
    }
    _manager.addExecutionListener(this);
  }
 else {
    throw new Exception(""String_Node_Str"");
  }
  return result;
}","/** 
 * Read the model from the <i>modelURL</i> applet parameter.
 * @param workspace The workspace in which to create the model.
 * @return A model.
 * @throws Exception If something goes wrong.
 */
protected NamedObj _createModel(Workspace workspace) throws Exception {
  String modelURL=getParameter(""String_Node_Str"");
  if (modelURL == null) {
    modelURL=getParameter(""String_Node_Str"");
    if (modelURL == null) {
      throw new Exception(""String_Node_Str"");
    }
  }
  MoMLParser parser=new MoMLParser();
  URL docBase=getDocumentBase();
  URL xmlFile=new URL(docBase,modelURL);
  _manager=null;
  NamedObj toplevel=parser.parse(docBase,xmlFile);
  _workspace=toplevel.workspace();
  if (toplevel instanceof CompositeActor) {
    CompositeActor result=(CompositeActor)toplevel;
    _manager=result.getManager();
    if (_manager == null) {
      _manager=new Manager(_workspace,""String_Node_Str"");
      result.setManager(_manager);
    }
    _manager.addExecutionListener(this);
  }
  return toplevel;
}"
75909,"/** 
 * Initialize the applet. This method is called by the browser or applet viewer to inform this applet that it has been loaded into the system. It is always called before the first time that the start() method is called. In this base class, this method creates a new workspace, and instantiates in it the model whose class name is given by the <i>modelClass</i> applet parameter.  If that model does not contain a manager, then this method creates one for it.
 */
public void init(){
  super.init();
  _setupOK=true;
  _workspace=new Workspace(getClass().getName());
  try {
    _toplevel=_createModel(_workspace);
    if (_toplevel.getManager() == null) {
      _manager=new Manager(_workspace,""String_Node_Str"");
      _manager.addExecutionListener(this);
      _toplevel.setManager(_manager);
    }
 else {
      _manager=_toplevel.getManager();
    }
  }
 catch (  Exception ex) {
    _setupOK=false;
    report(""String_Node_Str"",ex);
  }
  _createView();
}","/** 
 * Initialize the applet. This method is called by the browser or applet viewer to inform this applet that it has been loaded into the system. It is always called before the first time that the start() method is called. In this base class, this method creates a new workspace, and instantiates in it the model whose class name is given by the <i>modelClass</i> applet parameter.  If that model does not contain a manager, then this method creates one for it.
 */
public void init(){
  super.init();
  _setupOK=true;
  _workspace=new Workspace(getClass().getName());
  try {
    _toplevel=_createModel(_workspace);
    if (_toplevel instanceof CompositeActor) {
      if (((CompositeActor)_toplevel).getManager() == null) {
        _manager=new Manager(_workspace,""String_Node_Str"");
        _manager.addExecutionListener(this);
        ((CompositeActor)_toplevel).setManager(_manager);
      }
 else {
        _manager=((CompositeActor)_toplevel).getManager();
      }
    }
  }
 catch (  Exception ex) {
    _setupOK=false;
    report(""String_Node_Str"",ex);
  }
  _createView();
}"
75910,"/** 
 * Create a model.  In this base class, we check to see whether the applet has a parameter <i>modelClass</i>, and if so, then we instantiate the class specified in that parameter.  If not, then we create an empty instance of CompositeActor. It is required that the class specified in the modelClass parameter have a constructor that takes one argument, an instance of Workspace. In either case, if the resulting model does not have a manager, then we give it a manager.
 * @param workspace The workspace in which to create the model.
 * @return A model.
 * @throws Exception If something goes wrong.  This is a broadexception to allow derived classes wide lattitude as to which exception to throw.
 */
protected CompositeActor _createModel(Workspace workspace) throws Exception {
  CompositeActor result=null;
  String modelSpecification=getParameter(""String_Node_Str"");
  if (modelSpecification != null) {
    Object[] arguments=new Object[1];
    arguments[0]=workspace;
    Class modelClass=Class.forName(modelSpecification);
    Constructor[] constructors=modelClass.getConstructors();
    boolean foundConstructor=false;
    for (int i=0; i < constructors.length; i++) {
      Constructor constructor=constructors[i];
      Class[] parameterTypes=constructor.getParameterTypes();
      if (parameterTypes.length != arguments.length)       continue;
      boolean match=true;
      for (int j=0; j < parameterTypes.length; j++) {
        if (!(parameterTypes[j].isInstance(arguments[j]))) {
          match=false;
          break;
        }
      }
      if (match) {
        result=(CompositeActor)constructor.newInstance(arguments);
        foundConstructor=true;
      }
    }
    if (!foundConstructor) {
      throw new IllegalActionException(""String_Node_Str"" + modelSpecification);
    }
  }
  if (result == null) {
    if (_toplevel == null) {
      throw new Exception(""String_Node_Str"");
    }
 else {
      return _toplevel;
    }
  }
  return result;
}","/** 
 * Create a model.  In this base class, we check to see whether the applet has a parameter <i>modelClass</i>, and if so, then we instantiate the class specified in that parameter.  If not, then we create an empty instance of NamedObj. It is required that the class specified in the modelClass parameter have a constructor that takes one argument, an instance of Workspace. In either case, if the resulting model does not have a manager, then we give it a manager.
 * @param workspace The workspace in which to create the model.
 * @return A model.
 * @throws Exception If something goes wrong.  This is a broadexception to allow derived classes wide lattitude as to which exception to throw.
 */
protected NamedObj _createModel(Workspace workspace) throws Exception {
  NamedObj result=null;
  String modelSpecification=getParameter(""String_Node_Str"");
  if (modelSpecification != null) {
    Object[] arguments=new Object[1];
    arguments[0]=workspace;
    Class modelClass=Class.forName(modelSpecification);
    Constructor[] constructors=modelClass.getConstructors();
    boolean foundConstructor=false;
    for (int i=0; i < constructors.length; i++) {
      Constructor constructor=constructors[i];
      Class[] parameterTypes=constructor.getParameterTypes();
      if (parameterTypes.length != arguments.length)       continue;
      boolean match=true;
      for (int j=0; j < parameterTypes.length; j++) {
        if (!(parameterTypes[j].isInstance(arguments[j]))) {
          match=false;
          break;
        }
      }
      if (match) {
        result=(NamedObj)constructor.newInstance(arguments);
        foundConstructor=true;
      }
    }
    if (!foundConstructor) {
      throw new IllegalActionException(""String_Node_Str"" + modelSpecification);
    }
  }
  if (result == null) {
    if (_toplevel == null) {
      throw new Exception(""String_Node_Str"");
    }
 else {
      return _toplevel;
    }
  }
  return result;
}"
75911,"/** 
 * Create a ModelPane to control execution of the model and display its results.  Derived classes may override this to do something different.
 */
protected void _createView(){
  String orientationSpec=getParameter(""String_Node_Str"");
  int orientation=ModelPane.VERTICAL;
  if (orientationSpec != null) {
    if (orientationSpec.trim().toLowerCase().equals(""String_Node_Str"")) {
      orientation=ModelPane.HORIZONTAL;
    }
 else     if (orientationSpec.trim().toLowerCase().equals(""String_Node_Str"")) {
      orientation=ModelPane.CONTROLS_ONLY;
    }
  }
  String controlsSpec=getParameter(""String_Node_Str"");
  int controls=ModelPane.BUTTONS;
  if (controlsSpec != null) {
    controls=0;
    StringTokenizer tokenizer=new StringTokenizer(controlsSpec,""String_Node_Str"");
    while (tokenizer.hasMoreTokens()) {
      String controlSpec=tokenizer.nextToken().trim().toLowerCase();
      if (controlSpec.equals(""String_Node_Str"")) {
        controls=controls | ModelPane.BUTTONS;
      }
 else       if (controlSpec.equals(""String_Node_Str"")) {
        controls=controls | ModelPane.TOP_PARAMETERS;
      }
 else       if (controlSpec.equals(""String_Node_Str"")) {
        controls=controls | ModelPane.DIRECTOR_PARAMETERS;
      }
 else       if (controlSpec.equals(""String_Node_Str"")) {
        controls=0;
      }
 else {
        report(""String_Node_Str"" + controlSpec);
      }
    }
  }
  ModelPane pane=new ModelPane(_toplevel,orientation,controls);
  pane.setBackground(null);
  getContentPane().add(pane);
}","/** 
 * Create a ModelPane to control execution of the model and display its results.  Derived classes may override this to do something different.
 */
protected void _createView(){
  if (!(_toplevel instanceof CompositeActor))   return;
  String orientationSpec=getParameter(""String_Node_Str"");
  int orientation=ModelPane.VERTICAL;
  if (orientationSpec != null) {
    if (orientationSpec.trim().toLowerCase().equals(""String_Node_Str"")) {
      orientation=ModelPane.HORIZONTAL;
    }
 else     if (orientationSpec.trim().toLowerCase().equals(""String_Node_Str"")) {
      orientation=ModelPane.CONTROLS_ONLY;
    }
  }
  String controlsSpec=getParameter(""String_Node_Str"");
  int controls=ModelPane.BUTTONS;
  if (controlsSpec != null) {
    controls=0;
    StringTokenizer tokenizer=new StringTokenizer(controlsSpec,""String_Node_Str"");
    while (tokenizer.hasMoreTokens()) {
      String controlSpec=tokenizer.nextToken().trim().toLowerCase();
      if (controlSpec.equals(""String_Node_Str"")) {
        controls=controls | ModelPane.BUTTONS;
      }
 else       if (controlSpec.equals(""String_Node_Str"")) {
        controls=controls | ModelPane.TOP_PARAMETERS;
      }
 else       if (controlSpec.equals(""String_Node_Str"")) {
        controls=controls | ModelPane.DIRECTOR_PARAMETERS;
      }
 else       if (controlSpec.equals(""String_Node_Str"")) {
        controls=0;
      }
 else {
        report(""String_Node_Str"" + controlSpec);
      }
    }
  }
  ModelPane pane=new ModelPane(((CompositeActor)_toplevel),orientation,controls);
  pane.setBackground(null);
  getContentPane().add(pane);
}"
75912,"/** 
 * Consume the inputs and produce the outputs of the FIR filter.
 * @exception IllegalActionException If parameter values are invalid,or if there is no director, or if runtime type conflicts occur.
 */
public void fire() throws IllegalActionException {
  if (_reinitializeNeeded)   _reinitialize();
  int phase=_dec - _decPhase - 1;
  if (--_mostRecent < 0)   _mostRecent=_data.length - 1;
  _data[_mostRecent]=input.get(0);
  for (int inC=1; inC <= _dec; inC++) {
    while (phase < _interp) {
      _outToken=_zero;
      for (int i=0; i < _phaseLength; i++) {
        int tapsIndex=i * _interp + phase;
        int dataIndex=(_mostRecent + _dec - inC + i) % (_data.length);
        if (tapsIndex < _taps.length) {
          _tapItem=_taps[tapsIndex];
          _dataItem=_data[dataIndex];
          _dataItem=_tapItem.multiply(_dataItem);
          _outToken=_outToken.add(_dataItem);
        }
 else {
          _dataItem=_data[dataIndex];
          _outToken=_outToken.add(_dataItem);
        }
      }
      output.send(0,_outToken);
      phase+=_dec;
    }
    phase-=_interp;
  }
}","/** 
 * Consume the inputs and produce the outputs of the FIR filter.
 * @exception IllegalActionException If parameter values are invalid,or if there is no director, or if runtime type conflicts occur.
 */
public void fire() throws IllegalActionException {
  if (_reinitializeNeeded)   _reinitialize();
  int phase=_dec - _decPhase - 1;
  if (--_mostRecent < 0)   _mostRecent=_data.length - 1;
  _data[_mostRecent]=input.get(0);
  for (int inC=1; inC <= _dec; inC++) {
    while (phase < _interp) {
      _outToken=_zero;
      for (int i=0; i < _phaseLength; i++) {
        int tapsIndex=i * _interp + phase;
        int dataIndex=(_mostRecent + _dec - inC + i) % (_data.length);
        if (tapsIndex < _taps.length) {
          _tapItem=_taps[tapsIndex];
          _dataItem=_data[dataIndex];
          _dataItem=_tapItem.multiply(_dataItem);
          _outToken=_outToken.add(_dataItem);
        }
      }
      output.send(0,_outToken);
      phase+=_dec;
    }
    phase-=_interp;
  }
}"
75913,"private void _reinitialize() throws IllegalActionException {
  if (_decPhase >= _dec) {
    throw new IllegalActionException(this,""String_Node_Str"" + _decPhase + ""String_Node_Str""+ _dec+ ""String_Node_Str"");
  }
  _phaseLength=(int)(_taps.length / _interp);
  if ((_taps.length % _interp) != 0)   _phaseLength++;
  int datalength=_taps.length / _interp;
  if (_taps.length % _interp != 0)   datalength++;
  if (_data == null || _data.length != datalength) {
    _data=new Token[datalength];
    for (int i=0; i < datalength; i++) {
      _data[i]=_zero;
    }
    _mostRecent=datalength;
  }
}","private void _reinitialize() throws IllegalActionException {
  if (_decPhase >= _dec) {
    throw new IllegalActionException(this,""String_Node_Str"" + _decPhase + ""String_Node_Str""+ _dec+ ""String_Node_Str"");
  }
  _phaseLength=(int)(_taps.length / _interp);
  if ((_taps.length % _interp) != 0)   _phaseLength++;
  if (_data == null || _data.length != _phaseLength) {
    _data=new Token[_phaseLength];
    for (int i=0; i < _phaseLength; i++) {
      _data[i]=_zero;
    }
    _mostRecent=_phaseLength;
  }
  _reinitializeNeeded=false;
}"
75914,"public void setFont(Font font){
  int size=font.getSize();
  boolean bold=font.isBold();
  if (bold) {
    _buffer.append(""String_Node_Str"");
  }
 else {
    _buffer.append(""String_Node_Str"");
  }
  _buffer.append(""String_Node_Str"" + size + ""String_Node_Str"");
  _currentFont=font;
}","public void setFont(Font font){
  if (font == null)   return;
  int size=font.getSize();
  boolean bold=font.isBold();
  if (bold) {
    _buffer.append(""String_Node_Str"");
  }
 else {
    _buffer.append(""String_Node_Str"");
  }
  _buffer.append(""String_Node_Str"" + size + ""String_Node_Str"");
  _currentFont=font;
}"
75915,"/** 
 * Construct a plot box with a default configuration. 
 */
public PlotBox(){
  setOpaque(true);
  setLayout(new FlowLayout(FlowLayout.RIGHT,2,2));
  addMouseListener(new ZoomListener());
  addKeyListener(new CommandListener());
  addMouseMotionListener(new DragListener());
  _measureFonts();
  requestFocus();
}","/** 
 * Construct a plot box with a default configuration. 
 */
public PlotBox(){
  setOpaque(true);
  setLayout(new FlowLayout(FlowLayout.RIGHT,2,2));
  addMouseListener(new ZoomListener());
  addKeyListener(new CommandListener());
  addMouseMotionListener(new DragListener());
  _measureFonts();
}"
75916,"/** 
 * Rescale so that the data that is currently plotted just fits. This is done based on the protected variables _xBottom, _xTop, _yBottom, and _yTop.  It is up to derived classes to ensure that variables are valid. This method calls repaint(), which eventually causes the display to be updated.
 */
public synchronized void fillPlot(){
  setXRange(_xBottom,_xTop);
  setYRange(_yBottom,_yTop);
  repaint();
  requestFocus();
}","/** 
 * Rescale so that the data that is currently plotted just fits. This is done based on the protected variables _xBottom, _xTop, _yBottom, and _yTop.  It is up to derived classes to ensure that variables are valid. This method calls repaint(), which eventually causes the display to be updated.
 */
public synchronized void fillPlot(){
  setXRange(_xBottom,_xTop);
  setYRange(_yBottom,_yTop);
  repaint();
}"
75917,"/** 
 * Export a description of the plot. Currently, only EPS is supported.  But in the future, this may cause a dialog box to open to allow the user to select a format.  If the argument is null, then the description goes to the clipboard.  Otherwise, it goes to the specified file. To send it to standard output, use <code>System.out</code> as an argument.
 * @param file A file writer to which to send the description.
 */
public synchronized void export(OutputStream out){
  EPSGraphics g=new EPSGraphics(out,_width,_height);
  _drawPlot(g,false);
  g.showpage();
}","/** 
 * Export a description of the plot. Currently, only EPS is supported.  But in the future, this may cause a dialog box to open to allow the user to select a format.  If the argument is null, then the description goes to the clipboard.  Otherwise, it goes to the specified file. To send it to standard output, use <code>System.out</code> as an argument.
 * @param file A file writer to which to send the description.
 */
public synchronized void export(OutputStream out){
  try {
    EPSGraphics g=new EPSGraphics(out,_width,_height);
    _drawPlot(g,false);
    g.showpage();
  }
 catch (  RuntimeException ex) {
    String message=""String_Node_Str"" + ex.getMessage();
    JOptionPane.showMessageDialog(this,message,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    throw (RuntimeException)ex.fillInStackTrace();
  }
}"
75918,"/** 
 * If the argument is true, make a fill button visible at the upper right.  This button auto-scales the plot. NOTE: The button may infringe on the title space, if the title is long.  In an application, it is preferable to provide a menu with the fill command.  This way, when printing the plot, the printed plot will not have a spurious button.  Thus, this method should be used only by applets, which normally do not have menus. This method should only be called from within the event dispatch thread, since it interacts with swing.
 */
public synchronized void setButtons(boolean visible){
  if (_resetButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    if (img != null) {
      ImageIcon resetIcon=new ImageIcon(img);
      _resetButton=new JButton(resetIcon);
      _resetButton.setBorderPainted(false);
    }
 else {
      _resetButton=new JButton(""String_Node_Str"");
    }
    _resetButton.setPreferredSize(new Dimension(20,20));
    _resetButton.setToolTipText(""String_Node_Str"");
    _resetButton.addActionListener(new ButtonListener());
    add(_resetButton);
  }
  _resetButton.setVisible(visible);
  if (_formatButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    if (img != null) {
      ImageIcon formatIcon=new ImageIcon(img);
      _formatButton=new JButton(formatIcon);
      _formatButton.setBorderPainted(false);
    }
 else {
      _formatButton=new JButton(""String_Node_Str"");
    }
    _formatButton.setPreferredSize(new Dimension(20,20));
    _formatButton.setToolTipText(""String_Node_Str"");
    _formatButton.addActionListener(new ButtonListener());
    add(_formatButton);
  }
  _formatButton.setVisible(visible);
  if (_fillButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    if (img != null) {
      ImageIcon fillIcon=new ImageIcon(img);
      _fillButton=new JButton(fillIcon);
      _fillButton.setBorderPainted(false);
    }
 else {
      _fillButton=new JButton(""String_Node_Str"");
    }
    _fillButton.setPreferredSize(new Dimension(20,20));
    _fillButton.setToolTipText(""String_Node_Str"");
    _fillButton.addActionListener(new ButtonListener());
    add(_fillButton);
  }
  _fillButton.setVisible(visible);
  requestFocus();
}","/** 
 * If the argument is true, make a fill button visible at the upper right.  This button auto-scales the plot. NOTE: The button may infringe on the title space, if the title is long.  In an application, it is preferable to provide a menu with the fill command.  This way, when printing the plot, the printed plot will not have a spurious button.  Thus, this method should be used only by applets, which normally do not have menus. This method should only be called from within the event dispatch thread, since it interacts with swing.
 */
public synchronized void setButtons(boolean visible){
  if (_resetButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    if (img != null) {
      ImageIcon resetIcon=new ImageIcon(img);
      _resetButton=new JButton(resetIcon);
      _resetButton.setBorderPainted(false);
    }
 else {
      _resetButton=new JButton(""String_Node_Str"");
    }
    _resetButton.setPreferredSize(new Dimension(20,20));
    _resetButton.setToolTipText(""String_Node_Str"");
    _resetButton.addActionListener(new ButtonListener());
    add(_resetButton);
  }
  _resetButton.setVisible(visible);
  if (_formatButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    if (img != null) {
      ImageIcon formatIcon=new ImageIcon(img);
      _formatButton=new JButton(formatIcon);
      _formatButton.setBorderPainted(false);
    }
 else {
      _formatButton=new JButton(""String_Node_Str"");
    }
    _formatButton.setPreferredSize(new Dimension(20,20));
    _formatButton.setToolTipText(""String_Node_Str"");
    _formatButton.addActionListener(new ButtonListener());
    add(_formatButton);
  }
  _formatButton.setVisible(visible);
  if (_fillButton == null) {
    URL img=getClass().getResource(""String_Node_Str"");
    if (img != null) {
      ImageIcon fillIcon=new ImageIcon(img);
      _fillButton=new JButton(fillIcon);
      _fillButton.setBorderPainted(false);
    }
 else {
      _fillButton=new JButton(""String_Node_Str"");
    }
    _fillButton.setPreferredSize(new Dimension(20,20));
    _fillButton.setToolTipText(""String_Node_Str"");
    _fillButton.addActionListener(new ButtonListener());
    add(_fillButton);
  }
  _fillButton.setVisible(visible);
}"
75919,"/** 
 * Paint the component contents, which in this base class is only the axes.
 * @param graphics The graphics context.
 */
public void paintComponent(Graphics graphics){
  super.paintComponent(graphics);
  _drawPlot(graphics,true);
  requestFocus();
}","/** 
 * Paint the component contents, which in this base class is only the axes.
 * @param graphics The graphics context.
 */
public void paintComponent(Graphics graphics){
  super.paintComponent(graphics);
  _drawPlot(graphics,true);
}"
75920,"public void mouseClicked(MouseEvent event){
}","public void mouseClicked(MouseEvent event){
  requestFocus();
}"
75921,"/** 
 * Create a background figure based on this icon.  The background figure will be painted with each graphic element that this icon contains.
 * @return A figure for this icon.
 */
public Figure createBackgroundFigure(){
  NamedObj container=(NamedObj)getContainer();
  SingletonConfigurableAttribute description=(SingletonConfigurableAttribute)container.getAttribute(""String_Node_Str"");
  if (_description != description) {
    if (_description != null) {
      _description.removeValueListener(this);
    }
    _description=description;
    if (_description != null) {
      _description.addValueListener(this);
    }
    _updatePaintedList();
  }
  if (_paintedList == null) {
    return _createDefaultBackgroundFigure();
  }
 else {
    return new PaintedFigure(_paintedList);
  }
}","/** 
 * Create a background figure based on this icon.  The background figure will be painted with each graphic element that this icon contains.
 * @return A figure for this icon.
 */
public Figure createBackgroundFigure(){
  NamedObj container=(NamedObj)getContainer();
  SingletonConfigurableAttribute description=(SingletonConfigurableAttribute)container.getAttribute(""String_Node_Str"");
  if (_description != description) {
    if (_description != null) {
      _description.removeValueListener(this);
    }
    _description=description;
    if (_description != null) {
      _description.addValueListener(this);
    }
    _recreateFigure();
  }
  paintedList();
  if (_paintedList == null) {
    return _createDefaultBackgroundFigure();
  }
 else {
    return new PaintedFigure(_paintedList);
  }
}"
75922,"/** 
 * React to the fact that the value of an attribute named ""_iconDescription"" contained by the same container has changed value by redrawing the figure.
 * @param settable The object that has changed value.
 */
public void valueChanged(Settable settable){
  if (((Nameable)settable).getName().equals(""String_Node_Str"")) {
    _recreateFigure();
    _paintedList=null;
  }
}","/** 
 * React to the fact that the value of an attribute named ""_iconDescription"" contained by the same container has changed value by redrawing the figure.
 * @param settable The object that has changed value.
 */
public void valueChanged(Settable settable){
  if (((Nameable)settable).getName().equals(""String_Node_Str"")) {
    _recreateFigure();
  }
}"
75923,"/** 
 * If the argument is the <i>identifier</i> parameter, then set the title of all contained Tableaux to the value of the parameter; if the argument is the <i>url</i> parameter, then check to see whether it is writable, and call setModifiable() appropriately.
 * @exception IllegalActionException If the base class throws it.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == identifier) {
    Iterator tableaux=entityList(Tableau.class).iterator();
    while (tableaux.hasNext()) {
      Tableau tableau=(Tableau)tableaux.next();
      tableau.setTitle(identifier.getExpression());
    }
  }
 else   if (attribute == url) {
    URL u=url.getURL();
    if (u == null) {
      _modifiableURL=false;
    }
 else {
      String protocol=u.getProtocol();
      if (!(protocol.equals(""String_Node_Str""))) {
        _modifiableURL=false;
      }
 else {
        String filename=u.getFile();
        File file=new File(filename);
        _modifiableURL=file.canWrite();
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the argument is the <i>identifier</i> parameter, then set the title of all contained Tableaux to the value of the parameter; if the argument is the <i>url</i> parameter, then check to see whether it is writable, and call setModifiable() appropriately.
 * @exception IllegalActionException If the base class throws it.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == identifier) {
    Iterator tableaux=entityList(Tableau.class).iterator();
    while (tableaux.hasNext()) {
      Tableau tableau=(Tableau)tableaux.next();
      tableau.setTitle(identifier.getExpression());
    }
  }
 else   if (attribute == url) {
    URL u=url.getURL();
    if (u == null) {
      _modifiableURL=true;
    }
 else {
      String protocol=u.getProtocol();
      if (!(protocol.equals(""String_Node_Str""))) {
        _modifiableURL=false;
      }
 else {
        String filename=u.getFile();
        File file=new File(filename);
        _modifiableURL=file.canWrite();
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75924,"/** 
 * Construct a panel for interacting with the specified Ptolemy II model. The layout argument should be one of HORIZONTAL or VERTICAL; it determines whether the controls are put to the left of, or above the placeable displays.  The show argument should be a bitwise or of any of BUTTONS, TOP_PARAMETERS, or DIRECTOR_PARAMETERS. Or it can be 0, in which case, no controls are shown. If BUTTONS is included, then a panel of buttons, go, pause, resume, and stop, are shown.  If TOP_PARAMETERS is included, then the top-level parameters of the model are included. If DIRECTOR_PARAMETERS is included, then the paramters of the director are included.
 * @param model The model to control.
 * @param layout HORIZONTAL or VERTICAL layout.
 * @param show Indicator of which controls to show.
 */
public ModelPane(final CompositeActor model,int layout,int show){
  if (layout == HORIZONTAL) {
    setLayout(new BoxLayout(this,BoxLayout.X_AXIS));
  }
 else {
    setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  }
  _layout=layout;
  if (show != 0) {
    _controlPanel=new JPanel();
    _controlPanel.setLayout(new BoxLayout(_controlPanel,BoxLayout.Y_AXIS));
    _controlPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
    if ((show & BUTTONS) != 0) {
      _buttonPanel=new JPanel();
      _buttonPanel.setLayout(new BoxLayout(_buttonPanel,BoxLayout.X_AXIS));
      _buttonPanel.setBorder(BorderFactory.createEmptyBorder(10,0,10,0));
      _buttonPanel.setAlignmentX(LEFT_ALIGNMENT);
      _goButton=new JButton(""String_Node_Str"");
      _goButton.setToolTipText(""String_Node_Str"");
      _goButton.setAlignmentX(LEFT_ALIGNMENT);
      _buttonPanel.add(_goButton);
      _buttonPanel.add(Box.createRigidArea(new Dimension(10,0)));
      _goButton.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          startRun();
        }
      }
);
      _pauseButton=new JButton(""String_Node_Str"");
      _pauseButton.setToolTipText(""String_Node_Str"");
      _buttonPanel.add(_pauseButton);
      _buttonPanel.add(Box.createRigidArea(new Dimension(10,0)));
      _pauseButton.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          pauseRun();
        }
      }
);
      _resumeButton=new JButton(""String_Node_Str"");
      _resumeButton.setToolTipText(""String_Node_Str"");
      _buttonPanel.add(_resumeButton);
      _buttonPanel.add(Box.createRigidArea(new Dimension(10,0)));
      _resumeButton.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          resumeRun();
        }
      }
);
      _stopButton=new JButton(""String_Node_Str"");
      _stopButton.setToolTipText(""String_Node_Str"");
      _buttonPanel.add(_stopButton);
      _stopButton.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          stopRun();
        }
      }
);
      _controlPanel.add(_buttonPanel);
      _buttonPanel.setBackground(null);
    }
    add(_controlPanel);
    _controlPanel.setBackground(null);
  }
  _show=show;
  setModel(model);
}","/** 
 * Construct a panel for interacting with the specified Ptolemy II model. The layout argument should be one of HORIZONTAL or VERTICAL; it determines whether the controls are put to the left of, or above the placeable displays.  The show argument should be a bitwise or of any of BUTTONS, TOP_PARAMETERS, or DIRECTOR_PARAMETERS. Or it can be 0, in which case, no controls are shown. If BUTTONS is included, then a panel of buttons, go, pause, resume, and stop, are shown.  If TOP_PARAMETERS is included, then the top-level parameters of the model are included. If DIRECTOR_PARAMETERS is included, then the paramters of the director are included.
 * @param model The model to control.
 * @param layout HORIZONTAL or VERTICAL layout.
 * @param show Indicator of which controls to show.
 */
public ModelPane(final CompositeActor model,int layout,int show){
  if (layout == HORIZONTAL) {
    setLayout(new BoxLayout(this,BoxLayout.X_AXIS));
  }
 else {
    setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  }
  _layout=layout;
  if (show != 0) {
    _controlPanel=new JPanel();
    _controlPanel.setLayout(new BoxLayout(_controlPanel,BoxLayout.Y_AXIS));
    _controlPanel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
    ClickListener clickListener=new ClickListener();
    _controlPanel.addMouseListener(clickListener);
    _controlPanel.addKeyListener(new CommandListener());
    if ((show & BUTTONS) != 0) {
      _buttonPanel=new JPanel();
      _buttonPanel.setLayout(new BoxLayout(_buttonPanel,BoxLayout.X_AXIS));
      _buttonPanel.addMouseListener(clickListener);
      _buttonPanel.setBorder(BorderFactory.createEmptyBorder(10,0,10,0));
      _buttonPanel.setAlignmentX(LEFT_ALIGNMENT);
      _goButton=new JButton(""String_Node_Str"");
      _goButton.setToolTipText(""String_Node_Str"");
      _goButton.setAlignmentX(LEFT_ALIGNMENT);
      _buttonPanel.add(_goButton);
      _buttonPanel.add(Box.createRigidArea(new Dimension(10,0)));
      _goButton.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          startRun();
        }
      }
);
      _pauseButton=new JButton(""String_Node_Str"");
      _pauseButton.setToolTipText(""String_Node_Str"");
      _buttonPanel.add(_pauseButton);
      _buttonPanel.add(Box.createRigidArea(new Dimension(10,0)));
      _pauseButton.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          pauseRun();
        }
      }
);
      _resumeButton=new JButton(""String_Node_Str"");
      _resumeButton.setToolTipText(""String_Node_Str"");
      _buttonPanel.add(_resumeButton);
      _buttonPanel.add(Box.createRigidArea(new Dimension(10,0)));
      _resumeButton.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          resumeRun();
        }
      }
);
      _stopButton=new JButton(""String_Node_Str"");
      _stopButton.setToolTipText(""String_Node_Str"");
      _buttonPanel.add(_stopButton);
      _stopButton.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent evt){
          stopRun();
        }
      }
);
      _controlPanel.add(_buttonPanel);
      _buttonPanel.setBackground(null);
    }
    add(_controlPanel);
    _controlPanel.setBackground(null);
  }
  _show=show;
  setModel(model);
}"
75925,"/** 
 * If the specified effigy already contains a tableau named ""textTableau"", then return that tableau; otherwise, create a new instance of TextEditorTableau in the specified effigy, and name it ""textTableau"" and return that tableau. If the specified effigy is not an instance of TextEffigy, but contains an instance of TextEffigy, then open a tableau for that effigy.  If it is a PtolemyEffigy, then create a text effigy with the MoML representation of the model. Finally, if is not a TextEffigy or a PtolemyEffigy, and it does not contain a TextEffigy, then attempt to open its URL and display its date by creating a text effigy, which will then be contained by the specified effigy. If all of this fails, then do not create a tableau and return null. It is the responsibility of callers of this method to check the return value and call show().
 * @param effigy The effigy.
 * @return A text editor tableau, or null if one cannot befound or created.
 * @exception Exception If the factory should be able to create atableau for the effigy, but something goes wrong.
 */
public Tableau createTableau(Effigy effigy) throws Exception {
  if (effigy instanceof TextEffigy) {
    TextEditorTableau tableau=(TextEditorTableau)effigy.getEntity(""String_Node_Str"");
    if (tableau == null) {
      tableau=new TextEditorTableau((TextEffigy)effigy,""String_Node_Str"");
    }
    tableau.setEditable(effigy.isModifiable());
    return tableau;
  }
 else {
    List effigies=effigy.entityList(TextEffigy.class);
    if (effigies.size() > 0) {
      TextEffigy textEffigy=(TextEffigy)effigies.get(0);
      return createTableau(textEffigy);
    }
 else {
      URL url=effigy.url.getURL();
      TextEffigy textEffigy;
      if (effigy instanceof PtolemyEffigy) {
        String moml=((PtolemyEffigy)effigy).getModel().exportMoML();
        textEffigy=TextEffigy.newTextEffigy(effigy,moml);
      }
 else {
        textEffigy=TextEffigy.newTextEffigy(effigy,url,url);
      }
      TextEditorTableau textTableau=(TextEditorTableau)createTableau(textEffigy);
      textTableau.setEditable(false);
      if (url != null) {
        textEffigy.identifier.setExpression(url.toExternalForm());
      }
      return textTableau;
    }
  }
}","/** 
 * If the specified effigy is a TextEffigy and it already contains a tableau named ""textTableau"", then return that tableau; otherwise, create a new instance of TextEditorTableau in the specified effigy, and name it ""textTableau"" and return that tableau. If the specified effigy is not an instance of TextEffigy, but contains an instance of TextEffigy, then open a tableau for that effigy.  If it is a PtolemyEffigy, then create a text effigy with the MoML representation of the model. Finally, if is not a TextEffigy or a PtolemyEffigy, and it does not contain a TextEffigy, then attempt to open its URL and display its date by creating a text effigy, which will then be contained by the specified effigy. If all of this fails, then do not create a tableau and return null. It is the responsibility of callers of this method to check the return value and call show().
 * @param effigy The effigy.
 * @return A text editor tableau, or null if one cannot befound or created.
 * @exception Exception If the factory should be able to create atableau for the effigy, but something goes wrong.
 */
public Tableau createTableau(Effigy effigy) throws Exception {
  if (effigy instanceof TextEffigy) {
    TextEditorTableau tableau=(TextEditorTableau)effigy.getEntity(""String_Node_Str"");
    if (tableau == null) {
      tableau=new TextEditorTableau((TextEffigy)effigy,""String_Node_Str"");
    }
    tableau.setEditable(effigy.isModifiable());
    return tableau;
  }
 else {
    Iterator effigies=effigy.entityList(TextEffigy.class).iterator();
    while (effigies.hasNext()) {
      TextEffigy textEffigy=(TextEffigy)effigies.next();
      if (textEffigy.getName().equals(""String_Node_Str"")) {
        return createTableau(textEffigy);
      }
    }
    URL url=effigy.url.getURL();
    TextEffigy textEffigy;
    if (effigy instanceof PtolemyEffigy) {
      String moml=((PtolemyEffigy)effigy).getModel().exportMoML();
      textEffigy=TextEffigy.newTextEffigy(effigy,moml);
      textEffigy.setModifiable(false);
      textEffigy.setName(""String_Node_Str"");
    }
 else {
      textEffigy=TextEffigy.newTextEffigy(effigy,url,url);
      textEffigy.setName(""String_Node_Str"");
    }
    TextEditorTableau textTableau=(TextEditorTableau)createTableau(textEffigy);
    if (url != null) {
      textEffigy.identifier.setExpression(url.toExternalForm());
    }
    return textTableau;
  }
}"
75926,"/** 
 * Create a new effigy in the given container by reading the specified URL. If the specified URL is null, then create a blank effigy. The extension of the URL is not checked, so this will open any file. The new effigy will have a new instance of DefaultStyledDocument associated with it.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.  This is ignored in this class.
 * @param in The input URL.
 * @return A new instance of TextEffigy.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public static TextEffigy newTextEffigy(CompositeEntity container,URL base,URL in) throws Exception {
  TextEffigy effigy=new TextEffigy(container,container.uniqueName(""String_Node_Str""));
  Document doc=new DefaultStyledDocument();
  effigy.setDocument(doc);
  if (in != null) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(in.openStream()));
    String line=reader.readLine();
    while (line != null) {
      doc.insertString(doc.getLength(),line + ""String_Node_Str"",null);
      line=reader.readLine();
    }
    reader.close();
    if (in.getProtocol().equals(""String_Node_Str"")) {
      String filename=in.getFile();
      File file=new File(filename);
      if (!file.canWrite()) {
        effigy.setModifiable(false);
      }
    }
 else {
      effigy.setModifiable(false);
    }
  }
  effigy.url.setURL(in);
  return effigy;
}","/** 
 * Create a new effigy in the given container by reading the specified URL. If the specified URL is null, then create a blank effigy. The extension of the URL is not checked, so this will open any file. The new effigy will have a new instance of DefaultStyledDocument associated with it.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.  This is ignored in this class.
 * @param in The input URL.
 * @return A new instance of TextEffigy.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public static TextEffigy newTextEffigy(CompositeEntity container,URL base,URL in) throws Exception {
  TextEffigy effigy=new TextEffigy(container,container.uniqueName(""String_Node_Str""));
  Document doc=new DefaultStyledDocument();
  effigy.setDocument(doc);
  if (in != null) {
    BufferedReader reader=new BufferedReader(new InputStreamReader(in.openStream()));
    String line=reader.readLine();
    while (line != null) {
      doc.insertString(doc.getLength(),line + ""String_Node_Str"",null);
      line=reader.readLine();
    }
    reader.close();
    if (in.getProtocol().equals(""String_Node_Str"")) {
      String filename=in.getFile();
      File file=new File(filename);
      if (!file.canWrite()) {
        effigy.setModifiable(false);
      }
    }
 else {
      effigy.setModifiable(false);
    }
  }
 else {
    effigy.setModifiable(true);
  }
  effigy.url.setURL(in);
  return effigy;
}"
75927,"/** 
 * Print out the current state.
 */
public String toString(){
  return new String(""String_Node_Str"" + getManager() + ""String_Node_Str""+ getDescription());
}","/** 
 * Print out the current state.
 */
public String toString(){
  return ""String_Node_Str"" + getDescription();
}"
75928,"/** 
 * Construct a configurer for the specified object.
 * @param object The object to configure.
 */
public Configurer(final NamedObj object){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  _object=object;
  Iterator params=object.attributeList(Settable.class).iterator();
  while (params.hasNext()) {
    Settable param=(Settable)params.next();
    if (param.getVisibility() == Settable.FULL) {
      _originalValues.put(param.getName(),param.getExpression());
    }
  }
  boolean foundOne=false;
  Iterator editors=object.attributeList(EditorPaneFactory.class).iterator();
  while (editors.hasNext()) {
    foundOne=true;
    EditorPaneFactory editor=(EditorPaneFactory)editors.next();
    Component pane=editor.createEditorPane();
    add(pane);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
  if (!foundOne) {
    Component pane=EditorPaneFactory.createEditorPane(object);
    add(pane);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
}","/** 
 * Construct a configurer for the specified object.
 * @param object The object to configure.
 */
public Configurer(final NamedObj object){
  setLayout(new BoxLayout(this,BoxLayout.Y_AXIS));
  _object=object;
  Iterator params=object.attributeList(Settable.class).iterator();
  while (params.hasNext()) {
    Settable param=(Settable)params.next();
    if (param.getVisibility() == Settable.FULL) {
      _originalValues.put(param.getName(),param.getExpression());
    }
  }
  boolean foundOne=false;
  Iterator editors=object.attributeList(EditorPaneFactory.class).iterator();
  while (editors.hasNext()) {
    foundOne=true;
    EditorPaneFactory editor=(EditorPaneFactory)editors.next();
    Component pane=editor.createEditorPane();
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
  if (!foundOne) {
    Component pane=EditorPaneFactory.createEditorPane(object);
    add(pane);
    pane.setBackground(null);
    if (pane instanceof CloseListener) {
      _closeListeners.add(pane);
    }
  }
}"
75929,"/** 
 * Read the model from the <i>model</i> applet parameter.
 * @return A model.
 * @throws Exception If something goes wrong.
 */
protected CompositeActor _createModel() throws Exception {
  String modelURL=getParameter(""String_Node_Str"");
  if (modelURL == null) {
    throw new Exception(""String_Node_Str"");
  }
  MoMLParser parser=new MoMLParser();
  URL docBase=getDocumentBase();
  URL xmlFile=new URL(docBase,modelURL);
  _manager=null;
  CompositeActor result=null;
  NamedObj toplevel=parser.parse(docBase,xmlFile);
  _workspace=toplevel.workspace();
  if (toplevel instanceof CompositeActor) {
    result=(CompositeActor)toplevel;
    _manager=result.getManager();
    if (_manager == null) {
      _manager=new Manager(_workspace,""String_Node_Str"");
      result.setManager(_manager);
    }
    _manager.addExecutionListener(this);
  }
 else {
    throw new Exception(""String_Node_Str"");
  }
  return result;
}","/** 
 * Read the model from the <i>model</i> applet parameter.
 * @param workspace The workspace in which to create the model.
 * @return A model.
 * @throws Exception If something goes wrong.
 */
protected CompositeActor _createModel(Workspace workspace) throws Exception {
  String modelURL=getParameter(""String_Node_Str"");
  if (modelURL == null) {
    modelURL=getParameter(""String_Node_Str"");
    if (modelURL == null) {
      throw new Exception(""String_Node_Str"");
    }
  }
  MoMLParser parser=new MoMLParser();
  URL docBase=getDocumentBase();
  URL xmlFile=new URL(docBase,modelURL);
  _manager=null;
  CompositeActor result=null;
  NamedObj toplevel=parser.parse(docBase,xmlFile);
  _workspace=toplevel.workspace();
  if (toplevel instanceof CompositeActor) {
    result=(CompositeActor)toplevel;
    _manager=result.getManager();
    if (_manager == null) {
      _manager=new Manager(_workspace,""String_Node_Str"");
      result.setManager(_manager);
    }
    _manager.addExecutionListener(this);
  }
 else {
    throw new Exception(""String_Node_Str"");
  }
  return result;
}"
75930,"/** 
 * Initialize the applet. This method is called by the browser or applet viewer to inform this applet that it has been loaded into the system. It is always called before the first time that the start() method is called. In this base class, this method creates a new workspace, and instantiates in it the model whose class name is given by the <i>modelClass</i> applet parameter.  If that model does not contain a manager, then this method creates one for it.
 */
public void init(){
  super.init();
  _setupOK=true;
  _workspace=new Workspace(getClass().getName());
  try {
    _toplevel=_createModel();
  }
 catch (  Exception ex) {
    _setupOK=false;
    report(""String_Node_Str"",ex);
  }
  _createView();
}","/** 
 * Initialize the applet. This method is called by the browser or applet viewer to inform this applet that it has been loaded into the system. It is always called before the first time that the start() method is called. In this base class, this method creates a new workspace, and instantiates in it the model whose class name is given by the <i>modelClass</i> applet parameter.  If that model does not contain a manager, then this method creates one for it.
 */
public void init(){
  super.init();
  _setupOK=true;
  _workspace=new Workspace(getClass().getName());
  try {
    _toplevel=_createModel(_workspace);
    if (_toplevel.getManager() == null) {
      _manager=new Manager(_workspace,""String_Node_Str"");
      _manager.addExecutionListener(this);
      _toplevel.setManager(_manager);
    }
 else {
      _manager=_toplevel.getManager();
    }
  }
 catch (  Exception ex) {
    _setupOK=false;
    report(""String_Node_Str"",ex);
  }
  _createView();
}"
75931,"/** 
 * Execute the model, if the manager is not currently executing.
 * @exception IllegalActionException Not thrown in this base class.
 */
protected void _go() throws IllegalActionException {
  if (!_setupOK)   return;
  if (_manager.getState() == _manager.IDLE)   _manager.startRun();
}","/** 
 * Execute the model, if the manager is not currently executing. Note that this method is not called if there are button controls on the screen and the user pushes the ""Go"" button.
 * @exception IllegalActionException Not thrown in this base class.
 */
protected void _go() throws IllegalActionException {
  if (!_setupOK)   return;
  if (_manager.getState() == _manager.IDLE)   _manager.startRun();
}"
75932,"/** 
 * Create a model.  In this base class, we check to see whether the applet has a parameter <i>modelClass</i>, and if so, then we instantiate the class specified in that parameter.  If not, then we create an empty instance of CompositeActor. It is required that the class specified in the modelClass parameter have a constructor that takes one argument, an instance of Workspace. In either case, if the resulting model does not have a manager, then we give it a manager.
 * @throws Exception If something goes wrong.
 */
protected CompositeActor _createModel() throws Exception {
  CompositeActor result=null;
  String modelSpecification=getParameter(""String_Node_Str"");
  if (modelSpecification != null) {
    Object[] arguments=new Object[1];
    arguments[0]=_workspace;
    Class modelClass=Class.forName(modelSpecification);
    Constructor[] constructors=modelClass.getConstructors();
    boolean foundConstructor=false;
    for (int i=0; i < constructors.length; i++) {
      Constructor constructor=constructors[i];
      Class[] parameterTypes=constructor.getParameterTypes();
      if (parameterTypes.length != arguments.length)       continue;
      boolean match=true;
      for (int j=0; j < parameterTypes.length; j++) {
        if (!(parameterTypes[j].isInstance(arguments[j]))) {
          match=false;
          break;
        }
      }
      if (match) {
        result=(CompositeActor)constructor.newInstance(arguments);
        foundConstructor=true;
      }
    }
    if (!foundConstructor) {
      throw new IllegalActionException(""String_Node_Str"" + modelSpecification);
    }
  }
  if (result == null) {
    throw new Exception(""String_Node_Str"");
  }
  if (result.getManager() == null) {
    _manager=new Manager(_workspace,""String_Node_Str"");
    _manager.addExecutionListener(this);
    result.setManager(_manager);
  }
 else {
    _manager=result.getManager();
  }
  return result;
}","/** 
 * Create a model.  In this base class, we check to see whether the applet has a parameter <i>modelClass</i>, and if so, then we instantiate the class specified in that parameter.  If not, then we create an empty instance of CompositeActor. It is required that the class specified in the modelClass parameter have a constructor that takes one argument, an instance of Workspace. In either case, if the resulting model does not have a manager, then we give it a manager.
 * @param workspace The workspace in which to create the model.
 * @return A model.
 * @throws Exception If something goes wrong.  This is a broadexception to allow derived classes wide lattitude as to which exception to throw.
 */
protected CompositeActor _createModel(Workspace workspace) throws Exception {
  CompositeActor result=null;
  String modelSpecification=getParameter(""String_Node_Str"");
  if (modelSpecification != null) {
    Object[] arguments=new Object[1];
    arguments[0]=workspace;
    Class modelClass=Class.forName(modelSpecification);
    Constructor[] constructors=modelClass.getConstructors();
    boolean foundConstructor=false;
    for (int i=0; i < constructors.length; i++) {
      Constructor constructor=constructors[i];
      Class[] parameterTypes=constructor.getParameterTypes();
      if (parameterTypes.length != arguments.length)       continue;
      boolean match=true;
      for (int j=0; j < parameterTypes.length; j++) {
        if (!(parameterTypes[j].isInstance(arguments[j]))) {
          match=false;
          break;
        }
      }
      if (match) {
        result=(CompositeActor)constructor.newInstance(arguments);
        foundConstructor=true;
      }
    }
    if (!foundConstructor) {
      throw new IllegalActionException(""String_Node_Str"" + modelSpecification);
    }
  }
  if (result == null) {
    throw new Exception(""String_Node_Str"");
  }
  return result;
}"
75933,"/** 
 * Specify the container into which this plot should be placed. This method needs to be called before the first call to initialize(). Otherwise, the plot will be placed in its own frame. The plot is also placed in its own frame if this method is called with a null argument.  The size of the plot, unfortunately, cannot be effectively determined from the size of the container because the container may not yet be laid out (its size will be zero).  Thus, you will have to explicitly set the size of the plot by calling plot.setSize(). The background of the plot is set equal to that of the container (unless it is null). <p> If configure() has been called (prior to the plot getting created), then the configurations that it specified have been deferred. Those configurations are performed at this time.
 * @param container The container into which to place the plot.
 */
public void place(Container container){
  _container=container;
  _placeCalled=true;
  if (_container == null) {
    plot=new Plot();
    _frame=new PlotFrame(getFullName(),plot);
    _frame.setVisible(true);
  }
 else {
    if (_container instanceof Plot) {
      plot=(Plot)_container;
    }
 else {
      if (plot == null) {
        plot=new Plot();
        plot.setButtons(true);
      }
      _container.add(plot);
      plot.setBackground(null);
    }
  }
  if (_configureSources != null) {
    Iterator sources=_configureSources.iterator();
    Iterator texts=_configureTexts.iterator();
    Iterator bases=_configureBases.iterator();
    while (sources.hasNext()) {
      URL base=(URL)bases.next();
      String source=(String)sources.next();
      String text=(String)texts.next();
      try {
        configure(base,source,text);
      }
 catch (      Exception ex) {
        getManager().notifyListenersOfException(ex);
      }
    }
    _configureSources=null;
    _configureTexts=null;
    _configureBases=null;
  }
  try {
    attributeChanged(legend);
  }
 catch (  IllegalActionException ex) {
  }
}","/** 
 * Specify the container into which this plot should be placed. This method needs to be called before the first call to initialize(). Otherwise, the plot will be placed in its own frame. The plot is also placed in its own frame if this method is called with a null argument.  The size of the plot, unfortunately, cannot be effectively determined from the size of the container because the container may not yet be laid out (its size will be zero).  Thus, you will have to explicitly set the size of the plot by calling plot.setSize(). The background of the plot is set equal to that of the container (unless it is null). <p> If configure() has been called (prior to the plot getting created), then the configurations that it specified have been deferred. Those configurations are performed at this time.
 * @param container The container into which to place the plot.
 */
public void place(Container container){
  _container=container;
  _placeCalled=true;
  if (_container == null) {
    plot=new Plot();
    plot.setButtons(true);
    _frame=new PlotFrame(getFullName(),plot);
    _frame.setVisible(true);
  }
 else {
    if (_container instanceof Plot) {
      plot=(Plot)_container;
      plot.setButtons(true);
    }
 else {
      if (plot == null) {
        plot=new Plot();
      }
      plot.setButtons(true);
      _container.add(plot);
      plot.setBackground(null);
    }
  }
  if (_configureSources != null) {
    Iterator sources=_configureSources.iterator();
    Iterator texts=_configureTexts.iterator();
    Iterator bases=_configureBases.iterator();
    while (sources.hasNext()) {
      URL base=(URL)bases.next();
      String source=(String)sources.next();
      String text=(String)texts.next();
      try {
        configure(base,source,text);
      }
 catch (      Exception ex) {
        getManager().notifyListenersOfException(ex);
      }
    }
    _configureSources=null;
    _configureTexts=null;
    _configureBases=null;
  }
  try {
    attributeChanged(legend);
  }
 catch (  IllegalActionException ex) {
  }
}"
75934,"/** 
 * Set the associated model and add a query box with its top-level parameters, and those of its director, if it has one. All placeable objects in the hierarchy will get placed.
 * @param model The associated model.
 */
public void setModel(CompositeActor model){
  _model=model;
  if (_paramQuery != null) {
    _controlPanel.remove(_paramQuery);
    _paramQuery=null;
  }
  if (_directorQuery != null) {
    _controlPanel.remove(_directorQuery);
    _directorQuery=null;
  }
  if (_displays != null) {
    remove(_displays);
    _displays=null;
  }
  if (model != null) {
    _manager=_model.getManager();
    if ((_show & TOP_PARAMETERS) != 0) {
      List paramList=_model.attributeList(Parameter.class);
      if (paramList.size() > 0) {
        JLabel pTitle=new JLabel(""String_Node_Str"");
        pTitle.setForeground(new Color(0,0,128));
        _controlPanel.add(pTitle);
        _controlPanel.add(Box.createRigidArea(new Dimension(0,8)));
        _paramQuery=new Configurer(model);
        _paramQuery.setAlignmentX(LEFT_ALIGNMENT);
        _paramQuery.setBackground(null);
        _controlPanel.add(_paramQuery);
        if ((_show & DIRECTOR_PARAMETERS) != 0) {
          _controlPanel.add(Box.createRigidArea(new Dimension(0,15)));
        }
      }
    }
    if ((_show & DIRECTOR_PARAMETERS) != 0) {
      Director director=_model.getDirector();
      if (director != null) {
        List dirParamList=director.attributeList(Parameter.class);
        if (dirParamList.size() > 0) {
          JLabel pTitle=new JLabel(""String_Node_Str"");
          pTitle.setForeground(new Color(0,0,128));
          _controlPanel.add(pTitle);
          _controlPanel.add(Box.createRigidArea(new Dimension(0,8)));
          _directorQuery=new Configurer(model);
          _directorQuery.setAlignmentX(LEFT_ALIGNMENT);
          _directorQuery.setBackground(null);
          _controlPanel.add(_directorQuery);
        }
      }
    }
    if (_controlPanel != null && _layout == HORIZONTAL) {
      _controlPanel.add(Box.createVerticalGlue());
    }
    if (_paramQuery != null && _directorQuery != null) {
      Dimension modelSize=_paramQuery.getPreferredSize();
      Dimension directorSize=_directorQuery.getPreferredSize();
      if (directorSize.width > modelSize.width) {
        _paramQuery.setPreferredSize(new Dimension(directorSize.width,modelSize.height));
      }
 else {
        _directorQuery.setPreferredSize(new Dimension(modelSize.width,directorSize.height));
      }
    }
    _displays=new JPanel();
    _displays.setBackground(null);
    add(_displays);
    _displays.setLayout(new BoxLayout(_displays,BoxLayout.Y_AXIS));
    _displays.setBackground(null);
    for (Iterator i=_model.deepEntityList().iterator(); i.hasNext(); ) {
      Object o=i.next();
      if (o instanceof Placeable) {
        ((Placeable)o).place(_displays);
      }
    }
  }
}","/** 
 * Set the associated model and add a query box with its top-level parameters, and those of its director, if it has one. All placeable objects in the hierarchy will get placed.
 * @param model The associated model.
 */
public void setModel(CompositeActor model){
  _model=model;
  if (_paramQuery != null) {
    _controlPanel.remove(_paramQuery);
    _paramQuery=null;
  }
  if (_directorQuery != null) {
    _controlPanel.remove(_directorQuery);
    _directorQuery=null;
  }
  if (_displays != null) {
    remove(_displays);
    _displays=null;
  }
  if (model != null) {
    _manager=_model.getManager();
    if ((_show & TOP_PARAMETERS) != 0) {
      List paramList=_model.attributeList(Parameter.class);
      if (paramList.size() > 0) {
        JLabel pTitle=new JLabel(""String_Node_Str"");
        pTitle.setForeground(new Color(0,0,128));
        _controlPanel.add(pTitle);
        _controlPanel.add(Box.createRigidArea(new Dimension(0,8)));
        _paramQuery=new Configurer(model);
        _paramQuery.setAlignmentX(LEFT_ALIGNMENT);
        _paramQuery.setBackground(null);
        _controlPanel.add(_paramQuery);
        if ((_show & DIRECTOR_PARAMETERS) != 0) {
          _controlPanel.add(Box.createRigidArea(new Dimension(0,15)));
        }
      }
    }
    if ((_show & DIRECTOR_PARAMETERS) != 0) {
      Director director=_model.getDirector();
      if (director != null) {
        List dirParamList=director.attributeList(Parameter.class);
        if (dirParamList.size() > 0) {
          JLabel pTitle=new JLabel(""String_Node_Str"");
          pTitle.setForeground(new Color(0,0,128));
          _controlPanel.add(pTitle);
          _controlPanel.add(Box.createRigidArea(new Dimension(0,8)));
          _directorQuery=new Configurer(director);
          _directorQuery.setAlignmentX(LEFT_ALIGNMENT);
          _directorQuery.setBackground(null);
          _controlPanel.add(_directorQuery);
        }
      }
    }
    if (_controlPanel != null && _layout == HORIZONTAL) {
      _controlPanel.add(Box.createVerticalGlue());
    }
    if (_paramQuery != null && _directorQuery != null) {
      Dimension modelSize=_paramQuery.getPreferredSize();
      Dimension directorSize=_directorQuery.getPreferredSize();
      if (directorSize.width > modelSize.width) {
        _paramQuery.setPreferredSize(new Dimension(directorSize.width,modelSize.height));
      }
 else {
        _directorQuery.setPreferredSize(new Dimension(modelSize.width,directorSize.height));
      }
    }
    _displays=new JPanel();
    _displays.setBackground(null);
    add(_displays);
    _displays.setLayout(new BoxLayout(_displays,BoxLayout.Y_AXIS));
    _displays.setBackground(null);
    for (Iterator i=_model.deepEntityList().iterator(); i.hasNext(); ) {
      Object o=i.next();
      if (o instanceof Placeable) {
        ((Placeable)o).place(_displays);
      }
    }
  }
}"
75935,"/** 
 * Sanity check the parameters; if the parameters are legal create a continuous-time subsystem that implement the transfer function, preinitialize all the actors in the subsystem,  and set the opaqueness of this actor to true. This method need the write access on the workspace.
 * @throws IllegalActionException If there is no CTDirector,or any contained actors throw it in its preinitialize() method .
 */
public void preinitialize() throws IllegalActionException {
  double[] bRow=((DoubleMatrixToken)numerator.getToken()).doubleMatrix()[0];
  double[] a=((DoubleMatrixToken)denominator.getToken()).doubleMatrix()[0];
  int m=bRow.length;
  int n=a.length;
  if (m > n) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  double[] b=new double[n];
  for (int i=1; i <= m; i++) {
    b[n - i]=bRow[m - i];
  }
  for (int i=0; i < n; i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ a[i]+ ""String_Node_Str""+ i+ ""String_Node_Str""+ b[i]);
  }
  try {
    _workspace.getWriteAccess();
    removeAllEntities();
    removeAllRelations();
    if (n == 1) {
      if (a[0] == b[0]) {
        connect(input,output);
      }
 else {
        Scale scaleD=new Scale(this,""String_Node_Str"");
        scaleD.factor.setToken(new DoubleToken(b[0] / a[0]));
        connect(input,scaleD.input);
        connect(output,scaleD.output);
      }
    }
 else {
      double d=b[0] / a[0];
      int order=n - 1;
      AddSubtract inputAdder=new AddSubtract(this,""String_Node_Str"");
      AddSubtract outputAdder=new AddSubtract(this,""String_Node_Str"");
      Integrator[] integrators=new Integrator[order];
      IORelation[] nodes=new IORelation[order];
      Scale[] feedback=new Scale[order];
      Scale[] feedforward=new Scale[order];
      for (int i=0; i < order; i++) {
        integrators[i]=new Integrator(this,""String_Node_Str"" + i);
        feedback[i]=new Scale(this,""String_Node_Str"" + i);
        feedback[i].factor.setToken(new DoubleToken(-a[i + 1] / a[0]));
        feedforward[i]=new Scale(this,""String_Node_Str"" + i);
        feedforward[i].factor.setToken(new DoubleToken((b[order - i] - d * a[order - i]) / a[0]));
        nodes[i]=(IORelation)connect(integrators[i].output,feedforward[i].input,""String_Node_Str"" + i);
        feedback[i].input.link(nodes[i]);
        connect(feedback[i].output,inputAdder.plus);
        connect(feedforward[i].output,outputAdder.plus);
        if (i >= 1) {
          integrators[i].input.link(nodes[i - 1]);
        }
      }
      connect(inputAdder.output,integrators[0].input);
      IORelation inputRelation=(IORelation)connect(input,inputAdder.plus,""String_Node_Str"");
      IORelation outputRelation=(IORelation)connect(output,outputAdder.output,""String_Node_Str"");
      if (d != 0) {
        Scale scaleD=new Scale(this,""String_Node_Str"");
        scaleD.factor.setToken(new DoubleToken(d));
        scaleD.input.link(inputRelation);
        connect(scaleD.output,outputAdder.plus);
      }
    }
    _opaque=false;
    _workspace.incrVersion();
    System.out.println(""String_Node_Str"");
  }
 catch (  NameDuplicationException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _workspace.doneWriting();
  }
  for (Iterator i=deepEntityList().iterator(); i.hasNext(); ) {
    Actor actor=(Actor)i.next();
    actor.preinitialize();
  }
}","/** 
 * Sanity check the parameters; if the parameters are legal create a continuous-time subsystem that implement the transfer function, preinitialize all the actors in the subsystem,  and set the opaqueness of this actor to true. This method need the write access on the workspace.
 * @throws IllegalActionException If there is no CTDirector,or any contained actors throw it in its preinitialize() method .
 */
public void preinitialize() throws IllegalActionException {
  double[] bRow=((DoubleMatrixToken)numerator.getToken()).doubleMatrix()[0];
  double[] a=((DoubleMatrixToken)denominator.getToken()).doubleMatrix()[0];
  int m=bRow.length;
  int n=a.length;
  if (m > n) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  double[] b=new double[n];
  for (int i=1; i <= m; i++) {
    b[n - i]=bRow[m - i];
  }
  for (int i=0; i < n; i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ a[i]+ ""String_Node_Str""+ i+ ""String_Node_Str""+ b[i]);
  }
  try {
    _workspace.getWriteAccess();
    removeAllEntities();
    removeAllRelations();
    if (n == 1) {
      if (a[0] == b[0]) {
        connect(input,output);
      }
 else {
        Scale scaleD=new Scale(this,""String_Node_Str"");
        scaleD.factor.setToken(new DoubleToken(b[0] / a[0]));
        connect(input,scaleD.input);
        connect(output,scaleD.output);
      }
    }
 else {
      double d=b[0] / a[0];
      int order=n - 1;
      AddSubtract inputAdder=new AddSubtract(this,""String_Node_Str"");
      AddSubtract outputAdder=new AddSubtract(this,""String_Node_Str"");
      Integrator[] integrators=new Integrator[order];
      IORelation[] nodes=new IORelation[order];
      Scale[] feedback=new Scale[order];
      Scale[] feedforward=new Scale[order];
      for (int i=0; i < order; i++) {
        integrators[i]=new Integrator(this,""String_Node_Str"" + i);
        feedback[i]=new Scale(this,""String_Node_Str"" + i);
        feedback[i].factor.setToken(new DoubleToken(-a[i + 1] / a[0]));
        feedforward[i]=new Scale(this,""String_Node_Str"" + i);
        feedforward[i].factor.setToken(new DoubleToken((b[i + 1] - d * a[i + 1]) / a[0]));
        nodes[i]=(IORelation)connect(integrators[i].output,feedforward[i].input,""String_Node_Str"" + i);
        feedback[i].input.link(nodes[i]);
        connect(feedback[i].output,inputAdder.plus);
        connect(feedforward[i].output,outputAdder.plus);
        if (i >= 1) {
          integrators[i].input.link(nodes[i - 1]);
        }
      }
      connect(inputAdder.output,integrators[0].input);
      IORelation inputRelation=(IORelation)connect(input,inputAdder.plus,""String_Node_Str"");
      IORelation outputRelation=(IORelation)connect(output,outputAdder.output,""String_Node_Str"");
      if (d != 0) {
        Scale scaleD=new Scale(this,""String_Node_Str"");
        scaleD.factor.setToken(new DoubleToken(d));
        scaleD.input.link(inputRelation);
        connect(scaleD.output,outputAdder.plus);
      }
    }
    _opaque=false;
    _workspace.incrVersion();
    System.out.println(""String_Node_Str"");
  }
 catch (  NameDuplicationException ex) {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"" + ex.getMessage());
  }
 finally {
    _workspace.doneWriting();
  }
  for (Iterator i=deepEntityList().iterator(); i.hasNext(); ) {
    Actor actor=(Actor)i.next();
    actor.preinitialize();
  }
}"
75936,"/** 
 * Read at most one token from each input channel and display its string value on the screen.  Each value is terminated with a newline character.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      Token token=input.get(i);
      String value=token.toString();
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 2);
      }
      textArea.append(value);
      if (width > i + 1)       textArea.append(""String_Node_Str"");
      try {
        int lineOffset=textArea.getLineStartOffset(textArea.getLineCount() - 1);
        textArea.setCaretPosition(lineOffset);
      }
 catch (      BadLocationException ex) {
      }
    }
  }
  textArea.append(""String_Node_Str"");
  return super.postfire();
}","/** 
 * Read at most one token from each input channel and display its string value on the screen.  Each value is terminated with a newline character.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      Token token=input.get(i);
      String value=token.toString();
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 1);
      }
      textArea.append(value);
      if (width > i + 1)       textArea.append(""String_Node_Str"");
      try {
        int lineOffset=textArea.getLineStartOffset(textArea.getLineCount() - 1);
        textArea.setCaretPosition(lineOffset);
      }
 catch (      BadLocationException ex) {
      }
    }
  }
  textArea.append(""String_Node_Str"");
  return super.postfire();
}"
75937,"/** 
 * Notify the listener that the change has failed with the specified exception.
 * @param change The change that has failed.
 * @param exception The exception that was thrown.
 */
public void changeFailed(ChangeRequest change,Exception exception){
  if (!change.isErrorReported()) {
    change.setErrorReported(true);
    MessageHandler.error(""String_Node_Str"",exception);
  }
  dispatchGraphEvent(new GraphEvent(AbstractPtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
}","/** 
 * Notify the listener that the change has failed with the specified exception.
 * @param change The change that has failed.
 * @param exception The exception that was thrown.
 */
public void changeFailed(ChangeRequest change,Exception exception){
  _update();
  if (!change.isErrorReported()) {
    change.setErrorReported(true);
    MessageHandler.error(""String_Node_Str"",exception);
  }
  dispatchGraphEvent(new GraphEvent(AbstractPtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
}"
75938,"/** 
 * Notify the listener that a change has been successfully executed. If the originator of this change is not this graph model, then issue a graph event to indicate that the structure of the graph has changed.
 * @param change The change that has been executed.
 */
public void changeExecuted(ChangeRequest change){
  if (change.getSource() == AbstractPtolemyGraphModel.this) {
    return;
  }
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      dispatchGraphEvent(new GraphEvent(AbstractPtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
    }
  }
);
}","/** 
 * Notify the listener that a change has been successfully executed. If the originator of this change is not this graph model, then issue a graph event to indicate that the structure of the graph has changed.
 * @param change The change that has been executed.
 */
public void changeExecuted(ChangeRequest change){
  _update();
  if (change.getSource() == AbstractPtolemyGraphModel.this) {
    return;
  }
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      dispatchGraphEvent(new GraphEvent(AbstractPtolemyGraphModel.this,GraphEvent.STRUCTURE_CHANGED,getRoot()));
    }
  }
);
}"
75939,"/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  _currentElement=elementName;
  try {
    if (_configureNesting > 0 || _docNesting > 0) {
      if (elementName.equals(""String_Node_Str"")) {
        _configureNesting++;
      }
 else       if (elementName.equals(""String_Node_Str"")) {
        _docNesting++;
      }
      _currentCharData.append(""String_Node_Str"" + elementName);
      Iterator attributes=_attributes.entrySet().iterator();
      while (attributes.hasNext()) {
        Map.Entry entry=(Map.Entry)attributes.next();
        if (entry.getValue() != null) {
          _currentCharData.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"");
        }
      }
      _attributes.clear();
      _currentCharData.append(""String_Node_Str"");
      return;
    }
    if (_skipRendition) {
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
      }
      newEntity.getMoMLInfo().elementName=""String_Node_Str"";
      _current=newEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedPort;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedProp;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedRelation;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      NamedObj container=_current;
      _containers.push(_current);
      _namespaces.push(_namespace);
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
      }
      _current=newEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespace=groupName;
      }
 else {
        _namespaces.push(DEFAULT_NAMESPACE);
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
      newParser.setContext(_current);
      newParser._propagating=_propagating;
      _parse(newParser,_base,source);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      Relation tmpRelation=context.getRelation(relationName);
      _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
      ComponentRelation relation=(ComponentRelation)tmpRelation;
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      if (insertAtSpec == null) {
        port.link(relation);
      }
 else {
        int insertAt=Integer.parseInt(insertAtSpec);
        port.insertLink(insertAt,relation);
      }
      _recordLink(context,portName,relationName,insertAtSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        if (className == null) {
          port=container.newPort(portName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
        }
        _recordNewObject(container,port);
      }
      _containers.push(_current);
      _namespaces.push(_namespace);
      _current=port;
      _namespace=DEFAULT_NAMESPACE;
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          ioport.setOutput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
          ioport.setInput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      boolean isIOPort=(_current instanceof IOPort);
      if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else {
        NamedObj property=(Attribute)_current.getAttribute(propertyName);
        String className=(String)_attributes.get(""String_Node_Str"");
        Class newClass=null;
        if (className != null) {
          newClass=Class.forName(className,true,_classLoader);
        }
        boolean createdNew=false;
        if (property == null || (className != null && !property.getClass().getName().equals(className))) {
          try {
            if (newClass == null) {
              newClass=Attribute.class;
            }
            Object[] arguments=new Object[2];
            arguments[0]=_current;
            arguments[1]=propertyName;
            property=_createInstance(newClass,arguments);
            if (value != null) {
              if (!(property instanceof Settable)) {
                throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
              }
              Settable settable=(Settable)property;
              settable.setExpression(value);
              _paramsToParse.add(property);
            }
            createdNew=true;
          }
 catch (          NameDuplicationException ex) {
          }
        }
        if (!createdNew) {
          if (value != null) {
            if (!(property instanceof Settable)) {
              throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
            }
            Settable settable=(Settable)property;
            settable.setExpression(value);
            _paramsToParse.add(property);
          }
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=property;
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      if (relation == null) {
        NamedObj newRelation=null;
        _containers.push(_current);
        _namespaces.push(_namespace);
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
        }
        _namespace=DEFAULT_NAMESPACE;
        _recordNewObject(_current,newRelation);
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=relation;
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        _current.setName(newName);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      int countArgs=0;
      if (indexSpec != null)       countArgs++;
      if (insideIndexSpec != null)       countArgs++;
      if (relationName != null)       countArgs++;
      if (countArgs != 1) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      if (relationName != null) {
        Relation tmpRelation=context.getRelation(relationName);
        _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
        ComponentRelation relation=(ComponentRelation)tmpRelation;
        port.unlink(relation);
      }
 else       if (indexSpec != null) {
        int index=Integer.parseInt(indexSpec);
        port.unlink(index);
      }
 else {
        int index=Integer.parseInt(insideIndexSpec);
        port.unlinkInside(index);
      }
      _recordUnlink(context,portName,relationName,indexSpec,insideIndexSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null) {
        vertex.setExpression(value);
      }
      _containers.push(_current);
      _namespaces.push(_namespace);
      _current=vertex;
      _namespace=DEFAULT_NAMESPACE;
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    System.err.println(""String_Node_Str"");
    ex.printStackTrace();
    String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException().toString();
    throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
catch (  Exception ex) {
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.toString();
      System.err.println(""String_Node_Str"");
      ex.printStackTrace();
      throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
    }
  }
  _attributes.clear();
}","/** 
 * Start an element. This is called at the beginning of each XML element.  By the time it is called, all of the attributes for the element will already have been reported using the attribute() method.  Unrecognized elements are ignored.
 * @param elementName The element type name.
 * @exception XmlException If the element produces an errorin constructing the model.
 */
public void startElement(String elementName) throws XmlException {
  _currentElement=elementName;
  try {
    if (_configureNesting > 0 || _docNesting > 0) {
      if (elementName.equals(""String_Node_Str"")) {
        _configureNesting++;
      }
 else       if (elementName.equals(""String_Node_Str"")) {
        _docNesting++;
      }
      _currentCharData.append(""String_Node_Str"" + elementName);
      Iterator attributes=_attributes.entrySet().iterator();
      while (attributes.hasNext()) {
        Map.Entry entry=(Map.Entry)attributes.next();
        if (entry.getValue() != null) {
          _currentCharData.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"");
        }
      }
      _attributes.clear();
      _currentCharData.append(""String_Node_Str"");
      return;
    }
    if (_skipRendition) {
      return;
    }
    if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
      }
      newEntity.getMoMLInfo().elementName=""String_Node_Str"";
      _current=newEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _checkClass(_current,Configurable.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      _configureSource=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _configureNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      NamedObj deletedEntity=_deleteEntity(entityName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      NamedObj deletedPort=_deletePort(portName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedPort;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propName,""String_Node_Str"");
      NamedObj deletedProp=_deleteProperty(propName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedProp;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      NamedObj deletedRelation=_deleteRelation(relationName);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
      _current=deletedRelation;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(className,""String_Node_Str"");
      String dirName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(dirName,""String_Node_Str"");
      _checkClass(_current,CompositeActor.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Object[] arguments=new Object[2];
      arguments[0]=_current;
      arguments[1]=dirName;
      NamedObj container=_current;
      _containers.push(_current);
      _namespaces.push(_namespace);
      Class newClass=Class.forName(className,true,_classLoader);
      _current=_createInstance(newClass,arguments);
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _currentDocName=(String)_attributes.get(""String_Node_Str"");
      _currentCharData=new StringBuffer();
      _docNesting++;
    }
 else     if (elementName.equals(""String_Node_Str"") || elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String entityName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(entityName,""String_Node_Str"");
      String source=(String)_attributes.get(""String_Node_Str"");
      NamedObj newEntity=_createEntity(className,entityName,source);
      if (_current != null) {
        _containers.push(_current);
        _namespaces.push(_namespace);
      }
 else       if (_toplevel == null) {
        _toplevel=newEntity.toplevel();
      }
      _current=newEntity;
      _namespace=DEFAULT_NAMESPACE;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String groupName=(String)_attributes.get(""String_Node_Str"");
      if (groupName != null) {
        _namespaces.push(_namespace);
        _namespace=groupName;
      }
 else {
        _namespaces.push(DEFAULT_NAMESPACE);
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String source=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(source,""String_Node_Str"");
      MoMLParser newParser=new MoMLParser(_workspace,_classLoader);
      newParser.setContext(_current);
      newParser._propagating=_propagating;
      _parse(newParser,_base,source);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      Relation tmpRelation=context.getRelation(relationName);
      _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
      ComponentRelation relation=(ComponentRelation)tmpRelation;
      String insertAtSpec=(String)_attributes.get(""String_Node_Str"");
      if (insertAtSpec == null) {
        port.link(relation);
      }
 else {
        int insertAt=Integer.parseInt(insertAtSpec);
        port.insertLink(insertAt,relation);
      }
      _recordLink(context,portName,relationName,insertAtSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      _checkClass(_current,Entity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Entity container=(Entity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Port port=container.getPort(portName);
      if (port != null) {
        if (newClass != null) {
          _checkClass(port,newClass,""String_Node_Str"" + portName + ""String_Node_Str""+ className);
        }
      }
 else {
        if (className == null) {
          port=container.newPort(portName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=container;
          arguments[1]=portName;
          port=(Port)_createInstance(newClass,arguments);
        }
        _recordNewObject(container,port);
      }
      _containers.push(_current);
      _namespaces.push(_namespace);
      _current=port;
      _namespace=DEFAULT_NAMESPACE;
      if (port instanceof IOPort) {
        String direction=(String)_attributes.get(""String_Node_Str"");
        if (direction != null) {
          IOPort ioport=(IOPort)port;
          ioport.setOutput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
          ioport.setInput(direction.equals(""String_Node_Str"") || direction.equals(""String_Node_Str""));
        }
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String propertyName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(propertyName,""String_Node_Str"");
      String value=(String)_attributes.get(""String_Node_Str"");
      boolean isIOPort=(_current instanceof IOPort);
      if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setMultiport(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setOutput(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else       if (propertyName.equals(""String_Node_Str"") && isIOPort) {
        if (value == null || value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(true);
        }
 else         if (value.trim().toLowerCase().equals(""String_Node_Str"")) {
          ((IOPort)_current).setInput(false);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=(Attribute)_current.getAttribute(propertyName);
        _namespace=DEFAULT_NAMESPACE;
      }
 else {
        NamedObj property=(Attribute)_current.getAttribute(propertyName);
        String className=(String)_attributes.get(""String_Node_Str"");
        Class newClass=null;
        if (className != null) {
          newClass=Class.forName(className,true,_classLoader);
        }
        boolean createdNew=false;
        if (property == null || (className != null && !property.getClass().getName().equals(className))) {
          try {
            if (newClass == null) {
              newClass=Attribute.class;
            }
            Object[] arguments=new Object[2];
            arguments[0]=_current;
            arguments[1]=propertyName;
            property=_createInstance(newClass,arguments);
            if (value != null) {
              if (!(property instanceof Settable)) {
                throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
              }
              Settable settable=(Settable)property;
              settable.setExpression(value);
              _paramsToParse.add(property);
            }
            createdNew=true;
          }
 catch (          NameDuplicationException ex) {
          }
        }
        if (!createdNew) {
          if (value != null) {
            if (!(property instanceof Settable)) {
              throw new XmlException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
            }
            Settable settable=(Settable)property;
            settable.setExpression(value);
            _paramsToParse.add(property);
          }
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=property;
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String className=(String)_attributes.get(""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(relationName,""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity container=(CompositeEntity)_current;
      Class newClass=null;
      if (className != null) {
        newClass=Class.forName(className,true,_classLoader);
      }
      Relation relation=container.getRelation(relationName);
      if (relation == null) {
        NamedObj newRelation=null;
        _containers.push(_current);
        _namespaces.push(_namespace);
        if (newClass == null) {
          newRelation=container.newRelation(relationName);
        }
 else {
          Object[] arguments=new Object[2];
          arguments[0]=(CompositeEntity)_current;
          arguments[1]=relationName;
          newRelation=_createInstance(newClass,arguments);
        }
        _namespace=DEFAULT_NAMESPACE;
        _recordNewObject(_current,newRelation);
        _current=newRelation;
      }
 else {
        if (newClass != null) {
          _checkClass(relation,newClass,""String_Node_Str"" + relationName + ""String_Node_Str""+ className);
        }
        _containers.push(_current);
        _namespaces.push(_namespace);
        _current=relation;
        _namespace=DEFAULT_NAMESPACE;
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String newName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(newName,""String_Node_Str"");
      if (_current != null) {
        _current.setName(newName);
      }
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      _skipRendition=true;
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String portName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(portName,""String_Node_Str"");
      String relationName=(String)_attributes.get(""String_Node_Str"");
      String indexSpec=(String)_attributes.get(""String_Node_Str"");
      String insideIndexSpec=(String)_attributes.get(""String_Node_Str"");
      _checkClass(_current,CompositeEntity.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      CompositeEntity context=(CompositeEntity)_current;
      ComponentPort port=_getPort(portName,context);
      int countArgs=0;
      if (indexSpec != null)       countArgs++;
      if (insideIndexSpec != null)       countArgs++;
      if (relationName != null)       countArgs++;
      if (countArgs != 1) {
        throw new XmlException(""String_Node_Str"" + ""String_Node_Str"",_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
      }
      if (relationName != null) {
        Relation tmpRelation=context.getRelation(relationName);
        _checkForNull(tmpRelation,""String_Node_Str"" + relationName + ""String_Node_Str""+ context.getFullName());
        ComponentRelation relation=(ComponentRelation)tmpRelation;
        port.unlink(relation);
      }
 else       if (indexSpec != null) {
        int index=Integer.parseInt(indexSpec);
        port.unlink(index);
      }
 else {
        int index=Integer.parseInt(insideIndexSpec);
        port.unlinkInside(index);
      }
      _recordUnlink(context,portName,relationName,indexSpec,insideIndexSpec);
    }
 else     if (elementName.equals(""String_Node_Str"")) {
      String vertexName=(String)_attributes.get(""String_Node_Str"");
      _checkForNull(vertexName,""String_Node_Str"");
      _checkClass(_current,Relation.class,""String_Node_Str"" + ""String_Node_Str"" + _current);
      Vertex vertex=new Vertex((Relation)_current,vertexName);
      String value=(String)_attributes.get(""String_Node_Str"");
      if (value != null) {
        vertex.setExpression(value);
        _paramsToParse.add(vertex);
      }
      _containers.push(_current);
      _namespaces.push(_namespace);
      _current=vertex;
      _namespace=DEFAULT_NAMESPACE;
    }
 else {
      if (_unrecognized == null) {
        _unrecognized=new LinkedList();
      }
      _unrecognized.add(elementName);
    }
  }
 catch (  InvocationTargetException ex) {
    System.err.println(""String_Node_Str"");
    ex.printStackTrace();
    String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.getTargetException().toString();
    throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
  }
catch (  Exception ex) {
    if (ex instanceof XmlException) {
      throw (XmlException)ex;
    }
 else {
      String msg=""String_Node_Str"" + elementName + ""String_Node_Str""+ ex.toString();
      System.err.println(""String_Node_Str"");
      ex.printStackTrace();
      throw new XmlException(msg,_currentExternalEntity(),_parser.getLineNumber(),_parser.getColumnNumber());
    }
  }
  _attributes.clear();
}"
75940,"/** 
 * Read at most one token from each input channel and display its string value on the screen.  Each value is terminated with a newline character.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      Token token=input.get(i);
      String value=token.toString();
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str""))       ;
{
        value=value.substring(1,value.length() - 2);
      }
      textArea.append(value);
      if (width > i + 1)       textArea.append(""String_Node_Str"");
      try {
        int lineOffset=textArea.getLineStartOffset(textArea.getLineCount() - 1);
        textArea.setCaretPosition(lineOffset);
      }
 catch (      BadLocationException ex) {
      }
    }
  }
  textArea.append(""String_Node_Str"");
  return super.postfire();
}","/** 
 * Read at most one token from each input channel and display its string value on the screen.  Each value is terminated with a newline character.
 * @exception IllegalActionException If there is no director.
 */
public boolean postfire() throws IllegalActionException {
  int width=input.getWidth();
  for (int i=0; i < width; i++) {
    if (input.hasToken(i)) {
      Token token=input.get(i);
      String value=token.toString();
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 2);
      }
      textArea.append(value);
      if (width > i + 1)       textArea.append(""String_Node_Str"");
      try {
        int lineOffset=textArea.getLineStartOffset(textArea.getLineCount() - 1);
        textArea.setCaretPosition(lineOffset);
      }
 catch (      BadLocationException ex) {
      }
    }
  }
  textArea.append(""String_Node_Str"");
  return super.postfire();
}"
75941,"/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (histogram != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    histogram.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
}","/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (histogram != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    histogram.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
 else   if (_configureSources != null) {
    Iterator sources=_configureSources.iterator();
    Iterator texts=_configureTexts.iterator();
    while (sources.hasNext()) {
      String source=(String)sources.next();
      String text=(String)texts.next();
      if (source != null && !source.trim().equals(""String_Node_Str"")) {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + source+ ""String_Node_Str"");
      }
 else {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
      }
      if (text != null)       output.write(text);
      output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
    }
  }
}"
75942,"/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (plot != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    plot.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
}","/** 
 * Write a MoML description of the contents of this object, which in this class is the configuration information. This method is called by exportMoML().  Each description is indented according to the specified depth and terminated with a newline character.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @exception IOException If an I/O error occurs.
 */
protected void _exportMoMLContents(Writer output,int depth) throws IOException {
  super._exportMoMLContents(output,depth);
  String header=""String_Node_Str"" + ""String_Node_Str"";
  if (plot != null) {
    output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + header+ ""String_Node_Str"");
    PrintWriter print=new PrintWriter(output);
    plot.writeFormat(print);
    output.write(""String_Node_Str"" + _getIndentPrefix(depth) + ""String_Node_Str"");
  }
 else   if (_configureSources != null) {
    Iterator sources=_configureSources.iterator();
    Iterator texts=_configureTexts.iterator();
    while (sources.hasNext()) {
      String source=(String)sources.next();
      String text=(String)texts.next();
      if (source != null && !source.trim().equals(""String_Node_Str"")) {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + source+ ""String_Node_Str"");
      }
 else {
        output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
      }
      if (text != null)       output.write(text);
      output.write(_getIndentPrefix(depth) + ""String_Node_Str"");
    }
  }
}"
75943,"/** 
 * Start at the specified node in the shedule tree and move up the tree (towards the root node) until we find a node the has children we have not iterated through yet or children that we have not iterated through enough times (not reached the maximum iteration count).
 * @param firingNode The starting node to backtrack from.
 */
private Schedule _backTrack(ScheduleElement firingNode){
  _currentDepth--;
  Schedule node=(Schedule)firingNode._parent;
  if (node == null) {
    return null;
  }
 else   if (node.size() > (++_horizontalNodePosition[_currentDepth + 1])) {
    return node;
  }
 else   if ((++_iterationCounts[_currentDepth]) < node.getIterationCount()) {
    _horizontalNodePosition[_currentDepth + 1]=0;
    return node;
  }
  _horizontalNodePosition[_currentDepth + 1]=0;
  _iterationCounts[_currentDepth]=0;
  return (_backTrack(node));
}","/** 
 * Start at the specified node in the shedule tree and move up the tree (towards the root node) until we find a node the has children we have not iterated through yet or children that we have not iterated through enough times (not reached the maximum iteration count).
 * @param firingNode The starting node to backtrack from.
 */
private Schedule _backTrack(ScheduleElement firingNode){
  if (_currentDepth == 0) {
    return null;
  }
  _currentDepth--;
  Schedule node=(Schedule)firingNode._parent;
  if (node == null) {
    return null;
  }
 else   if (node.size() > (++_horizontalNodePosition[_currentDepth + 1])) {
    return node;
  }
 else   if ((++_iterationCounts[_currentDepth]) < node.getIterationCount()) {
    _horizontalNodePosition[_currentDepth + 1]=0;
    return node;
  }
  _horizontalNodePosition[_currentDepth + 1]=0;
  _iterationCounts[_currentDepth]=0;
  return (_backTrack(node));
}"
75944,"/** 
 * Remove the first token (the oldest one) from the receiver and return it. If there is no token in the receiver, throw an exception.  Increment the local time by deltaT.
 * @return The oldest token in the receiver.
 */
public Token get(){
  Actor actor=(Actor)super.getContainer().getContainer();
  IOPort currentPort=(IOPort)super.getContainer();
  DTDirector director=(DTDirector)((Actor)actor).getDirector();
  try {
    director.setActorLocalTime(_localTime,actor);
  }
 catch (  Exception e) {
  }
  String sourceName=((Nameable)_to).getName();
  String destinationName=((Nameable)_from).getName();
  _localTime=_localTime + _deltaT;
  return super.get();
}","/** 
 * Remove the first token (the oldest one) from the receiver and return it. If there is no token in the receiver, throw an exception.  Increment the local time by deltaT.
 * @return The oldest token in the receiver.
 */
public Token get(){
  Actor actor=(Actor)super.getContainer().getContainer();
  IOPort currentPort=(IOPort)super.getContainer();
  Director director=((Actor)actor).getDirector();
  if (director instanceof DTDirector) {
    DTDirector dtDirector=(DTDirector)director;
    dtDirector.setActorLocalTime(_localTime,actor);
  }
  String sourceName=((Nameable)_to).getName();
  String destinationName=((Nameable)_from).getName();
  _localTime=_localTime + _deltaT;
  return super.get();
}"
75945,"/** 
 * Construct a dialog with the specified owner and target. An ""OK"" and a ""Cancel"" button are added to the dialog. The dialog is placed relative to the owner.
 * @param owner The object that, per the user, appears to begenerating the dialog.
 * @param target The object whose parameters are being edited.
 */
public EditParametersDialog(Frame owner,NamedObj target){
  super(owner,""String_Node_Str"" + target.getName(),new Configurer(target),_moreButtons);
  _owner=owner;
  _target=target;
  if (buttonPressed().equals(""String_Node_Str"")) {
    _openAddDialog(null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    _target.removeChangeListener(this);
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    List attList=_target.attributeList(Settable.class);
    Iterator parameters=attList.iterator();
    int count=0;
    while (parameters.hasNext()) {
      Settable param=(Settable)parameters.next();
      if (param.getVisibility() == Settable.FULL)       count++;
    }
    String[] attNames=new String[count];
    Iterator params=attList.iterator();
    int index=0;
    while (params.hasNext()) {
      Settable param=(Settable)params.next();
      if (param.getVisibility() == Settable.FULL) {
        attNames[index++]=((Attribute)param).getName();
      }
    }
    Query query=new Query();
    query.addChoice(""String_Node_Str"",""String_Node_Str"",attNames,null,false);
    ComponentDialog dialog=new ComponentDialog(_owner,""String_Node_Str"" + _target.getFullName(),query,null);
    String delName=query.stringValue(""String_Node_Str"");
    if (dialog.buttonPressed().equals(""String_Node_Str"") && !delName.equals(""String_Node_Str"")) {
      String moml=""String_Node_Str"" + delName + ""String_Node_Str"";
      _target.addChangeListener(this);
      _target.requestChange(new MoMLChangeRequest(this,_target,moml));
    }
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    try {
      StyleConfigurer panel=new StyleConfigurer(target);
      ComponentDialog dialog=new ComponentDialog(_owner,""String_Node_Str"" + target.getName(),panel);
      if (!(dialog.buttonPressed().equals(""String_Node_Str""))) {
        panel.restore();
      }
    }
 catch (    IllegalActionException ex) {
      MessageHandler.error(""String_Node_Str"",ex);
    }
  }
}","/** 
 * Construct a dialog with the specified owner and target. A ""Commit"" and a ""Cancel"" button are added to the dialog. The dialog is placed relative to the owner.
 * @param owner The object that, per the user, appears to begenerating the dialog.
 * @param target The object whose parameters are being edited.
 */
public EditParametersDialog(Frame owner,NamedObj target){
  super(owner,""String_Node_Str"" + target.getName(),new Configurer(target),_moreButtons);
  _owner=owner;
  _target=target;
  if (buttonPressed().equals(""String_Node_Str"")) {
    _openAddDialog(null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    _target.removeChangeListener(this);
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    List attList=_target.attributeList(Settable.class);
    Iterator parameters=attList.iterator();
    int count=0;
    while (parameters.hasNext()) {
      Settable param=(Settable)parameters.next();
      if (param.getVisibility() == Settable.FULL)       count++;
    }
    String[] attNames=new String[count];
    Iterator params=attList.iterator();
    int index=0;
    while (params.hasNext()) {
      Settable param=(Settable)params.next();
      if (param.getVisibility() == Settable.FULL) {
        attNames[index++]=((Attribute)param).getName();
      }
    }
    Query query=new Query();
    query.addChoice(""String_Node_Str"",""String_Node_Str"",attNames,null,false);
    ComponentDialog dialog=new ComponentDialog(_owner,""String_Node_Str"" + _target.getFullName(),query,null);
    String delName=query.stringValue(""String_Node_Str"");
    if (dialog.buttonPressed().equals(""String_Node_Str"") && !delName.equals(""String_Node_Str"")) {
      String moml=""String_Node_Str"" + delName + ""String_Node_Str"";
      _target.addChangeListener(this);
      _target.requestChange(new MoMLChangeRequest(this,_target,moml));
    }
  }
 else   if (buttonPressed().equals(""String_Node_Str"")) {
    try {
      StyleConfigurer panel=new StyleConfigurer(target);
      ComponentDialog dialog=new ComponentDialog(_owner,""String_Node_Str"" + target.getName(),panel);
      if (!(dialog.buttonPressed().equals(""String_Node_Str""))) {
        panel.restore();
      }
      new EditParametersDialog(_owner,_target);
    }
 catch (    IllegalActionException ex) {
      MessageHandler.error(""String_Node_Str"",ex);
    }
  }
}"
75946,"/** 
 * Notify the listener that a change has been successfully executed.
 * @param change The change that has been executed.
 */
public void changeExecuted(ChangeRequest change){
  if (change.getSource() != this)   return;
  EditParametersDialog dialog=new EditParametersDialog(_owner,_target);
  _target.removeChangeListener(this);
}","/** 
 * Notify the listener that a change has been successfully executed.
 * @param change The change that has been executed.
 */
public void changeExecuted(ChangeRequest change){
  if (change.getSource() != this)   return;
  new EditParametersDialog(_owner,_target);
  _target.removeChangeListener(this);
}"
75947,"/** 
 * If the contents of this dialog implements the CloseListener interface, then notify it that the window has closed.
 */
protected void _handleClosing(){
  super._handleClosing();
  if (!buttonPressed().equals(""String_Node_Str"") && !buttonPressed().equals(""String_Node_Str"") && !buttonPressed().equals(""String_Node_Str"")) {
    ((Configurer)contents).restore();
  }
}","/** 
 * If the contents of this dialog implements the CloseListener interface, then notify it that the window has closed.
 */
protected void _handleClosing(){
  super._handleClosing();
  if (!buttonPressed().equals(""String_Node_Str"") && !buttonPressed().equals(""String_Node_Str"") && !buttonPressed().equals(""String_Node_Str"")&& !buttonPressed().equals(""String_Node_Str"")) {
    ((Configurer)contents).restore();
  }
}"
75948,"/** 
 * If the window is closed with an OK, then apply the changes.
 */
protected void _handleClosing(){
  super._handleClosing();
  if (buttonPressed().equals(""String_Node_Str"")) {
    ((PortConfigurer)contents).apply();
  }
}","/** 
 * If the window is closed with anything but Cancel, apply the changes.
 */
protected void _handleClosing(){
  super._handleClosing();
  if (!buttonPressed().equals(""String_Node_Str"")) {
    ((PortConfigurer)contents).apply();
  }
}"
75949,"/** 
 * Create a new effigy in the given container by reading the specified URL. If the specified URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param in The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL in) throws Exception {
  PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
  if (in == null) {
    NamedObj entity=getEntity(""String_Node_Str"");
    NamedObj newModel;
    if (entity != null) {
      newModel=(NamedObj)entity.clone(new Workspace());
    }
 else {
      newModel=new TypedCompositeActor(new Workspace());
    }
    newModel.setName(""String_Node_Str"");
    effigy.setModel(newModel);
    return effigy;
  }
 else {
    String extension=getExtension(in);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      return null;
    }
    MoMLParser parser=new MoMLParser();
    NamedObj toplevel=null;
    try {
      try {
        toplevel=parser.parse(base,in.openStream());
        if (toplevel != null) {
          effigy.setModel(toplevel);
          URLAttribute url=new URLAttribute(toplevel,""String_Node_Str"");
          url.setURL(in);
          effigy.url.setURL(in);
          return effigy;
        }
 else {
          effigy.setContainer(null);
        }
      }
 catch (      Exception e) {
        ModelDirectory dir=(ModelDirectory)effigy.topEffigy().getContainer();
        List effigies=dir.entityList(Effigy.class);
        if (effigies.size() <= 2) {
          MessageHandler.error(""String_Node_Str"" + in,e);
        }
 else {
          throw e;
        }
      }
    }
  finally {
      if (toplevel == null) {
        effigy.setContainer(null);
      }
    }
    return null;
  }
}","/** 
 * Create a new effigy in the given container by reading the specified URL. If the specified URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param in The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL in) throws Exception {
  if (in == null) {
    PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
    NamedObj entity=getEntity(""String_Node_Str"");
    NamedObj newModel;
    if (entity != null) {
      newModel=(NamedObj)entity.clone(new Workspace());
    }
 else {
      newModel=new TypedCompositeActor(new Workspace());
    }
    newModel.setName(""String_Node_Str"");
    effigy.setModel(newModel);
    return effigy;
  }
 else {
    String extension=getExtension(in);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      return null;
    }
    PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
    MoMLParser parser=new MoMLParser();
    NamedObj toplevel=null;
    try {
      try {
        toplevel=parser.parse(base,in.openStream());
        if (toplevel != null) {
          effigy.setModel(toplevel);
          URLAttribute url=new URLAttribute(toplevel,""String_Node_Str"");
          url.setURL(in);
          effigy.url.setURL(in);
          return effigy;
        }
 else {
          effigy.setContainer(null);
        }
      }
 catch (      Exception e) {
        ModelDirectory dir=(ModelDirectory)effigy.topEffigy().getContainer();
        List effigies=dir.entityList(Effigy.class);
        if (effigies.size() <= 2) {
          MessageHandler.error(""String_Node_Str"" + in,e);
        }
 else {
          throw e;
        }
      }
    }
  finally {
      if (toplevel == null) {
        effigy.setContainer(null);
      }
    }
    return null;
  }
}"
75950,"/** 
 * Consume an input token and compute a single output token.
 * @exception IllegalActionException Not thrown in this base class
 */
public void fire() throws IllegalActionException {
  iterate(1);
}","/** 
 * If at least one input token is available, consume a single input token, apply the filter to that input token, and compute a single output token. If this method is invoked multiple times in one iteration, then only the input read on the last invocation in the iteration will affect the filter state.
 * @exception IllegalActionException Not thrown here.
 */
public void fire() throws IllegalActionException {
  double xCurrent;
  double yCurrent;
  double window;
  if (input.hasToken(0)) {
    DoubleToken in=(DoubleToken)input.get(0);
    xCurrent=(in).doubleValue();
    window=xCurrent;
    for (int j=1; j < _denominator.length; j++) {
      window+=_denominator[j] * _stateVector[(_currentTap + j) % _stateVector.length];
    }
    _latestWindow=window;
    double savedState=_stateVector[_currentTap];
    _stateVector[_currentTap]=window;
    yCurrent=0;
    for (int k=0; k < _numerator.length; k++) {
      yCurrent+=_numerator[k] * _stateVector[(_currentTap + k) % _stateVector.length];
    }
    _stateVector[_currentTap]=savedState;
    DoubleToken out=new DoubleToken(yCurrent);
    output.send(0,out);
  }
}"
75951,"/** 
 * Check whether the current element type is acceptable. The element type is acceptable if it represents an instantiable object.
 * @return True if the element type is acceptable.
 */
public boolean isValueAcceptable(){
  return isInstantiable();
}","/** 
 * Check whether the current element type is acceptable. The element type is acceptable if it represents an instantiable object.
 * @return True if the element type is acceptable.
 */
public boolean isValueAcceptable(){
  return _resolvedType.isInstantiable();
}"
75952,"/** 
 * Return the actor invocation sequence of the schedule in the form of a sequence of actors. For a valid schedule, all of the lowest-level nodes should be an instance of Firing. If the schedule is not valid, then the returned iterator will contain null elements. <p> Note that the behavior of an iterator is unspecified if the underlying schedule structure is modified while the iterator is active.
 * @return An iterator over a sequence of actors.
 */
public Iterator actorIterator(){
  _updateActorInvocations();
  return _actorInvocations.iterator();
}","/** 
 * Return the actor invocation sequence of the schedule in the form of a sequence of actors. For a valid schedule, all of the lowest-level nodes should be an instance of Firing. If the schedule is not valid, then the returned iterator will contain null elements. <p> A runtime exception is thrown if the underlying schedule structure is modified while the iterator is active.
 * @return An iterator over a sequence of actors.
 * @exception ConcurrentModificationException If theunderlying schedule structure is modified while the iterator is active.
 */
public Iterator actorIterator(){
  return new ActorIterator();
}"
75953,"/** 
 * Set the actor associated with this firing. This actor will then be returned when the getActor() method is invoked. If this firing already contains a reference to an actor, then the reference will overwritten.
 * @param actor The actor to associate with this firing.
 */
public void setActor(Executable actor){
  _actor=actor;
  _actorInvocationsValid=false;
}","/** 
 * Set the actor associated with this firing. This actor will then be returned when the getActor() method is invoked. If this firing already contains a reference to an actor, then the reference will overwritten.
 * @param actor The actor to associate with this firing.
 */
public void setActor(Actor actor){
  _incrementVersion();
  _actor=actor;
  _actorInvocationsValid=false;
}"
75954,"/** 
 * Construct a firing with a default iteration count equal to one.
 */
public Firing(){
  super();
  _firing=new LinkedList();
  _firing.add(this);
  _actorInvocations=new LinkedList();
}","/** 
 * Construct a firing with a default iteration count equal to one and with no parent schedule.
 */
public Firing(){
  super();
  _firing=new LinkedList();
  _firing.add(this);
  _actorInvocations=new LinkedList();
}"
75955,"/** 
 * Return the actor invocation sequence in the form of a sequence of firings. Since this ScheduleElement is a Firing, the iterator returned will contain exactly one Firing (this Firing). <p> Note that the behavior of an iterator is unspecified if the underlying schedule structure is modified while the iterator is active.
 * @return An iterator over a sequence of firings.
 */
public Iterator firingIterator(){
  return _firing.iterator();
}","/** 
 * Return the actor invocation sequence in the form of a sequence of firings. Since this ScheduleElement is a Firing, the iterator returned will contain exactly one Firing (this Firing). <p> A runtime exception is thrown if the underlying schedule structure is modified while the iterator is active.
 * @return An iterator over a sequence of firings.
 * @exception ConcurrentModificationException If theunderlying schedule structure is modified while the iterator is active.
 */
public Iterator firingIterator(){
  return _firing.iterator();
}"
75956,"/** 
 * Get the actor associated with this Firing. The setActor() method is used to set the actor that this method returns. If setActor() was never called, then throw an exception.
 * @return The actor associated with this Firing.
 */
public Executable getActor(){
  return _actor;
}","/** 
 * Get the actor associated with this Firing. The setActor() method is used to set the actor that this method returns. If setActor() was never called, then throw an exception.
 * @return The actor associated with this Firing.
 */
public Actor getActor(){
  return _actor;
}"
75957,"/** 
 * Evaluate the current expression to a token. If this variable was last set directly with a token, then do nothing. In other words, the expression is evaluated only if the value of the token was most recently given by an expression.  The expression is also evaluated if any of the variables it refers to have changed since the last evaluation.  If the value of this variable changes due to this evaluation, then notify all value dependents and notify the container (if there is one) by calling its attributeChanged() and attributeTypeChanged() methods, as appropriate. An exception is thrown if the expression is illegal, for example if a parse error occurs or if there is a dependency loop. <p> If evaluation results in a token that is not of the same type as the current type of the variable, then the type of the variable is changed, unless the new type is incompatible with statically specified types (setTypeEquals() and setTypeAtMost()). If the type is changed, the attributeTypeChanged() method of the container is called.  The container can reject the change by throwing an exception. <p> Part of this method is read-synchronized on the workspace.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated.
 */
protected void _evaluate() throws IllegalActionException {
  if (!_needsEvaluation)   return;
  if (_currentExpression == null || _currentExpression.equals(""String_Node_Str"")) {
    _setToken(null);
    return;
  }
  if (_dependencyLoop) {
    _dependencyLoop=false;
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + getFullName() + ""String_Node_Str""+ _currentExpression);
  }
  _dependencyLoop=true;
  try {
    workspace().getReadAccess();
    _buildParseTree();
    Token result=_parseTree.evaluateParseTree();
    _dependencyLoop=false;
    _setTokenAndNotify(result);
  }
 catch (  IllegalActionException ex) {
    _needsEvaluation=true;
    throw ex;
  }
 finally {
    _dependencyLoop=false;
    workspace().doneReading();
  }
}","/** 
 * Evaluate the current expression to a token. If this variable was last set directly with a token, then do nothing. In other words, the expression is evaluated only if the value of the token was most recently given by an expression.  The expression is also evaluated if any of the variables it refers to have changed since the last evaluation.  If the value of this variable changes due to this evaluation, then notify all value dependents and notify the container (if there is one) by calling its attributeChanged() and attributeTypeChanged() methods, as appropriate. An exception is thrown if the expression is illegal, for example if a parse error occurs or if there is a dependency loop. <p> If evaluation results in a token that is not of the same type as the current type of the variable, then the type of the variable is changed, unless the new type is incompatible with statically specified types (setTypeEquals() and setTypeAtMost()). If the type is changed, the attributeTypeChanged() method of the container is called.  The container can reject the change by throwing an exception. <p> Part of this method is read-synchronized on the workspace.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated.
 */
private void _evaluate() throws IllegalActionException {
  if (_currentExpression == null || _currentExpression.equals(""String_Node_Str"")) {
    _setToken(null);
    return;
  }
  if (_dependencyLoop) {
    _dependencyLoop=false;
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + getFullName() + ""String_Node_Str""+ _currentExpression);
  }
  _dependencyLoop=true;
  try {
    workspace().getReadAccess();
    _buildParseTree();
    Token result=_parseTree.evaluateParseTree();
    _dependencyLoop=false;
    _setTokenAndNotify(result);
  }
 catch (  IllegalActionException ex) {
    _needsEvaluation=true;
    throw ex;
  }
 finally {
    _dependencyLoop=false;
    workspace().doneReading();
  }
}"
75958,"/** 
 * Get the type of this variable. If a token has been set by setToken(), the returned type is the type of that token; If an expression has been set by setExpression(), and the expression can be evaluated, the returned type is the type the evaluation result. If the expression cannot be evaluated at this time, the returned type is the declared type of this Variable, which is either set by setTypeEquals(), or the default BaseType.NAT; If no token has been set by setToken(), no expression has been set by setExpression(), and setTypeEquals() has not been called, the returned type is BaseType.NAT.
 * @return The type of this variable.
 */
public Type getType(){
  try {
    _evaluate();
    return _varType;
  }
 catch (  IllegalActionException iae) {
    return _declaredType;
  }
}","/** 
 * Get the type of this variable. If a token has been set by setToken(), the returned type is the type of that token; If an expression has been set by setExpression(), and the expression can be evaluated, the returned type is the type the evaluation result. If the expression cannot be evaluated at this time, the returned type is the declared type of this Variable, which is either set by setTypeEquals(), or the default BaseType.NAT; If no token has been set by setToken(), no expression has been set by setExpression(), and setTypeEquals() has not been called, the returned type is BaseType.NAT.
 * @return The type of this variable.
 */
public Type getType(){
  try {
    if (_needsEvaluation)     _evaluate();
    return _varType;
  }
 catch (  IllegalActionException iae) {
    return _declaredType;
  }
}"
75959,"/** 
 * Get the token contained by this variable.  The type of the returned token is always that returned by getType().  Calling this method will trigger evaluation of the expression, if the value has been given by setExpression(). Notice the evaluation of the expression can trigger an exception if the expression is not valid, or if the result of the expression violates type constraints specified by setTypeEquals() or setTypeAtMost(), or if the result of the expression is null and there are other variables that depend on this one. The returned value will be null if neither an expression nor a token has been set, or either has been set to null.
 * @return The token contained by this variable converted to thetype of this variable, or null if there is none.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if the result of evaluation violates type constraints, or if the result of evaluation is null and there are variables that depend on this one.
 */
public ptolemy.data.Token getToken() throws IllegalActionException {
  _evaluate();
  return _token;
}","/** 
 * Get the token contained by this variable.  The type of the returned token is always that returned by getType().  Calling this method will trigger evaluation of the expression, if the value has been given by setExpression(). Notice the evaluation of the expression can trigger an exception if the expression is not valid, or if the result of the expression violates type constraints specified by setTypeEquals() or setTypeAtMost(), or if the result of the expression is null and there are other variables that depend on this one. The returned value will be null if neither an expression nor a token has been set, or either has been set to null.
 * @return The token contained by this variable converted to thetype of this variable, or null if there is none.
 * @exception IllegalActionException If the expression cannotbe parsed or cannot be evaluated, or if the result of evaluation violates type constraints, or if the result of evaluation is null and there are variables that depend on this one.
 */
public ptolemy.data.Token getToken() throws IllegalActionException {
  if (_needsEvaluation)   _evaluate();
  return _token;
}"
75960,"/** 
 * Set up the taps and consumption and production constants.
 * @exception IllegalActionException If the parameters are out of range.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  double ebw=((DoubleToken)(excessBW.getToken())).doubleValue();
  int inter=((IntToken)(symbolInterval.getToken())).intValue();
  int len=((IntToken)(length.getToken())).intValue();
  boolean sqrt=((BooleanToken)(root.getToken())).booleanValue();
  if (ebw < 0.0) {
    throw new IllegalActionException(this,""String_Node_Str"" + ebw + ""String_Node_Str"");
  }
  if (len <= 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + len + ""String_Node_Str"");
  }
  double[][] tps=new double[1][];
  double center=len * 0.5;
  DoubleUnaryOperation rcSg=sqrt ? (DoubleUnaryOperation)new SignalProcessing.SqrtRaisedCosineSampleGenerator(inter,ebw) : (DoubleUnaryOperation)new SignalProcessing.RaisedCosineSampleGenerator(inter,ebw);
  tps[0]=SignalProcessing.sampleWave(len,-center,1.0,rcSg);
  taps.setToken(new DoubleMatrixToken(tps));
  super.preinitialize();
}","/** 
 * Set up the taps and consumption and production constants.
 * @exception IllegalActionException If the parameters are out of range.
 */
public void preinitialize() throws IllegalActionException {
  super.preinitialize();
  double ebw=((DoubleToken)(excessBW.getToken())).doubleValue();
  int inter=((IntToken)(symbolInterval.getToken())).intValue();
  int len=((IntToken)(length.getToken())).intValue();
  boolean sqrt=((BooleanToken)(root.getToken())).booleanValue();
  if (ebw < 0.0) {
    throw new IllegalActionException(this,""String_Node_Str"" + ebw + ""String_Node_Str"");
  }
  if (len <= 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + len + ""String_Node_Str"");
  }
  double[][] tps=new double[1][];
  double center=len * 0.5;
  DoubleUnaryOperation rcSg=sqrt ? (DoubleUnaryOperation)new SignalProcessing.SqrtRaisedCosineSampleGenerator(inter,ebw) : (DoubleUnaryOperation)new SignalProcessing.RaisedCosineSampleGenerator(inter,ebw);
  tps[0]=SignalProcessing.sampleWave(len,-center,1.0,rcSg);
  taps.setToken(new DoubleMatrixToken(tps));
}"
75961,"/** 
 * End the document. The MoMLParser calls this method once, when it has finished parsing the complete XML document. It is guaranteed that this will be the last method called in the XML parsing process. As a consequence, it is guaranteed that all dependencies between parameters used in the XML description are resolved.
 * @exception CancelException If an error occurs parsing one of theparameter values, and the user clicks on ""cancel"" to cancel the parse.
 */
public void endDocument() throws Exception {
  Iterator parameters=_paramsToParse.iterator();
  while (parameters.hasNext()) {
    Variable param=(Variable)parameters.next();
    try {
      param.getToken();
    }
 catch (    IllegalActionException ex) {
      MessageHandler.warning(""String_Node_Str"" + param.getFullName() + ""String_Node_Str"",ex);
    }
  }
  if (_unrecognized != null) {
    StringBuffer warning=new StringBuffer(""String_Node_Str"");
    Iterator elements=_unrecognized.iterator();
    while (elements.hasNext()) {
      warning.append(""String_Node_Str"" + elements.next().toString());
    }
    try {
      MessageHandler.warning(warning.toString());
    }
 catch (    CancelException ex) {
    }
  }
}","/** 
 * End the document. The MoMLParser calls this method once, when it has finished parsing the complete XML document. It is guaranteed that this will be the last method called in the XML parsing process. As a consequence, it is guaranteed that all dependencies between parameters used in the XML description are resolved.
 * @exception CancelException If an error occurs parsing one of theparameter values, and the user clicks on ""cancel"" to cancel the parse.
 */
public void endDocument() throws Exception {
  Iterator parameters=_paramsToParse.iterator();
  while (parameters.hasNext()) {
    Variable param=(Variable)parameters.next();
    try {
      param.propagate();
    }
 catch (    IllegalActionException ex) {
      MessageHandler.warning(""String_Node_Str"" + param.getFullName() + ""String_Node_Str"",ex);
    }
  }
  if (_unrecognized != null) {
    StringBuffer warning=new StringBuffer(""String_Node_Str"");
    Iterator elements=_unrecognized.iterator();
    while (elements.hasNext()) {
      warning.append(""String_Node_Str"" + elements.next().toString());
    }
    try {
      MessageHandler.warning(warning.toString());
    }
 catch (    CancelException ex) {
    }
  }
}"
75962,"/** 
 * Query the user for a filename, save the model to that file, and open a new window to view the model. This overrides the base class to update the entry in the ModelDirectory.
 * @return True if the save succeeds.
 */
protected boolean _saveAs(){
  JFileChooser fileDialog=new JFileChooser();
  fileDialog.setDialogTitle(""String_Node_Str"");
  if (_directory != null) {
    fileDialog.setCurrentDirectory(_directory);
  }
 else {
    String cwd=System.getProperty(""String_Node_Str"");
    if (cwd != null) {
      fileDialog.setCurrentDirectory(new File(cwd));
    }
  }
  int returnVal=fileDialog.showSaveDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    File file=fileDialog.getSelectedFile();
    if (file.exists()) {
      String query=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
      int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
      if (selected == 1) {
        return false;
      }
    }
    _directory=fileDialog.getCurrentDirectory();
    try {
      _writeFile(file);
      setModified(false);
    }
 catch (    IOException ex) {
      report(""String_Node_Str"",ex);
      return false;
    }
    try {
      URL newURL=file.toURL();
      String newKey=newURL.toExternalForm();
      getConfiguration().openModel(newURL,newURL,newKey);
      Effigy effigy=getEffigy();
      if (effigy != null) {
        String id=effigy.identifier.getExpression();
        if (id.equals(""String_Node_Str"")) {
          effigy.setContainer(null);
        }
      }
    }
 catch (    Exception ex) {
      MessageHandler.error(""String_Node_Str"",ex);
    }
  }
  return true;
}","/** 
 * Query the user for a filename, save the model to that file, and open a new window to view the model. This overrides the base class to update the entry in the ModelDirectory.
 * @return True if the save succeeds.
 */
protected boolean _saveAs(){
  JFileChooser fileDialog=new JFileChooser();
  fileDialog.setDialogTitle(""String_Node_Str"");
  if (_directory != null) {
    fileDialog.setCurrentDirectory(_directory);
  }
 else {
    String cwd=System.getProperty(""String_Node_Str"");
    if (cwd != null) {
      fileDialog.setCurrentDirectory(new File(cwd));
    }
  }
  int returnVal=fileDialog.showSaveDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    File file=fileDialog.getSelectedFile();
    try {
      URL newURL=file.toURL();
      String newKey=newURL.toExternalForm();
      Effigy previousOpen=getDirectory().getEffigy(newKey);
      if (previousOpen != null) {
        if (previousOpen.isModified()) {
          previousOpen.showTableaux();
          String confirm=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
          int selected=JOptionPane.showOptionDialog(this,confirm,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
          if (selected == 1) {
            return false;
          }
          previousOpen.setModified(false);
        }
        previousOpen.closeTableaux();
      }
      if (file.exists()) {
        String query=""String_Node_Str"" + file.getName() + ""String_Node_Str"";
        int selected=JOptionPane.showOptionDialog(this,query,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,null,null);
        if (selected == 1) {
          return false;
        }
      }
      _directory=fileDialog.getCurrentDirectory();
      _writeFile(file);
      getConfiguration().openModel(newURL,newURL,newKey);
      Effigy effigy=getEffigy();
      if (effigy != null) {
        String id=effigy.identifier.getExpression();
        if (id.equals(""String_Node_Str"")) {
          effigy.setContainer(null);
        }
      }
    }
 catch (    Exception ex) {
      report(""String_Node_Str"",ex);
      return false;
    }
  }
  return true;
}"
75963,"/** 
 * Calculate the next random boolean for this iteration.
 * @exception IllegalActionException If the base class throws it.
 * @return True if it is ok to continue.
 */
public boolean prefire() throws IllegalActionException {
  double tp=((DoubleToken)(trueProbability.getToken())).doubleValue();
  double rawNum=_random.nextDouble();
  if (rawNum < tp) {
    _current=true;
  }
 else {
    _current=false;
  }
  return super.prefire();
}","/** 
 * Calculate the next random boolean for this iteration.
 * @exception IllegalActionException If the base class throws it.
 * @return True if it is ok to continue.
 */
public boolean prefire() throws IllegalActionException {
  if (_random.nextDouble() < ((DoubleToken)(trueProbability.getToken())).doubleValue()) {
    _current=true;
  }
 else {
    _current=false;
  }
  return super.prefire();
}"
75964,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the parameter public members to refer to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Clock newObject=(Clock)super.clone(workspace);
  try {
    newObject.attributeChanged(newObject.offsets);
    newObject.attributeChanged(values);
    ArrayType valuesArrayType=(ArrayType)newObject.values.getType();
    InequalityTerm elemTerm=valuesArrayType.getElementTypeTerm();
    newObject.output.setTypeAtLeast(elemTerm);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the parameter public members to refer to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Clock newObject=(Clock)super.clone(workspace);
  try {
    newObject.attributeChanged(newObject.offsets);
    newObject.attributeChanged(values);
    ArrayType valuesArrayType=(ArrayType)newObject.values.getType();
    InequalityTerm elementTerm=valuesArrayType.getElementTypeTerm();
    newObject.output.setTypeAtLeast(elementTerm);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
  return newObject;
}"
75965,"/** 
 * Notify the director that a type change has occurred that may affect the type of the output. This will cause type resolution to be redone when it is next needed. It is assumed that type changes in the parameters are implemented by the director's change request mechanism, so they are implemented when it is safe to redo type resolution. If there is no director, then do nothing.
 * @exception IllegalActionException If the new values array has noelements in it.
 */
public void attributeTypeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == values) {
    Director dir=getDirector();
    if (dir != null) {
      dir.invalidateResolvedTypes();
    }
  }
 else {
    super.attributeTypeChanged(attribute);
  }
}","/** 
 * Notify the director that a type change has occurred that may affect the type of the output. This will cause type resolution to be redone when it is next needed. It is assumed that type changes in the parameters are implemented by the director's change request mechanism, so they are implemented when it is safe to redo type resolution. If there is no director, then do nothing.
 * @exception IllegalActionException If the new values array has noelements in it.
 */
public void attributeTypeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == values) {
    Director director=getDirector();
    if (director != null) {
      director.invalidateResolvedTypes();
    }
  }
 else {
    super.attributeTypeChanged(attribute);
  }
}"
75966,"/** 
 * Output the current value of the clock.
 * @exception IllegalActionException If the <i>values</i> and<i>offsets</i> parameters do not have the same dimension, or if the value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  double currentTime=getDirector().getCurrentTime();
  double prd=((DoubleToken)period.getToken()).doubleValue();
  _tentativeCycleStartTime=_cycleStartTime;
  _tentativeCurrentValue=_currentValue;
  _tentativePhase=_phase;
  _tentativeNextFiringTime=-1.0;
  while (_tentativeCycleStartTime + prd <= currentTime) {
    _tentativeCycleStartTime+=prd;
  }
  double[][] offsts=((DoubleMatrixToken)offsets.getToken()).doubleMatrix();
  ArrayToken val=(ArrayToken)(values.getToken());
  if (offsts[0].length != val.length()) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  while (currentTime >= _tentativeCycleStartTime + offsts[0][_tentativePhase]) {
    _tentativeCurrentValue=_getValue(_tentativePhase);
    _tentativePhase++;
    if (_tentativePhase >= offsts[0].length) {
      _tentativePhase=0;
      _tentativeCycleStartTime+=prd;
    }
    if (offsts[0][_tentativePhase] >= prd) {
      throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ offsts[0][_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ prd);
    }
    _tentativeNextFiringTime=_tentativeCycleStartTime + offsts[0][_tentativePhase];
  }
  output.send(0,_tentativeCurrentValue);
}","/** 
 * Output the current value of the clock.
 * @exception IllegalActionException If the <i>values</i> and<i>offsets</i> parameters do not have the same dimension, or if the value in the offsets parameter is encountered that is greater than the period, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  double currentTime=getDirector().getCurrentTime();
  double periodValue=((DoubleToken)period.getToken()).doubleValue();
  _tentativeCycleStartTime=_cycleStartTime;
  _tentativeCurrentValue=_currentValue;
  _tentativePhase=_phase;
  _tentativeNextFiringTime=-1.0;
  while (_tentativeCycleStartTime + periodValue <= currentTime) {
    _tentativeCycleStartTime+=periodValue;
  }
  double[][] offsts=((DoubleMatrixToken)offsets.getToken()).doubleMatrix();
  ArrayToken val=(ArrayToken)(values.getToken());
  if (offsts[0].length != val.length()) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  while (currentTime >= _tentativeCycleStartTime + offsts[0][_tentativePhase]) {
    _tentativeCurrentValue=_getValue(_tentativePhase);
    _tentativePhase++;
    if (_tentativePhase >= offsts[0].length) {
      _tentativePhase=0;
      _tentativeCycleStartTime+=periodValue;
    }
    if (offsts[0][_tentativePhase] >= periodValue) {
      throw new IllegalActionException(this,""String_Node_Str"" + _tentativePhase + ""String_Node_Str""+ offsts[0][_tentativePhase]+ ""String_Node_Str""+ ""String_Node_Str""+ periodValue);
    }
    _tentativeNextFiringTime=_tentativeCycleStartTime + offsts[0][_tentativePhase];
  }
  output.send(0,_tentativeCurrentValue);
}"
75967,"/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Clock(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  period=new Parameter(this,""String_Node_Str"",new DoubleToken(2.0));
  period.setTypeEquals(BaseType.DOUBLE);
  double defaultOffsets[][]={{0.0,1.0}};
  offsets=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(defaultOffsets));
  offsets.setTypeEquals(BaseType.DOUBLE_MATRIX);
  attributeChanged(offsets);
  IntToken[] defaultValues=new IntToken[2];
  defaultValues[0]=new IntToken(1);
  defaultValues[1]=new IntToken(0);
  ArrayToken defaultValueToken=new ArrayToken(defaultValues);
  values=new Parameter(this,""String_Node_Str"",defaultValueToken);
  values.setTypeEquals(new ArrayType(BaseType.ANY));
  ArrayType valuesArrayType=(ArrayType)values.getType();
  InequalityTerm elemTerm=valuesArrayType.getElementTypeTerm();
  output.setTypeAtLeast(elemTerm);
  attributeChanged(values);
}","/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Clock(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  period=new Parameter(this,""String_Node_Str"",new DoubleToken(2.0));
  period.setTypeEquals(BaseType.DOUBLE);
  double defaultOffsets[][]={{0.0,1.0}};
  offsets=new Parameter(this,""String_Node_Str"",new DoubleMatrixToken(defaultOffsets));
  offsets.setTypeEquals(BaseType.DOUBLE_MATRIX);
  attributeChanged(offsets);
  IntToken[] defaultValues=new IntToken[2];
  defaultValues[0]=new IntToken(1);
  defaultValues[1]=new IntToken(0);
  ArrayToken defaultValueToken=new ArrayToken(defaultValues);
  values=new Parameter(this,""String_Node_Str"",defaultValueToken);
  values.setTypeEquals(new ArrayType(BaseType.ANY));
  ArrayType valuesArrayType=(ArrayType)values.getType();
  InequalityTerm elementTerm=valuesArrayType.getElementTypeTerm();
  output.setTypeAtLeast(elementTerm);
  attributeChanged(values);
}"
75968,"/** 
 * Notify the director when a type change in the parameter occurs. This will cause type resolution to be redone at the next opportunity. It is assumed that type changes in the parameter are implemented by the director's change request mechanism, so they are implemented when it is safe to redo type resolution. If there is no director, then do nothing.
 */
public void attributeTypeChanged(Attribute attribute){
  Director dir=getDirector();
  if (dir != null) {
    dir.invalidateResolvedTypes();
  }
}","/** 
 * Notify the director when a type change in the parameter occurs. This will cause type resolution to be redone at the next opportunity. It is assumed that type changes in the parameter are implemented by the director's change request mechanism, so they are implemented when it is safe to redo type resolution. If there is no director, then do nothing.
 */
public void attributeTypeChanged(Attribute attribute){
  Director director=getDirector();
  if (director != null) {
    director.invalidateResolvedTypes();
  }
}"
75969,"/** 
 * Send the current value of the state of this actor to the output.
 * @exception IllegalActionException If send() throws it.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director dir=getDirector();
  output.send(0,new DoubleToken(dir.getCurrentTime()));
}","/** 
 * Send the current value of the state of this actor to the output.
 * @exception IllegalActionException If send() throws it.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  output.send(0,new DoubleToken(director.getCurrentTime()));
}"
75970,"/** 
 * Return the speified number in decibels, but no less than <i>minValue</i>.
 */
private DoubleToken _doFunction(double number,double minValue) throws IllegalActionException {
  double outNumber;
  if (number <= 0.0) {
    outNumber=minValue;
  }
 else {
    outNumber=ptolemy.math.SignalProcessing.decibel(number);
    if (((BooleanToken)inputIsPower.getToken()).booleanValue()) {
      outNumber/=2.0;
    }
    if (outNumber < minValue) {
      outNumber=minValue;
    }
  }
  return new DoubleToken(outNumber);
}","/** 
 * Return the specified number in decibels, but no less than <i>minValue</i>.
 */
private DoubleToken _doFunction(double number,double minValue) throws IllegalActionException {
  double outNumber;
  if (number <= 0.0) {
    outNumber=minValue;
  }
 else {
    outNumber=ptolemy.math.SignalProcessing.decibel(number);
    if (((BooleanToken)inputIsPower.getToken()).booleanValue()) {
      outNumber/=2.0;
    }
    if (outNumber < minValue) {
      outNumber=minValue;
    }
  }
  return new DoubleToken(outNumber);
}"
75971,"/** 
 * Allow the type of <i>values</i> to change. This will cause the type of the output port to change. Notify the director, which will cause type resolution to be redone at the next opportunity. It is assumed that type changes in the parameter are implemented by the container's change request mechanism, so they are implemented when it is safe to redo type resolution.
 * @param attribute The attribute whose type has changed.
 * @exception IllegalActionException If the base class throws itfor some parameter other than attribute.
 */
public void attributeTypeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == values) {
    Token value=((MatrixToken)values.getToken()).getElementAsToken(0,0);
    output.setTypeEquals(value.getType());
    Director dir=getDirector();
    if (dir != null) {
      dir.invalidateResolvedTypes();
    }
  }
 else {
    super.attributeTypeChanged(attribute);
  }
}","/** 
 * Allow the type of <i>values</i> to change. This will cause the type of the output port to change. Notify the director, which will cause type resolution to be redone at the next opportunity. It is assumed that type changes in the parameter are implemented by the container's change request mechanism, so they are implemented when it is safe to redo type resolution.
 * @param attribute The attribute whose type has changed.
 * @exception IllegalActionException If the base class throws itfor some parameter other than attribute.
 */
public void attributeTypeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == values) {
    Token value=((MatrixToken)values.getToken()).getElementAsToken(0,0);
    output.setTypeEquals(value.getType());
    Director director=getDirector();
    if (director != null) {
      director.invalidateResolvedTypes();
    }
  }
 else {
    super.attributeTypeChanged(attribute);
  }
}"
75972,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param ws The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  Expression newObject=(Expression)super.clone(ws);
  newObject._iterationCount=1;
  newObject._time=(Variable)newObject.getAttribute(""String_Node_Str"");
  newObject._iteration=(Variable)newObject.getAttribute(""String_Node_Str"");
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then creates new ports and parameters.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Expression newObject=(Expression)super.clone(workspace);
  newObject._iterationCount=1;
  newObject._time=(Variable)newObject.getAttribute(""String_Node_Str"");
  newObject._iteration=(Variable)newObject.getAttribute(""String_Node_Str"");
  return newObject;
}"
75973,"/** 
 * Evaluate the expression and send its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  Director dir=getDirector();
  if (dir == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _time.setToken(new DoubleToken(dir.getCurrentTime()));
  Iterator inputPorts=inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)(inputPorts.next());
    if (port.getWidth() > 0) {
      if (port.hasToken(0)) {
        Token inputToken=port.get(0);
        Variable var=(Variable)(getAttribute(port.getName()));
        var.setToken(inputToken);
      }
    }
  }
  Token result=expression.getToken();
  if (result == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + expression.getExpression());
  }
  output.send(0,result);
}","/** 
 * Evaluate the expression and send its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _time.setToken(new DoubleToken(director.getCurrentTime()));
  Iterator inputPorts=inputPortList().iterator();
  while (inputPorts.hasNext()) {
    IOPort port=(IOPort)(inputPorts.next());
    if (port.getWidth() > 0) {
      if (port.hasToken(0)) {
        Token inputToken=port.get(0);
        Variable var=(Variable)(getAttribute(port.getName()));
        var.setToken(inputToken);
      }
    }
  }
  Token result=expression.getToken();
  if (result == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + expression.getExpression());
  }
  output.send(0,result);
}"
75974,"/** 
 * Initialize the filter state vector with zero state.
 * @exception IllegalActionException If the base class throwsit.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  int stateSize=(int)java.lang.Math.max(_numerator.length,_denominator.length);
  _stateVector=new double[stateSize];
  _curTap=0;
}","/** 
 * Initialize the filter state vector with zero state.
 * @exception IllegalActionException If the base class throwsit.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  int stateSize=(int)java.lang.Math.max(_numerator.length,_denominator.length);
  _stateVector=new double[stateSize];
  _currentTap=0;
}"
75975,"/** 
 * Invoke a specified number of iterations of this actor. Each iteration causes the filter to consume an input token and compute a single output token. An invocation of this method therefore applies the filter to <i>count</i> successive input tokens. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, return NOT_READY, and do not consume any input tokens.
 * @exception IllegalActionException If iterating cannot beperformed.
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _resultArray.length) {
    _resultArray=new DoubleToken[count];
  }
  double xCur;
  double yCur;
  double wn;
  if (input.hasToken(0,count)) {
    Token[] inArray=input.get(0,count);
    for (int i=0; i < count; i++) {
      xCur=((DoubleToken)(inArray[i])).doubleValue();
      wn=xCur;
      for (int j=1; j < _denominator.length; j++) {
        wn+=_denominator[j] * _stateVector[(_curTap + j) % _stateVector.length];
      }
      _stateVector[_curTap]=wn;
      yCur=0;
      for (int k=0; k < _numerator.length; k++) {
        yCur+=_numerator[k] * _stateVector[(_curTap + k) % _stateVector.length];
      }
      _resultArray[i]=new DoubleToken(yCur);
      if (--_curTap < 0)       _curTap=_stateVector.length - 1;
    }
    output.send(0,_resultArray,count);
    return COMPLETED;
  }
 else {
    return NOT_READY;
  }
}","/** 
 * Invoke a specified number of iterations of this actor. Each iteration causes the filter to consume an input token and compute a single output token. An invocation of this method therefore applies the filter to <i>count</i> successive input tokens. <p> This method should be called instead of the usual prefire(), fire(), postfire() methods when this actor is used in a domain that supports vectorized actors.  This leads to more efficient execution.
 * @param count The number of iterations to perform.
 * @return COMPLETED if the actor was successfully iterated thespecified number of times. Otherwise, return NOT_READY, and do not consume any input tokens.
 * @exception IllegalActionException If iterating cannot beperformed.
 */
public int iterate(int count) throws IllegalActionException {
  if (count > _resultArray.length) {
    _resultArray=new DoubleToken[count];
  }
  double xCurrent;
  double yCurrent;
  double window;
  if (input.hasToken(0,count)) {
    Token[] inArray=input.get(0,count);
    for (int i=0; i < count; i++) {
      xCurrent=((DoubleToken)(inArray[i])).doubleValue();
      window=xCurrent;
      for (int j=1; j < _denominator.length; j++) {
        window+=_denominator[j] * _stateVector[(_currentTap + j) % _stateVector.length];
      }
      _stateVector[_currentTap]=window;
      yCurrent=0;
      for (int k=0; k < _numerator.length; k++) {
        yCurrent+=_numerator[k] * _stateVector[(_currentTap + k) % _stateVector.length];
      }
      _resultArray[i]=new DoubleToken(yCurrent);
      if (--_currentTap < 0)       _currentTap=_stateVector.length - 1;
    }
    output.send(0,_resultArray,count);
    return COMPLETED;
  }
 else {
    return NOT_READY;
  }
}"
75976,"/** 
 * Update the state of the actor and schedule the next firing, if appropriate.
 * @exception IllegalActionException If the director throws it whenscheduling the next firing.
 */
public boolean postfire() throws IllegalActionException {
  _currentOutputIndex=_tentativeCurrentOutputIndex;
  if (_boundaryCrossed) {
    double meanTimeValue=((DoubleToken)meanTime.getToken()).doubleValue();
    double exp=-Math.log((1 - Math.random())) * meanTimeValue;
    Director dir=getDirector();
    _nextFiringTime=dir.getCurrentTime() + exp;
    dir.fireAt(this,_nextFiringTime);
  }
  return super.postfire();
}","/** 
 * Update the state of the actor and schedule the next firing, if appropriate.
 * @exception IllegalActionException If the director throws it whenscheduling the next firing.
 */
public boolean postfire() throws IllegalActionException {
  _currentOutputIndex=_tentativeCurrentOutputIndex;
  if (_boundaryCrossed) {
    double meanTimeValue=((DoubleToken)meanTime.getToken()).doubleValue();
    double exp=-Math.log((1 - Math.random())) * meanTimeValue;
    Director director=getDirector();
    _nextFiringTime=director.getCurrentTime() + exp;
    director.fireAt(this,_nextFiringTime);
  }
  return super.postfire();
}"
75977,"/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Poisson(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  meanTime=new Parameter(this,""String_Node_Str"",new DoubleToken(1.0));
  meanTime.setTypeEquals(BaseType.DOUBLE);
  IntToken[] defaultValues=new IntToken[2];
  defaultValues[0]=new IntToken(1);
  defaultValues[1]=new IntToken(0);
  ArrayToken defaultValueToken=new ArrayToken(defaultValues);
  values=new Parameter(this,""String_Node_Str"",defaultValueToken);
  values.setTypeEquals(new ArrayType(BaseType.ANY));
  ArrayType valuesArrayType=(ArrayType)values.getType();
  InequalityTerm elemTerm=valuesArrayType.getElementTypeTerm();
  output.setTypeAtLeast(elemTerm);
  attributeChanged(values);
}","/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Poisson(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  meanTime=new Parameter(this,""String_Node_Str"",new DoubleToken(1.0));
  meanTime.setTypeEquals(BaseType.DOUBLE);
  IntToken[] defaultValues=new IntToken[2];
  defaultValues[0]=new IntToken(1);
  defaultValues[1]=new IntToken(0);
  ArrayToken defaultValueToken=new ArrayToken(defaultValues);
  values=new Parameter(this,""String_Node_Str"",defaultValueToken);
  values.setTypeEquals(new ArrayType(BaseType.ANY));
  ArrayType valuesArrayType=(ArrayType)values.getType();
  InequalityTerm elementTerm=valuesArrayType.getElementTypeTerm();
  output.setTypeAtLeast(elementTerm);
  attributeChanged(values);
}"
75978,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the parameter public members to refer to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Poisson newObject=(Poisson)super.clone(workspace);
  try {
    newObject.attributeChanged(values);
    ArrayType valuesArrayType=(ArrayType)newObject.values.getType();
    InequalityTerm elemTerm=valuesArrayType.getElementTypeTerm();
    newObject.output.setTypeAtLeast(elemTerm);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the parameter public members to refer to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Poisson newObject=(Poisson)super.clone(workspace);
  try {
    newObject.attributeChanged(values);
    ArrayType valuesArrayType=(ArrayType)newObject.values.getType();
    InequalityTerm elementTerm=valuesArrayType.getElementTypeTerm();
    newObject.output.setTypeAtLeast(elementTerm);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
  return newObject;
}"
75979,"/** 
 * If the parameter being changed is <i>values</i>, notify the director that type resolution may be invalid. This will cause type resolution to be redone when it is next needed. It is assumed that type changes in the parameters are implemented by the director's change request mechanism, so they are implemented when it is safe to redo type resolution. If there is no director, then do nothing.
 * @exception IllegalActionException If the parent class throws it.
 */
public void attributeTypeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == values) {
    Director dir=getDirector();
    if (dir != null) {
      dir.invalidateResolvedTypes();
    }
  }
 else {
    super.attributeTypeChanged(attribute);
  }
}","/** 
 * If the parameter being changed is <i>values</i>, notify the director that type resolution may be invalid. This will cause type resolution to be redone when it is next needed. It is assumed that type changes in the parameters are implemented by the director's change request mechanism, so they are implemented when it is safe to redo type resolution. If there is no director, then do nothing.
 * @exception IllegalActionException If the parent class throws it.
 */
public void attributeTypeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == values) {
    Director director=getDirector();
    if (director != null) {
      director.invalidateResolvedTypes();
    }
  }
 else {
    super.attributeTypeChanged(attribute);
  }
}"
75980,"/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Pulse(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  indexes=new Parameter(this,""String_Node_Str"",_defaultIndexToken);
  indexes.setTypeEquals(BaseType.INT_MATRIX);
  attributeChanged(indexes);
  IntToken[] defaultValues=new IntToken[2];
  defaultValues[0]=new IntToken(1);
  defaultValues[1]=new IntToken(0);
  ArrayToken defaultValueToken=new ArrayToken(defaultValues);
  values=new Parameter(this,""String_Node_Str"",defaultValueToken);
  values.setTypeEquals(new ArrayType(BaseType.ANY));
  repeat=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  repeat.setTypeEquals(BaseType.BOOLEAN);
  attributeChanged(repeat);
  ArrayType valuesArrayType=(ArrayType)values.getType();
  InequalityTerm elemTerm=valuesArrayType.getElementTypeTerm();
  output.setTypeAtLeast(elemTerm);
  attributeChanged(values);
  _zero=new IntToken(0);
}","/** 
 * Construct an actor with the specified container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Pulse(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  indexes=new Parameter(this,""String_Node_Str"",_defaultIndexToken);
  indexes.setTypeEquals(BaseType.INT_MATRIX);
  attributeChanged(indexes);
  IntToken[] defaultValues=new IntToken[2];
  defaultValues[0]=new IntToken(1);
  defaultValues[1]=new IntToken(0);
  ArrayToken defaultValueToken=new ArrayToken(defaultValues);
  values=new Parameter(this,""String_Node_Str"",defaultValueToken);
  values.setTypeEquals(new ArrayType(BaseType.ANY));
  repeat=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  repeat.setTypeEquals(BaseType.BOOLEAN);
  attributeChanged(repeat);
  ArrayType valuesArrayType=(ArrayType)values.getType();
  InequalityTerm elementTerm=valuesArrayType.getElementTypeTerm();
  output.setTypeAtLeast(elementTerm);
  attributeChanged(values);
  _zero=new IntToken(0);
}"
75981,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the parameter public members to refer to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Pulse newObject=(Pulse)super.clone(workspace);
  try {
    newObject.attributeChanged(newObject.indexes);
    newObject.attributeChanged(newObject.values);
    newObject.attributeChanged(newObject.repeat);
    ArrayType valuesArrayType=(ArrayType)newObject.values.getType();
    InequalityTerm elemTerm=valuesArrayType.getElementTypeTerm();
    newObject.output.setTypeAtLeast(elemTerm);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the parameter public members to refer to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Pulse newObject=(Pulse)super.clone(workspace);
  try {
    newObject.attributeChanged(newObject.indexes);
    newObject.attributeChanged(newObject.values);
    newObject.attributeChanged(newObject.repeat);
    ArrayType valuesArrayType=(ArrayType)newObject.values.getType();
    InequalityTerm elementTerm=valuesArrayType.getElementTypeTerm();
    newObject.output.setTypeAtLeast(elementTerm);
  }
 catch (  IllegalActionException ex) {
    throw new InternalErrorException(ex.getMessage());
  }
  return newObject;
}"
75982,"/** 
 * Notify the director that a type change has occurred that may affect the type of the output. This will cause type resolution to be redone at the next opportunity. It is assumed that type changes in the parameters are implemented by the director's change request mechanism, so they are implemented when it is safe to redo type resolution. If there is no director, then do nothing.
 * @exception IllegalActionException If the new values array has noelements in it.
 */
public void attributeTypeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == values) {
    Director dir=getDirector();
    if (dir != null) {
      dir.invalidateResolvedTypes();
    }
    try {
      ArrayToken valuesArray=(ArrayToken)values.getToken();
      Token prototype=valuesArray.getElement(0);
      _zero=prototype.zero();
    }
 catch (    ArrayIndexOutOfBoundsException ex) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
catch (    ClassCastException ex) {
      throw new IllegalActionException(this,""String_Node_Str"" + values.getToken());
    }
  }
 else {
    super.attributeTypeChanged(attribute);
  }
}","/** 
 * Notify the director that a type change has occurred that may affect the type of the output. This will cause type resolution to be redone at the next opportunity. It is assumed that type changes in the parameters are implemented by the director's change request mechanism, so they are implemented when it is safe to redo type resolution. If there is no director, then do nothing.
 * @exception IllegalActionException If the new values array has noelements in it.
 */
public void attributeTypeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == values) {
    Director director=getDirector();
    if (director != null) {
      director.invalidateResolvedTypes();
    }
    try {
      ArrayToken valuesArray=(ArrayToken)values.getToken();
      Token prototype=valuesArray.getElement(0);
      _zero=prototype.zero();
    }
 catch (    ArrayIndexOutOfBoundsException ex) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
catch (    ClassCastException ex) {
      throw new IllegalActionException(this,""String_Node_Str"" + values.getToken());
    }
  }
 else {
    super.attributeTypeChanged(attribute);
  }
}"
75983,"/** 
 * If the argument is the levels parameter, check that the array is increasing and has the right dimension.  Recompute the quantization thresholds.
 * @exception IllegalActionException If the levels array is notincreasing, or it is not a row vector.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == levels) {
    double[][] lvls=((DoubleMatrixToken)levels.getToken()).doubleMatrix();
    if (lvls.length != 1 || lvls[0].length == 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    int length=lvls[0].length;
    for (int j=1; j < length; j++) {
      if (lvls[0][j] <= lvls[0][j - 1]) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
    }
    _thresholds=new double[length - 1];
    for (int j=0; j < length - 1; j++) {
      _thresholds[j]=(lvls[0][j + 1] + lvls[0][j]) / 2.0;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the argument is the levels parameter, check that the array is increasing and has the right dimension.  Recompute the quantization thresholds.
 * @exception IllegalActionException If the levels array is notincreasing, or it is not a row vector.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == levels) {
    double[][] levelsArray=((DoubleMatrixToken)levels.getToken()).doubleMatrix();
    if (levelsArray.length != 1 || levelsArray[0].length == 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    int length=levelsArray[0].length;
    for (int j=1; j < length; j++) {
      if (levelsArray[0][j] <= levelsArray[0][j - 1]) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
    }
    _thresholds=new double[length - 1];
    for (int j=0; j < length - 1; j++) {
      _thresholds[j]=(levelsArray[0][j + 1] + levelsArray[0][j]) / 2.0;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
75984,"/** 
 * Handle parameter change events on the <i>numerator</i> and <i>denominator</i> parameters. The filter state vector is reinitialized to zero state.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If this method is invokedwith an unrecognized parameter.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == numerator) {
    _numerator=(((DoubleMatrixToken)numerator.getToken()).doubleMatrix())[0];
  }
 else   if (attribute == denominator) {
    _denominator=(((DoubleMatrixToken)denominator.getToken()).doubleMatrix())[0];
    _denominator[0]=1.0;
  }
 else {
    throw new IllegalActionException(this,""String_Node_Str"" + attribute.getName());
  }
  if ((_numerator != null) && (_denominator != null)) {
    int stateSize=(int)java.lang.Math.max(_numerator.length,_denominator.length);
    _stateVector=new double[stateSize];
  }
}","/** 
 * Handle parameter change events on the <i>numerator</i> and <i>denominator</i> parameters. The filter state vector is reinitialized to zero state.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If this method is invokedwith an unrecognized parameter.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == numerator) {
    _numerator=(((DoubleMatrixToken)numerator.getToken()).doubleMatrix())[0];
  }
 else   if (attribute == denominator) {
    _denominator=(((DoubleMatrixToken)denominator.getToken()).doubleMatrix())[0];
    _denominator[0]=1.0;
  }
 else {
    super.attributeChanged(attribute);
  }
  if ((_numerator != null) && (_denominator != null)) {
    int stateSize=(int)java.lang.Math.max(_numerator.length,_denominator.length);
    _stateVector=new double[stateSize];
  }
}"
75985,"/** 
 * Convert the argument token into an ArrayToken having this type, if losslessly conversion can be done. The argument can be an ArrayToken or a MatrixToken. If the argument is a MatrixToken, it will be converted to an ArrayToken containing a one dimensional token array if the MatrixToken has only one row, or it will be converted to an ArrayToken containing another ArrayToken (an array of arrays) if the MatrixToken has more than one row. If this type is a variable, convert the the argument into a substitution instance of this variable.
 * @param t A token.
 * @return An ArrayToken.
 * @exception IllegalActionException If lossless conversioncannot be done.
 */
public Token convert(Token t) throws IllegalActionException {
  if (!isCompatible(t)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  ArrayToken argArrTok;
  if (t instanceof MatrixToken) {
    argArrTok=fromMatrixToken((MatrixToken)t);
  }
 else {
    argArrTok=(ArrayToken)t;
  }
  if (isConstant()) {
    if (isEqualTo(argArrTok.getType())) {
      return argArrTok;
    }
 else {
      Token[] argArray=argArrTok.arrayValue();
      Token[] result=new Token[argArray.length];
      for (int i=0; i < argArray.length; i++) {
        result[i]=_elementType.convert(argArray[i]);
      }
      return new ArrayToken(result);
    }
  }
  if (isSubstitutionInstance(argArrTok.getType())) {
    return argArrTok;
  }
 else {
    throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Convert the argument token into an ArrayToken having this type, if losslessly conversion can be done. The argument can be an ArrayToken or a MatrixToken. If the argument is a MatrixToken, it will be converted to an ArrayToken containing a one dimensional token array if the MatrixToken has only one row, or it will be converted to an ArrayToken containing another ArrayToken (an array of arrays) if the MatrixToken has more than one row.
 * @param t A token.
 * @return An ArrayToken.
 * @exception IllegalActionException If lossless conversioncannot be done.
 */
public Token convert(Token t) throws IllegalActionException {
  if (!isCompatible(t)) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  ArrayToken argArrTok;
  if (t instanceof MatrixToken) {
    argArrTok=fromMatrixToken((MatrixToken)t);
  }
 else {
    argArrTok=(ArrayToken)t;
  }
  Token[] argArray=argArrTok.arrayValue();
  Token[] result=new Token[argArray.length];
  for (int i=0; i < argArray.length; i++) {
    result[i]=_elementType.convert(argArray[i]);
  }
  return new ArrayToken(result);
}"
75986,"/** 
 * Send the specified portion of a token array to all receivers  connected to the specified channel, checking the type and converting the token if necessary. The first  <i>vectorLength</i> tokens of the token array are sent. If the port is not connected to anything, or receivers have not been created in the remote port, or the channel index is out of range, or the port is not an output port, then just silently return.  This behavior makes it easy to leave output ports unconnected when you are not interested in the output. <p> To improve effiecency for the common case where the type of the tokens to send matches the type of this port and all connected ports, this method assumes that all of the tokens in the  specified portion of the token array are of the same type. If this is not the case, then the non-vectorized send() method should be used instead. The implementation only actually checks the  type of the first token in the array, and then assumes that  the remaining tokens are of the same type.  <p> If the type of the tokens in the specified portion of the  token array is the type of this port, or the tokens in the specified portion of the  token array can be converted to that type losslessly, the tokens in the specified portion of the  token array are sent to all receivers connected to the specified channel. Otherwise, IllegalActionException is thrown. Before putting the tokens in the specified portion of the  token array into the destination receivers, this method also checks the type of the remote input port, and converts the tokens if necessary. The conversion is done by calling the convert() method of the type of the remote input port. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a put, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling put.
 * @param channelIndex The index of the channel, from 0 to width-1
 * @param tokenArray The token array to send
 * @param vectorLength The number of elements of of the tokenarray to send.
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException If the tokens to be sent cannotbe converted to the type of this port.
 */
public void send(int channelIndex,Token[] tokenArray,int vectorLength) throws IllegalActionException, NoRoomException {
  Receiver[][] farRec;
  Token token=null;
  try {
    try {
      _workspace.getReadAccess();
      token=tokenArray[0];
      int compare=TypeLattice.compare(token.getType(),_resolvedType);
      if (compare == CPO.HIGHER || compare == CPO.INCOMPARABLE) {
        throw new IllegalArgumentException(""String_Node_Str"" + token.getType().toString() + ""String_Node_Str""+ getFullName()+ ""String_Node_Str""+ getType().toString());
      }
      farRec=getRemoteReceivers();
      if (farRec == null || farRec[channelIndex] == null) {
        System.out.println(""String_Node_Str"");
        return;
      }
    }
  finally {
      _workspace.doneReading();
    }
    for (int j=0; j < farRec[channelIndex].length; j++) {
      TypedIOPort port=(TypedIOPort)farRec[channelIndex][j].getContainer();
      Type farType=port.getType();
      if (farType.isEqualTo(token.getType())) {
        farRec[channelIndex][j].putArray(tokenArray,vectorLength);
      }
 else {
        for (int i=0; i < vectorLength; i++) {
          tokenArray[i]=farType.convert(tokenArray[i]);
        }
        farRec[channelIndex][j].putArray(tokenArray,vectorLength);
      }
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
}","/** 
 * Send the specified portion of a token array to all receivers  connected to the specified channel, checking the type and converting the token if necessary. The first  <i>vectorLength</i> tokens of the token array are sent. If the port is not connected to anything, or receivers have not been created in the remote port, or the channel index is out of range, or the port is not an output port, then just silently return.  This behavior makes it easy to leave output ports unconnected when you are not interested in the output. <p> To improve effiecency for the common case where the type of the tokens to send matches the type of this port and all connected ports, this method assumes that all of the tokens in the  specified portion of the token array are of the same type. If this is not the case, then the non-vectorized send() method should be used instead. The implementation only actually checks the  type of the first token in the array, and then assumes that  the remaining tokens are of the same type.  <p> If the type of the tokens in the specified portion of the  token array is the type of this port, or the tokens in the specified portion of the  token array can be converted to that type losslessly, the tokens in the specified portion of the  token array are sent to all receivers connected to the specified channel. Otherwise, IllegalActionException is thrown. Before putting the tokens in the specified portion of the  token array into the destination receivers, this method also checks the type of the remote input port, and converts the tokens if necessary. The conversion is done by calling the convert() method of the type of the remote input port. <p> Some of this method is read-synchronized on the workspace. Since it is possible for a thread to block while executing a put, it is important that the thread does not hold read access on the workspace when it is blocked. Thus this method releases read access on the workspace before calling put.
 * @param channelIndex The index of the channel, from 0 to width-1
 * @param tokenArray The token array to send
 * @param vectorLength The number of elements of of the tokenarray to send.
 * @exception NoRoomException If there is no room in the receiver.
 * @exception IllegalActionException If the tokens to be sent cannotbe converted to the type of this port.
 */
public void send(int channelIndex,Token[] tokenArray,int vectorLength) throws IllegalActionException, NoRoomException {
  Receiver[][] farRec;
  Token token=null;
  try {
    try {
      _workspace.getReadAccess();
      token=tokenArray[0];
      int compare=TypeLattice.compare(token.getType(),_resolvedType);
      if (compare == CPO.HIGHER || compare == CPO.INCOMPARABLE) {
        throw new IllegalArgumentException(""String_Node_Str"" + token.getType().toString() + ""String_Node_Str""+ getFullName()+ ""String_Node_Str""+ getType().toString());
      }
      farRec=getRemoteReceivers();
      if (farRec == null || farRec[channelIndex] == null) {
        System.out.println(""String_Node_Str"");
        return;
      }
    }
  finally {
      _workspace.doneReading();
    }
    for (int j=0; j < farRec[channelIndex].length; j++) {
      TypedIOPort port=(TypedIOPort)farRec[channelIndex][j].getContainer();
      Type farType=port.getType();
      if (farType.isEqualTo(token.getType())) {
        farRec[channelIndex][j].putArray(tokenArray,vectorLength);
      }
 else {
        for (int i=0; i < vectorLength; i++) {
          farRec[channelIndex][j].put(farType.convert(tokenArray[i]));
        }
      }
    }
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
}"
75987,"private void _setToken(Token newToken) throws IllegalActionException {
  if (newToken == null) {
    if (_valueDependents != null && !_valueDependents.isEmpty()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    _token=null;
    _needsEvaluation=false;
    if (_declaredType instanceof BaseType) {
      _varType=_declaredType;
    }
 else {
      ((StructuredType)_varType).initialize(BaseType.ANY);
    }
  }
 else {
    if (_declaredType.isCompatible(newToken)) {
      newToken=_declaredType.convert(newToken);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + newToken.getType().toString() + ""String_Node_Str""+ ""String_Node_Str""+ _varType.toString());
    }
    if (_declaredType instanceof StructuredType) {
      ((StructuredType)_varType).updateType((StructuredType)newToken.getType());
    }
 else {
      _varType=newToken.getType();
    }
    if (_typeAtMost != BaseType.NAT) {
      Type tokenType=newToken.getType();
      int comparison=TypeLattice.compare(tokenType,_typeAtMost);
      if ((comparison == CPO.HIGHER) || (comparison == CPO.INCOMPARABLE)) {
        throw new IllegalActionException(this,""String_Node_Str"" + tokenType.toString() + ""String_Node_Str""+ _typeAtMost.toString());
      }
    }
    if (_noTokenYet) {
      _initialExpression=_currentExpression;
      if (_currentExpression == null) {
        _initialToken=newToken;
      }
      _noTokenYet=false;
    }
    _token=newToken;
    _needsEvaluation=false;
  }
}","private void _setToken(Token newToken) throws IllegalActionException {
  if (newToken == null) {
    if (_valueDependents != null && !_valueDependents.isEmpty()) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    _token=null;
    _needsEvaluation=false;
    if (_declaredType instanceof BaseType) {
      _varType=_declaredType;
    }
 else {
      ((StructuredType)_varType).initialize(BaseType.ANY);
    }
  }
 else {
    if (_declaredType.isCompatible(newToken)) {
      if (_declaredType instanceof StructuredType) {
        ((StructuredType)_declaredType).initialize(BaseType.ANY);
      }
      newToken=_declaredType.convert(newToken);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + newToken.getType().toString() + ""String_Node_Str""+ ""String_Node_Str""+ _varType.toString());
    }
    if (_declaredType instanceof StructuredType) {
      ((StructuredType)_varType).updateType((StructuredType)newToken.getType());
    }
 else {
      _varType=newToken.getType();
    }
    if (_typeAtMost != BaseType.NAT) {
      Type tokenType=newToken.getType();
      int comparison=TypeLattice.compare(tokenType,_typeAtMost);
      if ((comparison == CPO.HIGHER) || (comparison == CPO.INCOMPARABLE)) {
        throw new IllegalActionException(this,""String_Node_Str"" + tokenType.toString() + ""String_Node_Str""+ _typeAtMost.toString());
      }
    }
    if (_noTokenYet) {
      _initialExpression=_currentExpression;
      if (_currentExpression == null) {
        _initialToken=newToken;
      }
      _noTokenYet=false;
    }
    _token=newToken;
    _needsEvaluation=false;
  }
}"
75988,"/** 
 * Return the scheduling sequence as an enumeration. For efficiency, this method returns a cached version of the schedule, if it is valid.  Otherwise, it calls the protected method _schedule() to update the schedule.  Derived classes would normally override the protected method, not this one. The validity of the current schedule is set by the setValid() method. This method is read-synchronized on the workspace.
 * @return The Enumeration returned by the _schedule() method.
 * @exception IllegalActionException If the scheduler has no container(a director), or the director has no container (a CompositeActor).
 * @exception NotSchedulableException If the _schedule() methodthrows it. Not thrown in this base class, but may be needed by the derived schedulers.
 */
public Enumeration schedule() throws IllegalActionException, NotSchedulableException {
  try {
    workspace().getReadAccess();
    StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
    if (dir == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    CompositeActor ca=(CompositeActor)(dir.getContainer());
    if (ca == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (!isValid()) {
      _cachedSchedule=new ArrayList();
      Enumeration newSchedEnum=_schedule();
      while (newSchedEnum.hasMoreElements()) {
        _cachedSchedule.add(newSchedEnum.nextElement());
      }
    }
    return Collections.enumeration(_cachedSchedule);
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Return the scheduling sequence as an enumeration. For efficiency, this method returns a cached version of the schedule, if it is valid.  Otherwise, it calls the protected method _schedule() to update the schedule.  Derived classes would normally override the protected method, not this one. The validity of the current schedule is set by the setValid() method. This method is read-synchronized on the workspace.
 * @return The Enumeration returned by the _schedule() method.
 * @exception IllegalActionException If the scheduler has no container(a director), or the director has no container (a CompositeActor).
 * @exception NotSchedulableException If the _schedule() methodthrows it. Not thrown in this base class, but may be needed by the derived schedulers.
 */
public Enumeration schedule() throws IllegalActionException, NotSchedulableException {
  try {
    workspace().getReadAccess();
    StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
    if (dir == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    CompositeActor ca=(CompositeActor)(dir.getContainer());
    if (ca == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (!isValid() || _cachedSchedule == null) {
      _cachedSchedule=new ArrayList();
      Enumeration newSchedEnum=_schedule();
      while (newSchedEnum.hasMoreElements()) {
        _cachedSchedule.add(newSchedEnum.nextElement());
      }
    }
    return Collections.enumeration(_cachedSchedule);
  }
  finally {
    workspace().doneReading();
  }
}"
75989,"/** 
 * Validate/invalidate the current schedule by giving a true/false argument. A true argument will indicate that the current schedule is valid and can be returned immediately when schedule() is called without running the scheduling algorithm. A false argument will invalidate it.
 * @param valid True to set the current schedule to valid.
 */
public void setValid(boolean valid){
  _valid=valid;
}","/** 
 * Validate/invalidate the current schedule by giving a true/false argument. A true argument will indicate that the current schedule is valid and can be returned immediately when schedule() is called without running the scheduling algorithm. A false argument will invalidate it.
 * @param valid True to set the current schedule to valid.
 */
public void setValid(boolean valid){
  _valid=valid;
  if (valid == false) {
    _cachedSchedule=null;
    _cachedGetSchedule=null;
  }
}"
75990,"/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method returns a cached version of the schedule, if it is valid.  Otherwise, it calls the protected method _getSchedule() to update the schedule.  Derived classes would normally override the protected method, not this one. The validity of the current schedule is set by the setValid() method. This method is read-synchronized on the workspace.
 * @return The Schedule returned by the _getSchedule() method.
 * @exception IllegalActionException If the scheduler has no container(a director), or the director has no container (a CompositeActor).
 * @exception NotSchedulableException If the _getSchedule() methodthrows it. Not thrown in this base class, but may be needed by the derived schedulers.
 */
public Schedule getSchedule() throws IllegalActionException, NotSchedulableException {
  try {
    workspace().getReadAccess();
    StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
    if (dir == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    CompositeActor ca=(CompositeActor)(dir.getContainer());
    if (ca == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (!isValid()) {
      _cachedGetSchedule=_getSchedule();
    }
    if (_cachedGetSchedule == null) {
      _cachedGetSchedule=_getSchedule();
    }
    return _cachedGetSchedule;
  }
  finally {
    workspace().doneReading();
  }
}","/** 
 * Return the scheduling sequence as an instance of Schedule. For efficiency, this method returns a cached version of the schedule, if it is valid.  Otherwise, it calls the protected method _getSchedule() to update the schedule.  Derived classes would normally override the protected method, not this one. The validity of the current schedule is set by the setValid() method. This method is read-synchronized on the workspace.
 * @return The Schedule returned by the _getSchedule() method.
 * @exception IllegalActionException If the scheduler has no container(a director), or the director has no container (a CompositeActor).
 * @exception NotSchedulableException If the _getSchedule() methodthrows it. Not thrown in this base class, but may be needed by the derived schedulers.
 */
public Schedule getSchedule() throws IllegalActionException, NotSchedulableException {
  try {
    workspace().getReadAccess();
    StaticSchedulingDirector dir=(StaticSchedulingDirector)getContainer();
    if (dir == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    CompositeActor ca=(CompositeActor)(dir.getContainer());
    if (ca == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (!isValid() || _cachedGetSchedule == null) {
      _cachedGetSchedule=_getSchedule();
    }
    return _cachedGetSchedule;
  }
  finally {
    workspace().doneReading();
  }
}"
75991,"/** 
 * Set the scheduler for this StaticSchedulingDirector. The container of the specified scheduler is set to this director. If there was a previous scheduler, the container of that scheduler is set to null. This method is write-synchronized on the workspace. If the scheduler is not compatible with the director, an IllegalActionException is thrown.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException Not thrown in this base class,but derived classes may throw it if the scheduler is not compatible.
 */
public void setScheduler(Scheduler scheduler) throws IllegalActionException {
  if (scheduler != null && workspace() != scheduler.workspace()) {
    throw new IllegalActionException(this,scheduler,""String_Node_Str"");
  }
  try {
    workspace().getWriteAccess();
    if (_scheduler != null)     _scheduler._makeSchedulerOf(null);
    if (scheduler != null) {
      scheduler._makeSchedulerOf(this);
    }
    _scheduler=scheduler;
  }
  finally {
    workspace().doneWriting();
  }
}","/** 
 * Set the scheduler for this StaticSchedulingDirector. The container of the specified scheduler is set to this director. If there was a previous scheduler, the container of that scheduler is set to null. This method is write-synchronized on the workspace. If the scheduler is not compatible with the director, an IllegalActionException is thrown.
 * @param director The Director responsible for execution.
 * @exception IllegalActionException Not thrown in this base class,but derived classes may throw it if the scheduler is not compatible.
 */
public void setScheduler(Scheduler scheduler) throws IllegalActionException {
  if (scheduler != null && workspace() != scheduler.workspace()) {
    throw new IllegalActionException(this,scheduler,""String_Node_Str"");
  }
  try {
    workspace().getWriteAccess();
    if (_scheduler != null) {
      _scheduler._makeSchedulerOf(null);
    }
    _scheduler=scheduler;
    if (scheduler != null) {
      scheduler._makeSchedulerOf(this);
    }
  }
  finally {
    workspace().doneWriting();
  }
}"
75992,"/** 
 * Create a new effigy in the given container by reading the specified URL. If the specified URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param in The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL in) throws Exception {
  PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
  if (in == null) {
    NamedObj entity=getEntity(""String_Node_Str"");
    NamedObj newModel;
    if (entity != null) {
      newModel=(NamedObj)entity.clone(new Workspace());
    }
 else {
      newModel=new TypedCompositeActor(new Workspace());
    }
    newModel.setName(""String_Node_Str"");
    effigy.setModel(newModel);
    return effigy;
  }
 else {
    String extension=getExtension(in);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      return null;
    }
    MoMLParser parser=new MoMLParser();
    NamedObj toplevel=null;
    try {
      toplevel=parser.parse(base,in.openStream());
      if (toplevel != null) {
        effigy.setModel(toplevel);
        URLAttribute url=new URLAttribute(toplevel,toplevel.uniqueName(""String_Node_Str""));
        url.setURL(in);
        effigy.url.setURL(in);
        return effigy;
      }
 else {
        effigy.setContainer(null);
      }
    }
  finally {
      if (toplevel == null) {
        effigy.setContainer(null);
      }
    }
    return null;
  }
}","/** 
 * Create a new effigy in the given container by reading the specified URL. If the specified URL is null, then create a blank effigy. The blank effigy will have a new model associated with it. If this effigy factory contains an entity named ""blank"", then the new model will be a clone of that entity.  Otherwise, it will be an instance of TypedCompositeActor. If the URL does not end with extension "".xml"" or "".moml"", then return null.  If the URL points to an XML file that is not a MoML file, then also return null. The specified base is used to expand any relative file references within the URL.
 * @param container The container for the effigy.
 * @param base The base for relative file references, or null ifthere are no relative file references.
 * @param in The input URL.
 * @return A new instance of PtolemyEffigy, or null if the URLdoes not specify a Ptolemy II model.
 * @exception Exception If the URL cannot be read, or if the datais malformed in some way.
 */
public Effigy createEffigy(CompositeEntity container,URL base,URL in) throws Exception {
  PtolemyEffigy effigy=new PtolemyEffigy(container,container.uniqueName(""String_Node_Str""));
  if (in == null) {
    NamedObj entity=getEntity(""String_Node_Str"");
    NamedObj newModel;
    if (entity != null) {
      newModel=(NamedObj)entity.clone(new Workspace());
    }
 else {
      newModel=new TypedCompositeActor(new Workspace());
    }
    newModel.setName(""String_Node_Str"");
    effigy.setModel(newModel);
    return effigy;
  }
 else {
    String extension=getExtension(in);
    if (!extension.equals(""String_Node_Str"") && !extension.equals(""String_Node_Str"")) {
      return null;
    }
    MoMLParser parser=new MoMLParser();
    NamedObj toplevel=null;
    try {
      try {
        toplevel=parser.parse(base,in.openStream());
        if (toplevel != null) {
          effigy.setModel(toplevel);
          URLAttribute url=new URLAttribute(toplevel,toplevel.uniqueName(""String_Node_Str""));
          url.setURL(in);
          effigy.url.setURL(in);
          return effigy;
        }
 else {
          effigy.setContainer(null);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        throw e;
      }
    }
  finally {
      if (toplevel == null) {
        effigy.setContainer(null);
      }
    }
    return null;
  }
}"
75993,"/** 
 * Push the rates calculated for this system up to the contained Actor. This allows the container to be properly scheduled if it is in a hierarchical system
 * @exception IllegalActionException If any called method throws it.
 */
private void _setContainerRates() throws NotSchedulableException, IllegalActionException {
  Director director=(Director)getContainer();
  if (director == null)   throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"");
  CompositeActor container=(CompositeActor)director.getContainer();
  if (container == null)   throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"");
  Iterator ports=container.portList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    Iterator connectedports=port.insidePortList().iterator();
    int consumptionRate=0;
    int productionRate=0;
    int initProduction=0;
    if (connectedports.hasNext()) {
      IOPort cport=(IOPort)connectedports.next();
      Entity cactor=(Entity)cport.getContainer();
      consumptionRate=_getFiringCount(cactor) * getTokenConsumptionRate(cport);
      productionRate=_getFiringCount(cactor) * getTokenProductionRate(cport);
      initProduction=_getFiringCount(cactor) * getTokenInitProduction(cport);
      if (_debugging) {
        _debug(""String_Node_Str"" + cport.getName());
        _debug(""String_Node_Str"" + consumptionRate);
        _debug(""String_Node_Str"" + productionRate);
        _debug(""String_Node_Str"" + initProduction);
      }
    }
    while (connectedports.hasNext()) {
      IOPort cport=(IOPort)connectedports.next();
      Entity cactor=(Entity)cport.getContainer();
      int crate=_getFiringCount(cactor) * getTokenConsumptionRate(cport);
      if (crate != consumptionRate)       throw new NotSchedulableException(port,cport,""String_Node_Str"" + cport.getName() + ""String_Node_Str""+ crate+ ""String_Node_Str""+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ consumptionRate+ ""String_Node_Str"");
      int prate=_getFiringCount(cactor) * getTokenProductionRate(cport);
      if (prate != productionRate)       throw new NotSchedulableException(port,cport,""String_Node_Str"" + cport.getName() + ""String_Node_Str""+ prate+ ""String_Node_Str""+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ productionRate+ ""String_Node_Str"");
      int initp=_getFiringCount(cactor) * getTokenInitProduction(cport);
      if (initp != initProduction)       throw new NotSchedulableException(port,cport,""String_Node_Str"" + cport.getName() + ""String_Node_Str""+ initp+ ""String_Node_Str""+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ initProduction+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + port.getName());
      _debug(""String_Node_Str"" + consumptionRate);
      _debug(""String_Node_Str"" + productionRate);
      _debug(""String_Node_Str"" + initProduction);
    }
    try {
      Parameter param;
      param=(Parameter)port.getAttribute(""String_Node_Str"");
      if (param == null)       param=new Parameter(port,""String_Node_Str"",new IntToken(1));
      param.setToken(new IntToken(consumptionRate));
      param=(Parameter)port.getAttribute(""String_Node_Str"");
      if (param == null)       param=new Parameter(port,""String_Node_Str"",new IntToken(1));
      param.setToken(new IntToken(productionRate));
      param=(Parameter)port.getAttribute(""String_Node_Str"");
      if (param == null)       param=new Parameter(port,""String_Node_Str"",new IntToken(1));
      param.setToken(new IntToken(initProduction));
    }
 catch (    Exception ex) {
    }
  }
}","/** 
 * Push the rates calculated for this system up to the contained Actor. This allows the container to be properly scheduled if it is in a hierarchical system
 * @exception IllegalActionException If any called method throws it.
 */
private void _setContainerRates() throws NotSchedulableException, IllegalActionException {
  Director director=(Director)getContainer();
  if (director == null)   throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"");
  CompositeActor container=(CompositeActor)director.getContainer();
  if (container == null)   throw new NotSchedulableException(""String_Node_Str"" + ""String_Node_Str"");
  Iterator ports=container.portList().iterator();
  while (ports.hasNext()) {
    IOPort port=(IOPort)ports.next();
    Iterator connectedports=port.insidePortList().iterator();
    int consumptionRate=0;
    int productionRate=0;
    int initProduction=0;
    List connectedInputPortList=new LinkedList();
    List connectedOutputPortList=new LinkedList();
    while (connectedports.hasNext()) {
      IOPort cport=(IOPort)connectedports.next();
      if (cport.isInput()) {
        connectedInputPortList.add(cport);
      }
      if (cport.isOutput()) {
        connectedOutputPortList.add(cport);
      }
    }
    Iterator inputPorts=connectedInputPortList.iterator();
    if (inputPorts.hasNext()) {
      IOPort cport=(IOPort)inputPorts.next();
      Entity cactor=(Entity)cport.getContainer();
      consumptionRate=_getFiringCount(cactor) * getTokenConsumptionRate(cport);
      if (_debugging) {
        _debug(""String_Node_Str"" + cport.getName());
        _debug(""String_Node_Str"" + consumptionRate);
      }
    }
    while (inputPorts.hasNext()) {
      IOPort cport=(IOPort)inputPorts.next();
      Entity cactor=(Entity)cport.getContainer();
      int crate=_getFiringCount(cactor) * getTokenConsumptionRate(cport);
      if (crate != consumptionRate)       throw new NotSchedulableException(port,cport,""String_Node_Str"" + cport.getName() + ""String_Node_Str""+ crate+ ""String_Node_Str""+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ consumptionRate+ ""String_Node_Str"");
    }
    Iterator outputPorts=connectedOutputPortList.iterator();
    if (outputPorts.hasNext()) {
      IOPort cport=(IOPort)outputPorts.next();
      Entity cactor=(Entity)cport.getContainer();
      productionRate=_getFiringCount(cactor) * getTokenProductionRate(cport);
      initProduction=_getFiringCount(cactor) * getTokenInitProduction(cport);
      if (_debugging) {
        _debug(""String_Node_Str"" + cport.getName());
        _debug(""String_Node_Str"" + productionRate);
        _debug(""String_Node_Str"" + initProduction);
      }
    }
    while (outputPorts.hasNext()) {
      IOPort cport=(IOPort)outputPorts.next();
      Entity cactor=(Entity)cport.getContainer();
      int prate=_getFiringCount(cactor) * getTokenProductionRate(cport);
      if (prate != productionRate)       throw new NotSchedulableException(port,cport,""String_Node_Str"" + cport.getName() + ""String_Node_Str""+ prate+ ""String_Node_Str""+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ productionRate+ ""String_Node_Str"");
      int initp=_getFiringCount(cactor) * getTokenInitProduction(cport);
      if (initp != initProduction)       throw new NotSchedulableException(port,cport,""String_Node_Str"" + cport.getName() + ""String_Node_Str""+ initp+ ""String_Node_Str""+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str""+ initProduction+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + port.getName());
      _debug(""String_Node_Str"" + consumptionRate);
      _debug(""String_Node_Str"" + productionRate);
      _debug(""String_Node_Str"" + initProduction);
    }
    try {
      Parameter param;
      param=(Parameter)port.getAttribute(""String_Node_Str"");
      if (param == null)       param=new Parameter(port,""String_Node_Str"",new IntToken(1));
      param.setToken(new IntToken(consumptionRate));
      param=(Parameter)port.getAttribute(""String_Node_Str"");
      if (param == null)       param=new Parameter(port,""String_Node_Str"",new IntToken(1));
      param.setToken(new IntToken(productionRate));
      param=(Parameter)port.getAttribute(""String_Node_Str"");
      if (param == null)       param=new Parameter(port,""String_Node_Str"",new IntToken(1));
      param.setToken(new IntToken(initProduction));
    }
 catch (    Exception ex) {
    }
  }
}"
75994,"/** 
 * Get the name of this object relative to the specified container.  A recursive structure, where this object is directly or indirectly contained by itself, may result in a runtime exception of class InvalidStateException if it is detected.  Note that it is not possible to construct a recursive structure using this class alone, since there is no container. But derived classes might erroneously permit recursive structures, so this error is caught here. If the given container is not actually a container of this object, or is null, then the full name of the object is returned. This method is read-synchronized on the workspace.
 * @param parent An object that deeply contains this object.
 * @return A string of the form ""name2...nameN"".
 */
public String getName(NamedObj parent){
  if (parent == null) {
    return getFullName();
  }
  try {
    _workspace.getReadAccess();
    String name=getName();
    Set visited=new HashSet();
    visited.add(this);
    Nameable container=getContainer();
    while (container != null && container != parent) {
      if (visited.contains(container)) {
        throw new InvalidStateException(""String_Node_Str"");
      }
      name=container.getName() + ""String_Node_Str"" + name;
      visited.add(container);
      container=container.getContainer();
    }
    if (container == null) {
      return getFullName();
    }
    return name;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Get the name of this object relative to the specified container. A recursive structure, where this object is directly or indirectly contained by itself, may result in a runtime exception of class InvalidStateException if it is detected.  Note that it is not possible to construct a recursive structure using this class alone, since there is no container. But derived classes might erroneously permit recursive structures, so this error is caught here. If the given container is not actually a container of this object, or is null, then the full name of the object is returned. This method is read-synchronized on the workspace.
 * @param parent An object that deeply contains this object.
 * @return A string of the form ""name2...nameN"".
 */
public String getName(NamedObj parent){
  if (parent == null) {
    return getFullName();
  }
  try {
    _workspace.getReadAccess();
    String name=getName();
    Set visited=new HashSet();
    visited.add(this);
    Nameable container=getContainer();
    while (container != null && container != parent) {
      if (visited.contains(container)) {
        throw new InvalidStateException(""String_Node_Str"");
      }
      name=container.getName() + ""String_Node_Str"" + name;
      visited.add(container);
      container=container.getContainer();
    }
    if (container == null) {
      return getFullName();
    }
    return name;
  }
  finally {
    _workspace.doneReading();
  }
}"
75995,"/** 
 * Return a description of the object.  The level of detail depends on the argument, which is an or-ing of the static final constants defined in this class (NamedObj).  Lines are indented according to to the level argument using the protected method _getIndentPrefix(). Zero, one or two brackets can be specified to surround the returned description.  If one is specified it is the the leading bracket. This is used by derived classes that will append to the description. Those derived classes are responsible for the closing bracket. An argument other than 0, 1, or 2 is taken to be equivalent to 0. This method is read-synchronized on the workspace.
 * @param detail The level of detail.
 * @param indent The amount of indenting.
 * @param bracket The number of surrounding brackets (0, 1, or 2).
 * @return A description of the object.
 */
protected String _description(int detail,int indent,int bracket){
  try {
    _workspace.getReadAccess();
    String result=_getIndentPrefix(indent);
    if (bracket == 1 || bracket == 2)     result+=""String_Node_Str"";
    if ((detail & CLASSNAME) != 0) {
      result+=getClass().getName();
      if ((detail & FULLNAME) != 0) {
        result+=""String_Node_Str"";
      }
    }
    if ((detail & FULLNAME) != 0) {
      result+=""String_Node_Str"" + getFullName() + ""String_Node_Str"";
    }
    if ((detail & ATTRIBUTES) != 0) {
      if ((detail & (CLASSNAME | FULLNAME)) != 0) {
        result+=""String_Node_Str"";
      }
      result+=""String_Node_Str"";
      if ((detail & DEEP) == 0) {
        detail&=~ATTRIBUTES;
      }
      Iterator params=attributeList().iterator();
      while (params.hasNext()) {
        Attribute p=(Attribute)params.next();
        result+=p._description(detail,indent + 1,2) + ""String_Node_Str"";
      }
      result+=_getIndentPrefix(indent) + ""String_Node_Str"";
    }
    if (bracket == 2)     result+=""String_Node_Str"";
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Return a description of the object.  The level of detail depends on the argument, which is an or-ing of the static final constants defined in this class (NamedObj).  Lines are indented according to to the level argument using the protected method _getIndentPrefix(). Zero, one or two brackets can be specified to surround the returned description.  If one is specified it is the the leading bracket. This is used by derived classes that will append to the description. Those derived classes are responsible for the closing bracket. An argument other than 0, 1, or 2 is taken to be equivalent to 0. This method is read-synchronized on the workspace.
 * @param detail The level of detail.
 * @param indent The amount of indenting.
 * @param bracket The number of surrounding brackets (0, 1, or 2).
 * @return A description of the object.
 */
protected String _description(int detail,int indent,int bracket){
  try {
    _workspace.getReadAccess();
    String result=_getIndentPrefix(indent);
    if (bracket == 1 || bracket == 2)     result+=""String_Node_Str"";
    if ((detail & CLASSNAME) != 0) {
      result+=getClass().getName();
      if ((detail & FULLNAME) != 0) {
        result+=""String_Node_Str"";
      }
    }
    if ((detail & FULLNAME) != 0) {
      result+=""String_Node_Str"" + getFullName() + ""String_Node_Str"";
    }
    if ((detail & ATTRIBUTES) != 0) {
      if ((detail & (CLASSNAME | FULLNAME)) != 0) {
        result+=""String_Node_Str"";
      }
      result+=""String_Node_Str"";
      if ((detail & DEEP) == 0) {
        detail&=~ATTRIBUTES;
      }
      Iterator parameters=attributeList().iterator();
      while (parameters.hasNext()) {
        Attribute parameter=(Attribute)parameters.next();
        result+=parameter._description(detail,indent + 1,2) + ""String_Node_Str"";
      }
      result+=_getIndentPrefix(indent) + ""String_Node_Str"";
    }
    if (bracket == 2)     result+=""String_Node_Str"";
    return result;
  }
  finally {
    _workspace.doneReading();
  }
}"
75996,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). This uses the clone() method of java.lang.Object, which makes a field-by-field copy. It then adjusts the workspace reference and clones the attributes on the attribute list, if there is one. In addition, if this object has the MoML element name ""class"", as determined by className field of the associated MoMLInfo object, then the new object will not export its contents when exportMoML() is called, but rather will declare that it extends this one, and will export only its attributes. This method read-synchronizes on the workspace.
 * @param ws The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #getMoMLInfo()
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace ws) throws CloneNotSupportedException {
  try {
    _workspace.getReadAccess();
    NamedObj newobj=(NamedObj)super.clone();
    newobj._attributes=null;
    newobj._workspace=ws;
    newobj._fullNameVersion=-1;
    Iterator params=attributeList().iterator();
    while (params.hasNext()) {
      Attribute p=(Attribute)params.next();
      Attribute np=(Attribute)p.clone(ws);
      try {
        np.setContainer(newobj);
      }
 catch (      KernelException ex) {
        throw new CloneNotSupportedException(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ ex.getMessage());
      }
    }
    if (_debugging) {
      if (ws == null) {
        _debug(""String_Node_Str"",getFullName(),""String_Node_Str"");
      }
 else {
        _debug(""String_Node_Str"",getFullName(),""String_Node_Str"",ws.getFullName());
      }
    }
    if (_MoMLInfo != null) {
      newobj._MoMLInfo=new MoMLInfo(newobj);
      newobj._MoMLInfo.elementName=_MoMLInfo.elementName;
      newobj._MoMLInfo.source=_MoMLInfo.source;
      newobj._MoMLInfo.deferredFrom=null;
      if (_MoMLInfo.deferTo != null) {
        _MoMLInfo.deferTo._MoMLInfo.getDeferredFrom().add(newobj);
      }
      if (getMoMLInfo().elementName.equals(""String_Node_Str"")) {
        newobj._setDeferMoMLDefinitionTo(this);
        newobj._MoMLInfo.className=getFullName();
      }
 else {
        newobj._MoMLInfo.className=_MoMLInfo.className;
      }
    }
    return newobj;
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). This uses the clone() method of java.lang.Object, which makes a field-by-field copy. It then adjusts the workspace reference and clones the attributes on the attribute list, if there is one. In addition, if this object has the MoML element name ""class"", as determined by className field of the associated MoMLInfo object, then the new object will not export its contents when exportMoML() is called, but rather will declare that it extends this one, and will export only its attributes. This method read-synchronizes on the workspace.
 * @param ws The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #getMoMLInfo()
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  try {
    _workspace.getReadAccess();
    NamedObj newObject=(NamedObj)super.clone();
    newObject._attributes=null;
    newObject._workspace=workspace;
    newObject._fullNameVersion=-1;
    Iterator parameters=attributeList().iterator();
    while (parameters.hasNext()) {
      Attribute parameter=(Attribute)parameters.next();
      Attribute newParameter=(Attribute)parameter.clone(workspace);
      try {
        newParameter.setContainer(newObject);
      }
 catch (      KernelException exception) {
        throw new CloneNotSupportedException(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ exception.getMessage());
      }
    }
    if (_debugging) {
      if (workspace == null) {
        _debug(""String_Node_Str"",getFullName(),""String_Node_Str"");
      }
 else {
        _debug(""String_Node_Str"",getFullName(),""String_Node_Str"",workspace.getFullName());
      }
    }
    if (_MoMLInfo != null) {
      newObject._MoMLInfo=new MoMLInfo(newObject);
      newObject._MoMLInfo.elementName=_MoMLInfo.elementName;
      newObject._MoMLInfo.source=_MoMLInfo.source;
      newObject._MoMLInfo.deferredFrom=null;
      if (_MoMLInfo.deferTo != null) {
        _MoMLInfo.deferTo._MoMLInfo.getDeferredFrom().add(newObject);
      }
      if (getMoMLInfo().elementName.equals(""String_Node_Str"")) {
        newObject._setDeferMoMLDefinitionTo(this);
        newObject._MoMLInfo.className=getFullName();
      }
 else {
        newObject._MoMLInfo.className=_MoMLInfo.className;
      }
    }
    return newObject;
  }
  finally {
    _workspace.doneReading();
  }
}"
75997,"/** 
 * Increment the iteration counter, and if it equals the value of the <i>firingCountLimit</i> parameter, return false. Otherwise, return true.  Derived classes should call this at the end of their postfire() method and return its returned value.
 * @exception IllegalActionException If firingCountLimit hasan invalid expression.
 */
public boolean postfire() throws IllegalActionException {
  _iterationCount++;
  if (_iterationCount == ((IntToken)firingCountLimit.getToken()).intValue()) {
    return false;
  }
  return true;
}","/** 
 * Increment the iteration counter, and if it equals the value of the <i>firingCountLimit</i> parameter, return false. Otherwise, return true.  Derived classes should call this at the end of their postfire() method and return its returned value.
 * @exception IllegalActionException If firingCountLimit hasan invalid expression.
 */
public boolean postfire() throws IllegalActionException {
  if (_firingCountLimit != 0) {
    _iterationCount++;
    if (_iterationCount == _firingCountLimit) {
      return false;
    }
  }
  return true;
}"
75998,"private Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  if (_eventQueue == null)   return null;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      _stopRequested=false;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      _eventQueue.take();
      currentEvent=nextEvent;
      actorToFire=currentEvent.actor();
      if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
        if (_debugging)         _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      double currentTime=currentEvent.timeStamp();
      if (_synchronizeToRealTime) {
        long elapsedTime=System.currentTimeMillis() - _realStartTime;
        double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
        if (currentTime > elapsedTimeInSeconds) {
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (timeToWait > 0) {
            if (_debugging) {
              _debug(""String_Node_Str"" + timeToWait);
            }
synchronized (_eventQueue) {
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
      if (_debugging)       _debug(""String_Node_Str"",Double.toString(currentTime));
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}","private Actor _dequeueEvents(){
  Actor actorToFire=null;
  DEEvent currentEvent=null, nextEvent=null;
  int currentDepth=0;
  if (_eventQueue == null)   return null;
  while (true) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
 else {
      if (actorToFire != null && _eventQueue.isEmpty())       break;
      _stopRequested=false;
      while (_eventQueue.isEmpty() && !_stopRequested) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
synchronized (_eventQueue) {
          try {
            _eventQueue.wait();
          }
 catch (          InterruptedException e) {
            break;
          }
        }
      }
      if (_eventQueue.isEmpty()) {
        break;
      }
 else {
        nextEvent=(DEEvent)_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      _eventQueue.take();
      currentEvent=nextEvent;
      actorToFire=currentEvent.actor();
      if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
        if (_debugging)         _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
        actorToFire=null;
        continue;
      }
      double currentTime=currentEvent.timeStamp();
      if (_synchronizeToRealTime) {
        long elapsedTime=System.currentTimeMillis() - _realStartTime;
        double elapsedTimeInSeconds=((double)elapsedTime) / 1000.0;
        if (currentTime > elapsedTimeInSeconds) {
          long timeToWait=(long)((currentTime - elapsedTimeInSeconds) * 1000.0);
          if (timeToWait > 0) {
            if (_debugging) {
              _debug(""String_Node_Str"" + timeToWait);
            }
synchronized (_eventQueue) {
              try {
                _eventQueue.wait(timeToWait);
              }
 catch (              InterruptedException ex) {
              }
            }
          }
        }
      }
      if (_debugging)       _debug(""String_Node_Str"",Double.toString(currentTime));
      try {
        setCurrentTime(currentTime);
      }
 catch (      IllegalActionException ex) {
        throw new InternalErrorException(ex.toString());
      }
      currentDepth=currentEvent.depth();
      _microstep=currentEvent.microstep();
      if (currentTime > getStopTime()) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
      DEReceiver receiver=currentEvent.receiver();
      if (receiver != null) {
        if (_debugging)         _debug(getName(),""String_Node_Str"",receiver.getContainer().getName());
        receiver._triggerEvent(currentEvent.token());
      }
    }
 else {
      if (nextEvent.isSimultaneousWith(currentEvent) && nextEvent.actor() == currentEvent.actor()) {
        _eventQueue.take();
        DEReceiver receiver=nextEvent.receiver();
        if (receiver != null) {
          receiver._triggerEvent(nextEvent.token());
        }
      }
 else {
        break;
      }
    }
  }
  return actorToFire;
}"
75999,"/** 
 * Return false if there is no more actor to fire. Otherwise, if the director is an embedded director and the queue is not empty, then requests the executive director to refire the container of this director at the time of the next event in the event queue of this director. Note that when the <i>stopWhenQueueIsEmpty</i> parameter is false, and the queue is empty, the stall happens in the fire() method.
 * @exception IllegalActionException Not thrown in this base class.
 */
public boolean postfire() throws IllegalActionException {
  if (_noMoreActorsToFire) {
    return false;
  }
 else   if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
  return true;
}","/** 
 * Return false if there is no more actor to fire. Otherwise, if the director is an embedded director and the queue is not empty, then requests the executive director to refire the container of this director at the time of the next event in the event queue of this director. Note that when the <i>stopWhenQueueIsEmpty</i> parameter is false, and the queue is empty, the stall happens in the fire() method.
 * @exception IllegalActionException Not thrown in this base class.
 */
public boolean postfire() throws IllegalActionException {
  if (_noMoreActorsToFire && _exceedStopTime) {
    return false;
  }
 else   if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
  return true;
}"
76000,"/** 
 * Invoke the initialize() method of each deeply contained actor, and then check the event queue for any events. If there are any, and the director is embedded in an opaque composite actor, then request a firing of the outside director. This method should be invoked once per execution, after the initialization phase, but before any iteration.  Since type resolution has been completed, the initialize() method of a contained actor may produce output or schedule events. The real start time of the model is recorded when this method is called. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  _realStartTime=System.currentTimeMillis();
  super.initialize();
  if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
}","/** 
 * Invoke the initialize() method of each deeply contained actor, and then check the event queue for any events. If there are any, and the director is embedded in an opaque composite actor, then request a firing of the outside director. This method should be invoked once per execution, after the initialization phase, but before any iteration.  Since type resolution has been completed, the initialize() method of a contained actor may produce output or schedule events. The real start time of the model is recorded when this method is called. This method is <i>not</i> synchronized on the workspace, so the caller should be.
 * @exception IllegalActionException If the initialize() method ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  _realStartTime=System.currentTimeMillis();
  if (!_isEmbedded() && getStartTime() > getStopTime()) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _exceedStopTime=false;
  super.initialize();
  if (_isEmbedded() && !_eventQueue.isEmpty()) {
    _requestFiring();
  }
}"
