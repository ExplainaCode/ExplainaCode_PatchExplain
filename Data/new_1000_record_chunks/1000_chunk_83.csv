record_number,buggy_code,fixed_code
82001,"public String getSchedule(boolean[] daysFilter){
  return classSchedule.getDescription(daysFilter);
}","public String getSchedule(){
  return getScheduleWithFilter(daysFilters);
}"
82002,"/** 
 * Get the HTML representation of an image. Visible for testing.
 * @param res the {@link ImageResource} to render as HTML
 * @param valign the vertical alignment
 * @param isPlaceholder if true, do not include the background image
 * @return the rendered HTML
 */
SafeHtml getImageHtml(ImageResource res,VerticalAlignmentConstant valign,boolean isPlaceholder){
  if (isPlaceholder) {
    return template.imagePlaceholder(direction,res.getWidth());
  }
 else {
    String vert=valign == HasVerticalAlignment.ALIGN_MIDDLE ? ""String_Node_Str"" : valign.getVerticalAlignString();
    return SafeHtmlUtils.fromTrustedString(""String_Node_Str"" + direction + ""String_Node_Str""+ res.getWidth()+ ""String_Node_Str""+ res.getURL()+ ""String_Node_Str""+ SafeHtmlUtils.htmlEscape(vert)+ ""String_Node_Str"");
  }
}","/** 
 * Get the HTML representation of an image. Visible for testing.
 * @param res the {@link ImageResource} to render as HTML
 * @param valign the vertical alignment
 * @param isPlaceholder if true, do not include the background image
 * @return the rendered HTML
 */
SafeHtml getImageHtml(ImageResource res,VerticalAlignmentConstant valign,boolean isPlaceholder){
  SafeHtml image;
  if (isPlaceholder) {
    image=SafeHtmlUtils.fromTrustedString(""String_Node_Str"");
  }
 else {
    AbstractImagePrototype proto=AbstractImagePrototype.create(res);
    image=SafeHtmlUtils.fromTrustedString(proto.getHTML());
  }
  if (HasVerticalAlignment.ALIGN_TOP == valign) {
    return template.imageWrapperTop(direction,image);
  }
 else   if (HasVerticalAlignment.ALIGN_BOTTOM == valign) {
    return template.imageWrapperBottom(direction,image);
  }
 else {
    int halfHeight=1 + (int)Math.round(res.getHeight() / 2.0);
    return template.imageWrapperMiddle(direction,halfHeight,image);
  }
}"
82003,"/** 
 * Construct a new   {@link IconCellDecorator}.
 * @param icon the icon to use
 * @param cell the cell to decorate
 * @param valign the vertical alignment attribute of the contents
 * @param spacing the pixel space between the icon and the cell
 */
public IconCellDecorator(ImageResource icon,Cell<C> cell,VerticalAlignmentConstant valign,int spacing){
  if (template == null) {
    template=GWT.create(Template.class);
  }
  this.cell=cell;
  this.iconHtml=getImageHtml(icon,valign,false);
  this.imageWidth=icon.getWidth() + 6;
  this.placeHolderHtml=getImageHtml(icon,valign,true);
}","/** 
 * Construct a new   {@link IconCellDecorator}.
 * @param icon the icon to use
 * @param cell the cell to decorate
 * @param valign the vertical alignment attribute of the contents
 * @param spacing the pixel space between the icon and the cell
 */
public IconCellDecorator(ImageResource icon,Cell<C> cell,VerticalAlignmentConstant valign,int spacing){
  if (template == null) {
    template=GWT.create(Template.class);
  }
  this.cell=cell;
  this.iconHtml=getImageHtml(icon,valign,false);
  this.imageWidth=icon.getWidth() + spacing;
  this.placeHolderHtml=getImageHtml(icon,valign,true);
}"
82004,"/** 
 * Get the HTML representation of an image.
 * @param res the {@link ImageResource} to render as HTML
 * @return the rendered HTML
 */
private SafeHtml getImageHtml(ImageResource res){
  return SafeHtmlUtils.fromTrustedString(""String_Node_Str"" + (LocaleInfo.getCurrentLocale().isRTL() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ res.getWidth()+ ""String_Node_Str""+ res.getURL()+ ""String_Node_Str"");
}","/** 
 * Get the HTML representation of an image.
 * @param res the {@link ImageResource} to render as HTML
 * @return the rendered HTML
 */
private SafeHtml getImageHtml(ImageResource res){
  AbstractImagePrototype proto=AbstractImagePrototype.create(res);
  SafeHtml image=SafeHtmlUtils.fromTrustedString(proto.getHTML());
  return template.imageWrapper((LocaleInfo.getCurrentLocale().isRTL() ? ""String_Node_Str"" : ""String_Node_Str""),res.getWidth(),res.getHeight(),image);
}"
82005,"/** 
 * Get the HTML representation of an image.
 * @param res the {@link ImageResource} to render as HTML
 * @param isTop true if the image is for a top level element.
 * @return the rendered HTML
 */
private SafeHtml getImageHtml(ImageResource res,boolean isTop){
  StringBuilder classesBuilder=new StringBuilder(style.cellTreeItemImage());
  if (isTop) {
    classesBuilder.append(""String_Node_Str"").append(style.cellTreeTopItemImage());
  }
  String direction;
  if (LocaleInfo.getCurrentLocale().isRTL()) {
    direction=""String_Node_Str"";
  }
 else {
    direction=""String_Node_Str"";
  }
  return template.image(classesBuilder.toString(),direction,res.getHeight(),res.getWidth(),res.getURL());
}","/** 
 * Get the HTML representation of an image.
 * @param res the {@link ImageResource} to render as HTML
 * @param isTop true if the image is for a top level element.
 * @return the rendered HTML
 */
private SafeHtml getImageHtml(ImageResource res,boolean isTop){
  StringBuilder classesBuilder=new StringBuilder(style.cellTreeItemImage());
  if (isTop) {
    classesBuilder.append(""String_Node_Str"").append(style.cellTreeTopItemImage());
  }
  String direction;
  if (LocaleInfo.getCurrentLocale().isRTL()) {
    direction=""String_Node_Str"";
  }
 else {
    direction=""String_Node_Str"";
  }
  AbstractImagePrototype proto=AbstractImagePrototype.create(res);
  SafeHtml image=SafeHtmlUtils.fromTrustedString(proto.getHTML());
  return template.imageWrapper(classesBuilder.toString(),direction,res.getWidth(),res.getHeight(),image);
}"
82006,"public void onWindowClosing(ClosingEvent event){
  StringBuilder sb=new StringBuilder();
  for (  EntityProxyId id : favoriteIds) {
    sb.append(id.asString()).append(""String_Node_Str"");
  }
  Cookies.setCookie(COOKIE_NAME,sb.toString());
}","public void onWindowClosing(ClosingEvent event){
  StringBuilder sb=new StringBuilder();
  for (  EntityProxyId id : favoriteIds) {
    sb.append(requestFactory.getHistoryToken(id)).append(""String_Node_Str"");
  }
  Cookies.setCookie(COOKIE_NAME,sb.toString());
}"
82007,"public FavoritesManager(RequestFactory requestFactory){
  String cookie=Cookies.getCookie(COOKIE_NAME);
  if (cookie != null) {
    try {
      for (      String fragment : cookie.split(""String_Node_Str"")) {
        if (fragment.length() == 0) {
          continue;
        }
        EntityProxyId id=requestFactory.getProxyId(fragment);
        favoriteIds.add(id);
      }
    }
 catch (    NumberFormatException e) {
      favoriteIds.clear();
    }
  }
  Window.addWindowClosingHandler(new ClosingHandler(){
    public void onWindowClosing(    ClosingEvent event){
      StringBuilder sb=new StringBuilder();
      for (      EntityProxyId id : favoriteIds) {
        sb.append(id.asString()).append(""String_Node_Str"");
      }
      Cookies.setCookie(COOKIE_NAME,sb.toString());
    }
  }
);
}","public FavoritesManager(final RequestFactory requestFactory){
  String cookie=Cookies.getCookie(COOKIE_NAME);
  if (cookie != null) {
    try {
      for (      String fragment : cookie.split(""String_Node_Str"")) {
        if (fragment.length() == 0) {
          continue;
        }
        EntityProxyId id=requestFactory.getProxyId(fragment);
        favoriteIds.add(id);
      }
    }
 catch (    NumberFormatException e) {
      favoriteIds.clear();
    }
  }
  Window.addWindowClosingHandler(new ClosingHandler(){
    public void onWindowClosing(    ClosingEvent event){
      StringBuilder sb=new StringBuilder();
      for (      EntityProxyId id : favoriteIds) {
        sb.append(requestFactory.getHistoryToken(id)).append(""String_Node_Str"");
      }
      Cookies.setCookie(COOKIE_NAME,sb.toString());
    }
  }
);
}"
82008,"@UiHandler(""String_Node_Str"") void onSave(ClickEvent e){
  final RequestObject<Void> request=editorDriver.<Void>flush();
  if (editorDriver.hasErrors()) {
    dialog.setText(""String_Node_Str"");
    return;
  }
  request.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void response,    Set<SyncResult> syncResults){
      dialog.hide();
    }
    @Override public void onViolation(    Set<Violation> errors){
      dialog.setText(""String_Node_Str"");
      editorDriver.setViolations(errors);
    }
  }
);
}","@UiHandler(""String_Node_Str"") void onSave(ClickEvent e){
  final RequestObject<Void> request=editorDriver.<Void>flush();
  if (editorDriver.hasErrors()) {
    dialog.setText(""String_Node_Str"");
    return;
  }
  request.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void response){
      dialog.hide();
    }
    @Override public void onViolation(    Set<Violation> errors){
      dialog.setText(""String_Node_Str"");
      editorDriver.setViolations(errors);
    }
  }
);
}"
82009,"private void edit(){
  ProxyRequest<PersonProxy> fetchRequest=requestFactory.personRequest().findPerson(person.getId());
  editorDriver=GWT.create(Driver.class);
  editorDriver.initialize(null,requestFactory,personEditor);
  fetchRequest.with(editorDriver.getPaths());
  fetchRequest.fire(new Receiver<PersonProxy>(){
    public void onSuccess(    PersonProxy person,    Set<SyncResult> syncResults){
      editorDriver.edit(person,requestFactory.personRequest().persist(person));
      personEditor.focus();
    }
  }
);
  favorite.setValue(manager.isFavorite(person),false);
  dialog.center();
}","private void edit(){
  ProxyRequest<PersonProxy> fetchRequest=requestFactory.personRequest().findPerson(person.getId());
  editorDriver=GWT.create(Driver.class);
  editorDriver.initialize(null,requestFactory,personEditor);
  fetchRequest.with(editorDriver.getPaths());
  fetchRequest.fire(new Receiver<PersonProxy>(){
    @Override public void onSuccess(    PersonProxy person){
      editorDriver.edit(person,requestFactory.personRequest().persist(person));
      personEditor.focus();
    }
  }
);
  favorite.setValue(manager.isFavorite(person),false);
  dialog.center();
}"
82010,"public void onSuccess(PersonProxy person,Set<SyncResult> syncResults){
  editorDriver.edit(person,requestFactory.personRequest().persist(person));
  personEditor.focus();
}","@Override public void onSuccess(PersonProxy person){
  editorDriver.edit(person,requestFactory.personRequest().persist(person));
  personEditor.focus();
}"
82011,"@Override protected void onLoad(){
  subscription=manager.addMarkFavoriteHandler(new MarkFavoriteEvent.Handler(){
    public void onMarkFavorite(    MarkFavoriteEvent event){
      FavoritesWidget.this.onMarkFavorite(event);
    }
  }
);
  for (  EntityProxyId id : manager.getFavoriteIds()) {
    factory.find(id).fire(new Receiver<EntityProxy>(){
      public void onSuccess(      EntityProxy response,      Set<SyncResult> syncResults){
        PersonProxy person=(PersonProxy)response;
        onMarkFavorite(new MarkFavoriteEvent(person,true));
      }
    }
);
  }
}","@Override protected void onLoad(){
  subscription=manager.addMarkFavoriteHandler(new MarkFavoriteEvent.Handler(){
    public void onMarkFavorite(    MarkFavoriteEvent event){
      FavoritesWidget.this.onMarkFavorite(event);
    }
  }
);
  for (  EntityProxyId id : manager.getFavoriteIds()) {
    factory.find(id).fire(new Receiver<EntityProxy>(){
      @Override public void onSuccess(      EntityProxy response){
        PersonProxy person=(PersonProxy)response;
        onMarkFavorite(new MarkFavoriteEvent(person,true));
      }
    }
);
  }
}"
82012,"public void onSuccess(EntityProxy response,Set<SyncResult> syncResults){
  PersonProxy person=(PersonProxy)response;
  onMarkFavorite(new MarkFavoriteEvent(person,true));
}","@Override public void onSuccess(EntityProxy response){
  PersonProxy person=(PersonProxy)response;
  onMarkFavorite(new MarkFavoriteEvent(person,true));
}"
82013,"private void fetch(final int start){
  requestFactory.schoolCalendarRequest().getPeople(start,numRows).fire(new Receiver<List<PersonProxy>>(){
    public void onSuccess(    List<PersonProxy> response,    Set<SyncResult> syncResults){
      int responses=response.size();
      table.setRowData(start,response);
      if (!table.isRowCountExact()) {
        table.setRowCount(start + responses,responses < numRows);
      }
    }
  }
);
}","private void fetch(final int start){
  requestFactory.schoolCalendarRequest().getPeople(start,numRows).fire(new Receiver<List<PersonProxy>>(){
    @Override public void onSuccess(    List<PersonProxy> response){
      int responses=response.size();
      table.setRowData(start,response);
      if (!table.isRowCountExact()) {
        table.setRowCount(start + responses,responses < numRows);
      }
    }
  }
);
}"
82014,"void onPersonChanged(EntityProxyChange<PersonProxy> event){
  if (WriteOperation.UPDATE.equals(event.getWriteOperation())) {
    PersonProxy record=event.getProxy();
    int displayOffset=offsetOf(record);
    if (displayOffset != -1) {
      requestFactory.personRequest().findPerson(record.getId()).fire(new Receiver<PersonProxy>(){
        public void onSuccess(        PersonProxy response,        Set<SyncResult> syncResults){
          int offset=offsetOf(response);
          if (offset != -1) {
            table.setRowData(table.getPageStart() + offset,Collections.singletonList(response));
          }
        }
      }
);
    }
  }
}","void onPersonChanged(EntityProxyChange<PersonProxy> event){
  if (WriteOperation.UPDATE.equals(event.getWriteOperation())) {
    PersonProxy record=event.getProxy();
    int displayOffset=offsetOf(record);
    if (displayOffset != -1) {
      requestFactory.personRequest().findPerson(record.getId()).fire(new Receiver<PersonProxy>(){
        @Override public void onSuccess(        PersonProxy response){
          int offset=offsetOf(response);
          if (offset != -1) {
            table.setRowData(table.getPageStart() + offset,Collections.singletonList(response));
          }
        }
      }
);
    }
  }
}"
82015,"public void onSuccess(List<PersonProxy> response,Set<SyncResult> syncResults){
  int responses=response.size();
  table.setRowData(start,response);
  if (!table.isRowCountExact()) {
    table.setRowCount(start + responses,responses < numRows);
  }
}","@Override public void onSuccess(List<PersonProxy> response){
  int responses=response.size();
  table.setRowData(start,response);
  if (!table.isRowCountExact()) {
    table.setRowCount(start + responses,responses < numRows);
  }
}"
82016,"/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  lastReceiver=new Receiver<List<ExpenseProxy>>(){
    @Override public void onSuccess(    List<ExpenseProxy> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        List<ExpenseProxy> list=new ArrayList<ExpenseProxy>(newValues);
        if (lastComparator != null) {
          sortExpenses(list,lastComparator);
        }
        items.setList(list);
        refreshCost();
        boolean isInitialData=knownExpenseKeys == null;
        if (knownExpenseKeys == null) {
          knownExpenseKeys=new HashMap<Object,ExpenseProxy>();
        }
        for (        ExpenseProxy value : newValues) {
          Object key=items.getKey(value);
          if (!isInitialData) {
            ExpenseProxy existing=knownExpenseKeys.get(key);
            if (existing == null || !value.getAmount().equals(existing.getAmount()) || !value.getDescription().equals(existing.getDescription()) || !value.getCategory().equals(existing.getCategory())) {
              (new PhaseAnimation.CellTablePhaseAnimation<ExpenseProxy>(table,value,items)).run();
            }
          }
          knownExpenseKeys.put(key,value);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  expensesRequestFactory.expenseRequest().findExpensesByReport(report.getId()).with(getExpenseColumns()).fire(lastReceiver);
}","/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  lastReceiver=new Receiver<List<ExpenseProxy>>(){
    @Override public void onSuccess(    List<ExpenseProxy> newValues){
      if (this == lastReceiver) {
        List<ExpenseProxy> list=new ArrayList<ExpenseProxy>(newValues);
        if (lastComparator != null) {
          sortExpenses(list,lastComparator);
        }
        items.setList(list);
        refreshCost();
        boolean isInitialData=knownExpenseKeys == null;
        if (knownExpenseKeys == null) {
          knownExpenseKeys=new HashMap<Object,ExpenseProxy>();
        }
        for (        ExpenseProxy value : newValues) {
          Object key=items.getKey(value);
          if (!isInitialData) {
            ExpenseProxy existing=knownExpenseKeys.get(key);
            if (existing == null || !value.getAmount().equals(existing.getAmount()) || !value.getDescription().equals(existing.getDescription()) || !value.getCategory().equals(existing.getCategory())) {
              (new PhaseAnimation.CellTablePhaseAnimation<ExpenseProxy>(table,value,items)).run();
            }
          }
          knownExpenseKeys.put(key,value);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  expensesRequestFactory.expenseRequest().findExpensesByReport(report.getId()).with(getExpenseColumns()).fire(lastReceiver);
}"
82017,"/** 
 * Save the notes that the user entered in the notes box.
 */
private void saveNotes(){
  final String pendingNotes=notesBox.getText();
  if (pendingNotes.equals(report.getNotes())) {
    setNotesEditState(false,false,pendingNotes);
    return;
  }
  setNotesEditState(false,true,pendingNotes);
  RequestObject<Void> editRequest=expensesRequestFactory.reportRequest().persist(report);
  ReportProxy editableReport=editRequest.edit(report);
  editableReport.setNotes(pendingNotes);
  editRequest.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=getErrorMessageFromSync(response);
      if (errorMessage.length() > 0) {
        showErrorPopup(errorMessage);
        setNotesEditState(false,false,report.getNotes());
      }
    }
  }
);
}","/** 
 * Save the notes that the user entered in the notes box.
 */
private void saveNotes(){
  final String pendingNotes=notesBox.getText();
  if (pendingNotes.equals(report.getNotes())) {
    setNotesEditState(false,false,pendingNotes);
    return;
  }
  setNotesEditState(false,true,pendingNotes);
  RequestObject<Void> editRequest=expensesRequestFactory.reportRequest().persist(report);
  ReportProxy editableReport=editRequest.edit(report);
  editableReport.setNotes(pendingNotes);
  editRequest.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore){
    }
  }
);
}"
82018,"public void onReportChanged(EntityProxyChange<ReportProxy> event){
  ReportProxy changed=event.getProxy();
  if (report != null && report.getId().equals(changed.getId())) {
    expensesRequestFactory.reportRequest().findReport(report.getId()).fire(new Receiver<ReportProxy>(){
      @Override public void onSuccess(      ReportProxy response,      Set<SyncResult> syncResults){
        report=response;
        setNotesEditState(false,false,response.getNotes());
      }
    }
);
  }
}","public void onReportChanged(EntityProxyChange<ReportProxy> event){
  ReportProxy changed=event.getProxy();
  if (report != null && report.getId().equals(changed.getId())) {
    expensesRequestFactory.reportRequest().findReport(report.getId()).fire(new Receiver<ReportProxy>(){
      @Override public void onSuccess(      ReportProxy response){
        report=response;
        setNotesEditState(false,false,response.getNotes());
      }
    }
);
  }
}"
82019,"private void updateExpenseRecord(final ExpenseProxy record,String approval,String reasonDenied){
  if (Expenses.Approval.APPROVED.is(approval) && !Expenses.Approval.APPROVED.is(record.getApproval())) {
    double amount=record.getAmount();
    if (amount + totalApproved > MAX_COST) {
      syncCommit(record,""String_Node_Str"" + MAX_COST + ""String_Node_Str"");
      return;
    }
  }
  RequestObject<Void> editRequest=expensesRequestFactory.expenseRequest().persist(record);
  ExpenseProxy editableRecord=editRequest.edit(record);
  editableRecord.setApproval(approval);
  editableRecord.setReasonDenied(reasonDenied);
  editRequest.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=getErrorMessageFromSync(response);
      if (errorMessage.length() > 0) {
        syncCommit(record,errorMessage.length() > 0 ? errorMessage : null);
      }
    }
  }
);
}","private void updateExpenseRecord(final ExpenseProxy record,String approval,String reasonDenied){
  if (Expenses.Approval.APPROVED.is(approval) && !Expenses.Approval.APPROVED.is(record.getApproval())) {
    double amount=record.getAmount();
    if (amount + totalApproved > MAX_COST) {
      syncCommit(record,""String_Node_Str"" + MAX_COST + ""String_Node_Str"");
      return;
    }
  }
  RequestObject<Void> editRequest=expensesRequestFactory.expenseRequest().persist(record);
  ExpenseProxy editableRecord=editRequest.edit(record);
  editableRecord.setApproval(approval);
  editableRecord.setReasonDenied(reasonDenied);
  editRequest.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore){
    }
  }
);
}"
82020,"@Override public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=getErrorMessageFromSync(response);
  if (errorMessage.length() > 0) {
    syncCommit(record,errorMessage.length() > 0 ? errorMessage : null);
  }
}","@Override public void onSuccess(Void ignore){
}"
82021,"/** 
 * Send a request for reports in the current range.
 * @param isPolling true if this request is caused by polling
 */
private void requestReports(boolean isPolling){
  refreshTimer.cancel();
  if (requestFactory == null) {
    return;
  }
  if (!isPolling) {
    knownReportKeys=null;
  }
  String startsWith=startsWithSearch;
  if (startsWith == null || searchBox.getDefaultText().equals(startsWith)) {
    startsWith=""String_Node_Str"";
  }
  Range range=table.getVisibleRange();
  Long employeeId=employee == null ? -1 : new Long(employee.getId());
  String dept=department == null ? ""String_Node_Str"" : department;
  if (startsWith.length() > 0) {
    for (    SortableHeader header : allHeaders) {
      header.setSorted(false);
      header.setReverseSort(false);
    }
    table.redrawHeaders();
  }
  if (isCountStale) {
    isCountStale=false;
    if (!isPolling) {
      pager.startLoading();
    }
    lastDataSizeReceiver=new Receiver<Long>(){
      @Override public void onSuccess(      Long response,      Set<SyncResult> syncResults){
        if (this == lastDataSizeReceiver) {
          int count=response.intValue();
          reports.updateRowCount(count,count != 1000);
        }
      }
    }
;
    requestFactory.reportRequest().countReportsBySearch(employeeId,dept,startsWith).fire(lastDataSizeReceiver);
  }
  lastDataReceiver=new Receiver<List<ReportProxy>>(){
    @Override public void onSuccess(    List<ReportProxy> newValues,    Set<SyncResult> syncResults){
      if (this == lastDataReceiver) {
        int size=newValues.size();
        if (size < table.getPageSize()) {
          reports.updateRowCount(table.getPageStart() + size,true);
        }
        if (size > 0) {
          reports.updateRowData(table.getPageStart(),newValues);
        }
        boolean isInitialData=knownReportKeys == null;
        if (knownReportKeys == null) {
          knownReportKeys=new HashSet<Object>();
        }
        for (        ReportProxy value : newValues) {
          Object key=reports.getKey(value);
          if (!isInitialData && !knownReportKeys.contains(key)) {
            (new PhaseAnimation.CellTablePhaseAnimation<ReportProxy>(table,value,reports)).run();
          }
          knownReportKeys.add(key);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employeeId,dept,startsWith,orderBy,range.getStart(),range.getLength()).with(reportColumns).fire(lastDataReceiver);
}","/** 
 * Send a request for reports in the current range.
 * @param isPolling true if this request is caused by polling
 */
private void requestReports(boolean isPolling){
  refreshTimer.cancel();
  if (requestFactory == null) {
    return;
  }
  if (!isPolling) {
    knownReportKeys=null;
  }
  String startsWith=startsWithSearch;
  if (startsWith == null || searchBox.getDefaultText().equals(startsWith)) {
    startsWith=""String_Node_Str"";
  }
  Range range=table.getVisibleRange();
  Long employeeId=employee == null ? -1 : new Long(employee.getId());
  String dept=department == null ? ""String_Node_Str"" : department;
  if (startsWith.length() > 0) {
    for (    SortableHeader header : allHeaders) {
      header.setSorted(false);
      header.setReverseSort(false);
    }
    table.redrawHeaders();
  }
  if (isCountStale) {
    isCountStale=false;
    if (!isPolling) {
      pager.startLoading();
    }
    lastDataSizeReceiver=new Receiver<Long>(){
      @Override public void onSuccess(      Long response){
        if (this == lastDataSizeReceiver) {
          int count=response.intValue();
          reports.updateRowCount(count,count != 1000);
        }
      }
    }
;
    requestFactory.reportRequest().countReportsBySearch(employeeId,dept,startsWith).fire(lastDataSizeReceiver);
  }
  lastDataReceiver=new Receiver<List<ReportProxy>>(){
    @Override public void onSuccess(    List<ReportProxy> newValues){
      if (this == lastDataReceiver) {
        int size=newValues.size();
        if (size < table.getPageSize()) {
          reports.updateRowCount(table.getPageStart() + size,true);
        }
        if (size > 0) {
          reports.updateRowData(table.getPageStart(),newValues);
        }
        boolean isInitialData=knownReportKeys == null;
        if (knownReportKeys == null) {
          knownReportKeys=new HashSet<Object>();
        }
        for (        ReportProxy value : newValues) {
          Object key=reports.getKey(value);
          if (!isInitialData && !knownReportKeys.contains(key)) {
            (new PhaseAnimation.CellTablePhaseAnimation<ReportProxy>(table,value,reports)).run();
          }
          knownReportKeys.add(key);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employeeId,dept,startsWith,orderBy,range.getStart(),range.getLength()).with(reportColumns).fire(lastDataReceiver);
}"
82022,"@Override public void onSuccess(List<ReportProxy> newValues,Set<SyncResult> syncResults){
  if (this == lastDataReceiver) {
    int size=newValues.size();
    if (size < table.getPageSize()) {
      reports.updateRowCount(table.getPageStart() + size,true);
    }
    if (size > 0) {
      reports.updateRowData(table.getPageStart(),newValues);
    }
    boolean isInitialData=knownReportKeys == null;
    if (knownReportKeys == null) {
      knownReportKeys=new HashSet<Object>();
    }
    for (    ReportProxy value : newValues) {
      Object key=reports.getKey(value);
      if (!isInitialData && !knownReportKeys.contains(key)) {
        (new PhaseAnimation.CellTablePhaseAnimation<ReportProxy>(table,value,reports)).run();
      }
      knownReportKeys.add(key);
    }
  }
  refreshTimer.schedule(REFRESH_INTERVAL);
}","@Override public void onSuccess(List<ReportProxy> newValues){
  if (this == lastDataReceiver) {
    int size=newValues.size();
    if (size < table.getPageSize()) {
      reports.updateRowCount(table.getPageStart() + size,true);
    }
    if (size > 0) {
      reports.updateRowData(table.getPageStart(),newValues);
    }
    boolean isInitialData=knownReportKeys == null;
    if (knownReportKeys == null) {
      knownReportKeys=new HashSet<Object>();
    }
    for (    ReportProxy value : newValues) {
      Object key=reports.getKey(value);
      if (!isInitialData && !knownReportKeys.contains(key)) {
        (new PhaseAnimation.CellTablePhaseAnimation<ReportProxy>(table,value,reports)).run();
      }
      knownReportKeys.add(key);
    }
  }
  refreshTimer.schedule(REFRESH_INTERVAL);
}"
82023,"@Override protected void onRangeChanged(HasData<EmployeeProxy> view){
  Range range=view.getVisibleRange();
  requestFactory.employeeRequest().findEmployeeEntriesByDepartment(department,range.getStart(),range.getLength()).with(getEmployeeMenuProperties()).fire(new Receiver<List<EmployeeProxy>>(){
    @Override public void onSuccess(    List<EmployeeProxy> response,    Set<SyncResult> syncResults){
      updateRowData(0,response);
    }
  }
);
}","@Override protected void onRangeChanged(HasData<EmployeeProxy> view){
  Range range=view.getVisibleRange();
  requestFactory.employeeRequest().findEmployeeEntriesByDepartment(department,range.getStart(),range.getLength()).with(getEmployeeMenuProperties()).fire(new Receiver<List<EmployeeProxy>>(){
    @Override public void onSuccess(    List<EmployeeProxy> response){
      updateRowData(0,response);
    }
  }
);
}"
82024,"@Override public void addDataDisplay(HasData<EmployeeProxy> display){
  super.addDataDisplay(display);
  requestFactory.employeeRequest().countEmployeesByDepartment(department).fire(new Receiver<Long>(){
    @Override public void onSuccess(    Long response,    Set<SyncResult> syncResults){
      updateRowCount(response.intValue(),true);
    }
  }
);
}","@Override public void addDataDisplay(HasData<EmployeeProxy> display){
  super.addDataDisplay(display);
  requestFactory.employeeRequest().countEmployeesByDepartment(department).fire(new Receiver<Long>(){
    @Override public void onSuccess(    Long response){
      updateRowCount(response.intValue(),true);
    }
  }
);
}"
82025,"@Override public void onSuccess(List<EmployeeProxy> response,Set<SyncResult> syncResults){
  updateRowData(0,response);
}","@Override public void onSuccess(List<EmployeeProxy> response){
  updateRowData(0,response);
}"
82026,"public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  final EventBus eventBus=new SimpleEventBus();
  requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  RootLayoutPanel root=RootLayoutPanel.get();
  shell=new ExpensesShell();
  final ExpenseTree expenseTree=shell.getExpenseTree();
  final ExpenseList expenseList=shell.getExpenseList();
  final ExpenseDetails expenseDetails=shell.getExpenseDetails();
  root.add(shell);
  RequestEvent.register(eventBus,new AuthenticationFailureHandler());
  final LoginWidget login=shell.getLoginWidget();
  Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
    @Override public void onSuccess(    UserInformationProxy userInformationRecord,    Set<SyncResult> syncResults){
      login.setUserInformation(userInformationRecord);
    }
  }
;
  requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
  expenseTree.setListener(new ExpenseTree.Listener(){
    public void onSelection(    String department,    EmployeeProxy employee){
      lastDepartment=department;
      lastEmployee=employee;
      expenseList.setEmployee(department,employee);
      shell.showExpenseDetails(false);
    }
  }
);
  expenseTree.setRequestFactory(requestFactory);
  expenseList.setListener(new ExpenseList.Listener(){
    public void onReportSelected(    ReportProxy report){
      expenseDetails.setExpensesRequestFactory(requestFactory);
      expenseDetails.setReportRecord(report,lastDepartment,lastEmployee);
      shell.showExpenseDetails(true);
    }
  }
);
  expenseList.init(requestFactory,eventBus);
  expenseDetails.init(eventBus);
}","public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  final EventBus eventBus=new SimpleEventBus();
  requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  RootLayoutPanel root=RootLayoutPanel.get();
  shell=new ExpensesShell();
  final ExpenseTree expenseTree=shell.getExpenseTree();
  final ExpenseList expenseList=shell.getExpenseList();
  final ExpenseDetails expenseDetails=shell.getExpenseDetails();
  root.add(shell);
  RequestEvent.register(eventBus,new AuthenticationFailureHandler());
  final LoginWidget login=shell.getLoginWidget();
  Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
    @Override public void onSuccess(    UserInformationProxy userInformationRecord){
      login.setUserInformation(userInformationRecord);
    }
  }
;
  requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
  expenseTree.setListener(new ExpenseTree.Listener(){
    public void onSelection(    String department,    EmployeeProxy employee){
      lastDepartment=department;
      lastEmployee=employee;
      expenseList.setEmployee(department,employee);
      shell.showExpenseDetails(false);
    }
  }
);
  expenseTree.setRequestFactory(requestFactory);
  expenseList.setListener(new ExpenseList.Listener(){
    public void onReportSelected(    ReportProxy report){
      expenseDetails.setExpensesRequestFactory(requestFactory);
      expenseDetails.setReportRecord(report,lastDepartment,lastEmployee);
      shell.showExpenseDetails(true);
    }
  }
);
  expenseList.init(requestFactory,eventBus);
  expenseDetails.init(eventBus);
}"
82027,"@Override public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}","@Override public void onSuccess(UserInformationProxy userInformationRecord){
  login.setUserInformation(userInformationRecord);
}"
82028,"/** 
 * Gets the container element associated with this layer. <p> This is the element that sits between the parent and child elements. It is normally necessary to operate on this element only when you need to modify certain CSS properties, such as visibility. </p>
 * @return the container element
 */
public Element getContainerElement(){
  return container;
}","/** 
 * Gets the container element associated with this layer. <p> This is the element that sits between the parent and child elements. It is normally necessary to operate on this element only when you need to modify CSS properties that are not directly modeled by the Layer class. </p>
 * @return the container element
 */
public Element getContainerElement(){
  return container;
}"
82029,"public void layout(Layer layer){
  Style style=layer.container.getStyle();
  style.setProperty(""String_Node_Str"",layer.setLeft ? (layer.left + layer.leftUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setTop ? (layer.top + layer.topUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setRight ? (layer.right + layer.rightUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setBottom ? (layer.bottom + layer.bottomUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setWidth ? (layer.width + layer.widthUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setHeight ? (layer.height + layer.heightUnit.getType()) : ""String_Node_Str"");
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}","public void layout(Layer layer){
  Style style=layer.container.getStyle();
  if (layer.visible) {
    style.clearDisplay();
  }
 else {
    style.setDisplay(Display.NONE);
  }
  style.setProperty(""String_Node_Str"",layer.setLeft ? (layer.left + layer.leftUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setTop ? (layer.top + layer.topUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setRight ? (layer.right + layer.rightUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setBottom ? (layer.bottom + layer.bottomUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setWidth ? (layer.width + layer.widthUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setHeight ? (layer.height + layer.heightUnit.getType()) : ""String_Node_Str"");
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}"
82030,"@Override public void layout(Layer layer){
  Element elem=layer.getContainerElement();
  setLayer(elem,layer);
}","@Override public void layout(Layer layer){
  Element elem=layer.container;
  Style style=elem.getStyle();
  if (layer.visible) {
    style.clearDisplay();
  }
 else {
    style.setDisplay(Display.NONE);
  }
  setLayer(elem,layer);
}"
82031,"@Override public void layout(Layer layer){
  Style style=layer.container.getStyle();
  if (layer.setLeft) {
    setValue(layer,""String_Node_Str"",layer.left,layer.leftUnit,false,false);
  }
 else {
    style.clearLeft();
  }
  if (layer.setRight) {
    setValue(layer,""String_Node_Str"",layer.right,layer.rightUnit,false,false);
  }
 else {
    style.clearRight();
  }
  if (layer.setTop) {
    setValue(layer,""String_Node_Str"",layer.top,layer.topUnit,true,false);
  }
 else {
    style.clearTop();
  }
  if (layer.setBottom) {
    setValue(layer,""String_Node_Str"",layer.bottom,layer.bottomUnit,true,false);
  }
 else {
    style.clearBottom();
  }
  if (layer.setWidth) {
    setValue(layer,""String_Node_Str"",layer.width,layer.widthUnit,false,true);
  }
 else {
    style.clearWidth();
  }
  if (layer.setHeight) {
    setValue(layer,""String_Node_Str"",layer.height,layer.heightUnit,true,true);
  }
 else {
    style.clearHeight();
  }
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}","@Override public void layout(Layer layer){
  Style style=layer.container.getStyle();
  setLayer(layer.container,layer);
  if (layer.visible) {
    String oldDisplay=style.getDisplay();
    style.clearDisplay();
    if (oldDisplay.length() > 0) {
      updateVisibility(layer.container);
    }
  }
 else {
    style.setDisplay(Display.NONE);
  }
  if (layer.setLeft) {
    setValue(layer,""String_Node_Str"",layer.left,layer.leftUnit,false,false);
  }
 else {
    style.clearLeft();
  }
  if (layer.setRight) {
    setValue(layer,""String_Node_Str"",layer.right,layer.rightUnit,false,false);
  }
 else {
    style.clearRight();
  }
  if (layer.setTop) {
    setValue(layer,""String_Node_Str"",layer.top,layer.topUnit,true,false);
  }
 else {
    style.clearTop();
  }
  if (layer.setBottom) {
    setValue(layer,""String_Node_Str"",layer.bottom,layer.bottomUnit,true,false);
  }
 else {
    style.clearBottom();
  }
  if (layer.setWidth) {
    setValue(layer,""String_Node_Str"",layer.width,layer.widthUnit,false,true);
  }
 else {
    style.clearWidth();
  }
  if (layer.setHeight) {
    setValue(layer,""String_Node_Str"",layer.height,layer.heightUnit,true,true);
  }
 else {
    style.clearHeight();
  }
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}"
82032,"/** 
 * Shows or hides the given widget and its layer. This method explicitly calls   {@link UIObject#setVisible(boolean)} on the child widget and ensuresthat its associated layer is shown/hidden.
 * @param child
 * @param visible
 */
public void setWidgetVisible(Widget child,boolean visible){
  assertIsChild(child);
  Element container=getWidgetContainerElement(child);
  setVisible(container,visible);
  child.setVisible(visible);
  animate(0);
}","/** 
 * Shows or hides the given widget and its layer. This method explicitly calls   {@link UIObject#setVisible(boolean)} on the child widget and ensuresthat its associated layer is shown/hidden.
 * @param child
 * @param visible
 */
public void setWidgetVisible(Widget child,boolean visible){
  assertIsChild(child);
  getLayer(child).setVisible(visible);
  child.setVisible(visible);
  animate(0);
}"
82033,"private void layoutChild(Widget child){
  panel.setWidgetLeftRight(child,0,Unit.PX,0,Unit.PX);
  panel.setWidgetTopBottom(child,barHeight,barUnit,0,Unit.PX);
  panel.getWidgetContainerElement(child).getStyle().setDisplay(Display.NONE);
  child.addStyleName(CONTENT_STYLE);
  child.setVisible(false);
}","private void layoutChild(Widget child){
  panel.setWidgetLeftRight(child,0,Unit.PX,0,Unit.PX);
  panel.setWidgetTopBottom(child,barHeight,barUnit,0,Unit.PX);
  panel.setWidgetVisible(child,false);
  child.addStyleName(CONTENT_STYLE);
  child.setVisible(false);
}"
82034,"public void execute(){
  assertEquals(128,bar.getOffsetWidth());
  assertEquals(128 - 32,bar.getOffsetHeight());
  finishTest();
}","public void execute(){
  assertTrue(bar.getOffsetWidth() > 0);
  assertTrue(bar.getOffsetHeight() > 0);
  finishTest();
}"
82035,"protected List<PropertyColumn<EmployeeProxy,?>> getColumns(){
  List<PropertyColumn<EmployeeProxy,?>> columns=new ArrayList<PropertyColumn<EmployeeProxy,?>>();
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(new PropertyColumn<EmployeeProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeRenderer.instance()));
  return columns;
}","protected List<PropertyColumn<EmployeeProxy,?>> getColumns(){
  List<PropertyColumn<EmployeeProxy,?>> columns=new ArrayList<PropertyColumn<EmployeeProxy,?>>();
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(PropertyColumn.<EmployeeProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(new PropertyColumn<EmployeeProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeProxy.class,EmployeeRenderer.instance()));
  return columns;
}"
82036,"protected List<PropertyColumn<ReportProxy,?>> getColumns(){
  List<PropertyColumn<ReportProxy,?>> columns=new ArrayList<PropertyColumn<ReportProxy,?>>();
  columns.add(new PropertyColumn<ReportProxy,Date>(""String_Node_Str"",""String_Node_Str"",new DateTimeFormatRenderer(DateTimeFormat.getShortDateFormat())));
  columns.add(PropertyColumn.<ReportProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(new PropertyColumn<ReportProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeRenderer.instance()));
  columns.add(new PropertyColumn<ReportProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeRenderer.instance()));
  return columns;
}","protected List<PropertyColumn<ReportProxy,?>> getColumns(){
  List<PropertyColumn<ReportProxy,?>> columns=new ArrayList<PropertyColumn<ReportProxy,?>>();
  columns.add(new PropertyColumn<ReportProxy,Date>(""String_Node_Str"",""String_Node_Str"",Date.class,new DateTimeFormatRenderer(DateTimeFormat.getShortDateFormat())));
  columns.add(PropertyColumn.<ReportProxy>getStringPropertyColumn(""String_Node_Str"",""String_Node_Str""));
  columns.add(new PropertyColumn<ReportProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeProxy.class,EmployeeRenderer.instance()));
  columns.add(new PropertyColumn<ReportProxy,EmployeeProxy>(""String_Node_Str"",""String_Node_Str"",EmployeeProxy.class,EmployeeRenderer.instance()));
  return columns;
}"
82037,"@Override public String getValue(R object){
  ProxyImpl proxyImpl=(ProxyImpl)object;
  return renderer.render(proxyImpl.<T>get(property,String.class));
}","@Override public String getValue(R object){
  ProxyImpl proxyImpl=(ProxyImpl)object;
  return renderer.render(proxyImpl.<T>get(property,clazz));
}"
82038,"public PropertyColumn(String property,String displayName,Renderer<T> renderer){
  this.displayName=displayName;
  this.property=property;
  this.renderer=renderer;
  this.paths=new String[]{property};
}","public PropertyColumn(String property,String displayName,Class<T> clazz,Renderer<T> renderer){
  this.displayName=displayName;
  this.property=property;
  this.clazz=clazz;
  this.renderer=renderer;
  this.paths=new String[]{property};
}"
82039,"public static <R extends EntityProxy>PropertyColumn<R,String> getStringPropertyColumn(String property,String displayName){
  return new PropertyColumn<R,String>(property,displayName,PassthroughRenderer.instance());
}","public static <R extends EntityProxy>PropertyColumn<R,String> getStringPropertyColumn(String property,String displayName){
  return new PropertyColumn<R,String>(property,displayName,String.class,PassthroughRenderer.instance());
}"
82040,"public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  final EventBus eventBus=new SimpleEventBus();
  requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  RootLayoutPanel root=RootLayoutPanel.get();
  shell=new ExpensesShell();
  final ExpenseTree expenseTree=shell.getExpenseTree();
  final ExpenseList expenseList=shell.getExpenseList();
  final ExpenseDetails expenseDetails=shell.getExpenseDetails();
  root.add(shell);
  RequestEvent.register(eventBus,new AuthenticationFailureHandler());
  final LoginWidget login=shell.getLoginWidget();
  Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
    public void onSuccess(    UserInformationProxy userInformationRecord,    Set<SyncResult> syncResults){
      login.setUserInformation(userInformationRecord);
    }
  }
;
  requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
  expenseTree.setListener(new ExpenseTree.Listener(){
    public void onSelection(    String department,    EmployeeProxy employee){
      lastDepartment=department;
      lastEmployee=employee;
      expenseList.setEmployee(department,employee);
      shell.showExpenseDetails(false);
    }
  }
);
  expenseTree.setRequestFactory(requestFactory);
  expenseList.setListener(new ExpenseList.Listener(){
    public void onReportSelected(    ReportProxy report){
      expenseDetails.setExpensesRequestFactory(requestFactory);
      expenseDetails.setReportRecord(report,lastDepartment,lastEmployee);
      shell.showExpenseDetails(true);
    }
  }
);
  expenseList.init(requestFactory,eventBus);
  expenseDetails.init(eventBus);
}","public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  final EventBus eventBus=new SimpleEventBus();
  requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  RootLayoutPanel root=RootLayoutPanel.get();
  shell=new ExpensesShell();
  final ExpenseTree expenseTree=shell.getExpenseTree();
  final ExpenseList expenseList=shell.getExpenseList();
  final ExpenseDetails expenseDetails=shell.getExpenseDetails();
  root.add(shell);
  RequestEvent.register(eventBus,new AuthenticationFailureHandler());
  final LoginWidget login=shell.getLoginWidget();
  Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
    @Override public void onSuccess(    UserInformationProxy userInformationRecord,    Set<SyncResult> syncResults){
      login.setUserInformation(userInformationRecord);
    }
  }
;
  requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
  expenseTree.setListener(new ExpenseTree.Listener(){
    public void onSelection(    String department,    EmployeeProxy employee){
      lastDepartment=department;
      lastEmployee=employee;
      expenseList.setEmployee(department,employee);
      shell.showExpenseDetails(false);
    }
  }
);
  expenseTree.setRequestFactory(requestFactory);
  expenseList.setListener(new ExpenseList.Listener(){
    public void onReportSelected(    ReportProxy report){
      expenseDetails.setExpensesRequestFactory(requestFactory);
      expenseDetails.setReportRecord(report,lastDepartment,lastEmployee);
      shell.showExpenseDetails(true);
    }
  }
);
  expenseList.init(requestFactory,eventBus);
  expenseDetails.init(eventBus);
}"
82041,"public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}","@Override public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}"
82042,"/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  long employeeId=1;
  try {
    String value=Window.Location.getParameter(EMPLOYEE_ID_PARAM);
    if (value != null && value.length() > 0) {
      employeeId=Long.parseLong(value);
    }
  }
 catch (  NumberFormatException e) {
    RootPanel.get().add(new Label(""String_Node_Str""));
    return;
  }
  final EventBus eventBus=new SimpleEventBus();
  final ExpensesRequestFactory requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  requestFactory.employeeRequest().findEmployee(employeeId).fire(new Receiver<EmployeeProxy>(){
    public void onSuccess(    EmployeeProxy employee,    Set<SyncResult> syncResults){
      final ExpensesMobileShell shell=new ExpensesMobileShell(eventBus,requestFactory,employee);
      RootPanel.get().add(shell);
      RequestEvent.register(eventBus,new AuthenticationFailureHandler());
      final LoginWidget login=shell.getLoginWidget();
      Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
        public void onSuccess(        UserInformationProxy userInformationRecord,        Set<SyncResult> syncResults){
          login.setUserInformation(userInformationRecord);
        }
      }
;
      requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
    }
  }
);
}","/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  long employeeId=1;
  try {
    String value=Window.Location.getParameter(EMPLOYEE_ID_PARAM);
    if (value != null && value.length() > 0) {
      employeeId=Long.parseLong(value);
    }
  }
 catch (  NumberFormatException e) {
    RootPanel.get().add(new Label(""String_Node_Str""));
    return;
  }
  final EventBus eventBus=new SimpleEventBus();
  final ExpensesRequestFactory requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  requestFactory.employeeRequest().findEmployee(employeeId).fire(new Receiver<EmployeeProxy>(){
    @Override public void onSuccess(    EmployeeProxy employee,    Set<SyncResult> syncResults){
      final ExpensesMobileShell shell=new ExpensesMobileShell(eventBus,requestFactory,employee);
      RootPanel.get().add(shell);
      RequestEvent.register(eventBus,new AuthenticationFailureHandler());
      final LoginWidget login=shell.getLoginWidget();
      Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
        @Override public void onSuccess(        UserInformationProxy userInformationRecord,        Set<SyncResult> syncResults){
          login.setUserInformation(userInformationRecord);
        }
      }
;
      requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
    }
  }
);
}"
82043,"public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}","@Override public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}"
82044,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}"
82045,"@SuppressWarnings(""String_Node_Str"") public void onCustom(){
  ExpenseProxy editableExpense=requestObject.edit(expense);
  editableExpense.setDescription(nameText.getText());
  editableExpense.setCategory(categoryText.getText());
  String amountText=priceText.getText();
  double amount=Double.parseDouble(amountText);
  editableExpense.setAmount(amount);
  Date date=new Date(dateYear.getSelectedIndex() + 100,dateMonth.getSelectedIndex(),dateDay.getSelectedIndex() + 1);
  editableExpense.setCreated(date);
  requestObject.fire(new Receiver<Void>(){
    public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=""String_Node_Str"";
      if (errorMessage.length() > 0) {
        errorText.setInnerText(errorMessage);
      }
 else {
        listener.onExpenseUpdated();
      }
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") public void onCustom(){
  ExpenseProxy editableExpense=requestObject.edit(expense);
  editableExpense.setDescription(nameText.getText());
  editableExpense.setCategory(categoryText.getText());
  String amountText=priceText.getText();
  double amount=Double.parseDouble(amountText);
  editableExpense.setAmount(amount);
  Date date=new Date(dateYear.getSelectedIndex() + 100,dateMonth.getSelectedIndex(),dateDay.getSelectedIndex() + 1);
  editableExpense.setCreated(date);
  requestObject.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=""String_Node_Str"";
      if (errorMessage.length() > 0) {
        errorText.setInnerText(errorMessage);
      }
 else {
        listener.onExpenseUpdated();
      }
    }
  }
);
}"
82046,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}"
82047,"public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=""String_Node_Str"";
  if (errorMessage.length() > 0) {
    errorText.setInnerText(errorMessage);
  }
 else {
    listener.onExpenseUpdated();
  }
}","@Override public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=""String_Node_Str"";
  if (errorMessage.length() > 0) {
    errorText.setInnerText(errorMessage);
  }
 else {
    listener.onExpenseUpdated();
  }
}"
82048,"@SuppressWarnings(""String_Node_Str"") public void onCustom(){
  ReportProxy editableReport=requestObject.edit(report);
  editableReport.setPurpose(purposeText.getText());
  editableReport.setNotes(notesText.getText());
  editableReport.setDepartment(departmentList.getValue(departmentList.getSelectedIndex()));
  Date date=new Date(dateYear.getSelectedIndex() + 100,dateMonth.getSelectedIndex(),dateDay.getSelectedIndex() + 1);
  editableReport.setCreated(date);
  requestObject.fire(new Receiver<Void>(){
    public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=""String_Node_Str"";
      if (errorMessage.length() > 0) {
        errorText.setInnerText(errorMessage);
      }
 else {
        listener.onReportUpdated();
      }
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") public void onCustom(){
  ReportProxy editableReport=requestObject.edit(report);
  editableReport.setPurpose(purposeText.getText());
  editableReport.setNotes(notesText.getText());
  editableReport.setDepartment(departmentList.getValue(departmentList.getSelectedIndex()));
  Date date=new Date(dateYear.getSelectedIndex() + 100,dateMonth.getSelectedIndex(),dateDay.getSelectedIndex() + 1);
  editableReport.setCreated(date);
  requestObject.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=""String_Node_Str"";
      if (errorMessage.length() > 0) {
        errorText.setInnerText(errorMessage);
      }
 else {
        listener.onReportUpdated();
      }
    }
  }
);
}"
82049,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}"
82050,"public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=""String_Node_Str"";
  if (errorMessage.length() > 0) {
    errorText.setInnerText(errorMessage);
  }
 else {
    listener.onReportUpdated();
  }
}","@Override public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=""String_Node_Str"";
  if (errorMessage.length() > 0) {
    errorText.setInnerText(errorMessage);
  }
 else {
    listener.onReportUpdated();
  }
}"
82051,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}"
82052,"public EmployeeEditView asWidget(){
  return this;
}","@Override public EmployeeEditView asWidget(){
  return this;
}"
82053,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}"
82054,"public ReportEditView asWidget(){
  return this;
}","@Override public ReportEditView asWidget(){
  return this;
}"
82055,"public void start(AcceptsOneWidget display,EventBus eventBus){
  this.display=display;
  view.setDelegate(this);
  view.setCreating(creating);
  if (creating) {
    P tempRecord=requests.create(proxyType);
    stableId=tempRecord.stableId();
    doStart(display,tempRecord);
  }
 else {
    ProxyRequest<P> findRequest=getFindRequest(getRecord().getId());
    findRequest.with(getView().getPaths()).fire(new Receiver<P>(){
      public void onSuccess(      P record,      Set<SyncResult> syncResults){
        if (AbstractProxyEditActivity.this.display != null) {
          doStart(AbstractProxyEditActivity.this.display,record);
        }
      }
    }
);
  }
}","public void start(AcceptsOneWidget display,EventBus eventBus){
  this.display=display;
  view.setDelegate(this);
  view.setCreating(creating);
  if (creating) {
    P tempRecord=requests.create(proxyType);
    stableId=tempRecord.stableId();
    doStart(display,tempRecord);
  }
 else {
    ProxyRequest<P> findRequest=getFindRequest(getRecord().getId());
    findRequest.with(getView().getPaths()).fire(new Receiver<P>(){
      @Override public void onSuccess(      P record,      Set<SyncResult> syncResults){
        if (AbstractProxyEditActivity.this.display != null) {
          doStart(AbstractProxyEditActivity.this.display,record);
        }
      }
    }
);
  }
}"
82056,"public void onSuccess(P record,Set<SyncResult> syncResults){
  if (AbstractProxyEditActivity.this.display != null) {
    doStart(AbstractProxyEditActivity.this.display,record);
  }
}","@Override public void onSuccess(P record,Set<SyncResult> syncResults){
  if (AbstractProxyEditActivity.this.display != null) {
    doStart(AbstractProxyEditActivity.this.display,record);
  }
}"
82057,"public AbstractProxyListView<P> asWidget(){
  return this;
}","@Override public AbstractProxyListView<P> asWidget(){
  return this;
}"
82058,"/** 
 * Calls   {@link ValueBoxBase#getValueOrThrow()}. If a   {@link ParseException}is thrown, it will be available through  {@link com.google.gwt.editor.client.EditorError#getUserData() EditorError.getUserData()}.
 */
public T getValue(){
  try {
    value=peer.getValueOrThrow();
  }
 catch (  ParseException e) {
    getDelegate().recordError(""String_Node_Str"" + peer.getText() + ""String_Node_Str"",peer.getText(),e);
  }
  return value;
}","/** 
 * Calls   {@link ValueBoxBase#getValueOrThrow()}. If a   {@link ParseException}is thrown, it will be available through  {@link com.google.gwt.editor.client.EditorError#getUserData() EditorError.getUserData()}.
 */
@Override public T getValue(){
  try {
    value=peer.getValueOrThrow();
  }
 catch (  ParseException e) {
    getDelegate().recordError(""String_Node_Str"" + peer.getText() + ""String_Node_Str"",peer.getText(),e);
  }
  return value;
}"
82059,"public void setValue(T value){
  peer.setValue(this.value=value);
}","@Override public void setValue(T value){
  peer.setValue(this.value=value);
}"
82060,"/** 
 * For debugging use only.
 */
public String toString(){
  return path + ""String_Node_Str"" + type.getParameterizedQualifiedSourceName();
}","/** 
 * For debugging use only.
 */
@Override public String toString(){
  return path + ""String_Node_Str"" + type.getParameterizedQualifiedSourceName();
}"
82061,"/** 
 * Process a child element that should be added using a   {@link UiChild} method
 */
private void handleChild(XMLElement child) throws UnableToCompleteException {
  String tag=child.getLocalName();
  Pair<JMethod,Integer> methodPair=uiChildMethods.get(tag);
  JMethod method=methodPair.left;
  int limit=methodPair.right;
  Iterator<XMLElement> children=child.consumeChildElements().iterator();
  if (!children.hasNext()) {
    return;
  }
  XMLElement toAdd=children.next();
  if (!writer.isWidgetElement(toAdd)) {
    writer.die(child,""String_Node_Str"",child);
  }
  if (children.hasNext()) {
    writer.die(toAdd,""String_Node_Str"");
  }
  checkLimit(limit,tag,toAdd);
  String[] parameters=makeArgsList(child,method,toAdd);
  writer.addStatement(""String_Node_Str"",fieldName,method.getName(),UiBinderWriter.asCommaSeparatedList(parameters));
}","/** 
 * Process a child element that should be added using a   {@link UiChild} method.
 */
private void handleChild(XMLElement child) throws UnableToCompleteException {
  String tag=child.getLocalName();
  Pair<JMethod,Integer> methodPair=uiChildMethods.get(tag);
  JMethod method=methodPair.left;
  int limit=methodPair.right;
  Iterator<XMLElement> children=child.consumeChildElements().iterator();
  if (!children.hasNext()) {
    return;
  }
  XMLElement toAdd=children.next();
  if (!writer.isWidgetElement(toAdd)) {
    writer.die(child,""String_Node_Str"",child);
  }
  if (children.hasNext()) {
    writer.die(toAdd,""String_Node_Str"");
  }
  checkLimit(limit,tag,toAdd);
  String[] parameters=makeArgsList(child,method,toAdd);
  writer.addStatement(""String_Node_Str"",fieldName,method.getName(),UiBinderWriter.asCommaSeparatedList(parameters));
}"
82062,"/** 
 * Scans the class to find all methods annotated with @UiChild
 * @param ownerType the type of the owner class
 * @throws UnableToCompleteException
 */
private void findUiChildren(JClassType ownerType) throws UnableToCompleteException {
  JMethod[] methods=ownerType.getMethods();
  while (ownerType != null) {
    for (    JMethod method : methods) {
      UiChild annotation=method.getAnnotation(UiChild.class);
      if (annotation != null) {
        String tag=annotation.tagname();
        int limit=annotation.limit();
        if (tag.equals(""String_Node_Str"")) {
          String name=method.getName();
          if (name.startsWith(""String_Node_Str"")) {
            tag=name.substring(3).toLowerCase();
          }
 else {
            logger.die(method.getName() + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        uiChildren.put(tag,Pair.create(method,limit));
      }
    }
    ownerType=ownerType.getSuperclass();
  }
}","/** 
 * Scans the class to find all methods annotated with @UiChild.
 * @param ownerType the type of the owner class
 * @throws UnableToCompleteException
 */
private void findUiChildren(JClassType ownerType) throws UnableToCompleteException {
  JMethod[] methods=ownerType.getMethods();
  while (ownerType != null) {
    for (    JMethod method : methods) {
      UiChild annotation=method.getAnnotation(UiChild.class);
      if (annotation != null) {
        String tag=annotation.tagname();
        int limit=annotation.limit();
        if (tag.equals(""String_Node_Str"")) {
          String name=method.getName();
          if (name.startsWith(""String_Node_Str"")) {
            tag=name.substring(3).toLowerCase();
          }
 else {
            logger.die(method.getName() + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        uiChildren.put(tag,Pair.create(method,limit));
      }
    }
    ownerType=ownerType.getSuperclass();
  }
}"
82063,"/** 
 * Gets the panel's child widget.
 * @return the child widget, or <code>null</code> if none is present
 */
public Widget getWidget();","/** 
 * Gets the panel's child widget.
 * @return the child widget, or <code>null</code> if none is present
 */
Widget getWidget();"
82064,"/** 
 * Sets this panel's widget. Any existing child widget will be removed.
 * @param w the panel's new widget, or <code>null</code> to clear the panel
 */
public void setWidget(Widget w);","/** 
 * Sets this panel's widget. Any existing child widget will be removed.
 * @param w the panel's new widget, or <code>null</code> to clear the panel
 */
void setWidget(Widget w);"
82065,"/** 
 * Validates all constraints placed on the property named <code>propertyName</code> of the class <code>beanType</code> would the property value be <code>value</code> <p/> <code>ConstraintViolation</code> objects return null for  {@link ConstraintViolation#getRootBean()} and{@link ConstraintViolation#getLeafBean()}
 * @param < T > the type of the RootBean for this validation context
 * @param context The gwt validation context
 * @param beanType the bean type
 * @param propertyName property to validate
 * @param value property value to validate
 * @param groups group or list of groups targeted for validation (default to{@link javax.validation.groups.Default})
 * @return constraint violations or an empty Set if none
 * @throws IllegalArgumentException if <code>beanType</code> is null, if<code>propertyName</code> null, empty or not a valid object property or if null is passed to the varargs groups
 * @throws ValidationException if a non recoverable error happens during thevalidation process
 */
<T>Set<ConstraintViolation<T>> validateValue(GwtValidationContext<T> context,Class<G> beanType,String propertyName,Object value,Class<?>... groups) throws ValidationException ;","/** 
 * Validates all constraints placed on the property named <code>propertyName</code> of the class <code>beanType</code> where the property value is <code>value</code>. <p/> <code>ConstraintViolation</code> objects return null for  {@link ConstraintViolation#getRootBean()} and{@link ConstraintViolation#getLeafBean()}
 * @param < T > the type of the RootBean for this validation context
 * @param context The gwt validation context
 * @param beanType the bean type
 * @param propertyName property to validate
 * @param value property value to validate
 * @param groups group or list of groups targeted for validation (default to{@link javax.validation.groups.Default})
 * @return constraint violations or an empty Set if none
 * @throws IllegalArgumentException if <code>beanType</code> is null, if<code>propertyName</code> null, empty or not a valid object property or if null is passed to the varargs groups
 * @throws ValidationException if a non recoverable error happens during thevalidation process
 */
<T>Set<ConstraintViolation<T>> validateValue(GwtValidationContext<T> context,Class<G> beanType,String propertyName,Object value,Class<?>... groups) throws ValidationException ;"
82066,"public final String create(){
  SourceWriter sourceWriter=getSourceWriter(logger,context);
  if (sourceWriter != null) {
    writeClassBody(sourceWriter);
    sourceWriter.commit(logger);
  }
  return getQaulifiedName();
}","public final String create(){
  SourceWriter sourceWriter=getSourceWriter(logger,context);
  if (sourceWriter != null) {
    writeClassBody(sourceWriter);
    sourceWriter.commit(logger);
  }
  return getQualifiedName();
}"
82067,"private final String getSimpleName(){
  return validatorType.getSimpleSourceName() + ""String_Node_Str"";
}","private String getSimpleName(){
  return validatorType.getSimpleSourceName() + ""String_Node_Str"";
}"
82068,"private final SourceWriter getSourceWriter(TreeLogger logger,GeneratorContext ctx){
  String packageName=getPackage();
  String simpleName=getSimpleName();
  PrintWriter printWriter=ctx.tryCreate(logger,packageName,simpleName);
  if (printWriter == null) {
    return null;
  }
  ClassSourceFileComposerFactory composerFactory=new ClassSourceFileComposerFactory(packageName,simpleName);
  compose(composerFactory);
  SourceWriter sourceWriter=composerFactory.createSourceWriter(ctx,printWriter);
  return sourceWriter;
}","private SourceWriter getSourceWriter(TreeLogger logger,GeneratorContext ctx){
  String packageName=getPackage();
  String simpleName=getSimpleName();
  PrintWriter printWriter=ctx.tryCreate(logger,packageName,simpleName);
  if (printWriter == null) {
    return null;
  }
  ClassSourceFileComposerFactory composerFactory=new ClassSourceFileComposerFactory(packageName,simpleName);
  compose(composerFactory);
  SourceWriter sourceWriter=composerFactory.createSourceWriter(ctx,printWriter);
  return sourceWriter;
}"
82069,"private void generateRequestSelectorImplementation(TreeLogger logger,GeneratorContext generatorContext,PrintWriter out,JMethod selectorMethod,JClassType mainType,String packageName,String implName) throws UnableToCompleteException {
  JClassType selectorInterface=selectorMethod.getReturnType().isInterface();
  logger=logger.branch(TreeLogger.DEBUG,String.format(""String_Node_Str"",selectorInterface.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(RequestData.class.getName());
  f.addImport(mainType.getQualifiedSourceName() + ""String_Node_Str"");
  f.addImplementedInterface(selectorInterface.getQualifiedSourceName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  sw.println(""String_Node_Str"" + mainType.getName() + ""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + implName + ""String_Node_Str""+ mainType.getName()+ ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  for (  JMethod method : selectorInterface.getOverridableMethods()) {
    JClassType returnType=method.getReturnType().isParameterized().getTypeArgs()[0];
    ensureProxyType(logger,generatorContext,returnType.getPackage().getName(),returnType);
    String operationName=selectorInterface.getQualifiedBinaryName() + ReflectionBasedOperationRegistry.SCOPE_SEPARATOR + method.getName();
    JClassType requestType=method.getReturnType().isClassOrInterface();
    String requestClassName=null;
    TypeOracle typeOracle=generatorContext.getTypeOracle();
    String enumArgument=""String_Node_Str"";
    if (isProxyListRequest(typeOracle,requestType)) {
      requestClassName=asInnerImplClass(""String_Node_Str"",returnType);
    }
 else     if (isProxyRequest(typeOracle,requestType)) {
      requestClassName=asInnerImplClass(""String_Node_Str"",returnType);
    }
 else     if (isStringRequest(typeOracle,requestType)) {
      requestClassName=AbstractStringRequest.class.getName();
    }
 else     if (isLongRequest(typeOracle,requestType)) {
      requestClassName=AbstractLongRequest.class.getName();
    }
 else     if (isIntegerRequest(typeOracle,requestType)) {
      requestClassName=AbstractIntegerRequest.class.getName();
    }
 else     if (isDoubleRequest(typeOracle,requestType)) {
      requestClassName=AbstractDoubleRequest.class.getName();
    }
 else     if (isByteRequest(typeOracle,requestType)) {
      requestClassName=AbstractByteRequest.class.getName();
    }
 else     if (isBooleanRequest(typeOracle,requestType)) {
      requestClassName=AbstractBooleanRequest.class.getName();
    }
 else     if (isShortRequest(typeOracle,requestType)) {
      requestClassName=AbstractShortRequest.class.getName();
    }
 else     if (isFloatRequest(typeOracle,requestType)) {
      requestClassName=AbstractFloatRequest.class.getName();
    }
 else     if (isCharacterRequest(typeOracle,requestType)) {
      requestClassName=AbstractCharacterRequest.class.getName();
    }
 else     if (isDateRequest(typeOracle,requestType)) {
      requestClassName=AbstractDateRequest.class.getName();
    }
 else     if (isBigDecimalRequest(typeOracle,requestType)) {
      requestClassName=AbstractBigDecimalRequest.class.getName();
    }
 else     if (isBigIntegerRequest(typeOracle,requestType)) {
      requestClassName=AbstractBigIntegerRequest.class.getName();
    }
 else     if (isEnumRequest(typeOracle,requestType)) {
      requestClassName=AbstractEnumRequest.class.getName();
      enumArgument=""String_Node_Str"" + requestType.isParameterized().getTypeArgs()[0] + ""String_Node_Str"";
    }
 else     if (isVoidRequest(typeOracle,requestType)) {
      requestClassName=AbstractVoidRequest.class.getName();
    }
 else {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + requestType + ""String_Node_Str"");
      throw new UnableToCompleteException();
    }
    sw.println(getMethodDeclaration(method) + ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + requestClassName + ""String_Node_Str""+ enumArgument+ ""String_Node_Str"");
    sw.indent();
    String requestDataName=RequestData.class.getSimpleName();
    sw.println(""String_Node_Str"" + requestDataName + ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + requestDataName + ""String_Node_Str""+ operationName+ ""String_Node_Str""+ getParametersAsString(method,typeOracle)+ ""String_Node_Str""+ ""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
  }
  sw.outdent();
  sw.println(""String_Node_Str"");
  generatorContext.commit(logger,out);
}","private void generateRequestSelectorImplementation(TreeLogger logger,GeneratorContext generatorContext,PrintWriter out,JMethod selectorMethod,JClassType mainType,String packageName,String implName) throws UnableToCompleteException {
  JClassType selectorInterface=selectorMethod.getReturnType().isInterface();
  logger=logger.branch(TreeLogger.DEBUG,String.format(""String_Node_Str"",selectorInterface.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(RequestData.class.getName());
  f.addImport(mainType.getQualifiedSourceName() + ""String_Node_Str"");
  f.addImplementedInterface(selectorInterface.getQualifiedSourceName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  sw.println(""String_Node_Str"" + mainType.getName() + ""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + implName + ""String_Node_Str""+ mainType.getName()+ ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  for (  JMethod method : selectorInterface.getOverridableMethods()) {
    JClassType returnType=method.getReturnType().isParameterized().getTypeArgs()[0];
    ensureProxyType(logger,generatorContext,returnType.getPackage().getName(),returnType);
    String operationName=selectorInterface.getQualifiedBinaryName() + ReflectionBasedOperationRegistry.SCOPE_SEPARATOR + method.getName();
    JClassType requestType=method.getReturnType().isClassOrInterface();
    String requestClassName=null;
    TypeOracle typeOracle=generatorContext.getTypeOracle();
    String enumOrFindArgument=""String_Node_Str"";
    if (isProxyListRequest(typeOracle,requestType)) {
      requestClassName=asInnerImplClass(""String_Node_Str"",returnType);
    }
 else     if (isProxyRequest(typeOracle,requestType)) {
      if (selectorInterface.isAssignableTo(typeOracle.findType(FindRequest.class.getName()))) {
        enumOrFindArgument=""String_Node_Str"";
        requestClassName=FindRequestObjectImpl.class.getName();
      }
 else {
        requestClassName=asInnerImplClass(""String_Node_Str"",returnType);
      }
    }
 else     if (isStringRequest(typeOracle,requestType)) {
      requestClassName=AbstractStringRequest.class.getName();
    }
 else     if (isLongRequest(typeOracle,requestType)) {
      requestClassName=AbstractLongRequest.class.getName();
    }
 else     if (isIntegerRequest(typeOracle,requestType)) {
      requestClassName=AbstractIntegerRequest.class.getName();
    }
 else     if (isDoubleRequest(typeOracle,requestType)) {
      requestClassName=AbstractDoubleRequest.class.getName();
    }
 else     if (isByteRequest(typeOracle,requestType)) {
      requestClassName=AbstractByteRequest.class.getName();
    }
 else     if (isBooleanRequest(typeOracle,requestType)) {
      requestClassName=AbstractBooleanRequest.class.getName();
    }
 else     if (isShortRequest(typeOracle,requestType)) {
      requestClassName=AbstractShortRequest.class.getName();
    }
 else     if (isFloatRequest(typeOracle,requestType)) {
      requestClassName=AbstractFloatRequest.class.getName();
    }
 else     if (isCharacterRequest(typeOracle,requestType)) {
      requestClassName=AbstractCharacterRequest.class.getName();
    }
 else     if (isDateRequest(typeOracle,requestType)) {
      requestClassName=AbstractDateRequest.class.getName();
    }
 else     if (isBigDecimalRequest(typeOracle,requestType)) {
      requestClassName=AbstractBigDecimalRequest.class.getName();
    }
 else     if (isBigIntegerRequest(typeOracle,requestType)) {
      requestClassName=AbstractBigIntegerRequest.class.getName();
    }
 else     if (isEnumRequest(typeOracle,requestType)) {
      requestClassName=AbstractEnumRequest.class.getName();
      enumOrFindArgument=""String_Node_Str"" + requestType.isParameterized().getTypeArgs()[0] + ""String_Node_Str"";
    }
 else     if (isVoidRequest(typeOracle,requestType)) {
      requestClassName=AbstractVoidRequest.class.getName();
    }
 else {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + requestType + ""String_Node_Str"");
      throw new UnableToCompleteException();
    }
    sw.println(getMethodDeclaration(method) + ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + requestClassName + ""String_Node_Str""+ enumOrFindArgument+ ""String_Node_Str"");
    sw.indent();
    String requestDataName=RequestData.class.getSimpleName();
    sw.println(""String_Node_Str"" + requestDataName + ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + requestDataName + ""String_Node_Str""+ operationName+ ""String_Node_Str""+ getParametersAsString(method,typeOracle)+ ""String_Node_Str""+ ""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
  }
  sw.outdent();
  sw.println(""String_Node_Str"");
  generatorContext.commit(logger,out);
}"
82070,"/** 
 * Returns the string representation of the parameters to be passed to the server side method.
 */
private String getParametersAsString(JMethod method,TypeOracle typeOracle){
  StringBuilder sb=new StringBuilder();
  for (  JParameter parameter : method.getParameters()) {
    if (sb.length() > 0) {
      sb.append(""String_Node_Str"");
    }
    JClassType classType=parameter.getType().isClassOrInterface();
    JType paramType=parameter.getType();
    JParameterizedType params=paramType.isParameterized();
    if (params != null) {
      classType=params.getTypeArgs()[0];
    }
    if (classType != null && classType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
      sb.append(""String_Node_Str"" + classType.getQualifiedBinaryName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    sb.append(parameter.getName());
    if (classType != null && classType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
      sb.append(""String_Node_Str"");
    }
  }
  return ""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
}","/** 
 * Returns the string representation of the parameters to be passed to the server side method.
 */
private String getParametersAsString(JMethod method,TypeOracle typeOracle){
  StringBuilder sb=new StringBuilder();
  for (  JParameter parameter : method.getParameters()) {
    if (sb.length() > 0) {
      sb.append(""String_Node_Str"");
    }
    JClassType classType=parameter.getType().isClassOrInterface();
    JType paramType=parameter.getType();
    if (paramType.getQualifiedSourceName().equals(EntityProxyId.class.getName())) {
      sb.append(""String_Node_Str"" + parameter.getName() + ""String_Node_Str"");
      continue;
    }
    JParameterizedType params=paramType.isParameterized();
    if (params != null) {
      classType=params.getTypeArgs()[0];
    }
    if (classType != null && classType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
      sb.append(""String_Node_Str"" + classType.getQualifiedBinaryName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
    sb.append(parameter.getName());
    if (classType != null && classType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
      sb.append(""String_Node_Str"");
    }
  }
  return ""String_Node_Str"" + sb.toString() + ""String_Node_Str"";
}"
82071,"private void ensureProxyType(TreeLogger logger,GeneratorContext generatorContext,String packageName,JClassType publicProxyType) throws UnableToCompleteException {
  TypeOracle typeOracle=generatorContext.getTypeOracle();
  if (!publicProxyType.isAssignableTo(typeOracle.findType(EntityProxy.class.getName()))) {
    return;
  }
  if (generatedProxyTypes.contains(publicProxyType)) {
    return;
  }
  String proxyImplTypeName=publicProxyType.getName() + ""String_Node_Str"";
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,proxyImplTypeName);
  Set<JClassType> transitiveDeps=new LinkedHashSet<JClassType>();
  if (pw != null) {
    logger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + publicProxyType.getName());
    ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,proxyImplTypeName);
    f.addImport(AbstractJsonListRequest.class.getName());
    f.addImport(AbstractJsonObjectRequest.class.getName());
    f.addImport(RequestFactoryJsonImpl.class.getName());
    f.addImport(Property.class.getName());
    f.addImport(EnumProperty.class.getName());
    f.addImport(EntityProxy.class.getName());
    f.addImport(ProxyImpl.class.getName());
    f.addImport(ProxyJsoImpl.class.getName());
    f.addImport(ProxySchema.class.getName());
    f.addImport(WriteOperation.class.getName().replace(""String_Node_Str"",""String_Node_Str""));
    f.addImport(Collections.class.getName());
    f.addImport(HashSet.class.getName());
    f.addImport(Set.class.getName());
    f.setSuperclass(ProxyImpl.class.getSimpleName());
    f.addImplementedInterface(publicProxyType.getName());
    List<EntityProperty> entityProperties=computeEntityPropertiesFromProxyType(publicProxyType);
    for (    EntityProperty entityProperty : entityProperties) {
      JType type=entityProperty.getType();
      if (type.isPrimitive() == null) {
        f.addImport(type.getErasedType().getQualifiedSourceName());
      }
    }
    SourceWriter sw=f.createSourceWriter(generatorContext,pw);
    sw.println();
    for (    EntityProperty entityProperty : entityProperties) {
      sw.println();
      String name=entityProperty.getName();
      if (entityProperty.getType().isEnum() != null) {
        sw.println(String.format(""String_Node_Str"",entityProperty.getType().getSimpleSourceName(),name));
      }
 else {
        sw.println(String.format(""String_Node_Str"",entityProperty.getType().getSimpleSourceName(),name,capitalize(name)));
      }
    }
    printSchema(typeOracle,publicProxyType,proxyImplTypeName,sw);
    sw.println();
    String simpleImplName=publicProxyType.getSimpleSourceName() + ""String_Node_Str"";
    printRequestImplClass(sw,publicProxyType,simpleImplName,true);
    printRequestImplClass(sw,publicProxyType,simpleImplName,false);
    sw.println();
    sw.println(String.format(""String_Node_Str"",proxyImplTypeName));
    sw.println();
    sw.println(String.format(""String_Node_Str"",proxyImplTypeName));
    sw.indent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    for (    EntityProperty entityProperty : entityProperties) {
      JClassType returnType=entityProperty.getType().isClassOrInterface();
      sw.println();
      sw.println(String.format(""String_Node_Str"",returnType.getQualifiedSourceName(),capitalize(entityProperty.getName())));
      sw.indent();
      sw.println(String.format(""String_Node_Str"",entityProperty.getName()));
      sw.outdent();
      sw.println(""String_Node_Str"");
      if (isProxyType(typeOracle,returnType)) {
        transitiveDeps.add(returnType);
      }
    }
    for (    EntityProperty entityProperty : entityProperties) {
      JClassType returnType=entityProperty.getType().isClassOrInterface();
      sw.println();
      String varName=entityProperty.getName();
      sw.println(String.format(""String_Node_Str"",capitalize(varName),returnType.getQualifiedSourceName(),varName));
      sw.indent();
      sw.println(String.format(""String_Node_Str"",varName,varName));
      sw.outdent();
      sw.println(""String_Node_Str"");
    }
    sw.outdent();
    sw.println(""String_Node_Str"");
    generatorContext.commit(logger,pw);
  }
  generatedProxyTypes.add(publicProxyType);
  for (  JClassType type : transitiveDeps) {
    ensureProxyType(logger,generatorContext,type.getPackage().getName(),type);
  }
}","private void ensureProxyType(TreeLogger logger,GeneratorContext generatorContext,String packageName,JClassType publicProxyType) throws UnableToCompleteException {
  TypeOracle typeOracle=generatorContext.getTypeOracle();
  JClassType entityProxyClass=typeOracle.findType(EntityProxy.class.getName());
  if (!publicProxyType.isAssignableTo(entityProxyClass)) {
    return;
  }
  if (publicProxyType.equals(entityProxyClass)) {
    return;
  }
  if (generatedProxyTypes.contains(publicProxyType)) {
    return;
  }
  String proxyImplTypeName=publicProxyType.getName() + ""String_Node_Str"";
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,proxyImplTypeName);
  Set<JClassType> transitiveDeps=new LinkedHashSet<JClassType>();
  if (pw != null) {
    logger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + publicProxyType.getName());
    ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,proxyImplTypeName);
    f.addImport(AbstractJsonListRequest.class.getName());
    f.addImport(AbstractJsonObjectRequest.class.getName());
    f.addImport(RequestFactoryJsonImpl.class.getName());
    f.addImport(Property.class.getName());
    f.addImport(EnumProperty.class.getName());
    f.addImport(EntityProxy.class.getName());
    f.addImport(ProxyImpl.class.getName());
    f.addImport(ProxyJsoImpl.class.getName());
    f.addImport(ProxySchema.class.getName());
    f.addImport(WriteOperation.class.getName().replace(""String_Node_Str"",""String_Node_Str""));
    f.addImport(Collections.class.getName());
    f.addImport(HashSet.class.getName());
    f.addImport(Set.class.getName());
    f.setSuperclass(ProxyImpl.class.getSimpleName());
    f.addImplementedInterface(publicProxyType.getName());
    List<EntityProperty> entityProperties=computeEntityPropertiesFromProxyType(publicProxyType);
    for (    EntityProperty entityProperty : entityProperties) {
      JType type=entityProperty.getType();
      if (type.isPrimitive() == null) {
        f.addImport(type.getErasedType().getQualifiedSourceName());
      }
    }
    SourceWriter sw=f.createSourceWriter(generatorContext,pw);
    sw.println();
    for (    EntityProperty entityProperty : entityProperties) {
      sw.println();
      String name=entityProperty.getName();
      if (entityProperty.getType().isEnum() != null) {
        sw.println(String.format(""String_Node_Str"",entityProperty.getType().getSimpleSourceName(),name));
      }
 else {
        sw.println(String.format(""String_Node_Str"",entityProperty.getType().getSimpleSourceName(),name,capitalize(name)));
      }
    }
    printSchema(typeOracle,publicProxyType,proxyImplTypeName,sw);
    sw.println();
    String simpleImplName=publicProxyType.getSimpleSourceName() + ""String_Node_Str"";
    printRequestImplClass(sw,publicProxyType,simpleImplName,true);
    printRequestImplClass(sw,publicProxyType,simpleImplName,false);
    sw.println();
    sw.println(String.format(""String_Node_Str"",proxyImplTypeName));
    sw.println();
    sw.println(String.format(""String_Node_Str"",proxyImplTypeName));
    sw.indent();
    sw.println(""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    for (    EntityProperty entityProperty : entityProperties) {
      JClassType returnType=entityProperty.getType().isClassOrInterface();
      sw.println();
      sw.println(String.format(""String_Node_Str"",returnType.getQualifiedSourceName(),capitalize(entityProperty.getName())));
      sw.indent();
      sw.println(String.format(""String_Node_Str"",entityProperty.getName()));
      sw.outdent();
      sw.println(""String_Node_Str"");
      if (isProxyType(typeOracle,returnType)) {
        transitiveDeps.add(returnType);
      }
    }
    for (    EntityProperty entityProperty : entityProperties) {
      JClassType returnType=entityProperty.getType().isClassOrInterface();
      sw.println();
      String varName=entityProperty.getName();
      sw.println(String.format(""String_Node_Str"",capitalize(varName),returnType.getQualifiedSourceName(),varName));
      sw.indent();
      sw.println(String.format(""String_Node_Str"",varName,varName));
      sw.outdent();
      sw.println(""String_Node_Str"");
    }
    sw.outdent();
    sw.println(""String_Node_Str"");
    generatorContext.commit(logger,pw);
  }
  generatedProxyTypes.add(publicProxyType);
  for (  JClassType type : transitiveDeps) {
    ensureProxyType(logger,generatorContext,type.getPackage().getName(),type);
  }
}"
82072,"private void generateOnce(JClassType requestFactoryType,TreeLogger logger,GeneratorContext generatorContext,PrintWriter out,JClassType interfaceType,String packageName,String implName) throws UnableToCompleteException {
  logger=logger.branch(TreeLogger.DEBUG,String.format(""String_Node_Str"",interfaceType.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(HandlerManager.class.getName());
  f.addImport(RequestFactoryJsonImpl.class.getName());
  f.addImport(interfaceType.getQualifiedSourceName());
  f.addImport(ProxyToTypeMap.class.getName());
  f.addImport(EntityProxy.class.getName());
  f.addImport(ProxySchema.class.getName());
  f.addImplementedInterface(interfaceType.getName());
  f.setSuperclass(RequestFactoryJsonImpl.class.getSimpleName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  Set<JMethod> requestSelectors=new LinkedHashSet<JMethod>();
  for (  JMethod method : interfaceType.getOverridableMethods()) {
    if (method.getEnclosingType().equals(requestFactoryType)) {
      continue;
    }
    JType returnType=method.getReturnType();
    if (null == returnType) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    JClassType asInterface=returnType.isInterface();
    if (null == asInterface) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    requestSelectors.add(method);
  }
  JClassType proxyToTypeInterface=generatorContext.getTypeOracle().findType(ProxyToTypeMap.class.getName());
  String proxyToTypeMapName=proxyToTypeInterface.getName() + ""String_Node_Str"";
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxyId.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  for (  JMethod requestSelector : requestSelectors) {
    String returnTypeName=requestSelector.getReturnType().getQualifiedSourceName();
    String nestedImplName=capitalize(requestSelector.getName().replace('.','_')) + ""String_Node_Str"";
    String nestedImplPackage=generatorContext.getTypeOracle().findType(returnTypeName).getPackage().getName();
    sw.println(""String_Node_Str"" + returnTypeName + ""String_Node_Str""+ requestSelector.getName()+ ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + nestedImplPackage + ""String_Node_Str""+ nestedImplName+ ""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.println();
    PrintWriter pw=generatorContext.tryCreate(logger,nestedImplPackage,nestedImplName);
    if (pw != null) {
      generateRequestSelectorImplementation(logger,generatorContext,pw,requestSelector,interfaceType,nestedImplPackage,nestedImplName);
    }
  }
  sw.outdent();
  sw.println(""String_Node_Str"");
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,proxyToTypeMapName);
  if (pw != null) {
    generateProxyToTypeMap(logger,generatorContext,pw,proxyToTypeInterface,packageName,proxyToTypeMapName);
  }
  generatorContext.commit(logger,out);
}","private void generateOnce(JClassType requestFactoryType,TreeLogger logger,GeneratorContext generatorContext,PrintWriter out,JClassType interfaceType,String packageName,String implName) throws UnableToCompleteException {
  logger=logger.branch(TreeLogger.DEBUG,String.format(""String_Node_Str"",interfaceType.getName()));
  ClassSourceFileComposerFactory f=new ClassSourceFileComposerFactory(packageName,implName);
  f.addImport(HandlerManager.class.getName());
  f.addImport(RequestFactoryJsonImpl.class.getName());
  f.addImport(interfaceType.getQualifiedSourceName());
  f.addImport(ProxyToTypeMap.class.getName());
  f.addImport(EntityProxy.class.getName());
  f.addImport(ProxySchema.class.getName());
  f.addImplementedInterface(interfaceType.getName());
  f.setSuperclass(RequestFactoryJsonImpl.class.getSimpleName());
  SourceWriter sw=f.createSourceWriter(generatorContext,out);
  sw.println();
  Set<JMethod> requestSelectors=new LinkedHashSet<JMethod>();
  for (  JMethod method : interfaceType.getOverridableMethods()) {
    if (method.getEnclosingType().equals(requestFactoryType)) {
      continue;
    }
    JType returnType=method.getReturnType();
    if (null == returnType) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    JClassType asInterface=returnType.isInterface();
    if (null == asInterface) {
      logger.log(TreeLogger.ERROR,String.format(""String_Node_Str"",method.getName(),interfaceType.getName()));
      throw new UnableToCompleteException();
    }
    requestSelectors.add(method);
  }
  JClassType t=generatorContext.getTypeOracle().findType(RequestFactoryJsonImpl.class.getName());
  try {
    requestSelectors.add(t.getMethod(""String_Node_Str"",new JType[0]));
  }
 catch (  NotFoundException e) {
    e.printStackTrace();
  }
  JClassType proxyToTypeInterface=generatorContext.getTypeOracle().findType(ProxyToTypeMap.class.getName());
  String proxyToTypeMapName=proxyToTypeInterface.getName() + ""String_Node_Str"";
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxy.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"" + EntityProxyId.class.getName() + ""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  sw.println();
  sw.println(""String_Node_Str"");
  sw.indent();
  sw.println(""String_Node_Str"" + proxyToTypeMapName + ""String_Node_Str"");
  sw.outdent();
  sw.println(""String_Node_Str"");
  for (  JMethod requestSelector : requestSelectors) {
    String returnTypeName=requestSelector.getReturnType().getQualifiedSourceName();
    String nestedImplName=capitalize(requestSelector.getName().replace('.','_')) + ""String_Node_Str"";
    String nestedImplPackage=generatorContext.getTypeOracle().findType(returnTypeName).getPackage().getName();
    sw.println(""String_Node_Str"" + returnTypeName + ""String_Node_Str""+ requestSelector.getName()+ ""String_Node_Str"");
    sw.indent();
    sw.println(""String_Node_Str"" + nestedImplPackage + ""String_Node_Str""+ nestedImplName+ ""String_Node_Str"");
    sw.outdent();
    sw.println(""String_Node_Str"");
    sw.println();
    PrintWriter pw=generatorContext.tryCreate(logger,nestedImplPackage,nestedImplName);
    if (pw != null) {
      generateRequestSelectorImplementation(logger,generatorContext,pw,requestSelector,interfaceType,nestedImplPackage,nestedImplName);
    }
  }
  sw.outdent();
  sw.println(""String_Node_Str"");
  PrintWriter pw=generatorContext.tryCreate(logger,packageName,proxyToTypeMapName);
  if (pw != null) {
    generateProxyToTypeMap(logger,generatorContext,pw,proxyToTypeInterface,packageName,proxyToTypeMapName);
  }
  generatorContext.commit(logger,out);
}"
82073,"public void testInternalPrecision(){
  long millis=System.currentTimeMillis();
  Date now=new Date(millis);
  Date after=new Date(now.getTime() + 1);
  Date before=new Date(now.getTime() - 1);
  assertTrue(after.after(now));
  assertTrue(before.before(now));
}","public void testInternalPrecision(){
  long millis=1283895273475L;
  Date now=new Date(millis);
  Date after=new Date(now.getTime() + 1);
  Date before=new Date(now.getTime() - 1);
  assertTrue(after.after(now));
  assertTrue(before.before(now));
}"
82074,"public void testInternalPrecision(){
  long millis=System.currentTimeMillis();
  Time today=new Time(millis);
  Time after=new Time(today.getTime() + 1);
  Time before=new Time(today.getTime() - 1);
  assertTrue(after.after(today));
  assertTrue(before.before(today));
}","public void testInternalPrecision(){
  long millis=1283895273475L;
  Time today=new Time(millis);
  Time after=new Time(today.getTime() + 1);
  Time before=new Time(today.getTime() - 1);
  assertTrue(after.after(today));
  assertTrue(before.before(today));
}"
82075,"public void testNanosAffectTime(){
  long now=System.currentTimeMillis();
  int millis=(int)(now % 1000);
  Timestamp t=new Timestamp(now);
  assertEquals(now,t.getTime());
  assertEquals(millis * 1000000,t.getNanos());
  t.setNanos(0);
  assertEquals(now - millis,t.getTime());
  t.setNanos(999999999);
  assertEquals(now - millis + 999,t.getTime());
}","public void testNanosAffectTime(){
  long now=1283895273475L;
  int millis=(int)(now % 1000);
  Timestamp t=new Timestamp(now);
  assertEquals(now,t.getTime());
  assertEquals(millis * 1000000,t.getNanos());
  t.setNanos(0);
  assertEquals(now - millis,t.getTime());
  t.setNanos(999999999);
  assertEquals(now - millis + 999,t.getTime());
}"
82076,"public void testNanosRange(){
  long now=System.currentTimeMillis();
  Timestamp t=new Timestamp(now);
  assertEquals(now,t.getTime());
  assertEquals((now % 1000) * 1000000,t.getNanos());
  try {
    t.setNanos(-1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  t.setNanos(0);
  try {
    t.setNanos(1000000000);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  t.setNanos(999999999);
}","public void testNanosRange(){
  long now=1283895273475L;
  Timestamp t=new Timestamp(now);
  assertEquals(now,t.getTime());
  assertEquals((now % 1000) * 1000000,t.getNanos());
  try {
    t.setNanos(-1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  t.setNanos(0);
  try {
    t.setNanos(1000000000);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  t.setNanos(999999999);
}"
82077,"public void testTimeAffectsNanos(){
  long now=(System.currentTimeMillis() / 1000) * 1000 + 5;
  Timestamp t=new Timestamp(now);
  assertEquals(5000000,t.getNanos());
  t.setTime(now + 1);
  assertEquals(6000000,t.getNanos());
}","public void testTimeAffectsNanos(){
  long now=1283895273005L;
  Timestamp t=new Timestamp(now);
  assertEquals(5000000,t.getNanos());
  t.setTime(now + 1);
  assertEquals(6000000,t.getNanos());
}"
82078,"public void testNanosComparison(){
  long now=System.currentTimeMillis();
  Timestamp t=new Timestamp(now);
  t.setNanos(0);
  Timestamp t2=new Timestamp(t.getTime());
  t2.setNanos(0);
  assertEquals(t,t2);
  assertEquals(0,t.compareTo(t2));
  assertFalse(t.before(t2));
  assertFalse(t.after(t2));
  t2.setNanos(1);
  assertFalse(t.equals(t2));
  assertTrue(t.compareTo(t2) < 0);
  assertTrue(t2.compareTo(t) > 0);
  assertTrue(t.before(t2));
  assertTrue(t2.after(t));
}","public void testNanosComparison(){
  long now=1283895273475L;
  Timestamp t=new Timestamp(now);
  t.setNanos(0);
  Timestamp t2=new Timestamp(t.getTime());
  t2.setNanos(0);
  assertEquals(t,t2);
  assertEquals(0,t.compareTo(t2));
  assertFalse(t.before(t2));
  assertFalse(t.after(t2));
  t2.setNanos(1);
  assertFalse(t.equals(t2));
  assertTrue(t.compareTo(t2) < 0);
  assertTrue(t2.compareTo(t) > 0);
  assertTrue(t.before(t2));
  assertTrue(t2.after(t));
}"
82079,"/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  assertEquals(1,t.compareTo(d2));
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(t.getNanos() + 1);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}","/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  testDateComparisonOneValue(1283895274000L);
  testDateComparisonOneValue(1283895273475L);
}"
82080,"Sandbox(AbstractCompiler outer,boolean doGenerateBytes){
  this.outer=outer;
  this.doGenerateBytes=doGenerateBytes;
  rememberPackage(""String_Node_Str"");
  INameEnvironment env=new INameEnvironmentImpl();
  IErrorHandlingPolicy pol=DefaultErrorHandlingPolicies.proceedWithAllProblems();
  IProblemFactory probFact=new DefaultProblemFactory(Locale.getDefault());
  ICompilerRequestor req=new ICompilerRequestorImpl();
  CompilerOptions options=getCompilerOptions();
  options.docCommentSupport=false;
  compiler=new CompilerImpl(env,pol,options,req,probFact);
  for (  CompilationUnit unit : outer.compilationState.getCompilationUnits()) {
    String packageName=Shared.getPackageName(unit.getTypeName());
    rememberPackage(packageName);
  }
}","Sandbox(AbstractCompiler outer,boolean doGenerateBytes){
  this.outer=outer;
  this.doGenerateBytes=doGenerateBytes;
  rememberPackage(""String_Node_Str"");
  INameEnvironment env=new INameEnvironmentImpl();
  IErrorHandlingPolicy pol=DefaultErrorHandlingPolicies.proceedWithAllProblems();
  IProblemFactory probFact=new DefaultProblemFactory(Locale.getDefault());
  ICompilerRequestor req=new ICompilerRequestorImpl();
  CompilerOptions options=getCompilerOptions();
  options.docCommentSupport=false;
  compiler=new CompilerImpl(env,pol,options,req,probFact);
  refreshPackagesFromCompState();
}"
82081,"/** 
 * Causes the compilation service itself to recognize the specified package name (and all its parent packages), avoiding a call back into the host. This is useful as an optimization, but more importantly, it is useful to compile against bytecode that was pre-compiled to which we don't have the source. This ability is crucial bridging the gap between user-level and ""dev"" code in hosted mode for classes such as JavaScriptHost and ShellJavaScriptHost.
 */
private void rememberPackage(String packageName){
  int i=packageName.lastIndexOf('.');
  if (i != -1) {
    rememberPackage(packageName.substring(0,i));
  }
  knownPackages.add(packageName);
}","/** 
 * Causes the compilation service itself to recognize the specified package name (and all its parent packages), avoiding a call back into the host. This is useful as an optimization, but more importantly, it is useful to compile against bytecode that was pre-compiled to which we don't have the source. This ability is crucial bridging the gap between user-level and ""dev"" code in hosted mode for classes such as JavaScriptHost and ShellJavaScriptHost.
 */
private void rememberPackage(String packageName){
  if (knownPackages.add(packageName)) {
    int i=packageName.lastIndexOf('.');
    if (i != -1) {
      rememberPackage(packageName.substring(0,i));
    }
  }
}"
82082,"@Override public void process(CompilationUnitDeclaration unit,int index){
  long processBeginNanos=System.nanoTime();
{
    this.lookupEnvironment.unitBeingCompleted=unit;
    long parseStart=System.currentTimeMillis();
    this.parser.getMethodBodies(unit);
    long resolveStart=System.currentTimeMillis();
    this.stats.parseTime+=resolveStart - parseStart;
    if (unit.scope != null) {
      unit.scope.faultInTypes();
    }
    if (unit.scope != null) {
      unit.scope.verifyMethods(lookupEnvironment.methodVerifier());
    }
    unit.resolve();
    long analyzeStart=System.currentTimeMillis();
    this.stats.resolveTime+=analyzeStart - resolveStart;
    unit.analyseCode();
    long generateStart=System.currentTimeMillis();
    this.stats.analyzeTime+=generateStart - analyzeStart;
    if (doGenerateBytes) {
      unit.generateCode();
    }
    if (options.produceReferenceInfo && unit.scope != null) {
      unit.scope.storeDependencyInfo();
    }
    unit.finalizeProblems();
    this.stats.generateTime+=System.currentTimeMillis() - generateStart;
    unit.compilationResult.totalUnitsKnown=totalUnits;
    this.lookupEnvironment.unitBeingCompleted=null;
  }
  ICompilationUnit cu=unit.compilationResult.compilationUnit;
  String loc=String.valueOf(cu.getFileName());
  TreeLogger branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"" + loc,null);
  String[] typeNames=outer.doFindAdditionalTypesUsingJsni(branch,unit);
  addAdditionalTypes(branch,typeNames);
  typeNames=outer.doFindAdditionalTypesUsingRebinds(branch,unit);
  addAdditionalTypes(branch,typeNames);
  typeNames=outer.doFindAdditionalTypesUsingArtificialRescues(branch,unit);
  addAdditionalTypes(branch,typeNames);
  if (cuds != null) {
    cuds.add(unit);
  }
  jdtProcessNanos+=System.nanoTime() - processBeginNanos;
}","@Override public void process(CompilationUnitDeclaration unit,int index){
  long processBeginNanos=System.nanoTime();
{
    this.lookupEnvironment.unitBeingCompleted=unit;
    long parseStart=System.currentTimeMillis();
    this.parser.getMethodBodies(unit);
    long resolveStart=System.currentTimeMillis();
    this.stats.parseTime+=resolveStart - parseStart;
    if (unit.scope != null) {
      unit.scope.faultInTypes();
    }
    if (unit.scope != null) {
      unit.scope.verifyMethods(lookupEnvironment.methodVerifier());
    }
    unit.resolve();
    long analyzeStart=System.currentTimeMillis();
    this.stats.resolveTime+=analyzeStart - resolveStart;
    unit.analyseCode();
    long generateStart=System.currentTimeMillis();
    this.stats.analyzeTime+=generateStart - analyzeStart;
    if (doGenerateBytes) {
      unit.generateCode();
    }
    if (options.produceReferenceInfo && unit.scope != null) {
      unit.scope.storeDependencyInfo();
    }
    unit.finalizeProblems();
    this.stats.generateTime+=System.currentTimeMillis() - generateStart;
    unit.compilationResult.totalUnitsKnown=totalUnits;
    this.lookupEnvironment.unitBeingCompleted=null;
  }
  ICompilationUnit cu=unit.compilationResult.compilationUnit;
  String loc=String.valueOf(cu.getFileName());
  TreeLogger branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"" + loc,null);
  String[] typeNames=outer.doFindAdditionalTypesUsingJsni(branch,unit);
  addAdditionalTypes(branch,typeNames);
  typeNames=outer.doFindAdditionalTypesUsingArtificialRescues(branch,unit);
  addAdditionalTypes(branch,typeNames);
  typeNames=outer.doFindAdditionalTypesUsingRebinds(branch,unit);
  addAdditionalTypes(branch,typeNames);
  if (typeNames.length > 0) {
    refreshPackagesFromCompState();
  }
  if (cuds != null) {
    cuds.add(unit);
  }
  jdtProcessNanos+=System.nanoTime() - processBeginNanos;
}"
82083,"/** 
 * Pull in types implicitly referenced through rebind answers.
 */
@Override protected String[] doFindAdditionalTypesUsingRebinds(TreeLogger logger,CompilationUnitDeclaration cud){
  Set<String> dependentTypeNames=new HashSet<String>();
  FindDeferredBindingSitesVisitor v=new FindDeferredBindingSitesVisitor();
  cud.traverse(v,cud.scope);
  Map<String,MessageSendSite> requestedTypes=v.getSites();
  Map<String,String[]> rebindAnswers=new HashMap<String,String[]>();
  boolean doFinish=false;
  for (  Map.Entry<String,MessageSendSite> entry : requestedTypes.entrySet()) {
    String reqType=entry.getKey();
    MessageSendSite site=entry.getValue();
    try {
      String[] resultTypes=rebindPermOracle.getAllPossibleRebindAnswers(logger,reqType);
      rebindAnswers.put(reqType,resultTypes);
      Collections.addAll(dependentTypeNames,resultTypes);
      doFinish=true;
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + reqType + ""String_Node_Str"");
      rebindAnswers.put(reqType,new String[0]);
    }
  }
  for (  MessageSendSite site : v.getRunAsyncSites()) {
    String resultType;
    try {
      resultType=fragmentLoaderCreator.create(logger);
      dependentTypeNames.add(resultType);
      doFinish=true;
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"");
    }
  }
  if (doFinish) {
    try {
      rebindPermOracle.getGeneratorContext().finish(logger);
    }
 catch (    UnableToCompleteException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
  for (  Map.Entry<String,MessageSendSite> entry : requestedTypes.entrySet()) {
    String reqType=entry.getKey();
    MessageSendSite site=entry.getValue();
    String[] resultTypes=rebindAnswers.get(reqType);
    for (    String typeName : resultTypes) {
      checkRebindResultInstantiable(site,typeName);
    }
  }
  return dependentTypeNames.toArray(new String[dependentTypeNames.size()]);
}","/** 
 * Pull in types implicitly referenced through rebind answers.
 */
@Override protected String[] doFindAdditionalTypesUsingRebinds(TreeLogger logger,CompilationUnitDeclaration cud){
  Set<String> dependentTypeNames=new LinkedHashSet<String>();
  FindDeferredBindingSitesVisitor v=new FindDeferredBindingSitesVisitor();
  cud.traverse(v,cud.scope);
  Map<String,MessageSendSite> requestedTypes=v.getSites();
  Map<String,String[]> rebindAnswers=new HashMap<String,String[]>();
  boolean doFinish=false;
  for (  Map.Entry<String,MessageSendSite> entry : requestedTypes.entrySet()) {
    String reqType=entry.getKey();
    MessageSendSite site=entry.getValue();
    try {
      String[] resultTypes=rebindPermOracle.getAllPossibleRebindAnswers(logger,reqType);
      rebindAnswers.put(reqType,resultTypes);
      Collections.addAll(dependentTypeNames,resultTypes);
      doFinish=true;
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + reqType + ""String_Node_Str"");
      rebindAnswers.put(reqType,new String[0]);
    }
  }
  for (  MessageSendSite site : v.getRunAsyncSites()) {
    String resultType;
    try {
      resultType=fragmentLoaderCreator.create(logger);
      dependentTypeNames.add(resultType);
      doFinish=true;
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"");
    }
  }
  if (doFinish) {
    try {
      rebindPermOracle.getGeneratorContext().finish(logger);
    }
 catch (    UnableToCompleteException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
  for (  Map.Entry<String,MessageSendSite> entry : requestedTypes.entrySet()) {
    String reqType=entry.getKey();
    MessageSendSite site=entry.getValue();
    String[] resultTypes=rebindAnswers.get(reqType);
    for (    String typeName : resultTypes) {
      checkRebindResultInstantiable(site,typeName);
    }
  }
  return dependentTypeNames.toArray(new String[dependentTypeNames.size()]);
}"
82084,"private void setValue(Layer layer,String prop,double value,Unit unit,boolean vertical,boolean noNegative){
switch (unit) {
case PX:
case PCT:
    break;
default :
  value=value * (int)getUnitSizeInPixels(layer.container,unit,vertical);
unit=Unit.PX;
break;
}
if (noNegative) {
if (value < 0) {
value=0;
}
}
layer.getContainerElement().getStyle().setProperty(prop,value,unit);
}","private void setValue(Layer layer,String prop,double value,Unit unit,boolean vertical,boolean noNegative){
switch (unit) {
case PX:
case PCT:
    break;
default :
  value=value * getUnitSizeInPixels(layer.container,unit,vertical);
unit=Unit.PX;
break;
}
if (noNegative) {
if (value < 0) {
value=0;
}
}
layer.getContainerElement().getStyle().setProperty(prop,(int)(value + 0.5),unit);
}"
82085,"/** 
 * Get the columns displayed in the expense table.
 */
private Collection<Property<?>> getExpenseColumns(){
  List<Property<?>> columns=new ArrayList<Property<?>>();
  columns.add(ExpenseRecord.amount);
  columns.add(ExpenseRecord.approval);
  columns.add(ExpenseRecord.category);
  columns.add(ExpenseRecord.created);
  columns.add(ExpenseRecord.description);
  columns.add(ExpenseRecord.reasonDenied);
  return columns;
}","/** 
 * Get the columns displayed in the expense table.
 */
private String[] getExpenseColumns(){
  return new String[]{ExpenseRecord.amount.getName(),ExpenseRecord.approval.getName(),ExpenseRecord.category.getName(),ExpenseRecord.created.getName(),ExpenseRecord.description.getName(),ExpenseRecord.reasonDenied.getName()};
}"
82086,"/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  lastReceiver=new Receiver<List<ExpenseRecord>>(){
    public void onSuccess(    List<ExpenseRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        List<ExpenseRecord> list=new ArrayList<ExpenseRecord>(newValues);
        sortExpenses(list,lastComparator);
        items.setList(list);
        refreshCost();
        boolean isInitialData=knownExpenseKeys == null;
        if (knownExpenseKeys == null) {
          knownExpenseKeys=new HashMap<Object,ExpenseRecord>();
        }
        for (        ExpenseRecord value : newValues) {
          Object key=items.getKey(value);
          if (!isInitialData) {
            ExpenseRecord existing=knownExpenseKeys.get(key);
            if (existing == null || !value.getAmount().equals(existing.getAmount()) || !value.getDescription().equals(existing.getDescription()) || !value.getCategory().equals(existing.getCategory())) {
              (new PhaseAnimation.CellTablePhaseAnimation<ExpenseRecord>(table,value,items)).run();
            }
          }
          knownExpenseKeys.put(key,value);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  expensesRequestFactory.expenseRequest().findExpensesByReport(report.getRef(Record.id)).forProperties(getExpenseColumns()).fire(lastReceiver);
}","/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  lastReceiver=new Receiver<List<ExpenseRecord>>(){
    public void onSuccess(    List<ExpenseRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        List<ExpenseRecord> list=new ArrayList<ExpenseRecord>(newValues);
        sortExpenses(list,lastComparator);
        items.setList(list);
        refreshCost();
        boolean isInitialData=knownExpenseKeys == null;
        if (knownExpenseKeys == null) {
          knownExpenseKeys=new HashMap<Object,ExpenseRecord>();
        }
        for (        ExpenseRecord value : newValues) {
          Object key=items.getKey(value);
          if (!isInitialData) {
            ExpenseRecord existing=knownExpenseKeys.get(key);
            if (existing == null || !value.getAmount().equals(existing.getAmount()) || !value.getDescription().equals(existing.getDescription()) || !value.getCategory().equals(existing.getCategory())) {
              (new PhaseAnimation.CellTablePhaseAnimation<ExpenseRecord>(table,value,items)).run();
            }
          }
          knownExpenseKeys.put(key,value);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  expensesRequestFactory.expenseRequest().findExpensesByReport(report.getRef(Record.id)).with(getExpenseColumns()).fire(lastReceiver);
}"
82087,"public void onReportChanged(ReportRecordChanged event){
  ReportRecord changed=event.getRecord();
  if (report != null && report.getId().equals(changed.getId())) {
    report=changed;
    setNotesEditState(false,false,changed.getNotes());
  }
}","public void onReportChanged(ReportRecordChanged event){
  ReportRecord changed=event.getRecord();
  if (report != null && report.getId().equals(changed.getId())) {
    expensesRequestFactory.reportRequest().findReport(report.getRef(ReportRecord.id)).with(ReportRecord.notes.getName()).fire(new Receiver<ReportRecord>(){
      @Override public void onSuccess(      ReportRecord response,      Set<SyncResult> syncResults){
        report=response;
        setNotesEditState(false,false,response.getNotes());
      }
    }
);
  }
}"
82088,"public ExpenseList(){
  reports.setKeyProvider(Expenses.REPORT_RECORD_KEY_PROVIDER);
  reportColumns=new ArrayList<Property<?>>();
  reportColumns.add(ReportRecord.created);
  reportColumns.add(ReportRecord.purpose);
  reportColumns.add(ReportRecord.notes);
  createTable();
  searchBox=new DefaultTextBox(""String_Node_Str"");
  initWidget(uiBinder.createAndBindUi(this));
  reports.addDataDisplay(table);
  searchBox.addKeyUpHandler(new KeyUpHandler(){
    public void onKeyUp(    KeyUpEvent event){
      if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
        search();
        return;
      }
      String text=searchBox.getText();
      if (text.length() > 0) {
        searchRegExp=RegExp.compile(""String_Node_Str"" + text + ""String_Node_Str"",""String_Node_Str"");
      }
 else {
        searchRegExp=null;
      }
      table.redraw();
    }
  }
);
  searchButton.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      search();
    }
  }
);
}","public ExpenseList(){
  reports.setKeyProvider(Expenses.REPORT_RECORD_KEY_PROVIDER);
  createTable();
  searchBox=new DefaultTextBox(""String_Node_Str"");
  initWidget(uiBinder.createAndBindUi(this));
  reports.addDataDisplay(table);
  searchBox.addKeyUpHandler(new KeyUpHandler(){
    public void onKeyUp(    KeyUpEvent event){
      if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
        search();
        return;
      }
      String text=searchBox.getText();
      if (text.length() > 0) {
        searchRegExp=RegExp.compile(""String_Node_Str"" + text + ""String_Node_Str"",""String_Node_Str"");
      }
 else {
        searchRegExp=null;
      }
      table.redraw();
    }
  }
);
  searchButton.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      search();
    }
  }
);
}"
82089,"/** 
 * Send a request for reports in the current range.
 * @param isPolling true if this request is caused by polling
 */
private void requestReports(boolean isPolling){
  refreshTimer.cancel();
  if (requestFactory == null) {
    return;
  }
  if (!isPolling) {
    knownReportKeys=null;
  }
  String startsWith=startsWithSearch;
  if (startsWith == null || searchBox.getDefaultText().equals(startsWith)) {
    startsWith=""String_Node_Str"";
  }
  Range range=table.getVisibleRange();
  Long employeeId=employee == null ? -1 : new Long(employee.getId());
  String dept=department == null ? ""String_Node_Str"" : department;
  if (startsWith.length() > 0) {
    for (    SortableHeader header : allHeaders) {
      header.setSorted(false);
      header.setReverseSort(false);
    }
    table.redrawHeaders();
  }
  if (isCountStale) {
    isCountStale=false;
    if (!isPolling) {
      pager.startLoading();
    }
    lastDataSizeReceiver=new Receiver<Long>(){
      public void onSuccess(      Long response,      Set<SyncResult> syncResults){
        if (this == lastDataSizeReceiver) {
          int count=response.intValue();
          reports.updateRowCount(count,count != 1000);
        }
      }
    }
;
    requestFactory.reportRequest().countReportsBySearch(employeeId,dept,startsWith).fire(lastDataSizeReceiver);
  }
  lastDataReceiver=new Receiver<List<ReportRecord>>(){
    public void onSuccess(    List<ReportRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastDataReceiver) {
        int size=newValues.size();
        if (size < table.getPageSize()) {
          reports.updateRowCount(table.getPageStart() + size,true);
        }
        if (size > 0) {
          reports.updateRowData(table.getPageStart(),newValues);
        }
        boolean isInitialData=knownReportKeys == null;
        if (knownReportKeys == null) {
          knownReportKeys=new HashSet<Object>();
        }
        for (        ReportRecord value : newValues) {
          Object key=reports.getKey(value);
          if (!isInitialData && !knownReportKeys.contains(key)) {
            (new PhaseAnimation.CellTablePhaseAnimation<ReportRecord>(table,value,reports)).run();
          }
          knownReportKeys.add(key);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employeeId,dept,startsWith,orderBy,range.getStart(),range.getLength()).forProperties(reportColumns).fire(lastDataReceiver);
}","/** 
 * Send a request for reports in the current range.
 * @param isPolling true if this request is caused by polling
 */
private void requestReports(boolean isPolling){
  refreshTimer.cancel();
  if (requestFactory == null) {
    return;
  }
  if (!isPolling) {
    knownReportKeys=null;
  }
  String startsWith=startsWithSearch;
  if (startsWith == null || searchBox.getDefaultText().equals(startsWith)) {
    startsWith=""String_Node_Str"";
  }
  Range range=table.getVisibleRange();
  Long employeeId=employee == null ? -1 : new Long(employee.getId());
  String dept=department == null ? ""String_Node_Str"" : department;
  if (startsWith.length() > 0) {
    for (    SortableHeader header : allHeaders) {
      header.setSorted(false);
      header.setReverseSort(false);
    }
    table.redrawHeaders();
  }
  if (isCountStale) {
    isCountStale=false;
    if (!isPolling) {
      pager.startLoading();
    }
    lastDataSizeReceiver=new Receiver<Long>(){
      public void onSuccess(      Long response,      Set<SyncResult> syncResults){
        if (this == lastDataSizeReceiver) {
          int count=response.intValue();
          reports.updateRowCount(count,count != 1000);
        }
      }
    }
;
    requestFactory.reportRequest().countReportsBySearch(employeeId,dept,startsWith).fire(lastDataSizeReceiver);
  }
  lastDataReceiver=new Receiver<List<ReportRecord>>(){
    public void onSuccess(    List<ReportRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastDataReceiver) {
        int size=newValues.size();
        if (size < table.getPageSize()) {
          reports.updateRowCount(table.getPageStart() + size,true);
        }
        if (size > 0) {
          reports.updateRowData(table.getPageStart(),newValues);
        }
        boolean isInitialData=knownReportKeys == null;
        if (knownReportKeys == null) {
          knownReportKeys=new HashSet<Object>();
        }
        for (        ReportRecord value : newValues) {
          Object key=reports.getKey(value);
          if (!isInitialData && !knownReportKeys.contains(key)) {
            (new PhaseAnimation.CellTablePhaseAnimation<ReportRecord>(table,value,reports)).run();
          }
          knownReportKeys.add(key);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employeeId,dept,startsWith,orderBy,range.getStart(),range.getLength()).with(reportColumns).fire(lastDataReceiver);
}"
82090,"@Override protected void onRangeChanged(HasData<EmployeeRecord> view){
  Range range=view.getVisibleRange();
  requestFactory.employeeRequest().findEmployeeEntriesByDepartment(department,range.getStart(),range.getLength()).forProperties(getEmployeeMenuProperties()).fire(this);
}","@Override protected void onRangeChanged(HasData<EmployeeRecord> view){
  Range range=view.getVisibleRange();
  requestFactory.employeeRequest().findEmployeeEntriesByDepartment(department,range.getStart(),range.getLength()).with(getEmployeeMenuProperties()).fire(this);
}"
82091,"public boolean isLeaf(Object value){
  return !isDepartment(value) || isAllDepartment(value);
}","public boolean isLeaf(Object value){
  return value != null && (!isDepartment(value) || isAllDepartment(value));
}"
82092,"private Collection<Property<?>> getEmployeeMenuProperties(){
  List<Property<?>> columns=new ArrayList<Property<?>>();
  columns.add(EmployeeRecord.displayName);
  columns.add(EmployeeRecord.userName);
  return columns;
}","private String[] getEmployeeMenuProperties(){
  return new String[]{EmployeeRecord.displayName.getName(),EmployeeRecord.userName.getName()};
}"
82093,"/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  long employeeId=1;
  try {
    String value=Window.Location.getParameter(EMPLOYEE_ID_PARAM);
    if (value != null && value.length() > 0) {
      employeeId=Long.parseLong(value);
    }
  }
 catch (  NumberFormatException e) {
    RootPanel.get().add(new Label(""String_Node_Str""));
    return;
  }
  final HandlerManager eventBus=new HandlerManager(null);
  final ExpensesRequestFactory requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  final long finalEmployeeId=employeeId;
  requestFactory.employeeRequest().findEmployee(Value.of(employeeId)).fire(new Receiver<EmployeeRecord>(){
    public void onSuccess(    EmployeeRecord employee,    Set<SyncResult> syncResults){
      final ExpensesMobileShell shell=new ExpensesMobileShell(eventBus,requestFactory,employee);
      RootPanel.get().add(shell);
      eventBus.addHandler(RequestEvent.TYPE,new AuthenticationFailureHandler());
      final LoginWidget login=shell.getLoginWidget();
      Receiver<UserInformationRecord> receiver=new Receiver<UserInformationRecord>(){
        public void onSuccess(        UserInformationRecord userInformationRecord,        Set<SyncResult> syncResults){
          login.setUserInformation(userInformationRecord);
        }
      }
;
      requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
    }
  }
);
}","/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  long employeeId=1;
  try {
    String value=Window.Location.getParameter(EMPLOYEE_ID_PARAM);
    if (value != null && value.length() > 0) {
      employeeId=Long.parseLong(value);
    }
  }
 catch (  NumberFormatException e) {
    RootPanel.get().add(new Label(""String_Node_Str""));
    return;
  }
  final HandlerManager eventBus=new HandlerManager(null);
  final ExpensesRequestFactory requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  requestFactory.employeeRequest().findEmployee(Value.of(employeeId)).fire(new Receiver<EmployeeRecord>(){
    public void onSuccess(    EmployeeRecord employee,    Set<SyncResult> syncResults){
      final ExpensesMobileShell shell=new ExpensesMobileShell(eventBus,requestFactory,employee);
      RootPanel.get().add(shell);
      eventBus.addHandler(RequestEvent.TYPE,new AuthenticationFailureHandler());
      final LoginWidget login=shell.getLoginWidget();
      Receiver<UserInformationRecord> receiver=new Receiver<UserInformationRecord>(){
        public void onSuccess(        UserInformationRecord userInformationRecord,        Set<SyncResult> syncResults){
          login.setUserInformation(userInformationRecord);
        }
      }
;
      requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
    }
  }
);
}"
82094,"public void create(ReportRecord report){
  expense=(ExpenseRecord)requestFactory.create(ExpenseRecord.class);
  requestObject=requestFactory.expenseRequest().persist(expense);
  ExpenseRecord editableExpense=requestObject.edit(expense);
  editableExpense.setReport(report);
  displayExpense();
}","public void create(ReportRecord report){
  expense=requestFactory.create(ExpenseRecord.class);
  requestObject=requestFactory.expenseRequest().persist(expense);
  ExpenseRecord editableExpense=requestObject.edit(expense);
  editableExpense.setReport(report);
  displayExpense();
}"
82095,"private Collection<Property<?>> getExpenseColumns(){
  List<Property<?>> columns=new ArrayList<Property<?>>();
  columns.add(ExpenseRecord.description);
  columns.add(ExpenseRecord.amount);
  return columns;
}","private String[] getExpenseColumns(){
  return new String[]{ExpenseRecord.description.getName(),ExpenseRecord.amount.getName()};
}"
82096,"/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  if (requestFactory == null || report == null) {
    return;
  }
  lastReceiver=new Receiver<List<ExpenseRecord>>(){
    public void onSuccess(    List<ExpenseRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        int size=newValues.size();
        expenseDataProvider.updateRowCount(size,true);
        expenseDataProvider.updateRowData(0,newValues);
        boolean isInitialData=knownDeniedKeys == null;
        if (knownDeniedKeys == null) {
          knownDeniedKeys=new HashSet<Object>();
        }
        for (        ExpenseRecord value : newValues) {
          Object key=expenseDataProvider.getKey(value);
          String approval=value.getApproval();
          if (Expenses.Approval.DENIED.getText().equals(approval)) {
            if (!isInitialData && !knownDeniedKeys.contains(key)) {
              (new PhaseAnimation.CellListPhaseAnimation<ExpenseRecord>(expenseList,value,expenseDataProvider)).run();
            }
            knownDeniedKeys.add(key);
          }
 else {
            knownDeniedKeys.remove(key);
          }
        }
        refreshTimer.schedule(REFRESH_INTERVAL);
      }
    }
  }
;
  requestFactory.expenseRequest().findExpensesByReport(report.getRef(ReportRecord.id)).forProperties(getExpenseColumns()).fire(lastReceiver);
}","/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  if (requestFactory == null || report == null) {
    return;
  }
  lastReceiver=new Receiver<List<ExpenseRecord>>(){
    public void onSuccess(    List<ExpenseRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        int size=newValues.size();
        expenseDataProvider.updateRowCount(size,true);
        expenseDataProvider.updateRowData(0,newValues);
        boolean isInitialData=knownDeniedKeys == null;
        if (knownDeniedKeys == null) {
          knownDeniedKeys=new HashSet<Object>();
        }
        for (        ExpenseRecord value : newValues) {
          Object key=expenseDataProvider.getKey(value);
          String approval=value.getApproval();
          if (Expenses.Approval.DENIED.getText().equals(approval)) {
            if (!isInitialData && !knownDeniedKeys.contains(key)) {
              (new PhaseAnimation.CellListPhaseAnimation<ExpenseRecord>(expenseList,value,expenseDataProvider)).run();
            }
            knownDeniedKeys.add(key);
          }
 else {
            knownDeniedKeys.remove(key);
          }
        }
        refreshTimer.schedule(REFRESH_INTERVAL);
      }
    }
  }
;
  requestFactory.expenseRequest().findExpensesByReport(report.getRef(ReportRecord.id)).with(getExpenseColumns()).fire(lastReceiver);
}"
82097,"public void create(EmployeeRecord reporter){
  report=(ReportRecord)requestFactory.create(ReportRecord.class);
  requestObject=requestFactory.reportRequest().persist(report);
  ReportRecord editableReport=requestObject.edit(report);
  editableReport.setReporter(reporter);
  displayReport();
}","public void create(EmployeeRecord reporter){
  report=requestFactory.create(ReportRecord.class);
  requestObject=requestFactory.reportRequest().persist(report);
  ReportRecord editableReport=requestObject.edit(report);
  editableReport.setReporter(reporter);
  displayReport();
}"
82098,"private void requestReports(){
  if (requestFactory == null) {
    return;
  }
  lastReceiver=new Receiver<List<ReportRecord>>(){
    public void onSuccess(    List<ReportRecord> newValues,    Set<SyncResult> syncResults){
      int size=newValues.size();
      reportDataProvider.updateRowCount(size,true);
      reportDataProvider.updateRowData(0,newValues);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employee.getId(),""String_Node_Str"",""String_Node_Str"",ReportRecord.created.getName() + ""String_Node_Str"",0,25).forProperties(getReportColumns()).fire(lastReceiver);
}","private void requestReports(){
  if (requestFactory == null) {
    return;
  }
  lastReceiver=new Receiver<List<ReportRecord>>(){
    public void onSuccess(    List<ReportRecord> newValues,    Set<SyncResult> syncResults){
      int size=newValues.size();
      reportDataProvider.updateRowCount(size,true);
      reportDataProvider.updateRowData(0,newValues);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employee.getId(),""String_Node_Str"",""String_Node_Str"",ReportRecord.created.getName() + ""String_Node_Str"",0,25).with(getReportColumns()).fire(lastReceiver);
}"
82099,"private Collection<Property<?>> getReportColumns(){
  List<Property<?>> columns=new ArrayList<Property<?>>();
  columns.add(ReportRecord.created);
  columns.add(ReportRecord.purpose);
  return columns;
}","private String[] getReportColumns(){
  return new String[]{ReportRecord.created.getName(),ReportRecord.purpose.getName()};
}"
82100,"/** 
 * Create an instance with the given default value.
 * @param the value that will be returned by {@link #process} if{@link #setResult} is not called.
 */
public ExpensesEntityTypesProcessor(T defaultValue){
  this.defaultValue=defaultValue;
}","/** 
 * Create an instance with the given default value.
 * @param defaultValue the value that will be returned by {@link #process} if{@link #setResult} is not called.
 */
public ExpensesEntityTypesProcessor(T defaultValue){
  this.defaultValue=defaultValue;
}"
82101,"@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  if (resolveChanges()) {
    SelectionChangeEvent.fire(this);
  }
}","@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  resolveChanges();
}"
82102,"private boolean resolveChanges(){
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    boolean defaultSelected=isDefaultSelected(object);
    Object key=getKey(object);
    Boolean previousException=exceptions.get(key);
    if (defaultSelected == selected) {
      if (previousException != null) {
        exceptions.remove(key);
        changed=true;
      }
    }
 else {
      if (previousException != Boolean.valueOf(selected)) {
        exceptions.put(key,selected);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  return changed;
}","private void resolveChanges(){
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    boolean defaultSelected=isDefaultSelected(object);
    Object key=getKey(object);
    Boolean previousException=exceptions.get(key);
    if (defaultSelected == selected) {
      if (previousException != null) {
        exceptions.remove(key);
        changed=true;
      }
    }
 else {
      if (previousException != Boolean.valueOf(selected)) {
        exceptions.put(key,selected);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}"
82103,"@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  if (resolveChanges()) {
    SelectionChangeEvent.fire(this);
  }
}","@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  resolveChanges();
}"
82104,"private boolean resolveChanges(){
  if (selectionChanges.isEmpty()) {
    return false;
  }
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    Object key=getKey(object);
    T oldValue=selectedSet.get(key);
    if (selected) {
      if (oldValue == null || !oldValue.equals(object)) {
        selectedSet.put(getKey(object),object);
        changed=true;
      }
    }
 else {
      if (oldValue != null) {
        selectedSet.remove(key);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  return changed;
}","private void resolveChanges(){
  if (selectionChanges.isEmpty()) {
    return;
  }
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    Object key=getKey(object);
    T oldValue=selectedSet.get(key);
    if (selected) {
      if (oldValue == null || !oldValue.equals(object)) {
        selectedSet.put(getKey(object),object);
        changed=true;
      }
    }
 else {
      if (oldValue != null) {
        selectedSet.remove(key);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}"
82105,"@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  if (resolveChanges()) {
    SelectionChangeEvent.fire(this);
  }
}","@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  resolveChanges();
}"
82106,"private boolean resolveChanges(){
  if (newSelectedObject == null) {
    return false;
  }
  Object key=getKey(newSelectedObject);
  boolean sameKey=curKey == null ? key == null : curKey.equals(key);
  boolean changed=false;
  if (newSelected) {
    changed=!sameKey;
    curSelection=newSelectedObject;
    curKey=key;
  }
 else   if (sameKey) {
    changed=true;
    curSelection=null;
    curKey=null;
  }
  newSelectedObject=null;
  return changed;
}","private void resolveChanges(){
  if (newSelectedObject == null) {
    return;
  }
  Object key=getKey(newSelectedObject);
  boolean sameKey=curKey == null ? key == null : curKey.equals(key);
  boolean changed=false;
  if (newSelected) {
    changed=!sameKey;
    curSelection=newSelectedObject;
    curKey=key;
  }
 else   if (sameKey) {
    changed=true;
    curSelection=null;
    curKey=null;
  }
  newSelectedObject=null;
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}"
82107,"public void setSelected(T object,boolean selected){
}","public void setSelected(T object,boolean selected){
  scheduleSelectionChangeEvent();
}"
82108,"public void testLoadModuleMessage() throws IOException, BrowserChannelException {
  String url=""String_Node_Str"";
  String sessionKey=""String_Node_Str"";
  String tabKey=""String_Node_Str"";
  String moduleName=""String_Node_Str"";
  String userAgent=""String_Node_Str"";
  new LoadModuleMessage(channel,url,tabKey,sessionKey,moduleName,userAgent).send();
  MessageType type=channel.readMessageType();
  assertEquals(MessageType.LOAD_MODULE,type);
  LoadModuleMessage message=LoadModuleMessage.receive(channel);
  assertEquals(url,message.getUrl());
  assertEquals(tabKey,message.getTabKey());
  assertEquals(sessionKey,message.getSessionKey());
  assertEquals(moduleName,message.getModuleName());
  assertEquals(userAgent,message.getUserAgent());
  url=""String_Node_Str"";
  sessionKey=""String_Node_Str"";
  tabKey=""String_Node_Str"";
  moduleName=""String_Node_Str"";
  userAgent=""String_Node_Str"";
  new LoadModuleMessage(channel,url,tabKey,sessionKey,moduleName,userAgent).send();
  type=channel.readMessageType();
  assertEquals(MessageType.LOAD_MODULE,type);
  message=LoadModuleMessage.receive(channel);
  assertEquals(url,message.getUrl());
  assertEquals(tabKey,message.getTabKey());
  assertEquals(sessionKey,message.getSessionKey());
  assertEquals(moduleName,message.getModuleName());
  assertEquals(userAgent,message.getUserAgent());
  TemporaryBufferStream tempBufferStream=new TemporaryBufferStream();
  TestBrowserChannel trashableChannel=new TestBrowserChannel(tempBufferStream.getInputStream(),tempBufferStream.getOutputStream());
  try {
    new LoadModuleMessage(trashableChannel,null,tabKey,sessionKey,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,null,sessionKey,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,null,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,sessionKey,null,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,sessionKey,moduleName,null).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
}","public void testLoadModuleMessage() throws IOException, BrowserChannelException {
  String url=""String_Node_Str"";
  String sessionKey=""String_Node_Str"";
  String tabKey=""String_Node_Str"";
  String moduleName=""String_Node_Str"";
  String userAgent=""String_Node_Str"";
  new LoadModuleMessage(channel,url,tabKey,sessionKey,moduleName,userAgent).send();
  MessageType type=channel.readMessageType();
  assertEquals(MessageType.LOAD_MODULE,type);
  LoadModuleMessage message=LoadModuleMessage.receive(channel);
  assertEquals(url,message.getUrl());
  assertEquals(tabKey,message.getTabKey());
  assertEquals(sessionKey,message.getSessionKey());
  assertEquals(moduleName,message.getModuleName());
  assertEquals(userAgent,message.getUserAgent());
  url=""String_Node_Str"";
  sessionKey=""String_Node_Str"";
  tabKey=""String_Node_Str"";
  moduleName=""String_Node_Str"";
  userAgent=""String_Node_Str"";
  new LoadModuleMessage(channel,url,tabKey,sessionKey,moduleName,userAgent).send();
  type=channel.readMessageType();
  assertEquals(MessageType.LOAD_MODULE,type);
  message=LoadModuleMessage.receive(channel);
  assertEquals(url,message.getUrl());
  assertEquals(tabKey,message.getTabKey());
  assertEquals(sessionKey,message.getSessionKey());
  assertEquals(moduleName,message.getModuleName());
  assertEquals(userAgent,message.getUserAgent());
  TemporaryBufferStream tempBufferStream=new TemporaryBufferStream();
  TestBrowserChannel trashableChannel=new TestBrowserChannel(tempBufferStream.getInputStream(),tempBufferStream.getOutputStream());
  try {
    new LoadModuleMessage(trashableChannel,null,tabKey,sessionKey,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,null,sessionKey,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,null,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,sessionKey,null,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,sessionKey,moduleName,null).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
}"
82109,"public void computeTypeCastabilityMaps(){
  computeSourceType(program.getTypeJavaLangString());
  assert(castableTypeMaps.size() == 3);
  for (  JReferenceType type : program.getDeclaredTypes()) {
    if (type instanceof JClassType) {
      computeSourceType(type);
    }
  }
  for (  JArrayType type : program.getAllArrayTypes()) {
    computeSourceType(type);
  }
  program.initTypeInfo(castableTypeMaps);
  JClassType jsoType=program.getJavaScriptObject();
  if (jsoType != null) {
    queryIds.put(jsoType,-1);
  }
  program.recordQueryIds(queryIds);
}","public void computeTypeCastabilityMaps(){
  computeSourceType(program.getTypeJavaLangString());
  assert(castableTypeMaps.size() == 2);
  for (  JReferenceType type : program.getDeclaredTypes()) {
    if (type instanceof JClassType) {
      computeSourceType(type);
    }
  }
  for (  JArrayType type : program.getAllArrayTypes()) {
    computeSourceType(type);
  }
  program.initTypeInfo(castableTypeMaps);
  JClassType jsoType=program.getJavaScriptObject();
  if (jsoType != null) {
    queryIds.put(jsoType,-1);
  }
  program.recordQueryIds(queryIds);
}"
82110,"public Object encodePropertyValue(Object value){
  if (value == null) {
    return value;
  }
  Class<?> type=value.getClass();
  if (Boolean.class == type) {
    return value;
  }
  if (Date.class == type) {
    return String.valueOf(((Date)value).getTime());
  }
  if (Enum.class.isAssignableFrom(type)) {
    return Double.valueOf(((Enum<?>)value).ordinal());
  }
  if (BigDecimal.class == type || BigInteger.class == type || Long.class == type) {
    return String.valueOf(value);
  }
  if (Number.class.isAssignableFrom(type)) {
    return ((Number)value).doubleValue();
  }
  return String.valueOf(value);
}","public Object encodePropertyValue(Object value){
  if (value == null) {
    return value;
  }
  Class<?> type=value.getClass();
  if (Boolean.class == type) {
    return value;
  }
  if (Date.class.isAssignableFrom(type)) {
    return String.valueOf(((Date)value).getTime());
  }
  if (Enum.class.isAssignableFrom(type)) {
    return Double.valueOf(((Enum<?>)value).ordinal());
  }
  if (BigDecimal.class == type || BigInteger.class == type || Long.class == type) {
    return String.valueOf(value);
  }
  if (Number.class.isAssignableFrom(type)) {
    return ((Number)value).doubleValue();
  }
  return String.valueOf(value);
}"
82111,"/** 
 * Flush pending list changes to the displays. By default,
 */
private void flushNow(){
  if (flushPending) {
    flushCancelled=true;
  }
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateRowCount(curSize,true);
  }
  if (modified) {
    updateRowData(minModified,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
}","/** 
 * Flush pending list changes to the displays. By default,
 */
private void flushNow(){
  if (flushPending) {
    flushCancelled=true;
  }
  if (listWrapper != this) {
    return;
  }
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateRowCount(curSize,true);
  }
  if (modified) {
    updateRowData(minModified,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
}"
82112,"public void testSetList(){
  ListDataProvider<String> provider=createListDataProvider(10);
  MockHasData<String> display=new MockHasData<String>();
  display.setVisibleRange(0,15);
  provider.addDataDisplay(display);
  provider.flush();
  display.clearLastRowDataAndRange();
  assertEquals(""String_Node_Str"",provider.getList().get(0));
  List<String> replace=new ArrayList<String>();
  replace.add(""String_Node_Str"");
  provider.setList(replace);
  assertEquals(""String_Node_Str"",provider.getList().get(0));
  assertEquals(1,display.getRowCount());
  assertEquals(replace,display.getLastRowData());
  assertEquals(new Range(0,1),display.getLastRowDataRange());
}","public void testSetList(){
  ListDataProvider<String> provider=createListDataProvider(10);
  final MockHasData<String> display=new MockHasData<String>();
  display.setVisibleRange(0,15);
  provider.addDataDisplay(display);
  provider.flush();
  display.clearLastRowDataAndRange();
  List<String> oldList=provider.getList();
  assertEquals(""String_Node_Str"",oldList.get(0));
  List<String> replace=new ArrayList<String>();
  replace.add(""String_Node_Str"");
  provider.setList(replace);
  assertEquals(""String_Node_Str"",provider.getList().get(0));
  assertEquals(1,display.getRowCount());
  assertEquals(replace,display.getLastRowData());
  assertEquals(new Range(0,1),display.getLastRowDataRange());
  display.clearLastRowDataAndRange();
  oldList.set(0,""String_Node_Str"");
  delayTestFinish(2000);
  Scheduler.get().scheduleDeferred(new ScheduledCommand(){
    public void execute(){
      assertNull(display.getLastRowData());
      finishTest();
    }
  }
);
}"
82113,"String toJson(){
  if (operations.size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return toJsonWithoutChecks();
}","String toJson(){
}"
82114,"public void testSeparateIds(){
  RecordImpl createRecord=(RecordImpl)requestFactory.create(SimpleFooRecord.class);
  assertTrue(createRecord.isFuture());
  Long futureId=createRecord.getId();
  RecordImpl mockRecord=new RecordImpl(RecordJsoImpl.create(futureId,1,SimpleFooRecordImpl.SCHEMA),RequestFactoryJsonImpl.NOT_FUTURE);
  valueStore.setRecord(mockRecord.asJso(),requestFactory);
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.set(SimpleFooRecord.userName,createRecord,""String_Node_Str"");
  deltaValueStore.set(SimpleFooRecord.userName,mockRecord,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  String jsonString=deltaValueStore.toJsonWithoutChecks();
  JSONObject jsonObject=(JSONObject)JSONParser.parse(jsonString);
  assertFalse(jsonObject.containsKey(WriteOperation.DELETE.name()));
  assertTrue(jsonObject.containsKey(WriteOperation.CREATE.name()));
  assertTrue(jsonObject.containsKey(WriteOperation.UPDATE.name()));
  JSONArray createOperationArray=jsonObject.get(WriteOperation.CREATE.name()).isArray();
  assertEquals(1,createOperationArray.size());
  assertEquals(""String_Node_Str"",createOperationArray.get(0).isObject().get(SimpleFooRecord.class.getName()).isObject().get(SimpleFooRecord.userName.getName()).isString().stringValue());
  JSONArray updateOperationArray=jsonObject.get(WriteOperation.UPDATE.name()).isArray();
  assertEquals(1,updateOperationArray.size());
  assertEquals(""String_Node_Str"",updateOperationArray.get(0).isObject().get(SimpleFooRecord.class.getName()).isObject().get(SimpleFooRecord.userName.getName()).isString().stringValue());
}","public void testSeparateIds(){
  RecordImpl createRecord=(RecordImpl)requestFactory.create(SimpleFooRecord.class);
  assertTrue(createRecord.isFuture());
  Long futureId=createRecord.getId();
  RecordImpl mockRecord=new RecordImpl(RecordJsoImpl.create(futureId,1,SimpleFooRecordImpl.SCHEMA),RequestFactoryJsonImpl.NOT_FUTURE);
  valueStore.setRecord(mockRecord.asJso(),requestFactory);
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.set(SimpleFooRecord.userName,createRecord,""String_Node_Str"");
  deltaValueStore.set(SimpleFooRecord.userName,mockRecord,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  String jsonString=deltaValueStore.toJson();
  JSONObject jsonObject=(JSONObject)JSONParser.parse(jsonString);
  assertFalse(jsonObject.containsKey(WriteOperation.DELETE.name()));
  assertTrue(jsonObject.containsKey(WriteOperation.CREATE.name()));
  assertTrue(jsonObject.containsKey(WriteOperation.UPDATE.name()));
  JSONArray createOperationArray=jsonObject.get(WriteOperation.CREATE.name()).isArray();
  assertEquals(1,createOperationArray.size());
  assertEquals(""String_Node_Str"",createOperationArray.get(0).isObject().get(SimpleFooRecord.class.getName()).isObject().get(SimpleFooRecord.userName.getName()).isString().stringValue());
  JSONArray updateOperationArray=jsonObject.get(WriteOperation.UPDATE.name()).isArray();
  assertEquals(1,updateOperationArray.size());
  assertEquals(""String_Node_Str"",updateOperationArray.get(0).isObject().get(SimpleFooRecord.class.getName()).isObject().get(SimpleFooRecord.userName.getName()).isString().stringValue());
}"
82115,"public void testCreate(){
  Record created=requestFactory.create(SimpleFooRecord.class);
  assertNotNull(created.getId());
  assertNotNull(created.getVersion());
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  assertFalse(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,created,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.CREATE);
}","public void testCreate(){
  Record created=requestFactory.create(SimpleFooRecord.class);
  assertNotNull(created.getId());
  assertNotNull(created.getVersion());
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  String json=deltaValueStore.toJson();
  testAndGetChangeRecord(json,WriteOperation.CREATE);
}"
82116,"@Override public void gwtSetUp(){
  valueStore=new ValueStoreJsonImpl();
  requestFactory=new RequestFactoryJsonImpl(){
    public Record create(    Class token){
      return create(token,typeMap);
    }
    public RecordSchema getSchema(    String token){
      return typeMap.getType(token);
    }
    @Override public void init(    EventBus eventBus){
    }
    public LoggingRequest loggingRequest(){
      return null;
    }
    public Class<? extends Record> getClass(    String token){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    public Record getProxy(    String token){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    public String getToken(    Class<? extends Record> clazz){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
;
  jso=RecordJsoImpl.fromJson(""String_Node_Str"");
  jso.set(SimpleFooRecord.id,42L);
  jso.set(SimpleFooRecord.version,1);
  jso.set(SimpleFooRecord.userName,""String_Node_Str"");
  jso.set(SimpleFooRecord.password,""String_Node_Str"");
  jso.set(SimpleFooRecord.intId,4);
  jso.set(SimpleFooRecord.created,new Date());
  jso.setSchema(SimpleFooRecordImpl.SCHEMA);
  valueStore.setRecord(jso,requestFactory);
}","@Override public void gwtSetUp(){
  valueStore=new ValueStoreJsonImpl();
  requestFactory=new RequestFactoryJsonImpl(){
    public Record create(    Class token){
      return create(token,typeMap);
    }
    @Override public RecordSchema getSchema(    String token){
      return typeMap.getType(token);
    }
    @Override public void init(    EventBus eventBus){
    }
    public LoggingRequest loggingRequest(){
      return null;
    }
    public Class<? extends Record> getClass(    String token){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    public Record getProxy(    String token){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    public String getToken(    Class<? extends Record> clazz){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
;
  jso=RecordJsoImpl.fromJson(""String_Node_Str"");
  jso.set(SimpleFooRecord.id,42L);
  jso.set(SimpleFooRecord.version,1);
  jso.set(SimpleFooRecord.userName,""String_Node_Str"");
  jso.set(SimpleFooRecord.password,""String_Node_Str"");
  jso.set(SimpleFooRecord.intId,4);
  jso.set(SimpleFooRecord.created,new Date());
  jso.setSchema(SimpleFooRecordImpl.SCHEMA);
  valueStore.setRecord(jso,requestFactory);
}"
82117,"public RecordSchema getSchema(String token){
  return typeMap.getType(token);
}","@Override public RecordSchema getSchema(String token){
  return typeMap.getType(token);
}"
82118,"public void testEndToEndSmartDiff_SomeChange(){
  com.google.gwt.valuestore.server.SimpleFoo.reset();
  try {
    JSONObject foo=fetchVerifyAndGetInitialObject();
    SimpleFoo fooResult=SimpleFoo.getSingleton();
    fooResult.setUserName(""String_Node_Str"");
    fooResult.setIntId(45);
    foo.put(""String_Node_Str"",""String_Node_Str"");
    foo.put(""String_Node_Str"",45);
    Date now=new Date();
    foo.put(""String_Node_Str"",""String_Node_Str"" + now.getTime());
    JSONObject result=getResultFromServer(foo);
    assertTrue(result.getJSONObject(""String_Node_Str"").has(""String_Node_Str""));
    fooResult=SimpleFoo.getSingleton();
    assertEquals((int)45,(int)fooResult.getIntId());
    assertEquals(""String_Node_Str"",fooResult.getUserName());
    assertEquals(now,fooResult.getCreated());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.toString());
  }
}","public void testEndToEndSmartDiff_SomeChange(){
  com.google.gwt.valuestore.server.SimpleFoo.reset();
  try {
    JSONObject foo=fetchVerifyAndGetInitialObject();
    SimpleFoo fooResult=SimpleFoo.getSingleton();
    fooResult.setUserName(""String_Node_Str"");
    fooResult.setIntId(45);
    foo.put(""String_Node_Str"",""String_Node_Str"");
    foo.put(""String_Node_Str"",45);
    Date now=new Date();
    long newTime=now.getTime() + 10000;
    foo.put(""String_Node_Str"",""String_Node_Str"" + newTime);
    JSONObject result=getResultFromServer(foo);
    assertTrue(result.getJSONObject(""String_Node_Str"").has(""String_Node_Str""));
    fooResult=SimpleFoo.getSingleton();
    assertEquals((int)45,(int)fooResult.getIntId());
    assertEquals(""String_Node_Str"",fooResult.getUserName());
    assertEquals(newTime,fooResult.getCreated().getTime());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.toString());
  }
}"
82119,"/** 
 * Handle a keyboard event to move focus away from the current item.
 */
void keyboardExit(){
  if (keyboardSelection == null) {
    return;
  }
  Element child=keyboardSelection.getFirstChildElement().getFirstChildElement();
  child.removeAttribute(""String_Node_Str"");
  child.removeClassName(tree.getStyle().keyboardSelectedItem());
  keyboardSelection=null;
  keyboardSelectedIndex=-1;
  keyboardFocused=false;
}","/** 
 * Handle a keyboard event to move focus away from the current item.
 */
void keyboardExit(){
  if (keyboardSelection == null) {
    return;
  }
  Element child=keyboardSelection.getFirstChildElement().getFirstChildElement();
  child.removeAttribute(""String_Node_Str"");
  child.removeClassName(tree.getStyle().keyboardSelectedItem());
  keyboardSelection=null;
  keyboardFocused=false;
}"
82120,"@SuppressWarnings(""String_Node_Str"") public <P extends Record>P edit(P record){
  P returnRecordImpl=(P)((RecordImpl)record).getSchema().create(((RecordImpl)record).asJso());
  ((RecordImpl)returnRecordImpl).setDeltaValueStore(deltaValueStore);
  return returnRecordImpl;
}","@SuppressWarnings(""String_Node_Str"") public <P extends Record>P edit(P record){
  P returnRecordImpl=(P)((RecordImpl)record).getSchema().create(((RecordImpl)record).asJso(),((RecordImpl)record).isFuture());
  ((RecordImpl)returnRecordImpl).setDeltaValueStore(deltaValueStore);
  return returnRecordImpl;
}"
82121,"public String toJson(){
  used=true;
  if (operations.size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  StringBuffer jsonData=new StringBuffer(""String_Node_Str"");
  for (  WriteOperation writeOperation : WriteOperation.values()) {
    String jsonDataForOperation=getJsonForOperation(writeOperation);
    if (jsonDataForOperation.equals(""String_Node_Str"")) {
      continue;
    }
    if (jsonData.length() > 1) {
      jsonData.append(""String_Node_Str"");
    }
    jsonData.append(jsonDataForOperation);
  }
  jsonData.append(""String_Node_Str"");
  return jsonData.toString();
}","String toJson(){
  if (operations.size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return toJsonWithoutChecks();
}"
82122,"protected RecordKey(Long id,RecordSchema<?> schema){
}","protected RecordKey(Long id,RecordSchema<?> schema,boolean isFuture){
}"
82123,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((id == null) ? 0 : id.hashCode());
  result=prime * result + ((schema == null) ? 0 : schema.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=(isFuture ? 0 : 1);
  result=prime * result + ((id == null) ? 0 : id.hashCode());
  result=prime * result + ((schema == null) ? 0 : schema.hashCode());
  return result;
}"
82124,"@Override public String toString(){
  return ""String_Node_Str"" + schema.getClass().getName() + ""String_Node_Str""+ id+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + schema.getClass().getName() + ""String_Node_Str""+ id+ ""String_Node_Str""+ (isFuture ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"";
}"
82125,"private Record createFuture(RecordSchema<? extends Record> schema){
  Long futureId=futureIdGenerator.getFutureId();
  RecordJsoImpl newRecord=RecordJsoImpl.create(futureId,INITIAL_VERSION,schema);
  RecordKey recordKey=new RecordKey(newRecord);
  creates.put(recordKey,newRecord);
  return schema.create(newRecord);
}","private Record createFuture(RecordSchema<? extends Record> schema){
  Long futureId=++currentFutureId;
  RecordJsoImpl newRecord=RecordJsoImpl.create(futureId,INITIAL_VERSION,schema);
  RecordKey recordKey=new RecordKey(newRecord,IS_FUTURE);
  creates.put(recordKey,newRecord);
  return schema.create(newRecord,IS_FUTURE);
}"
82126,"public void fire(final RequestObject<?> requestObject){
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,GWT.getHostPageBaseURL() + RequestFactory.URL);
  builder.setHeader(""String_Node_Str"",RequestFactory.JSON_CONTENT_TYPE_UTF8);
  builder.setHeader(""String_Node_Str"",Location.getHref());
  builder.setRequestData(ClientRequestHelper.getRequestString(requestObject.getRequestData().getRequestMap(((AbstractRequest)requestObject).deltaValueStore.toJson())));
  builder.setCallback(new RequestCallback(){
    public void onError(    Request request,    Throwable exception){
      postRequestEvent(State.RECEIVED,null);
      wireLogger.log(Level.SEVERE,SERVER_ERROR,exception);
    }
    public void onResponseReceived(    Request request,    Response response){
      wireLogger.finest(""String_Node_Str"");
      if (200 == response.getStatusCode()) {
        String text=response.getText();
        requestObject.handleResponseText(text);
      }
 else       if (Response.SC_UNAUTHORIZED == response.getStatusCode()) {
        wireLogger.finest(""String_Node_Str"");
      }
 else       if (response.getStatusCode() > 0) {
        wireLogger.severe(SERVER_ERROR + ""String_Node_Str"" + response.getStatusCode()+ ""String_Node_Str""+ response.getText());
      }
      postRequestEvent(State.RECEIVED,response);
    }
  }
);
  try {
    wireLogger.finest(""String_Node_Str"");
    builder.send();
    postRequestEvent(State.SENT,null);
  }
 catch (  RequestException e) {
    wireLogger.log(Level.SEVERE,SERVER_ERROR + ""String_Node_Str"" + e.getMessage()+ ""String_Node_Str"",e);
  }
}","public void fire(final RequestObject<?> requestObject){
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,GWT.getHostPageBaseURL() + RequestFactory.URL);
  builder.setHeader(""String_Node_Str"",RequestFactory.JSON_CONTENT_TYPE_UTF8);
  builder.setHeader(""String_Node_Str"",Location.getHref());
  builder.setRequestData(ClientRequestHelper.getRequestString(requestObject.getRequestData().getRequestMap(((AbstractRequest<?,?>)requestObject).deltaValueStore.toJson())));
  builder.setCallback(new RequestCallback(){
    public void onError(    Request request,    Throwable exception){
      postRequestEvent(State.RECEIVED,null);
      wireLogger.log(Level.SEVERE,SERVER_ERROR,exception);
    }
    public void onResponseReceived(    Request request,    Response response){
      wireLogger.finest(""String_Node_Str"");
      if (200 == response.getStatusCode()) {
        String text=response.getText();
        requestObject.handleResponseText(text);
      }
 else       if (Response.SC_UNAUTHORIZED == response.getStatusCode()) {
        wireLogger.finest(""String_Node_Str"");
      }
 else       if (response.getStatusCode() > 0) {
        wireLogger.severe(SERVER_ERROR + ""String_Node_Str"" + response.getStatusCode()+ ""String_Node_Str""+ response.getText());
      }
      postRequestEvent(State.RECEIVED,response);
    }
  }
);
  try {
    wireLogger.finest(""String_Node_Str"");
    builder.send();
    postRequestEvent(State.SENT,null);
  }
 catch (  RequestException e) {
    wireLogger.log(Level.SEVERE,SERVER_ERROR + ""String_Node_Str"" + e.getMessage()+ ""String_Node_Str"",e);
  }
}"
82127,"/** 
 * @param newRecord
 * @param i
 * @param array
 */
private void setRecordInList(RecordJsoImpl newRecord,int i,JsArray<RecordJsoImpl> array){
  RecordKey recordKey=new RecordKey(newRecord);
  RecordJsoImpl oldRecord=records.get(recordKey);
  if (oldRecord == null) {
    records.put(recordKey,newRecord);
  }
 else {
    boolean changed=oldRecord.merge(newRecord);
    newRecord=oldRecord.cast();
    if (array != null) {
      array.set(i,newRecord);
    }
    if (changed) {
      eventBus.fireEvent(newRecord.getSchema().createChangeEvent(newRecord,WriteOperation.UPDATE));
    }
  }
}","/** 
 * @param newRecord
 * @param i
 * @param array
 */
private void setRecordInList(RecordJsoImpl newRecord,int i,JsArray<RecordJsoImpl> array){
  RecordKey recordKey=new RecordKey(newRecord,RequestFactoryJsonImpl.NOT_FUTURE);
  RecordJsoImpl oldRecord=records.get(recordKey);
  if (oldRecord == null) {
    records.put(recordKey,newRecord);
  }
 else {
    boolean changed=oldRecord.merge(newRecord);
    newRecord=oldRecord.cast();
    if (array != null) {
      array.set(i,newRecord);
    }
    if (changed) {
      eventBus.fireEvent(newRecord.getSchema().createChangeEvent(newRecord,WriteOperation.UPDATE));
    }
  }
}"
82128,"public void init(HandlerManager eventBus){
}","@Override public void init(HandlerManager eventBus){
}"
82129,"@Override public void gwtSetUp(){
  valueStore=new ValueStoreJsonImpl(null);
  requestFactory=new RequestFactoryJsonImpl(){
    public Record create(    Class token){
      return create(token,typeMap);
    }
    public void init(    HandlerManager eventBus){
    }
    public LoggingRequest loggingRequest(){
      return null;
    }
  }
;
  jso=RecordJsoImpl.fromJson(""String_Node_Str"");
  jso.set(SimpleFooRecord.id,42L);
  jso.set(SimpleFooRecord.version,1);
  jso.set(SimpleFooRecord.userName,""String_Node_Str"");
  jso.set(SimpleFooRecord.password,""String_Node_Str"");
  jso.set(SimpleFooRecord.intId,4);
  jso.set(SimpleFooRecord.created,new Date());
  jso.setSchema(SimpleFooRecordImpl.SCHEMA);
  valueStore.setRecord(jso);
}","@Override public void gwtSetUp(){
  valueStore=new ValueStoreJsonImpl(null);
  requestFactory=new RequestFactoryJsonImpl(){
    public Record create(    Class token){
      return create(token,typeMap);
    }
    @Override public void init(    HandlerManager eventBus){
    }
    public LoggingRequest loggingRequest(){
      return null;
    }
  }
;
  jso=RecordJsoImpl.fromJson(""String_Node_Str"");
  jso.set(SimpleFooRecord.id,42L);
  jso.set(SimpleFooRecord.version,1);
  jso.set(SimpleFooRecord.userName,""String_Node_Str"");
  jso.set(SimpleFooRecord.password,""String_Node_Str"");
  jso.set(SimpleFooRecord.intId,4);
  jso.set(SimpleFooRecord.created,new Date());
  jso.setSchema(SimpleFooRecordImpl.SCHEMA);
  valueStore.setRecord(jso);
}"
82130,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}"
82131,"public void testDeleteUpdate(){
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.delete(new MyRecordImpl(jso));
  assertTrue(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,new MyRecordImpl(jso),""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.UPDATE);
  changeRecord.get(SimpleFooRecord.userName.getName());
}","public void testDeleteUpdate(){
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.delete(new MyRecordImpl(jso));
  assertTrue(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,new MyRecordImpl(jso),""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.UPDATE);
  assertEquals(""String_Node_Str"",changeRecord.get(SimpleFooRecord.userName.getName()).isString().stringValue());
}"
82132,"public void testCreateUpdate(){
  Record created=requestFactory.create(SimpleFooRecord.class);
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  assertFalse(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,created,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.CREATE);
  changeRecord.get(SimpleFooRecord.userName.getName());
}","public void testCreateUpdate(){
  Record created=requestFactory.create(SimpleFooRecord.class);
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  assertFalse(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,created,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.CREATE);
  assertEquals(""String_Node_Str"",changeRecord.get(SimpleFooRecord.userName.getName()).isString().stringValue());
}"
82133,"public void testUpdate(){
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.set(SimpleFooRecord.userName,new MyRecordImpl(jso),""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.UPDATE);
  changeRecord.get(SimpleFooRecord.userName.getName());
}","public void testUpdate(){
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.set(SimpleFooRecord.userName,new MyRecordImpl(jso),""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.UPDATE);
  assertEquals(""String_Node_Str"",changeRecord.get(SimpleFooRecord.userName.getName()).isString().stringValue());
}"
82134,"/** 
 * Returns the propertyValue in the right type, from the DataStore. The value is sent into the response.
 */
public Object encodePropertyValueFromDataStore(Object entityElement,Class<?> propertyType,String propertyName,RequestProperty propertyContext) throws SecurityException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, JSONException {
  String methodName=getMethodNameFromPropertyName(propertyName,""String_Node_Str"");
  Method method=entityElement.getClass().getMethod(methodName);
  Object returnValue=method.invoke(entityElement);
  if (returnValue != null && Record.class.isAssignableFrom(propertyType)) {
    Method idMethod=entityElement.getClass().getMethod(""String_Node_Str"");
    Long id=(Long)idMethod.invoke(entityElement);
    String keyRef=operationRegistry.getSecurityProvider().encodeClassType(propertyType) + ""String_Node_Str"" + id;
    addRelatedObject(keyRef,returnValue,(Class<? extends Record>)propertyType,propertyContext.getProperty(propertyName));
    return keyRef;
  }
  return encodePropertyValue(returnValue);
}","/** 
 * Returns the propertyValue in the right type, from the DataStore. The value is sent into the response.
 */
public Object encodePropertyValueFromDataStore(Object entityElement,Class<?> propertyType,String propertyName,RequestProperty propertyContext) throws SecurityException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, JSONException {
  String methodName=getMethodNameFromPropertyName(propertyName,""String_Node_Str"");
  Method method=entityElement.getClass().getMethod(methodName);
  Object returnValue=method.invoke(entityElement);
  if (returnValue != null && Record.class.isAssignableFrom(propertyType)) {
    Method idMethod=returnValue.getClass().getMethod(""String_Node_Str"");
    Long id=(Long)idMethod.invoke(returnValue);
    String keyRef=operationRegistry.getSecurityProvider().encodeClassType(propertyType) + ""String_Node_Str"" + id;
    addRelatedObject(keyRef,returnValue,(Class<? extends Record>)propertyType,propertyContext.getProperty(propertyName));
    return keyRef;
  }
  return encodePropertyValue(returnValue);
}"
82135,"public void onWindowResized(int width,int height){
  if (width == windowWidth || width < 1) {
    return;
  }
  windowWidth=width;
  onWindowResizedImpl(width);
}","@SuppressWarnings(""String_Node_Str"") public void onWindowResized(int width,int height){
  if (width == windowWidth || width < 1) {
    return;
  }
  windowWidth=width;
  onWindowResizedImpl(width);
}"
82136,"/** 
 * Load the contents of a remote file into the specified widget.
 * @param url a partial path relative to the module base URL
 * @param target the target Widget to place the contents
 * @param callback the callback when the call completes
 */
private void requestSourceContents(String url,final HTML target,final RequestCallback callback){
  if (loadingImage == null) {
    loadingImage=""String_Node_Str"" + GWT.getModuleBaseURL() + ""String_Node_Str"";
  }
  target.setDirection(HasDirection.Direction.LTR);
  DOM.setStyleAttribute(target.getElement(),""String_Node_Str"",""String_Node_Str"");
  target.setHTML(""String_Node_Str"" + loadingImage);
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,GWT.getModuleBaseURL() + url);
  RequestCallback realCallback=new RequestCallback(){
    public void onError(    Request request,    Throwable exception){
      target.setHTML(""String_Node_Str"");
      if (callback != null) {
        callback.onError(request,exception);
      }
    }
    public void onResponseReceived(    Request request,    Response response){
      target.setHTML(response.getText());
      if (callback != null) {
        callback.onResponseReceived(request,response);
      }
    }
  }
;
  builder.setCallback(realCallback);
  try {
    builder.send();
  }
 catch (  RequestException e) {
    realCallback.onError(null,e);
  }
}","/** 
 * Load the contents of a remote file into the specified widget.
 * @param url a partial path relative to the module base URL
 * @param target the target Widget to place the contents
 * @param callback the callback when the call completes
 */
@SuppressWarnings(""String_Node_Str"") private void requestSourceContents(String url,final HTML target,final RequestCallback callback){
  if (loadingImage == null) {
    loadingImage=""String_Node_Str"" + GWT.getModuleBaseURL() + ""String_Node_Str"";
  }
  target.setDirection(HasDirection.Direction.LTR);
  DOM.setStyleAttribute(target.getElement(),""String_Node_Str"",""String_Node_Str"");
  target.setHTML(""String_Node_Str"" + loadingImage);
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,GWT.getModuleBaseURL() + url);
  RequestCallback realCallback=new RequestCallback(){
    public void onError(    Request request,    Throwable exception){
      target.setHTML(""String_Node_Str"");
      if (callback != null) {
        callback.onError(request,exception);
      }
    }
    public void onResponseReceived(    Request request,    Response response){
      target.setHTML(response.getText());
      if (callback != null) {
        callback.onResponseReceived(request,response);
      }
    }
  }
;
  builder.setCallback(realCallback);
  try {
    builder.send();
  }
 catch (  RequestException e) {
    realCallback.onError(null,e);
  }
}"
82137,"/** 
 * Initialize this example.
 */
@ShowcaseSource @Override public Widget onInitialize(){
  DecoratedTabPanel tabPanel=new DecoratedTabPanel();
  tabPanel.setWidth(""String_Node_Str"");
  tabPanel.setAnimationEnabled(true);
  String[] tabTitles=constants.cwTabPanelTabs();
  HTML homeText=new HTML(constants.cwTabPanelTab0());
  tabPanel.add(homeText,tabTitles[0]);
  VerticalPanel vPanel=new VerticalPanel();
  vPanel.add(new Image(Showcase.images.gwtLogo()));
  tabPanel.add(vPanel,tabTitles[1]);
  HTML moreInfo=new HTML(constants.cwTabPanelTab2());
  tabPanel.add(moreInfo,tabTitles[2]);
  tabPanel.selectTab(0);
  tabPanel.ensureDebugId(""String_Node_Str"");
  return tabPanel;
}","/** 
 * Initialize this example.
 */
@SuppressWarnings(""String_Node_Str"") @ShowcaseSource @Override public Widget onInitialize(){
  DecoratedTabPanel tabPanel=new DecoratedTabPanel();
  tabPanel.setWidth(""String_Node_Str"");
  tabPanel.setAnimationEnabled(true);
  String[] tabTitles=constants.cwTabPanelTabs();
  HTML homeText=new HTML(constants.cwTabPanelTab0());
  tabPanel.add(homeText,tabTitles[0]);
  VerticalPanel vPanel=new VerticalPanel();
  vPanel.add(new Image(Showcase.images.gwtLogo()));
  tabPanel.add(vPanel,tabTitles[1]);
  HTML moreInfo=new HTML(constants.cwTabPanelTab2());
  tabPanel.add(moreInfo,tabTitles[2]);
  tabPanel.selectTab(0);
  tabPanel.ensureDebugId(""String_Node_Str"");
  return tabPanel;
}"
82138,"/** 
 * Initialize this example.
 */
@ShowcaseSource @Override public Widget onInitialize(){
  DatePicker datePicker=new DatePicker();
  final Label text=new Label();
  datePicker.addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      String dateString=DateTimeFormat.getMediumDateFormat().format(date);
      text.setText(dateString);
    }
  }
);
  datePicker.setValue(new Date(),true);
  DateTimeFormat dateFormat=DateTimeFormat.getLongDateFormat();
  DateBox dateBox=new DateBox();
  dateBox.setFormat(new DateBox.DefaultFormat(dateFormat));
  VerticalPanel vPanel=new VerticalPanel();
  vPanel.add(new HTML(constants.cwDatePickerLabel()));
  vPanel.add(text);
  vPanel.add(datePicker);
  vPanel.add(new HTML(constants.cwDatePickerBoxLabel()));
  vPanel.add(dateBox);
  return vPanel;
}","/** 
 * Initialize this example.
 */
@SuppressWarnings(""String_Node_Str"") @ShowcaseSource @Override public Widget onInitialize(){
  DatePicker datePicker=new DatePicker();
  final Label text=new Label();
  datePicker.addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      String dateString=DateTimeFormat.getMediumDateFormat().format(date);
      text.setText(dateString);
    }
  }
);
  datePicker.setValue(new Date(),true);
  DateTimeFormat dateFormat=DateTimeFormat.getLongDateFormat();
  DateBox dateBox=new DateBox();
  dateBox.setFormat(new DateBox.DefaultFormat(dateFormat));
  VerticalPanel vPanel=new VerticalPanel();
  vPanel.add(new HTML(constants.cwDatePickerLabel()));
  vPanel.add(text);
  vPanel.add(datePicker);
  vPanel.add(new HTML(constants.cwDatePickerBoxLabel()));
  vPanel.add(dateBox);
  return vPanel;
}"
82139,"/** 
 * Adds a widget to the panel at the specified position. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the widget to be added
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void add(Widget w,int left,int top){
  w.removeFromParent();
  int beforeIndex=getWidgetCount();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
}","/** 
 * Adds a widget to the panel at the specified position. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the widget to be added
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void add(Widget w,int left,int top){
  w.removeFromParent();
  int beforeIndex=getWidgetCount();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
  verifyPositionNotStatic(w);
}"
82140,"/** 
 * Inserts a child widget at the specified position before the specified index. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically. If the widget is already a child of this panel, it will be moved to the specified index.
 * @param w the child widget to be inserted
 * @param left the widget's left position
 * @param top the widget's top position
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int left,int top,int beforeIndex){
  w.removeFromParent();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
}","/** 
 * Inserts a child widget at the specified position before the specified index. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically. If the widget is already a child of this panel, it will be moved to the specified index.
 * @param w the child widget to be inserted
 * @param left the widget's left position
 * @param top the widget's top position
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int left,int top,int beforeIndex){
  w.removeFromParent();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
  verifyPositionNotStatic(w);
}"
82141,"/** 
 * Sets the position of the specified child widget. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the child widget to be positioned
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void setWidgetPosition(Widget w,int left,int top){
  checkWidgetParent(w);
  setWidgetPositionImpl(w,left,top);
}","/** 
 * Sets the position of the specified child widget. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the child widget to be positioned
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void setWidgetPosition(Widget w,int left,int top){
  checkWidgetParent(w);
  setWidgetPositionImpl(w,left,top);
  verifyPositionNotStatic(w);
}"
82142,"/** 
 * Called to fetch the string token needed to get a new record via  {@link DeltaValueStore#create}.
 */
protected abstract Class getRecordClass();","/** 
 * Called to fetch the string token needed to get a new record via  {@link DeltaValueStore#create}.
 */
protected abstract Class<? extends Record> getRecordClass();"
82143,"/** 
 * Ignore DevMode's normal WEB-INF classloader rules and just allow the system classloader to dominate. This makes JUnitHostImpl live in the right classloader (mine).
 */
@SuppressWarnings(""String_Node_Str"") @Override protected WebAppContext createWebAppContext(TreeLogger logger,File appRootDir){
  return new WebAppContext(appRootDir.getAbsolutePath(),""String_Node_Str""){
{
      getInitParams().put(""String_Node_Str"",""String_Node_Str"");
      setParentLoaderPriority(true);
    }
  }
;
}","/** 
 * Ignore DevMode's normal WEB-INF classloader rules and just allow the system classloader to dominate. This makes JUnitHostImpl live in the right classloader (mine).
 */
@Override protected WebAppContext createWebAppContext(TreeLogger logger,File appRootDir){
  return new WebAppContext(appRootDir.getAbsolutePath(),""String_Node_Str""){
{
      getInitParams().put(""String_Node_Str"",""String_Node_Str"");
      setParentLoaderPriority(true);
    }
  }
;
}"
82144,"@Override public void flush(){
  if (!closed) {
    for (    LogRecord record : records) {
      Receiver<Long> loggingReciever=new LoggingReceiver();
      requestFactory.loggingRequest().logMessage(record.getLevel().toString(),record.getLoggerName(),record.getMessage()).fire(loggingReciever);
    }
  }
}","@Override public void flush(){
  if (!closed) {
    for (    LogRecord record : records) {
      Receiver<Long> loggingReceiver=new LoggingReceiver();
      requestFactory.loggingRequest().logMessage(record.getLevel().toString(),record.getLoggerName(),record.getMessage()).fire(loggingReceiver);
    }
  }
}"
82145,"/** 
 * Generate an ID for a new record. The default behavior is to return null and let the data store generate the ID automatically.
 * @param key the key of the record field
 * @return the ID of the new record, or null to auto generate
 */
protected Long generateIdForCreate(@SuppressWarnings(""String_Node_Str"") String key){
  return null;
}","/** 
 * Generate an ID for a new record. The default behavior is to return null and let the data store generate the ID automatically.
 * @param key the key of the record field
 * @return the ID of the new record, or null to auto generate
 */
protected Long generateIdForCreate(String key){
  return null;
}"
82146,"/** 
 * Failed in all modes due to HtmlUnit bug:
 */
@DoNotRunWith({Platform.HtmlUnitBug}) public void testValueChangeEvent(){
  TextBoxBase tb=createTextBoxBase();
  RootPanel.get().add(tb);
  Handler h=new Handler();
  tb.addValueChangeHandler(h);
  tb.setValue(null);
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setText(""String_Node_Str"");
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"");
  assertNull(h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",h.received);
}","/** 
 * Failed in all modes due to HtmlUnit bug.
 */
@DoNotRunWith({Platform.HtmlUnitBug}) public void testValueChangeEvent(){
  TextBoxBase tb=createTextBoxBase();
  RootPanel.get().add(tb);
  Handler h=new Handler();
  tb.addValueChangeHandler(h);
  tb.setValue(null);
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setText(""String_Node_Str"");
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"");
  assertNull(h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",h.received);
}"
82147,"public void removeView(ListView<T> view){
  if (!views.contains(view)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  views.remove(view);
  view.setDelegate(null);
}","public void removeView(ListView<T> view){
  if (!views.contains(view)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  views.remove(view);
  view.setDataProvider(null);
}"
82148,"/** 
 * Inform the views of the total number of items that are available.
 * @param size the new size
 * @param exact true if the size is exact, false if it is a guess
 */
protected void updateDataSize(int size,boolean exact){
  for (  ListView<T> view : views) {
    view.setDataSize(size,exact);
  }
}","/** 
 * Inform the views of the total number of items that are available.
 * @param size the new size
 * @param exact true if the size is exact, false if it is a guess
 */
protected void updateDataSize(int size,boolean exact){
  lastDataSize=size;
  lastDataSizeExact=exact;
  for (  ListView<T> view : views) {
    view.setDataSize(size,exact);
  }
}"
82149,"/** 
 * Adds a view to this adapter. The current range of interest of the view will be populated with data.
 * @param view a {@link ListView}.
 */
public void addView(ListView<T> view){
  if (views.contains(view)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  views.add(view);
  view.setDelegate(delegate);
  delegate.onRangeChanged(view);
}","/** 
 * Adds a view to this adapter. The current range of interest of the view will be populated with data.
 * @param view a {@link ListView}.
 */
public void addView(ListView<T> view){
  if (views.contains(view)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  views.add(view);
  view.setDataProvider(dataProvider,false);
  if (lastDataSize >= 0) {
    view.setDataSize(lastDataSize,lastDataSizeExact);
  }
  dataProvider.onRangeChanged(view);
}"
82150,"/** 
 * Formats Fractional seconds field according to pattern specified.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatFractionalSeconds(StringBuffer buf,int count,Date date){
  long time=date.getTime();
  int value;
  if (time < 0) {
    value=1000 - (int)(-time % 1000);
  }
 else {
    value=(int)(time % 1000);
  }
  if (count == 1) {
    value=Math.min((value + 50) / 100,9);
    buf.append((char)('0' + value));
  }
 else   if (count == 2) {
    value=Math.min((value + 5) / 10,99);
    zeroPaddingNumber(buf,value,2);
  }
 else {
    zeroPaddingNumber(buf,value,3);
    if (count > 3) {
      zeroPaddingNumber(buf,0,count - 3);
    }
  }
}","/** 
 * Formats Fractional seconds field according to pattern specified.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatFractionalSeconds(StringBuffer buf,int count,Date date){
  long time=date.getTime();
  int value;
  if (time < 0) {
    value=1000 - (int)(-time % 1000);
    if (value == 1000) {
      value=0;
    }
  }
 else {
    value=(int)(time % 1000);
  }
  if (count == 1) {
    value=Math.min((value + 50) / 100,9);
    buf.append((char)('0' + value));
  }
 else   if (count == 2) {
    value=Math.min((value + 5) / 10,99);
    zeroPaddingNumber(buf,value,2);
  }
 else {
    zeroPaddingNumber(buf,value,3);
    if (count > 3) {
      zeroPaddingNumber(buf,0,count - 3);
    }
  }
}"
82151,"public void testPre1970Milliseconds(){
  Date date=new Date(-631151998945L);
  long midnight=Date.UTC(1950 - 1900,0,1,0,0,1);
  assertEquals(-631151998945L,midnight + 55);
  TimeZone utc=TimeZone.createTimeZone(0);
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
}","public void testPre1970Milliseconds(){
  Date date=new Date(-631151998945L);
  long midnight=Date.UTC(1950 - 1900,0,1,0,0,1);
  assertEquals(-631151998945L,midnight + 55);
  TimeZone utc=TimeZone.createTimeZone(0);
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  date=new Date(midnight);
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
}"
82152,"/** 
 * Create an ActivityManager. Next call   {@link #setDisplay} and{@link #activate}.
 * @param mapper finds the {@link Activity} for a given {@link Place}
 * @param eventBus source of {@link PlaceChangeEvent} and{@link PlaceChangeRequestedEvent} events.
 */
public ActivityManager(ActivityMapper<P> mapper,HandlerManager eventBus){
  this.mapper=mapper;
  this.eventBus=eventBus;
}","/** 
 * Create an ActivityManager. Next call   {@link #setDisplay}.
 * @param mapper finds the {@link Activity} for a given {@link Place}
 * @param eventBus source of {@link PlaceChangeEvent} and{@link PlaceChangeRequestedEvent} events.
 */
public ActivityManager(ActivityMapper<P> mapper,HandlerManager eventBus){
  this.mapper=mapper;
  this.eventBus=eventBus;
}"
82153,"/** 
 * This method will dispatch commands from the command queue. It will dispatch commands until one of the following conditions is <code>true</code>: <ul> <li>It consumed its dispatching time slice  {@value #DEFAULT_TIME_SLICE_MILLIS}</li> <li>It encounters a <code>null</code> in the command queue</li> <li>All commands which were present at the start of the dispatching have been removed from the command queue</li> <li>The command that it was processing was canceled due to a false cancellation -- in this case we exit without updating any state</li> </ul>
 * @param startTimeMillis the time when this method started
 */
protected void doExecuteCommands(double startTimeMillis){
  assert(!isExecutionTimerPending());
  boolean wasCanceled=false;
  try {
    setExecuting(true);
    iterator.setEnd(commands.size());
    cancellationTimer.schedule(DEFAULT_CANCELLATION_TIMEOUT_MILLIS);
    while (iterator.hasNext()) {
      Object element=iterator.next();
      boolean removeCommand=true;
      try {
        if (element == null) {
          return;
        }
        if (element instanceof Command) {
          Command command=(Command)element;
          command.execute();
        }
 else         if (element instanceof IncrementalCommand) {
          IncrementalCommand incrementalCommand=(IncrementalCommand)element;
          removeCommand=!incrementalCommand.execute();
        }
      }
  finally {
        wasCanceled=iterator.wasRemoved();
        if (wasCanceled) {
          return;
        }
        if (removeCommand) {
          iterator.remove();
        }
      }
      if (hasTimeSliceExpired(Duration.currentTimeMillis(),startTimeMillis)) {
        return;
      }
    }
  }
  finally {
    if (!wasCanceled) {
      cancellationTimer.cancel();
      setExecuting(false);
      maybeStartExecutionTimer();
    }
  }
}","/** 
 * This method will dispatch commands from the command queue. It will dispatch commands until one of the following conditions is <code>true</code>: <ul> <li>It consumed its dispatching time slice  {@value #DEFAULT_TIME_SLICE_MILLIS}</li> <li>It encounters a <code>null</code> in the command queue</li> <li>All commands which were present at the start of the dispatching have been removed from the command queue</li> <li>The command that it was processing was canceled due to a false cancellation -- in this case we exit without updating any state</li> </ul>
 * @param startTimeMillis the time when this method started
 */
protected void doExecuteCommands(double startTimeMillis){
  assert(!isExecutionTimerPending());
  boolean wasCanceled=false;
  try {
    setExecuting(true);
    iterator.setEnd(commands.size());
    cancellationTimer.schedule(DEFAULT_CANCELLATION_TIMEOUT_MILLIS);
    while (iterator.hasNext()) {
      Object element=iterator.next();
      boolean removeCommand=true;
      try {
        if (element == null) {
          return;
        }
        if (element instanceof Command) {
          Command command=(Command)element;
          command.execute();
        }
 else         if (element instanceof IncrementalCommand) {
          IncrementalCommand incrementalCommand=(IncrementalCommand)element;
          removeCommand=!incrementalCommand.execute();
        }
      }
  finally {
        wasCanceled=iterator.wasRemoved();
        if (!wasCanceled) {
          if (removeCommand) {
            iterator.remove();
          }
        }
      }
      if (hasTimeSliceExpired(Duration.currentTimeMillis(),startTimeMillis)) {
        return;
      }
    }
  }
  finally {
    if (!wasCanceled) {
      cancellationTimer.cancel();
      setExecuting(false);
      maybeStartExecutionTimer();
    }
  }
}"
82154,"public void configureClientSideLogging(){
  Logger root=Logger.getLogger(""String_Node_Str"");
  setLevels(root);
  setDefaultHandlers(root);
}","public void configureClientSideLogging(){
  root=Logger.getLogger(""String_Node_Str"");
  setLevels(root);
  setDefaultHandlers(root);
}"
82155,"/** 
 * Evaluates a JSON expression. This method does not validate the JSON text and should only be used on JSON from trusted sources.
 * @param < T > The type of JavaScriptObject that should be returned
 * @param json The source JSON text
 * @return The evaluated object
 */
public static native <T extends JavaScriptObject>T unsafeEval(String json);","/** 
 * Evaluates a JSON expression using   {@code eval()}. This method does not validate the JSON text and should only be used on JSON from trusted sources. The payload must evaluate to an Object or an Array (not a primitive or a String).
 * @param < T > The type of JavaScriptObject that should be returned
 * @param json The source JSON text
 * @return The evaluated object
 */
public static native <T extends JavaScriptObject>T unsafeEval(String json);"
82156,"/** 
 * Evaluates a trusted JSON string and returns its JSONValue representation. CAUTION! For efficiency, this method is implemented using the JavaScript <code>eval()</code> function, which can execute arbitrary script. DO NOT pass an untrusted string into this method.
 * @param jsonString a JSON object to parse
 * @return a JSONValue that has been built by parsing the JSON string
 * @throws NullPointerException if <code>jsonString</code> is<code>null</code>
 * @throws IllegalArgumentException if <code>jsonString</code> is empty
 */
public static JSONValue parse(String jsonString){
  if (jsonString == null) {
    throw new NullPointerException();
  }
  if (jsonString.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return evaluate(jsonString);
  }
 catch (  JavaScriptException ex) {
    throw new JSONException(ex);
  }
}","private static JSONValue parse(String jsonString,boolean strict){
  if (jsonString == null) {
    throw new NullPointerException();
  }
  if (jsonString.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return evaluate(jsonString,strict);
  }
 catch (  JavaScriptException ex) {
    throw new JSONException(ex);
  }
}"
82157,"/** 
 * This method converts <code>jsonString</code> into a JSONValue.
 */
private static native JSONValue evaluate(String jsonString);","/** 
 * This method converts <code>jsonString</code> into a JSONValue. In strict mode (strict == true), one of two code paths is taken: 1) Call JSON.parse if available, or 2) Validate the input and call eval() In lenient mode (strict == false), eval() is called without validation.
 * @param strict if true, parse in strict mode. 
 */
private static native JSONValue evaluate(String json,boolean strict);"
82158,"/** 
 * Return the parsed value, or null if the field is empty.
 * @throws ParseFailedException if the value cannot be parsed
 */
public T getValueOrThrow() throws ParseException {
  String text=getText().trim();
  if (""String_Node_Str"".equals(text)) {
    return null;
  }
  return parser.parse(text);
}","/** 
 * Return the parsed value, or null if the field is empty.
 * @throws ParseException if the value cannot be parsed
 */
public T getValueOrThrow() throws ParseException {
  String text=getText().trim();
  if (""String_Node_Str"".equals(text)) {
    return null;
  }
  return parser.parse(text);
}"
82159,"public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
}","public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertEquals(1.0d,Double.parseDouble(""String_Node_Str""),0.0);
  assertEquals(1.0d,Double.parseDouble(""String_Node_Str""),0.0);
  assertEquals(1.0d,Double.parseDouble(""String_Node_Str""),0.0);
  assertEquals(1.0d,Double.parseDouble(""String_Node_Str""),0.0);
}"
82160,"public void testParse(){
  assertEquals(0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(-1.5f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(3.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(0.5f,Float.parseFloat(""String_Node_Str""),0.0);
}","public void testParse(){
  assertEquals(0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(-1.5f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(3.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(0.5f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(1.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(1.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(1.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(1.0f,Float.parseFloat(""String_Node_Str""),0.0);
}"
82161,"public int compare(JMethod m1,JMethod m2){
  String name1=m1.getName();
  String name2=m2.getName();
  return name1.compareTo(name2);
}","public int compare(JClassType o1,JClassType o2){
  return o1.getQualifiedSourceName().compareTo(o2.getQualifiedSourceName());
}"
82162,"/** 
 * Gets all types, both top-level and nested.
 * @return an array of types, possibly of zero length
 */
public JClassType[] getTypes(){
  Collection<JRealClassType> values=allTypes.values();
  return values.toArray(new JClassType[values.size()]);
}","/** 
 * Gets all types, both top-level and nested.
 * @return an array of types, possibly of zero length
 */
public JClassType[] getTypes(){
  Collection<JRealClassType> values=allTypes.values();
  JClassType[] result=values.toArray(new JClassType[values.size()]);
  Arrays.sort(result,new Comparator<JClassType>(){
    public int compare(    JClassType o1,    JClassType o2){
      return o1.getQualifiedSourceName().compareTo(o2.getQualifiedSourceName());
    }
  }
);
  return result;
}"
82163,"/** 
 * Validates the given module can be compiled.
 * @param logger a logger to use
 * @param jjsOptions a set of compiler options
 * @param module the module to compile
 * @param genDir optional directory to dump generated source, may be<code>null</code>
 */
public static boolean validate(TreeLogger logger,JJSOptions jjsOptions,ModuleDef module,File genDir,File dumpSignatureFile){
  try {
    CompilationState compilationState=module.getCompilationState(logger);
    if (dumpSignatureFile != null) {
      SignatureDumper.dumpSignatures(logger,compilationState.getTypeOracle(),dumpSignatureFile);
    }
    String[] declEntryPts=module.getEntryPointTypeNames();
    String[] additionalRootTypes=null;
    if (declEntryPts.length == 0) {
      Collection<CompilationUnit> compilationUnits=compilationState.getCompilationUnits();
      additionalRootTypes=new String[compilationUnits.size()];
      int i=0;
      for (      CompilationUnit unit : compilationUnits) {
        additionalRootTypes[i++]=unit.getTypeName();
      }
    }
    ArtifactSet generatorArtifacts=new ArtifactSet();
    DistillerRebindPermutationOracle rpo=new DistillerRebindPermutationOracle(module,compilationState,generatorArtifacts,new PropertyPermutations(module.getProperties(),module.getActiveLinkerNames()),genDir);
    compilationState=null;
    if (dumpSignatureFile != null) {
      SignatureDumper.dumpSignatures(logger,compilationState.getTypeOracle(),dumpSignatureFile);
    }
    jjsOptions.setOptimizePrecompile(false);
    getCompiler(module).precompile(logger,module,rpo,declEntryPts,additionalRootTypes,jjsOptions,true);
    return true;
  }
 catch (  UnableToCompleteException e) {
    return false;
  }
}","/** 
 * Validates the given module can be compiled.
 * @param logger a logger to use
 * @param jjsOptions a set of compiler options
 * @param module the module to compile
 * @param genDir optional directory to dump generated source, may be<code>null</code>
 */
public static boolean validate(TreeLogger logger,JJSOptions jjsOptions,ModuleDef module,File genDir,File dumpSignatureFile){
  try {
    CompilationState compilationState=module.getCompilationState(logger);
    if (dumpSignatureFile != null) {
      SignatureDumper.dumpSignatures(logger,compilationState.getTypeOracle(),dumpSignatureFile);
    }
    String[] declEntryPts=module.getEntryPointTypeNames();
    String[] additionalRootTypes=null;
    if (declEntryPts.length == 0) {
      Collection<CompilationUnit> compilationUnits=compilationState.getCompilationUnits();
      additionalRootTypes=new String[compilationUnits.size()];
      int i=0;
      for (      CompilationUnit unit : compilationUnits) {
        additionalRootTypes[i++]=unit.getTypeName();
      }
    }
    ArtifactSet generatorArtifacts=new ArtifactSet();
    DistillerRebindPermutationOracle rpo=new DistillerRebindPermutationOracle(module,compilationState,generatorArtifacts,new PropertyPermutations(module.getProperties(),module.getActiveLinkerNames()),genDir);
    compilationState=null;
    jjsOptions.setOptimizePrecompile(false);
    getCompiler(module).precompile(logger,module,rpo,declEntryPts,additionalRootTypes,jjsOptions,true);
    return true;
  }
 catch (  UnableToCompleteException e) {
    return false;
  }
}"
82164,"@Override public void finalizeLayout(Element parent){
  if (!isIE6()) {
    super.finalizeLayout(parent);
    return;
  }
  resizeRelativeToParent(parent);
  resizeHandler(parent,true);
}","@Override public void finalizeLayout(Element parent){
  resizeRelativeToParent(parent);
  resizeHandler(parent,true);
}"
82165,"@Override public void fillParent(Element elem){
  if (!isIE6()) {
    super.fillParent(elem);
    return;
  }
  fillParentImpl(elem);
}","@Override public void fillParent(Element elem){
  fillParentImpl(elem);
}"
82166,"@Override public void onDetach(Element parent){
  if (isIE6()) {
    removeLayerRefs(parent);
    removeResizeHandler(parent);
    removeUnitChangeHandler(relativeRuler);
  }
}","@Override public void onDetach(Element parent){
  removeLayerRefs(parent);
  removeResizeHandler(parent);
  removeUnitChangeHandler(relativeRuler);
}"
82167,"@Override public void layout(Layer layer){
  if (!isIE6()) {
    super.layout(layer);
    return;
  }
  Element elem=layer.getContainerElement();
  setLayer(elem,layer);
}","@Override public void layout(Layer layer){
  Element elem=layer.getContainerElement();
  setLayer(elem,layer);
}"
82168,"@Override public void onAttach(Element parent){
  if (isIE6()) {
    initResizeHandler(parent);
    initUnitChangeHandler(parent,relativeRuler);
  }
}","@Override public void onAttach(Element parent){
  initResizeHandler(parent);
  initUnitChangeHandler(parent,relativeRuler);
}"
82169,"@Override public void initParent(Element parent){
  super.initParent(parent);
  if (isIE6()) {
    setPropertyElement(parent,""String_Node_Str"",createStyleRuler(parent));
  }
}","@Override public void initParent(Element parent){
  super.initParent(parent);
  setPropertyElement(parent,""String_Node_Str"",createStyleRuler(parent));
}"
82170,"public void layout(Layer layer){
  Style style=layer.container.getStyle();
  if (layer.setLeft) {
    setValue(layer,""String_Node_Str"",layer.left,layer.leftUnit,false,false);
  }
 else {
    style.clearLeft();
  }
  if (layer.setRight) {
    setValue(layer,""String_Node_Str"",layer.right,layer.rightUnit,false,false);
  }
 else {
    style.clearRight();
  }
  if (layer.setTop) {
    setValue(layer,""String_Node_Str"",layer.top,layer.topUnit,true,false);
  }
 else {
    style.clearTop();
  }
  if (layer.setBottom) {
    setValue(layer,""String_Node_Str"",layer.bottom,layer.bottomUnit,true,false);
  }
 else {
    style.clearBottom();
  }
  if (layer.setWidth) {
    setValue(layer,""String_Node_Str"",layer.width,layer.widthUnit,false,true);
  }
 else {
    style.clearWidth();
  }
  if (layer.setHeight) {
    setValue(layer,""String_Node_Str"",layer.height,layer.heightUnit,true,true);
  }
 else {
    style.clearHeight();
  }
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}","@Override public void layout(Layer layer){
  Style style=layer.container.getStyle();
  if (layer.setLeft) {
    setValue(layer,""String_Node_Str"",layer.left,layer.leftUnit,false,false);
  }
 else {
    style.clearLeft();
  }
  if (layer.setRight) {
    setValue(layer,""String_Node_Str"",layer.right,layer.rightUnit,false,false);
  }
 else {
    style.clearRight();
  }
  if (layer.setTop) {
    setValue(layer,""String_Node_Str"",layer.top,layer.topUnit,true,false);
  }
 else {
    style.clearTop();
  }
  if (layer.setBottom) {
    setValue(layer,""String_Node_Str"",layer.bottom,layer.bottomUnit,true,false);
  }
 else {
    style.clearBottom();
  }
  if (layer.setWidth) {
    setValue(layer,""String_Node_Str"",layer.width,layer.widthUnit,false,true);
  }
 else {
    style.clearWidth();
  }
  if (layer.setHeight) {
    setValue(layer,""String_Node_Str"",layer.height,layer.heightUnit,true,true);
  }
 else {
    style.clearHeight();
  }
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}"
82171,"public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    lhs=visitor.accept(lhs);
    rhs=visitor.accept(rhs);
  }
  visitor.endVisit(this,ctx);
}","public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    if (isAssignment()) {
      lhs=visitor.acceptLvalue(lhs);
    }
 else {
      lhs=visitor.accept(lhs);
    }
    rhs=visitor.accept(rhs);
  }
  visitor.endVisit(this,ctx);
}"
82172,"public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    variableRef=(JVariableRef)visitor.accept(variableRef);
    if (initializer != null) {
      initializer=visitor.accept(initializer);
    }
  }
  visitor.endVisit(this,ctx);
}","public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    variableRef=(JVariableRef)visitor.acceptLvalue(variableRef);
    if (initializer != null) {
      initializer=visitor.accept(initializer);
    }
  }
  visitor.endVisit(this,ctx);
}"
82173,"public void traverse(JVisitor visitor,Context ctx){
  arg=visitor.accept(arg);
}","public void traverse(JVisitor visitor,Context ctx){
  if (getOp().isModifying()) {
    arg=visitor.acceptLvalue(arg);
  }
 else {
    arg=visitor.accept(arg);
  }
}"
82174,"@Override public final boolean visit(JStatement x,Context ctx){
  if (ctx.canInsert()) {
    insertionStack.push(ctx);
  }
  return super.visit(x,ctx);
}","@Override public final boolean visit(JStatement x,Context ctx){
  if (ctx.canInsert() && !banList.contains(x)) {
    insertionStack.push(ctx);
  }
  if (x instanceof JForStatement) {
    JForStatement forStmt=(JForStatement)x;
    banList.addAll(forStmt.getIncrements());
  }
  return super.visit(x,ctx);
}"
82175,"@Override public void endVisit(JExpression x,Context ctx){
  SourceInfo info=x.getSourceInfo();
  JType type=x.getType();
  JLocal local=createTempLocal(info,type);
  local.getDeclarationStatement().initializer=x;
  ctx.replaceMe(new JLocalRef(info,local));
}","@Override public void endVisit(JExpression x,Context ctx){
  if (x != dontBother && !ctx.isLvalue()) {
    SourceInfo info=x.getSourceInfo();
    JType type=x.getType();
    JLocal local=createTempLocal(info,type);
    local.getDeclarationStatement().initializer=x;
    ctx.replaceMe(new JLocalRef(info,local));
  }
}"
82176,"@Override public boolean visit(JPrefixOperation x,Context ctx){
  if (x.getOp().isModifying()) {
    return false;
  }
  return true;
}","@Override public boolean visit(JExpressionStatement x,Context ctx){
  dontBother=x.getExpr();
  return super.visit(x,ctx);
}"
82177,"public void testForStatement() throws Exception {
  StringBuilder original=new StringBuilder();
  original.append(""String_Node_Str"");
  StringBuilder expected=new StringBuilder();
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  assertTransform(original.toString()).into(expected.toString());
}","public void testForStatement() throws Exception {
  StringBuilder original=new StringBuilder();
  original.append(""String_Node_Str"");
  StringBuilder expected=new StringBuilder();
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  assertTransform(original.toString()).into(expected.toString());
}"
82178,"/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  if (GWT.isScript()) {
    try {
      t.compareTo(d2);
      fail(""String_Node_Str"");
    }
 catch (    ClassCastException e) {
    }
  }
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(t.getNanos() + 1);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}","/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  assertEquals(1,t.compareTo(d2));
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(t.getNanos() + 1);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}"
82179,"private void checkIndexForAdd(int index){
  checkIndex(index,size - 1);
}","private void checkIndexForAdd(int index){
  checkIndex(index,size + 1);
}"
82180,"private void checkListSizeAndContent(List<Integer> in,int[] expected){
  assertEquals(expected.length,in.size());
  for (int i=0; i < expected.length; i++) {
    assertEquals(expected[i],(int)in.get(i));
  }
}","private void checkListSizeAndContent(List<Integer> in,int... expected){
  assertEquals(expected.length,in.size());
  for (int i=0; i < expected.length; i++) {
    assertEquals(expected[i],(int)in.get(i));
  }
}"
82181,"public void testSubList(){
  List<Integer> wrappedList=createListWithContent(new int[]{1,2,3,4,5});
  List<Integer> testList=wrappedList.subList(1,4);
  assertEquals(3,testList.size());
  assertEquals(testList,Arrays.asList(2,3,4));
  checkListSizeAndContent(testList,new int[]{2,3,4});
  testList.add(1,6);
  assertEquals(testList,Arrays.asList(2,6,3,4));
  checkListSizeAndContent(testList,new int[]{2,6,3,4});
  assertEquals(wrappedList,Arrays.asList(1,2,6,3,4,5));
  checkListSizeAndContent(wrappedList,new int[]{1,2,6,3,4,5});
  testList.remove(2);
  assertEquals(testList,Arrays.asList(2,6,4));
  checkListSizeAndContent(testList,new int[]{2,6,4});
  try {
    testList.remove(3);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  checkListSizeAndContent(wrappedList,new int[]{1,2,6,4,5});
  testList.set(0,7);
  checkListSizeAndContent(testList,new int[]{7,6,4});
  checkListSizeAndContent(wrappedList,new int[]{1,7,6,4,5});
  try {
    wrappedList.subList(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,15);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(5,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    wrappedList.subList(0,1).add(2,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).add(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).get(1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).get(-1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).set(2,2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).set(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
}","public void testSubList(){
  List<Integer> wrappedList=createListWithContent(new int[]{1,2,3,4,5});
  List<Integer> testList=wrappedList.subList(1,4);
  assertEquals(3,testList.size());
  assertEquals(testList,Arrays.asList(2,3,4));
  checkListSizeAndContent(testList,2,3,4);
  testList.add(1,6);
  assertEquals(testList,Arrays.asList(2,6,3,4));
  checkListSizeAndContent(testList,2,6,3,4);
  assertEquals(wrappedList,Arrays.asList(1,2,6,3,4,5));
  checkListSizeAndContent(wrappedList,1,2,6,3,4,5);
  testList.remove(2);
  assertEquals(testList,Arrays.asList(2,6,4));
  checkListSizeAndContent(testList,2,6,4);
  try {
    testList.remove(3);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  checkListSizeAndContent(wrappedList,1,2,6,4,5);
  testList.set(0,7);
  checkListSizeAndContent(testList,7,6,4);
  checkListSizeAndContent(wrappedList,1,7,6,4,5);
  try {
    wrappedList.subList(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,15);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(5,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    wrappedList.subList(0,1).add(2,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).add(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).get(1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).get(-1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).set(2,2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).set(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
}"
82182,"/** 
 * Method parses GMT type timezone.
 * @param text the time text to be parsed
 * @param start from where parse start
 * @param pos Parse position
 * @param cal DateRecord object that holds parsed value
 * @return <code>true</code> if parsing successful, otherwise<code>false</code>
 */
private boolean subParseTimeZoneInGMT(String text,int start,int[] pos,DateRecord cal){
  if (text.startsWith(GMT,start)) {
    pos[0]=start + GMT.length();
    return parseTimeZoneOffset(text,pos,cal);
  }
  return parseTimeZoneOffset(text,pos,cal);
}","/** 
 * Method parses GMT type timezone.
 * @param text the time text to be parsed
 * @param start from where parse start
 * @param pos Parse position
 * @param cal DateRecord object that holds parsed value
 * @return <code>true</code> if parsing successful, otherwise<code>false</code>
 */
private boolean subParseTimeZoneInGMT(String text,int start,int[] pos,DateRecord cal){
  if (text.startsWith(GMT,start)) {
    pos[0]=start + GMT.length();
    return parseTimeZoneOffset(text,pos,cal);
  }
  if (text.startsWith(UTC,start)) {
    pos[0]=start + UTC.length();
    return parseTimeZoneOffset(text,pos,cal);
  }
  return parseTimeZoneOffset(text,pos,cal);
}"
82183,"public void test_timezonez(){
  TimeZoneConstants timeZoneData=GWT.create(TimeZoneConstants.class);
  String str=timeZoneData.americaLosAngeles();
  TimeZone usPacific=TimeZone.createTimeZone(str);
  Date date=new Date();
  date.setTime(Date.UTC(2006 - 1900,6,27,13,10,10));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  date.setTime(Date.UTC(2006 - 1900,1,27,13,10,10));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
}","public void test_timezonez(){
  TimeZoneConstants timeZoneData=GWT.create(TimeZoneConstants.class);
  String str=timeZoneData.americaLosAngeles();
  TimeZone usPacific=TimeZone.createTimeZone(str);
  Date date=new Date();
  date.setTime(Date.UTC(2006 - 1900,6,27,13,10,10));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  date.setTime(Date.UTC(2006 - 1900,1,27,13,10,10));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  DateTimeFormat format=DateTimeFormat.getFormat(""String_Node_Str"");
  assertEquals(date,format.parse(format.format(date)));
}"
82184,"public void testSin(){
  double v=Math.sin(0.0);
  assertEquals(0.0,v,1e-7);
  v=Math.sin(Math.PI * .5);
  assertEquals(1.0,v,1e-7);
  v=Math.sin(Math.PI);
  assertEquals(0.0,v,1e-7);
  v=Math.sin(Math.PI * 1.5);
  assertEquals(-1.0,v,1e-7);
}","public void testSin(){
  double v=Math.sin(0.0);
  assertEquals(0.0,v,1e-7);
  v=Math.sin(-0.0);
  assertEquals(-0.0,v,1e-7);
  v=Math.sin(Math.PI * .5);
  assertEquals(1.0,v,1e-7);
  v=Math.sin(Math.PI);
  assertEquals(0.0,v,1e-7);
  v=Math.sin(Math.PI * 1.5);
  assertEquals(-1.0,v,1e-7);
  v=Math.sin(Double.NaN);
  assertTrue(Double.isNaN(v));
  v=Math.sin(Double.NEGATIVE_INFINITY);
  assertTrue(Double.isNaN(v));
  v=Math.sin(Double.POSITIVE_INFINITY);
  assertTrue(Double.isNaN(v));
}"
82185,"public void testCos(){
  double v=Math.cos(0.0);
  assertEquals(1.0,v,1e-7);
  v=Math.cos(Math.PI * .5);
  assertEquals(0.0,v,1e-7);
  v=Math.cos(Math.PI);
  assertEquals(-1.0,v,1e-7);
  v=Math.cos(Math.PI * 1.5);
  assertEquals(0.0,v,1e-7);
}","public void testCos(){
  double v=Math.cos(0.0);
  assertEquals(1.0,v,1e-7);
  v=Math.cos(-0.0);
  assertEquals(1.0,v,1e-7);
  v=Math.cos(Math.PI * .5);
  assertEquals(0.0,v,1e-7);
  v=Math.cos(Math.PI);
  assertEquals(-1.0,v,1e-7);
  v=Math.cos(Math.PI * 1.5);
  assertEquals(0.0,v,1e-7);
  v=Math.cos(Double.NaN);
  assertTrue(Double.isNaN(v));
  v=Math.cos(Double.NEGATIVE_INFINITY);
  assertTrue(Double.isNaN(v));
  v=Math.cos(Double.POSITIVE_INFINITY);
  assertTrue(Double.isNaN(v));
}"
82186,"public static int compare(double x,double y){
  if (x < y) {
    return -1;
  }
 else   if (x > y) {
    return 1;
  }
 else {
    return 0;
  }
}","public static int compare(double x,double y){
  if (isNaN(x)) {
    if (isNaN(y)) {
      return 0;
    }
 else {
      return 1;
    }
  }
 else   if (isNaN(y)) {
    return -1;
  }
  if (x < y) {
    return -1;
  }
 else   if (x > y) {
    return 1;
  }
 else {
    return 0;
  }
}"
82187,"public int compareTo(Double b){
  if (value < b.value) {
    return -1;
  }
 else   if (value > b.value) {
    return 1;
  }
 else {
    return 0;
  }
}","public int compareTo(Double b){
  return compare(this.value,b.value);
}"
82188,"private static TypedProgramReference typedProgramReference(JsName name,JavaToJavaScriptMap jjsmap,Map<JsName,String> obfuscateMap){
  JMethod method=jjsmap.nameToMethod(name);
  if (method != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(method.getEnclosingType().getName());
    sb.append(""String_Node_Str"");
    sb.append(method.getName());
    sb.append(""String_Node_Str"");
    for (    JType type : method.getOriginalParamTypes()) {
      sb.append(type.getJsniSignatureName());
    }
    sb.append(""String_Node_Str"");
    sb.append(method.getOriginalReturnType().getJsniSignatureName());
    String desc=sb.toString();
    return new TypedProgramReference(""String_Node_Str"",desc);
  }
  JClassType type=jjsmap.nameToType(name);
  if (type != null) {
    return new TypedProgramReference(""String_Node_Str"",type.getName());
  }
  String string=obfuscateMap.get(name);
  if (string != null) {
    return new TypedProgramReference(""String_Node_Str"",string);
  }
  return new TypedProgramReference(""String_Node_Str"",name.getShortIdent());
}","private static TypedProgramReference typedProgramReference(JsName name,JavaToJavaScriptMap jjsmap,Map<JsName,String> obfuscateMap){
  JMethod method=jjsmap.nameToMethod(name);
  if (method != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(method.getEnclosingType().getName());
    sb.append(""String_Node_Str"");
    sb.append(method.getName());
    sb.append(""String_Node_Str"");
    for (    JType type : method.getOriginalParamTypes()) {
      sb.append(type.getJsniSignatureName());
    }
    sb.append(""String_Node_Str"");
    sb.append(method.getOriginalReturnType().getJsniSignatureName());
    String desc=sb.toString();
    return new TypedProgramReference(""String_Node_Str"",desc);
  }
  JField field=jjsmap.nameToField(name);
  if ((field != null) && (field.getEnclosingType() != null)) {
    StringBuilder sb=new StringBuilder();
    sb.append(field.getEnclosingType().getName());
    sb.append(""String_Node_Str"");
    sb.append(field.getName());
    return new TypedProgramReference(""String_Node_Str"",sb.toString());
  }
  JClassType type=jjsmap.nameToType(name);
  if (type != null) {
    return new TypedProgramReference(""String_Node_Str"",type.getName());
  }
  String string=obfuscateMap.get(name);
  if (string != null) {
    return new TypedProgramReference(""String_Node_Str"",string);
  }
  return new TypedProgramReference(""String_Node_Str"",name.getShortIdent());
}"
82189,"public Response execute(Request request) throws Exception {
  if (request.getServiceType() != Request.ServiceType.DEV_MODE) {
    throw new IllegalArgumentException(""String_Node_Str"" + request.getServiceType().name());
  }
switch (request.getDevModeRequest().getRequestType()) {
case CAPABILITY_EXCHANGE:
    return processCapabilityExchange();
case RESTART_WEB_SERVER:
  return processRestartServer();
default :
{
  break;
}
}
throw new IllegalArgumentException(""String_Node_Str"" + request.getDevModeRequest().getRequestType().name());
}","public Response execute(Request request) throws Exception {
  if (request.getServiceType() != Request.ServiceType.DEV_MODE) {
    throw new IllegalArgumentException(""String_Node_Str"" + request.getServiceType().name());
  }
  RequestType requestType=request.getDevModeRequest().getRequestType();
  if (requestType != null) {
switch (requestType) {
case CAPABILITY_EXCHANGE:
      return processCapabilityExchange();
case RESTART_WEB_SERVER:
    return processRestartServer();
default :
{
    break;
  }
}
}
throw new IllegalArgumentException(""String_Node_Str"" + requestType == null ? ""String_Node_Str"" : requestType.name());
}"
82190,"private void processMessage(final Message message) throws InterruptedException {
switch (message.getMessageType()) {
case RESPONSE:
{
      processServerResponse(message.getMessageId(),message.getResponse());
      break;
    }
case REQUEST:
{
    processClientRequest(message.getMessageId(),message.getRequest());
    break;
  }
case FAILURE:
{
  processFailure(message.getMessageId(),message.getFailure());
  break;
}
default :
{
processUnknownMessageType(message.getMessageId(),message.getMessageType().name());
break;
}
}
}","private void processMessage(final Message message) throws InterruptedException {
  MessageType messageType=message.getMessageType();
  if (messageType == null) {
    processUnknownMessageType(message.getMessageId(),""String_Node_Str"");
    return;
  }
switch (messageType) {
case RESPONSE:
{
      processServerResponse(message.getMessageId(),message.getResponse());
      break;
    }
case REQUEST:
{
    processClientRequest(message.getMessageId(),message.getRequest());
    break;
  }
case FAILURE:
{
  processFailure(message.getMessageId(),message.getFailure());
  break;
}
default :
{
processUnknownMessageType(message.getMessageId(),messageType.name());
break;
}
}
}"
82191,"private String getContent(HttpServletRequest request) throws IOException {
  int contentLength=request.getContentLength();
  byte contentBytes[]=new byte[contentLength];
  BufferedInputStream bis=new BufferedInputStream(request.getInputStream());
  int readBytes=0;
  while (bis.read(contentBytes,readBytes,contentLength - readBytes) > 0) {
  }
  return new String(contentBytes);
}","private String getContent(HttpServletRequest request) throws IOException {
  int contentLength=request.getContentLength();
  byte contentBytes[]=new byte[contentLength];
  BufferedInputStream bis=new BufferedInputStream(request.getInputStream());
  try {
    int readBytes=0;
    while (bis.read(contentBytes,readBytes,contentLength - readBytes) > 0) {
    }
    return new String(contentBytes);
  }
  finally {
    bis.close();
  }
}"
82192,"private void assertIsChild(Widget widget){
}","void assertIsChild(Widget widget){
}"
82193,"/** 
 * Sets the minimum allowable size for the given widget. <p> Its assocated splitter cannot be dragged to a position that would make it smaller than this size. This method has no effect for the  {@link DockLayoutPanel.Direction#CENTER} widget.</p>
 * @param child the child whose minimum size will be set
 * @param minSize the minimum size for this widget
 */
public void setWidgetMinSize(Widget child,int minSize){
  Splitter splitter=getAssociatedSplitter(child);
  splitter.setMinSize(minSize);
}","/** 
 * Sets the minimum allowable size for the given widget. <p> Its associated splitter cannot be dragged to a position that would make it smaller than this size. This method has no effect for the  {@link DockLayoutPanel.Direction#CENTER} widget.</p>
 * @param child the child whose minimum size will be set
 * @param minSize the minimum size for this widget
 */
public void setWidgetMinSize(Widget child,int minSize){
  assertIsChild(child);
  Splitter splitter=getAssociatedSplitter(child);
  if (splitter != null) {
    splitter.setMinSize(minSize);
  }
}"
82194,"/** 
 * Shows the popup and attach it to the page. It must have a child widget before this method is called.
 */
public void show(){
  if (showing) {
    return;
  }
  resizeAnimation.setState(true,false);
}","/** 
 * Shows the popup and attach it to the page. It must have a child widget before this method is called.
 */
public void show(){
  if (showing) {
    return;
  }
 else   if (isAttached()) {
    this.removeFromParent();
  }
  resizeAnimation.setState(true,false);
}"
82195,"/** 
 * Test the showing a popup while it is hiding will not result in an illegal state.
 */
public void testShowWhileHiding(){
  PopupPanel popup=createPopupPanel();
  popup.setAnimationEnabled(false);
  popup.show();
  assertTrue(popup.isShowing());
  popup.setAnimationEnabled(true);
  popup.hide();
  assertFalse(popup.isShowing());
  popup.show();
  assertTrue(popup.isShowing());
}","/** 
 * Test that showing a popup while it is hiding will not result in an illegal state.
 */
public void testShowWhileHiding(){
  PopupPanel popup=createPopupPanel();
  popup.setAnimationEnabled(false);
  popup.show();
  assertTrue(popup.isShowing());
  popup.setAnimationEnabled(true);
  popup.hide();
  assertFalse(popup.isShowing());
  popup.show();
  assertTrue(popup.isShowing());
}"
82196,"private static Set<ExpensesKey<?>> get(){
  if (instance == null) {
    instance=new HashSet<ExpensesKey<?>>();
    instance.add(ReportKey.get());
    instance.add(EmployeeKey.get());
  }
  return instance;
}","private static Set<ExpensesKey<?>> get(){
  if (instance == null) {
    HashSet<ExpensesKey<?>> newInstance=new HashSet<ExpensesKey<?>>();
    newInstance.add(ReportKey.get());
    newInstance.add(EmployeeKey.get());
    instance=newInstance;
  }
  return instance;
}"
82197,"/** 
 * Resizes the grid to the specified number of columns.
 * @param columns the number of columns
 * @throws IndexOutOfBoundsException
 */
public void resizeColumns(int columns){
  if (numColumns == columns) {
    return;
  }
  if (columns < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + columns);
  }
  if (numColumns > columns) {
    for (int i=0; i < numRows; i++) {
      for (int j=numColumns - 1; j >= columns; j--) {
        removeCell(i,j);
      }
    }
  }
 else {
    for (int i=0; i < numRows; i++) {
      for (int j=numColumns; j < columns; j++) {
        insertCell(i,j);
      }
    }
  }
  numColumns=columns;
  getColumnFormatter().resizeColumnGroup(columns);
}","/** 
 * Resizes the grid to the specified number of columns.
 * @param columns the number of columns
 * @throws IndexOutOfBoundsException
 */
public void resizeColumns(int columns){
  if (numColumns == columns) {
    return;
  }
  if (columns < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + columns);
  }
  if (numColumns > columns) {
    for (int i=0; i < numRows; i++) {
      for (int j=numColumns - 1; j >= columns; j--) {
        removeCell(i,j);
      }
    }
  }
 else {
    for (int i=0; i < numRows; i++) {
      for (int j=numColumns; j < columns; j++) {
        insertCell(i,j);
      }
    }
  }
  numColumns=columns;
  getColumnFormatter().resizeColumnGroup(columns,false);
}"
82198,"/** 
 * Resize the column group element.
 * @param columns the number of columns
 */
void resizeColumnGroup(int columns){
  columns=Math.max(columns,1);
  int num=columnGroup.getChildCount();
  if (num < columns) {
    for (int i=num; i < columns; i++) {
      columnGroup.appendChild(Document.get().createColElement());
    }
  }
 else   if (num > columns) {
    for (int i=num; i > columns; i--) {
      columnGroup.removeChild(columnGroup.getLastChild());
    }
  }
}","/** 
 * Resize the column group element.
 * @param columns the number of columns
 * @param growOnly true to only grow, false to shrink if needed
 */
void resizeColumnGroup(int columns,boolean growOnly){
  columns=Math.max(columns,1);
  int num=columnGroup.getChildCount();
  if (num < columns) {
    for (int i=num; i < columns; i++) {
      columnGroup.appendChild(Document.get().createColElement());
    }
  }
 else   if (!growOnly && num > columns) {
    for (int i=num; i > columns; i--) {
      columnGroup.removeChild(columnGroup.getLastChild());
    }
  }
}"
82199,"private Element ensureColumn(int col){
  prepareColumn(col);
  prepareColumnGroup();
  resizeColumnGroup(col + 1);
  return columnGroup.getChild(col).cast();
}","private Element ensureColumn(int col){
  prepareColumn(col);
  prepareColumnGroup();
  resizeColumnGroup(col + 1,true);
  return columnGroup.getChild(col).cast();
}"
82200,"public void testColumnFormatterStyleName(){
  Grid r=new Grid(4,5);
  Grid.ColumnFormatter columns=r.getColumnFormatter();
  columns.setStyleName(0,""String_Node_Str"");
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.removeStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.removeStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  Element e=DOM.getChild(r.getElement(),0);
  assertEquals(1,DOM.getChildCount(e));
  columns.addStyleName(3,""String_Node_Str"");
  e=DOM.getChild(r.getElement(),0);
  assertEquals(4,DOM.getChildCount(e));
}","public void testColumnFormatterStyleName(){
  Grid r=new Grid(4,5);
  Grid.ColumnFormatter columns=r.getColumnFormatter();
  columns.setStyleName(0,""String_Node_Str"");
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.removeStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.removeStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  Element e=DOM.getChild(r.getElement(),0);
  assertEquals(5,DOM.getChildCount(e));
  columns.addStyleName(3,""String_Node_Str"");
  e=DOM.getChild(r.getElement(),0);
  assertEquals(5,DOM.getChildCount(e));
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  assertEquals(""String_Node_Str"",columns.getStyleName(3));
}"
82201,"/** 
 * Inform the views of the new data.
 * @param start the start index
 * @param length the length of the data
 * @param values the data values
 */
protected void updateViewData(int start,int length,List<T> values){
  int end=start + length;
  for (  DefaultListRegistration reg : registrations) {
    int curStart=reg.getStart();
    int curLength=reg.getLength();
    int curEnd=curStart + curLength;
    if (curStart < end && curEnd > start) {
      int realStart=curStart < start ? start : curStart;
      int realEnd=curEnd > end ? end : curEnd;
      int realLength=realEnd - realStart;
      List<T> realValues=values.subList(0,realLength);
      ListEvent<T> event=new ListEvent<T>(realStart,realLength,realValues);
      reg.getHandler().onDataChanged(event);
    }
  }
}","/** 
 * Inform the views of the new data.
 * @param start the start index
 * @param length the length of the data
 * @param values the data values
 */
protected void updateViewData(int start,int length,List<T> values){
  int end=start + length;
  for (  DefaultListRegistration reg : registrations) {
    int curStart=reg.getStart();
    int curLength=reg.getLength();
    int curEnd=curStart + curLength;
    if (curStart < end && curEnd > start) {
      int realStart=curStart < start ? start : curStart;
      int realEnd=curEnd > end ? end : curEnd;
      int realLength=realEnd - realStart;
      List<T> realValues=values.subList(realStart - start,realStart - start + realLength);
      ListEvent<T> event=new ListEvent<T>(realStart,realLength,realValues);
      reg.getHandler().onDataChanged(event);
    }
  }
}"
82202,"public void execute(){
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateDataSize(curSize,true);
  }
  if (modified) {
    int length=maxModified - minModified;
    updateViewData(minModified,length,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
  flushPending=false;
}","public void execute(){
  flushPending=false;
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateDataSize(curSize,true);
  }
  if (modified) {
    int length=maxModified - minModified;
    updateViewData(minModified,length,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
}"
82203,"@Override protected void moveSelectionUp(){
  if (isSuggestionListShowing()) {
    suggestionMenu.selectItem(suggestionMenu.getSelectedItemIndex() - 1);
  }
}","@Override protected void moveSelectionUp(){
  if (isSuggestionListShowing()) {
    if (suggestionMenu.getSelectedItemIndex() == -1) {
      suggestionMenu.selectItem(suggestionMenu.getNumItems() - 1);
    }
 else {
      suggestionMenu.selectItem(suggestionMenu.getSelectedItemIndex() - 1);
    }
  }
}"
82204,"@Override public synchronized void launchModule(String moduleName){
  String domain=""String_Node_Str"" + getLocalHostName() + ""String_Node_Str""+ shell.getPort()+ ""String_Node_Str"";
  for (  SeleniumWrapper remote : remotes) {
    try {
      String url=shell.getModuleUrl(moduleName);
      shell.getTopLogger().log(TreeLogger.TRACE,""String_Node_Str"" + domain + ""String_Node_Str""+ url);
      remote.createSelenium(domain);
      remote.getSelenium().start();
      remote.getSelenium().open(url);
    }
 catch (    Exception e) {
      shell.getTopLogger().log(TreeLogger.ERROR,""String_Node_Str"" + remote.getSpecifier(),e);
    }
  }
}","@Override public void launchModule(String moduleName){
  String domain=""String_Node_Str"" + getLocalHostName() + ""String_Node_Str""+ shell.getPort()+ ""String_Node_Str"";
synchronized (lock) {
    for (    SeleniumWrapper remote : remotes) {
      try {
        String url=shell.getModuleUrl(moduleName);
        shell.getTopLogger().log(TreeLogger.TRACE,""String_Node_Str"" + domain + ""String_Node_Str""+ url);
        remote.createSelenium(domain);
        remote.getSelenium().start();
        remote.getSelenium().open(url);
      }
 catch (      Exception e) {
        shell.getTopLogger().log(TreeLogger.ERROR,""String_Node_Str"" + remote.getSpecifier(),e);
      }
    }
  }
}"
82205,"private synchronized boolean doKeepAlives(){
  if (remotes != null) {
    for (    SeleniumWrapper remote : remotes) {
      try {
        if (remote.getSelenium() != null) {
          remote.getSelenium().getTitle();
        }
      }
 catch (      Throwable e) {
synchronized (wasInterruptedLock) {
          if (interruptedHosts == null) {
            interruptedHosts=new HashSet<String>();
          }
          interruptedHosts.add(remote.getSpecifier());
        }
      }
    }
  }
  return interruptedHosts == null;
}","private boolean doKeepAlives(){
synchronized (lock) {
    if (remotes != null) {
      if (stopped) {
        return false;
      }
      for (      SeleniumWrapper remote : remotes) {
        try {
          if (remote.getSelenium() != null) {
            remote.getSelenium().getTitle();
          }
        }
 catch (        Throwable e) {
          String message=e.getMessage();
          if (message != null && message.toLowerCase().contains(""String_Node_Str"")) {
            if (interruptedHosts == null) {
              interruptedHosts=new HashSet<String>();
            }
            interruptedHosts.add(remote.getSpecifier());
          }
        }
      }
    }
    return interruptedHosts == null;
  }
}"
82206,"@Override public String[] getInterruptedHosts(){
synchronized (wasInterruptedLock) {
    if (interruptedHosts == null) {
      return null;
    }
    return interruptedHosts.toArray(new String[interruptedHosts.size()]);
  }
}","@Override public String[] getInterruptedHosts(){
synchronized (lock) {
    if (interruptedHosts == null) {
      return null;
    }
    return interruptedHosts.toArray(new String[interruptedHosts.size()]);
  }
}"
82207,"@Override public int initialize(String args){
  if (args == null || args.length() == 0) {
    getLogger().log(TreeLogger.ERROR,""String_Node_Str"");
    return -1;
  }
  String[] targetsIn=args.split(""String_Node_Str"");
  SeleniumWrapper targets[]=new SeleniumWrapper[targetsIn.length];
  for (int i=0; i < targets.length; ++i) {
    try {
      targets[i]=createSeleniumWrapper(targetsIn[i]);
    }
 catch (    IllegalArgumentException e) {
      getLogger().log(TreeLogger.ERROR,e.getMessage());
      return -1;
    }
  }
  this.remotes=targets;
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      for (      SeleniumWrapper remote : remotes) {
        if (remote.getSelenium() != null) {
          try {
            remote.getSelenium().stop();
          }
 catch (          SeleniumException se) {
            shell.getTopLogger().log(TreeLogger.WARN,""String_Node_Str"",se);
          }
        }
      }
    }
  }
);
  start();
  return targets.length;
}","@Override public int initialize(String args){
  if (args == null || args.length() == 0) {
    getLogger().log(TreeLogger.ERROR,""String_Node_Str"");
    return -1;
  }
  String[] targetsIn=args.split(""String_Node_Str"");
  SeleniumWrapper targets[]=new SeleniumWrapper[targetsIn.length];
  for (int i=0; i < targets.length; ++i) {
    try {
      targets[i]=createSeleniumWrapper(targetsIn[i]);
    }
 catch (    IllegalArgumentException e) {
      getLogger().log(TreeLogger.ERROR,e.getMessage());
      return -1;
    }
  }
  this.remotes=targets;
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
synchronized (lock) {
        stopped=true;
        for (        SeleniumWrapper remote : remotes) {
          if (remote.getSelenium() != null) {
            try {
              remote.getSelenium().stop();
            }
 catch (            SeleniumException se) {
              shell.getTopLogger().log(TreeLogger.WARN,""String_Node_Str"",se);
            }
          }
        }
      }
    }
  }
);
  start();
  return targets.length;
}"
82208,"/** 
 * Intended to be used to pull the value out of a CSS length. We rely on the behavior of parseFloat to ignore non-numeric chars in its input. If the value is ""auto"" or ""inherit"", 0 will be returned.
 * @param s The CSS length string to extract
 * @return The leading numeric portion of <code>s</code>, or 0 if ""auto"" or""inherit"" are passed in.
 */
private native double extractLengthValue(String s);","/** 
 * Intended to be used to pull the value out of a CSS length. If the value is ""auto"" or ""inherit"", 0 will be returned.
 * @param s The CSS length string to extract
 * @return The leading numeric portion of <code>s</code>, or 0 if ""auto"" or""inherit"" are passed in.
 */
private native double extractLengthValue(String s);"
82209,"public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
}","public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
}"
82210,"public void testBadStrings(){
  try {
    new Double(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}","public void testBadStrings(){
  try {
    new Double(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}"
82211,"public void onSizeChanged(SizeChangeEvent event){
  int size=event.getSize();
  if (size > maxSize) {
    showMoreElem.getStyle().clearDisplay();
  }
 else {
    showMoreElem.getStyle().setDisplay(Display.NONE);
  }
  int dataSize=data.size();
  if (size < dataSize) {
    while (size < dataSize) {
      data.remove(dataSize - 1);
      dataSize--;
    }
  }
 else {
    data.ensureCapacity(size);
    while (dataSize < size) {
      data.add(null);
      dataSize++;
    }
  }
  gc(size);
}","public void onSizeChanged(SizeChangeEvent event){
  size=event.getSize();
  showOrHide(showMoreElem,size > maxSize);
  showOrHide(showFewerElem,maxSize > initialMaxSize);
}"
82212,"@Override protected void onLoad(){
  super.onLoad();
  this.reg=model.addListHandler(new ListHandler<T>(){
    public void onDataChanged(    ListEvent<T> event){
      int start=event.getStart(), len=event.getLength();
      List<T> values=event.getValues();
      for (int i=0; i < len; ++i) {
        data.set(start + i,values.get(i));
      }
      render(start,len,values);
    }
    public void onSizeChanged(    SizeChangeEvent event){
      int size=event.getSize();
      if (size > maxSize) {
        showMoreElem.getStyle().clearDisplay();
      }
 else {
        showMoreElem.getStyle().setDisplay(Display.NONE);
      }
      int dataSize=data.size();
      if (size < dataSize) {
        while (size < dataSize) {
          data.remove(dataSize - 1);
          dataSize--;
        }
      }
 else {
        data.ensureCapacity(size);
        while (dataSize < size) {
          data.add(null);
          dataSize++;
        }
      }
      gc(size);
    }
  }
);
  reg.setRangeOfInterest(0,maxSize);
}","@Override protected void onLoad(){
  super.onLoad();
  this.reg=model.addListHandler(new ListHandler<T>(){
    public void onDataChanged(    ListEvent<T> event){
      int start=event.getStart();
      int len=event.getLength();
      List<T> values=event.getValues();
      StringBuilder sb=new StringBuilder();
      for (int i=0; i < len; i++) {
        sb.append(""String_Node_Str"" + (start + i) + ""String_Node_Str""+ seq+++ ""String_Node_Str"");
        cell.render(values.get(i),null,sb);
        sb.append(""String_Node_Str"");
      }
      Element parent=getElement().getFirstChildElement();
      if (start == 0 && len == maxSize) {
        parent.setInnerHTML(sb.toString());
      }
 else {
        makeElements();
        tmpElem.setInnerHTML(sb.toString());
        for (int i=0; i < len; i++) {
          Element child=parent.getChild(start + i).cast();
          parent.replaceChild(tmpElem.getChild(0),child);
        }
      }
    }
    public void onSizeChanged(    SizeChangeEvent event){
      size=event.getSize();
      showOrHide(showMoreElem,size > maxSize);
      showOrHide(showFewerElem,maxSize > initialMaxSize);
    }
    private void makeElements(){
      Element parent=getElement().getFirstChildElement();
      int childCount=parent.getChildCount();
      int actualSize=Math.min(size,maxSize);
      if (actualSize > childCount) {
        StringBuilder sb=new StringBuilder();
        int newElements=actualSize - childCount;
        for (int i=0; i < newElements; i++) {
          sb.append(""String_Node_Str"" + (childCount + i) + ""String_Node_Str"");
        }
        if (childCount == 0) {
          parent.setInnerHTML(sb.toString());
        }
 else {
          tmpElem.setInnerHTML(sb.toString());
          for (int i=0; i < newElements; i++) {
            parent.appendChild(tmpElem.getChild(0));
          }
        }
      }
 else       if (actualSize < childCount) {
        while (actualSize < childCount) {
          parent.getChild(--childCount).removeFromParent();
        }
      }
    }
  }
);
  reg.setRangeOfInterest(0,maxSize);
}"
82213,"public SimpleCellList(ListModel<T> model,Cell<T,Void> cell,int maxSize,int increment){
  this.maxSize=maxSize;
  this.increment=increment;
  this.model=model;
  this.cell=cell;
  tmpElem=Document.get().createDivElement();
  showMoreElem=Document.get().createDivElement();
  showMoreElem.setInnerHTML(""String_Node_Str"" + increment + ""String_Node_Str"");
  showMoreElem.getStyle().setDisplay(Display.NONE);
  DivElement outerDiv=Document.get().createDivElement();
  DivElement innerDiv=Document.get().createDivElement();
  outerDiv.appendChild(innerDiv);
  outerDiv.appendChild(showMoreElem);
  setElement(outerDiv);
  sinkEvents(Event.ONCLICK);
  sinkEvents(Event.ONCHANGE);
}","public SimpleCellList(ListModel<T> model,Cell<T,Void> cell,int maxSize,int increment){
  this.initialMaxSize=this.maxSize=maxSize;
  this.increment=increment;
  this.model=model;
  this.cell=cell;
  this.seq=0;
  tmpElem=Document.get().createDivElement();
  showMoreElem=Document.get().createDivElement();
  showMoreElem.setInnerHTML(""String_Node_Str"");
  showFewerElem=Document.get().createDivElement();
  showFewerElem.setInnerHTML(""String_Node_Str"");
  showOrHide(showMoreElem,false);
  showOrHide(showFewerElem,false);
  DivElement outerDiv=Document.get().createDivElement();
  DivElement innerDiv=Document.get().createDivElement();
  outerDiv.appendChild(innerDiv);
  outerDiv.appendChild(showFewerElem);
  outerDiv.appendChild(showMoreElem);
  setElement(outerDiv);
  sinkEvents(Event.ONCLICK);
  sinkEvents(Event.ONCHANGE);
}"
82214,"@Override public void onBrowserEvent(Event event){
  Element target=event.getEventTarget().cast();
  String idxString=""String_Node_Str"";
  while ((target != null) && ((idxString=target.getAttribute(""String_Node_Str"")).length() == 0)) {
    target=target.getParentElement();
  }
  if (idxString.length() > 0) {
    int idx=Integer.parseInt(idxString);
    cell.onBrowserEvent(target,data.get(idx),null,event,valueUpdater);
  }
}","@Override public void onBrowserEvent(Event event){
  Element target=event.getEventTarget().cast();
  if (target.getParentElement() == showMoreElem) {
    this.maxSize+=increment;
    reg.setRangeOfInterest(0,maxSize);
  }
 else   if (target.getParentElement() == showFewerElem) {
    this.maxSize=Math.max(initialMaxSize,maxSize - increment);
    reg.setRangeOfInterest(0,maxSize);
  }
 else {
    String idxString=""String_Node_Str"";
    while ((target != null) && ((idxString=target.getAttribute(""String_Node_Str"")).length() == 0)) {
      target=target.getParentElement();
    }
    if (idxString.length() > 0) {
      int idx=Integer.parseInt(idxString);
      cell.onBrowserEvent(target,data.get(idx),null,event,valueUpdater);
    }
  }
}"
82215,"public void onDataChanged(ListEvent<T> event){
  int start=event.getStart(), len=event.getLength();
  List<T> values=event.getValues();
  for (int i=0; i < len; ++i) {
    data.set(start + i,values.get(i));
  }
  render(start,len,values);
}","public void onDataChanged(ListEvent<T> event){
  int start=event.getStart();
  int len=event.getLength();
  List<T> values=event.getValues();
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < len; i++) {
    sb.append(""String_Node_Str"" + (start + i) + ""String_Node_Str""+ seq+++ ""String_Node_Str"");
    cell.render(values.get(i),null,sb);
    sb.append(""String_Node_Str"");
  }
  Element parent=getElement().getFirstChildElement();
  if (start == 0 && len == maxSize) {
    parent.setInnerHTML(sb.toString());
  }
 else {
    makeElements();
    tmpElem.setInnerHTML(sb.toString());
    for (int i=0; i < len; i++) {
      Element child=parent.getChild(start + i).cast();
      parent.replaceChild(tmpElem.getChild(0),child);
    }
  }
}"
82216,"public boolean remove(Object o){
  return flush(list.remove(o));
}","public boolean remove(Object o){
  int index=indexOf(o);
  if (index == -1) {
    return false;
  }
  remove(index);
  return true;
}"
82217,"public boolean removeAll(Collection<?> c){
  return flush(list.removeAll(c));
}","public boolean removeAll(Collection<?> c){
  boolean toRet=list.removeAll(c);
  minModified=0;
  maxModified=size();
  modified=true;
  return flush(toRet);
}"
82218,"public boolean add(T e){
  return flush(list.add(e));
}","public boolean add(T e){
  boolean toRet=list.add(e);
  minModified=Math.min(minModified,size() - 1);
  maxModified=size();
  modified=true;
  return flush(toRet);
}"
82219,"public T set(int index,T element){
  T toRet=list.set(index,element);
  flush();
  return toRet;
}","public T set(int index,T element){
  T toRet=list.set(index,element);
  minModified=Math.min(minModified,index);
  maxModified=Math.max(maxModified,index + 1);
  modified=true;
  flush();
  return toRet;
}"
82220,"public void clear(){
  list.clear();
  flush();
}","public void clear(){
  list.clear();
  minModified=maxModified=0;
  modified=true;
  flush();
}"
82221,"public ListWrapper(List<T> list){
  this.list=list;
}","public ListWrapper(List<T> list){
  this.list=list;
  minModified=0;
  maxModified=list.size();
  modified=true;
}"
82222,"public void execute(){
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateDataSize(curSize,true);
  }
  updateViewData(0,list.size(),list);
  flushPending=false;
}","public void execute(){
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateDataSize(curSize,true);
  }
  if (modified) {
    int length=maxModified - minModified;
    updateViewData(minModified,length,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
  flushPending=false;
}"
82223,"public boolean addAll(int index,Collection<? extends T> c){
  return flush(list.addAll(index,c));
}","public boolean addAll(int index,Collection<? extends T> c){
  try {
    boolean toRet=list.addAll(index,c);
    minModified=Math.min(minModified,index);
    maxModified=size();
    modified=true;
    return flush(toRet);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new IndexOutOfBoundsException(e.getMessage());
  }
}"
82224,"public boolean retainAll(Collection<?> c){
  return flush(list.retainAll(c));
}","public boolean retainAll(Collection<?> c){
  boolean toRet=list.retainAll(c);
  minModified=0;
  maxModified=size();
  modified=true;
  return flush(toRet);
}"
82225,"public void execute(){
  p.animate(100,new AnimationCallback(){
    public void onLayout(    Layer layer,    double progress){
    }
    public void onAnimationComplete(){
      finishTest();
    }
  }
);
}","public void execute(){
  int offsetWidth=lp.getOffsetWidth();
  int offsetHeight=lp.getOffsetHeight();
  assertTrue(offsetWidth > 0);
  assertTrue(offsetHeight > 0);
  finishTest();
}"
82226,"@Override public void render(String value,StringBuilder sb){
  sb.append(""String_Node_Str"");
  if (value.charAt(0) == '-') {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(value);
  sb.append(""String_Node_Str"");
}","@Override public void render(String value,StringBuilder sb){
  if (value == null || value.length() == 0) {
    return;
  }
  sb.append(""String_Node_Str"");
  if (value.charAt(0) == '-') {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(value);
  sb.append(""String_Node_Str"");
}"
82227,"@Override public void render(String value,StringBuilder sb){
  sb.append(""String_Node_Str"");
  if (highlightRegex == null || highlightRegex.length() == 0) {
    sb.append(value);
    sb.append(""String_Node_Str"");
    return;
  }
  RegExp regExp=RegExp.compile(highlightRegex,""String_Node_Str"");
  int fromIndex=0;
  int length=value.length();
  MatchResult result;
  while (fromIndex < length) {
    result=regExp.exec(value);
    if (result == null) {
      break;
    }
    int index=result.getIndex();
    String match=result.getGroup(0);
    sb.append(value.substring(fromIndex,index));
    sb.append(""String_Node_Str"");
    sb.append(match);
    sb.append(""String_Node_Str"");
    fromIndex=index + match.length();
    regExp.setLastIndex(fromIndex);
  }
  if (fromIndex < length) {
    sb.append(value.substring(fromIndex));
  }
  sb.append(""String_Node_Str"");
}","@Override public void render(String value,StringBuilder sb){
  sb.append(""String_Node_Str"");
  if (highlightRegex == null) {
    sb.append(value);
    sb.append(""String_Node_Str"");
    return;
  }
  int fromIndex=0;
  int length=value.length();
  MatchResult result;
  highlightRegex.setLastIndex(0);
  while (fromIndex < length) {
    result=highlightRegex.exec(value);
    if (result == null) {
      break;
    }
    int index=result.getIndex();
    String match=result.getGroup(0);
    sb.append(value.substring(fromIndex,index));
    sb.append(""String_Node_Str"");
    sb.append(match);
    sb.append(""String_Node_Str"");
    fromIndex=index + match.length();
    highlightRegex.setLastIndex(fromIndex);
  }
  if (fromIndex < length) {
    sb.append(value.substring(fromIndex));
  }
  sb.append(""String_Node_Str"");
}"
82228,"public void setHighlightRegex(String highlightRegex){
  this.highlightRegex=highlightRegex;
}","public void setHighlightRegex(String highlightText){
  if (highlightText != null && highlightText.length() > 0) {
    highlightRegex=RegExp.compile(highlightText,""String_Node_Str"");
  }
 else {
    highlightRegex=null;
  }
}"
82229,"private Result getQuotes(SortedSet<String> symbols,Range range){
  int start=range.getStart();
  int end=Math.min(start + range.getLength(),symbols.size());
  if (end <= start) {
    return new Result(new StockQuoteList(0),0);
  }
  SortedSet<String> symbolsInRange=new TreeSet<String>();
  int idx=0;
  for (  String symbol : symbols) {
    if (idx >= start && idx < end) {
      symbolsInRange.add(symbol);
    }
    idx++;
  }
  SortedSet<String> symbolsToQuery=new TreeSet<String>();
  long now=System.currentTimeMillis();
  for (  String symbol : symbolsInRange) {
    Quote quote=QUOTES.get(symbol);
    if (quote == null || now - quote.getCreatedTime() >= 5000) {
      symbolsToQuery.add(symbol);
    }
 else {
    }
  }
  if (symbolsToQuery.size() > 0) {
    GoogleFinance.queryServer(symbolsToQuery,QUOTES);
  }
  StockQuoteList toRet=new StockQuoteList(start);
  for (  String symbol : symbolsInRange) {
    Quote quote=QUOTES.get(symbol);
    if (quote == null) {
      System.out.println(""String_Node_Str"" + symbol);
    }
 else {
      String name=Stocks.companyNamesBySymbol.get(symbol);
      PlayerStatus player=ensurePlayer();
      Integer sharesOwned=player.getSharesOwned(symbol);
      boolean favorite=player.isFavorite(symbol);
      int totalPaid=player.getAverageCostBasis(symbol);
      toRet.add(new StockQuote(symbol,name,quote.getPrice(),quote.getChange(),sharesOwned == null ? 0 : sharesOwned.intValue(),favorite,totalPaid));
    }
  }
  return new Result(toRet,symbols.size());
}","private Result getQuotes(SortedSet<String> symbols,Range range){
  int start=range.getStart();
  int end=Math.min(start + range.getLength(),symbols.size());
  if (end <= start) {
    return new Result(new StockQuoteList(0),0);
  }
  SortedSet<String> symbolsInRange=new TreeSet<String>();
  int idx=0;
  for (  String symbol : symbols) {
    if (idx >= start && idx < end) {
      symbolsInRange.add(symbol);
    }
    idx++;
  }
  SortedSet<String> symbolsToQuery=new TreeSet<String>();
  long now=System.currentTimeMillis();
  for (  String symbol : symbolsInRange) {
    Quote quote=QUOTES.get(symbol);
    if (quote == null || now - quote.getCreatedTime() >= 5000) {
      symbolsToQuery.add(symbol);
    }
 else {
    }
  }
  if (symbolsToQuery.size() > 0) {
    GoogleFinance.queryServer(symbolsToQuery,QUOTES);
  }
  StockQuoteList toRet=new StockQuoteList(start);
  for (  String symbol : symbolsInRange) {
    Quote quote=QUOTES.get(symbol);
    if (quote == null) {
      System.out.println(""String_Node_Str"" + symbol);
    }
 else {
      String name=Stocks.companyNamesBySymbol.get(symbol);
      PlayerStatus player=ensurePlayer();
      Integer sharesOwned=player.getSharesOwned(symbol);
      boolean favorite=player.isFavorite(symbol);
      int totalPaid=player.getAverageCostBasis(symbol);
      toRet.add(new StockQuote(symbol,name,quote.getPrice(),quote.getChange(),sharesOwned == null ? 0 : sharesOwned.intValue(),favorite,totalPaid));
    }
  }
  return new Result(toRet,toRet.size());
}"
82230,"private Result getSearchQuotes(String query,Range searchRange){
  SortedSet<String> symbols=new TreeSet<String>();
  boolean queryIsAlpha=true;
  for (int i=0; i < query.length(); i++) {
    char c=query.charAt(i);
    if ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) {
      queryIsAlpha=false;
      break;
    }
  }
  query=query.toUpperCase(Locale.US);
  if (queryIsAlpha) {
    getTickersByPrefix(query,symbols);
  }
  Pattern pattern=compile(""String_Node_Str"" + query + ""String_Node_Str"");
  if (pattern != null) {
    if (!queryIsAlpha) {
      getTickersBySymbolRegex(pattern,symbols);
    }
    getTickersByNameRegex(pattern,symbols);
  }
  return getQuotes(symbols,searchRange);
}","private Result getSearchQuotes(String query,Range searchRange){
  SortedSet<String> symbols=new TreeSet<String>();
  boolean queryIsAlpha=true;
  for (int i=0; i < query.length(); i++) {
    char c=query.charAt(i);
    if ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) {
      queryIsAlpha=false;
      break;
    }
  }
  query=query.toUpperCase(Locale.US);
  if (queryIsAlpha) {
    getTickersByPrefix(query,symbols);
  }
  Pattern pattern=compile(""String_Node_Str"" + query + ""String_Node_Str"");
  if (pattern != null) {
    if (!queryIsAlpha) {
      getTickersBySymbolRegex(pattern,symbols);
    }
    if (query.length() > 2) {
      getTickersByNameRegex(pattern,symbols);
    }
  }
  return getQuotes(symbols,searchRange);
}"
82231,"/** 
 * Testing for public void java.util.Date.setHours(int). 
 */
public void testSetHours(){
  for (int i=0; i < 24; i++) {
    Date accum0=create();
    accum0.setHours(i);
    assertEquals(accum0.getHours(),i);
  }
}","/** 
 * Testing for public void java.util.Date.setHours(int). 
 */
public void testSetHours(){
  for (int i=0; i < 24; i++) {
    Date accum0=create();
    if (isDst(accum0)) {
      return;
    }
    accum0.setHours(i);
    assertEquals(accum0.getHours(),i);
  }
}"
82232,"/** 
 * Returns the precision of this   {@code BigDecimal}. The precision is the number of decimal digits used to represent this decimal. It is equivalent to the number of digits of the unscaled value. The precision of   {@code 0}is   {@code 1} (independent of the scale).
 * @return the precision of this {@code BigDecimal}.
 */
public int precision(){
  if (precision > 0) {
    return precision;
  }
  int decimalDigits=1;
  double doubleUnsc=1;
  if (bitLength < 1024) {
    if (bitLength >= 54) {
      doubleUnsc=getUnscaledValue().doubleValue();
    }
 else     if (bitLength >= 1) {
      doubleUnsc=smallValue;
    }
    decimalDigits+=(int)Math.log10(Math.abs(doubleUnsc));
  }
 else {
    decimalDigits+=(bitLength - 1) * LOG10_2;
    if (getUnscaledValue().divide(Multiplication.powerOf10(decimalDigits)).signum() != 0) {
      decimalDigits++;
    }
  }
  precision=decimalDigits;
  return precision;
}","/** 
 * Returns the precision of this   {@code BigDecimal}. The precision is the number of decimal digits used to represent this decimal. It is equivalent to the number of digits of the unscaled value. The precision of   {@code 0}is   {@code 1} (independent of the scale).
 * @return the precision of this {@code BigDecimal}.
 */
public int precision(){
  if (precision > 0) {
    return precision;
  }
  double decimalDigits=1;
  double doubleUnsc=1;
  if (bitLength < SMALL_VALUE_BITS) {
    if (bitLength >= 1) {
      doubleUnsc=smallValue;
    }
    decimalDigits+=Math.log10(Math.abs(doubleUnsc));
  }
 else {
    decimalDigits+=(bitLength - 1) * LOG10_2;
    if (getUnscaledValue().divide(Multiplication.powerOf10(decimalDigits)).signum() != 0) {
      decimalDigits++;
    }
  }
  precision=(int)decimalDigits;
  return precision;
}"
82233,"private static BigDecimal addAndMult10(BigDecimal thisValue,BigDecimal augend,double diffScale){
  if (diffScale < DOUBLE_TEN_POW.length && Math.max(thisValue.bitLength,augend.bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)diffScale]) + 1 < 54) {
    return valueOf(thisValue.smallValue + augend.smallValue * DOUBLE_TEN_POW[(int)diffScale],thisValue.scale);
  }
  return new BigDecimal(thisValue.getUnscaledValue().add(Multiplication.multiplyByTenPow(augend.getUnscaledValue(),(int)diffScale)),thisValue.scale);
}","private static BigDecimal addAndMult10(BigDecimal thisValue,BigDecimal augend,double diffScale){
  if (diffScale < DOUBLE_TEN_POW.length && Math.max(thisValue.bitLength,augend.bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)diffScale]) + 1 < SMALL_VALUE_BITS) {
    return valueOf(thisValue.smallValue + augend.smallValue * DOUBLE_TEN_POW[(int)diffScale],thisValue.scale);
  }
  return new BigDecimal(thisValue.getUnscaledValue().add(Multiplication.multiplyByTenPow(augend.getUnscaledValue(),(int)diffScale)),thisValue.scale);
}"
82234,"/** 
 * Compares this   {@code BigDecimal} with {@code val}. Returns one of the three values   {@code 1},   {@code 0}, or   {@code -1}. The method behaves as if  {@code this.subtract(val)} is computed. If this difference is > 0 then 1 isreturned, if the difference is < 0 then -1 is returned, and if the difference is 0 then 0 is returned. This means, that if two decimal instances are compared which are equal in value but differ in scale, then these two instances are considered as equal.
 * @param val value to be compared with {@code this}.
 * @return {@code 1} if {@code this > val},   {@code -1} if {@code this < val},  {@code 0} if {@code this == val}.
 * @throws NullPointerException if {@code val == null}.
 */
public int compareTo(BigDecimal val){
  int thisSign=signum();
  int valueSign=val.signum();
  if (thisSign == valueSign) {
    if (this.scale == val.scale && this.bitLength < 54 && val.bitLength < 54) {
      return (smallValue < val.smallValue) ? -1 : (smallValue > val.smallValue) ? 1 : 0;
    }
    double diffScale=this.scale - val.scale;
    double diffPrecision=this.approxPrecision() - val.approxPrecision();
    if (diffPrecision > diffScale + 1) {
      return thisSign;
    }
 else     if (diffPrecision < diffScale - 1) {
      return -thisSign;
    }
 else {
      BigInteger thisUnscaled=this.getUnscaledValue();
      BigInteger valUnscaled=val.getUnscaledValue();
      if (diffScale < 0) {
        thisUnscaled=thisUnscaled.multiply(Multiplication.powerOf10(-diffScale));
      }
 else       if (diffScale > 0) {
        valUnscaled=valUnscaled.multiply(Multiplication.powerOf10(diffScale));
      }
      return thisUnscaled.compareTo(valUnscaled);
    }
  }
 else   if (thisSign < valueSign) {
    return -1;
  }
 else {
    return 1;
  }
}","/** 
 * Compares this   {@code BigDecimal} with {@code val}. Returns one of the three values   {@code 1},   {@code 0}, or   {@code -1}. The method behaves as if  {@code this.subtract(val)} is computed. If this difference is > 0 then 1 isreturned, if the difference is < 0 then -1 is returned, and if the difference is 0 then 0 is returned. This means, that if two decimal instances are compared which are equal in value but differ in scale, then these two instances are considered as equal.
 * @param val value to be compared with {@code this}.
 * @return {@code 1} if {@code this > val},   {@code -1} if {@code this < val},  {@code 0} if {@code this == val}.
 * @throws NullPointerException if {@code val == null}.
 */
public int compareTo(BigDecimal val){
  int thisSign=signum();
  int valueSign=val.signum();
  if (thisSign == valueSign) {
    if (this.scale == val.scale && this.bitLength < SMALL_VALUE_BITS && val.bitLength < SMALL_VALUE_BITS) {
      return (smallValue < val.smallValue) ? -1 : (smallValue > val.smallValue) ? 1 : 0;
    }
    double diffScale=this.scale - val.scale;
    double diffPrecision=this.approxPrecision() - val.approxPrecision();
    if (diffPrecision > diffScale + 1) {
      return thisSign;
    }
 else     if (diffPrecision < diffScale - 1) {
      return -thisSign;
    }
 else {
      BigInteger thisUnscaled=this.getUnscaledValue();
      BigInteger valUnscaled=val.getUnscaledValue();
      if (diffScale < 0) {
        thisUnscaled=thisUnscaled.multiply(Multiplication.powerOf10(-diffScale));
      }
 else       if (diffScale > 0) {
        valUnscaled=valUnscaled.multiply(Multiplication.powerOf10(diffScale));
      }
      return thisUnscaled.compareTo(valUnscaled);
    }
  }
 else   if (thisSign < valueSign) {
    return -1;
  }
 else {
    return 1;
  }
}"
82235,"/** 
 * Returns the sign of this   {@code BigDecimal}.
 * @return {@code -1} if {@code this < 0},   {@code 0} if {@code this == 0},  {@code 1} if {@code this > 0}.
 */
public int signum(){
  if (bitLength < 54) {
    return this.smallValue < 0 ? -1 : this.smallValue > 0 ? 1 : 0;
  }
  return getUnscaledValue().signum();
}","/** 
 * Returns the sign of this   {@code BigDecimal}.
 * @return {@code -1} if {@code this < 0},   {@code 0} if {@code this == 0},  {@code 1} if {@code this > 0}.
 */
public int signum(){
  if (bitLength < SMALL_VALUE_BITS) {
    return this.smallValue < 0 ? -1 : this.smallValue > 0 ? 1 : 0;
  }
  return getUnscaledValue().signum();
}"
82236,"/** 
 * It does all rounding work of the public method   {@code round(MathContext)}, performing an inplace rounding without creating a new object.
 * @param mc the {@code MathContext} for perform the rounding.
 * @see #round(MathContext)
 */
private void inplaceRound(MathContext mc){
  int mcPrecision=mc.getPrecision();
  if (approxPrecision() - mcPrecision <= 0 || mcPrecision == 0) {
    return;
  }
  int discardedPrecision=precision() - mcPrecision;
  if ((discardedPrecision <= 0)) {
    return;
  }
  if (this.bitLength < 54) {
    smallRound(mc,discardedPrecision);
    return;
  }
  BigInteger sizeOfFraction=Multiplication.powerOf10(discardedPrecision);
  BigInteger[] integerAndFraction=getUnscaledValue().divideAndRemainder(sizeOfFraction);
  double newScale=scale - discardedPrecision;
  int compRem;
  BigDecimal tempBD;
  if (integerAndFraction[1].signum() != 0) {
    compRem=(integerAndFraction[1].abs().shiftLeftOneBit().compareTo(sizeOfFraction));
    compRem=roundingBehavior(integerAndFraction[0].testBit(0) ? 1 : 0,integerAndFraction[1].signum() * (5 + compRem),mc.getRoundingMode());
    if (compRem != 0) {
      integerAndFraction[0]=integerAndFraction[0].add(BigInteger.valueOf(compRem));
    }
    tempBD=new BigDecimal(integerAndFraction[0]);
    if (tempBD.precision() > mcPrecision) {
      integerAndFraction[0]=integerAndFraction[0].divide(BigInteger.TEN);
      newScale--;
    }
  }
  scale=toIntScale(newScale);
  precision=mcPrecision;
  setUnscaledValue(integerAndFraction[0]);
}","/** 
 * It does all rounding work of the public method   {@code round(MathContext)}, performing an inplace rounding without creating a new object.
 * @param mc the {@code MathContext} for perform the rounding.
 * @see #round(MathContext)
 */
private void inplaceRound(MathContext mc){
  int mcPrecision=mc.getPrecision();
  if (approxPrecision() - mcPrecision < 0 || mcPrecision == 0) {
    return;
  }
  int discardedPrecision=precision() - mcPrecision;
  if ((discardedPrecision <= 0)) {
    return;
  }
  if (this.bitLength < SMALL_VALUE_BITS) {
    smallRound(mc,discardedPrecision);
    return;
  }
  BigInteger sizeOfFraction=Multiplication.powerOf10(discardedPrecision);
  BigInteger[] integerAndFraction=getUnscaledValue().divideAndRemainder(sizeOfFraction);
  double newScale=scale - discardedPrecision;
  int compRem;
  BigDecimal tempBD;
  if (integerAndFraction[1].signum() != 0) {
    compRem=(integerAndFraction[1].abs().shiftLeftOneBit().compareTo(sizeOfFraction));
    compRem=roundingBehavior(integerAndFraction[0].testBit(0) ? 1 : 0,integerAndFraction[1].signum() * (5 + compRem),mc.getRoundingMode());
    if (compRem != 0) {
      integerAndFraction[0]=integerAndFraction[0].add(BigInteger.valueOf(compRem));
    }
    tempBD=new BigDecimal(integerAndFraction[0]);
    if (tempBD.precision() > mcPrecision) {
      integerAndFraction[0]=integerAndFraction[0].divide(BigInteger.TEN);
      newScale--;
    }
  }
  scale=toIntScale(newScale);
  precision=mcPrecision;
  setUnscaledValue(integerAndFraction[0]);
}"
82237,"private void initFrom(String val){
  int begin=0;
  int offset=0;
  int last=val.length() - 1;
  String scaleString=null;
  StringBuilder unscaledBuffer;
  if (val == null) {
    throw new NullPointerException();
  }
  unscaledBuffer=new StringBuilder(val.length());
  if ((offset <= last) && (val.charAt(offset) == '+')) {
    offset++;
    begin++;
  }
  int counter=0;
  boolean wasNonZero=false;
  for (; (offset <= last) && (val.charAt(offset) != '.') && (val.charAt(offset) != 'e')&& (val.charAt(offset) != 'E'); offset++) {
    if (!wasNonZero) {
      if (val.charAt(offset) == '0') {
        counter++;
      }
 else {
        wasNonZero=true;
      }
    }
  }
  unscaledBuffer.append(val,begin,offset);
  if ((offset <= last) && (val.charAt(offset) == '.')) {
    offset++;
    begin=offset;
    for (; (offset <= last) && (val.charAt(offset) != 'e') && (val.charAt(offset) != 'E'); offset++) {
      if (!wasNonZero) {
        if (val.charAt(offset) == '0') {
          counter++;
        }
 else {
          wasNonZero=true;
        }
      }
    }
    scale=offset - begin;
    unscaledBuffer.append(val,begin,offset);
  }
 else {
    scale=0;
  }
  if ((offset <= last) && ((val.charAt(offset) == 'e') || (val.charAt(offset) == 'E'))) {
    offset++;
    begin=offset;
    if ((offset <= last) && (val.charAt(offset) == '+')) {
      offset++;
      if ((offset <= last) && (val.charAt(offset) != '-')) {
        begin++;
      }
    }
    scaleString=val.substring(begin,last + 1);
    scale=scale - Integer.parseInt(scaleString);
    if (scale != (int)scale) {
      throw new NumberFormatException(""String_Node_Str"");
    }
  }
  String unscaled=unscaledBuffer.toString();
  if (unscaled.length() < 16) {
    smallValue=parseUnscaled(unscaled);
    if (Double.isNaN(smallValue)) {
      throw new NumberFormatException(""String_Node_Str"" + val + ""String_Node_Str"");
    }
    bitLength=bitLength(smallValue);
  }
 else {
    setUnscaledValue(new BigInteger(unscaled));
  }
  precision=unscaledBuffer.length() - counter;
  if (unscaledBuffer.charAt(0) == '-') {
    precision--;
  }
}","private void initFrom(String val){
  int begin=0;
  int offset=0;
  int last=val.length() - 1;
  String scaleString=null;
  StringBuilder unscaledBuffer;
  unscaledBuffer=new StringBuilder(val.length());
  if ((offset <= last) && (val.charAt(offset) == '+')) {
    offset++;
    begin++;
  }
  int counter=0;
  boolean wasNonZero=false;
  for (; (offset <= last) && (val.charAt(offset) != '.') && (val.charAt(offset) != 'e')&& (val.charAt(offset) != 'E'); offset++) {
    if (!wasNonZero) {
      if (val.charAt(offset) == '0') {
        counter++;
      }
 else {
        wasNonZero=true;
      }
    }
  }
  unscaledBuffer.append(val,begin,offset);
  if ((offset <= last) && (val.charAt(offset) == '.')) {
    offset++;
    begin=offset;
    for (; (offset <= last) && (val.charAt(offset) != 'e') && (val.charAt(offset) != 'E'); offset++) {
      if (!wasNonZero) {
        if (val.charAt(offset) == '0') {
          counter++;
        }
 else {
          wasNonZero=true;
        }
      }
    }
    scale=offset - begin;
    unscaledBuffer.append(val,begin,offset);
  }
 else {
    scale=0;
  }
  if ((offset <= last) && ((val.charAt(offset) == 'e') || (val.charAt(offset) == 'E'))) {
    offset++;
    begin=offset;
    if ((offset <= last) && (val.charAt(offset) == '+')) {
      offset++;
      if ((offset <= last) && (val.charAt(offset) != '-')) {
        begin++;
      }
    }
    scaleString=val.substring(begin,last + 1);
    scale=scale - Integer.parseInt(scaleString);
    if (scale != (int)scale) {
      throw new NumberFormatException(""String_Node_Str"");
    }
  }
  String unscaled=unscaledBuffer.toString();
  if (unscaled.length() < 16) {
    smallValue=parseUnscaled(unscaled);
    if (Double.isNaN(smallValue)) {
      throw new NumberFormatException(""String_Node_Str"" + val + ""String_Node_Str"");
    }
    bitLength=bitLength(smallValue);
  }
 else {
    setUnscaledValue(new BigInteger(unscaled));
  }
  precision=unscaledBuffer.length() - counter;
  for (int i=0; i < unscaledBuffer.length(); ++i) {
    char ch=unscaledBuffer.charAt(i);
    if (ch != '-' && ch != '0') {
      break;
    }
    --precision;
  }
}"
82238,"/** 
 * Returns a new   {@code BigDecimal} instance with the specified scale.<p> If the new scale is greater than the old scale, then additional zeros are added to the unscaled value. In this case no rounding is necessary. <p> If the new scale is smaller than the old scale, then trailing digits are removed. If these trailing digits are not zero, then the remaining unscaled value has to be rounded. For this rounding operation the specified rounding mode is used.
 * @param newScale scale of the result returned.
 * @param roundingMode rounding mode to be used to round the result.
 * @return a new {@code BigDecimal} instance with the specified scale.
 * @throws NullPointerException if {@code roundingMode == null}.
 * @throws ArithmeticException if {@code roundingMode == ROUND_UNNECESSARY}and rounding is necessary according to the given scale.
 */
public BigDecimal setScale(int newScale,RoundingMode roundingMode){
  if (roundingMode == null) {
    throw new NullPointerException();
  }
  double diffScale=newScale - scale;
  if (diffScale == 0) {
    return this;
  }
  if (diffScale > 0) {
    if (diffScale < DOUBLE_TEN_POW.length && (this.bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)diffScale]) < 54) {
      return valueOf(this.smallValue * DOUBLE_TEN_POW[(int)diffScale],newScale);
    }
    return new BigDecimal(Multiplication.multiplyByTenPow(getUnscaledValue(),(int)diffScale),newScale);
  }
  if (this.bitLength < 54 && -diffScale < DOUBLE_TEN_POW.length) {
    return dividePrimitiveLongs((long)this.smallValue,(long)DOUBLE_TEN_POW[(int)-diffScale],newScale,roundingMode);
  }
  return divideBigIntegers(this.getUnscaledValue(),Multiplication.powerOf10(-diffScale),newScale,roundingMode);
}","/** 
 * Returns a new   {@code BigDecimal} instance with the specified scale.<p> If the new scale is greater than the old scale, then additional zeros are added to the unscaled value. In this case no rounding is necessary. <p> If the new scale is smaller than the old scale, then trailing digits are removed. If these trailing digits are not zero, then the remaining unscaled value has to be rounded. For this rounding operation the specified rounding mode is used.
 * @param newScale scale of the result returned.
 * @param roundingMode rounding mode to be used to round the result.
 * @return a new {@code BigDecimal} instance with the specified scale.
 * @throws NullPointerException if {@code roundingMode == null}.
 * @throws ArithmeticException if {@code roundingMode == ROUND_UNNECESSARY}and rounding is necessary according to the given scale.
 */
public BigDecimal setScale(int newScale,RoundingMode roundingMode){
  if (roundingMode == null) {
    throw new NullPointerException();
  }
  double diffScale=newScale - scale;
  if (diffScale == 0) {
    return this;
  }
  if (diffScale > 0) {
    if (diffScale < DOUBLE_TEN_POW.length && (this.bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)diffScale]) < SMALL_VALUE_BITS) {
      return valueOf(this.smallValue * DOUBLE_TEN_POW[(int)diffScale],newScale);
    }
    return new BigDecimal(Multiplication.multiplyByTenPow(getUnscaledValue(),(int)diffScale),newScale);
  }
  if (this.bitLength < SMALL_VALUE_BITS && -diffScale < DOUBLE_TEN_POW.length) {
    return dividePrimitiveLongs((long)this.smallValue,(long)DOUBLE_TEN_POW[(int)-diffScale],newScale,roundingMode);
  }
  return divideBigIntegers(this.getUnscaledValue(),Multiplication.powerOf10(-diffScale),newScale,roundingMode);
}"
82239,"/** 
 * Returns a hash code for this   {@code BigDecimal}.
 * @return hash code for {@code this}.
 */
@Override public int hashCode(){
  if (hashCode != 0) {
    return hashCode;
  }
  if (bitLength < 54) {
    long longValue=(long)smallValue;
    hashCode=(int)(longValue & 0xffffffff);
    hashCode=33 * hashCode + (int)((longValue >> 32) & 0xffffffff);
    hashCode=17 * hashCode + (int)scale;
    return hashCode;
  }
  hashCode=17 * intVal.hashCode() + (int)scale;
  return hashCode;
}","/** 
 * Returns a hash code for this   {@code BigDecimal}.
 * @return hash code for {@code this}.
 */
@Override public int hashCode(){
  if (hashCode != 0) {
    return hashCode;
  }
  if (bitLength < SMALL_VALUE_BITS) {
    long longValue=(long)smallValue;
    hashCode=(int)(longValue & 0xffffffff);
    hashCode=33 * hashCode + (int)((longValue >> 32) & 0xffffffff);
    hashCode=17 * hashCode + (int)scale;
    return hashCode;
  }
  hashCode=17 * intVal.hashCode() + (int)scale;
  return hashCode;
}"
82240,"/** 
 * Returns a new   {@code BigDecimal} whose value is {@code this} 10^{@code n}. The scale of the result is   {@code this.scale()} - {@code n}. The precision of the result is the precision of   {@code this}. <p> This method has the same effect as   {@link #movePointRight}, except that the precision is not changed.
 * @param n number of places the decimal point has to be moved.
 * @return {@code this * 10^n}
 */
public BigDecimal scaleByPowerOfTen(int n){
  double newScale=scale - n;
  if (bitLength < 54) {
    if (smallValue == 0) {
      return zeroScaledBy(newScale);
    }
    return valueOf(smallValue,toIntScale(newScale));
  }
  return new BigDecimal(getUnscaledValue(),toIntScale(newScale));
}","/** 
 * Returns a new   {@code BigDecimal} whose value is {@code this} 10^{@code n}. The scale of the result is   {@code this.scale()} - {@code n}. The precision of the result is the precision of   {@code this}. <p> This method has the same effect as   {@link #movePointRight}, except that the precision is not changed.
 * @param n number of places the decimal point has to be moved.
 * @return {@code this * 10^n}
 */
public BigDecimal scaleByPowerOfTen(int n){
  double newScale=scale - n;
  if (bitLength < SMALL_VALUE_BITS) {
    if (smallValue == 0) {
      return zeroScaledBy(newScale);
    }
    return valueOf(smallValue,toIntScale(newScale));
  }
  return new BigDecimal(getUnscaledValue(),toIntScale(newScale));
}"
82241,"private void setUnscaledValue(BigInteger unscaledValue){
  this.intVal=unscaledValue;
  this.bitLength=unscaledValue.bitLength();
  if (this.bitLength < 54) {
    this.smallValue=unscaledValue.longValue();
  }
}","private void setUnscaledValue(BigInteger unscaledValue){
  this.intVal=unscaledValue;
  this.bitLength=unscaledValue.bitLength();
  if (this.bitLength < SMALL_VALUE_BITS) {
    this.smallValue=unscaledValue.longValue();
  }
}"
82242,"private static BigDecimal divideBigIntegers(BigInteger scaledDividend,BigInteger scaledDivisor,int scale,RoundingMode roundingMode){
  BigInteger[] quotAndRem=scaledDividend.divideAndRemainder(scaledDivisor);
  BigInteger quotient=quotAndRem[0];
  BigInteger remainder=quotAndRem[1];
  if (remainder.signum() == 0) {
    return new BigDecimal(quotient,scale);
  }
  int sign=scaledDividend.signum() * scaledDivisor.signum();
  int compRem;
  if (scaledDivisor.bitLength() < 54) {
    long rem=remainder.longValue();
    long divisor=scaledDivisor.longValue();
    compRem=longCompareTo(Math.abs(rem) << 1,Math.abs(divisor));
    compRem=roundingBehavior(quotient.testBit(0) ? 1 : 0,sign * (5 + compRem),roundingMode);
  }
 else {
    compRem=remainder.abs().shiftLeftOneBit().compareTo(scaledDivisor.abs());
    compRem=roundingBehavior(quotient.testBit(0) ? 1 : 0,sign * (5 + compRem),roundingMode);
  }
  if (compRem != 0) {
    if (quotient.bitLength() < 54) {
      return valueOf(quotient.longValue() + compRem,scale);
    }
    quotient=quotient.add(BigInteger.valueOf(compRem));
    return new BigDecimal(quotient,scale);
  }
  return new BigDecimal(quotient,scale);
}","private static BigDecimal divideBigIntegers(BigInteger scaledDividend,BigInteger scaledDivisor,int scale,RoundingMode roundingMode){
  BigInteger[] quotAndRem=scaledDividend.divideAndRemainder(scaledDivisor);
  BigInteger quotient=quotAndRem[0];
  BigInteger remainder=quotAndRem[1];
  if (remainder.signum() == 0) {
    return new BigDecimal(quotient,scale);
  }
  int sign=scaledDividend.signum() * scaledDivisor.signum();
  int compRem;
  if (scaledDivisor.bitLength() < SMALL_VALUE_BITS) {
    long rem=remainder.longValue();
    long divisor=scaledDivisor.longValue();
    compRem=longCompareTo(Math.abs(rem) << 1,Math.abs(divisor));
    compRem=roundingBehavior(quotient.testBit(0) ? 1 : 0,sign * (5 + compRem),roundingMode);
  }
 else {
    compRem=remainder.abs().shiftLeftOneBit().compareTo(scaledDivisor.abs());
    compRem=roundingBehavior(quotient.testBit(0) ? 1 : 0,sign * (5 + compRem),roundingMode);
  }
  if (compRem != 0) {
    if (quotient.bitLength() < SMALL_VALUE_BITS) {
      return valueOf(quotient.longValue() + compRem,scale);
    }
    quotient=quotient.add(BigInteger.valueOf(compRem));
    return new BigDecimal(quotient,scale);
  }
  return new BigDecimal(quotient,scale);
}"
82243,"private BigDecimal movePoint(double newScale){
  if (isZero()) {
    return zeroScaledBy(Math.max(newScale,0));
  }
  if (newScale >= 0) {
    if (bitLength < 54) {
      return valueOf(smallValue,toIntScale(newScale));
    }
    return new BigDecimal(getUnscaledValue(),toIntScale(newScale));
  }
  if (-newScale < DOUBLE_TEN_POW.length && bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)-newScale] < 54) {
    return valueOf(smallValue * DOUBLE_TEN_POW[(int)-newScale],0);
  }
  return new BigDecimal(Multiplication.multiplyByTenPow(getUnscaledValue(),(int)-newScale),0);
}","private BigDecimal movePoint(double newScale){
  if (isZero()) {
    return zeroScaledBy(Math.max(newScale,0));
  }
  if (newScale >= 0) {
    if (bitLength < SMALL_VALUE_BITS) {
      return valueOf(smallValue,toIntScale(newScale));
    }
    return new BigDecimal(getUnscaledValue(),toIntScale(newScale));
  }
  if (-newScale < DOUBLE_TEN_POW.length && bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)-newScale] < SMALL_VALUE_BITS) {
    return valueOf(smallValue * DOUBLE_TEN_POW[(int)-newScale],0);
  }
  return new BigDecimal(Multiplication.multiplyByTenPow(getUnscaledValue(),(int)-newScale),0);
}"
82244,"private BigDecimal(long smallValue,int scale){
  this.scale=scale;
  this.bitLength=bitLength(smallValue);
  if (bitLength < 54) {
    this.smallValue=smallValue;
  }
 else {
    this.intVal=BigInteger.valueOf(smallValue);
  }
}","private BigDecimal(long smallValue,int scale){
  this.scale=scale;
  this.bitLength=bitLength(smallValue);
  if (bitLength < SMALL_VALUE_BITS) {
    this.smallValue=smallValue;
  }
 else {
    this.intVal=BigInteger.valueOf(smallValue);
  }
}"
82245,"/** 
 * Returns   {@code true} if {@code x} is a {@code BigDecimal} instance and ifthis instance is equal to this big decimal. Two big decimals are equal if their unscaled value and their scale is equal. For example, 1.0 (10*10^(-1)) is not equal to 1.00 (100*10^(-2)). Similarly, zero instances are not equal if their scale differs.
 * @param x object to be compared with {@code this}.
 * @return true if {@code x} is a {@code BigDecimal} and {@code this == x}.
 */
@Override public boolean equals(Object x){
  if (this == x) {
    return true;
  }
  if (x instanceof BigDecimal) {
    BigDecimal x1=(BigDecimal)x;
    return x1.scale == scale && (bitLength < 54 ? (x1.smallValue == smallValue) : intVal.equals(x1.intVal));
  }
  return false;
}","/** 
 * Returns   {@code true} if {@code x} is a {@code BigDecimal} instance and ifthis instance is equal to this big decimal. Two big decimals are equal if their unscaled value and their scale is equal. For example, 1.0 (10*10^(-1)) is not equal to 1.00 (100*10^(-2)). Similarly, zero instances are not equal if their scale differs.
 * @param x object to be compared with {@code this}.
 * @return true if {@code x} is a {@code BigDecimal} and {@code this == x}.
 */
@Override public boolean equals(Object x){
  if (this == x) {
    return true;
  }
  if (x instanceof BigDecimal) {
    BigDecimal x1=(BigDecimal)x;
    return x1.scale == scale && (bitLength < SMALL_VALUE_BITS ? (x1.smallValue == smallValue) : intVal.equals(x1.intVal));
  }
  return false;
}"
82246,"private void record(JsExpression x,JsContext<JsExpression> ctx){
  if (ctx.isLvalue()) {
    return;
  }
 else   if (x.getSourceInfo().getStartLine() == lastLine && (!recordFileNames || x.getSourceInfo().getFileName().equals(lastFile))) {
    return;
  }
  SourceInfo info=x.getSourceInfo().makeChild(JsStackEmulator.class,""String_Node_Str"");
  JsExpression location=program.getStringLiteral(info,String.valueOf(lastLine=info.getStartLine()));
  if (recordFileNames) {
    JsStringLiteral stringLit=program.getStringLiteral(info,baseName(lastFile=info.getFileName()) + ""String_Node_Str"");
    location=new JsBinaryOperation(info,JsBinaryOperator.ADD,stringLit,location);
  }
  JsArrayAccess access=new JsArrayAccess(info,lineNumbers.makeRef(info),stackIndexRef(info));
  JsBinaryOperation asg=new JsBinaryOperation(info,JsBinaryOperator.ASG,access,location);
  JsBinaryOperation comma=new JsBinaryOperation(info,JsBinaryOperator.COMMA,asg,x);
  ctx.replaceMe(comma);
}","private void record(JsExpression x,JsContext<JsExpression> ctx){
  if (ctx.isLvalue()) {
    return;
  }
 else   if (nodesInRefContext.contains(x)) {
    return;
  }
 else   if (x.getSourceInfo().getStartLine() == lastLine && (!recordFileNames || x.getSourceInfo().getFileName().equals(lastFile))) {
    return;
  }
  SourceInfo info=x.getSourceInfo().makeChild(JsStackEmulator.class,""String_Node_Str"");
  JsExpression location=program.getStringLiteral(info,String.valueOf(lastLine=info.getStartLine()));
  if (recordFileNames) {
    JsStringLiteral stringLit=program.getStringLiteral(info,baseName(lastFile=info.getFileName()) + ""String_Node_Str"");
    location=new JsBinaryOperation(info,JsBinaryOperator.ADD,stringLit,location);
  }
  JsArrayAccess access=new JsArrayAccess(info,lineNumbers.makeRef(info),stackIndexRef(info));
  JsBinaryOperation asg=new JsBinaryOperation(info,JsBinaryOperator.ASG,access,location);
  JsBinaryOperation comma=new JsBinaryOperation(info,JsBinaryOperator.COMMA,asg,x);
  ctx.replaceMe(comma);
}"
82247,"public void traverse(JsVisitor v,JsContext<JsStatement> ctx){
  if (v.visit(this,ctx)) {
    if (iterExpr != null) {
      iterExpr=v.accept(iterExpr);
    }
    objExpr=v.accept(objExpr);
    body=v.accept(body);
  }
  v.endVisit(this,ctx);
}","public void traverse(JsVisitor v,JsContext<JsStatement> ctx){
  if (v.visit(this,ctx)) {
    if (iterExpr != null) {
      iterExpr=v.acceptLvalue(iterExpr);
    }
    objExpr=v.accept(objExpr);
    body=v.accept(body);
  }
  v.endVisit(this,ctx);
}"
82248,"/** 
 * Closes the menu bar.
 * @deprecated Use {@link #addCloseHandler(CloseHandler)} instead
 */
@Deprecated public void onPopupClosed(PopupPanel sender,boolean autoClosed){
  if (autoClosed) {
    closeAllParents();
  }
  onHide(autoClosed);
  CloseEvent.fire(MenuBar.this,sender);
  shownChildMenu=null;
  popup=null;
  if (parentMenu != null && parentMenu.popup != null) {
    parentMenu.popup.setPreviewingAllNativeEvents(true);
  }
}","/** 
 * Closes the menu bar.
 * @deprecated Use {@link #addCloseHandler(CloseHandler)} instead
 */
@Deprecated public void onPopupClosed(PopupPanel sender,boolean autoClosed){
  if (autoClosed) {
    closeAllParents();
  }
  onHide(!autoClosed);
  CloseEvent.fire(MenuBar.this,sender);
  shownChildMenu=null;
  popup=null;
  if (parentMenu != null && parentMenu.popup != null) {
    parentMenu.popup.setPreviewingAllNativeEvents(true);
  }
}"
82249,"public void parse(XMLElement elem,String fieldName,JClassType type,UiBinderWriter writer) throws UnableToCompleteException {
  String debugId=elem.consumeStringAttribute(""String_Node_Str"",null);
  if (null != debugId) {
    writer.addStatement(""String_Node_Str"",fieldName,debugId);
  }
  String[] styleNames=elem.consumeStringArrayAttribute(""String_Node_Str"");
  for (  String s : styleNames) {
    writer.addStatement(""String_Node_Str"",fieldName,s);
  }
  styleNames=elem.consumeStringArrayAttribute(""String_Node_Str"");
  for (  String s : styleNames) {
    writer.addStatement(""String_Node_Str"",fieldName,s);
  }
}","public void parse(XMLElement elem,String fieldName,JClassType type,UiBinderWriter writer) throws UnableToCompleteException {
  String debugId=elem.consumeStringAttribute(""String_Node_Str"",null);
  if (null != debugId) {
    writer.addStatement(""String_Node_Str"",fieldName,debugId);
  }
  String styleName=elem.consumeStringAttribute(""String_Node_Str"",null);
  String stylePrimaryName=elem.consumeStringAttribute(""String_Node_Str"",null);
  if (null != styleName && null != stylePrimaryName) {
    writer.die(""String_Node_Str"" + ""String_Node_Str"",elem);
  }
  if (null != styleName) {
    writer.addStatement(""String_Node_Str"",fieldName,styleName);
  }
  if (null != stylePrimaryName) {
    writer.addStatement(""String_Node_Str"",fieldName,stylePrimaryName);
  }
  String[] extraStyleNames=elem.consumeStringArrayAttribute(""String_Node_Str"");
  for (  String s : extraStyleNames) {
    writer.addStatement(""String_Node_Str"",fieldName,s);
  }
  extraStyleNames=elem.consumeStringArrayAttribute(""String_Node_Str"");
  for (  String s : extraStyleNames) {
    writer.addStatement(""String_Node_Str"",fieldName,s);
  }
}"
82250,"private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}","private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}"
82251,"public void testHappy() throws UnableToCompleteException, SAXException, IOException {
  StringBuffer b=new StringBuffer();
  b.append(""String_Node_Str"");
  b.append(""String_Node_Str"");
  b.append(""String_Node_Str"");
  String[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  tester.parse(b.toString());
  Iterator<String> i=tester.writer.statements.iterator();
  for (  String e : expected) {
    assertEquals(e,i.next());
  }
  assertFalse(i.hasNext());
  assertNull(tester.logger.died);
}","public void testHappy() throws UnableToCompleteException, SAXException, IOException {
  StringBuffer b=new StringBuffer();
  b.append(""String_Node_Str"" + ""String_Node_Str"");
  b.append(""String_Node_Str"");
  b.append(""String_Node_Str"");
  String[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  tester.parse(b.toString());
  Iterator<String> i=tester.writer.statements.iterator();
  for (  String e : expected) {
    assertEquals(e,i.next());
  }
  assertFalse(i.hasNext());
  assertNull(tester.logger.died);
}"
82252,"@Override public void gwtTearDown() throws Exception {
  RootPanel.get().clear();
  super.gwtTearDown();
}","@Override public void gwtTearDown() throws Exception {
  domUi.root.getParentElement().removeChild(domUi.root);
  RootPanel.get().clear();
  super.gwtTearDown();
}"
82253,"public void testAddStyleNamesAndDebugId(){
  Label l=widgetUi.lblDebugId;
  assertEquals(""String_Node_Str"",l.getElement().getId());
  WidgetBasedUiExternalResources resources=GWT.create(WidgetBasedUiExternalResources.class);
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(resources.style().prettyText()));
}","public void testAddStyleNamesAndDebugId(){
  Label l=widgetUi.lblDebugId;
  assertEquals(""String_Node_Str"",l.getElement().getId());
  assertEquals(""String_Node_Str"",l.getStylePrimaryName());
  WidgetBasedUiExternalResources resources=GWT.create(WidgetBasedUiExternalResources.class);
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str"" + resources.style().prettyText()));
}"
82254,"/** 
 * Extract the module's base path from the current request.
 * @return the module's base path, modulo protocol and host, as reported by{@link com.google.gwt.core.client.GWT#getModuleBaseURL()} or<code>null</code> if the request did not contain the {@value com.google.gwt.user.client.rpc.RpcRequestBuilder#MODULE_BASE_HEADER} header
 */
protected final String getRequestModuleBasePath(){
  try {
    String header=getThreadLocalRequest().getHeader(MODULE_BASE_HEADER);
    if (header == null) {
      return null;
    }
    return new URL(header).getPath();
  }
 catch (  MalformedURLException e) {
    return null;
  }
}","/** 
 * Extract the module's base path from the current request.
 * @return the module's base path, modulo protocol and host, as reported by{@link com.google.gwt.core.client.GWT#getModuleBaseURL()} or<code>null</code> if the request did not contain the {@value com.google.gwt.user.client.rpc.RpcRequestBuilder#MODULE_BASE_HEADER} header
 */
protected final String getRequestModuleBasePath(){
  try {
    String header=getThreadLocalRequest().getHeader(MODULE_BASE_HEADER);
    if (header == null) {
      return null;
    }
    String path=new URL(header).getPath();
    String contextPath=getThreadLocalRequest().getContextPath();
    if (!path.startsWith(contextPath)) {
      return null;
    }
    return path.substring(contextPath.length());
  }
 catch (  MalformedURLException e) {
    return null;
  }
}"
82255,"/** 
 * Clear the opacity css property.
 */
public final void clearOpacity(){
  clearProperty(STYLE_OPACITY);
}","/** 
 * Clear the opacity css property.
 */
public final void clearOpacity(){
  DOMImpl.impl.cssClearOpacity(this);
}"
82256,"/** 
 * Set the opacity css property.
 */
public final void setOpacity(double value){
  setProperty(STYLE_OPACITY,value + ""String_Node_Str"");
}","/** 
 * Set the opacity css property.
 */
public final void setOpacity(double value){
  DOMImpl.impl.cssSetOpacity(this,value);
}"
82257,"public Tab(Widget child){
  super(Document.get().createDivElement());
  getElement().appendChild(inner=Document.get().createDivElement());
  setWidget(child);
  setStyleName(""String_Node_Str"");
  inner.setClassName(""String_Node_Str"");
  getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
}","public Tab(Widget child){
  super(Document.get().createDivElement());
  getElement().appendChild(inner=Document.get().createDivElement());
  setWidget(child);
  setStyleName(""String_Node_Str"");
  inner.setClassName(""String_Node_Str"");
  getElement().getStyle().setFloat(Style.Float.LEFT);
}"
82258,"private void writeClassOpen(IndentedWriter w){
  w.write(""String_Node_Str"",implClassName,uiRootType.getName(),uiOwnerType.getName(),baseClass.getName());
  w.indent();
}","private void writeClassOpen(IndentedWriter w){
  w.write(""String_Node_Str"",implClassName,uiRootType.getParameterizedQualifiedSourceName(),uiOwnerType.getParameterizedQualifiedSourceName(),baseClass.getParameterizedQualifiedSourceName());
  w.indent();
}"
82259,"/** 
 * Writes the UiBinder's source.
 */
private void writeBinder(IndentedWriter w,String rootField) throws UnableToCompleteException {
  writePackage(w);
  writeImports(w);
  w.newline();
  writeClassOpen(w);
  writeStatics(w);
  w.newline();
  w.write(""String_Node_Str"",uiRootType.getName(),uiOwnerType.getName());
  w.indent();
  w.newline();
  writeGwtFields(w);
  w.newline();
  writeAddedStatements(w);
  w.newline();
  writeInitStatements(w);
  w.newline();
  writeHandlers(w);
  w.newline();
  writeOwnerFieldSetters(w);
  writeCssInjectors(w);
  w.write(""String_Node_Str"",rootField);
  w.outdent();
  w.write(""String_Node_Str"");
  w.outdent();
  w.write(""String_Node_Str"");
}","/** 
 * Writes the UiBinder's source.
 */
private void writeBinder(IndentedWriter w,String rootField) throws UnableToCompleteException {
  writePackage(w);
  writeImports(w);
  w.newline();
  writeClassOpen(w);
  writeStatics(w);
  w.newline();
  w.write(""String_Node_Str"",uiRootType.getParameterizedQualifiedSourceName(),uiOwnerType.getParameterizedQualifiedSourceName());
  w.indent();
  w.newline();
  writeGwtFields(w);
  w.newline();
  writeAddedStatements(w);
  w.newline();
  writeInitStatements(w);
  w.newline();
  writeHandlers(w);
  w.newline();
  writeOwnerFieldSetters(w);
  writeCssInjectors(w);
  w.write(""String_Node_Str"",rootField);
  w.outdent();
  w.write(""String_Node_Str"");
  w.outdent();
  w.write(""String_Node_Str"");
}"
82260,"private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}","private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}"
82261,"/** 
 * Instructs the writer to initialize the field with a specific contructor invocaction, instead of the default GWT.create call.
 */
public void setFieldInitializerAsConstructor(String fieldName,JClassType type,String... args){
  setFieldInitializer(fieldName,formatCode(""String_Node_Str"",type.getQualifiedSourceName(),asCommaSeparatedList(args)));
}","/** 
 * Instructs the writer to initialize the field with a specific contructor invocaction, instead of the default GWT.create call.
 * @param fieldName the field to intialize
 * @param type the type of the field
 * @param arguments to the constructor call
 */
public void setFieldInitializerAsConstructor(String fieldName,JClassType type,String... args){
  setFieldInitializer(fieldName,formatCode(""String_Node_Str"",type.getQualifiedSourceName(),asCommaSeparatedList(args)));
}"
82262,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(FieldWriterOfGeneratedCssResourceTest.class);
  suite.addTestSuite(GwtResourceEntityResolverTest.class);
  suite.addTestSuite(HandlerEvaluatorTest.class);
  suite.addTestSuite(TokenatorTest.class);
  suite.addTestSuite(XMLElementTest.class);
  suite.addTestSuite(OwnerClassTest.class);
  suite.addTestSuite(OwnerFieldClassTest.class);
  suite.addTestSuite(OwnerFieldTest.class);
  suite.addTestSuite(CssNameConverterTest.class);
  suite.addTestSuite(IntAttributeParserTest.class);
  suite.addTestSuite(FieldReferenceConverterTest.class);
  suite.addTestSuite(StrictAttributeParserTest.class);
  suite.addTestSuite(StringAttributeParserTest.class);
  suite.addTestSuite(LengthAttributeParserTest.class);
  suite.addTestSuite(DialogBoxParserTest.class);
  suite.addTestSuite(DockLayoutPanelParserTest.class);
  suite.addTestSuite(IsEmptyParserTest.class);
  suite.addTestSuite(LayoutPanelParserTest.class);
  suite.addTestSuite(StackLayoutPanelParserTest.class);
  suite.addTestSuite(TabLayoutPanelParserTest.class);
  suite.addTestSuite(UIObjectParserTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(FieldWriterOfGeneratedCssResourceTest.class);
  suite.addTestSuite(GwtResourceEntityResolverTest.class);
  suite.addTestSuite(HandlerEvaluatorTest.class);
  suite.addTestSuite(TokenatorTest.class);
  suite.addTestSuite(XMLElementTest.class);
  suite.addTestSuite(OwnerClassTest.class);
  suite.addTestSuite(OwnerFieldClassTest.class);
  suite.addTestSuite(OwnerFieldTest.class);
  suite.addTestSuite(CssNameConverterTest.class);
  suite.addTestSuite(IntAttributeParserTest.class);
  suite.addTestSuite(FieldReferenceConverterTest.class);
  suite.addTestSuite(StrictAttributeParserTest.class);
  suite.addTestSuite(StringAttributeParserTest.class);
  suite.addTestSuite(LengthAttributeParserTest.class);
  suite.addTestSuite(DialogBoxParserTest.class);
  suite.addTestSuite(DockLayoutPanelParserTest.class);
  suite.addTestSuite(ImageParserTest.class);
  suite.addTestSuite(IsEmptyParserTest.class);
  suite.addTestSuite(LayoutPanelParserTest.class);
  suite.addTestSuite(StackLayoutPanelParserTest.class);
  suite.addTestSuite(TabLayoutPanelParserTest.class);
  suite.addTestSuite(UIObjectParserTest.class);
  return suite;
}"
82263,"/** 
 * @return a pale reflection of com.google.gwt.user.ui, plus{@link JavaResourceBase#getStandardResources}
 */
public static Set<Resource> getUiResources(){
  Set<Resource> rtn=new HashSet<Resource>(Arrays.asList(JavaResourceBase.getStandardResources()));
  rtn.add(BUTTON);
  rtn.add(CLICK_EVENT);
  rtn.add(CLICK_HANDLER);
  rtn.add(DIALOG_BOX);
  rtn.add(DOCK_LAYOUT_PANEL);
  rtn.add(EVENT_HANDLER);
  rtn.add(GWT_EVENT);
  rtn.add(HANDLER_REGISTRATION);
  rtn.add(HAS_CLICK_HANDLERS);
  rtn.add(HAS_HORIZONTAL_ALIGNMENT);
  rtn.add(HAS_VERTICAL_ALIGNMENT);
  rtn.add(LABEL);
  rtn.add(LAYOUT_PANEL);
  rtn.add(MOUSE_OVER_EVENT);
  rtn.add(MOUSE_OVER_HANDLER);
  rtn.add(SPLIT_LAYOUT_PANEL);
  rtn.add(STACK_LAYOUT_PANEL);
  rtn.add(STYLE);
  rtn.add(TAB_LAYOUT_PANEL);
  rtn.add(UI_OBJECT);
  rtn.add(UI_BINDER);
  rtn.add(UI_FACTORY);
  rtn.add(WIDGET);
  return rtn;
}","/** 
 * @return a pale reflection of com.google.gwt.user.ui, plus{@link JavaResourceBase#getStandardResources}
 */
public static Set<Resource> getUiResources(){
  Set<Resource> rtn=new HashSet<Resource>(Arrays.asList(JavaResourceBase.getStandardResources()));
  rtn.add(BUTTON);
  rtn.add(CLICK_EVENT);
  rtn.add(CLICK_HANDLER);
  rtn.add(DIALOG_BOX);
  rtn.add(DOCK_LAYOUT_PANEL);
  rtn.add(EVENT_HANDLER);
  rtn.add(GWT_EVENT);
  rtn.add(IMAGE);
  rtn.add(IMAGE_RESOURCE);
  rtn.add(HANDLER_REGISTRATION);
  rtn.add(HAS_CLICK_HANDLERS);
  rtn.add(HAS_HORIZONTAL_ALIGNMENT);
  rtn.add(HAS_VERTICAL_ALIGNMENT);
  rtn.add(LABEL);
  rtn.add(LAYOUT_PANEL);
  rtn.add(MOUSE_OVER_EVENT);
  rtn.add(MOUSE_OVER_HANDLER);
  rtn.add(SPLIT_LAYOUT_PANEL);
  rtn.add(STACK_LAYOUT_PANEL);
  rtn.add(STYLE);
  rtn.add(TAB_LAYOUT_PANEL);
  rtn.add(UI_OBJECT);
  rtn.add(UI_BINDER);
  rtn.add(UI_FACTORY);
  rtn.add(WIDGET);
  return rtn;
}"
82264,"public void testImageResourceInImageWidget(){
  assertEquals(widgetUi.prettyImage.getWidth(),widgetUi.babyWidget.getOffsetWidth());
  assertEquals(widgetUi.prettyImage.getHeight(),widgetUi.babyWidget.getOffsetHeight());
  assertEquals(widgetUi.prettyImage.getTop(),widgetUi.babyWidget.getOriginTop());
  assertEquals(widgetUi.prettyImage.getLeft(),widgetUi.babyWidget.getOriginLeft());
}","public void testImageResourceInImageWidget(){
  ImageResource resource=widgetUi.prettyImage;
  Image widget=widgetUi.babyWidget;
  assertEquals(resource.getWidth(),widget.getOffsetWidth());
  assertEquals(resource.getHeight(),widget.getOffsetHeight());
  assertEquals(resource.getTop(),widget.getOriginTop());
  assertEquals(resource.getLeft(),widget.getOriginLeft());
  assertEquals(""String_Node_Str"",widget.getAltText());
  assertEquals(""String_Node_Str"",widget.getStyleName());
}"
82265,"/** 
 * Set the bind address for the web server socket. <p> Will be called before   {@link #start(TreeLogger,int,File)}, if at all. If not called, the SCL should listen on all addresses.
 * @param bindAddress host name or IP address, suitable for use with{@link InetAddress#getByName(String)}
 */
public void setBindAddress(String bindAddress){
}","/** 
 * Set the bind address for the web server socket. <p> Will be called before   {@link #start(TreeLogger,int,File)}, if at all. If not called, the SCL should listen on all addresses.
 * @param bindAddress host name or IP address, suitable for use with{@link java.net.InetAddress#getByName(String)}
 */
public void setBindAddress(String bindAddress){
}"
82266,"/** 
 * This method treats arrays in a special way.
 */
private static Class<?> computeHasCustomFieldSerializer(Class<?> instanceType){
  assert(instanceType != null);
  String qualifiedTypeName=instanceType.getName();
  ClassLoader classLoader=SerializabilityUtil.class.getClassLoader();
  String simpleSerializerName=qualifiedTypeName + ""String_Node_Str"";
  Class<?> customSerializer=getCustomFieldSerializer(classLoader,simpleSerializerName);
  if (customSerializer != null) {
    return customSerializer;
  }
  Class<?> customSerializerClass=getCustomFieldSerializer(classLoader,JRE_SERIALIZER_PACKAGE + ""String_Node_Str"" + simpleSerializerName);
  if (customSerializerClass != null) {
    return customSerializerClass;
  }
  return null;
}","/** 
 * This method treats arrays in a special way.
 */
private static Class<?> computeHasCustomFieldSerializer(Class<?> instanceType){
  assert(instanceType != null);
  String qualifiedTypeName=instanceType.getName();
  ClassLoader classLoader=GWT.isClient() ? SerializabilityUtil.class.getClassLoader() : Thread.currentThread().getContextClassLoader();
  String simpleSerializerName=qualifiedTypeName + ""String_Node_Str"";
  Class<?> customSerializer=getCustomFieldSerializer(classLoader,simpleSerializerName);
  if (customSerializer != null) {
    return customSerializer;
  }
  Class<?> customSerializerClass=getCustomFieldSerializer(classLoader,JRE_SERIALIZER_PACKAGE + ""String_Node_Str"" + simpleSerializerName);
  if (customSerializerClass != null) {
    return customSerializerClass;
  }
  return null;
}"
82267,"/** 
 * Adapted from  {@link com.google.gwt.dev.js.rhino.ScriptRuntime#escapeString(String)}. The difference is that we quote with either &quot; or &apos; depending on which one is used less inside the string.
 */
private void printStringLiteral(String value){
  char[] chars=value.toCharArray();
  final int n=chars.length;
  int quoteCount=0;
  int aposCount=0;
  for (int i=0; i < n; ++i) {
switch (chars[i]) {
case '""':
      ++quoteCount;
    break;
case '\'':
  ++aposCount;
break;
}
}
StringBuffer result=new StringBuffer(value.length() + 16);
char quoteChar=(quoteCount < aposCount) ? '""' : '\'';
p.print(quoteChar);
for (int i=0; i < n; ++i) {
char c=chars[i];
if (' ' <= c && c <= '~' && c != quoteChar && c != '\\') {
result.append(c);
continue;
}
int escape=-1;
switch (c) {
case 0:
escape='0';
break;
case '\b':
escape='b';
break;
case '\f':
escape='f';
break;
case '\n':
escape='n';
break;
case '\r':
escape='r';
break;
case '\t':
escape='t';
break;
case '""':
escape='""';
break;
case '\'':
escape='\'';
break;
case '\\':
escape='\\';
break;
}
if (escape >= 0) {
result.append('\\');
result.append((char)escape);
}
 else {
int hexSize;
if (c < 256) {
result.append(""String_Node_Str"");
hexSize=2;
}
 else {
result.append(""String_Node_Str"");
hexSize=4;
}
for (int shift=(hexSize - 1) * 4; shift >= 0; shift-=4) {
int digit=0xf & (c >> shift);
result.append(HEX_DIGITS[digit]);
}
}
}
result.append(quoteChar);
escapeClosingTags(result);
p.print(result.toString());
}","/** 
 * Adapted from  {@link com.google.gwt.dev.js.rhino.ScriptRuntime#escapeString(String)}. The difference is that we quote with either &quot; or &apos; depending on which one is used less inside the string.
 */
private void printStringLiteral(String value){
  char[] chars=value.toCharArray();
  final int n=chars.length;
  int quoteCount=0;
  int aposCount=0;
  for (int i=0; i < n; ++i) {
switch (chars[i]) {
case '""':
      ++quoteCount;
    break;
case '\'':
  ++aposCount;
break;
}
}
StringBuffer result=new StringBuffer(value.length() + 16);
char quoteChar=(quoteCount < aposCount) ? '""' : '\'';
p.print(quoteChar);
for (int i=0; i < n; ++i) {
char c=chars[i];
if (' ' <= c && c <= '~' && c != quoteChar && c != '\\') {
result.append(c);
continue;
}
int escape=-1;
switch (c) {
case '\b':
escape='b';
break;
case '\f':
escape='f';
break;
case '\n':
escape='n';
break;
case '\r':
escape='r';
break;
case '\t':
escape='t';
break;
case '""':
escape='""';
break;
case '\'':
escape='\'';
break;
case '\\':
escape='\\';
break;
}
if (escape >= 0) {
result.append('\\');
result.append((char)escape);
}
 else {
if (c < ' ' && (i == n - 1 || chars[i + 1] < '0' || chars[i + 1] > '9')) {
result.append('\\');
if (c > 0x7) {
result.append((char)('0' + (0x7 & (c >> 3))));
}
result.append((char)('0' + (0x7 & c)));
}
 else {
int hexSize;
if (c < 256) {
result.append(""String_Node_Str"");
hexSize=2;
}
 else {
result.append(""String_Node_Str"");
hexSize=4;
}
for (int shift=(hexSize - 1) * 4; shift >= 0; shift-=4) {
int digit=0xf & (c >> shift);
result.append(HEX_DIGITS[digit]);
}
}
}
}
result.append(quoteChar);
escapeClosingTags(result);
p.print(result.toString());
}"
82268,"public final void execute(){
  if (canceled) {
    return;
  }
  scheduled=false;
  doBeforeLayout();
  layout.layout(duration,new Layout.AnimationCallback(){
    public void onAnimationComplete(){
      if (callback != null) {
        callback.onAnimationComplete();
      }
    }
    public void onLayout(    Layer layer,    double progress){
      Widget child=(Widget)layer.getUserObject();
      if (child instanceof RequiresResize) {
        ((RequiresResize)child).onResize();
      }
      if (callback != null) {
        callback.onLayout(layer,progress);
      }
    }
  }
);
}","public final void execute(){
  scheduled=false;
  if (canceled) {
    return;
  }
  doBeforeLayout();
  layout.layout(duration,new Layout.AnimationCallback(){
    public void onAnimationComplete(){
      if (callback != null) {
        callback.onAnimationComplete();
      }
    }
    public void onLayout(    Layer layer,    double progress){
      Widget child=(Widget)layer.getUserObject();
      if (child instanceof RequiresResize) {
        ((RequiresResize)child).onResize();
      }
      if (callback != null) {
        callback.onLayout(layer,progress);
      }
    }
  }
);
}"
82269,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(AsyncProxyTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(CalendarUtilTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FileUploadTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(FormPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HorizontalSplitPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(TreeItemTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(VerticalSplitPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  suite.addTestSuite(RootPanelTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(AsyncProxyTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(CalendarUtilTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FileUploadTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(FormPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HorizontalSplitPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LayoutPanelTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(TreeItemTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(VerticalSplitPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  suite.addTestSuite(RootPanelTest.class);
  return suite;
}"
82270,"private void doLayout(){
  int left=0, top=0, right=0, bottom=0;
  for (  Widget child : getChildren()) {
    LayoutData data=(LayoutData)child.getLayoutData();
    Layer layer=data.layer;
switch (data.direction) {
case NORTH:
      layer.setLeftRight(left,unit,right,unit);
    layer.setTopHeight(top,unit,data.size,unit);
  top+=data.size;
break;
case SOUTH:
layer.setLeftRight(left,unit,right,unit);
layer.setBottomHeight(bottom,unit,data.size,unit);
bottom+=data.size;
break;
case WEST:
layer.setTopBottom(top,unit,bottom,unit);
layer.setLeftWidth(left,unit,data.size,unit);
left+=data.size;
break;
case EAST:
layer.setTopBottom(top,unit,bottom,unit);
layer.setRightWidth(right,unit,data.size,unit);
right+=data.size;
break;
case CENTER:
layer.setLeftRight(left,unit,right,unit);
layer.setTopBottom(top,unit,bottom,unit);
break;
}
}
}","private void doLayout(){
  double left=0, top=0, right=0, bottom=0;
  for (  Widget child : getChildren()) {
    LayoutData data=(LayoutData)child.getLayoutData();
    Layer layer=data.layer;
switch (data.direction) {
case NORTH:
      layer.setLeftRight(left,unit,right,unit);
    layer.setTopHeight(top,unit,data.size,unit);
  top+=data.size;
break;
case SOUTH:
layer.setLeftRight(left,unit,right,unit);
layer.setBottomHeight(bottom,unit,data.size,unit);
bottom+=data.size;
break;
case WEST:
layer.setTopBottom(top,unit,bottom,unit);
layer.setLeftWidth(left,unit,data.size,unit);
left+=data.size;
break;
case EAST:
layer.setTopBottom(top,unit,bottom,unit);
layer.setRightWidth(right,unit,data.size,unit);
right+=data.size;
break;
case CENTER:
layer.setLeftRight(left,unit,right,unit);
layer.setTopBottom(top,unit,bottom,unit);
break;
}
}
}"
82271,"public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
}","public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
}"
82272,"public void testBadStrings(){
  try {
    new Integer(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.decode(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf(Long.MAX_VALUE));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf(Long.MIN_VALUE));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf((long)Integer.MAX_VALUE + 1));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf((long)Integer.MIN_VALUE - 1));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}","public void testBadStrings(){
  try {
    new Integer(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.decode(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf(Long.MAX_VALUE));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf(Long.MIN_VALUE));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf((long)Integer.MAX_VALUE + 1));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf((long)Integer.MIN_VALUE - 1));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}"
82273,"/** 
 * Constructor.
 * @param enableSourceInfoDescendants Controls whether or not SourceInfo nodescreated via the JProgram will record descendant information. Enabling this feature will collect extra data during the compilation cycle, but at a cost of memory and object allocations.
 */
public JProgram(CorrelationFactory correlator){
  super(correlator.makeSourceInfo(SourceOrigin.create(0,JProgram.class.getName())));
  this.correlator=correlator;
  intrinsic=createSourceInfo(0,getClass().getName());
  stringPoolSourceInfo=createLiteralSourceInfo(""String_Node_Str"",Literal.STRING);
}","/** 
 * Constructor.
 * @param correlator Controls whether or not SourceInfo nodes created via theJProgram will record descendant information. Enabling this feature will collect extra data during the compilation cycle, but at a cost of memory and object allocations.
 */
public JProgram(CorrelationFactory correlator){
  super(correlator.makeSourceInfo(SourceOrigin.create(0,JProgram.class.getName())));
  this.correlator=correlator;
  intrinsic=createSourceInfo(0,getClass().getName());
  stringPoolSourceInfo=createLiteralSourceInfo(""String_Node_Str"",Literal.STRING);
}"
82274,"public JInterfaceType createInterface(SourceInfo info,char[][] name){
  String sname=dotify(name);
  JInterfaceType x=new JInterfaceType(info,sname);
  allTypes.add(x);
  putIntoTypeMap(sname,x);
  if (INDEX_TYPES_SET.contains(sname)) {
    indexedTypes.put(x.getShortName(),x);
  }
  return x;
}","public JInterfaceType createInterface(SourceInfo info,char[][] name){
  String sname=dotify(name);
  JInterfaceType x=new JInterfaceType(info,sname);
  allTypes.add(x);
  putIntoTypeMap(sname,x);
  if (INDEX_TYPES_SET.contains(sname)) {
    indexedTypes.put(x.getShortName(),x);
    if (sname.equals(""String_Node_Str"")) {
      typeJavaLangCloneable=x;
    }
 else     if (sname.equals(""String_Node_Str"")) {
      typeJavaIoSerializable=x;
    }
  }
  return x;
}"
82275,"public boolean canTriviallyCast(JReferenceType type,JReferenceType qType){
  if (type.canBeNull() && !qType.canBeNull()) {
    return false;
  }
  type=type.getUnderlyingType();
  qType=qType.getUnderlyingType();
  JClassType jlo=program.getTypeJavaLangObject();
  if (type == qType || qType == jlo) {
    return true;
  }
  if (type instanceof JArrayType) {
    JArrayType aType=(JArrayType)type;
    if (qType instanceof JArrayType) {
      JArrayType qaType=(JArrayType)qType;
      JType leafType=aType.getLeafType();
      JType qLeafType=qaType.getLeafType();
      int dims=aType.getDims();
      int qDims=qaType.getDims();
      if (dims > qDims && (qLeafType == jlo || qLeafType instanceof JNullType)) {
        return true;
      }
      if (dims == qDims) {
        if (leafType instanceof JReferenceType && qLeafType instanceof JReferenceType) {
          return canTriviallyCast((JReferenceType)leafType,(JReferenceType)qLeafType);
        }
      }
    }
  }
 else   if (type instanceof JClassType) {
    JClassType cType=(JClassType)type;
    if (qType instanceof JClassType) {
      JClassType qcType=(JClassType)qType;
      if (isSuperClass(cType,qcType)) {
        return true;
      }
      JClassType jsoType=program.getJavaScriptObject();
      if (jsoType != null) {
        return isSameOrSuper(cType,jsoType) && isSameOrSuper(qcType,jsoType);
      }
    }
 else     if (qType instanceof JInterfaceType) {
      return implementsInterface(cType,(JInterfaceType)qType);
    }
  }
 else   if (type instanceof JInterfaceType) {
    JInterfaceType iType=(JInterfaceType)type;
    if (qType instanceof JInterfaceType) {
      return extendsInterface(iType,(JInterfaceType)qType);
    }
  }
 else   if (type instanceof JNullType) {
    return true;
  }
  return false;
}","public boolean canTriviallyCast(JReferenceType type,JReferenceType qType){
  if (type.canBeNull() && !qType.canBeNull()) {
    return false;
  }
  type=type.getUnderlyingType();
  qType=qType.getUnderlyingType();
  JClassType jlo=program.getTypeJavaLangObject();
  if (type == qType || qType == jlo) {
    return true;
  }
  if (type instanceof JArrayType) {
    JArrayType aType=(JArrayType)type;
    if (qType instanceof JArrayType) {
      JArrayType qaType=(JArrayType)qType;
      JType leafType=aType.getLeafType();
      JType qLeafType=qaType.getLeafType();
      int dims=aType.getDims();
      int qDims=qaType.getDims();
      if (dims > qDims && (qLeafType == jlo || qLeafType instanceof JNullType)) {
        return true;
      }
      if (dims == qDims) {
        if (leafType instanceof JReferenceType && qLeafType instanceof JReferenceType) {
          return canTriviallyCast((JReferenceType)leafType,(JReferenceType)qLeafType);
        }
      }
    }
    if (qType == javaIoSerializable || qType == javaLangCloneable) {
      return true;
    }
  }
 else   if (type instanceof JClassType) {
    JClassType cType=(JClassType)type;
    if (qType instanceof JClassType) {
      JClassType qcType=(JClassType)qType;
      if (isSuperClass(cType,qcType)) {
        return true;
      }
      JClassType jsoType=program.getJavaScriptObject();
      if (jsoType != null) {
        return isSameOrSuper(cType,jsoType) && isSameOrSuper(qcType,jsoType);
      }
    }
 else     if (qType instanceof JInterfaceType) {
      return implementsInterface(cType,(JInterfaceType)qType);
    }
  }
 else   if (type instanceof JInterfaceType) {
    JInterfaceType iType=(JInterfaceType)type;
    if (qType instanceof JInterfaceType) {
      return extendsInterface(iType,(JInterfaceType)qType);
    }
  }
 else   if (type instanceof JNullType) {
    return true;
  }
  return false;
}"
82276,"public void testCanTriviallyCast(){
  assertTrue(typeOracle.canTriviallyCast(classB,classB));
  assertTrue(typeOracle.canTriviallyCast(classBSub,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,classBSub));
  assertFalse(typeOracle.canTriviallyCast(classC,classA));
  assertFalse(typeOracle.canTriviallyCast(classA,classC));
  assertTrue(typeOracle.canTriviallyCast(classB,intfI));
  assertFalse(typeOracle.canTriviallyCast(intfI,classB));
  assertTrue(typeOracle.canTriviallyCast(classB,classObject));
  assertFalse(typeOracle.canTriviallyCast(classObject,classB));
  assertTrue(typeOracle.canTriviallyCast(classB,intfI));
  assertFalse(typeOracle.canTriviallyCast(intfI,classB));
  assertTrue(typeOracle.canTriviallyCast(classBnn,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,classBnn));
  assertTrue(typeOracle.canTriviallyCast(typeNull,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,typeNull));
  assertTrue(typeOracle.canTriviallyCast(arrayOfBSub,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfBSub));
  assertFalse(typeOracle.canTriviallyCast(arrayOfA,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfA));
  assertFalse(typeOracle.canTriviallyCast(arrayOfArrayOfB,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfArrayOfB));
  assertTrue(typeOracle.canTriviallyCast(arrayOfArrayOfB,arrayOfObject));
  assertFalse(typeOracle.canTriviallyCast(arrayOfObject,arrayOfArrayOfB));
  assertTrue(typeOracle.canTriviallyCast(classJso1,classJso2));
  assertTrue(typeOracle.canTriviallyCast(classJso2,classJso1));
  assertTrue(typeOracle.canTriviallyCast(classJso,classJso1));
  assertTrue(typeOracle.canTriviallyCast(classJso,classJso1));
  for (  JReferenceType type1 : severalTypes()) {
    for (    JReferenceType type2 : severalTypes()) {
      if (type1 != type2) {
        if (!isJso(type1) || !isJso(type2)) {
          assertFalse(typeOracle.canTriviallyCast(type1,type2) && typeOracle.canTriviallyCast(type2,type1));
        }
      }
    }
  }
}","public void testCanTriviallyCast(){
  assertTrue(typeOracle.canTriviallyCast(classB,classB));
  assertTrue(typeOracle.canTriviallyCast(classBSub,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,classBSub));
  assertFalse(typeOracle.canTriviallyCast(classC,classA));
  assertFalse(typeOracle.canTriviallyCast(classA,classC));
  assertTrue(typeOracle.canTriviallyCast(classB,intfI));
  assertFalse(typeOracle.canTriviallyCast(intfI,classB));
  assertTrue(typeOracle.canTriviallyCast(classB,classObject));
  assertFalse(typeOracle.canTriviallyCast(classObject,classB));
  assertTrue(typeOracle.canTriviallyCast(classB,intfI));
  assertFalse(typeOracle.canTriviallyCast(intfI,classB));
  assertTrue(typeOracle.canTriviallyCast(classBnn,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,classBnn));
  assertTrue(typeOracle.canTriviallyCast(typeNull,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,typeNull));
  assertTrue(typeOracle.canTriviallyCast(arrayOfBSub,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfBSub));
  assertFalse(typeOracle.canTriviallyCast(arrayOfA,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfA));
  assertFalse(typeOracle.canTriviallyCast(arrayOfArrayOfB,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfArrayOfB));
  assertTrue(typeOracle.canTriviallyCast(arrayOfArrayOfB,arrayOfObject));
  assertFalse(typeOracle.canTriviallyCast(arrayOfObject,arrayOfArrayOfB));
  assertTrue(typeOracle.canTriviallyCast(classJso1,classJso2));
  assertTrue(typeOracle.canTriviallyCast(classJso2,classJso1));
  assertTrue(typeOracle.canTriviallyCast(classJso,classJso1));
  assertTrue(typeOracle.canTriviallyCast(classJso,classJso1));
  assertTrue(typeOracle.canTriviallyCast(arrayOfA,intfSerializable));
  assertFalse(typeOracle.canTriviallyCast(intfSerializable,arrayOfA));
  assertTrue(typeOracle.canTriviallyCast(arrayOfA,intfCloneable));
  assertFalse(typeOracle.canTriviallyCast(intfCloneable,arrayOfA));
  for (  JReferenceType type1 : severalTypes()) {
    for (    JReferenceType type2 : severalTypes()) {
      if (type1 != type2) {
        if (!isJso(type1) || !isJso(type2)) {
          assertFalse(typeOracle.canTriviallyCast(type1,type2) && typeOracle.canTriviallyCast(type2,type1));
        }
      }
    }
  }
}"
82277,"private void createSampleProgram(){
  program=new JProgram();
  typeOracle=program.typeOracle;
  synthSource=program.createSourceInfoSynthetic(JjsTypeTest.class,""String_Node_Str"");
  classObject=createClass(""String_Node_Str"",null,false,false);
  classString=createClass(""String_Node_Str"",classObject,false,true);
  classJso=createClass(""String_Node_Str"",classObject,false,false);
  intfIBase=createInterface(""String_Node_Str"");
  intfI=createInterface(""String_Node_Str"");
  intfI.addImplements(intfIBase);
  intfJ=createInterface(""String_Node_Str"");
  classBase=createClass(""String_Node_Str"",classObject,false,false);
  classA=createClass(""String_Node_Str"",classBase,false,false);
  classB=createClass(""String_Node_Str"",classBase,false,false);
  classB.addImplements(intfI);
  classC=createClass(""String_Node_Str"",classObject,false,false);
  classC.addImplements(intfI);
  classBSub=createClass(""String_Node_Str"",classB,false,false);
  classJso1=createClass(""String_Node_Str"",classJso,false,false);
  classJso2=createClass(""String_Node_Str"",classJso,false,false);
  program.typeOracle.computeBeforeAST();
  typeNull=program.getTypeNull();
  classBnn=program.getNonNullType(classB);
  classBaseNn=program.getNonNullType(classBase);
  arrayOfA=program.getTypeArray(classA,1);
  arrayOfB=program.getTypeArray(classB,1);
  arrayOfBSub=program.getTypeArray(classBSub,1);
  arrayOfC=program.getTypeArray(classC,1);
  arrayOfObject=program.getTypeArray(classObject,1);
  arrayOfInt=program.getTypeArray(program.getTypePrimitiveInt(),1);
  arrayOfArrayOfInt=program.getTypeArray(program.getTypePrimitiveInt(),2);
  arrayOfArrayOfB=program.getTypeArray(classB,2);
}","private void createSampleProgram(){
  program=new JProgram();
  typeOracle=program.typeOracle;
  synthSource=program.createSourceInfoSynthetic(JjsTypeTest.class,""String_Node_Str"");
  classObject=createClass(""String_Node_Str"",null,false,false);
  classString=createClass(""String_Node_Str"",classObject,false,true);
  classJso=createClass(""String_Node_Str"",classObject,false,false);
  intfSerializable=createInterface(""String_Node_Str"");
  intfCloneable=createInterface(""String_Node_Str"");
  intfIBase=createInterface(""String_Node_Str"");
  intfI=createInterface(""String_Node_Str"");
  intfI.addImplements(intfIBase);
  intfJ=createInterface(""String_Node_Str"");
  classBase=createClass(""String_Node_Str"",classObject,false,false);
  classA=createClass(""String_Node_Str"",classBase,false,false);
  classB=createClass(""String_Node_Str"",classBase,false,false);
  classB.addImplements(intfI);
  classC=createClass(""String_Node_Str"",classObject,false,false);
  classC.addImplements(intfI);
  classBSub=createClass(""String_Node_Str"",classB,false,false);
  classJso1=createClass(""String_Node_Str"",classJso,false,false);
  classJso2=createClass(""String_Node_Str"",classJso,false,false);
  program.typeOracle.computeBeforeAST();
  typeNull=program.getTypeNull();
  classBnn=program.getNonNullType(classB);
  classBaseNn=program.getNonNullType(classBase);
  arrayOfA=program.getTypeArray(classA,1);
  arrayOfB=program.getTypeArray(classB,1);
  arrayOfBSub=program.getTypeArray(classBSub,1);
  arrayOfC=program.getTypeArray(classC,1);
  arrayOfObject=program.getTypeArray(classObject,1);
  arrayOfInt=program.getTypeArray(program.getTypePrimitiveInt(),1);
  arrayOfArrayOfInt=program.getTypeArray(program.getTypePrimitiveInt(),2);
  arrayOfArrayOfB=program.getTypeArray(classB,2);
}"
82278,"public void testGeneralizeTypes(){
  assertSame(classA,generalizeTypes(classA,classA));
  assertSame(classB,generalizeTypes(classB,classBnn));
  assertSame(classB,generalizeTypes(classBnn,classB));
  assertSame(classBaseNn,generalizeTypes(classBnn,classBaseNn));
  assertSame(classB,generalizeTypes(classB,typeNull));
  assertSame(classB,generalizeTypes(typeNull,classB));
  assertSame(intfIBase,generalizeTypes(intfI,intfIBase));
  assertSame(intfIBase,generalizeTypes(intfIBase,intfI));
  assertSame(classObject,generalizeTypes(intfJ,intfI));
  assertSame(classObject,generalizeTypes(arrayOfB,arrayOfInt));
  assertSame(classObject,generalizeTypes(arrayOfC,arrayOfArrayOfB));
  assertSame(arrayOfObject,generalizeTypes(arrayOfC,arrayOfB));
  assertSame(arrayOfObject,generalizeTypes(arrayOfObject,arrayOfArrayOfInt));
  assertSame(intfI,generalizeTypes(classB,intfI));
  assertSame(classObject,generalizeTypes(classB,intfJ));
  assertSame(classObject,generalizeTypes(intfI,arrayOfInt));
  for (  JReferenceType type1 : severalTypes()) {
    for (    JReferenceType type2 : severalTypes()) {
      JReferenceType generalized=generalizeTypes(type1,type2);
      assertTrue(typeOracle.canTriviallyCast(type1,generalized));
      assertTrue(typeOracle.canTriviallyCast(type2,generalized));
    }
  }
}","public void testGeneralizeTypes(){
  assertSame(classA,generalizeTypes(classA,classA));
  assertSame(classB,generalizeTypes(classB,classBnn));
  assertSame(classB,generalizeTypes(classBnn,classB));
  assertSame(classBaseNn,generalizeTypes(classBnn,classBaseNn));
  assertSame(classB,generalizeTypes(classB,typeNull));
  assertSame(classB,generalizeTypes(typeNull,classB));
  assertSame(intfIBase,generalizeTypes(intfI,intfIBase));
  assertSame(intfIBase,generalizeTypes(intfIBase,intfI));
  assertSame(classObject,generalizeTypes(intfJ,intfI));
  assertSame(classObject,generalizeTypes(arrayOfB,arrayOfInt));
  assertSame(classObject,generalizeTypes(arrayOfC,arrayOfArrayOfB));
  assertSame(arrayOfObject,generalizeTypes(arrayOfC,arrayOfB));
  assertSame(arrayOfObject,generalizeTypes(arrayOfObject,arrayOfArrayOfInt));
  assertSame(intfI,generalizeTypes(classB,intfI));
  assertSame(classObject,generalizeTypes(classB,intfJ));
  assertSame(classObject,generalizeTypes(intfI,arrayOfInt));
  assertSame(intfSerializable,generalizeTypes(intfSerializable,arrayOfA));
  assertSame(intfCloneable,generalizeTypes(intfCloneable,arrayOfA));
  for (  JReferenceType type1 : severalTypes()) {
    for (    JReferenceType type2 : severalTypes()) {
      JReferenceType generalized=generalizeTypes(type1,type2);
      assertTrue(typeOracle.canTriviallyCast(type1,generalized));
      assertTrue(typeOracle.canTriviallyCast(type2,generalized));
    }
  }
}"
82279,"public void testCanTheoreticallyCast(){
  assertFalse(typeOracle.canTheoreticallyCast(classBnn,typeNull));
  assertTrue(typeOracle.canTheoreticallyCast(classBSub,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classBSub));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classBnn));
  assertTrue(typeOracle.canTheoreticallyCast(classBnn,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classObject,arrayOfB));
  assertFalse(typeOracle.canTheoreticallyCast(arrayOfA,arrayOfArrayOfB));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfObject,arrayOfArrayOfB));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfB,arrayOfBSub));
  assertTrue(typeOracle.canTheoreticallyCast(classBase,intfI));
  assertFalse(typeOracle.canTheoreticallyCast(classA,intfJ));
  assertTrue(typeOracle.canTheoreticallyCast(intfIBase,intfI));
  assertTrue(typeOracle.canTheoreticallyCast(intfIBase,classBase));
  assertFalse(typeOracle.canTheoreticallyCast(intfJ,classA));
}","public void testCanTheoreticallyCast(){
  assertFalse(typeOracle.canTheoreticallyCast(classBnn,typeNull));
  assertTrue(typeOracle.canTheoreticallyCast(classBSub,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classBSub));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classBnn));
  assertTrue(typeOracle.canTheoreticallyCast(classBnn,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classObject,arrayOfB));
  assertFalse(typeOracle.canTheoreticallyCast(arrayOfA,arrayOfArrayOfB));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfObject,arrayOfArrayOfB));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfB,arrayOfBSub));
  assertTrue(typeOracle.canTheoreticallyCast(classBase,intfI));
  assertFalse(typeOracle.canTheoreticallyCast(classA,intfJ));
  assertTrue(typeOracle.canTheoreticallyCast(intfIBase,intfI));
  assertTrue(typeOracle.canTheoreticallyCast(intfIBase,classBase));
  assertFalse(typeOracle.canTheoreticallyCast(intfJ,classA));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfA,intfSerializable));
  assertTrue(typeOracle.canTheoreticallyCast(intfSerializable,arrayOfA));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfA,intfCloneable));
  assertTrue(typeOracle.canTheoreticallyCast(intfCloneable,arrayOfA));
}"
82280,"public void testStrongerType(){
  assertSame(classA,program.strongerType(classA,classA));
  assertSame(classBnn,program.strongerType(classB,classBnn));
  assertSame(classB,program.strongerType(classB,classBase));
  assertSame(classB,program.strongerType(classBase,classB));
  assertSame(intfI,program.strongerType(intfI,intfJ));
}","public void testStrongerType(){
  assertSame(classA,program.strongerType(classA,classA));
  assertSame(classBnn,program.strongerType(classB,classBnn));
  assertSame(classB,program.strongerType(classB,classBase));
  assertSame(classB,program.strongerType(classBase,classB));
  assertSame(intfI,program.strongerType(intfI,intfJ));
  assertSame(arrayOfA,program.strongerType(intfSerializable,arrayOfA));
  assertSame(arrayOfA,program.strongerType(intfCloneable,arrayOfA));
}"
82281,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}"
82282,"public static Timestamp valueOf(String s){
  String[] components=s.split(""String_Node_Str"");
  if (components.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  String[] timeComponents=components[1].split(""String_Node_Str"");
  boolean hasNanos=true;
  int nanos=0;
  if (timeComponents.length == 1) {
    hasNanos=false;
  }
 else   if (timeComponents.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  Date d=Date.valueOf(components[0]);
  Time t=Time.valueOf(timeComponents[0]);
  if (hasNanos) {
    String nanosString=timeComponents[1];
    int len=nanosString.length();
    assert(len > 0);
    if (len > 9) {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
    if (len < 9) {
      nanosString+=""String_Node_Str"".substring(len - 1);
    }
    try {
      nanos=Integer.valueOf(nanosString);
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
  }
  return new Timestamp(d.getYear(),d.getMonth(),d.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),nanos);
}","public static Timestamp valueOf(String s){
}"
82283,"public static Timestamp valueOf(String s){
  String[] components=s.split(""String_Node_Str"");
  if (components.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  String[] timeComponents=components[1].split(""String_Node_Str"");
  if (timeComponents.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
 else   if (timeComponents[1].length() != 9) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  Date d=Date.valueOf(components[0]);
  Time t=Time.valueOf(timeComponents[0]);
  int nanos;
  try {
    nanos=Integer.valueOf(timeComponents[1]);
  }
 catch (  NumberFormatException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  return new Timestamp(d.getYear(),d.getMonth(),d.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),nanos);
}","public static Timestamp valueOf(String s){
  String[] components=s.split(""String_Node_Str"");
  if (components.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  String[] timeComponents=components[1].split(""String_Node_Str"");
  boolean hasNanos=true;
  int nanos=0;
  if (timeComponents.length == 1) {
    hasNanos=false;
  }
 else   if (timeComponents.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  Date d=Date.valueOf(components[0]);
  Time t=Time.valueOf(timeComponents[0]);
  if (hasNanos) {
    String nanosString=timeComponents[1];
    int len=nanosString.length();
    assert(len > 0);
    if (len > 9) {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
    if (len < 9) {
      nanosString+=""String_Node_Str"".substring(len - 1);
    }
    try {
      nanos=Integer.valueOf(nanosString);
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
  }
  return new Timestamp(d.getYear(),d.getMonth(),d.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),nanos);
}"
82284,"public void testValueOf(){
  try {
    Timestamp.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Timestamp.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  Timestamp expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456789);
  Timestamp actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
}","public void testValueOf(){
  try {
    Timestamp.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Timestamp.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  Timestamp expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456789);
  Timestamp actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,0);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,100000000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,120000000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123000000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123400000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123450000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456700);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456780);
  actual=Timestamp.valueOf(""String_Node_Str"");
}"
82285,"public void process(CompilationUnitBuilder builder,CompilationUnitDeclaration cud,List<CompiledClass> compiledClasses){
  Map<AbstractMethodDeclaration,JsniMethod> jsniMethods=JsniCollector.collectJsniMethods(cud,builder.getSource(),jsProgram);
  final Set<String> jsniDeps=new HashSet<String>();
  JsniChecker.check(cud,jsniMethods,new JsniChecker.TypeResolver(){
    public ReferenceBinding resolveType(    String typeName){
      ReferenceBinding resolveType=compiler.resolveType(typeName);
      if (resolveType != null) {
        String fileName=String.valueOf(resolveType.getFileName());
        jsniDeps.add(fileName);
      }
      return resolveType;
    }
  }
);
  JSORestrictionsChecker.check(jsoState,cud);
  ArtificialRescueChecker.check(cud,builder.isGenerated());
  BinaryTypeReferenceRestrictionsChecker.check(cud);
  CompilationUnitInvalidator.reportErrors(logger,cud,builder.getSource());
  Set<ContentId> dependencies=compiler.computeDependencies(cud,jsniDeps);
  CompilationUnit unit=builder.build(compiledClasses,dependencies,jsniMethods.values(),cud.compilationResult().getProblems());
  if (cud.compilationResult().hasErrors()) {
    unit=new ErrorCompilationUnit(unit);
  }
 else {
    addValidUnit(unit);
    ContentId contentId=builder.getContentId();
    unitCache.put(contentId,unit);
    if (builder instanceof ResourceCompilationUnitBuilder) {
      ResourceCompilationUnitBuilder rcub=(ResourceCompilationUnitBuilder)builder;
      ResourceTag resourceTag=new ResourceTag(rcub.getLastModifed(),contentId);
      resourceContentCache.put(builder.getLocation(),resourceTag);
      keepAliveLatestVersion.put(resourceTag,unit);
    }
 else     if (builder instanceof GeneratedCompilationUnitBuilder) {
      keepAliveRecentlyGenerated.put(unit.getTypeName(),unit);
    }
  }
  resultUnits.put(unit.getTypeName(),unit);
}","public void process(CompilationUnitBuilder builder,CompilationUnitDeclaration cud,List<CompiledClass> compiledClasses){
  Map<AbstractMethodDeclaration,JsniMethod> jsniMethods=JsniCollector.collectJsniMethods(cud,builder.getSource(),jsProgram);
  final Set<String> jsniDeps=new HashSet<String>();
  JsniChecker.check(cud,jsniMethods,new JsniChecker.TypeResolver(){
    public ReferenceBinding resolveType(    String typeName){
      ReferenceBinding resolveType=compiler.resolveType(typeName);
      if (resolveType != null) {
        String fileName=String.valueOf(resolveType.getFileName());
        jsniDeps.add(fileName);
      }
      return resolveType;
    }
  }
);
  JSORestrictionsChecker.check(jsoState,cud);
  ArtificialRescueChecker.check(cud,builder.isGenerated());
  BinaryTypeReferenceRestrictionsChecker.check(cud);
  MethodArgNamesLookup methodArgs=MethodParamCollector.collect(cud);
  CompilationUnitInvalidator.reportErrors(logger,cud,builder.getSource());
  Set<ContentId> dependencies=compiler.computeDependencies(cud,jsniDeps);
  CompilationUnit unit=builder.build(compiledClasses,dependencies,jsniMethods.values(),methodArgs,cud.compilationResult().getProblems());
  if (cud.compilationResult().hasErrors()) {
    unit=new ErrorCompilationUnit(unit);
  }
 else {
    addValidUnit(unit);
    ContentId contentId=builder.getContentId();
    unitCache.put(contentId,unit);
    if (builder instanceof ResourceCompilationUnitBuilder) {
      ResourceCompilationUnitBuilder rcub=(ResourceCompilationUnitBuilder)builder;
      ResourceTag resourceTag=new ResourceTag(rcub.getLastModifed(),contentId);
      resourceContentCache.put(builder.getLocation(),resourceTag);
      keepAliveLatestVersion.put(resourceTag,unit);
    }
 else     if (builder instanceof GeneratedCompilationUnitBuilder) {
      keepAliveRecentlyGenerated.put(unit.getTypeName(),unit);
    }
  }
  resultUnits.put(unit.getTypeName(),unit);
}"
82286,"public GeneratedCompilationUnit(GeneratedUnit generatedUnit,List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,CategorizedProblem[] problems){
  super(compiledClasses,dependencies,jsniMethods,problems);
  this.generatedUnit=generatedUnit;
}","public GeneratedCompilationUnit(GeneratedUnit generatedUnit,List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,MethodArgNamesLookup methodArgs,CategorizedProblem[] problems){
  super(compiledClasses,dependencies,jsniMethods,methodArgs,problems);
  this.generatedUnit=generatedUnit;
}"
82287,"@Override public boolean isSuperSource(){
  return false;
}","@Deprecated @Override public boolean isSuperSource(){
  return false;
}"
82288,"public CompilationUnit build(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,CategorizedProblem[] problems){
  source=null;
  return makeUnit(compiledClasses,dependencies,jsniMethods,problems);
}","public CompilationUnit build(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,MethodArgNamesLookup methodArgs,CategorizedProblem[] problems){
  source=null;
  return makeUnit(compiledClasses,dependencies,jsniMethods,methodArgs,problems);
}"
82289,"protected abstract CompilationUnit makeUnit(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,CategorizedProblem[] errors);","protected abstract CompilationUnit makeUnit(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,MethodArgNamesLookup methodArgs,CategorizedProblem[] errors);"
82290,"public CompilationUnitImpl(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,CategorizedProblem[] problems){
  this.exposedCompiledClasses=Lists.normalizeUnmodifiable(compiledClasses);
  this.dependencies=dependencies;
  this.jsniMethods=Lists.create(jsniMethods.toArray(new JsniMethod[jsniMethods.size()]));
  this.problems=problems;
  for (  CompiledClass cc : compiledClasses) {
    cc.initUnit(this);
  }
}","public CompilationUnitImpl(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,MethodArgNamesLookup methodArgs,CategorizedProblem[] problems){
  this.exposedCompiledClasses=Lists.normalizeUnmodifiable(compiledClasses);
  this.dependencies=dependencies;
  this.jsniMethods=Lists.create(jsniMethods.toArray(new JsniMethod[jsniMethods.size()]));
  this.methodArgs=methodArgs;
  this.problems=problems;
  for (  CompiledClass cc : compiledClasses) {
    cc.initUnit(this);
  }
}"
82291,"Set<ContentId> getDependencies(){
  return dependencies;
}","@Override Set<ContentId> getDependencies(){
  return dependencies;
}"
82292,"public List<JsniMethod> getJsniMethods(){
  return jsniMethods;
}","@Override public List<JsniMethod> getJsniMethods(){
  return jsniMethods;
}"
82293,"/** 
 * Returns all contained classes.
 */
Collection<CompiledClass> getCompiledClasses(){
  return exposedCompiledClasses;
}","/** 
 * Returns all contained classes.
 */
@Override Collection<CompiledClass> getCompiledClasses(){
  return exposedCompiledClasses;
}"
82294,"CategorizedProblem[] getProblems(){
  return problems;
}","@Override CategorizedProblem[] getProblems(){
  return problems;
}"
82295,"public boolean isCompiled(){
  return false;
}","@Override public boolean isCompiled(){
  return false;
}"
82296,"public long getLastModified(){
  return unit.getLastModified();
}","@Override public long getLastModified(){
  return unit.getLastModified();
}"
82297,"public boolean isSuperSource(){
  return unit.isSuperSource();
}","@Override @Deprecated public boolean isSuperSource(){
  return unit.isSuperSource();
}"
82298,"public List<JsniMethod> getJsniMethods(){
  return unit.getJsniMethods();
}","@Override public List<JsniMethod> getJsniMethods(){
  return unit.getJsniMethods();
}"
82299,"public boolean isGenerated(){
  return unit.isGenerated();
}","@Override @Deprecated public boolean isGenerated(){
  return unit.isGenerated();
}"
82300,"public boolean isError(){
  return true;
}","@Override public boolean isError(){
  return true;
}"
82301,"public String getDisplayLocation(){
  return unit.getDisplayLocation();
}","@Override public String getDisplayLocation(){
  return unit.getDisplayLocation();
}"
82302,"public String getSource(){
  return unit.getSource();
}","@Override @Deprecated public String getSource(){
  return unit.getSource();
}"
82303,"public String getTypeName(){
  return unit.getTypeName();
}","@Override public String getTypeName(){
  return unit.getTypeName();
}"
82304,"public boolean isCompiled(){
  return false;
}","@Override public boolean isCompiled(){
  return false;
}"
82305,"public long getLastModified(){
  return unit.getLastModified();
}","@Override public long getLastModified(){
  return unit.getLastModified();
}"
82306,"public boolean isSuperSource(){
  return unit.isSuperSource();
}","@Override @Deprecated public boolean isSuperSource(){
  return unit.isSuperSource();
}"
82307,"public List<JsniMethod> getJsniMethods(){
  return unit.getJsniMethods();
}","@Override public List<JsniMethod> getJsniMethods(){
  return unit.getJsniMethods();
}"
82308,"public boolean isGenerated(){
  return unit.isGenerated();
}","@Override @Deprecated public boolean isGenerated(){
  return unit.isGenerated();
}"
82309,"public boolean isError(){
  return false;
}","@Override public boolean isError(){
  return false;
}"
82310,"public String getDisplayLocation(){
  return unit.getDisplayLocation();
}","@Override public String getDisplayLocation(){
  return unit.getDisplayLocation();
}"
82311,"public String getSource(){
  return unit.getSource();
}","@Override @Deprecated public String getSource(){
  return unit.getSource();
}"
82312,"public String getTypeName(){
  return unit.getTypeName();
}","@Override public String getTypeName(){
  return unit.getTypeName();
}"
82313,"/** 
 * Escapes '&', '<', '>', '""', and optionally ''' to their XML entity equivalents. The portion of the input string between start (inclusive) and end (exclusive) is scanned.  The output is appended to the given StringBuilder.
 * @param code the input String
 * @param start the first character position to scan.
 * @param end the character position following the last character to scan.
 * @param quoteApostrophe if true, the &apos; character is quoted as&amp;apos;
 * @param builder a StringBuilder to be appended with the output.
 */
public static void escapeXml(String code,int start,int end,boolean quoteApostrophe,StringBuilder builder){
  int lastIndex=0;
  int len=end - start;
  char[] c=new char[len];
  code.getChars(start,end,c,0);
  for (int i=0; i < len; i++) {
    if ((c[i] >= '\uD800') && (c[i] <= '\uDBFF')) {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
      break;
    }
 else     if ((c[i] >= '\uDC00') && (c[i] <= '\uDFFF')) {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
      break;
    }
 else     if (c[i] == '\0') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
      break;
    }
 else     if (c[i] == '\uffff') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
      break;
    }
 else     if (c[i] == '\ufffe') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '&') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '>') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '<') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '\""') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '\'') {
      if (quoteApostrophe) {
        builder.append(c,lastIndex,i - lastIndex);
        builder.append(""String_Node_Str"");
        lastIndex=i + 1;
      }
    }
  }
  builder.append(c,lastIndex,len - lastIndex);
}","/** 
 * Escapes '&', '<', '>', '""', and optionally ''' to their XML entity equivalents. The portion of the input string between start (inclusive) and end (exclusive) is scanned.  The output is appended to the given StringBuilder.
 * @param code the input String
 * @param start the first character position to scan.
 * @param end the character position following the last character to scan.
 * @param quoteApostrophe if true, the &apos; character is quoted as&amp;apos;
 * @param builder a StringBuilder to be appended with the output.
 */
public static void escapeXml(String code,int start,int end,boolean quoteApostrophe,StringBuilder builder){
  int lastIndex=0;
  int len=end - start;
  char[] c=new char[len];
  code.getChars(start,end,c,0);
  for (int i=0; i < len; i++) {
    if ((c[i] < '\u0020')) {
      builder.append(c,lastIndex,i - lastIndex);
      if (c[i] == '\u0000') {
        builder.append(""String_Node_Str"");
      }
 else       if (c[i] == '\u0009') {
        builder.append(""String_Node_Str"");
      }
 else       if (c[i] == '\n') {
        builder.append(""String_Node_Str"");
      }
 else       if (c[i] == '\r') {
        builder.append(""String_Node_Str"");
      }
 else {
        builder.append(""String_Node_Str"" + charToHex(c[i]) + ""String_Node_Str"");
      }
      lastIndex=i + 1;
    }
 else     if (((c[i] >= '\u007F') && (c[i] <= '\u0084')) || ((c[i] >= '\u0086') && (c[i] <= '\u009F')) || ((c[i] >= '\uD800') && (c[i] <= '\uDBFF'))|| ((c[i] >= '\uDC00') && (c[i] <= '\uDFFF'))|| ((c[i] >= '\uFDD0') && (c[i] <= '\uFDDF'))|| (c[i] == '\u00A0')|| (c[i] == '\uFFFF')|| (c[i] == '\uFFFE')) {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"" + charToHex(c[i]) + ""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '&') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '>') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '<') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '\""') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '\'') {
      if (quoteApostrophe) {
        builder.append(c,lastIndex,i - lastIndex);
        builder.append(""String_Node_Str"");
        lastIndex=i + 1;
      }
    }
 else     if (c[i] > '\u007F') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"" + charToHex(c[i]) + ""String_Node_Str"");
      lastIndex=i + 1;
    }
  }
  builder.append(c,lastIndex,len - lastIndex);
}"
82314,"private static String escapeXml(String unescaped){
  String escaped=unescaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  escaped=escaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  escaped=escaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  escaped=escaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  escaped=escaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  return escaped;
}","private static String escapeXml(String unescaped){
  return SizeMapRecorder.escapeXml(unescaped);
}"
82315,"/** 
 * Checks whether the given method qualifies as a setter. This looks at the method qualifiers, name and return type, but not at the parameter types.
 * @param method the method to look at
 * @return whether it's a setter
 */
private boolean isSetterMethod(JMethod method){
  return method.isPublic() && !method.isStatic() && method.getName().startsWith(""String_Node_Str"")&& method.getReturnType() == JPrimitiveType.VOID;
}","/** 
 * Checks whether the given method qualifies as a setter. This looks at the method qualifiers, name and return type, but not at the parameter types.
 * @param method the method to look at
 * @return whether it's a setter
 */
private boolean isSetterMethod(JMethod method){
  return method.isPublic() && !method.isStatic() && method.getName().startsWith(""String_Node_Str"")&& method.getName().length() > 3 && method.getReturnType() == JPrimitiveType.VOID;
}"
82316,"/** 
 * Formats Year field according to pattern specified. Javascript Date object seems incapable handling 1BC and year before. It can show you year 0 which does not exists. following we just keep consistent with javascript's toString method. But keep in mind those things should be unsupported.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatYear(StringBuffer buf,int count,Date date){
  int value=date.getYear() + JS_START_YEAR;
  if (value < 0) {
    value=-value;
  }
  if (count == 2) {
    zeroPaddingNumber(buf,value % 100,2);
  }
 else {
    buf.append(Integer.toString(value));
  }
}","/** 
 * Formats Year field according to pattern specified. Javascript Date object seems incapable handling 1BC and year before. It can show you year 0 which does not exists. following we just keep consistent with javascript's toString method. But keep in mind those things should be unsupported.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatYear(StringBuffer buf,int count,Date date){
  int value=date.getYear() + JS_START_YEAR;
  if (value < 0) {
    value=-value;
  }
  if (count == 2) {
    zeroPaddingNumber(buf,value % 100,2);
  }
 else {
    buf.append(value);
  }
}"
82317,"/** 
 * Formats Fractional seconds field according to pattern specified.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatFractionalSeconds(StringBuffer buf,int count,Date date){
  long time=date.getTime();
  int value;
  if (time < 0) {
    value=1000 - (int)(-time % 1000);
  }
 else {
    value=(int)(time % 1000);
  }
  if (count == 1) {
    value=(value + 50) / 100;
    buf.append(Integer.toString(value));
  }
 else   if (count == 2) {
    value=(value + 5) / 10;
    zeroPaddingNumber(buf,value,2);
  }
 else {
    zeroPaddingNumber(buf,value,3);
    if (count > 3) {
      zeroPaddingNumber(buf,0,count - 3);
    }
  }
}","/** 
 * Formats Fractional seconds field according to pattern specified.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatFractionalSeconds(StringBuffer buf,int count,Date date){
  long time=date.getTime();
  int value;
  if (time < 0) {
    value=1000 - (int)(-time % 1000);
  }
 else {
    value=(int)(time % 1000);
  }
  if (count == 1) {
    value=Math.min((value + 50) / 100,9);
    buf.append((char)('0' + value));
  }
 else   if (count == 2) {
    value=Math.min((value + 5) / 10,99);
    zeroPaddingNumber(buf,value,2);
  }
 else {
    zeroPaddingNumber(buf,value,3);
    if (count > 3) {
      zeroPaddingNumber(buf,0,count - 3);
    }
  }
}"
82318,"/** 
 * Formats a number with the specified minimum number of digits, using zero to fill the gap.
 * @param buf where zero padded string will be written to
 * @param value the number value being formatted
 * @param minWidth minimum width of the formatted string; zero will be paddedto reach this width
 */
private void zeroPaddingNumber(StringBuffer buf,int value,int minWidth){
  int b=NUMBER_BASE;
  for (int i=0; i < minWidth - 1; i++) {
    if (value < b) {
      buf.append('0');
    }
    b*=NUMBER_BASE;
  }
  buf.append(Integer.toString(value));
}","/** 
 * Formats a number with the specified minimum number of digits, using zero to fill the gap.
 * @param buf where zero padded string will be written to
 * @param value the number value being formatted
 * @param minWidth minimum width of the formatted string; zero will be paddedto reach this width
 */
private void zeroPaddingNumber(StringBuffer buf,int value,int minWidth){
  int b=NUMBER_BASE;
  for (int i=0; i < minWidth - 1; i++) {
    if (value < b) {
      buf.append('0');
    }
    b*=NUMBER_BASE;
  }
  buf.append(value);
}"
82319,"@Override @SuppressWarnings(""String_Node_Str"") public <T>T[] toArray(T[] a){
  Object[] result=super.toArray(a);
  for (int i=0, c=result.length; i < c; ++i) {
    result[i]=new UnmodifiableEntry<K,V>((Map.Entry<K,V>)result[i]);
  }
  return (T[])result;
}","@Override @SuppressWarnings(""String_Node_Str"") public <T>T[] toArray(T[] a){
  Object[] result=super.toArray(a);
  wrap(result,coll.size());
  return (T[])result;
}"
82320,"public int compare(Object o1,Object o2){
  String s1=(String)o1;
  String s2=(String)o2;
  return s2.compareTo(s1);
}","public int compare(String s1,String s2){
  return s2.compareTo(s1);
}"
82321,"public void testSort(){
  List a=createSortedList();
  Collections.reverse(a);
  Collections.sort(a);
  assertEquals(createSortedList(),a);
}","public void testSort(){
  List<String> a=createSortedList();
  Collections.reverse(a);
  Collections.sort(a);
  assertEquals(createSortedList(),a);
}"
82322,"public static List createSortedList(){
  ArrayList l=new ArrayList();
  l.add(""String_Node_Str"");
  l.add(""String_Node_Str"");
  l.add(""String_Node_Str"");
  return l;
}","public static List<String> createSortedList(){
  ArrayList<String> l=new ArrayList<String>();
  l.add(""String_Node_Str"");
  l.add(""String_Node_Str"");
  l.add(""String_Node_Str"");
  return l;
}"
82323,"/** 
 * Test Collections.binarySearch(List, Object, Comparator). Verify the following cases: empty List odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements null Comparator uses natural ordering
 */
public void testBinarySearchObjectComparator(){
  Comparator inverseSort=new Comparator(){
    public int compare(    Object o1,    Object o2){
      return ((Comparable)o2).compareTo(o1);
    }
  }
;
  List a1=new ArrayList();
  int ret=Collections.binarySearch(a1,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  List a2=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(-3,ret);
  ret=Collections.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(2,ret);
  List a3=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-5,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(0,ret);
  List a4=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a4,""String_Node_Str"",null);
  assertEquals(3,ret);
}","/** 
 * Test Collections.binarySearch(List, Object, Comparator). Verify the following cases: empty List odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements null Comparator uses natural ordering
 */
public void testBinarySearchObjectComparator(){
  Comparator<String> inverseSort=new Comparator<String>(){
    public int compare(    String o1,    String o2){
      return o2.compareTo(o1);
    }
  }
;
  List<String> a1=new ArrayList<String>();
  int ret=Collections.binarySearch(a1,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  List<String> a2=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(-3,ret);
  ret=Collections.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(2,ret);
  List<String> a3=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-5,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(0,ret);
  List<String> a4=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a4,""String_Node_Str"",null);
  assertEquals(3,ret);
}"
82324,"public void testReverse(){
  List a=createSortedList();
  Collections.reverse(a);
  Object[] x={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,a);
  List b=createRandomList();
  Collections.reverse(b);
  Collections.reverse(b);
  assertEquals(b,createRandomList());
}","public void testReverse(){
  List<String> a=createSortedList();
  Collections.reverse(a);
  Object[] x={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,a);
  List<Integer> b=createRandomList();
  Collections.reverse(b);
  Collections.reverse(b);
  assertEquals(b,createRandomList());
}"
82325,"public void testSortWithComparator(){
  Comparator x=new Comparator(){
    public int compare(    Object o1,    Object o2){
      String s1=(String)o1;
      String s2=(String)o2;
      return s2.compareTo(s1);
    }
  }
;
  List a=createSortedList();
  Collections.sort(a,x);
  Object[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(expected,a);
}","public void testSortWithComparator(){
  Comparator<String> x=new Comparator<String>(){
    public int compare(    String s1,    String s2){
      return s2.compareTo(s1);
    }
  }
;
  List<String> a=createSortedList();
  Collections.sort(a,x);
  Object[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(expected,a);
}"
82326,"public void testFill(){
  List a=createSortedList();
  Collections.fill(a,null);
  assertEquals(new Object[a.size()],a);
  List b=createRandomList();
  Collections.fill(b,null);
  assertEquals(new Object[b.size()],b);
}","public void testFill(){
  List<String> a=createSortedList();
  Collections.fill(a,null);
  assertEquals(new Object[a.size()],a);
  List<Integer> b=createRandomList();
  Collections.fill(b,null);
  assertEquals(new Object[b.size()],b);
}"
82327,"/** 
 * Test Collections.binarySearch(List, Object). Verify the following cases: empty List odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements
 */
public void testBinarySearchObject(){
  List a1=new ArrayList();
  int ret=Collections.binarySearch(a1,""String_Node_Str"");
  assertEquals(-1,ret);
  List a2=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a2,""String_Node_Str"");
  assertEquals(-2,ret);
  ret=Collections.binarySearch(a2,""String_Node_Str"");
  assertEquals(2,ret);
  List a3=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(-5,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(-1,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(0,ret);
}","/** 
 * Test Collections.binarySearch(List, Object). Verify the following cases: empty List odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements
 */
public void testBinarySearchObject(){
  List<String> a1=new ArrayList<String>();
  int ret=Collections.binarySearch(a1,""String_Node_Str"");
  assertEquals(-1,ret);
  List<String> a2=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a2,""String_Node_Str"");
  assertEquals(-2,ret);
  ret=Collections.binarySearch(a2,""String_Node_Str"");
  assertEquals(2,ret);
  List<String> a3=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(-5,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(-1,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(0,ret);
}"
82328,"public static List createRandomList(){
  ArrayList l=new ArrayList();
  l.add(new Integer(5));
  l.add(new Integer(2));
  l.add(new Integer(3));
  l.add(new Integer(1));
  l.add(new Integer(4));
  return l;
}","public static List<Integer> createRandomList(){
  ArrayList<Integer> l=new ArrayList<Integer>();
  l.add(new Integer(5));
  l.add(new Integer(2));
  l.add(new Integer(3));
  l.add(new Integer(1));
  l.add(new Integer(4));
  return l;
}"
82329,"public static void retainValidUnits(Collection<CompilationUnit> units,Set<ContentId> knownValidRefs){
  Set<CompilationUnit> currentlyValidUnits=new HashSet<CompilationUnit>();
  Set<ContentId> currentlyValidRefs=new HashSet<ContentId>(knownValidRefs);
  for (  CompilationUnit unit : units) {
    if (unit.isCompiled()) {
      currentlyValidUnits.add(unit);
      currentlyValidRefs.add(unit.getContentId());
    }
  }
  boolean changed;
  do {
    changed=false;
    iterating:     for (Iterator<CompilationUnit> it=currentlyValidUnits.iterator(); it.hasNext(); ) {
      CompilationUnit unitToCheck=it.next();
      for (      ContentId ref : unitToCheck.getDependencies()) {
        if (!currentlyValidRefs.contains(ref)) {
          it.remove();
          currentlyValidRefs.remove(unitToCheck.getDisplayLocation());
          changed=true;
          continue iterating;
        }
      }
    }
  }
 while (changed);
  units.retainAll(currentlyValidUnits);
}","public static void retainValidUnits(Collection<CompilationUnit> units,Set<ContentId> knownValidRefs){
  Set<CompilationUnit> currentlyValidUnits=new HashSet<CompilationUnit>();
  Set<ContentId> currentlyValidRefs=new HashSet<ContentId>(knownValidRefs);
  for (  CompilationUnit unit : units) {
    if (unit.isCompiled()) {
      currentlyValidUnits.add(unit);
      currentlyValidRefs.add(unit.getContentId());
    }
  }
  boolean changed;
  do {
    changed=false;
    iterating:     for (Iterator<CompilationUnit> it=currentlyValidUnits.iterator(); it.hasNext(); ) {
      CompilationUnit unitToCheck=it.next();
      for (      ContentId ref : unitToCheck.getDependencies()) {
        if (!currentlyValidRefs.contains(ref)) {
          it.remove();
          currentlyValidRefs.remove(unitToCheck.getContentId());
          changed=true;
          continue iterating;
        }
      }
    }
  }
 while (changed);
  units.retainAll(currentlyValidUnits);
}"
82330,"/** 
 * Returns a pretty printed list of clients that have not retrieved the current test. Used for error reporting.
 * @param testInfo the {@link TestInfo} we are waiting for
 * @return a string containing the list of clients that have not retrieved thecurrent test.
 */
String getUnretrievedClients(TestInfo testInfo){
synchronized (clientStatusesLock) {
    Map<ClientStatus,JUnitResult> results=testResults.get(testInfo);
    StringBuilder buf=new StringBuilder();
    int lineCount=0;
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      if (results == null || !results.containsKey(clientStatus)) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(clientStatus.clientDesc);
      ++lineCount;
    }
    int difference=numClients - getNumClientsRetrievedTest(testInfo);
    if (difference > 0) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      buf.append(""String_Node_Str"" + difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}","/** 
 * Returns a pretty printed list of clients that have not retrieved the current test. Used for error reporting.
 * @param testInfo the {@link TestInfo} we are waiting for
 * @return a string containing the list of clients that have not retrieved thecurrent test.
 */
String getUnretrievedClients(TestInfo testInfo){
synchronized (clientStatusesLock) {
    Map<ClientStatus,JUnitResult> results=testResults.get(testInfo);
    StringBuilder buf=new StringBuilder();
    int lineCount=0;
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      if (results == null || !results.containsKey(clientStatus)) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(clientStatus.getDesc());
      ++lineCount;
    }
    int difference=numClients - getNumClientsRetrievedTest(testInfo);
    if (difference > 0) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      buf.append(""String_Node_Str"" + difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}"
82331,"public void reportFatalLaunch(String clientId,String clientDesc,String userAgent,JUnitResult result){
  ClientStatus clientStatus=ensureClientStatus(clientId,clientDesc);
  Map<TestInfo,JUnitResult> results=new HashMap<TestInfo,JUnitResult>();
  for (  TestInfo testInfo : testBlocks.get(clientStatus.blockIndex)) {
    results.put(testInfo,result);
  }
  reportResults(clientId,clientDesc,userAgent,results);
}","/** 
 * Reports a failure from a client that cannot startup.
 * @param clientInfo information about the client
 * @param result the failure result
 */
public void reportFatalLaunch(ClientInfoExt clientInfo,JUnitResult result){
  ClientStatus clientStatus=ensureClientStatus(clientInfo);
  Map<TestInfo,JUnitResult> results=new HashMap<TestInfo,JUnitResult>();
  for (  TestInfo testInfo : testBlocks.get(clientStatus.blockIndex)) {
    results.put(testInfo,result);
  }
  reportResults(clientInfo,results);
}"
82332,"/** 
 * Returns any new clients that have contacted the server since the last call. The same client will never be returned from this method twice.
 */
String[] getNewClients(){
synchronized (clientStatusesLock) {
    List<String> results=new ArrayList<String>();
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (clientStatus.isNew) {
        results.add(clientStatus.clientDesc);
        clientStatus.isNew=false;
      }
    }
    clientStatusesLock.notifyAll();
    return results.toArray(new String[results.size()]);
  }
}","/** 
 * Returns any new clients that have contacted the server since the last call. The same client will never be returned from this method twice.
 */
String[] getNewClients(){
synchronized (clientStatusesLock) {
    List<String> results=new ArrayList<String>();
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (clientStatus.isNew) {
        results.add(clientStatus.getDesc());
        clientStatus.isNew=false;
      }
    }
    clientStatusesLock.notifyAll();
    return results.toArray(new String[results.size()]);
  }
}"
82333,"public ClientStatus(String clientId,String clientDesc){
  this.clientId=clientId;
  this.clientDesc=clientDesc;
}","public ClientStatus(ClientInfoExt clientInfo){
  this.clientInfo=clientInfo;
}"
82334,"/** 
 * Ensure that a   {@link ClientStatus} for the clientId exists.
 * @param clientId the id of the client
 * @return the {@link ClientStatus} for the client
 */
private ClientStatus ensureClientStatus(String clientId,String clientDesc){
  ClientStatus clientStatus=clientStatuses.get(clientId);
  if (clientStatus == null) {
    clientStatus=new ClientStatus(clientId,clientDesc);
    clientStatuses.put(clientId,clientStatus);
  }
 else {
    clientStatus.clientDesc=clientDesc;
  }
  return clientStatus;
}","/** 
 * Ensure that a   {@link ClientStatus} for the clientId exists.
 * @param clientId the id of the client
 * @return the {@link ClientStatus} for the client
 */
private ClientStatus ensureClientStatus(ClientInfoExt clientInfo){
  int id=clientInfo.getSessionId();
  ClientStatus clientStatus=clientStatuses.get(id);
  if (clientStatus == null) {
    clientStatus=new ClientStatus(clientInfo);
    clientStatuses.put(id,clientStatus);
  }
 else {
    clientStatus.updateClientInfo(clientInfo);
  }
  return clientStatus;
}"
82335,"/** 
 * Called by the servlet to report the results of the last test to run.
 * @param clientId the ID of the client
 * @param userAgent the user agent property of the client
 * @param results the result of running the test block
 */
public void reportResults(String clientId,String clientDesc,String userAgent,Map<TestInfo,JUnitResult> results){
synchronized (clientStatusesLock) {
    if (results == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    userAgents.add(userAgent);
    ClientStatus clientStatus=ensureClientStatus(clientId,clientDesc);
    for (    Map.Entry<TestInfo,JUnitResult> entry : results.entrySet()) {
      TestInfo testInfo=entry.getKey();
      ensureResults(testInfo).put(clientStatus,entry.getValue());
    }
    clientStatusesLock.notifyAll();
  }
}","/** 
 * Called by the servlet to report the results of the last test to run.
 * @param clientInfo information about the client
 * @param results the result of running the test block
 */
public void reportResults(ClientInfoExt clientInfo,Map<TestInfo,JUnitResult> results){
synchronized (clientStatusesLock) {
    if (results == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    userAgents.add(clientInfo.getUserAgent());
    ClientStatus clientStatus=ensureClientStatus(clientInfo);
    for (    Map.Entry<TestInfo,JUnitResult> entry : results.entrySet()) {
      TestInfo testInfo=entry.getKey();
      ensureResults(testInfo).put(clientStatus,entry.getValue());
    }
    clientStatusesLock.notifyAll();
  }
}"
82336,"/** 
 * Returns a human-formatted message identifying what clients have connected but have not yet reported results for this test. It is used in a timeout condition, to identify what we're still waiting on.
 * @param testInfo the {@link TestInfo} that the clients are working on
 * @return human readable message
 */
String getWorkingClients(TestInfo testInfo){
synchronized (clientStatusesLock) {
    int itemCount=0;
    StringBuilder buf=new StringBuilder();
    Map<ClientStatus,JUnitResult> results=testResults.get(testInfo);
    if (results != null) {
      for (      Map.Entry<ClientStatus,JUnitResult> entry : results.entrySet()) {
        if (entry.getValue() == null) {
          buf.append(entry.getKey().clientDesc);
          buf.append(""String_Node_Str"");
          itemCount++;
        }
      }
    }
    int difference=numClients - itemCount;
    if (difference > 0) {
      if (itemCount > 0) {
        buf.append('\n');
      }
      buf.append(difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}","/** 
 * Returns a human-formatted message identifying what clients have connected but have not yet reported results for this test. It is used in a timeout condition, to identify what we're still waiting on.
 * @param testInfo the {@link TestInfo} that the clients are working on
 * @return human readable message
 */
String getWorkingClients(TestInfo testInfo){
synchronized (clientStatusesLock) {
    int itemCount=0;
    StringBuilder buf=new StringBuilder();
    Map<ClientStatus,JUnitResult> results=testResults.get(testInfo);
    if (results != null) {
      for (      Map.Entry<ClientStatus,JUnitResult> entry : results.entrySet()) {
        if (entry.getValue() == null) {
          buf.append(entry.getKey().getDesc());
          buf.append(""String_Node_Str"");
          itemCount++;
        }
      }
    }
    int difference=numClients - itemCount;
    if (difference > 0) {
      if (itemCount > 0) {
        buf.append('\n');
      }
      buf.append(difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}"
82337,"/** 
 * Called by the servlet to query for for the next block to test.
 * @param clientId the ID of the client
 * @param userAgent the user agent property of the client
 * @param blockIndex the index of the test block to get
 * @param timeout how long to wait for an answer
 * @return the next test to run, or <code>null</code> if<code>timeout</code> is exceeded or the next test does not match <code>testClassName</code>
 */
public TestBlock getTestBlock(String clientId,String clientDesc,String userAgent,int blockIndex,long timeout) throws TimeoutException {
synchronized (clientStatusesLock) {
    userAgents.add(userAgent);
    ClientStatus clientStatus=ensureClientStatus(clientId,clientDesc);
    clientStatus.blockIndex=blockIndex;
    if (isLastTestBlockAvailable && blockIndex >= testBlocks.size()) {
      return null;
    }
    long startTime=System.currentTimeMillis();
    long stopTime=startTime + timeout;
    while (blockIndex >= testBlocks.size()) {
      long timeToWait=stopTime - System.currentTimeMillis();
      if (timeToWait < 1) {
        double elapsed=(System.currentTimeMillis() - startTime) / 1000.0;
        throw new TimeoutException(""String_Node_Str"" + ""String_Node_Str"" + timeout + ""String_Node_Str""+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
      }
      try {
        clientStatusesLock.wait(timeToWait);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
        return null;
      }
    }
    TestInfo[] tests=testBlocks.get(blockIndex);
    for (    TestInfo testInfo : tests) {
      ensureResults(testInfo).put(clientStatus,null);
    }
    return new TestBlock(tests,blockIndex);
  }
}","/** 
 * Called by the servlet to query for for the next block to test.
 * @param clientInfo information about the client
 * @param blockIndex the index of the test block to get
 * @param timeout how long to wait for an answer
 * @return the next test to run, or <code>null</code> if<code>timeout</code> is exceeded or the next test does not match <code>testClassName</code>
 */
public TestBlock getTestBlock(ClientInfoExt clientInfo,int blockIndex,long timeout) throws TimeoutException {
synchronized (clientStatusesLock) {
    userAgents.add(clientInfo.getUserAgent());
    ClientStatus clientStatus=ensureClientStatus(clientInfo);
    clientStatus.blockIndex=blockIndex;
    if (isLastTestBlockAvailable && blockIndex >= testBlocks.size()) {
      return null;
    }
    long startTime=System.currentTimeMillis();
    long stopTime=startTime + timeout;
    while (blockIndex >= testBlocks.size()) {
      long timeToWait=stopTime - System.currentTimeMillis();
      if (timeToWait < 1) {
        double elapsed=(System.currentTimeMillis() - startTime) / 1000.0;
        throw new TimeoutException(""String_Node_Str"" + ""String_Node_Str"" + timeout + ""String_Node_Str""+ ""String_Node_Str""+ clientInfo.getDesc()+ ""String_Node_Str""+ ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
      }
      try {
        clientStatusesLock.wait(timeToWait);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
        return null;
      }
    }
    TestInfo[] tests=testBlocks.get(blockIndex);
    for (    TestInfo testInfo : tests) {
      ensureResults(testInfo).put(clientStatus,null);
    }
    return new TestBlock(tests,blockIndex);
  }
}"
82338,"/** 
 * Reports results for the last method run and gets the name of next method to run.
 * @param results the results of executing the test
 * @param blockIndex the index of the test block to retrieve
 * @param userAgent the user agent property of this client
 * @return the next test block
 * @throws TimeoutException if the wait for the next method times out.
 */
TestBlock reportResultsAndGetTestBlock(HashMap<TestInfo,JUnitResult> results,int blockIndex,String userAgent) throws TimeoutException ;","/** 
 * Reports results for the last method run and gets the name of next method to run.
 * @param results the results of executing the test
 * @param blockIndex the index of the test block to retrieve
 * @param clientInfo the info for this client
 * @return the next test block
 * @throws TimeoutException if the wait for the next method times out.
 */
TestBlock reportResultsAndGetTestBlock(HashMap<TestInfo,JUnitResult> results,int blockIndex,ClientInfo clientInfo) throws TimeoutException ;"
82339,"/** 
 * Gets a specific block of tests to run.
 * @param blockIndex the index of the test block to retrieve
 * @param userAgent the user agent property of this client
 * @return the test block
 * @throws TimeoutException if the wait for the next method times out.
 */
TestBlock getTestBlock(int blockIndex,String userAgent) throws TimeoutException ;","/** 
 * Gets a specific block of tests to run.
 * @param blockIndex the index of the test block to retrieve
 * @param clientInfo the info for this client
 * @return the initial response
 * @throws TimeoutException if the wait for the next method times out.
 */
InitialResponse getTestBlock(int blockIndex,ClientInfo clientInfo) throws TimeoutException ;"
82340,"public static String toSourceName(String dottedName){
  return dottedName.replaceAll(""String_Node_Str"",""String_Node_Str"");
}","public static String toSourceName(String dottedName){
  return NON_TRAILING_DOLLAR.matcher(dottedName).replaceAll(""String_Node_Str"");
}"
82341,"/** 
 * React to messages from the other side, where a return value is expected.
 * @param handler
 * @throws RemoteDeathError
 */
public ReturnMessage reactToMessagesWhileWaitingForReturn(SessionHandler handler){
  do {
    try {
      getStreamToOtherSide().flush();
      MessageType messageType=Message.readMessageType(getStreamFromOtherSide());
switch (messageType) {
case FREE_VALUE:
        final FreeMessage freeMsg=FreeMessage.receive(this);
      handler.freeValue(this,freeMsg.getIds());
    break;
case RETURN:
  return ReturnMessage.receive(this);
case INVOKE:
InvokeOnServerMessage imsg=InvokeOnServerMessage.receive(this);
ExceptionOrReturnValue result=handler.invoke(this,imsg.getThis(),imsg.getMethodDispatchId(),imsg.getArgs());
sendFreedValues();
ReturnMessage.send(this,result);
break;
case INVOKE_SPECIAL:
handleInvokeSpecial(handler);
break;
case QUIT:
throw new RemoteDeathError(null);
default :
throw new BrowserChannelException(""String_Node_Str"" + messageType + ""String_Node_Str"");
}
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
catch (BrowserChannelException e) {
throw new RemoteDeathError(e);
}
}
 while (true);
}","/** 
 * React to messages from the other side, where a return value is expected.
 * @param handler
 * @throws BrowserChannelException 
 * @throws RemoteDeathError
 */
public ReturnMessage reactToMessagesWhileWaitingForReturn(SessionHandler handler) throws BrowserChannelException, RemoteDeathError {
  do {
    try {
      getStreamToOtherSide().flush();
      MessageType messageType=Message.readMessageType(getStreamFromOtherSide());
switch (messageType) {
case FREE_VALUE:
        final FreeMessage freeMsg=FreeMessage.receive(this);
      handler.freeValue(this,freeMsg.getIds());
    break;
case RETURN:
  return ReturnMessage.receive(this);
case INVOKE:
InvokeOnServerMessage imsg=InvokeOnServerMessage.receive(this);
ExceptionOrReturnValue result=handler.invoke(this,imsg.getThis(),imsg.getMethodDispatchId(),imsg.getArgs());
sendFreedValues();
ReturnMessage.send(this,result);
break;
case INVOKE_SPECIAL:
handleInvokeSpecial(handler);
break;
case QUIT:
throw new RemoteDeathError(null);
default :
throw new BrowserChannelException(""String_Node_Str"" + messageType + ""String_Node_Str"");
}
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
catch (BrowserChannelException e) {
throw new RemoteDeathError(e);
}
}
 while (true);
}"
82342,"/** 
 * Load a new instance of a module.
 * @param channel
 * @param moduleName
 * @param userAgent
 * @param url top-level URL of the main page, null if using an old plugin
 * @param tabKey opaque key of the tab, may be empty if the plugin can'tdistinguish tabs or null if using an old plugin
 * @param sessionKey opaque key for this session, null if using an old plugin
 * @param userAgentIcon byte array containing an icon (which fits within24x24) representing the user agent or null if unavailable
 * @return a TreeLogger to use for the module's logs
 */
public abstract TreeLogger loadModule(BrowserChannel channel,String moduleName,String userAgent,String url,String tabKey,String sessionKey,byte[] userAgentIcon);","/** 
 * Load a new instance of a module.
 * @param channel
 * @param moduleName
 * @param userAgent
 * @param url top-level URL of the main page, null if using an old plugin
 * @param tabKey opaque key of the tab, may be empty if the plugin can'tdistinguish tabs or null if using an old plugin
 * @param sessionKey opaque key for this session, null if using an old plugin
 * @param userAgentIcon byte array containing an icon (which fits within24x24) representing the user agent or null if unavailable
 * @return a TreeLogger to use for the module's logs, or null if the moduleload failed
 */
public abstract TreeLogger loadModule(BrowserChannel channel,String moduleName,String userAgent,String url,String tabKey,String sessionKey,byte[] userAgentIcon);"
82343,"protected void BrowserChannel(InputStream inputStream,OutputStream outputStream,ObjectRefFactory objectRefFactory) throws IOException {
  streamFromOtherSide=new DataInputStream(inputStream);
  streamToOtherSide=new DataOutputStream(outputStream);
  socket=null;
  this.objectRefFactory=objectRefFactory;
}","protected void BrowserChannel(InputStream inputStream,OutputStream outputStream,ObjectRefFactory objectRefFactory){
  streamFromOtherSide=new DataInputStream(inputStream);
  streamToOtherSide=new DataOutputStream(outputStream);
  socket=null;
  this.objectRefFactory=objectRefFactory;
}"
82344,"BrowserChannelServer(TreeLogger initialLogger,InputStream inputStream,OutputStream outputStream,SessionHandler handler,boolean ignoreRemoteDeath) throws IOException {
  super(inputStream,outputStream,new ServerObjectRefFactory());
  this.handler=handler;
  this.ignoreRemoteDeath=ignoreRemoteDeath;
  init(initialLogger);
}","BrowserChannelServer(TreeLogger initialLogger,InputStream inputStream,OutputStream outputStream,SessionHandler handler,boolean ignoreRemoteDeath){
  super(inputStream,outputStream,new ServerObjectRefFactory());
  this.handler=handler;
  this.ignoreRemoteDeath=ignoreRemoteDeath;
  init(initialLogger);
}"
82345,"protected void processConnection() throws IOException, BrowserChannelException {
  MessageType type=Message.readMessageType(getStreamFromOtherSide());
  String url=null;
  String tabKey=null;
  String sessionKey=null;
  byte[] iconBytes=null;
switch (type) {
case OLD_LOAD_MODULE:
    OldLoadModuleMessage oldLoadModule=OldLoadModuleMessage.receive(this);
  if (oldLoadModule.getProtoVersion() != 1) {
    throw new BrowserChannelException(""String_Node_Str"");
  }
moduleName=oldLoadModule.getModuleName();
userAgent=oldLoadModule.getUserAgent();
protocolVersion=1;
HelpInfo helpInfo=new HelpInfo(){
@Override public String getAnchorText(){
return ""String_Node_Str"";
}
@Override public URL getURL(){
try {
return new URL(""String_Node_Str"");
}
 catch (MalformedURLException e) {
return null;
}
}
}
;
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"",null,helpInfo);
break;
case CHECK_VERSIONS:
String connectError=null;
CheckVersionsMessage hello=CheckVersionsMessage.receive(this);
int minVersion=hello.getMinVersion();
int maxVersion=hello.getMaxVersion();
String hostedHtmlVersion=hello.getHostedHtmlVersion();
if (minVersion > PROTOCOL_VERSION_CURRENT || maxVersion < PROTOCOL_VERSION_OLDEST) {
connectError=""String_Node_Str"" + minVersion + ""String_Node_Str""+ maxVersion+ ""String_Node_Str""+ PROTOCOL_VERSION_OLDEST+ ""String_Node_Str""+ PROTOCOL_VERSION_CURRENT;
}
 else {
if (!HostedHtmlVersion.validHostedHtmlVersion(logger,hostedHtmlVersion)) {
new FatalErrorMessage(this,""String_Node_Str"").send();
return;
}
}
if (connectError != null) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + connectError,null);
new FatalErrorMessage(this,connectError).send();
return;
}
protocolVersion=Math.min(PROTOCOL_VERSION_CURRENT,maxVersion);
new ProtocolVersionMessage(this,protocolVersion).send();
type=Message.readMessageType(getStreamFromOtherSide());
if (type == MessageType.CHOOSE_TRANSPORT) {
ChooseTransportMessage chooseTransport=ChooseTransportMessage.receive(this);
String transport=selectTransport(chooseTransport.getTransports());
String transportArgs=null;
if (transport != null) {
transportArgs=createTransport(transport);
}
new SwitchTransportMessage(this,transport,transportArgs).send();
type=Message.readMessageType(getStreamFromOtherSide());
}
if (type != MessageType.LOAD_MODULE) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
LoadModuleMessage loadModule=LoadModuleMessage.receive(this);
url=loadModule.getUrl();
tabKey=loadModule.getTabKey();
sessionKey=loadModule.getSessionKey();
moduleName=loadModule.getModuleName();
userAgent=loadModule.getUserAgent();
break;
case REQUEST_PLUGIN:
logger.log(TreeLogger.ERROR,""String_Node_Str"");
new FatalErrorMessage(this,""String_Node_Str"").send();
return;
default :
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
if (protocolVersion >= PROTOCOL_VERSION_GET_ICON) {
synchronized (cacheLock) {
if (iconCache.containsKey(userAgent)) {
iconBytes=iconCache.get(userAgent);
}
 else {
RequestIconMessage.send(this);
type=Message.readMessageType(getStreamFromOtherSide());
if (type != MessageType.USER_AGENT_ICON) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
UserAgentIconMessage uaIconMessage=UserAgentIconMessage.receive(this);
iconBytes=uaIconMessage.getIconBytes();
iconCache.put(userAgent,iconBytes);
}
}
}
Thread.currentThread().setName(""String_Node_Str"" + moduleName + ""String_Node_Str""+ userAgent+ ""String_Node_Str""+ url+ ""String_Node_Str""+ sessionKey);
logger=handler.loadModule(this,moduleName,userAgent,url,tabKey,sessionKey,iconBytes);
try {
try {
ReturnMessage.send(this,false,new Value());
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
reactToMessages(handler);
}
 catch (RemoteDeathError e) {
if (!ignoreRemoteDeath) {
logger.log(TreeLogger.ERROR,e.getMessage(),e);
}
}
 finally {
handler.unloadModule(this,moduleName);
}
}","protected void processConnection() throws IOException, BrowserChannelException {
  MessageType type=Message.readMessageType(getStreamFromOtherSide());
  String url=null;
  String tabKey=null;
  String sessionKey=null;
  byte[] iconBytes=null;
switch (type) {
case OLD_LOAD_MODULE:
    OldLoadModuleMessage oldLoadModule=OldLoadModuleMessage.receive(this);
  if (oldLoadModule.getProtoVersion() != 1) {
    throw new BrowserChannelException(""String_Node_Str"");
  }
moduleName=oldLoadModule.getModuleName();
userAgent=oldLoadModule.getUserAgent();
protocolVersion=1;
HelpInfo helpInfo=new HelpInfo(){
@Override public String getAnchorText(){
return ""String_Node_Str"";
}
@Override public URL getURL(){
try {
return new URL(""String_Node_Str"");
}
 catch (MalformedURLException e) {
return null;
}
}
}
;
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"",null,helpInfo);
break;
case CHECK_VERSIONS:
String connectError=null;
CheckVersionsMessage hello=CheckVersionsMessage.receive(this);
int minVersion=hello.getMinVersion();
int maxVersion=hello.getMaxVersion();
String hostedHtmlVersion=hello.getHostedHtmlVersion();
if (minVersion > PROTOCOL_VERSION_CURRENT || maxVersion < PROTOCOL_VERSION_OLDEST) {
connectError=""String_Node_Str"" + minVersion + ""String_Node_Str""+ maxVersion+ ""String_Node_Str""+ PROTOCOL_VERSION_OLDEST+ ""String_Node_Str""+ PROTOCOL_VERSION_CURRENT;
}
 else {
if (!HostedHtmlVersion.validHostedHtmlVersion(logger,hostedHtmlVersion)) {
new FatalErrorMessage(this,""String_Node_Str"").send();
return;
}
}
if (connectError != null) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + connectError,null);
new FatalErrorMessage(this,connectError).send();
return;
}
protocolVersion=Math.min(PROTOCOL_VERSION_CURRENT,maxVersion);
new ProtocolVersionMessage(this,protocolVersion).send();
type=Message.readMessageType(getStreamFromOtherSide());
if (type == MessageType.CHOOSE_TRANSPORT) {
ChooseTransportMessage chooseTransport=ChooseTransportMessage.receive(this);
String transport=selectTransport(chooseTransport.getTransports());
String transportArgs=null;
if (transport != null) {
transportArgs=createTransport(transport);
}
new SwitchTransportMessage(this,transport,transportArgs).send();
type=Message.readMessageType(getStreamFromOtherSide());
}
if (type != MessageType.LOAD_MODULE) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
LoadModuleMessage loadModule=LoadModuleMessage.receive(this);
url=loadModule.getUrl();
tabKey=loadModule.getTabKey();
sessionKey=loadModule.getSessionKey();
moduleName=loadModule.getModuleName();
userAgent=loadModule.getUserAgent();
break;
case REQUEST_PLUGIN:
logger.log(TreeLogger.ERROR,""String_Node_Str"");
new FatalErrorMessage(this,""String_Node_Str"").send();
return;
default :
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
if (protocolVersion >= PROTOCOL_VERSION_GET_ICON) {
synchronized (cacheLock) {
if (iconCache.containsKey(userAgent)) {
iconBytes=iconCache.get(userAgent);
}
 else {
RequestIconMessage.send(this);
type=Message.readMessageType(getStreamFromOtherSide());
if (type != MessageType.USER_AGENT_ICON) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
UserAgentIconMessage uaIconMessage=UserAgentIconMessage.receive(this);
iconBytes=uaIconMessage.getIconBytes();
iconCache.put(userAgent,iconBytes);
}
}
}
Thread.currentThread().setName(""String_Node_Str"" + moduleName + ""String_Node_Str""+ userAgent+ ""String_Node_Str""+ url+ ""String_Node_Str""+ sessionKey);
logger=handler.loadModule(this,moduleName,userAgent,url,tabKey,sessionKey,iconBytes);
if (logger == null) {
try {
Value errMsg=new Value();
errMsg.setString(""String_Node_Str"" + moduleName);
ReturnMessage.send(this,true,errMsg);
return;
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
}
try {
try {
ReturnMessage.send(this,false,new Value());
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
reactToMessages(handler);
}
 catch (RemoteDeathError e) {
if (!ignoreRemoteDeath) {
logger.log(TreeLogger.ERROR,e.getMessage(),e);
}
}
 finally {
handler.unloadModule(this,moduleName);
}
}"
82346,"/** 
 * @param ccl
 * @param jsthis
 * @param methodName
 * @param args
 * @param returnJsValue
 * @throws Throwable
 */
public void invokeJavascript(CompilingClassLoader ccl,JsValueOOPHM jsthis,String methodName,JsValueOOPHM[] args,JsValueOOPHM returnJsValue) throws Throwable {
  final ServerObjectsTable remoteObjects=getJavaObjectsExposedInBrowser();
  Value vthis=convertFromJsValue(remoteObjects,jsthis);
  Value[] vargs=new Value[args.length];
  for (int i=0; i < args.length; ++i) {
    vargs[i]=convertFromJsValue(remoteObjects,args[i]);
  }
  try {
    InvokeOnClientMessage invokeMessage=new InvokeOnClientMessage(this,methodName,vthis,vargs);
    invokeMessage.send();
    final ReturnMessage msg=reactToMessagesWhileWaitingForReturn(handler);
    Value returnValue=msg.getReturnValue();
    convertToJsValue(ccl,remoteObjects,returnValue,returnJsValue);
    if (msg.isException()) {
      if (returnValue.isNull() || returnValue.isUndefined()) {
        throw ModuleSpace.createJavaScriptException(ccl,null);
      }
 else       if (returnValue.isString()) {
        throw ModuleSpace.createJavaScriptException(ccl,returnValue.getString());
      }
 else       if (returnValue.isJsObject()) {
        Object jso=JsValueGlue.createJavaScriptObject(returnJsValue,ccl);
        throw ModuleSpace.createJavaScriptException(ccl,jso);
      }
 else       if (returnValue.isJavaObject()) {
        Object object=remoteObjects.get(returnValue.getJavaObject().getRefid());
        Object target=((JsValueOOPHM.DispatchObjectOOPHM)object).getTarget();
        if (target instanceof Throwable) {
          throw (Throwable)(target);
        }
 else {
          throw ModuleSpace.createJavaScriptException(ccl,target);
        }
      }
      throw ModuleSpace.createJavaScriptException(ccl,returnValue.getValue().toString());
    }
  }
 catch (  IOException e) {
    throw new RemoteDeathError(e);
  }
catch (  BrowserChannelException e) {
    throw new RemoteDeathError(e);
  }
}","/** 
 * @param ccl
 * @param jsthis
 * @param methodName
 * @param args
 * @param returnJsValue
 * @throws Throwable
 */
public void invokeJavascript(CompilingClassLoader ccl,JsValueOOPHM jsthis,String methodName,JsValueOOPHM[] args,JsValueOOPHM returnJsValue) throws Throwable {
  final ServerObjectsTable remoteObjects=getJavaObjectsExposedInBrowser();
  Value vthis=convertFromJsValue(remoteObjects,jsthis);
  Value[] vargs=new Value[args.length];
  for (int i=0; i < args.length; ++i) {
    vargs[i]=convertFromJsValue(remoteObjects,args[i]);
  }
  try {
    InvokeOnClientMessage invokeMessage=new InvokeOnClientMessage(this,methodName,vthis,vargs);
    invokeMessage.send();
    final ReturnMessage msg=reactToMessagesWhileWaitingForReturn(handler);
    Value returnValue=msg.getReturnValue();
    convertToJsValue(ccl,remoteObjects,returnValue,returnJsValue);
    if (msg.isException()) {
      Object exceptionValue;
      if (returnValue.isNull() || returnValue.isUndefined()) {
        exceptionValue=null;
      }
 else       if (returnValue.isString()) {
        exceptionValue=returnValue.getString();
      }
 else       if (returnValue.isJsObject()) {
        exceptionValue=JsValueGlue.createJavaScriptObject(returnJsValue,ccl);
      }
 else       if (returnValue.isJavaObject()) {
        Object object=remoteObjects.get(returnValue.getJavaObject().getRefid());
        Object target=((JsValueOOPHM.DispatchObjectOOPHM)object).getTarget();
        if (target instanceof Throwable) {
          throw (Throwable)(target);
        }
 else {
          exceptionValue=target;
        }
      }
 else {
        exceptionValue=returnValue.getValue().toString();
      }
      RuntimeException exception=ModuleSpace.createJavaScriptException(ccl,exceptionValue);
      exception.fillInStackTrace();
      throw exception;
    }
  }
 catch (  IOException e) {
    throw new RemoteDeathError(e);
  }
catch (  BrowserChannelException e) {
    throw new RemoteDeathError(e);
  }
}"
82347,"protected ModuleSpace(TreeLogger logger,ModuleSpaceHost host,String moduleName,Object key){
  this.host=host;
  this.moduleName=moduleName;
  this.key=key;
  this.logger=logger;
  threadLocalLogger.set(host.getLogger());
}","protected ModuleSpace(TreeLogger logger,ModuleSpaceHost host,String moduleName){
  this.host=host;
  this.moduleName=moduleName;
  this.logger=logger;
  threadLocalLogger.set(host.getLogger());
}"
82348,"public ModuleSpaceOOPHM(ModuleSpaceHost msh,String moduleName,BrowserChannelServer channel){
  super(msh.getLogger(),msh,moduleName,moduleName);
  this.channel=channel;
  msh.getLogger().log(TreeLogger.DEBUG,""String_Node_Str"" + moduleName,null);
}","public ModuleSpaceOOPHM(ModuleSpaceHost msh,String moduleName,BrowserChannelServer channel){
  super(msh.getLogger(),msh,moduleName);
  this.channel=channel;
  msh.getLogger().log(TreeLogger.DEBUG,""String_Node_Str"" + moduleName,null);
}"
82349,"@Override public synchronized TreeLogger loadModule(BrowserChannel channel,String moduleName,String userAgent,String url,String tabKey,String sessionKey,byte[] userAgentIcon){
  PerfLogger.start(""String_Node_Str"" + moduleName);
  BrowserChannelServer serverChannel=(BrowserChannelServer)channel;
  ModuleHandle moduleHandle=host.createModuleLogger(moduleName,userAgent,url,tabKey,sessionKey,serverChannel,userAgentIcon);
  TreeLogger logger=moduleHandle.getLogger();
  moduleHandleMap.put(serverChannel,moduleHandle);
  ModuleSpace moduleSpace=null;
  try {
    ModuleSpaceHost msh=host.createModuleSpaceHost(moduleHandle,moduleName);
    moduleSpace=new ModuleSpaceOOPHM(msh,moduleName,serverChannel);
    moduleMap.put(serverChannel,moduleSpace);
    PerfLogger.start(""String_Node_Str"");
    moduleSpace.onLoad(logger);
  }
 catch (  Throwable e) {
    moduleHandle.getLogger().log(TreeLogger.ERROR,""String_Node_Str"" + moduleName + ""String_Node_Str""+ userAgent+ ""String_Node_Str""+ channel.getRemoteEndpoint(),e);
    if (moduleSpace != null) {
      moduleSpace.dispose();
    }
    moduleHandle.unload();
    moduleMap.remove(serverChannel);
    moduleHandleMap.remove(serverChannel);
  }
 finally {
    PerfLogger.end();
    PerfLogger.end();
  }
  return moduleHandle.getLogger();
}","@Override public synchronized TreeLogger loadModule(BrowserChannel channel,String moduleName,String userAgent,String url,String tabKey,String sessionKey,byte[] userAgentIcon){
  PerfLogger.start(""String_Node_Str"" + moduleName);
  BrowserChannelServer serverChannel=(BrowserChannelServer)channel;
  ModuleHandle moduleHandle=host.createModuleLogger(moduleName,userAgent,url,tabKey,sessionKey,serverChannel,userAgentIcon);
  TreeLogger logger=moduleHandle.getLogger();
  moduleHandleMap.put(serverChannel,moduleHandle);
  ModuleSpace moduleSpace=null;
  try {
    ModuleSpaceHost msh=host.createModuleSpaceHost(moduleHandle,moduleName);
    moduleSpace=new ModuleSpaceOOPHM(msh,moduleName,serverChannel);
    moduleMap.put(serverChannel,moduleSpace);
    PerfLogger.start(""String_Node_Str"");
    moduleSpace.onLoad(logger);
  }
 catch (  Throwable e) {
    moduleHandle.getLogger().log(TreeLogger.ERROR,""String_Node_Str"" + moduleName + ""String_Node_Str""+ userAgent+ ""String_Node_Str""+ channel.getRemoteEndpoint(),e);
    if (moduleSpace != null) {
      moduleSpace.dispose();
    }
    moduleHandle.unload();
    moduleMap.remove(serverChannel);
    moduleHandleMap.remove(serverChannel);
    return null;
  }
 finally {
    PerfLogger.end();
    PerfLogger.end();
  }
  return moduleHandle.getLogger();
}"
82350,"/** 
 * @return full text of log event.
 */
public String getFullText(){
  StringBuffer sb=new StringBuffer();
  formatTimestamp(timestamp.getTime() - firstLog.getTime(),sb);
  sb.append(""String_Node_Str"");
  if (type != null) {
    sb.append(""String_Node_Str"");
    sb.append(type.getLabel());
    sb.append(""String_Node_Str"");
  }
  sb.append(htmlEscape(message));
  sb.append(""String_Node_Str"");
  if (exceptionDetail != null) {
    sb.append(""String_Node_Str"" + htmlEscape(exceptionDetail) + ""String_Node_Str"");
  }
  if (helpInfo != null) {
    URL url=helpInfo.getURL();
    String anchorText=helpInfo.getAnchorText();
    if (anchorText == null) {
      anchorText=url.toExternalForm();
    }
    String prefix=helpInfo.getPrefix();
    if (url != null) {
      sb.append(""String_Node_Str"" + prefix + ""String_Node_Str"");
      sb.append(url.toString());
      sb.append(""String_Node_Str"");
      sb.append(anchorText);
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  return sb.toString();
}","/** 
 * @return full text of log event.
 */
public String getFullText(){
  StringBuffer sb=new StringBuffer();
  formatTimestamp(timestamp.getTime() - firstLog.getTime(),sb);
  sb.append(""String_Node_Str"");
  if (type != null) {
    sb.append(""String_Node_Str"");
    sb.append(type.getLabel());
    sb.append(""String_Node_Str"");
  }
  sb.append(htmlEscape(message));
  sb.append(""String_Node_Str"");
  if (exceptionDetail != null) {
    sb.append(""String_Node_Str"" + htmlEscape(exceptionDetail) + ""String_Node_Str"");
  }
  if (helpInfo != null) {
    URL url=helpInfo.getURL();
    String anchorText=helpInfo.getAnchorText();
    if (anchorText == null && url != null) {
      anchorText=url.toExternalForm();
    }
    String prefix=helpInfo.getPrefix();
    if (url != null) {
      sb.append(""String_Node_Str"" + prefix + ""String_Node_Str"");
      sb.append(url.toString());
      sb.append(""String_Node_Str"");
      sb.append(anchorText);
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  return sb.toString();
}"
82351,"protected static DivElement createRuler(Unit widthUnit,Unit heightUnit){
  DivElement ruler=Document.get().createDivElement();
  ruler.setInnerHTML(""String_Node_Str"");
  Style style=ruler.getStyle();
  style.setPosition(Position.ABSOLUTE);
  style.setZIndex(-32767);
  style.setLeft(-10000,PX);
  style.setWidth(10,widthUnit);
  style.setHeight(10,heightUnit);
  return ruler;
}","protected static DivElement createRuler(Unit widthUnit,Unit heightUnit){
  DivElement ruler=Document.get().createDivElement();
  ruler.setInnerHTML(""String_Node_Str"");
  Style style=ruler.getStyle();
  style.setPosition(Position.ABSOLUTE);
  style.setZIndex(-32767);
  style.setLeft(-20,widthUnit);
  style.setTop(-20,heightUnit);
  style.setWidth(10,widthUnit);
  style.setHeight(10,heightUnit);
  return ruler;
}"
82352,"/** 
 * The height of the scroll view of an element.
 */
public final native int getScrollWidth();","/** 
 * The width of the scroll view of an element.
 */
public final native int getScrollWidth();"
82353,"/** 
 * @param classNames css class names to convert
 * @return map of the same class names in a form safe for use as Javaidentifiers, with the order of the input set preserved
 * @throws Failure on collisions due to conversions
 */
public Map<String,String> convertSet(Set<String> classNames) throws Failure {
  Map<String,String> rawToConverted=new LinkedHashMap<String,String>();
  Map<String,String> convertedToRaw=new LinkedHashMap<String,String>();
  for (  String className : classNames) {
    String converted=convertName(className);
    String already=convertedToRaw.get(converted);
    if (already != null) {
      throw new Failure(""String_Node_Str"",already,className);
    }
    if (!converted.equals(className)) {
      convertedToRaw.put(converted,className);
    }
    rawToConverted.put(className,converted);
  }
  return rawToConverted;
}","/** 
 * @param classNames css class names to convert
 * @return map of the same class names in a form safe for use as Javaidentifiers, with the order of the input set preserved
 * @throws Failure on collisions due to conversions
 */
public Map<String,String> convertSet(Set<String> classNames) throws Failure {
  Map<String,String> rawToConverted=new LinkedHashMap<String,String>();
  Map<String,String> convertedToRaw=new LinkedHashMap<String,String>();
  for (  String className : classNames) {
    String converted=convertName(className);
    String already=convertedToRaw.get(converted);
    if (already != null) {
      throw new Failure(""String_Node_Str"",already,className);
    }
    convertedToRaw.put(converted,className);
    rawToConverted.put(className,converted);
  }
  return rawToConverted;
}"
82354,"public void testSomeOp() throws CssNameConverter.Failure {
  Set<String> in=Sets.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Pair[] expected={new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str"")};
  Map<String,String> out=converter.convertSet(in);
  for (  Pair pair : expected) {
    String convert=out.remove(pair.before);
    assertEquals(pair.after,convert);
  }
  assertTrue(out.isEmpty());
}","public void testSomeOp() throws CssNameConverter.Failure {
  Set<String> in=makeOrderedSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Pair[] expected={new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str"")};
  Map<String,String> out=converter.convertSet(in);
  for (  Pair pair : expected) {
    String convert=out.remove(pair.before);
    assertEquals(pair.after,convert);
  }
  assertTrue(out.isEmpty());
}"
82355,"public void testNoOp() throws CssNameConverter.Failure {
  Set<String> in=Sets.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Map<String,String> out=converter.convertSet(in);
  for (  Map.Entry<String,String> entry : out.entrySet()) {
    String key=entry.getKey();
    assertTrue(in.remove(key));
    assertEquals(key,entry.getValue());
  }
  assertTrue(in.isEmpty());
}","public void testNoOp() throws CssNameConverter.Failure {
  Set<String> in=makeOrderedSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Map<String,String> out=converter.convertSet(in);
  for (  Map.Entry<String,String> entry : out.entrySet()) {
    String key=entry.getKey();
    assertTrue(in.remove(key));
    assertEquals(key,entry.getValue());
  }
  assertTrue(in.isEmpty());
}"
82356,"public void testCollision(){
  Set<String> in=Sets.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  try {
    converter.convertSet(in);
  }
 catch (  CssNameConverter.Failure e) {
    assertContains(e.getMessage(),""String_Node_Str"");
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}","public void testCollision(){
  Set<String> in=makeOrderedSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  try {
    converter.convertSet(in);
    fail();
  }
 catch (  CssNameConverter.Failure e) {
    assertContains(e.getMessage(),""String_Node_Str"");
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}"
82357,"public void testReverseCollision(){
  Set<String> in=Sets.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  try {
    converter.convertSet(in);
  }
 catch (  CssNameConverter.Failure e) {
    assertContains(e.getMessage(),""String_Node_Str"");
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}","public void testReverseCollision(){
  Set<String> in=makeOrderedSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  try {
    converter.convertSet(in);
    fail();
  }
 catch (  CssNameConverter.Failure e) {
    assertContains(e.getMessage(),""String_Node_Str"");
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}"
82358,"/** 
 * Attempts to get a named configuration property. Throws <code>BadPropertyValueException</code> if the property is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 */
ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named configuration property. Throws <code>BadPropertyValueException</code> if the property is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param propertyName 
 * @return the configuration property instance (never null)
 * @throws BadPropertyValueException if the property is unknown or not aconfiguration property
 */
ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException ;"
82359,"/** 
 * Attempts to get a named deferred binding property or configuration property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return a value for the property
 */
@Deprecated String getPropertyValue(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property or configuration property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return a value for the property
 * @throws BadPropertyValueException if the property is unknown or not of theright type
 */
@Deprecated String getPropertyValue(TreeLogger logger,String propertyName) throws BadPropertyValueException ;"
82360,"/** 
 * Attempts to get a named deferred binding property and returns the list of possible values. Throws <code>BadPropertyValueException</code> if the property is a configuration property or is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return the possible values for the property
 */
@Deprecated String[] getPropertyValueSet(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property and returns the list of possible values. Throws <code>BadPropertyValueException</code> if the property is a configuration property or is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return the possible values for the property
 * @throws BadPropertyValueException if the property is unknown or not of theright type 
 */
@Deprecated String[] getPropertyValueSet(TreeLogger logger,String propertyName) throws BadPropertyValueException ;"
82361,"/** 
 * Attempts to get a named deferred binding property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 */
SelectionProperty getSelectionProperty(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger 
 * @param propertyName 
 * @return the selection property instance (never null)
 * @throws BadPropertyValueException if the property is unknown or not aselection property
 */
SelectionProperty getSelectionProperty(TreeLogger logger,String propertyName) throws BadPropertyValueException ;"
82362,"public com.google.gwt.core.ext.ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException {
  for (  final ConfigurationProperty prop : configProps) {
    if (prop.getName().equals(propertyName)) {
      return new com.google.gwt.core.ext.ConfigurationProperty(){
        public String getName(){
          return prop.getName();
        }
        public List<String> getValues(){
          return prop.getValues();
        }
      }
;
    }
  }
  throw new BadPropertyValueException(propertyName);
}","public com.google.gwt.core.ext.ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException {
  for (  final ConfigurationProperty prop : configProps) {
    if (prop.getName().equals(propertyName)) {
      return new DefaultConfigurationProperty(prop.getName(),prop.getValues());
    }
  }
  throw new BadPropertyValueException(propertyName);
}"
82363,"public String[] getOrderedPropValues(){
  return orderedPropValues;
}","/** 
 * @return an array of binding property values.
 */
public String[] getOrderedPropValues(){
  return orderedPropValues;
}"
82364,"public BindingProperty[] getOrderedProps(){
  return orderedProps;
}","/** 
 * @return an array of binding properties.
 */
public BindingProperty[] getOrderedProps(){
  return orderedProps;
}"
82365,"public StaticPropertyOracle(BindingProperty[] orderedProps,String[] orderedPropValues,ConfigurationProperty[] configProps){
  this.orderedProps=orderedProps;
  this.orderedPropValues=orderedPropValues;
  this.configProps=configProps;
  int len=orderedProps.length;
  for (int i=0; i < len; i++) {
    BindingProperty prop=orderedProps[i];
    String value=orderedPropValues[i];
    if (!prop.isAllowedValue(value)) {
      throw new IllegalArgumentException(""String_Node_Str"" + prop.getName() + ""String_Node_Str""+ value);
    }
  }
}","/** 
 * Create a property oracle that will return the supplied values.
 * @param orderedProps array of binding properties
 * @param orderedPropValues values of the above binding properties
 * @param configProps array of config properties
 */
public StaticPropertyOracle(BindingProperty[] orderedProps,String[] orderedPropValues,ConfigurationProperty[] configProps){
  this.orderedProps=orderedProps;
  this.orderedPropValues=orderedPropValues;
  this.configProps=configProps;
  int len=orderedProps.length;
  for (int i=0; i < len; i++) {
    BindingProperty prop=orderedProps[i];
    String value=orderedPropValues[i];
    if (!prop.isAllowedValue(value)) {
      throw new IllegalArgumentException(""String_Node_Str"" + prop.getName() + ""String_Node_Str""+ value);
    }
  }
}"
82366,"public com.google.gwt.core.ext.SelectionProperty getSelectionProperty(TreeLogger logger,String propertyName) throws BadPropertyValueException {
  for (int i=0; i < orderedProps.length; i++) {
    final BindingProperty prop=orderedProps[i];
    final String name=prop.getName();
    final String fallback=prop.getFallback();
    if (name.equals(propertyName)) {
      final String value=orderedPropValues[i];
      String[] values=prop.getDefinedValues();
      final TreeSet<String> possibleValues=new TreeSet<String>();
      for (      String v : values) {
        possibleValues.add(v);
      }
      return new com.google.gwt.core.ext.SelectionProperty(){
        public String getCurrentValue(){
          return value;
        }
        public String getFallbackValue(){
          return fallback;
        }
        public String getName(){
          return name;
        }
        public SortedSet<String> getPossibleValues(){
          return possibleValues;
        }
      }
;
    }
  }
  throw new BadPropertyValueException(propertyName);
}","public com.google.gwt.core.ext.SelectionProperty getSelectionProperty(TreeLogger logger,String propertyName) throws BadPropertyValueException {
  for (int i=0; i < orderedProps.length; i++) {
    final BindingProperty prop=orderedProps[i];
    final String name=prop.getName();
    if (name.equals(propertyName)) {
      final String value=orderedPropValues[i];
      String[] values=prop.getDefinedValues();
      final TreeSet<String> possibleValues=new TreeSet<String>();
      for (      String v : values) {
        possibleValues.add(v);
      }
      return new DefaultSelectionProperty(value,prop.getFallback(),name,possibleValues);
    }
  }
  throw new BadPropertyValueException(propertyName);
}"
82367,"/** 
 * Invoke a JS method and return its value.
 * @param name method name to invoke
 * @param jthis object to invoke method on, null if static method
 * @param types argument types
 * @param args argument values
 */
@Override protected JsValue doInvoke(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  TreeLogger branch=host.getLogger().branch(TreeLogger.DEBUG,""String_Node_Str"" + name,null);
  CompilingClassLoader isolatedClassLoader=getIsolatedClassLoader();
  JsValueOOPHM jsthis=new JsValueOOPHM();
  Class<?> jthisType=(jthis == null) ? Object.class : jthis.getClass();
  JsValueGlue.set(jsthis,isolatedClassLoader,jthisType,jthis);
  branch.log(TreeLogger.SPAM,""String_Node_Str"" + jsthis);
  int argc=args.length;
  JsValueOOPHM argv[]=new JsValueOOPHM[argc];
  for (int i=0; i < argc; ++i) {
    argv[i]=new JsValueOOPHM();
    JsValueGlue.set(argv[i],isolatedClassLoader,types[i],args[i]);
    branch.log(TreeLogger.SPAM,""String_Node_Str"" + i + ""String_Node_Str""+ argv[i]);
  }
  JsValueOOPHM returnVal=new JsValueOOPHM();
  try {
    channel.invokeJavascript(isolatedClassLoader,jsthis,name,argv,returnVal);
    branch.log(TreeLogger.SPAM,""String_Node_Str"" + returnVal);
  }
 catch (  Throwable t) {
    branch.log(TreeLogger.DEBUG,""String_Node_Str"",t);
    throw t;
  }
  return returnVal;
}","/** 
 * Invoke a JS method and return its value.
 * @param name method name to invoke
 * @param jthis object to invoke method on, null if static method
 * @param types argument types
 * @param args argument values
 */
@Override protected JsValue doInvoke(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  TreeLogger branch=host.getLogger().branch(TreeLogger.SPAM,""String_Node_Str"" + name,null);
  CompilingClassLoader isolatedClassLoader=getIsolatedClassLoader();
  JsValueOOPHM jsthis=new JsValueOOPHM();
  Class<?> jthisType=(jthis == null) ? Object.class : jthis.getClass();
  JsValueGlue.set(jsthis,isolatedClassLoader,jthisType,jthis);
  branch.log(TreeLogger.SPAM,""String_Node_Str"" + jsthis);
  int argc=args.length;
  JsValueOOPHM argv[]=new JsValueOOPHM[argc];
  for (int i=0; i < argc; ++i) {
    argv[i]=new JsValueOOPHM();
    JsValueGlue.set(argv[i],isolatedClassLoader,types[i],args[i]);
    branch.log(TreeLogger.SPAM,""String_Node_Str"" + i + ""String_Node_Str""+ argv[i]);
  }
  JsValueOOPHM returnVal=new JsValueOOPHM();
  try {
    channel.invokeJavascript(isolatedClassLoader,jsthis,name,argv,returnVal);
    branch.log(TreeLogger.SPAM,""String_Node_Str"" + returnVal);
  }
 catch (  Throwable t) {
    branch.log(TreeLogger.SPAM,""String_Node_Str"",t);
    throw t;
  }
  return returnVal;
}"
82368,"/** 
 * Return true if we are running on a Mac.
 */
private static boolean isMac(){
  String lcOSName=System.getProperty(""String_Node_Str"").toLowerCase();
  return lcOSName.startsWith(""String_Node_Str"");
}","/** 
 * Return true if we are running on a Mac.
 */
private static boolean isMac(){
  String lcOSName=System.getProperty(""String_Node_Str"").toLowerCase(Locale.ENGLISH);
  return lcOSName.startsWith(""String_Node_Str"");
}"
82369,"public static String checkHost(String hostUnderConsideration,Set<String> hosts){
  hostUnderConsideration=hostUnderConsideration.toLowerCase();
  for (  String rule : hosts) {
    if (hostUnderConsideration.matches(""String_Node_Str"" + rule + ""String_Node_Str"")) {
      return rule;
    }
  }
  return null;
}","public static String checkHost(String hostUnderConsideration,Set<String> hosts){
  hostUnderConsideration=hostUnderConsideration.toLowerCase(Locale.ENGLISH);
  for (  String rule : hosts) {
    if (hostUnderConsideration.matches(""String_Node_Str"" + rule + ""String_Node_Str"")) {
      return rule;
    }
  }
  return null;
}"
82370,"static String suggestServletName(String servletClass){
  int pos=servletClass.lastIndexOf('.');
  String suggest=(pos < 0) ? servletClass : servletClass.substring(pos + 1);
  suggest=Character.toLowerCase(suggest.charAt(0)) + suggest.substring(1);
  return suggest;
}","static String suggestServletName(String servletClass){
  int pos=servletClass.lastIndexOf('.');
  String suggest=(pos < 0) ? servletClass : servletClass.substring(pos + 1);
  String firstChar=suggest.substring(0,1).toLowerCase(Locale.ENGLISH);
  suggest=firstChar + suggest.substring(1);
  return suggest;
}"
82371,"private Set<String> getSuppressedWarnings(MethodDeclaration method){
  Annotation[] annotations=method.annotations;
  if (annotations == null) {
    return Sets.create();
  }
  for (  Annotation a : annotations) {
    if (SuppressWarnings.class.getName().equals(CharOperation.toString(((ReferenceBinding)a.resolvedType).compoundName))) {
      for (      MemberValuePair pair : a.memberValuePairs()) {
        if (String.valueOf(pair.name).equals(""String_Node_Str"")) {
          Expression valueExpr=pair.value;
          if (valueExpr instanceof StringLiteral) {
            return Sets.create(((StringLiteral)valueExpr).constant.stringValue().toLowerCase());
          }
 else           if (valueExpr instanceof ArrayInitializer) {
            ArrayInitializer ai=(ArrayInitializer)valueExpr;
            String[] values=new String[ai.expressions.length];
            for (int i=0, j=values.length; i < j; i++) {
              values[i]=((StringLiteral)ai.expressions[i]).constant.stringValue().toLowerCase();
            }
            return Sets.create(values);
          }
 else {
            throw new InternalCompilerException(""String_Node_Str"");
          }
        }
      }
    }
  }
  return Sets.create();
}","private Set<String> getSuppressedWarnings(MethodDeclaration method){
  Annotation[] annotations=method.annotations;
  if (annotations == null) {
    return Sets.create();
  }
  for (  Annotation a : annotations) {
    if (SuppressWarnings.class.getName().equals(CharOperation.toString(((ReferenceBinding)a.resolvedType).compoundName))) {
      for (      MemberValuePair pair : a.memberValuePairs()) {
        if (String.valueOf(pair.name).equals(""String_Node_Str"")) {
          Expression valueExpr=pair.value;
          if (valueExpr instanceof StringLiteral) {
            return Sets.create(((StringLiteral)valueExpr).constant.stringValue().toLowerCase(Locale.ENGLISH));
          }
 else           if (valueExpr instanceof ArrayInitializer) {
            ArrayInitializer ai=(ArrayInitializer)valueExpr;
            String[] values=new String[ai.expressions.length];
            for (int i=0, j=values.length; i < j; i++) {
              values[i]=((StringLiteral)ai.expressions[i]).constant.stringValue().toLowerCase(Locale.ENGLISH);
            }
            return Sets.create(values);
          }
 else {
            throw new InternalCompilerException(""String_Node_Str"");
          }
        }
      }
    }
  }
  return Sets.create();
}"
82372,"public static ClassPathEntry createEntryForUrl(TreeLogger logger,URL url) throws URISyntaxException, IOException {
  if (url.getProtocol().equals(""String_Node_Str"")) {
    File f=new File(url.toURI());
    String lowerCaseFileName=f.getName().toLowerCase();
    if (f.isDirectory()) {
      return new DirectoryClassPathEntry(f);
    }
 else     if (f.isFile() && lowerCaseFileName.endsWith(""String_Node_Str"")) {
      return new ZipFileClassPathEntry(new JarFile(f));
    }
 else     if (f.isFile() && lowerCaseFileName.endsWith(""String_Node_Str"")) {
      return new ZipFileClassPathEntry(new ZipFile(f));
    }
 else {
      try {
        return new ZipFileClassPathEntry(new JarFile(f));
      }
 catch (      Exception ignored) {
      }
      try {
        return new ZipFileClassPathEntry(new ZipFile(f));
      }
 catch (      Exception ignored) {
      }
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + f + ""String_Node_Str"");
      return null;
    }
  }
 else {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + url,null);
    return null;
  }
}","public static ClassPathEntry createEntryForUrl(TreeLogger logger,URL url) throws URISyntaxException, IOException {
  if (url.getProtocol().equals(""String_Node_Str"")) {
    File f=new File(url.toURI());
    String lowerCaseFileName=f.getName().toLowerCase(Locale.ENGLISH);
    if (f.isDirectory()) {
      return new DirectoryClassPathEntry(f);
    }
 else     if (f.isFile() && lowerCaseFileName.endsWith(""String_Node_Str"")) {
      return new ZipFileClassPathEntry(new JarFile(f));
    }
 else     if (f.isFile() && lowerCaseFileName.endsWith(""String_Node_Str"")) {
      return new ZipFileClassPathEntry(new ZipFile(f));
    }
 else {
      try {
        return new ZipFileClassPathEntry(new JarFile(f));
      }
 catch (      Exception ignored) {
      }
      try {
        return new ZipFileClassPathEntry(new ZipFile(f));
      }
 catch (      Exception ignored) {
      }
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + f + ""String_Node_Str"");
      return null;
    }
  }
 else {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + url,null);
    return null;
  }
}"
82373,"/** 
 * This method checks the host to see if it is in the supplied set of regexes.
 * @param hostUnderConsideration the host to be checked
 * @param hosts the set of regexes to be checked against
 * @return true if the host matches
 */
public static String checkHost(String hostUnderConsideration,Set<String> hosts){
  hostUnderConsideration=hostUnderConsideration.toLowerCase();
  for (  String rule : hosts) {
    rule=rule.toLowerCase();
    if (hostUnderConsideration.matches(""String_Node_Str"" + rule + ""String_Node_Str"")) {
      return rule;
    }
  }
  return null;
}","/** 
 * This method checks the host to see if it is in the supplied set of regexes.
 * @param hostUnderConsideration the host to be checked
 * @param hosts the set of regexes to be checked against
 * @return true if the host matches
 */
public static String checkHost(String hostUnderConsideration,Set<String> hosts){
  hostUnderConsideration=hostUnderConsideration.toLowerCase(Locale.ENGLISH);
  for (  String rule : hosts) {
    rule=rule.toLowerCase(Locale.ENGLISH);
    if (hostUnderConsideration.matches(""String_Node_Str"" + rule + ""String_Node_Str"")) {
      return rule;
    }
  }
  return null;
}"
82374,"public static CheckForUpdates createUpdateChecker(TreeLogger logger,String entryPoint){
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    return new CheckForUpdatesIE6(logger,entryPoint);
  }
 else {
    return new CheckForUpdates(logger,entryPoint);
  }
}","public static CheckForUpdates createUpdateChecker(TreeLogger logger,String entryPoint){
  if (System.getProperty(""String_Node_Str"").toLowerCase(Locale.ENGLISH).contains(""String_Node_Str"")) {
    return new CheckForUpdatesIE6(logger,entryPoint);
  }
 else {
    return new CheckForUpdates(logger,entryPoint);
  }
}"
82375,"/** 
 * Retrieve a short name, suitable for use in a tab or filename, for a given user agent.
 * @param userAgent
 * @return short name of user agent
 */
public static String getShortName(String userAgent){
  String lcAgent=userAgent.toLowerCase();
  if (lcAgent.contains(""String_Node_Str"")) {
    return IE;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return CHROME;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return OPERA;
  }
 else   if (lcAgent.contains(""String_Node_Str"") || lcAgent.contains(""String_Node_Str"")) {
    return SAFARI;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return FIREFOX;
  }
  return UNKNOWN;
}","/** 
 * Retrieve a short name, suitable for use in a tab or filename, for a given user agent.
 * @param userAgent
 * @return short name of user agent
 */
public static String getShortName(String userAgent){
  String lcAgent=userAgent.toLowerCase(Locale.ENGLISH);
  if (lcAgent.contains(""String_Node_Str"")) {
    return IE;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return CHROME;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return OPERA;
  }
 else   if (lcAgent.contains(""String_Node_Str"") || lcAgent.contains(""String_Node_Str"")) {
    return SAFARI;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return FIREFOX;
  }
  return UNKNOWN;
}"
82376,"public int handle(String[] args,int startIndex){
  if (startIndex + 1 < args.length) {
    String style=args[startIndex + 1].toLowerCase();
    if (style.startsWith(""String_Node_Str"")) {
      option.setOutput(JsOutputOption.OBFUSCATED);
      return 1;
    }
 else     if (""String_Node_Str"".equals(style)) {
      option.setOutput(JsOutputOption.PRETTY);
      return 1;
    }
 else     if (""String_Node_Str"".equals(style)) {
      option.setOutput(JsOutputOption.DETAILED);
      return 1;
    }
  }
  System.err.println(getTag() + ""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return -1;
}","public int handle(String[] args,int startIndex){
  if (startIndex + 1 < args.length) {
    String style=args[startIndex + 1].toLowerCase(Locale.ENGLISH);
    if (style.startsWith(""String_Node_Str"")) {
      option.setOutput(JsOutputOption.OBFUSCATED);
      return 1;
    }
 else     if (""String_Node_Str"".equals(style)) {
      option.setOutput(JsOutputOption.PRETTY);
      return 1;
    }
 else     if (""String_Node_Str"".equals(style)) {
      option.setOutput(JsOutputOption.DETAILED);
      return 1;
    }
  }
  System.err.println(getTag() + ""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return -1;
}"
82377,"public void testNonOverlappingPrefixesNonEmptyFilter(){
  PathPrefixSet pps=new PathPrefixSet();
  ResourceFilter allowsGifs=new ResourceFilter(){
    public boolean allows(    String path){
      return path.toLowerCase().endsWith(""String_Node_Str"");
    }
  }
;
  PathPrefix pp1=new PathPrefix(""String_Node_Str"",allowsGifs);
  PathPrefix pp2=new PathPrefix(""String_Node_Str"",allowsGifs);
  pps.add(pp1);
  pps.add(pp2);
  assertEquals(pp1,pps.includesResource(""String_Node_Str""));
  assertEquals(pp2,pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
}","public void testNonOverlappingPrefixesNonEmptyFilter(){
  PathPrefixSet pps=new PathPrefixSet();
  ResourceFilter allowsGifs=new ResourceFilter(){
    public boolean allows(    String path){
      return path.toLowerCase(Locale.ENGLISH).endsWith(""String_Node_Str"");
    }
  }
;
  PathPrefix pp1=new PathPrefix(""String_Node_Str"",allowsGifs);
  PathPrefix pp2=new PathPrefix(""String_Node_Str"",allowsGifs);
  pps.add(pp1);
  pps.add(pp2);
  assertEquals(pp1,pps.includesResource(""String_Node_Str""));
  assertEquals(pp2,pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
}"
82378,"/** 
 * Adds new units to an existing TypeOracle.
 */
public void addNewUnits(TreeLogger logger,Collection<CompilationUnit> units){
  PerfLogger.start(""String_Node_Str"");
  classMap=new HashMap<String,CollectClassData>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      CollectClassData cv=processClass(compiledClass);
      if (!cv.hasNoExternalName()) {
        classMap.put(compiledClass.getInternalName(),cv);
      }
    }
  }
  classMapType=new HashMap<JRealClassType,CollectClassData>();
  Set<JRealClassType> unresolvedTypes=new HashSet<JRealClassType>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      String internalName=compiledClass.getInternalName();
      CollectClassData cv=classMap.get(internalName);
      if (cv == null) {
        continue;
      }
      JRealClassType type=createType(compiledClass,unresolvedTypes);
      if (type != null) {
        if (unit instanceof SourceFileCompilationUnit) {
          SourceFileCompilationUnit sourceUnit=(SourceFileCompilationUnit)unit;
          Resource sourceFile=sourceUnit.getSourceFile();
          typeOracle.addSourceReference(type,sourceFile);
        }
        binaryMapper.put(internalName,type);
        classMapType.put(type,cv);
      }
    }
  }
  TreeLogger branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"");
  for (Iterator<JRealClassType> it=unresolvedTypes.iterator(); it.hasNext(); ) {
    JRealClassType type=it.next();
    if (!resolveEnclosingClass(branch,type)) {
      it.remove();
    }
  }
  for (  JRealClassType type : unresolvedTypes) {
    branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"" + type.getQualifiedSourceName());
    if (!resolveClass(branch,type)) {
    }
  }
  typeOracle.finish();
  classMap=null;
  classMapType=null;
  PerfLogger.end();
}","/** 
 * Adds new units to an existing TypeOracle.
 * @param logger logger to use
 * @param units collection of compilation units to process 
 */
public void addNewUnits(TreeLogger logger,Collection<CompilationUnit> units){
  PerfLogger.start(""String_Node_Str"");
  classMap=new HashMap<String,CollectClassData>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      CollectClassData cv=processClass(compiledClass);
      if (!cv.hasNoExternalName()) {
        classMap.put(compiledClass.getInternalName(),cv);
      }
    }
  }
  classMapType=new HashMap<JRealClassType,CollectClassData>();
  Set<JRealClassType> unresolvedTypes=new HashSet<JRealClassType>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      String internalName=compiledClass.getInternalName();
      CollectClassData cv=classMap.get(internalName);
      if (cv == null) {
        continue;
      }
      JRealClassType type=createType(compiledClass,unresolvedTypes);
      if (type != null) {
        if (unit instanceof SourceFileCompilationUnit) {
          SourceFileCompilationUnit sourceUnit=(SourceFileCompilationUnit)unit;
          Resource sourceFile=sourceUnit.getSourceFile();
          typeOracle.addSourceReference(type,sourceFile);
        }
        binaryMapper.put(internalName,type);
        classMapType.put(type,cv);
      }
    }
  }
  TreeLogger branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"");
  for (Iterator<JRealClassType> it=unresolvedTypes.iterator(); it.hasNext(); ) {
    JRealClassType type=it.next();
    if (!resolveEnclosingClass(branch,type)) {
      it.remove();
    }
  }
  for (  JRealClassType type : unresolvedTypes) {
    branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"" + type.getQualifiedSourceName());
    if (!resolveClass(branch,type)) {
    }
  }
  typeOracle.finish();
  classMap=null;
  classMapType=null;
  PerfLogger.end();
}"
82379,"/** 
 * Collects data about a class which only needs the bytecode and no TypeOracle data structures. This is used to make the initial shallow identity pass for creating JRealClassType/JGenericType objects.
 */
private CollectClassData processClass(CompiledClass compiledClass){
  byte[] classBytes=compiledClass.getBytes();
  ClassReader reader=new ClassReader(classBytes);
  CollectClassData mcv=new CollectClassData(classBytes);
  ClassVisitor cv=mcv;
  if (false) {
    cv=new TraceClassVisitor(cv,new PrintWriter(System.out));
  }
  reader.accept(cv,0);
  return mcv;
}","/** 
 * Collects data about a class which only needs the bytecode and no TypeOracle data structures. This is used to make the initial shallow identity pass for creating JRealClassType/JGenericType objects.
 */
private CollectClassData processClass(CompiledClass compiledClass){
  byte[] classBytes=compiledClass.getBytes();
  ClassReader reader=new ClassReader(classBytes);
  CollectClassData mcv=new CollectClassData();
  ClassVisitor cv=mcv;
  if (false) {
    cv=new TraceClassVisitor(cv,new PrintWriter(System.out));
  }
  reader.accept(cv,0);
  return mcv;
}"
82380,"/** 
 * Returns the binary name of a type. This is the same name that would be returned by   {@link Class#getName()} for this type.
 */
public static String computeBinaryClassName(JType type){
  JPrimitiveType primitiveType=type.isPrimitive();
  if (primitiveType != null) {
    return primitiveType.getJNISignature();
  }
  JArrayType arrayType=type.isArray();
  if (arrayType != null) {
    JType component=arrayType.getComponentType();
    if (component.isClassOrInterface() != null) {
      return ""String_Node_Str"" + computeBinaryClassName(arrayType.getComponentType()) + ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"" + computeBinaryClassName(arrayType.getComponentType());
    }
  }
  JParameterizedType parameterizedType=type.isParameterized();
  if (parameterizedType != null) {
    return computeBinaryClassName(parameterizedType.getBaseType());
  }
  JClassType classType=type.isClassOrInterface();
  assert(classType != null);
  JClassType enclosingType=classType.getEnclosingType();
  if (enclosingType != null) {
    return computeBinaryClassName(enclosingType) + ""String_Node_Str"" + classType.getSimpleSourceName();
  }
  return classType.getQualifiedSourceName();
}","/** 
 * Returns the binary name of a type. This is the same name that would be returned by   {@link Class#getName()} for this type.
 * @param type TypeOracle type to get the name for
 * @return binary name for a type 
 */
public static String computeBinaryClassName(JType type){
  JPrimitiveType primitiveType=type.isPrimitive();
  if (primitiveType != null) {
    return primitiveType.getJNISignature();
  }
  JArrayType arrayType=type.isArray();
  if (arrayType != null) {
    JType component=arrayType.getComponentType();
    if (component.isClassOrInterface() != null) {
      return ""String_Node_Str"" + computeBinaryClassName(arrayType.getComponentType()) + ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"" + computeBinaryClassName(arrayType.getComponentType());
    }
  }
  JParameterizedType parameterizedType=type.isParameterized();
  if (parameterizedType != null) {
    return computeBinaryClassName(parameterizedType.getBaseType());
  }
  JClassType classType=type.isClassOrInterface();
  assert(classType != null);
  JClassType enclosingType=classType.getEnclosingType();
  if (enclosingType != null) {
    return computeBinaryClassName(enclosingType) + ""String_Node_Str"" + classType.getSimpleSourceName();
  }
  return classType.getQualifiedSourceName();
}"
82381,"public Map<String,JRealClassType> getBinaryMapper(){
  return binaryMapper;
}","/** 
 * @return a map from binary class names to JRealClassType.
 */
public Map<String,JRealClassType> getBinaryMapper(){
  return binaryMapper;
}"
82382,"public TypeOracleMediator(TypeOracle typeOracle){
  if (typeOracle == null) {
    typeOracle=new TypeOracle();
  }
  this.typeOracle=typeOracle;
  resolver=new Resolver(){
    public Map<String,JRealClassType> getBinaryMapper(){
      return TypeOracleMediator.this.binaryMapper;
    }
    public TypeOracle getTypeOracle(){
      return TypeOracleMediator.this.typeOracle;
    }
    public boolean resolveAnnotation(    TreeLogger logger,    CollectAnnotationData annotVisitor,    Map<Class<? extends Annotation>,Annotation> declaredAnnotations){
      return TypeOracleMediator.this.resolveAnnotation(logger,annotVisitor,declaredAnnotations);
    }
    public boolean resolveAnnotations(    TreeLogger logger,    List<CollectAnnotationData> annotations,    Map<Class<? extends Annotation>,Annotation> declaredAnnotations){
      return TypeOracleMediator.this.resolveAnnotations(logger,annotations,declaredAnnotations);
    }
    public boolean resolveClass(    TreeLogger logger,    JRealClassType type){
      return TypeOracleMediator.this.resolveClass(logger,type);
    }
  }
;
}","/** 
 * Construct a TypeOracleMediator.
 * @param typeOracle TypeOracle instance to use, or null to create a new one
 */
public TypeOracleMediator(TypeOracle typeOracle){
  if (typeOracle == null) {
    typeOracle=new TypeOracle();
  }
  this.typeOracle=typeOracle;
  resolver=new Resolver(){
    public Map<String,JRealClassType> getBinaryMapper(){
      return TypeOracleMediator.this.binaryMapper;
    }
    public TypeOracle getTypeOracle(){
      return TypeOracleMediator.this.typeOracle;
    }
    public boolean resolveAnnotation(    TreeLogger logger,    CollectAnnotationData annotVisitor,    Map<Class<? extends Annotation>,Annotation> declaredAnnotations){
      return TypeOracleMediator.this.resolveAnnotation(logger,annotVisitor,declaredAnnotations);
    }
    public boolean resolveAnnotations(    TreeLogger logger,    List<CollectAnnotationData> annotations,    Map<Class<? extends Annotation>,Annotation> declaredAnnotations){
      return TypeOracleMediator.this.resolveAnnotations(logger,annotations,declaredAnnotations);
    }
    public boolean resolveClass(    TreeLogger logger,    JRealClassType type){
      return TypeOracleMediator.this.resolveClass(logger,type);
    }
  }
;
}"
82383,"public TypeOracle getTypeOracle(){
  return typeOracle;
}","/** 
 * @return the TypeOracle managed by the mediator.
 */
public TypeOracle getTypeOracle(){
  return typeOracle;
}"
82384,"public AnnotationEnum(String desc,String value){
  this.desc=desc;
  this.value=value;
}","/** 
 * Construct the value of an Enum-valued annotation.
 * @param desc type descriptor of this enum
 * @param value actual value in this enum
 */
public AnnotationEnum(String desc,String value){
  this.desc=desc;
  this.value=value;
}"
82385,"public void CollectClassData(byte[] bytes){
  this.bytes=bytes;
}","/** 
 * Construct a visitor that will collect data about a class.
 */
public void CollectClassData(){
}"
82386,"/** 
 * @return the access
 */
public int getAccess(){
  return access;
}","/** 
 * @return the access flags for this class (ie, bitwise or of Opcodes.ACC_*).
 */
public int getAccess(){
  return access;
}"
82387,"/** 
 * @return the interfaces
 */
public String[] getInterfaces(){
  return interfaces;
}","/** 
 * @return an array of internal names of interfaces implemented by this class.
 */
public String[] getInterfaces(){
  return interfaces;
}"
82388,"/** 
 * @return annotations on this class
 */
public List<CollectAnnotationData> getAnnotations(){
  return annotations;
}","/** 
 * @return a list of annotations on this class.
 */
public List<CollectAnnotationData> getAnnotations(){
  return annotations;
}"
82389,"/** 
 * @return the value
 */
public String getValue(){
  return value;
}","/** 
 * @return the annotation value.
 */
public String getValue(){
  return value;
}"
82390,"public boolean isAnonymous(){
  return classType == ClassType.Anonymous;
}","/** 
 * @return true if this class has no source name at all.
 */
public boolean isAnonymous(){
  return classType == ClassType.Anonymous;
}"
82391,"/** 
 * @return the fields
 */
public List<CollectFieldData> getFields(){
  return fields;
}","/** 
 * @return a list of fields in this class.
 */
public List<CollectFieldData> getFields(){
  return fields;
}"
82392,"/** 
 * @return the descriptor
 */
public String getDesc(){
  return desc;
}","/** 
 * @return the type descriptor of the enum type.
 */
public String getDesc(){
  return desc;
}"
82393,"public boolean hasNoExternalName(){
  return classType == ClassType.Anonymous || classType == ClassType.Local;
}","/** 
 * @return true if this class has no external name (ie, is defined insidea method).
 */
public boolean hasNoExternalName(){
  return classType.hasNoExternalName();
}"
82394,"public boolean hasHiddenConstructorArg(){
  return false;
}","/** 
 * @return true if this class type has a hidden constructor argumentfor the containing instance (ie, this$0).
 */
public boolean hasHiddenConstructorArg(){
  return false;
}"
82395,"@SuppressWarnings(""String_Node_Str"") public CollectMethodData(CollectClassData.ClassType classType,int access,String name,String desc,String signature,String[] exceptions){
  this.access=access;
  this.name=name;
  this.desc=desc;
  this.signature=signature;
  this.exceptions=exceptions;
  syntheticArgs=0;
  argTypes=Type.getArgumentTypes(desc);
  if (classType.hasHiddenConstructorArg() && ""String_Node_Str"".equals(name)) {
    syntheticArgs=1;
    int n=argTypes.length - syntheticArgs;
    Type[] newArgTypes=new Type[n];
    System.arraycopy(argTypes,syntheticArgs,newArgTypes,0,n);
    argTypes=newArgTypes;
  }
  argNames=new String[argTypes.length];
  paramAnnots=new List[argTypes.length];
  for (int i=0; i < argNames.length; ++i) {
    argNames[i]=""String_Node_Str"" + i;
    paramAnnots[i]=new ArrayList<CollectAnnotationData>();
  }
}","/** 
 * Prepare to collect data for a method from bytecode.
 * @param classType
 * @param access
 * @param name
 * @param desc
 * @param signature
 * @param exceptions
 */
@SuppressWarnings(""String_Node_Str"") public CollectMethodData(CollectClassData.ClassType classType,int access,String name,String desc,String signature,String[] exceptions){
  this.access=access;
  this.name=name;
  this.desc=desc;
  this.signature=signature;
  this.exceptions=exceptions;
  syntheticArgs=0;
  argTypes=Type.getArgumentTypes(desc);
  if (classType.hasHiddenConstructorArg() && ""String_Node_Str"".equals(name)) {
    if (argTypes.length < 1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    syntheticArgs=1;
    int n=argTypes.length - syntheticArgs;
    Type[] newArgTypes=new Type[n];
    System.arraycopy(argTypes,syntheticArgs,newArgTypes,0,n);
    argTypes=newArgTypes;
  }
  argNames=new String[argTypes.length];
  paramAnnots=new List[argTypes.length];
  for (int i=0; i < argNames.length; ++i) {
    argNames[i]=""String_Node_Str"" + i;
    paramAnnots[i]=new ArrayList<CollectAnnotationData>();
  }
}"
82396,"private boolean resolveMethod(TreeLogger logger,JRealClassType type,CollectMethodData methodData,TypeParameterLookup typeParamLookup){
  Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
  resolveAnnotations(logger,methodData.getAnnotations(),declaredAnnotations);
  String name=methodData.getName();
  if (""String_Node_Str"".equals(name) || (methodData.getAccess() & Opcodes.ACC_SYNTHETIC) != 0) {
    return true;
  }
  if (type.isEnum() != null && ""String_Node_Str"".equals(name)) {
    return true;
  }
  JAbstractMethod method;
  JTypeParameter[] typeParams=collectTypeParams(methodData.getSignature());
  typeParamLookup.pushScope(typeParams);
  boolean hasReturnType=true;
  if (""String_Node_Str"".equals(name)) {
    name=type.getSimpleSourceName();
    method=new JConstructor(type,name,declaredAnnotations,typeParams);
    hasReturnType=false;
  }
 else {
    if (type.isAnnotation() != null) {
      method=new JAnnotationMethod(type,name,typeParams,declaredAnnotations);
    }
 else {
      method=new JMethod(type,name,declaredAnnotations,typeParams);
    }
  }
  method.addModifierBits(mapBits(ASM_TO_SHARED_MODIFIERS,methodData.getAccess()));
  if (type.isInterface() != null) {
    method.addModifierBits(Shared.MOD_PUBLIC | Shared.MOD_ABSTRACT);
  }
  if ((methodData.getAccess() & Opcodes.ACC_VARARGS) != 0) {
    method.setVarArgs();
  }
  String signature=methodData.getSignature();
  Type[] argTypes=methodData.getArgTypes();
  String[] argNames=methodData.getArgNames();
  if (signature != null) {
    SignatureReader reader=new SignatureReader(signature);
    ResolveMethodSignature methodResolver=new ResolveMethodSignature(resolver,logger,method,typeParamLookup,hasReturnType,methodData,argTypes,argNames);
    reader.accept(methodResolver);
    if (!methodResolver.finish()) {
      return false;
    }
  }
 else {
    if (hasReturnType) {
      Type returnType=Type.getReturnType(methodData.getDesc());
      JType returnJType=resolveType(returnType);
      if (returnJType == null) {
        return false;
      }
      ((JMethod)method).setReturnType(returnJType);
    }
    if (!resolveParameters(logger,method,methodData)) {
      return false;
    }
  }
  if (!resolveThrows(method,methodData)) {
    return false;
  }
  typeParamLookup.popScope();
  return true;
}","private boolean resolveMethod(TreeLogger logger,JRealClassType type,CollectMethodData methodData,TypeParameterLookup typeParamLookup){
  Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
  resolveAnnotations(logger,methodData.getAnnotations(),declaredAnnotations);
  String name=methodData.getName();
  if (""String_Node_Str"".equals(name) || (methodData.getAccess() & Opcodes.ACC_SYNTHETIC) != 0) {
    return true;
  }
  if (type.isEnum() != null && ""String_Node_Str"".equals(name)) {
    return true;
  }
  JAbstractMethod method;
  JTypeParameter[] typeParams=collectTypeParams(methodData.getSignature());
  typeParamLookup.pushScope(typeParams);
  boolean hasReturnType=true;
  if (""String_Node_Str"".equals(name)) {
    name=type.getSimpleSourceName();
    method=new JConstructor(type,name,declaredAnnotations,typeParams);
    hasReturnType=false;
  }
 else {
    if (type.isAnnotation() != null) {
      method=new JAnnotationMethod(type,name,typeParams,declaredAnnotations);
    }
 else {
      method=new JMethod(type,name,declaredAnnotations,typeParams);
    }
  }
  method.addModifierBits(mapBits(ASM_TO_SHARED_MODIFIERS,methodData.getAccess()));
  if (type.isInterface() != null) {
    method.addModifierBits(Shared.MOD_PUBLIC | Shared.MOD_ABSTRACT);
  }
  if ((methodData.getAccess() & Opcodes.ACC_VARARGS) != 0) {
    method.setVarArgs();
  }
  String signature=methodData.getSignature();
  if (signature != null) {
    SignatureReader reader=new SignatureReader(signature);
    ResolveMethodSignature methodResolver=new ResolveMethodSignature(resolver,logger,method,typeParamLookup,hasReturnType,methodData,methodData.getArgTypes(),methodData.getArgNames(),methodData.hasActualArgNames());
    reader.accept(methodResolver);
    if (!methodResolver.finish()) {
      return false;
    }
  }
 else {
    if (hasReturnType) {
      Type returnType=Type.getReturnType(methodData.getDesc());
      JType returnJType=resolveType(returnType);
      if (returnJType == null) {
        return false;
      }
      ((JMethod)method).setReturnType(returnJType);
    }
    if (!resolveParameters(logger,method,methodData)) {
      return false;
    }
  }
  if (!resolveThrows(method,methodData)) {
    return false;
  }
  typeParamLookup.popScope();
  return true;
}"
82397,"public ResolveMethodSignature(Resolver resolver,TreeLogger logger,JAbstractMethod method,TypeParameterLookup typeParamLookup,boolean hasReturnType,CollectMethodData methodData,Type[] argTypes,String[] argNames){
  this.resolver=resolver;
  this.logger=logger;
  this.method=method;
  this.typeParamLookup=typeParamLookup;
  this.hasReturnType=hasReturnType;
  this.methodData=methodData;
  this.argTypes=argTypes;
  this.argNames=argNames;
}","/** 
 * Resolve a method signature.
 * @param resolver
 * @param logger
 * @param method
 * @param typeParamLookup
 * @param hasReturnType
 * @param methodData
 * @param argTypes
 * @param argNames
 * @param argNamesAreReal
 */
public ResolveMethodSignature(Resolver resolver,TreeLogger logger,JAbstractMethod method,TypeParameterLookup typeParamLookup,boolean hasReturnType,CollectMethodData methodData,Type[] argTypes,String[] argNames,boolean argNamesAreReal){
  this.resolver=resolver;
  this.logger=logger;
  this.method=method;
  this.typeParamLookup=typeParamLookup;
  this.hasReturnType=hasReturnType;
  this.methodData=methodData;
  this.argTypes=argTypes;
  this.argNames=argNames;
  this.argNamesAreReal=argNamesAreReal;
}"
82398,"/** 
 * @return true if resolution succeeded.
 */
public boolean finish(){
  boolean failed=false;
  finishBound();
  if (hasReturnType) {
    failed|=(returnType[0] == null);
    ((JMethod)method).setReturnType(returnType[0]);
  }
  List<CollectAnnotationData>[] argAnnotations=methodData.getArgAnnotations();
  if (argTypes.length != params.size()) {
    throw new IllegalStateException(""String_Node_Str"" + methodData.getDesc() + ""String_Node_Str""+ methodData.getSignature()+ ""String_Node_Str"");
  }
  for (int i=0; i < argTypes.length; ++i) {
    JType argType=params.get(i)[0];
    if (argType == null) {
      failed=true;
      continue;
    }
    Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
    resolver.resolveAnnotations(logger,argAnnotations[i],declaredAnnotations);
    new JParameter(method,argType,argNames[i],declaredAnnotations);
  }
  for (  JType[] exc : exceptions) {
    if (exc[0] == null) {
      failed=true;
      continue;
    }
    method.addThrows(exc[0]);
  }
  return !failed;
}","/** 
 * @return true if resolution succeeded.
 */
public boolean finish(){
  boolean failed=false;
  finishBound();
  if (hasReturnType) {
    failed|=(returnType[0] == null);
    ((JMethod)method).setReturnType(returnType[0]);
  }
  List<CollectAnnotationData>[] argAnnotations=methodData.getArgAnnotations();
  if (argTypes.length != params.size()) {
    throw new IllegalStateException(""String_Node_Str"" + methodData.getDesc() + ""String_Node_Str""+ methodData.getSignature()+ ""String_Node_Str"");
  }
  for (int i=0; i < argTypes.length; ++i) {
    JType argType=params.get(i)[0];
    if (argType == null) {
      failed=true;
      continue;
    }
    Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
    resolver.resolveAnnotations(logger,argAnnotations[i],declaredAnnotations);
    new JParameter(method,argType,argNames[i],declaredAnnotations,argNamesAreReal);
  }
  for (  JType[] exc : exceptions) {
    if (exc[0] == null) {
      failed=true;
      continue;
    }
    method.addThrows(exc[0]);
  }
  return !failed;
}"
82399,"private void resolveMethodSignature(ReflectedMethod method,String signature){
  TypeParameterLookup lookup=new TypeParameterLookup();
  lookup.pushEnclosingScopes(method.getEnclosingType());
  lookup.pushScope(method.getTypeParameters());
  int access=Opcodes.ACC_PUBLIC;
  String desc=Type.getMethodDescriptor(method.getMethod());
  CollectMethodData methodData=new CollectMethodData(ClassType.TopLevel,access,method.getName(),desc,signature,null);
  Class<?>[] paramTypes=method.getMethod().getParameterTypes();
  int n=paramTypes.length;
  Type[] argTypes=new Type[n];
  String[] argNames=new String[n];
  for (int i=0; i < n; ++i) {
    argNames[i]=""String_Node_Str"" + i;
    argTypes[i]=Type.getType(paramTypes[i]);
  }
  ResolveMethodSignature methodResolver=new ResolveMethodSignature(resolver,failTreeLogger,method,lookup,true,methodData,argTypes,argNames);
  new SignatureReader(signature).accept(methodResolver);
  methodResolver.finish();
}","private void resolveMethodSignature(ReflectedMethod method,String signature){
  TypeParameterLookup lookup=new TypeParameterLookup();
  lookup.pushEnclosingScopes(method.getEnclosingType());
  lookup.pushScope(method.getTypeParameters());
  int access=Opcodes.ACC_PUBLIC;
  String desc=Type.getMethodDescriptor(method.getMethod());
  CollectMethodData methodData=new CollectMethodData(ClassType.TopLevel,access,method.getName(),desc,signature,null);
  Class<?>[] paramTypes=method.getMethod().getParameterTypes();
  int n=paramTypes.length;
  Type[] argTypes=new Type[n];
  String[] argNames=new String[n];
  for (int i=0; i < n; ++i) {
    argNames[i]=""String_Node_Str"" + i;
    argTypes[i]=Type.getType(paramTypes[i]);
  }
  ResolveMethodSignature methodResolver=new ResolveMethodSignature(resolver,failTreeLogger,method,lookup,true,methodData,argTypes,argNames,false);
  new SignatureReader(signature).accept(methodResolver);
  methodResolver.finish();
}"
82400,"private void writeClassSerializationStatements(){
  if (typesSentToBrowser.maybeEnhanced(serializableClass) && typesSentFromBrowser.maybeEnhanced(serializableClass)) {
    sourceWriter.println(""String_Node_Str"" + WEAK_MAPPING_CLASS_NAME + ""String_Node_Str"");
  }
  for (  JField serializableField : serializableFields) {
    JType fieldType=serializableField.getType();
    String writeMethodName=Shared.getStreamWriteMethodNameFor(fieldType);
    sourceWriter.print(""String_Node_Str"");
    sourceWriter.print(writeMethodName);
    sourceWriter.print(""String_Node_Str"");
    if (needsAccessorMethods(serializableField)) {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(Shared.capitalize(serializableField.getName()));
      sourceWriter.println(""String_Node_Str"");
    }
 else {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(serializableField.getName());
      sourceWriter.println(""String_Node_Str"");
    }
  }
  sourceWriter.println();
  JClassType superClass=serializableClass.getSuperclass();
  if (superClass != null && (typesSentFromBrowser.isSerializable(superClass) || typesSentToBrowser.isSerializable(superClass))) {
    String fieldSerializerName=SerializationUtils.getFieldSerializerName(typeOracle,superClass);
    sourceWriter.print(fieldSerializerName);
    sourceWriter.println(""String_Node_Str"");
  }
}","private void writeClassSerializationStatements(){
  if (serializableClass.isEnhanced()) {
    sourceWriter.println(""String_Node_Str"" + WEAK_MAPPING_CLASS_NAME + ""String_Node_Str"");
  }
  for (  JField serializableField : serializableFields) {
    JType fieldType=serializableField.getType();
    String writeMethodName=Shared.getStreamWriteMethodNameFor(fieldType);
    sourceWriter.print(""String_Node_Str"");
    sourceWriter.print(writeMethodName);
    sourceWriter.print(""String_Node_Str"");
    if (needsAccessorMethods(serializableField)) {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(Shared.capitalize(serializableField.getName()));
      sourceWriter.println(""String_Node_Str"");
    }
 else {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(serializableField.getName());
      sourceWriter.println(""String_Node_Str"");
    }
  }
  sourceWriter.println();
  JClassType superClass=serializableClass.getSuperclass();
  if (superClass != null && (typesSentFromBrowser.isSerializable(superClass) || typesSentToBrowser.isSerializable(superClass))) {
    String fieldSerializerName=SerializationUtils.getFieldSerializerName(typeOracle,superClass);
    sourceWriter.print(fieldSerializerName);
    sourceWriter.println(""String_Node_Str"");
  }
}"
82401,"private void writeClassDeserializationStatements(){
  if (typesSentToBrowser.maybeEnhanced(serializableClass) && typesSentFromBrowser.maybeEnhanced(serializableClass)) {
    sourceWriter.println(WEAK_MAPPING_CLASS_NAME + ""String_Node_Str"" + ""String_Node_Str"");
  }
  for (  JField serializableField : serializableFields) {
    JType fieldType=serializableField.getType();
    String readMethodName=Shared.getStreamReadMethodNameFor(fieldType);
    String streamReadExpression=""String_Node_Str"" + readMethodName + ""String_Node_Str"";
    if (Shared.typeNeedsCast(fieldType)) {
      streamReadExpression=""String_Node_Str"" + fieldType.getQualifiedSourceName() + ""String_Node_Str""+ streamReadExpression;
    }
    if (needsAccessorMethods(serializableField)) {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(Shared.capitalize(serializableField.getName()));
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(streamReadExpression);
      sourceWriter.println(""String_Node_Str"");
    }
 else {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(serializableField.getName());
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(streamReadExpression);
      sourceWriter.println(""String_Node_Str"");
    }
  }
  sourceWriter.println();
  JClassType superClass=serializableClass.getSuperclass();
  if (superClass != null && (typesSentFromBrowser.isSerializable(superClass) || typesSentToBrowser.isSerializable(superClass))) {
    String fieldSerializerName=SerializationUtils.getFieldSerializerName(typeOracle,superClass);
    sourceWriter.print(fieldSerializerName);
    sourceWriter.println(""String_Node_Str"");
  }
}","private void writeClassDeserializationStatements(){
  if (serializableClass.isEnhanced()) {
    sourceWriter.println(WEAK_MAPPING_CLASS_NAME + ""String_Node_Str"" + ""String_Node_Str"");
  }
  for (  JField serializableField : serializableFields) {
    JType fieldType=serializableField.getType();
    String readMethodName=Shared.getStreamReadMethodNameFor(fieldType);
    String streamReadExpression=""String_Node_Str"" + readMethodName + ""String_Node_Str"";
    if (Shared.typeNeedsCast(fieldType)) {
      streamReadExpression=""String_Node_Str"" + fieldType.getQualifiedSourceName() + ""String_Node_Str""+ streamReadExpression;
    }
    if (needsAccessorMethods(serializableField)) {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(Shared.capitalize(serializableField.getName()));
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(streamReadExpression);
      sourceWriter.println(""String_Node_Str"");
    }
 else {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(serializableField.getName());
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(streamReadExpression);
      sourceWriter.println(""String_Node_Str"");
    }
  }
  sourceWriter.println();
  JClassType superClass=serializableClass.getSuperclass();
  if (superClass != null && (typesSentFromBrowser.isSerializable(superClass) || typesSentToBrowser.isSerializable(superClass))) {
    String fieldSerializerName=SerializationUtils.getFieldSerializerName(typeOracle,superClass);
    sourceWriter.print(fieldSerializerName);
    sourceWriter.println(""String_Node_Str"");
  }
}"
82402,"protected String writeSerializationPolicyFile(TreeLogger logger,GeneratorContext ctx,SerializableTypeOracle serializationSto,SerializableTypeOracle deserializationSto) throws UnableToCompleteException {
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    OutputStreamWriter osw=new OutputStreamWriter(baos,SerializationPolicyLoader.SERIALIZATION_POLICY_FILE_ENCODING);
    TypeOracle oracle=ctx.getTypeOracle();
    PrintWriter pw=new PrintWriter(osw);
    JType[] serializableTypes=unionOfTypeArrays(serializationSto.getSerializableTypes(),deserializationSto.getSerializableTypes(),new JType[]{serviceIntf});
    for (int i=0; i < serializableTypes.length; ++i) {
      JType type=serializableTypes[i];
      String binaryTypeName=TypeOracleMediator.computeBinaryClassName(type);
      pw.print(binaryTypeName);
      pw.print(""String_Node_Str"" + Boolean.toString(deserializationSto.isSerializable(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(deserializationSto.maybeInstantiated(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(serializationSto.isSerializable(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(serializationSto.maybeInstantiated(type)));
      pw.print(""String_Node_Str"" + typeStrings.get(type));
      pw.print(""String_Node_Str"" + SerializationUtils.getSerializationSignature(oracle,type));
      pw.print('\n');
      if ((type instanceof JClassType) && serializationSto.maybeEnhanced(type) && deserializationSto.maybeEnhanced(type)) {
        JField[] fields=((JClassType)type).getFields();
        JField[] rpcFields=new JField[fields.length];
        int numRpcFields=0;
        for (        JField f : fields) {
          if (f.isTransient() || f.isStatic() || f.isFinal()) {
            continue;
          }
          rpcFields[numRpcFields++]=f;
        }
        pw.print(SerializationPolicyLoader.CLIENT_FIELDS_KEYWORD);
        pw.print(',');
        pw.print(binaryTypeName);
        for (int idx=0; idx < numRpcFields; idx++) {
          pw.print(',');
          pw.print(rpcFields[idx].getName());
        }
        pw.print('\n');
      }
    }
    pw.close();
    byte[] serializationPolicyFileContents=baos.toByteArray();
    String serializationPolicyName=Util.computeStrongName(serializationPolicyFileContents);
    String serializationPolicyFileName=SerializationPolicyLoader.getSerializationPolicyFileName(serializationPolicyName);
    OutputStream os=ctx.tryCreateResource(logger,serializationPolicyFileName);
    if (os != null) {
      os.write(serializationPolicyFileContents);
      GeneratedResource resource=ctx.commitResource(logger,os);
      ctx.commitArtifact(logger,new RpcPolicyFileArtifact(serviceIntf.getQualifiedSourceName(),resource));
    }
 else {
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + serviceIntf.getQualifiedSourceName() + ""String_Node_Str"",null);
    }
    return serializationPolicyName;
  }
 catch (  UnsupportedEncodingException e) {
    logger.log(TreeLogger.ERROR,SerializationPolicyLoader.SERIALIZATION_POLICY_FILE_ENCODING + ""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
catch (  IOException e) {
    logger.log(TreeLogger.ERROR,null,e);
    throw new UnableToCompleteException();
  }
}","protected String writeSerializationPolicyFile(TreeLogger logger,GeneratorContext ctx,SerializableTypeOracle serializationSto,SerializableTypeOracle deserializationSto) throws UnableToCompleteException {
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    OutputStreamWriter osw=new OutputStreamWriter(baos,SerializationPolicyLoader.SERIALIZATION_POLICY_FILE_ENCODING);
    TypeOracle oracle=ctx.getTypeOracle();
    PrintWriter pw=new PrintWriter(osw);
    JType[] serializableTypes=unionOfTypeArrays(serializationSto.getSerializableTypes(),deserializationSto.getSerializableTypes(),new JType[]{serviceIntf});
    for (int i=0; i < serializableTypes.length; ++i) {
      JType type=serializableTypes[i];
      String binaryTypeName=TypeOracleMediator.computeBinaryClassName(type);
      pw.print(binaryTypeName);
      pw.print(""String_Node_Str"" + Boolean.toString(deserializationSto.isSerializable(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(deserializationSto.maybeInstantiated(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(serializationSto.isSerializable(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(serializationSto.maybeInstantiated(type)));
      pw.print(""String_Node_Str"" + typeStrings.get(type));
      pw.print(""String_Node_Str"" + SerializationUtils.getSerializationSignature(oracle,type));
      pw.print('\n');
      if ((type instanceof JClassType) && ((JClassType)type).isEnhanced()) {
        JField[] fields=((JClassType)type).getFields();
        JField[] rpcFields=new JField[fields.length];
        int numRpcFields=0;
        for (        JField f : fields) {
          if (f.isTransient() || f.isStatic() || f.isFinal()) {
            continue;
          }
          rpcFields[numRpcFields++]=f;
        }
        pw.print(SerializationPolicyLoader.CLIENT_FIELDS_KEYWORD);
        pw.print(',');
        pw.print(binaryTypeName);
        for (int idx=0; idx < numRpcFields; idx++) {
          pw.print(',');
          pw.print(rpcFields[idx].getName());
        }
        pw.print('\n');
      }
    }
    pw.close();
    byte[] serializationPolicyFileContents=baos.toByteArray();
    String serializationPolicyName=Util.computeStrongName(serializationPolicyFileContents);
    String serializationPolicyFileName=SerializationPolicyLoader.getSerializationPolicyFileName(serializationPolicyName);
    OutputStream os=ctx.tryCreateResource(logger,serializationPolicyFileName);
    if (os != null) {
      os.write(serializationPolicyFileContents);
      GeneratedResource resource=ctx.commitResource(logger,os);
      ctx.commitArtifact(logger,new RpcPolicyFileArtifact(serviceIntf.getQualifiedSourceName(),resource));
    }
 else {
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + serviceIntf.getQualifiedSourceName() + ""String_Node_Str"",null);
    }
    return serializationPolicyName;
  }
 catch (  UnsupportedEncodingException e) {
    logger.log(TreeLogger.ERROR,SerializationPolicyLoader.SERIALIZATION_POLICY_FILE_ENCODING + ""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
catch (  IOException e) {
    logger.log(TreeLogger.ERROR,null,e);
    throw new UnableToCompleteException();
  }
}"
82403,"/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=computeTypeInstantiability(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems).hasInstantiableSubtypes();
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyEnhancedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (!(tic.getType() instanceof JClassType)) {
      continue;
    }
    JClassType type=(JClassType)tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if ((enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName())) || tic.maybeEnhanced()) {
      possiblyEnhancedTypes.add(type);
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes,possiblyEnhancedTypes);
}","/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=computeTypeInstantiability(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems).hasInstantiableSubtypes();
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (!(tic.getType() instanceof JClassType)) {
      continue;
    }
    JClassType type=(JClassType)tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if (tic.maybeEnhanced() || (enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName()))) {
      type.setEnhanced();
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes);
}"
82404,"public SerializableTypeOracleImpl(Set<JClassType> serializableTypes,Set<JClassType> possiblyInstantiatedTypes,Set<JClassType> possiblyEnhancedTypes){
  serializableTypesSet=serializableTypes;
  this.possiblyInstantiatedTypes=possiblyInstantiatedTypes;
  this.possiblyEnhancedTypes=possiblyEnhancedTypes;
}","public SerializableTypeOracleImpl(Set<JClassType> serializableTypes,Set<JClassType> possiblyInstantiatedTypes){
  serializableTypesSet=serializableTypes;
  this.possiblyInstantiatedTypes=possiblyInstantiatedTypes;
}"
82405,"/** 
 * Set any created BrowserChannelServers to ignore remote deaths. <p>This is most commonly wanted by JUnitShell.
 * @param ignoreRemoteDeath
 */
public void setIgnoreRemoteDeath(boolean ignoreRemoteDeath){
  this.ignoreRemoteDeath=ignoreRemoteDeath;
}","/** 
 * Set any created BrowserChannelServers to ignore remote deaths. <p> This is most commonly wanted by JUnitShell.
 * @param ignoreRemoteDeath
 */
public void setIgnoreRemoteDeath(boolean ignoreRemoteDeath){
  this.ignoreRemoteDeath=ignoreRemoteDeath;
}"
82406,"/** 
 * Create a new instance using the given streams and request processor. Closing either stream will cause the termination of the transport.
 * @param inputStream an input stream for reading messages
 * @param outputStream an output stream for writing messages
 * @param requestProcessor a callback interface for handling remote clientrequests
 */
public MessageTransport(final InputStream inputStream,final OutputStream outputStream,RequestProcessor requestProcessor){
  this.requestProcessor=requestProcessor;
  serverRequestExecutor=Executors.newFixedThreadPool(DEFAULT_SERVICE_THREADS);
  messageProcessingThread=new Thread(new Runnable(){
    public void run(){
      try {
        while (true) {
          Message message=Message.parseDelimitedFrom(inputStream);
          processMessage(message);
        }
      }
 catch (      IOException e) {
        terminateDueToException(e);
      }
catch (      InterruptedException e) {
        terminateDueToException(e);
      }
    }
  }
);
  messageProcessingThread.start();
  sendThread=new Thread(new Runnable(){
    public void run(){
      while (true) {
        try {
          PendingSend pendingSend=sendQueue.take();
          try {
            pendingSend.send(outputStream);
          }
 catch (          IOException e) {
            pendingSend.failed(e);
          }
        }
 catch (        InterruptedException e) {
          break;
        }
      }
    }
  }
);
  sendThread.setDaemon(true);
  sendThread.start();
}","/** 
 * Create a new instance using the given streams and request processor. Closing either stream will cause the termination of the transport.
 * @param inputStream an input stream for reading messages
 * @param outputStream an output stream for writing messages
 * @param requestProcessor a callback interface for handling remote clientrequests
 * @param terminationCallback a callback that is invoked when the transportterminates
 */
public MessageTransport(final InputStream inputStream,final OutputStream outputStream,RequestProcessor requestProcessor,TerminationCallback terminationCallback){
  this.requestProcessor=requestProcessor;
  this.terminationCallback=terminationCallback;
  serverRequestExecutor=Executors.newFixedThreadPool(DEFAULT_SERVICE_THREADS);
  messageProcessingThread=new Thread(new Runnable(){
    public void run(){
      try {
        while (true) {
          Message message=Message.parseDelimitedFrom(inputStream);
          processMessage(message);
        }
      }
 catch (      IOException e) {
        terminateDueToException(e);
      }
catch (      InterruptedException e) {
        terminateDueToException(e);
      }
    }
  }
);
  messageProcessingThread.start();
  sendThread=new Thread(new Runnable(){
    public void run(){
      while (true) {
        try {
          PendingSend pendingSend=sendQueue.take();
          try {
            pendingSend.send(outputStream);
          }
 catch (          IOException e) {
            pendingSend.failed(e);
          }
        }
 catch (        InterruptedException e) {
          break;
        }
      }
    }
  }
);
  sendThread.setDaemon(true);
  sendThread.start();
}"
82407,"private void terminateDueToException(Exception e){
  pendingRequestMap.blockAdds(e);
}","private void terminateDueToException(Exception e){
  pendingRequestMap.blockAdds(e);
  if (terminationCallback != null) {
    terminationCallback.onTermination(e);
  }
}"
82408,"public RemoteUI(String host,int port,String clientId,int webServerPort,int browserChannelPort){
  try {
    this.clientId=clientId;
    this.browserChannelPort=browserChannelPort;
    this.webServerPort=webServerPort;
    Socket socket=new Socket(host,port);
    devModeRequestProcessor=new DevModeServiceRequestProcessor(this);
    transport=new MessageTransport(socket.getInputStream(),socket.getOutputStream(),devModeRequestProcessor);
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public RemoteUI(String host,int port,String clientId,int webServerPort,int browserChannelPort){
  try {
    this.clientId=clientId;
    this.browserChannelPort=browserChannelPort;
    this.webServerPort=webServerPort;
    Socket socket=new Socket(host,port);
    socket.setKeepAlive(true);
    socket.setTcpNoDelay(true);
    devModeRequestProcessor=new DevModeServiceRequestProcessor(this);
    transport=new MessageTransport(socket.getInputStream(),socket.getOutputStream(),devModeRequestProcessor,this);
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
82409,"public void makeTopLevelShell() throws IOException {
  String permutationId=getPermutationId();
  PrintWriter outFile=new PrintWriter(getOutFile(""String_Node_Str"" + ""String_Node_Str"" + getPermutationId() + ""String_Node_Str""));
  addStandardHtmlProlog(outFile,""String_Node_Str"" + permutationId,""String_Node_Str"" + permutationId,""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getInitialCodeBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getTotalCodeBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getLeftoversBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  if (globalInformation.getSplitPointToLocation().size() > 1) {
    int numSplitPoints=globalInformation.getSplitPointToLocation().size();
    float maxSize=globalInformation.getTotalCodeBreakdown().sizeAllCode;
    for (int i=FRAGMENT_NUMBER_TOTAL_PROGRAM; i <= numSplitPoints + 1; i++) {
      SizeBreakdown breakdown;
      if (i == FRAGMENT_NUMBER_TOTAL_PROGRAM) {
        continue;
      }
 else       if (i == numSplitPoints + 1) {
        continue;
      }
 else       if (i == FRAGMENT_NUMBER_INITIAL_DOWNLOAD) {
        continue;
      }
 else {
        breakdown=globalInformation.splitPointCodeBreakdown(i);
      }
      String drillDownFileName=shellFileName(breakdown,getPermutationId());
      String splitPointDescription=globalInformation.getSplitPointToLocation().get(i);
      float size=breakdown.sizeAllCode;
      float ratio;
      ratio=(size / maxSize) * 100;
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"" + i + ""String_Node_Str"");
      outFile.println(""String_Node_Str"" + drillDownFileName + ""String_Node_Str""+ splitPointDescription+ ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"" + ratio + ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println((int)size + ""String_Node_Str"" + formatNumber(ratio)+ ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"");
    }
  }
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  addStandardHtmlEnding(outFile);
  outFile.close();
}","public void makeTopLevelShell() throws IOException {
  String permutationId=getPermutationId();
  PrintWriter outFile=new PrintWriter(getOutFile(""String_Node_Str"" + ""String_Node_Str"" + getPermutationId() + ""String_Node_Str""));
  addStandardHtmlProlog(outFile,""String_Node_Str"" + permutationId,""String_Node_Str"" + permutationId,""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getTotalCodeBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getInitialCodeBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getLeftoversBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  if (globalInformation.getSplitPointToLocation().size() >= 1) {
    int numSplitPoints=globalInformation.getSplitPointToLocation().size();
    float maxSize=globalInformation.getTotalCodeBreakdown().sizeAllCode;
    for (int i=FRAGMENT_NUMBER_TOTAL_PROGRAM; i <= numSplitPoints + 1; i++) {
      SizeBreakdown breakdown;
      if (i == FRAGMENT_NUMBER_TOTAL_PROGRAM) {
        continue;
      }
 else       if (i == numSplitPoints + 1) {
        continue;
      }
 else       if (i == FRAGMENT_NUMBER_INITIAL_DOWNLOAD) {
        continue;
      }
 else {
        breakdown=globalInformation.splitPointCodeBreakdown(i);
      }
      String drillDownFileName=shellFileName(breakdown,getPermutationId());
      String splitPointDescription=globalInformation.getSplitPointToLocation().get(i);
      float size=breakdown.sizeAllCode;
      float ratio;
      ratio=(size / maxSize) * 100;
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"" + i + ""String_Node_Str"");
      outFile.println(""String_Node_Str"" + drillDownFileName + ""String_Node_Str""+ splitPointDescription+ ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"" + ratio + ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println((int)size + ""String_Node_Str"" + formatNumber(ratio)+ ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"");
    }
  }
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  addStandardHtmlEnding(outFile);
  outFile.close();
}"
82410,"@Override protected void doCommitBranch(AbstractTreeLogger childBeingCommitted,Type type,String msg,Throwable caught,HelpInfo helpInfo){
  SwingTreeLogger commitChild=(SwingTreeLogger)childBeingCommitted;
  LogEvent logEvent=new LogEvent(commitChild,true,commitChild.getBranchedIndex(),type,msg,caught,helpInfo);
  commitChild.treeNode=new DefaultMutableTreeNode(logEvent);
  addUpdate(logEvent);
}","@Override protected void doCommitBranch(AbstractTreeLogger childBeingCommitted,Type type,String msg,Throwable caught,HelpInfo helpInfo){
}"
82411,"/** 
 * Constructs the top-level TreeItemLogger.
 * @param panel
 */
public SwingTreeLogger(SwingLoggerPanel panel){
  this.panel=panel;
  treeNode=(DefaultMutableTreeNode)panel.treeModel.getRoot();
}","/** 
 * Used to create a branch treelogger, supplying a tree node to use rather than the panel's.
 * @param panel
 * @param treeNode
 */
private SwingTreeLogger(SwingLoggerPanel panel,DefaultMutableTreeNode treeNode){
  this.panel=panel;
  this.treeNode=treeNode;
}"
82412,"private int findInsertionPoint(DefaultMutableTreeNode parent,int index){
  int high=parent.getChildCount() - 1;
  if (high < 0) {
    return 0;
  }
  int low=0;
  while (low <= high) {
    final int mid=low + ((high - low) >> 1);
    DefaultMutableTreeNode midChild=(DefaultMutableTreeNode)parent.getChildAt(mid);
    final Object userObject=midChild.getUserObject();
    int compIdx=-1;
    if (userObject instanceof LogEvent) {
      LogEvent event=(LogEvent)userObject;
      compIdx=event.index;
    }
    if (compIdx < index) {
      low=mid + 1;
    }
 else     if (compIdx > index) {
      high=mid - 1;
    }
 else {
      return mid;
    }
  }
  return low;
}","private int findInsertionPoint(DefaultMutableTreeNode parentNode,int index){
  int high=parentNode.getChildCount() - 1;
  if (high < 0) {
    return 0;
  }
  int low=0;
  while (low <= high) {
    final int mid=low + ((high - low) >> 1);
    DefaultMutableTreeNode midChild=(DefaultMutableTreeNode)parentNode.getChildAt(mid);
    final Object userObject=midChild.getUserObject();
    int compIdx=-1;
    if (userObject instanceof LogEvent) {
      LogEvent event=(LogEvent)userObject;
      compIdx=event.index;
    }
    if (compIdx < index) {
      low=mid + 1;
    }
 else     if (compIdx > index) {
      high=mid - 1;
    }
 else {
      return mid;
    }
  }
  return low;
}"
82413,"/** 
 * Update this log event's inherited priority, which is the highest priority of this event and any child events.
 * @param inheritedPriority
 * @return true if the priority was upgraded
 */
public boolean updateInheritedPriority(Type inheritedPriority){
  if (this.inheritedPriority.isLowerPriorityThan(inheritedPriority)) {
    this.inheritedPriority=inheritedPriority;
    return true;
  }
  return false;
}","/** 
 * Update this log event's inherited priority, which is the highest priority of this event and any child events.
 * @param childPriority
 * @return true if the priority was upgraded
 */
public boolean updateInheritedPriority(Type childPriority){
  if (this.inheritedPriority.isLowerPriorityThan(childPriority)) {
    this.inheritedPriority=childPriority;
    return true;
  }
  return false;
}"
82414,"public LogEvent(SwingTreeLogger logger,boolean isBranchCommit,int index,Type type,String message,Throwable caught,HelpInfo helpInfo){
  this.childLogger=logger;
  this.isBranchCommit=isBranchCommit;
  this.index=index;
  this.type=type;
  this.inheritedPriority=type;
  this.message=message;
  this.helpInfo=helpInfo;
  this.timestamp=new Date();
  this.exceptionDetail=AbstractTreeLogger.getStackTraceAsString(caught);
  this.exceptionName=AbstractTreeLogger.getExceptionName(caught);
}","/** 
 * Create a log event.
 * @param logger
 * @param isBranchCommit
 * @param index
 * @param type
 * @param message
 * @param caught
 * @param helpInfo
 */
public LogEvent(SwingTreeLogger logger,boolean isBranchCommit,int index,Type type,String message,Throwable caught,HelpInfo helpInfo){
  this.childLogger=logger;
  this.isBranchCommit=isBranchCommit;
  this.index=index;
  this.type=type;
  this.inheritedPriority=type;
  this.message=message;
  this.helpInfo=helpInfo;
  this.timestamp=new Date();
  this.exceptionDetail=AbstractTreeLogger.getStackTraceAsString(caught);
  this.exceptionName=AbstractTreeLogger.getExceptionName(caught);
}"
82415,"public Type getInheritedPriority(){
  return inheritedPriority;
}","/** 
 * @return the inherited priority, which will be the highest priority ofthis event or any child.
 */
public Type getInheritedPriority(){
  return inheritedPriority;
}"
82416,"@Override protected AbstractTreeLogger doBranch(){
  SwingTreeLogger newLogger=new SwingTreeLogger(panel);
  return newLogger;
}","@Override protected AbstractTreeLogger doBranch(){
  SwingTreeLogger newLogger=new SwingTreeLogger(panel,new DefaultMutableTreeNode(null));
  return newLogger;
}"
82417,"/** 
 * @param logEvent
 */
private void addUpdate(final LogEvent logEvent){
  new SwingWorker<LogEvent,Void>(){
    @Override protected LogEvent doInBackground() throws Exception {
      return logEvent;
    }
    @Override protected void done(){
      LogEvent event;
      try {
        event=get();
        SwingTreeLogger logger=event.childLogger;
        DefaultMutableTreeNode node;
        DefaultMutableTreeNode parent;
        int idx;
        if (event.isBranchCommit) {
          SwingTreeLogger parentLogger=(SwingTreeLogger)logger.getParentLogger();
          parent=parentLogger.treeNode;
          idx=logger.getBranchedIndex();
          node=logger.treeNode;
        }
 else {
          parent=logger.treeNode;
          idx=event.index;
          node=new DefaultMutableTreeNode(event);
        }
        int insertIndex=findInsertionPoint(parent,idx);
        panel.treeModel.insertNodeInto(node,parent,insertIndex);
        if (parent == panel.treeModel.getRoot() && parent.getChildCount() == 1) {
          panel.treeModel.reload();
        }
        if (event.type.needsAttention()) {
          panel.tree.makeVisible(new TreePath(node.getPath()));
        }
        Type priority=event.getInheritedPriority();
        while (parent != panel.treeModel.getRoot()) {
          LogEvent parentEvent=(LogEvent)parent.getUserObject();
          if (!parentEvent.updateInheritedPriority(priority)) {
            break;
          }
          parent=(DefaultMutableTreeNode)parent.getParent();
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
catch (      ExecutionException e) {
        e.printStackTrace();
      }
    }
    private int findInsertionPoint(    DefaultMutableTreeNode parent,    int index){
      int high=parent.getChildCount() - 1;
      if (high < 0) {
        return 0;
      }
      int low=0;
      while (low <= high) {
        final int mid=low + ((high - low) >> 1);
        DefaultMutableTreeNode midChild=(DefaultMutableTreeNode)parent.getChildAt(mid);
        final Object userObject=midChild.getUserObject();
        int compIdx=-1;
        if (userObject instanceof LogEvent) {
          LogEvent event=(LogEvent)userObject;
          compIdx=event.index;
        }
        if (compIdx < index) {
          low=mid + 1;
        }
 else         if (compIdx > index) {
          high=mid - 1;
        }
 else {
          return mid;
        }
      }
      return low;
    }
  }
.execute();
}","/** 
 * Add a log event to be processed on the event thread.
 * @param logEvent LogEvent to process
 */
private void addUpdate(final LogEvent logEvent){
  EventQueue.invokeLater(new Runnable(){
    public void run(){
      SwingTreeLogger logger=logEvent.childLogger;
      DefaultMutableTreeNode node;
      DefaultMutableTreeNode parentNode;
      int idx;
      if (logEvent.isBranchCommit) {
        SwingTreeLogger parentLogger=(SwingTreeLogger)logger.getParentLogger();
        logger.treeNode.setUserObject(logEvent);
        parentNode=parentLogger.treeNode;
        idx=logger.getBranchedIndex();
        node=logger.treeNode;
      }
 else {
        parentNode=logger.treeNode;
        idx=logEvent.index;
        node=new DefaultMutableTreeNode(logEvent);
      }
      int insertIndex=findInsertionPoint(parentNode,idx);
      panel.treeModel.insertNodeInto(node,parentNode,insertIndex);
      if (parentNode == panel.treeModel.getRoot() && parentNode.getChildCount() == 1) {
        panel.treeModel.reload();
      }
      if (logEvent.type.needsAttention()) {
        panel.tree.makeVisible(new TreePath(node.getPath()));
      }
      Type priority=logEvent.getInheritedPriority();
      while (parentNode != panel.treeModel.getRoot()) {
        LogEvent parentEvent=(LogEvent)parentNode.getUserObject();
        if (!parentEvent.updateInheritedPriority(priority)) {
          break;
        }
        parentNode=((DefaultMutableTreeNode)parentNode.getParent());
      }
    }
    private int findInsertionPoint(    DefaultMutableTreeNode parentNode,    int index){
      int high=parentNode.getChildCount() - 1;
      if (high < 0) {
        return 0;
      }
      int low=0;
      while (low <= high) {
        final int mid=low + ((high - low) >> 1);
        DefaultMutableTreeNode midChild=(DefaultMutableTreeNode)parentNode.getChildAt(mid);
        final Object userObject=midChild.getUserObject();
        int compIdx=-1;
        if (userObject instanceof LogEvent) {
          LogEvent event=(LogEvent)userObject;
          compIdx=event.index;
        }
        if (compIdx < index) {
          low=mid + 1;
        }
 else         if (compIdx > index) {
          high=mid - 1;
        }
 else {
          return mid;
        }
      }
      return low;
    }
  }
);
}"
82418,"public void animate(int duration,final Layout.AnimationCallback callback){
  animCmd.schedule(duration,callback);
}","public void animate(int duration,final Layout.AnimationCallback callback){
  layoutCmd.schedule(duration,callback);
}"
82419,"public void forceLayout(){
  animCmd.cancel();
  doLayout();
  layout.layout();
  onResize();
}","public void forceLayout(){
  layoutCmd.cancel();
  doLayout();
  layout.layout();
  onResize();
}"
82420,"/** 
 * Creates an empty dock panel.
 * @param unit the unit to be used for layout
 */
public DockLayoutPanel(Unit unit){
  this.unit=unit;
  setElement(Document.get().createDivElement());
  layout=new Layout(getElement());
  animCmd=new DockAnimateCommand(layout);
}","/** 
 * Creates an empty dock panel.
 * @param unit the unit to be used for layout
 */
public DockLayoutPanel(Unit unit){
  this.unit=unit;
  setElement(Document.get().createDivElement());
  layout=new Layout(getElement());
  layoutCmd=new DockAnimateCommand(layout);
}"
82421,"/** 
 * Creates a new command for the given layout object
 * @param layout
 */
public LayoutCommand(Layout layout){
  this.layout=layout;
}","/** 
 * Creates a new command for the given layout object.
 * @param layout
 */
public LayoutCommand(Layout layout){
  this.layout=layout;
}"
82422,"public void animate(final int duration,final AnimationCallback callback){
  animCmd.schedule(duration,callback);
}","public void animate(final int duration,final AnimationCallback callback){
  layoutCmd.schedule(duration,callback);
}"
82423,"/** 
 * Creates an empty layout panel.
 */
public LayoutPanel(){
  setElement(Document.get().createDivElement());
  layout=new Layout(getElement());
  animCmd=new LayoutCommand(layout);
}","/** 
 * Creates an empty layout panel.
 */
public LayoutPanel(){
  setElement(Document.get().createDivElement());
  layout=new Layout(getElement());
  layoutCmd=new LayoutCommand(layout);
}"
82424,"public void forceLayout(){
  animCmd.cancel();
  layout.layout();
  onResize();
}","public void forceLayout(){
  layoutCmd.cancel();
  layout.layout();
  onResize();
}"
82425,"/** 
 * Removes the given handler from the specified event type. Normally, applications should call   {@link HandlerRegistration#removeHandler()}instead.
 * @param < H > handler type
 * @param type the event type
 * @param handler the handler
 * @deprecated This method is likely to be removed along with ""listener""interfaces in a future release. If you have a reason it should be retained beyond that time, please add your comments to GWT <a href=""http://code.google.com/p/google-web-toolkit/issues/detail?id=3102"">issue 3102</a>
 */
@Deprecated public <H extends EventHandler>void removeHandler(GwtEvent.Type<H> type,final H handler){
  if (firingDepth > 0) {
    enqueueRemove(type,handler);
  }
 else {
    doRemove(type,handler);
  }
}","/** 
 * Removes the given handler from the specified event type. Normally, applications should call   {@link HandlerRegistration#removeHandler()}instead.
 * @param < H > handler type
 * @param type the event type
 * @param handler the handler
 */
public <H extends EventHandler>void removeHandler(GwtEvent.Type<H> type,final H handler){
  if (firingDepth > 0) {
    enqueueRemove(type,handler);
  }
 else {
    doRemove(type,handler);
  }
}"
82426,"@SuppressWarnings(""String_Node_Str"") public void testRemoveHandlers(){
  HandlerManager manager=new HandlerManager(""String_Node_Str"");
  addHandlers(manager);
  manager.removeHandler(MouseDownEvent.getType(),adaptor1);
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(mouse1,mouse2,mouse3,adaptor1);
  assertNotFired(click1,click2);
  manager.removeHandler(MouseDownEvent.getType(),adaptor1);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(mouse1,mouse2,mouse3);
  assertNotFired(adaptor1,click1,click2);
  reset();
  manager.fireEvent(new ClickEvent(){
  }
);
  assertNotFired(mouse1,mouse2,mouse3);
  assertFired(click1,click2,adaptor1);
}","public void testRemoveHandlers(){
  HandlerManager manager=new HandlerManager(""String_Node_Str"");
  addHandlers(manager);
  manager.removeHandler(MouseDownEvent.getType(),adaptor1);
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(mouse1,mouse2,mouse3,adaptor1);
  assertNotFired(click1,click2);
  manager.removeHandler(MouseDownEvent.getType(),adaptor1);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(mouse1,mouse2,mouse3);
  assertNotFired(adaptor1,click1,click2);
  reset();
  manager.fireEvent(new ClickEvent(){
  }
);
  assertNotFired(mouse1,mouse2,mouse3);
  assertFired(click1,click2,adaptor1);
}"
82427,"@SuppressWarnings(""String_Node_Str"") public void testConcurrentAddAfterRemoveIsNotClobbered(){
  final HandlerManager manager=new HandlerManager(""String_Node_Str"");
  MouseDownHandler one=new MouseDownHandler(){
    public void onMouseDown(    MouseDownEvent event){
      manager.removeHandler(MouseDownEvent.getType(),mouse1);
      manager.addHandler(MouseDownEvent.getType(),mouse1);
      add(this);
    }
  }
;
  manager.addHandler(MouseDownEvent.getType(),one);
  if (!GWT.isScript()) {
    try {
      manager.fireEvent(new MouseDownEvent(){
      }
);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    return;
  }
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one,mouse1);
}","public void testConcurrentAddAfterRemoveIsNotClobbered(){
  final HandlerManager manager=new HandlerManager(""String_Node_Str"");
  MouseDownHandler one=new MouseDownHandler(){
    public void onMouseDown(    MouseDownEvent event){
      manager.removeHandler(MouseDownEvent.getType(),mouse1);
      manager.addHandler(MouseDownEvent.getType(),mouse1);
      add(this);
    }
  }
;
  manager.addHandler(MouseDownEvent.getType(),one);
  if (!GWT.isScript()) {
    try {
      manager.fireEvent(new MouseDownEvent(){
      }
);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    return;
  }
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one,mouse1);
}"
82428,"/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger, LinkerContext, CompilationResult).}
 */
@Override protected String getModulePrefix(TreeLogger logger,LinkerContext context,String strongName) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}","/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger,LinkerContext,CompilationResult)}.
 */
@Override protected String getModulePrefix(TreeLogger logger,LinkerContext context,String strongName) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}"
82429,"/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger, LinkerContext, CompilationResult).}
 */
@Override protected String getCompilationExtension(TreeLogger logger,LinkerContext context) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}","/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger,LinkerContext,CompilationResult)}.
 */
@Override protected String getCompilationExtension(TreeLogger logger,LinkerContext context) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}"
82430,"/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger, LinkerContext, CompilationResult).}
 */
@Override protected String getModuleSuffix(TreeLogger logger,LinkerContext context) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}","/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger,LinkerContext,CompilationResult)}.
 */
@Override protected String getModuleSuffix(TreeLogger logger,LinkerContext context) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}"
82431,"/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a{@link #precompile(TreeLogger,WebModeCompilerFrontEnd,String[],JJSOptions,boolean)}
 * @param permutation the permutation to compile
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Permutation permutation) throws UnableToCompleteException {
  PropertyOracle[] propertyOracles=permutation.getPropertyOracles();
  int permutationId=permutation.getId();
  Map<String,String> rebindAnswers=permutation.getRebindAnswers();
  int printId=permutationId + 1;
  logger.log(TreeLogger.INFO,""String_Node_Str"" + printId + ""String_Node_Str"");
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    JJSOptions options=unifiedAst.getOptions();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,rebindAnswers);
    if (options.isDraftCompile()) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    LongCastNormalizer.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeAfterOptimizations();
    JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable);
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      boolean didChange;
      do {
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
        didChange=false;
        didChange=JsStaticEval.exec(jsProgram) || didChange;
        didChange=JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
    JsStackEmulator.exec(jsProgram,propertyOracles);
    SyntheticArtifact dependencies=null;
    if (options.isAggressivelyOptimize() && options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      CodeSplitter.exec(logger,jprogram,jsProgram,map,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      if (baos.size() == 0 && options.isSoycEnabled()) {
        recordNonSplitDependencies(jprogram,baos);
      }
      if (baos.size() > 0) {
        dependencies=new SyntheticArtifact(SoycReportLinker.class,""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
SelectionProperty userAgentProperty=null;
for (PropertyOracle oracle : propertyOracles) {
userAgentProperty=oracle.getSelectionProperty(logger,""String_Node_Str"");
if (userAgentProperty != null) {
break;
}
}
boolean splitBlocks=userAgentProperty == null || (""String_Node_Str"".equals(userAgentProperty.getCurrentValue()));
if (splitBlocks) {
JsIEBlockSizeVisitor.exec(jsProgram);
}
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=options.isSoycExtra() ? new ArrayList<Map<Range,SourceInfo>>() : null;
generateJavaScriptCode(options,jsProgram,map,js,ranges,sizeBreakdowns,sourceInfoMaps,splitBlocks);
PermutationResult toReturn=new PermutationResultImpl(js,permutation,makeSymbolMap(symbolTable),ranges);
toReturn.addArtifacts(makeSoycArtifacts(logger,permutationId,jprogram,js,sizeBreakdowns,sourceInfoMaps,dependencies,map,obfuscateMap));
logger.log(TreeLogger.TRACE,""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
return toReturn;
}
 catch (Throwable e) {
throw logAndTranslateException(logger,e);
}
}","/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a{@link #precompile(TreeLogger,WebModeCompilerFrontEnd,String[],JJSOptions,boolean)}
 * @param permutation the permutation to compile
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Permutation permutation) throws UnableToCompleteException {
  PropertyOracle[] propertyOracles=permutation.getPropertyOracles();
  int permutationId=permutation.getId();
  Map<String,String> rebindAnswers=permutation.getRebindAnswers();
  int printId=permutationId + 1;
  logger.log(TreeLogger.INFO,""String_Node_Str"" + printId + ""String_Node_Str"");
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    JJSOptions options=unifiedAst.getOptions();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,rebindAnswers);
    if (options.isDraftCompile()) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    LongCastNormalizer.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeAfterOptimizations();
    JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable);
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      boolean didChange;
      do {
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
        didChange=false;
        didChange=JsStaticEval.exec(jsProgram) || didChange;
        didChange=JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
    JsStackEmulator.exec(jsProgram,propertyOracles);
    SyntheticArtifact dependencies=null;
    if (options.isAggressivelyOptimize() && options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      CodeSplitter.exec(logger,jprogram,jsProgram,map,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      if (baos.size() == 0 && options.isSoycEnabled()) {
        recordNonSplitDependencies(jprogram,baos);
      }
      if (baos.size() > 0) {
        dependencies=new SyntheticArtifact(SoycReportLinker.class,""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
SelectionProperty userAgentProperty=null;
for (PropertyOracle oracle : propertyOracles) {
try {
userAgentProperty=oracle.getSelectionProperty(logger,""String_Node_Str"");
}
 catch (BadPropertyValueException e) {
break;
}
}
boolean splitBlocks=userAgentProperty == null || (""String_Node_Str"".equals(userAgentProperty.getCurrentValue()));
if (splitBlocks) {
JsIEBlockSizeVisitor.exec(jsProgram);
}
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=options.isSoycExtra() ? new ArrayList<Map<Range,SourceInfo>>() : null;
generateJavaScriptCode(options,jsProgram,map,js,ranges,sizeBreakdowns,sourceInfoMaps,splitBlocks);
PermutationResult toReturn=new PermutationResultImpl(js,permutation,makeSymbolMap(symbolTable),ranges);
toReturn.addArtifacts(makeSoycArtifacts(logger,permutationId,jprogram,js,sizeBreakdowns,sourceInfoMaps,dependencies,map,obfuscateMap));
logger.log(TreeLogger.TRACE,""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
return toReturn;
}
 catch (Throwable e) {
throw logAndTranslateException(logger,e);
}
}"
82432,"public void parse(XMLElement elem,String fieldName,JClassType type,UiBinderWriter writer) throws UnableToCompleteException {
  for (  XMLElement child : elem.consumeChildElements()) {
    String ns=child.getNamespaceUri();
    String tagName=child.getLocalName();
    if (ns.equals(elem.getNamespaceUri()) && localTagNameIsCell(tagName)) {
      XMLElement widget=child.consumeSingleChildElement();
      String childFieldName=writer.parseElementToField(widget);
      writer.addStatement(""String_Node_Str"",fieldName,childFieldName);
      parseCellAttributes(child,fieldName,childFieldName,writer);
    }
 else {
      String childFieldName=writer.parseElementToField(child);
      writer.addStatement(""String_Node_Str"",fieldName,childFieldName);
    }
  }
}","public void parse(XMLElement elem,String fieldName,JClassType type,UiBinderWriter writer) throws UnableToCompleteException {
  for (  XMLElement child : elem.consumeChildElements()) {
    String ns=child.getNamespaceUri();
    String tagName=child.getLocalName();
    if (ns != null && ns.equals(elem.getNamespaceUri()) && localTagNameIsCell(tagName)) {
      XMLElement widget=child.consumeSingleChildElement();
      String childFieldName=writer.parseElementToField(widget);
      writer.addStatement(""String_Node_Str"",fieldName,childFieldName);
      parseCellAttributes(child,fieldName,childFieldName,writer);
    }
 else {
      if (!writer.isWidgetElement(child)) {
        writer.die(""String_Node_Str"",elem,elem.getPrefix(),CELL_TAG.toLowerCase(),child);
      }
      String childFieldName=writer.parseElementToField(child);
      writer.addStatement(""String_Node_Str"",fieldName,childFieldName);
    }
  }
}"
82433,"/** 
 * Parses the root UiBinder element, and kicks off the parsing of the rest of the document.
 */
public String parse(XMLElement elem) throws UnableToCompleteException {
  findResources(elem);
  messagesWriter.findMessagesConfig(elem);
  XMLElement uiRoot=elem.consumeSingleChildElement();
  return writer.parseElementToField(uiRoot);
}","/** 
 * Parses the root UiBinder element, and kicks off the parsing of the rest of the document.
 */
public String parse(XMLElement elem) throws UnableToCompleteException {
  if (!writer.isBinderElement(elem)) {
    writer.die(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",elem.getPrefix(),elem.getLocalName(),UiBinderWriter.BINDER_URI,elem.getPrefix());
  }
  if (!TAG.equals(elem.getLocalName())) {
    writer.die(""String_Node_Str"",elem.getPrefix(),TAG,elem);
  }
  findResources(elem);
  messagesWriter.findMessagesConfig(elem);
  XMLElement uiRoot=elem.consumeSingleChildElement();
  return writer.parseElementToField(uiRoot);
}"
82434,"/** 
 * Consumes a single child element, ignoring any text nodes and throwing an exception if no child is found, or more than one child element is found.
 * @throws UnableToCompleteException on no children, or too many
 */
public XMLElement consumeSingleChildElement() throws UnableToCompleteException {
  XMLElement ret=null;
  for (  XMLElement child : consumeChildElements()) {
    if (ret != null) {
      writer.die(""String_Node_Str"" + ""String_Node_Str"",getLocalName(),ret,child);
    }
    ret=child;
  }
  if (ret == null) {
    writer.die(""String_Node_Str"",this);
  }
  return ret;
}","/** 
 * Consumes a single child element, ignoring any text nodes and throwing an exception if no child is found, or more than one child element is found.
 * @throws UnableToCompleteException on no children, or too many
 */
public XMLElement consumeSingleChildElement() throws UnableToCompleteException {
  XMLElement ret=null;
  for (  XMLElement child : consumeChildElements()) {
    if (ret != null) {
      writer.die(""String_Node_Str"" + ""String_Node_Str"",this,ret,child);
    }
    ret=child;
  }
  if (ret == null) {
    writer.die(""String_Node_Str"",this);
  }
  return ret;
}"
82435,"static String generateConstantOrMessageClass(TreeLogger logger,GeneratorContext context,GwtLocale locale,JClassType targetClass) throws UnableToCompleteException {
  TypeOracle oracle=context.getTypeOracle();
  JClassType constantsClass;
  JClassType messagesClass;
  JClassType constantsWithLookupClass;
  boolean seenError=false;
  try {
    constantsClass=oracle.getType(LocalizableGenerator.CONSTANTS_NAME);
    constantsWithLookupClass=oracle.getType(LocalizableGenerator.CONSTANTS_WITH_LOOKUP_NAME);
    messagesClass=oracle.getType(LocalizableGenerator.MESSAGES_NAME);
  }
 catch (  NotFoundException e) {
    throw error(logger,e);
  }
  String name=targetClass.getName();
  String packageName=targetClass.getPackage().getName();
  boolean assignableToConstants=constantsClass.isAssignableFrom(targetClass);
  boolean assignableToMessages=messagesClass.isAssignableFrom(targetClass);
  if (!assignableToConstants && !assignableToMessages) {
    return null;
  }
  if (assignableToConstants && assignableToMessages) {
    throw error(logger,name + ""String_Node_Str"");
  }
  if (targetClass.isInterface() == null) {
    throw error(logger,name + ""String_Node_Str"");
  }
  ResourceList resourceList=null;
  try {
    resourceList=ResourceFactory.getBundle(logger,targetClass,locale,assignableToConstants,context.getResourcesOracle().getResourceMap());
  }
 catch (  MissingResourceException e) {
    throw error(logger,""String_Node_Str"" + ""String_Node_Str"" + packageName + ""String_Node_Str""+ ResourceFactory.getResourceName(targetClass)+ ""String_Node_Str"");
  }
catch (  IllegalArgumentException e) {
    throw error(logger,e.getMessage());
  }
  GwtLocale generatedLocale=resourceList.findLeastDerivedLocale(locale);
  String localeSuffix=String.valueOf(ResourceFactory.LOCALE_SEPARATOR);
  localeSuffix+=generatedLocale.getAsString();
  String resourceName=targetClass.getName().replace('.','_');
  String className=resourceName + localeSuffix;
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.addImplementedInterface(targetClass.getQualifiedSourceName());
    SourceWriter writer=factory.createSourceWriter(context,pw);
    if (constantsWithLookupClass.isAssignableFrom(targetClass)) {
      ConstantsWithLookupImplCreator c=new ConstantsWithLookupImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      c.emitClass(logger,generatedLocale);
    }
 else     if (constantsClass.isAssignableFrom(targetClass)) {
      ConstantsImplCreator c=new ConstantsImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      c.emitClass(logger,generatedLocale);
    }
 else {
      MessagesImplCreator messages=new MessagesImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      messages.emitClass(logger,generatedLocale);
    }
    context.commit(logger,pw);
  }
  Generate generate=getClassAnnotation(targetClass,Generate.class);
  if (generate != null) {
    String path=generate.fileName();
    if (Generate.DEFAULT.equals(path)) {
      path=targetClass.getPackage().getName() + ""String_Node_Str"" + targetClass.getName().replace('.','_');
    }
 else     if (path.endsWith(File.pathSeparator)) {
      path=path + targetClass.getName().replace('.','_');
    }
    String[] genLocales=generate.locales();
    boolean found=false;
    if (genLocales.length != 0) {
      for (      String genLocale : genLocales) {
        if (GwtLocale.DEFAULT_LOCALE.equals(genLocale)) {
          try {
            SelectionProperty localeProp=context.getPropertyOracle().getSelectionProperty(logger,""String_Node_Str"");
            String defaultLocale=localeProp.getFallbackValue();
            if (defaultLocale.length() > 0) {
              genLocale=defaultLocale;
            }
          }
 catch (          BadPropertyValueException e) {
            throw error(logger,""String_Node_Str"");
          }
        }
        if (genLocale.equals(locale.toString())) {
          found=true;
          break;
        }
      }
    }
 else {
      found=true;
    }
    if (found) {
      for (      String genClassName : generate.format()) {
        MessageCatalogFormat msgWriter=null;
        try {
          Class<? extends MessageCatalogFormat> msgFormatClass=Class.forName(genClassName,false,MessageCatalogFormat.class.getClassLoader()).asSubclass(MessageCatalogFormat.class);
          msgWriter=msgFormatClass.newInstance();
        }
 catch (        InstantiationException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName,e);
          seenError=true;
          continue;
        }
catch (        IllegalAccessException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName + ""String_Node_Str"",e);
          seenError=true;
          continue;
        }
catch (        ClassNotFoundException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName + ""String_Node_Str"");
          seenError=true;
          continue;
        }
        String genPath=path;
        if (genLocales.length != 1) {
          genPath+='_' + locale.toString();
        }
        genPath+=msgWriter.getExtension();
        OutputStream outStr=context.tryCreateResource(logger,genPath);
        if (outStr != null) {
          TreeLogger branch=logger.branch(TreeLogger.INFO,""String_Node_Str"" + genPath + ""String_Node_Str""+ className+ ""String_Node_Str""+ locale,null);
          PrintWriter out=null;
          try {
            out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStr,""String_Node_Str"")),false);
          }
 catch (          UnsupportedEncodingException e) {
            throw error(logger,e.getMessage());
          }
          try {
            msgWriter.write(branch,locale.toString(),resourceList,out,targetClass);
            out.flush();
            context.commitResource(logger,outStr).setPrivate(true);
          }
 catch (          UnableToCompleteException e) {
            seenError=true;
          }
        }
      }
    }
  }
  if (seenError) {
    throw new UnableToCompleteException();
  }
  return packageName + ""String_Node_Str"" + className;
}","static String generateConstantOrMessageClass(TreeLogger logger,GeneratorContext context,GwtLocale locale,JClassType targetClass) throws UnableToCompleteException {
  TypeOracle oracle=context.getTypeOracle();
  JClassType constantsClass;
  JClassType messagesClass;
  JClassType constantsWithLookupClass;
  boolean seenError=false;
  try {
    constantsClass=oracle.getType(LocalizableGenerator.CONSTANTS_NAME);
    constantsWithLookupClass=oracle.getType(LocalizableGenerator.CONSTANTS_WITH_LOOKUP_NAME);
    messagesClass=oracle.getType(LocalizableGenerator.MESSAGES_NAME);
  }
 catch (  NotFoundException e) {
    throw error(logger,e);
  }
  String name=targetClass.getName();
  String packageName=targetClass.getPackage().getName();
  boolean assignableToConstants=constantsClass.isAssignableFrom(targetClass);
  boolean assignableToMessages=messagesClass.isAssignableFrom(targetClass);
  if (!assignableToConstants && !assignableToMessages) {
    return null;
  }
  if (assignableToConstants && assignableToMessages) {
    throw error(logger,name + ""String_Node_Str"");
  }
  if (targetClass.isInterface() == null) {
    throw error(logger,name + ""String_Node_Str"");
  }
  ResourceList resourceList=null;
  try {
    resourceList=ResourceFactory.getBundle(logger,targetClass,locale,assignableToConstants,context.getResourcesOracle().getResourceMap());
  }
 catch (  MissingResourceException e) {
    throw error(logger,""String_Node_Str"" + ""String_Node_Str"" + packageName + ""String_Node_Str""+ ResourceFactory.getResourceName(targetClass)+ ""String_Node_Str"");
  }
catch (  IllegalArgumentException e) {
    throw error(logger,e.getMessage());
  }
  GwtLocale generatedLocale=resourceList.findLeastDerivedLocale(logger,locale);
  String localeSuffix=String.valueOf(ResourceFactory.LOCALE_SEPARATOR);
  localeSuffix+=generatedLocale.getAsString();
  String resourceName=targetClass.getName().replace('.','_');
  String className=resourceName + localeSuffix;
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.addImplementedInterface(targetClass.getQualifiedSourceName());
    SourceWriter writer=factory.createSourceWriter(context,pw);
    if (constantsWithLookupClass.isAssignableFrom(targetClass)) {
      ConstantsWithLookupImplCreator c=new ConstantsWithLookupImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      c.emitClass(logger,generatedLocale);
    }
 else     if (constantsClass.isAssignableFrom(targetClass)) {
      ConstantsImplCreator c=new ConstantsImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      c.emitClass(logger,generatedLocale);
    }
 else {
      MessagesImplCreator messages=new MessagesImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      messages.emitClass(logger,generatedLocale);
    }
    context.commit(logger,pw);
  }
  Generate generate=getClassAnnotation(targetClass,Generate.class);
  if (generate != null) {
    String path=generate.fileName();
    if (Generate.DEFAULT.equals(path)) {
      path=targetClass.getPackage().getName() + ""String_Node_Str"" + targetClass.getName().replace('.','_');
    }
 else     if (path.endsWith(File.pathSeparator)) {
      path=path + targetClass.getName().replace('.','_');
    }
    String[] genLocales=generate.locales();
    boolean found=false;
    if (genLocales.length != 0) {
      for (      String genLocale : genLocales) {
        if (GwtLocale.DEFAULT_LOCALE.equals(genLocale)) {
          try {
            SelectionProperty localeProp=context.getPropertyOracle().getSelectionProperty(logger,""String_Node_Str"");
            String defaultLocale=localeProp.getFallbackValue();
            if (defaultLocale.length() > 0) {
              genLocale=defaultLocale;
            }
          }
 catch (          BadPropertyValueException e) {
            throw error(logger,""String_Node_Str"");
          }
        }
        if (genLocale.equals(locale.toString())) {
          found=true;
          break;
        }
      }
    }
 else {
      found=true;
    }
    if (found) {
      for (      String genClassName : generate.format()) {
        MessageCatalogFormat msgWriter=null;
        try {
          Class<? extends MessageCatalogFormat> msgFormatClass=Class.forName(genClassName,false,MessageCatalogFormat.class.getClassLoader()).asSubclass(MessageCatalogFormat.class);
          msgWriter=msgFormatClass.newInstance();
        }
 catch (        InstantiationException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName,e);
          seenError=true;
          continue;
        }
catch (        IllegalAccessException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName + ""String_Node_Str"",e);
          seenError=true;
          continue;
        }
catch (        ClassNotFoundException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName + ""String_Node_Str"");
          seenError=true;
          continue;
        }
        String genPath=path;
        if (genLocales.length != 1) {
          genPath+='_' + locale.toString();
        }
        genPath+=msgWriter.getExtension();
        OutputStream outStr=context.tryCreateResource(logger,genPath);
        if (outStr != null) {
          TreeLogger branch=logger.branch(TreeLogger.INFO,""String_Node_Str"" + genPath + ""String_Node_Str""+ className+ ""String_Node_Str""+ locale,null);
          PrintWriter out=null;
          try {
            out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStr,""String_Node_Str"")),false);
          }
 catch (          UnsupportedEncodingException e) {
            throw error(logger,e.getMessage());
          }
          try {
            msgWriter.write(branch,locale.toString(),resourceList,out,targetClass);
            out.flush();
            context.commitResource(logger,outStr).setPrivate(true);
          }
 catch (          UnableToCompleteException e) {
            seenError=true;
          }
        }
      }
    }
  }
  if (seenError) {
    throw new UnableToCompleteException();
  }
  return packageName + ""String_Node_Str"" + className;
}"
82436,"/** 
 * From the list of locales matched for any resources in this resource list, choose the one that is least derived from the original search locale.
 * @param locale originally requested locale
 * @return least derived matched locale
 */
public GwtLocale findLeastDerivedLocale(GwtLocale locale){
}","/** 
 * From the list of locales matched for any resources in this resource list, choose the one that is least derived from the original search locale.
 * @param logger logger to use
 * @param locale originally requested locale
 * @return least derived matched locale
 */
public GwtLocale findLeastDerivedLocale(TreeLogger logger,GwtLocale locale){
  List<GwtLocale> searchList=locale.getCompleteSearchList();
  Map<GwtLocale,Integer> derivedIndex=new HashMap<GwtLocale,Integer>();
  for (int i=0; i < searchList.size(); ++i) {
    derivedIndex.put(searchList.get(i),i);
  }
  GwtLocale best=LocaleUtils.getLocaleFactory().getDefault();
  int bestIdx=Integer.MAX_VALUE;
  for (int i=0; i < list.size(); ++i) {
    GwtLocale matchLocale=list.get(i).getMatchLocale();
    Integer wrappedIdx=derivedIndex.get(matchLocale);
    if (wrappedIdx == null) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + matchLocale + ""String_Node_Str""+ searchList);
      continue;
    }
    int idx=wrappedIdx;
    if (idx < bestIdx) {
      bestIdx=idx;
      best=matchLocale;
    }
  }
  return best;
}"
82437,"/** 
 * Returns a string where all URL component escape sequences have been converted back to their original character representations.
 * @param encodedURLComponent string containing encoded URL componentsequences
 * @return string with no encoded URL component encoded sequences
 * @throws NullPointerException if encodedURLComponent is <code>null</code>
 */
public static String decodeComponent(String encodedURLComponent){
  StringValidator.throwIfNull(""String_Node_Str"",encodedURLComponent);
  return decodeComponentImpl(encodedURLComponent);
}","/** 
 * Returns a string where all URL component escape sequences have been converted back to their original character representations.
 * @param encodedURLComponent string containing encoded URL componentsequences
 * @param fromQueryString if <code>true</code>, +'s will be turned intospaces, otherwise they'll be kept as-is.
 * @return string with no encoded URL component encoded sequences
 * @throws NullPointerException if encodedURLComponent is <code>null</code>
 */
public static String decodeComponent(String encodedURLComponent,boolean fromQueryString){
  StringValidator.throwIfNull(""String_Node_Str"",encodedURLComponent);
  return fromQueryString ? decodeComponentImpl(encodedURLComponent) : decodeComponentRawImpl(encodedURLComponent);
}"
82438,"/** 
 * Returns a string where all characters that are not valid for a URL component have been escaped. The escaping of a character is done by converting it into its UTF-8 encoding and then encoding each of the resulting bytes as a %xx hexadecimal escape sequence. <p> The following character sets are <em>not</em> escaped by this method: <ul> <li>ASCII digits or letters</li> <li>ASCII punctuation characters: <pre>- _ . ! ~ * ' ( )</pre></li> </ul> </p> <p> Notice that this method <em>does</em> encode the URL component delimiter characters:<blockquote> <pre> ; / ? : &amp; = + $ , # </pre> </blockquote> </p>
 * @param decodedURLComponent a string containing invalid URL characters
 * @return a string with all invalid URL characters escaped
 * @throws NullPointerException if decodedURLComponent is <code>null</code>
 */
public static String encodeComponent(String decodedURLComponent){
  StringValidator.throwIfNull(""String_Node_Str"",decodedURLComponent);
  return encodeComponentImpl(decodedURLComponent);
}","/** 
 * Returns a string where all characters that are not valid for a URL component have been escaped. The escaping of a character is done by converting it into its UTF-8 encoding and then encoding each of the resulting bytes as a %xx hexadecimal escape sequence. <p> The following character sets are <em>not</em> escaped by this method: <ul> <li>ASCII digits or letters</li> <li>ASCII punctuation characters: <pre>- _ . ! ~ * ' ( )</pre></li> </ul> </p> <p> Notice that this method <em>does</em> encode the URL component delimiter characters:<blockquote> <pre> ; / ? : &amp; = + $ , # </pre> </blockquote> </p>
 * @param decodedURLComponent a string containing invalid URL characters
 * @param queryStringSpaces if <code>true</code>, spaces will be encoded as +'s.
 * @return a string with all invalid URL characters escaped
 * @throws NullPointerException if decodedURLComponent is <code>null</code>
 */
public static String encodeComponent(String decodedURLComponent,boolean queryStringSpaces){
  StringValidator.throwIfNull(""String_Node_Str"",decodedURLComponent);
  return queryStringSpaces ? encodeComponentImpl(decodedURLComponent) : encodeComponentRawImpl(decodedURLComponent);
}"
82439,"/** 
 * Test method for  {@link com.google.gwt.http.client.URL#decodeComponent(java.lang.String)}.
 */
public void testDecodeComponent(){
  try {
    URL.decodeComponent(null);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException ex) {
  }
  assertEquals(""String_Node_Str"",URL.decodeComponent(""String_Node_Str""));
  assertEquals(""String_Node_Str"",URL.decodeComponent(""String_Node_Str""));
  String actualURLComponent=URL.decodeComponent(ENCODED_URL_COMPONENT);
  assertEquals(DECODED_URL_COMPONENT,actualURLComponent);
}","/** 
 * Test method for  {@link com.google.gwt.http.client.URL#decodeComponent(java.lang.String)}.
 */
public void testDecodeComponent(){
  try {
    URL.decodeComponent(null);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException ex) {
  }
  assertEquals(""String_Node_Str"",URL.decodeComponent(""String_Node_Str""));
  assertEquals(""String_Node_Str"",URL.decodeComponent(""String_Node_Str""));
  String actualURLComponent=URL.decodeComponent(ENCODED_URL_COMPONENT);
  assertEquals(DECODED_URL_COMPONENT,actualURLComponent);
  actualURLComponent=URL.decodeComponent(ENCODED_URL_COMPONENT_QS);
  assertEquals(DECODED_URL_COMPONENT,actualURLComponent);
}"
82440,"/** 
 * Test method for  {@link com.google.gwt.http.client.URL#encodeComponent(java.lang.String)}.
 */
public void testEncodeComponent(){
  try {
    URL.encodeComponent(null);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException ex) {
  }
  assertEquals(""String_Node_Str"",URL.encodeComponent(""String_Node_Str""));
  assertEquals(""String_Node_Str"",URL.encodeComponent(""String_Node_Str""));
  String actualURLComponent=URL.encodeComponent(DECODED_URL_COMPONENT);
  assertEquals(ENCODED_URL_COMPONENT,actualURLComponent);
}","/** 
 * Test method for  {@link com.google.gwt.http.client.URL#encodeComponent(java.lang.String)}.
 */
public void testEncodeComponent(){
  try {
    URL.encodeComponent(null);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException ex) {
  }
  assertEquals(""String_Node_Str"",URL.encodeComponent(""String_Node_Str""));
  assertEquals(""String_Node_Str"",URL.encodeComponent(""String_Node_Str""));
  String actualURLComponent=URL.encodeComponent(DECODED_URL_COMPONENT);
  assertEquals(ENCODED_URL_COMPONENT_QS,actualURLComponent);
}"
82441,"static JMethodCall makeStaticCall(JMethodCall x,JMethod newMethod){
  JMethodCall newCall=new JMethodCall(x.getSourceInfo().makeChild(MakeCallsStatic.class,""String_Node_Str""),null,newMethod);
  newCall.addArg(x.getInstance());
  newCall.addArgs(x.getArgs());
  return newCall;
}","static JExpression makeStaticCall(JMethodCall x,JMethod newMethod){
  JMethodCall newCall=new JMethodCall(x.getSourceInfo().makeChild(MakeCallsStatic.class,""String_Node_Str""),null,newMethod);
  if (x.getInstance() instanceof JMultiExpression) {
    JMultiExpression multi=(JMultiExpression)x.getInstance();
    int lastIndex=multi.exprs.size() - 1;
    newCall.addArg(multi.exprs.get(lastIndex));
    newCall.addArgs(x.getArgs());
    multi.exprs.set(lastIndex,newCall);
    return multi;
  }
 else {
    newCall.addArg(x.getInstance());
    newCall.addArgs(x.getArgs());
    return newCall;
  }
}"
82442,"/** 
 * This function parses a ""localized"" text into a <code>double</code>. It needs to handle locale specific decimal, grouping, exponent and digit.
 * @param text the text that need to be parsed
 * @param pos in/out parsing position. in case of failure, this shouldn't bechanged
 * @return double value, could be 0.0 if nothing can be parsed
 */
private double parseNumber(String text,int[] pos){
  double ret;
  boolean sawDecimal=false;
  boolean sawExponent=false;
  boolean sawDigit=false;
  int scale=1;
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String exponentChar=numberConstants.exponentialSymbol();
  StringBuffer normalizedText=new StringBuffer();
  for (; pos[0] < text.length(); ++pos[0]) {
    char ch=text.charAt(pos[0]);
    int digit=getDigit(ch);
    if (digit >= 0 && digit <= 9) {
      normalizedText.append((char)(digit + '0'));
      sawDigit=true;
    }
 else     if (ch == decimal.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      normalizedText.append('.');
      sawDecimal=true;
    }
 else     if (ch == grouping.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      continue;
    }
 else     if (ch == exponentChar.charAt(0)) {
      if (sawExponent) {
        break;
      }
      normalizedText.append('E');
      sawExponent=true;
    }
 else     if (ch == '+' || ch == '-') {
      normalizedText.append(ch);
    }
 else     if (ch == numberConstants.percent().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=100;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else     if (ch == numberConstants.perMill().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=1000;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else {
      break;
    }
  }
  ret=Double.parseDouble(normalizedText.toString());
  ret=ret / scale;
  return ret;
}","/** 
 * This function parses a ""localized"" text into a <code>double</code>. It needs to handle locale specific decimal, grouping, exponent and digit.
 * @param text the text that need to be parsed
 * @param pos in/out parsing position. in case of failure, this shouldn't bechanged
 * @return double value, could be 0.0 if nothing can be parsed
 */
private double parseNumber(String text,int[] pos){
  double ret;
  boolean sawDecimal=false;
  boolean sawExponent=false;
  boolean sawDigit=false;
  int scale=1;
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String exponentChar=numberConstants.exponentialSymbol();
  StringBuffer normalizedText=new StringBuffer();
  for (; pos[0] < text.length(); ++pos[0]) {
    char ch=text.charAt(pos[0]);
    int digit=getDigit(ch);
    if (digit >= 0 && digit <= 9) {
      normalizedText.append((char)(digit + '0'));
      sawDigit=true;
    }
 else     if (ch == decimal.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      normalizedText.append('.');
      sawDecimal=true;
    }
 else     if (ch == grouping.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      continue;
    }
 else     if (ch == exponentChar.charAt(0)) {
      if (sawExponent) {
        break;
      }
      normalizedText.append('E');
      sawExponent=true;
    }
 else     if (ch == '+' || ch == '-') {
      normalizedText.append(ch);
    }
 else     if (ch == numberConstants.percent().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=100;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else     if (ch == numberConstants.perMill().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=1000;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else {
      break;
    }
  }
  try {
    ret=Double.parseDouble(normalizedText.toString());
  }
 catch (  NumberFormatException e) {
    throw new NumberFormatException(text);
  }
  ret=ret / scale;
  return ret;
}"
82443,"private void addAllOuterThisRefs(List<? super JFieldRef> list,JExpression expr,JClassType classType){
  if (classType.getFields().size() > 0) {
    JField field=classType.getFields().get(0);
    if (field.getName().startsWith(""String_Node_Str"")) {
      list.add(new JFieldRef(expr.getSourceInfo(),expr,field,currentClass));
    }
  }
}","private void addAllOuterThisRefs(List<? super JFieldRef> list,JExpression expr,JClassType classType){
  if (classType.getFields().size() > 0) {
    JField field=classType.getFields().get(0);
    if (field.getName().startsWith(""String_Node_Str"") || field.getName().startsWith(""String_Node_Str"")) {
      list.add(new JFieldRef(expr.getSourceInfo(),expr,field,currentClass));
    }
  }
}"
82444,"/** 
 * Add a statement to be run after everything has been instantiated, in the style of   {@link String#format}
 */
public void addInitStatement(String format,Object... params){
  initStatements.add(String.format(format,params));
}","/** 
 * Add a statement to be run after everything has been instantiated, in the style of   {@link String#format}
 */
public void addInitStatement(String format,Object... params){
  initStatements.add(formatCode(format,params));
}"
82445,"/** 
 * Adds a statement to the block run after fields are declared, in the style of   {@link String#format}
 */
public void addStatement(String format,Object... args){
  statements.add(String.format(format,args));
}","/** 
 * Adds a statement to the block run after fields are declared, in the style of   {@link String#format}
 */
public void addStatement(String format,Object... args){
  statements.add(formatCode(format,args));
}"
82446,"/** 
 * Instructs the writer to initialize the field with a specific contructor invocaction, instead of the default GWT.create call.
 */
public void setFieldInitializerAsConstructor(String fieldName,JClassType type,String... args){
  setFieldInitializer(fieldName,String.format(""String_Node_Str"",type.getQualifiedSourceName(),asCommaSeparatedList(args)));
}","/** 
 * Instructs the writer to initialize the field with a specific contructor invocaction, instead of the default GWT.create call.
 */
public void setFieldInitializerAsConstructor(String fieldName,JClassType type,String... args){
  setFieldInitializer(fieldName,formatCode(""String_Node_Str"",type.getQualifiedSourceName(),asCommaSeparatedList(args)));
}"
82447,"/** 
 * Write declarations for variables or fields to hold elements declared with gwt:field in the template. For those that have not had constructor generation suppressed, emit GWT.create() calls instantiating them (or die if they have no default constructor).
 * @throws UnableToCompleteException on constructor problem
 */
private void writeGwtFields(IndentedWriter niceWriter) throws UnableToCompleteException {
  Collection<OwnerField> ownerFields=getOwnerClass().getUiFields();
  for (  OwnerField ownerField : ownerFields) {
    if (ownerField.isProvided()) {
      String fieldName=ownerField.getName();
      FieldWriter fieldWriter=fieldManager.lookup(fieldName);
      if (fieldWriter != null) {
        fieldManager.lookup(fieldName).setInitializerMaybe(String.format(""String_Node_Str"",fieldName));
      }
    }
  }
  fieldManager.writeGwtFieldsDeclaration(niceWriter,uiOwnerType.getName());
}","/** 
 * Write declarations for variables or fields to hold elements declared with gwt:field in the template. For those that have not had constructor generation suppressed, emit GWT.create() calls instantiating them (or die if they have no default constructor).
 * @throws UnableToCompleteException on constructor problem
 */
private void writeGwtFields(IndentedWriter niceWriter) throws UnableToCompleteException {
  Collection<OwnerField> ownerFields=getOwnerClass().getUiFields();
  for (  OwnerField ownerField : ownerFields) {
    if (ownerField.isProvided()) {
      String fieldName=ownerField.getName();
      FieldWriter fieldWriter=fieldManager.lookup(fieldName);
      if (fieldWriter != null) {
        fieldManager.lookup(fieldName).setInitializerMaybe(formatCode(""String_Node_Str"",fieldName));
      }
    }
  }
  fieldManager.writeGwtFieldsDeclaration(niceWriter,uiOwnerType.getName());
}"
82448,"public Contacts(){
  initWidget(panel=binder.createAndBindUi(this));
  for (int i=0; i < contacts.length; ++i) {
    addContact(contacts[i]);
  }
}","public Contacts(){
  initWidget(binder.createAndBindUi(this));
  for (int i=0; i < contacts.length; ++i) {
    addContact(contacts[i]);
  }
}"
82449,"@Override public List<TestInfo[]> getTestBlocks(String syntheticModuleName){
  Set<TestInfo> allTestsInModule=GWTTestCase.getTestsForModule(syntheticModuleName).getTests();
  TestInfo[] testBlock=allTestsInModule.toArray(new TestInfo[allTestsInModule.size()]);
  List<TestInfo[]> testBlocks=new ArrayList<TestInfo[]>();
  testBlocks.add(testBlock);
  return testBlocks;
}","@Override public List<TestInfo[]> getTestBlocks(String syntheticModuleName){
  Set<TestInfo> allTestsInModule=getTestsForModule(syntheticModuleName);
  List<TestInfo[]> testBlocks=new ArrayList<TestInfo[]>();
  if (allTestsInModule.size() > 0) {
    TestInfo[] testBlock=allTestsInModule.toArray(new TestInfo[allTestsInModule.size()]);
    testBlocks.add(testBlock);
  }
  return testBlocks;
}"
82450,"/** 
 * Get the list of remote user agents to compile. This method returns null until all clients have connected.
 * @return the list of remote user agents
 */
public static String[] getRemoteUserAgents(){
  return getUnitTestShell().remoteUserAgents;
}","/** 
 * Get the list of remote user agents to compile. This method returns null until all clients have connected.
 * @return the list of remote user agents
 */
public static String[] getRemoteUserAgents(){
  if (unitTestShell == null) {
    return null;
  }
  return unitTestShell.remoteUserAgents;
}"
82451,"/** 
 * Retrieves the JUnitShell. This should only be invoked during TestRunner execution of JUnit tests.
 */
private static JUnitShell getUnitTestShell(){
  if (unitTestShell == null) {
    unitTestShell=new JUnitShell();
    unitTestShell.lastLaunchFailed=true;
    String[] args=unitTestShell.synthesizeArgs();
    ArgProcessor argProcessor=unitTestShell.new ArgProcessor();
    if (!argProcessor.processArgs(args)) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.messageQueue=new JUnitMessageQueue(unitTestShell.numClients);
    if (!unitTestShell.startUp()) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.lastLaunchFailed=false;
  }
  return unitTestShell;
}","/** 
 * Retrieves the JUnitShell. This should only be invoked during TestRunner execution of JUnit tests.
 */
private static JUnitShell getUnitTestShell(){
  if (unitTestShell == null) {
    unitTestShell=new JUnitShell();
    unitTestShell.lastLaunchFailed=true;
    String[] args=unitTestShell.synthesizeArgs();
    ArgProcessor argProcessor=unitTestShell.new ArgProcessor();
    if (!argProcessor.processArgs(args)) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.messageQueue=new JUnitMessageQueue(unitTestShell.numClients);
    if (!unitTestShell.startUp()) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.lastLaunchFailed=false;
  }
  if (unitTestShell.thread != Thread.currentThread()) {
    throw new IllegalThreadStateException(""String_Node_Str"");
  }
  return unitTestShell;
}"
82452,"/** 
 * returns the set of banned   {@code Platform} for a test method.
 */
private static Set<Platform> getBannedPlatforms(TestCase testCase){
  Class<?> testClass=testCase.getClass();
  Set<Platform> bannedSet=EnumSet.noneOf(Platform.class);
  if (testClass.isAnnotationPresent(DoNotRunWith.class)) {
    bannedSet.addAll(Arrays.asList(testClass.getAnnotation(DoNotRunWith.class).value()));
  }
  try {
    Method testMethod=testClass.getMethod(testCase.getName());
    if (testMethod.isAnnotationPresent(DoNotRunWith.class)) {
      bannedSet.addAll(Arrays.asList(testMethod.getAnnotation(DoNotRunWith.class).value()));
    }
  }
 catch (  SecurityException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
  return bannedSet;
}","/** 
 * Returns the set of banned   {@code Platform} for a test method.
 * @param testClass the testClass
 * @param methodName the name of the test method
 */
private static Set<Platform> getBannedPlatforms(Class<?> testClass,String methodName){
  Set<Platform> bannedSet=EnumSet.noneOf(Platform.class);
  if (testClass.isAnnotationPresent(DoNotRunWith.class)) {
    bannedSet.addAll(Arrays.asList(testClass.getAnnotation(DoNotRunWith.class).value()));
  }
  try {
    Method testMethod=testClass.getMethod(methodName);
    if (testMethod.isAnnotationPresent(DoNotRunWith.class)) {
      bannedSet.addAll(Arrays.asList(testMethod.getAnnotation(DoNotRunWith.class).value()));
    }
  }
 catch (  SecurityException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
  return bannedSet;
}"
82453,"/** 
 * Enforce the singleton pattern. The call to   {@link GWTShell}'s ctor forces server mode and disables processing extra arguments as URLs to be shown.
 */
private JUnitShell(){
  setRunTomcat(true);
  setHeadless(true);
  if (System.getProperty(PROP_JUNIT_HYBRID_MODE) != null) {
    runStyle=new RunStyleLocalWeb(this);
  }
}","/** 
 * Enforce the singleton pattern. The call to   {@link GWTShell}'s ctor forces server mode and disables processing extra arguments as URLs to be shown.
 */
private JUnitShell(){
  thread=Thread.currentThread();
  setRunTomcat(true);
  setHeadless(true);
  if (System.getProperty(PROP_JUNIT_HYBRID_MODE) != null) {
    runStyle=new RunStyleLocalWeb(this);
  }
}"
82454,"/** 
 * Runs a particular test case.
 */
private void runTestImpl(GWTTestCase testCase,TestResult testResult) throws UnableToCompleteException {
  if (mustNotExecuteTest(testCase)) {
    return;
  }
  if (lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  String moduleName=testCase.getModuleName();
  String syntheticModuleName=testCase.getSyntheticModuleName();
  Strategy strategy=testCase.getStrategy();
  boolean sameTest=(currentModule != null) && syntheticModuleName.equals(currentModule.getName());
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  if (!sameTest) {
    currentModule=compileStrategy.maybeCompileModule(moduleName,syntheticModuleName,strategy,runStyle,batchingStrategy,getTopLogger());
  }
  assert(currentModule != null);
  JUnitFatalLaunchException launchException=checkTestClassInCurrentModule(getTopLogger(),currentModule,moduleName,testCase);
  if (launchException != null) {
    testResult.addError(testCase,launchException);
    return;
  }
  currentTestInfo=new TestInfo(currentModule.getName(),testCase.getClass().getName(),testCase.getName());
  if (messageQueue.hasResults(currentTestInfo)) {
    processTestResult(testCase,testResult,strategy);
    return;
  }
  try {
    if (firstLaunch) {
      runStyle.launchModule(currentModule.getName());
    }
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTime=System.currentTimeMillis();
    testBeginTimeout=testBeginTime + TEST_BEGIN_TIMEOUT_MILLIS;
    testMethodTimeout=0;
    pumpEventLoop();
    if (pendingException != null) {
      UnableToCompleteException e=pendingException;
      pendingException=null;
      throw e;
    }
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  assert(messageQueue.hasResults(currentTestInfo));
  processTestResult(testCase,testResult,testCase.getStrategy());
}","/** 
 * Runs a particular test case.
 */
private void runTestImpl(GWTTestCase testCase,TestResult testResult) throws UnableToCompleteException {
  if (mustNotExecuteTest(getBannedPlatforms(testCase.getClass(),testCase.getName()))) {
    return;
  }
  if (lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  String moduleName=testCase.getModuleName();
  String syntheticModuleName=testCase.getSyntheticModuleName();
  Strategy strategy=testCase.getStrategy();
  boolean sameTest=(currentModule != null) && syntheticModuleName.equals(currentModule.getName());
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  if (!sameTest) {
    currentModule=compileStrategy.maybeCompileModule(moduleName,syntheticModuleName,strategy,runStyle,batchingStrategy,getTopLogger());
  }
  assert(currentModule != null);
  JUnitFatalLaunchException launchException=checkTestClassInCurrentModule(getTopLogger(),currentModule,moduleName,testCase);
  if (launchException != null) {
    testResult.addError(testCase,launchException);
    return;
  }
  currentTestInfo=new TestInfo(currentModule.getName(),testCase.getClass().getName(),testCase.getName());
  if (messageQueue.hasResults(currentTestInfo)) {
    processTestResult(testCase,testResult,strategy);
    return;
  }
  try {
    if (firstLaunch) {
      runStyle.launchModule(currentModule.getName());
    }
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTime=System.currentTimeMillis();
    testBeginTimeout=testBeginTime + TEST_BEGIN_TIMEOUT_MILLIS;
    testMethodTimeout=0;
    pumpEventLoop();
    if (pendingException != null) {
      UnableToCompleteException e=pendingException;
      pendingException=null;
      throw e;
    }
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  assert(messageQueue.hasResults(currentTestInfo));
  processTestResult(testCase,testResult,testCase.getStrategy());
}"
82455,"@Override public void setName(String name){
  super.setName(name);
  if (JUnitShell.mustNotExecuteTest(this)) {
    return;
  }
synchronized (ALL_GWT_TESTS_LOCK) {
    String syntheticModuleName=getSyntheticModuleName();
    TestModuleInfo moduleInfo=ALL_GWT_TESTS.get(syntheticModuleName);
    if (moduleInfo == null) {
      moduleInfo=new TestModuleInfo(getModuleName(),syntheticModuleName,getStrategy());
      ALL_GWT_TESTS.put(syntheticModuleName,moduleInfo);
    }
    moduleInfo.getTests().add(new TestInfo(syntheticModuleName,getClass().getName(),getName()));
  }
}","@Override public void setName(String name){
  super.setName(name);
synchronized (ALL_GWT_TESTS_LOCK) {
    String syntheticModuleName=getSyntheticModuleName();
    TestModuleInfo moduleInfo=ALL_GWT_TESTS.get(syntheticModuleName);
    if (moduleInfo == null) {
      moduleInfo=new TestModuleInfo(getModuleName(),syntheticModuleName,getStrategy());
      ALL_GWT_TESTS.put(syntheticModuleName,moduleInfo);
    }
    moduleInfo.getTests().add(new TestInfo(syntheticModuleName,getClass().getName(),getName()));
  }
}"
82456,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(FakeMessagesMakerTest.class);
  suite.addTestSuite(BatchingStrategyTest.class);
  suite.addTestSuite(JUnitMessageQueueTest.class);
  suite.addTestSuite(GWTTestCaseNoClientTest.class);
  suite.addTestSuite(BenchmarkNoClientTest.class);
  suite.addTestSuite(GWTTestCaseTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(GWTTestCaseTest.class);
  suite.addTestSuite(BatchingStrategyTest.class);
  suite.addTestSuite(FakeMessagesMakerTest.class);
  suite.addTestSuite(JUnitMessageQueueTest.class);
  suite.addTestSuite(GWTTestCaseNoClientTest.class);
  suite.addTestSuite(BenchmarkNoClientTest.class);
  return suite;
}"
82457,"public void onModuleLoad(){
  SplitLayoutPanel p=new SplitLayoutPanel();
  p.add(new HTML(""String_Node_Str""),Direction.WEST,128);
  p.add(new HTML(""String_Node_Str""),Direction.NORTH,384);
  p.add(new HTML(""String_Node_Str""),Direction.CENTER,0);
  p.layout();
  RootLayoutPanel rp=RootLayoutPanel.get();
  rp.add(p);
  rp.layout();
}","public void onModuleLoad(){
  SplitLayoutPanel p=new SplitLayoutPanel();
  p.addWest(new HTML(""String_Node_Str""),128);
  p.addNorth(new HTML(""String_Node_Str""),384);
  p.add(new HTML(""String_Node_Str""));
  p.layout();
  RootLayoutPanel rp=RootLayoutPanel.get();
  rp.add(p);
  rp.layout();
}"
82458,"/** 
 * Gets the container element associated with the given child widget. <p> The container element is created by the   {@link Layout} class. This shouldbe used with certain styles, such as  {@link Style#setZIndex(int)}, that must be applied to the container, rather than directly to the child widget. </p> TODO(jgw): Is this really the best way to do this?
 * @param widget the widget whose container element is to be retrieved
 * @return the widget's container element
 */
public Element getContainerElementFor(Widget widget){
  assertIsChild(widget);
  return ((LayoutData)widget.getLayoutData()).layer.getContainerElement();
}","/** 
 * Gets the container element associated with the given child widget. <p> The container element is created by the   {@link Layout} class. This shouldbe used with certain styles, such as {@link com.google.gwt.dom.client.Style#setZIndex(int)}, that must be applied to the container, rather than directly to the child widget. </p> TODO(jgw): Is this really the best way to do this?
 * @param widget the widget whose container element is to be retrieved
 * @return the widget's container element
 */
public Element getContainerElementFor(Widget widget){
  assertIsChild(widget);
  return ((LayoutData)widget.getLayoutData()).layer.getContainerElement();
}"
82459,"public void makeBreakdownShell(SizeBreakdown breakdown,String permutationId) throws IOException {
  Map<String,CodeCollection> nameToCodeColl=breakdown.nameToCodeColl;
  Map<String,LiteralsCollection> nameToLitColl=breakdown.nameToLitColl;
  String classPath=settings.resources.get();
  if (classPath == null) {
    classPath=System.getProperty(""String_Node_Str"");
  }
  if (!classPath.endsWith(""String_Node_Str"")) {
    classPath+=""String_Node_Str"";
  }
  String inputFileName=""String_Node_Str"";
  File inputFile=new File(classPath + RESOURCES_PATH + inputFileName);
  File outputFile=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile,outputFile,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputFile2=new File(classPath + RESOURCES_PATH + inputFileName);
  File outputFile2=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile2,outputFile2,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputFile3=new File(classPath + RESOURCES_PATH + inputFileName);
  File outputFile3=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile3,outputFile3,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputDir=new File(classPath + RESOURCES_PATH + ""String_Node_Str"");
  File outputDir=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputDir,outputDir,classPath,inputFileName,true);
  final PrintWriter outFile=new PrintWriter(getOutFile(shellFileName(breakdown,permutationId)));
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  addHeaderWithBreakdownContext(breakdown,outFile);
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  String packageBreakdownFileName=makePackageHtml(breakdown,permutationId);
  outFile.println(""String_Node_Str"" + packageBreakdownFileName + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  String codeTypeBreakdownFileName=makeCodeTypeHtml(breakdown,nameToCodeColl,nameToLitColl,permutationId);
  outFile.println(""String_Node_Str"" + codeTypeBreakdownFileName + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.close();
}","public void makeBreakdownShell(SizeBreakdown breakdown,String permutationId) throws IOException {
  Map<String,CodeCollection> nameToCodeColl=breakdown.nameToCodeColl;
  Map<String,LiteralsCollection> nameToLitColl=breakdown.nameToLitColl;
  String classPath=settings.resources.get();
  if (classPath == null) {
    classPath=System.getProperty(""String_Node_Str"");
  }
  if (!classPath.endsWith(""String_Node_Str"")) {
    classPath+=""String_Node_Str"";
  }
  String inputFileName=""String_Node_Str"";
  File inputFile=new File(classPath + RESOURCES_PATH + inputFileName);
  if (!inputFile.exists()) {
    inputFile=new File(classPath + inputFileName);
  }
  File outputFile=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile,outputFile,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputFile2=new File(classPath + RESOURCES_PATH + inputFileName);
  if (!inputFile2.exists()) {
    inputFile2=new File(classPath + inputFileName);
  }
  File outputFile2=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile2,outputFile2,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputFile3=new File(classPath + RESOURCES_PATH + inputFileName);
  if (!inputFile3.exists()) {
    inputFile3=new File(classPath + inputFileName);
  }
  File outputFile3=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile3,outputFile3,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputDir=new File(classPath + RESOURCES_PATH + ""String_Node_Str"");
  if (!inputDir.exists()) {
    inputDir=new File(classPath + ""String_Node_Str"");
  }
  File outputDir=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputDir,outputDir,classPath,inputFileName,true);
  final PrintWriter outFile=new PrintWriter(getOutFile(shellFileName(breakdown,permutationId)));
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  addHeaderWithBreakdownContext(breakdown,outFile);
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  String packageBreakdownFileName=makePackageHtml(breakdown,permutationId);
  outFile.println(""String_Node_Str"" + packageBreakdownFileName + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  String codeTypeBreakdownFileName=makeCodeTypeHtml(breakdown,nameToCodeColl,nameToLitColl,permutationId);
  outFile.println(""String_Node_Str"" + codeTypeBreakdownFileName + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.close();
}"
82460,"/** 
 * Interprets <ui:with> elements.
 */
private void createResource(XMLElement elem) throws UnableToCompleteException {
  String resourceName=elem.consumeRequiredAttribute(""String_Node_Str"");
  JClassType resourceType=consumeTypeAttribute(elem);
  if (elem.getAttributeCount() > 0) {
    writer.die(""String_Node_Str"");
  }
  FieldWriter fieldWriter=fieldManager.registerField(resourceType,resourceName);
  OwnerField ownerField=writer.getOwnerClass().getUiField(resourceName);
  if (ownerField != null) {
    if (!resourceType.equals(ownerField.getType().getRawType())) {
      writer.die(""String_Node_Str"",ownerField);
    }
    if (ownerField.isProvided()) {
      fieldWriter.setInitializer(""String_Node_Str"" + ownerField.getName());
      return;
    }
  }
  JMethod factoryMethod=writer.getOwnerClass().getUiFactoryMethod(resourceType);
  if (factoryMethod != null) {
    fieldWriter.setInitializer(String.format(""String_Node_Str"",factoryMethod.getName()));
  }
}","/** 
 * Interprets <ui:with> elements.
 */
private void createResource(XMLElement elem) throws UnableToCompleteException {
  String resourceName=elem.consumeRequiredAttribute(""String_Node_Str"");
  JClassType resourceType=consumeTypeAttribute(elem);
  if (elem.getAttributeCount() > 0) {
    writer.die(""String_Node_Str"",elem);
  }
  FieldWriter fieldWriter=fieldManager.registerField(resourceType,resourceName);
  OwnerField ownerField=writer.getOwnerClass().getUiField(resourceName);
  if (ownerField != null) {
    if (!resourceType.equals(ownerField.getType().getRawType())) {
      writer.die(""String_Node_Str"",elem,ownerField);
    }
    if (ownerField.isProvided()) {
      fieldWriter.setInitializer(""String_Node_Str"" + ownerField.getName());
      return;
    }
  }
  JMethod factoryMethod=writer.getOwnerClass().getUiFactoryMethod(resourceType);
  if (factoryMethod != null) {
    fieldWriter.setInitializer(String.format(""String_Node_Str"",factoryMethod.getName()));
  }
}"
82461,"@Override public String getTagName(Element elem){
  String tagName=getTagNameInternal(elem);
  String scopeName=getScopeNameInternal(elem);
  if (""String_Node_Str"".equalsIgnoreCase(scopeName) || ""String_Node_Str"".equalsIgnoreCase(scopeName)) {
    return tagName;
  }
  return scopeName + ""String_Node_Str"" + tagName;
}","@Override public String getTagName(Element elem){
  String tagName=getTagNameInternal(elem);
  String scopeName=getScopeNameInternal(elem);
  if ((scopeName == null) || ""String_Node_Str"".equalsIgnoreCase(scopeName)) {
    return tagName;
  }
  return scopeName + ""String_Node_Str"" + tagName;
}"
82462,"public void testExpires(){
  Date expiresEarly=new Date(new Date().getTime() + (5 * 1000));
  Date expiresLate=new Date(new Date().getTime() + (60 * 1000));
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",expiresEarly);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",expiresLate);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null);
  Timer timer=new Timer(){
    public void run(){
      assertNull(Cookies.getCookie(""String_Node_Str""));
      assertEquals(Cookies.getCookie(""String_Node_Str""),""String_Node_Str"");
      assertEquals(Cookies.getCookie(""String_Node_Str""),""String_Node_Str"");
      Cookies.removeCookie(""String_Node_Str"");
      assertNull(Cookies.getCookie(""String_Node_Str""));
      finishTest();
    }
  }
;
  timer.schedule(5010);
  delayTestFinish(6 * 1000);
}","public void testExpires(){
  int uniqueId=Random.nextInt(9000000) + 1000000;
  final String earlyCookie=""String_Node_Str"" + uniqueId;
  final String lateCookie=""String_Node_Str"" + uniqueId;
  final String sessionCookie=""String_Node_Str"" + uniqueId;
  Date expiresEarly=new Date(new Date().getTime() + (5 * 1000));
  Date expiresLate=new Date(new Date().getTime() + (60 * 1000));
  Cookies.setCookie(earlyCookie,""String_Node_Str"",expiresEarly);
  Cookies.setCookie(lateCookie,""String_Node_Str"",expiresLate);
  Cookies.setCookie(sessionCookie,""String_Node_Str"",null);
  Timer timer=new Timer(){
    @Override public void run(){
      assertNull(Cookies.getCookie(earlyCookie));
      assertEquals(Cookies.getCookie(lateCookie),""String_Node_Str"");
      assertEquals(Cookies.getCookie(sessionCookie),""String_Node_Str"");
      Cookies.removeCookie(sessionCookie);
      assertNull(Cookies.getCookie(sessionCookie));
      finishTest();
    }
  }
;
  timer.schedule(5010);
  delayTestFinish(6 * 1000);
}"
82463,"/** 
 * Clear out all existing cookies.
 */
private void clearCookies(){
  Collection<String> cookies=Cookies.getCookieNames();
  for (  String cookie : cookies) {
    Cookies.removeCookie(cookie);
  }
}","/** 
 * Clear out all existing cookies, except the ones used in  {@link #testExpires()}.
 */
private void clearCookies(){
  Collection<String> cookies=Cookies.getCookieNames();
  for (  String cookie : cookies) {
    if (!cookie.startsWith(""String_Node_Str"")) {
      Cookies.removeCookie(cookie);
    }
  }
}"
82464,"/** 
 * Test that removing cookies with a path works correctly. Note that we do not verify failure to remove a cookie set with a path but removed without one as browser behavior differs.
 */
public void testRemoveCookiePath(){
  clearCookies();
  Cookies.setUriEncode(false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Collection<String> cookies=Cookies.getCookieNames();
  assertEquals(3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
  clearCookies();
  Cookies.setUriEncode(true);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  cookies=Cookies.getCookieNames();
  assertEquals(3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
}","/** 
 * Test that removing cookies with a path works correctly. Note that we do not verify failure to remove a cookie set with a path but removed without one as browser behavior differs.
 */
public void testRemoveCookiePath(){
  clearCookies();
  Cookies.setUriEncode(false);
  int curCount=Cookies.getCookieNames().size();
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Collection<String> cookies=Cookies.getCookieNames();
  assertEquals(curCount + 3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
  clearCookies();
  Cookies.setUriEncode(true);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  cookies=Cookies.getCookieNames();
  assertEquals(curCount + 3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
}"
82465,"public void run(){
  assertNull(Cookies.getCookie(""String_Node_Str""));
  assertEquals(Cookies.getCookie(""String_Node_Str""),""String_Node_Str"");
  assertEquals(Cookies.getCookie(""String_Node_Str""),""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  assertNull(Cookies.getCookie(""String_Node_Str""));
  finishTest();
}","@Override public void run(){
  assertNull(Cookies.getCookie(earlyCookie));
  assertEquals(Cookies.getCookie(lateCookie),""String_Node_Str"");
  assertEquals(Cookies.getCookie(sessionCookie),""String_Node_Str"");
  Cookies.removeCookie(sessionCookie);
  assertNull(Cookies.getCookie(sessionCookie));
  finishTest();
}"
82466,"/** 
 * Test that removing cookies works correctly.
 */
public void testRemoveCookie(){
  clearCookies();
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Collection<String> cookies=Cookies.getCookieNames();
  assertEquals(3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
  Cookies.setUriEncode(false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}","/** 
 * Test that removing cookies works correctly.
 */
public void testRemoveCookie(){
  clearCookies();
  int curCount=Cookies.getCookieNames().size();
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Collection<String> cookies=Cookies.getCookieNames();
  assertEquals(curCount + 3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
  Cookies.setUriEncode(false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}"
82467,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}"
82468,"/** 
 * Create a method call whose type is overridden to the specified type, ignoring the return type of the target method. This constructor is used during normalizing transformations to preserve type semantics when calling externally-defined compiler implementation methods. For example, Cast.dynamicCast() returns Object but that method is used to implement the cast operation. Using a stronger type on the call expression allows us to preserve type information during the latter phases of compilation.
 */
public JMethodCall(SourceInfo info,JExpression instance,JMethod method,JType overrideReturnType){
  super(info);
  this.instance=instance;
  this.method=method;
  assert(overrideReturnType != null);
  this.overrideReturnType=overrideReturnType;
}","/** 
 * Create a method call whose type is overridden to the specified type, ignoring the return type of the target method. This constructor is used during normalizing transformations to preserve type semantics when calling externally-defined compiler implementation methods. For example, Cast.dynamicCast() returns Object but that method is used to implement the cast operation. Using a stronger type on the call expression allows us to preserve type information during the latter phases of compilation.
 */
public JMethodCall(SourceInfo info,JExpression instance,JMethod method,JType overrideReturnType){
  super(info);
  assert(method != null);
  assert(instance != null || method.isStatic());
  this.instance=instance;
  this.method=method;
  assert(overrideReturnType != null);
  this.overrideReturnType=overrideReturnType;
}"
82469,"/** 
 * Adds a widget to the panel at the specified position. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the widget to be added
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void add(Widget w,int left,int top){
  w.removeFromParent();
  setWidgetPositionImpl(w,left,top);
  add(w);
}","/** 
 * Adds a widget to the panel at the specified position. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the widget to be added
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void add(Widget w,int left,int top){
  w.removeFromParent();
  int beforeIndex=getWidgetCount();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
}"
82470,"/** 
 * Adds the specified widget to the deck.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element container=createWidgetContainer();
  DOM.appendChild(getElement(),container);
  super.add(w,container);
  finishWidgetInitialization(container,w);
}","@Override public void add(Widget w){
  Element container=createWidgetContainer();
  DOM.appendChild(getElement(),container);
  super.add(w,container);
  finishWidgetInitialization(container,w);
}"
82471,"/** 
 * Inserts a widget before the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  Element container=createWidgetContainer();
  DOM.insertChild(getElement(),container,beforeIndex);
  insert(w,container,beforeIndex,true);
  finishWidgetInitialization(container,w);
}","public void insert(Widget w,int beforeIndex){
  Element container=createWidgetContainer();
  DOM.insertChild(getElement(),container,beforeIndex);
  insert(w,container,beforeIndex,true);
  finishWidgetInitialization(container,w);
}"
82472,"/** 
 * Adds a child widget to the panel. If the Widget is already attached to the HorizontalPanel, it will be moved to the end of the panel.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element td=createAlignedTd();
  DOM.appendChild(tableRow,td);
  add(w,td);
}","@Override public void add(Widget w){
  Element td=createAlignedTd();
  DOM.appendChild(tableRow,td);
  add(w,td);
}"
82473,"/** 
 * Inserts a widget before the specified index. If the Widget is already attached to the HorizontalPanel, it will be moved to the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  checkIndexBoundsForInsertion(beforeIndex);
  Element td=createAlignedTd();
  DOM.insertChild(tableRow,td,beforeIndex);
  insert(w,td,beforeIndex,false);
}","public void insert(Widget w,int beforeIndex){
  checkIndexBoundsForInsertion(beforeIndex);
  Element td=createAlignedTd();
  DOM.insertChild(tableRow,td,beforeIndex);
  insert(w,td,beforeIndex,false);
}"
82474,"/** 
 * Inserts a widget before the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  Element trh=DOM.createTR();
  Element tdh=DOM.createTD();
  DOM.appendChild(trh,tdh);
  DOM.appendChild(tdh,createHeaderElem());
  Element trb=DOM.createTR();
  Element tdb=DOM.createTD();
  DOM.appendChild(trb,tdb);
  beforeIndex=adjustIndex(w,beforeIndex);
  int effectiveIndex=beforeIndex * 2;
  DOM.insertChild(body,trb,effectiveIndex);
  DOM.insertChild(body,trh,effectiveIndex);
  setStyleName(tdh,DEFAULT_ITEM_STYLENAME,true);
  DOM.setElementPropertyInt(tdh,""String_Node_Str"",hashCode());
  DOM.setElementProperty(tdh,""String_Node_Str"",""String_Node_Str"");
  setStyleName(tdb,DEFAULT_STYLENAME + ""String_Node_Str"",true);
  DOM.setElementProperty(tdb,""String_Node_Str"",""String_Node_Str"");
  DOM.setElementProperty(tdb,""String_Node_Str"",""String_Node_Str"");
  insert(w,tdb,beforeIndex,false);
  updateIndicesFrom(beforeIndex);
  if (visibleStack == -1) {
    showStack(0);
  }
 else {
    setStackVisible(beforeIndex,false);
    if (visibleStack >= beforeIndex) {
      ++visibleStack;
    }
    setStackVisible(visibleStack,true);
  }
}","public void insert(Widget w,int beforeIndex){
  Element trh=DOM.createTR();
  Element tdh=DOM.createTD();
  DOM.appendChild(trh,tdh);
  DOM.appendChild(tdh,createHeaderElem());
  Element trb=DOM.createTR();
  Element tdb=DOM.createTD();
  DOM.appendChild(trb,tdb);
  beforeIndex=adjustIndex(w,beforeIndex);
  int effectiveIndex=beforeIndex * 2;
  DOM.insertChild(body,trb,effectiveIndex);
  DOM.insertChild(body,trh,effectiveIndex);
  setStyleName(tdh,DEFAULT_ITEM_STYLENAME,true);
  DOM.setElementPropertyInt(tdh,""String_Node_Str"",hashCode());
  DOM.setElementProperty(tdh,""String_Node_Str"",""String_Node_Str"");
  setStyleName(tdb,DEFAULT_STYLENAME + ""String_Node_Str"",true);
  DOM.setElementProperty(tdb,""String_Node_Str"",""String_Node_Str"");
  DOM.setElementProperty(tdb,""String_Node_Str"",""String_Node_Str"");
  insert(w,tdb,beforeIndex,false);
  updateIndicesFrom(beforeIndex);
  if (visibleStack == -1) {
    showStack(0);
  }
 else {
    setStackVisible(beforeIndex,false);
    if (visibleStack >= beforeIndex) {
      ++visibleStack;
    }
    setStackVisible(visibleStack,true);
  }
}"
82475,"/** 
 * Adds a child widget to the panel. If the Widget is already attached to the VerticalPanel, it will be moved to the end of the panel.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element tr=DOM.createTR();
  Element td=createAlignedTd();
  DOM.appendChild(tr,td);
  DOM.appendChild(getBody(),tr);
  add(w,td);
}","@Override public void add(Widget w){
  Element tr=DOM.createTR();
  Element td=createAlignedTd();
  DOM.appendChild(tr,td);
  DOM.appendChild(getBody(),tr);
  add(w,td);
}"
82476,"/** 
 * Inserts a widget before the specified index. If the Widget is already attached to the VerticalPanel, it will be moved to the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  checkIndexBoundsForInsertion(beforeIndex);
  Element tr=DOM.createTR();
  Element td=createAlignedTd();
  DOM.appendChild(tr,td);
  DOM.insertChild(getBody(),tr,beforeIndex);
  insert(w,td,beforeIndex,false);
}","public void insert(Widget w,int beforeIndex){
  checkIndexBoundsForInsertion(beforeIndex);
  Element tr=DOM.createTR();
  Element td=createAlignedTd();
  DOM.appendChild(tr,td);
  DOM.insertChild(getBody(),tr,beforeIndex);
  insert(w,td,beforeIndex,false);
}"
82477,"public void addBugs(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2318());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new Issue2855());
  addIssue(new Issue3172());
}","public void addBugs(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2318());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new Issue2855());
  addIssue(new Issue3172());
  addIssue(new Issue3973());
}"
82478,"@Override protected void onDetach(){
  super.onDetach();
  if (synthesizedFrame != null) {
    impl.unhookEvents(synthesizedFrame,getElement());
    Document.get().getBody().removeChild(synthesizedFrame);
    synthesizedFrame=null;
  }
}","@Override protected void onDetach(){
  super.onDetach();
  impl.unhookEvents(synthesizedFrame,getElement());
  if (synthesizedFrame != null) {
    Document.get().getBody().removeChild(synthesizedFrame);
    synthesizedFrame=null;
  }
}"
82479,"@Override protected void onAttach(){
  super.onAttach();
  if (frameName != null) {
    createFrame();
    Document.get().getBody().appendChild(synthesizedFrame);
    impl.hookEvents(synthesizedFrame,getElement(),this);
  }
}","@Override protected void onAttach(){
  super.onAttach();
  if (frameName != null) {
    createFrame();
    Document.get().getBody().appendChild(synthesizedFrame);
  }
  impl.hookEvents(synthesizedFrame,getElement(),this);
}"
82480,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(AsyncProxyTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(CalendarUtilTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FileUploadTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(TreeItemTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  suite.addTestSuite(RootPanelTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(AsyncProxyTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(CalendarUtilTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FileUploadTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(FormPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(TreeItemTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  suite.addTestSuite(RootPanelTest.class);
  return suite;
}"
82481,"private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
}","private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
}"
82482,"public void execute(){
  unregisterCallbacks(CALLBACKS);
  Node script=Document.get().getElementById(callbackId);
  getDocumentElement().getFirstChild().removeChild(script);
}","public void execute(){
  unregisterCallbacks(CALLBACKS);
  Node script=Document.get().getElementById(callbackId);
  getHeadElement().removeChild(script);
}"
82483,"/** 
 * Cleans everything once the response has been received: deletes the script tag and unregisters the callback.
 */
private void unload(){
  DeferredCommand.addCommand(new Command(){
    public void execute(){
      unregisterCallbacks(CALLBACKS);
      Node script=Document.get().getElementById(callbackId);
      getDocumentElement().getFirstChild().removeChild(script);
    }
  }
);
}","/** 
 * Cleans everything once the response has been received: deletes the script tag and unregisters the callback.
 */
private void unload(){
  DeferredCommand.addCommand(new Command(){
    public void execute(){
      unregisterCallbacks(CALLBACKS);
      Node script=Document.get().getElementById(callbackId);
      getHeadElement().removeChild(script);
    }
  }
);
}"
82484,"/** 
 * Sends a request using the JSONP mechanism.
 * @param baseUri To be sent to the server.
 */
void send(final String baseUri){
  registerCallbacks(CALLBACKS);
  StringBuffer uri=new StringBuffer(baseUri);
  uri.append(baseUri.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  String prefix=CALLBACKS_NAME + ""String_Node_Str"" + callbackId;
  uri.append(callbackParam).append(""String_Node_Str"").append(prefix).append(""String_Node_Str"");
  if (failureCallbackParam != null) {
    uri.append(""String_Node_Str"");
    uri.append(failureCallbackParam).append(""String_Node_Str"").append(prefix).append(""String_Node_Str"");
  }
  ScriptElement script=Document.get().createScriptElement();
  script.setType(""String_Node_Str"");
  script.setId(callbackId);
  script.setSrc(uri.toString());
  getDocumentElement().getFirstChild().appendChild(script);
  timer=new Timer(){
    @Override public void run(){
      onFailure(new TimeoutException(""String_Node_Str"" + baseUri));
    }
  }
;
  timer.schedule(timeout);
}","/** 
 * Sends a request using the JSONP mechanism.
 * @param baseUri To be sent to the server.
 */
void send(final String baseUri){
  registerCallbacks(CALLBACKS);
  StringBuffer uri=new StringBuffer(baseUri);
  uri.append(baseUri.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  String prefix=CALLBACKS_NAME + ""String_Node_Str"" + callbackId;
  uri.append(callbackParam).append(""String_Node_Str"").append(prefix).append(""String_Node_Str"");
  if (failureCallbackParam != null) {
    uri.append(""String_Node_Str"");
    uri.append(failureCallbackParam).append(""String_Node_Str"").append(prefix).append(""String_Node_Str"");
  }
  ScriptElement script=Document.get().createScriptElement();
  script.setType(""String_Node_Str"");
  script.setId(callbackId);
  script.setSrc(uri.toString());
  getHeadElement().appendChild(script);
  timer=new Timer(){
    @Override public void run(){
      onFailure(new TimeoutException(""String_Node_Str"" + baseUri));
    }
  }
;
  timer.schedule(timeout);
}"
82485,"/** 
 * Run the specified callback once the necessary code for it has been loaded.
 */
public static void runAsync(RunAsyncCallback callback){
  UncaughtExceptionHandler handler=sUncaughtExceptionHandler;
  if (handler == null) {
    callback.onSuccess();
  }
 else {
    try {
      callback.onSuccess();
    }
 catch (    Throwable e) {
      handler.onUncaughtException(e);
    }
  }
}","/** 
 * Run the specified callback once the necessary code for it has been loaded.
 */
public static void runAsync(RunAsyncCallback callback){
  if (isScript()) {
    AsyncFragmentLoader.BROWSER_LOADER.logEventProgress(""String_Node_Str"",""String_Node_Str"");
    AsyncFragmentLoader.BROWSER_LOADER.logEventProgress(""String_Node_Str"",""String_Node_Str"");
  }
  UncaughtExceptionHandler handler=sUncaughtExceptionHandler;
  if (handler == null) {
    callback.onSuccess();
  }
 else {
    try {
      callback.onSuccess();
    }
 catch (    Throwable e) {
      handler.onUncaughtException(e);
    }
  }
}"
82486,"private static String downloadGroup(int splitPoint){
  return ""String_Node_Str"" + splitPoint;
}","private String downloadGroup(int fragment){
  return (fragment == leftoversFragment()) ? LwmLabels.LEFTOVERS_DOWNLOAD : LwmLabels.downloadGroupForExclusive(fragment);
}"
82487,"private void logFragmentLoaded(int fragment){
  String logGroup=(fragment == leftoversFragment()) ? LwmLabels.LEFTOVERS_DOWNLOAD : LwmLabels.downloadGroup(fragment);
  logEventProgress(logGroup,LwmLabels.END,fragment,null);
}","private void logFragmentLoaded(int fragment){
  String logGroup=downloadGroup(fragment);
  logEventProgress(logGroup,LwmLabels.END,fragment,null);
}"
82488,"/** 
 * Start downloading the next fragment in the initial sequence, if there are any left.
 */
private void startLoadingNextInitial(){
  if (remainingInitialFragments == null) {
    remainingInitialFragments=new BoundedIntQueue(initialLoadSequence.length + 1);
    for (    int sp : initialLoadSequence) {
      remainingInitialFragments.add(sp);
    }
    remainingInitialFragments.add(leftoversFragment());
  }
  if (initialFragmentErrorHandlers.isEmpty() && waitingForInitialFragmentsErrorHandlers.isEmpty() && remainingInitialFragments.size() > 1) {
    initialFragmentsLoading=false;
    return;
  }
  if (remainingInitialFragments.size() > 0) {
    initialFragmentsLoading=true;
    int nextSplitPoint=remainingInitialFragments.peek();
    logEventProgress(LwmLabels.downloadGroup(nextSplitPoint),LwmLabels.BEGIN,nextSplitPoint,null);
    startLoadingFragment(nextSplitPoint,new InitialFragmentDownloadFailed());
    return;
  }
  initialFragmentsLoading=false;
  assert(haveInitialFragmentsLoaded());
  assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
  while (waitingForInitialFragments.size() > 0) {
    startLoadingFragment(waitingForInitialFragments.remove(),waitingForInitialFragmentsErrorHandlers.remove());
  }
}","/** 
 * Start downloading the next fragment in the initial sequence, if there are any left.
 */
private void startLoadingNextInitial(){
  if (remainingInitialFragments == null) {
    remainingInitialFragments=new BoundedIntQueue(initialLoadSequence.length + 1);
    for (    int sp : initialLoadSequence) {
      remainingInitialFragments.add(sp);
    }
    remainingInitialFragments.add(leftoversFragment());
  }
  if (initialFragmentErrorHandlers.isEmpty() && waitingForInitialFragmentsErrorHandlers.isEmpty() && remainingInitialFragments.size() > 1) {
    initialFragmentsLoading=false;
    return;
  }
  if (remainingInitialFragments.size() > 0) {
    initialFragmentsLoading=true;
    int nextSplitPoint=remainingInitialFragments.peek();
    logDownloadStart(nextSplitPoint);
    startLoadingFragment(nextSplitPoint,new InitialFragmentDownloadFailed());
    return;
  }
  initialFragmentsLoading=false;
  assert(haveInitialFragmentsLoaded());
  assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
  while (waitingForInitialFragments.size() > 0) {
    int nextSplitPoint=waitingForInitialFragments.remove();
    LoadErrorHandler handler=waitingForInitialFragmentsErrorHandlers.remove();
    logDownloadStart(nextSplitPoint);
    startLoadingFragment(nextSplitPoint,handler);
  }
}"
82489,"/** 
 * Loads the specified split point.
 * @param splitPoint the split point whose code needs to be loaded
 */
public void inject(int splitPoint,LoadErrorHandler loadErrorHandler){
  if (haveInitialFragmentsLoaded()) {
    logEventProgress(LwmLabels.downloadGroup(splitPoint),LwmLabels.BEGIN,splitPoint,null);
    startLoadingFragment(splitPoint,loadErrorHandler);
    return;
  }
  if (isInitial(splitPoint)) {
    initialFragmentErrorHandlers.put(splitPoint,loadErrorHandler);
  }
 else {
    assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
    waitingForInitialFragments.add(splitPoint);
    waitingForInitialFragmentsErrorHandlers.add(loadErrorHandler);
  }
  if (!initialFragmentsLoading) {
    startLoadingNextInitial();
  }
}","/** 
 * Loads the specified split point.
 * @param splitPoint the split point whose code needs to be loaded
 */
public void inject(int splitPoint,LoadErrorHandler loadErrorHandler){
  if (haveInitialFragmentsLoaded()) {
    logDownloadStart(splitPoint);
    startLoadingFragment(splitPoint,loadErrorHandler);
    return;
  }
  if (isInitial(splitPoint)) {
    initialFragmentErrorHandlers.put(splitPoint,loadErrorHandler);
  }
 else {
    assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
    waitingForInitialFragments.add(splitPoint);
    waitingForInitialFragmentsErrorHandlers.add(loadErrorHandler);
  }
  if (!initialFragmentsLoading) {
    startLoadingNextInitial();
  }
}"
82490,"public void addBugs(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2318());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new Issue2855());
  addIssue(new Issue3172());
  addIssue(new Issue3973());
}","public void addBugs(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2318());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new Issue2855());
  addIssue(new Issue3172());
  addIssue(new Issue3962());
  addIssue(new Issue3973());
}"
82491,"/** 
 * IE returns a numeric type for some attributes that are really properties, such as offsetWidth.  We need to coerce these to strings to prevent a runtime JS exception.
 */
@Override public native String getAttribute(Element elem,String name);","/** 
 * IE returns a numeric type for some attributes that are really properties, such as offsetWidth. We need to coerce these to strings to prevent a runtime JS exception.
 */
@Override public native String getAttribute(Element elem,String name);"
82492,"public String getTagName(Element elem){
  String tagName=getTagNameInternal(elem);
  String scopeName=getScopeNameInternal(elem);
  if (""String_Node_Str"".equalsIgnoreCase(scopeName) || ""String_Node_Str"".equalsIgnoreCase(scopeName)) {
    return tagName;
  }
  return scopeName + ""String_Node_Str"" + tagName;
}","@Override public String getTagName(Element elem){
  String tagName=getTagNameInternal(elem);
  String scopeName=getScopeNameInternal(elem);
  if (""String_Node_Str"".equalsIgnoreCase(scopeName) || ""String_Node_Str"".equalsIgnoreCase(scopeName)) {
    return tagName;
  }
  return scopeName + ""String_Node_Str"" + tagName;
}"
82493,"private JsExpression mapUnaryVariant(Node unOp) throws JsParserException {
switch (unOp.getIntDatum()) {
case TokenStream.SUB:
    return mapPrefixOperation(JsUnaryOperator.NEG,unOp);
case TokenStream.NOT:
  return mapPrefixOperation(JsUnaryOperator.NOT,unOp);
case TokenStream.BITNOT:
return mapPrefixOperation(JsUnaryOperator.BIT_NOT,unOp);
case TokenStream.TYPEOF:
return mapPrefixOperation(JsUnaryOperator.TYPEOF,unOp);
case TokenStream.ADD:
return mapExpression(unOp.getFirstChild());
case TokenStream.VOID:
return mapPrefixOperation(JsUnaryOperator.VOID,unOp);
default :
throw new JsParserException(""String_Node_Str"" + unOp.getIntDatum());
}
}","private JsExpression mapUnaryVariant(Node unOp) throws JsParserException {
switch (unOp.getIntDatum()) {
case TokenStream.SUB:
    return mapPrefixOperation(JsUnaryOperator.NEG,unOp);
case TokenStream.NOT:
  return mapPrefixOperation(JsUnaryOperator.NOT,unOp);
case TokenStream.BITNOT:
return mapPrefixOperation(JsUnaryOperator.BIT_NOT,unOp);
case TokenStream.TYPEOF:
return mapPrefixOperation(JsUnaryOperator.TYPEOF,unOp);
case TokenStream.ADD:
if (unOp.getFirstChild().getType() != TokenStream.NUMBER) {
return mapPrefixOperation(JsUnaryOperator.POS,unOp);
}
 else {
return mapExpression(unOp.getFirstChild());
}
case TokenStream.VOID:
return mapPrefixOperation(JsUnaryOperator.VOID,unOp);
default :
throw new JsParserException(""String_Node_Str"" + unOp.getIntDatum());
}
}"
82494,"/** 
 * Decide whether, if <code>op</code> is printed followed by <code>arg</code>, there needs to be a space between the operator and expression.
 * @return <code>true</code> if a space needs to be printed
 */
private boolean _spaceCalc(JsOperator op,JsExpression arg){
  if (op.isKeyword()) {
    return true;
  }
  if (arg instanceof JsBinaryOperation) {
    JsBinaryOperation binary=(JsBinaryOperation)arg;
    if (binary.getOperator().getPrecedence() > op.getPrecedence()) {
      return _spaceCalc(op,binary.getArg1());
    }
    return false;
  }
  if (arg instanceof JsPrefixOperation) {
    JsOperator op2=((JsPrefixOperation)arg).getOperator();
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (op2 == JsUnaryOperator.DEC || op2 == JsUnaryOperator.NEG) || (op == JsBinaryOperator.ADD && op2 == JsUnaryOperator.INC);
  }
  if (arg instanceof JsNumberLiteral) {
    JsNumberLiteral literal=(JsNumberLiteral)arg;
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (literal.getValue() < 0);
  }
  return false;
}","/** 
 * Decide whether, if <code>op</code> is printed followed by <code>arg</code>, there needs to be a space between the operator and expression.
 * @return <code>true</code> if a space needs to be printed
 */
private boolean _spaceCalc(JsOperator op,JsExpression arg){
  if (op.isKeyword()) {
    return true;
  }
  if (arg instanceof JsBinaryOperation) {
    JsBinaryOperation binary=(JsBinaryOperation)arg;
    if (binary.getOperator().getPrecedence() > op.getPrecedence()) {
      return _spaceCalc(op,binary.getArg1());
    }
    return false;
  }
  if (arg instanceof JsPrefixOperation) {
    JsOperator op2=((JsPrefixOperation)arg).getOperator();
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (op2 == JsUnaryOperator.DEC || op2 == JsUnaryOperator.NEG) || (op == JsBinaryOperator.ADD || op == JsUnaryOperator.POS) && (op2 == JsUnaryOperator.INC || op2 == JsUnaryOperator.POS);
  }
  if (arg instanceof JsNumberLiteral) {
    JsNumberLiteral literal=(JsNumberLiteral)arg;
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (literal.getValue() < 0);
  }
  return false;
}"
82495,"public DependencyRecorder(OutputStream out) throws IOException {
  try {
    this.writer=new OutputStreamWriter(new GZIPOutputStream(out),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new InternalCompilerException(""String_Node_Str"",e);
  }
}","public DependencyRecorder(OutputStream out){
  this.finalOutput=out;
}"
82496,"public void open(){
  printPre();
}","public void open(){
  try {
    this.writer=new OutputStreamWriter(new GZIPOutputStream(finalOutput),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new InternalCompilerException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new NestedIOException(e);
  }
  printPre();
}"
82497,"/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a{@link #precompile(TreeLogger,WebModeCompilerFrontEnd,String[],JJSOptions,boolean)}
 * @param rebindAnswers the set of rebind answers to resolve all outstandingrebind decisions
 * @param propertyOracles All property oracles corresponding to thispermutation.
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Map<String,String> rebindAnswers,PropertyOracle[] propertyOracles,int permutationId) throws UnableToCompleteException {
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    JJSOptions options=unifiedAst.getOptions();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,rebindAnswers);
    if (options.isDraftCompile()) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    LongCastNormalizer.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeAfterOptimizations();
    JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable);
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      boolean didChange;
      do {
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
        didChange=false;
        didChange=JsStaticEval.exec(jsProgram) || didChange;
        didChange=JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
    if (jprogram.getDeclaredTypes().contains(jprogram.getFromTypeMap(""String_Node_Str""))) {
      JsStackEmulator.exec(jsProgram,propertyOracles);
    }
    SoycArtifact dependencies=null;
    if (options.isAggressivelyOptimize() && options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      CodeSplitter.exec(logger,jprogram,jsProgram,map,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      if (baos.size() > 0) {
        dependencies=new SoycArtifact(""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
JsIEBlockSizeVisitor.exec(jsProgram);
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=options.isSoycExtra() ? new ArrayList<Map<Range,SourceInfo>>() : null;
generateJavaScriptCode(options,jsProgram,map,js,ranges,sizeBreakdowns,sourceInfoMaps);
PermutationResult toReturn=new PermutationResultImpl(js,makeSymbolMap(symbolTable),ranges,permutationId);
toReturn.getArtifacts().add(makeSoycArtifact(logger,permutationId,jprogram,js,sizeBreakdowns,sourceInfoMaps,dependencies,map,obfuscateMap));
System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
return toReturn;
}
 catch (Throwable e) {
throw logAndTranslateException(logger,e);
}
}","/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a{@link #precompile(TreeLogger,WebModeCompilerFrontEnd,String[],JJSOptions,boolean)}
 * @param rebindAnswers the set of rebind answers to resolve all outstandingrebind decisions
 * @param propertyOracles All property oracles corresponding to thispermutation.
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Map<String,String> rebindAnswers,PropertyOracle[] propertyOracles,int permutationId) throws UnableToCompleteException {
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    JJSOptions options=unifiedAst.getOptions();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,rebindAnswers);
    if (options.isDraftCompile()) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    LongCastNormalizer.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeAfterOptimizations();
    JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable);
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      boolean didChange;
      do {
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
        didChange=false;
        didChange=JsStaticEval.exec(jsProgram) || didChange;
        didChange=JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
    if (jprogram.getDeclaredTypes().contains(jprogram.getFromTypeMap(""String_Node_Str""))) {
      JsStackEmulator.exec(jsProgram,propertyOracles);
    }
    SoycArtifact dependencies=null;
    if (options.isAggressivelyOptimize() && options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      CodeSplitter.exec(logger,jprogram,jsProgram,map,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      if (baos.size() == 0 && options.isSoycEnabled()) {
        recordNonSplitDependencies(jprogram,baos);
      }
      if (baos.size() > 0) {
        dependencies=new SoycArtifact(""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
JsIEBlockSizeVisitor.exec(jsProgram);
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=options.isSoycExtra() ? new ArrayList<Map<Range,SourceInfo>>() : null;
generateJavaScriptCode(options,jsProgram,map,js,ranges,sizeBreakdowns,sourceInfoMaps);
PermutationResult toReturn=new PermutationResultImpl(js,makeSymbolMap(symbolTable),ranges,permutationId);
toReturn.getArtifacts().add(makeSoycArtifact(logger,permutationId,jprogram,js,sizeBreakdowns,sourceInfoMaps,dependencies,map,obfuscateMap));
System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
return toReturn;
}
 catch (Throwable e) {
throw logAndTranslateException(logger,e);
}
}"
82498,"public boolean hasInstantiableSubtypes(){
  return isInstantiable() || instantiableSubtypes;
}","public boolean hasInstantiableSubtypes(){
  return isInstantiable() || instantiableSubtypes || isPendingInstantiable();
}"
82499,"/** 
 * Remove serializable types that were visited due to speculative paths but are not really needed for serialization. NOTE: This is currently much more limited than it should be. For example, a path sensitive prune could remove instantiable types also.
 */
private void pruneUnreachableTypes(){
  Set<JType> supersOfInstantiableTypes=new LinkedHashSet<JType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (tic.isInstantiable()) {
      JClassType type=tic.getType().getErasedType();
      JClassType sup=type;
      while (sup != null) {
        supersOfInstantiableTypes.add(sup.getErasedType());
        sup=sup.getErasedType().getSuperclass();
      }
    }
  }
  Set<JType> toKill=new LinkedHashSet<JType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (tic.isFieldSerializable() && !supersOfInstantiableTypes.contains(tic.getType().getErasedType())) {
      toKill.add(tic.getType());
    }
  }
  for (  JType type : toKill) {
    typeToTypeInfoComputed.remove(type);
  }
}","/** 
 * Remove serializable types that were visited due to speculative paths but are not really needed for serialization. NOTE: This is currently much more limited than it should be. For example, a path sensitive prune could remove instantiable types also.
 */
private void pruneUnreachableTypes(){
  Set<JType> supersOfInstantiableTypes=new LinkedHashSet<JType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (tic.isInstantiable() && tic.getType() instanceof JClassType) {
      JClassType type=(JClassType)tic.getType().getErasedType();
      JClassType sup=type;
      while (sup != null) {
        supersOfInstantiableTypes.add(sup.getErasedType());
        sup=sup.getErasedType().getSuperclass();
      }
    }
  }
  Set<JType> toKill=new LinkedHashSet<JType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (tic.isFieldSerializable() && !supersOfInstantiableTypes.contains(tic.getType().getErasedType())) {
      toKill.add(tic.getType());
    }
  }
  for (  JType type : toKill) {
    typeToTypeInfoComputed.remove(type);
  }
}"
82500,"/** 
 * Consider any subtype of java.lang.Object which qualifies for serialization.
 * @param logger
 */
private void checkAllSubtypesOfObject(TreeLogger logger,TypePath parent,ProblemReport problems){
  if (alreadyCheckedObject) {
    return;
  }
  alreadyCheckedObject=true;
  TreeLogger localLogger=logger.branch(TreeLogger.WARN,""String_Node_Str"",null);
  JClassType[] allTypes=typeOracle.getJavaLangObject().getSubtypes();
  for (  JClassType cls : allTypes) {
    if (isDeclaredSerializable(cls)) {
      checkTypeInstantiable(localLogger,cls,TypePaths.createSubtypePath(parent,cls,typeOracle.getJavaLangObject()),problems);
    }
  }
}","/** 
 * Consider any subtype of java.lang.Object which qualifies for serialization.
 * @param logger
 */
private void checkAllSubtypesOfObject(TreeLogger logger,TypePath parent,ProblemReport problems){
  if (alreadyCheckedObject) {
    return;
  }
  alreadyCheckedObject=true;
  TreeLogger localLogger=logger.branch(TreeLogger.WARN,""String_Node_Str"",null);
  JClassType[] allTypes=typeOracle.getJavaLangObject().getSubtypes();
  for (  JClassType cls : allTypes) {
    if (isDeclaredSerializable(cls)) {
      computeTypeInstantiability(localLogger,cls,TypePaths.createSubtypePath(parent,cls,typeOracle.getJavaLangObject()),problems);
    }
  }
}"
82501,"/** 
 * Check the argument to a parameterized type to see if it will make the type it is applied to be serializable. As a side effect, populates  {@link #typeToTypeInfoComputed} in the same way as{@link #checkTypeInstantiable(TreeLogger,JType,boolean)}.
 * @param logger
 * @param baseType - The generic type the parameter is on
 * @param paramIndex - The index of the parameter in the generic type
 * @param typeArg - An upper bound on the actual argument being applied to thegeneric type
 * @return Whether the a parameterized type can be serializable if<code>baseType</code> is the base type and the <code>paramIndex</code>th type argument is a subtype of <code>typeArg</code>.
 */
private boolean checkTypeArgument(TreeLogger logger,JGenericType baseType,int paramIndex,JClassType typeArg,TypePath parent,ProblemReport problems){
  JWildcardType isWildcard=typeArg.isWildcard();
  if (isWildcard != null) {
    return checkTypeArgument(logger,baseType,paramIndex,isWildcard.getUpperBound(),parent,problems);
  }
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && otherFlowInfo.isTransitivelyAffectedBy(flowInfoForArrayParam)) {
          problems.add(baseType,""String_Node_Str"" + baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ typeArg.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ ""String_Node_Str"",Priority.DEFAULT);
          return false;
        }
      }
    }
  }
  TypePath path=TypePaths.createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case TypeParameterExposureComputer.EXPOSURE_DIRECT:
{
      TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
      return checkTypeInstantiable(branch,typeArg,path,problems) || mightNotBeExposed(baseType,paramIndex);
    }
case TypeParameterExposureComputer.EXPOSURE_NONE:
  logger.log(Type.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
return true;
default :
{
assert(exposure >= TypeParameterExposureComputer.EXPOSURE_MIN_BOUNDED_ARRAY);
problems.add(getArrayType(typeOracle,exposure,typeArg),""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ exposure+ ""String_Node_Str"",Priority.AUXILIARY);
return checkTypeInstantiable(logger,getArrayType(typeOracle,exposure,typeArg),path,problems) || mightNotBeExposed(baseType,paramIndex);
}
}
}","/** 
 * Check the argument to a parameterized type to see if it will make the type it is applied to be serializable. As a side effect, populates  {@link #typeToTypeInfoComputed} in the same way as{@link #checkTypeInstantiable(TreeLogger,JType,boolean)}.
 * @param logger
 * @param baseType - The generic type the parameter is on
 * @param paramIndex - The index of the parameter in the generic type
 * @param typeArg - An upper bound on the actual argument being applied to thegeneric type
 * @return Whether the a parameterized type can be serializable if<code>baseType</code> is the base type and the <code>paramIndex</code>th type argument is a subtype of <code>typeArg</code>.
 */
private boolean checkTypeArgument(TreeLogger logger,JGenericType baseType,int paramIndex,JClassType typeArg,TypePath parent,ProblemReport problems){
  JWildcardType isWildcard=typeArg.isWildcard();
  if (isWildcard != null) {
    return checkTypeArgument(logger,baseType,paramIndex,isWildcard.getUpperBound(),parent,problems);
  }
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && otherFlowInfo.isTransitivelyAffectedBy(flowInfoForArrayParam)) {
          problems.add(baseType,""String_Node_Str"" + baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ typeArg.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ ""String_Node_Str"",Priority.DEFAULT);
          return false;
        }
      }
    }
  }
  TypePath path=TypePaths.createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case TypeParameterExposureComputer.EXPOSURE_DIRECT:
{
      TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
      return computeTypeInstantiability(branch,typeArg,path,problems).hasInstantiableSubtypes() || mightNotBeExposed(baseType,paramIndex);
    }
case TypeParameterExposureComputer.EXPOSURE_NONE:
  logger.log(Type.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
return true;
default :
{
assert(exposure >= TypeParameterExposureComputer.EXPOSURE_MIN_BOUNDED_ARRAY);
problems.add(getArrayType(typeOracle,exposure,typeArg),""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ exposure+ ""String_Node_Str"",Priority.AUXILIARY);
return computeTypeInstantiability(logger,getArrayType(typeOracle,exposure,typeArg),path,problems).hasInstantiableSubtypes() || mightNotBeExposed(baseType,paramIndex);
}
}
}"
82502,"public TypeInfoComputed(JClassType type,TypePath path){
  this.type=type;
  this.path=path;
  autoSerializable=SerializableTypeOracleBuilder.isAutoSerializable(type);
  manualSerializer=findCustomFieldSerializer(typeOracle,type);
  directlyImplementsMarker=directlyImplementsMarkerInterface(type);
  maybeEnhanced=hasJdoAnnotation(type) || hasJpaAnnotation(type);
}","public TypeInfoComputed(JType type,TypePath path){
  this.type=type;
  this.path=path;
  if (type instanceof JClassType) {
    JClassType typeClass=(JClassType)type;
    autoSerializable=SerializableTypeOracleBuilder.isAutoSerializable(typeClass);
    manualSerializer=findCustomFieldSerializer(typeOracle,typeClass);
    directlyImplementsMarker=directlyImplementsMarkerInterface(typeClass);
    maybeEnhanced=hasJdoAnnotation(typeClass) || hasJpaAnnotation(typeClass);
  }
 else {
    autoSerializable=false;
    manualSerializer=null;
    directlyImplementsMarker=false;
    maybeEnhanced=false;
  }
}"
82503,"/** 
 * Returns <code>true</code> if the declared fields of this type are all instantiable. As a side-effect it fills in   {@link TypeInfoComputed} for allnecessary types.
 */
private boolean checkDeclaredFields(TreeLogger logger,TypeInfoComputed typeInfo,TypePath parent,ProblemReport problems){
  JClassType classOrInterface=typeInfo.getType();
  if (classOrInterface.isEnum() != null) {
    return true;
  }
  JClassType baseType=getBaseType(classOrInterface);
  boolean allSucceeded=true;
  JField[] fields=baseType.getFields();
  if (fields.length > 0) {
    TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classOrInterface.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
    for (    JField field : fields) {
      if (!shouldConsiderForSerialization(localLogger,suppressNonStaticFinalFieldWarnings,field)) {
        continue;
      }
      TreeLogger fieldLogger=localLogger.branch(TreeLogger.DEBUG,field.toString(),null);
      JType fieldType=field.getType();
      TypePath path=TypePaths.createFieldPath(parent,field);
      if (typeInfo.isManuallySerializable() && fieldType.getLeafType() == typeOracle.getJavaLangObject()) {
        checkAllSubtypesOfObject(fieldLogger.branch(TreeLogger.WARN,""String_Node_Str"",null),path,problems);
      }
 else {
        allSucceeded&=checkTypeInstantiable(fieldLogger,fieldType,path,problems);
      }
    }
  }
  boolean succeeded=allSucceeded || typeInfo.isManuallySerializable();
  if (succeeded) {
    typeInfo.setFieldSerializable();
  }
  return succeeded;
}","/** 
 * Returns <code>true</code> if the declared fields of this type are all instantiable. As a side-effect it fills in   {@link TypeInfoComputed} for allnecessary types.
 */
private boolean checkDeclaredFields(TreeLogger logger,TypeInfoComputed typeInfo,TypePath parent,ProblemReport problems){
  JClassType classOrInterface=(JClassType)typeInfo.getType();
  if (classOrInterface.isEnum() != null) {
    return true;
  }
  JClassType baseType=getBaseType(classOrInterface);
  boolean allSucceeded=true;
  JField[] fields=baseType.getFields();
  if (fields.length > 0) {
    TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classOrInterface.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
    for (    JField field : fields) {
      if (!shouldConsiderForSerialization(localLogger,suppressNonStaticFinalFieldWarnings,field)) {
        continue;
      }
      TreeLogger fieldLogger=localLogger.branch(TreeLogger.DEBUG,field.toString(),null);
      JType fieldType=field.getType();
      TypePath path=TypePaths.createFieldPath(parent,field);
      if (typeInfo.isManuallySerializable() && fieldType.getLeafType() == typeOracle.getJavaLangObject()) {
        checkAllSubtypesOfObject(fieldLogger.branch(TreeLogger.WARN,""String_Node_Str"",null),path,problems);
      }
 else {
        allSucceeded&=computeTypeInstantiability(fieldLogger,fieldType,path,problems).hasInstantiableSubtypes();
      }
    }
  }
  boolean succeeded=allSucceeded || typeInfo.isManuallySerializable();
  if (succeeded) {
    typeInfo.setFieldSerializable();
  }
  return succeeded;
}"
82504,"public JClassType getType(){
  return type;
}","public JType getType(){
  return type;
}"
82505,"private boolean checkArrayInstantiable(TreeLogger logger,JArrayType array,TypePath path,ProblemReport problems){
}","private TypeInfoComputed checkArrayInstantiable(TreeLogger logger,JArrayType array,TypePath path,ProblemReport problems){
}"
82506,"private TypeInfoComputed getTypeInfoComputed(JClassType type,TypePath path,boolean createIfNeeded){
  TypeInfoComputed tic=typeToTypeInfoComputed.get(type);
  if (tic == null && createIfNeeded) {
    tic=new TypeInfoComputed(type,path);
    typeToTypeInfoComputed.put(type,tic);
  }
  return tic;
}","private TypeInfoComputed getTypeInfoComputed(JType type,TypePath path,boolean createIfNeeded){
  TypeInfoComputed tic=typeToTypeInfoComputed.get(type);
  if (tic == null && createIfNeeded) {
    tic=new TypeInfoComputed(type,path);
    typeToTypeInfoComputed.put(type,tic);
  }
  return tic;
}"
82507,"/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=checkTypeInstantiable(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems);
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyEnhancedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    JClassType type=tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if ((enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName())) || tic.maybeEnhanced()) {
      possiblyEnhancedTypes.add(type);
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes,possiblyEnhancedTypes);
}","/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=computeTypeInstantiability(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems).hasInstantiableSubtypes();
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyEnhancedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (!(tic.getType() instanceof JClassType)) {
      continue;
    }
    JClassType type=(JClassType)tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if ((enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName())) || tic.maybeEnhanced()) {
      possiblyEnhancedTypes.add(type);
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes,possiblyEnhancedTypes);
}"
82508,"public WebModePayloadSink(ClientOracle clientOracle,OutputStream out){
  this.clientOracle=clientOracle;
  this.out=out;
  backRefIdent=clientOracle.createUnusedIdent(""String_Node_Str"");
}","public WebModePayloadSink(ClientOracle clientOracle,OutputStream out){
  this.clientOracle=clientOracle;
  this.out=out;
}"
82509,"byte[] makeBackRef(ValueCommand x){
  byte[] toReturn=valueBackRefs.get(x);
  if (toReturn == null) {
    if (freeBackRefs.isEmpty()) {
      int idx=valueBackRefs.size();
      toReturn=getBytes(backRefIdent + ""String_Node_Str"" + Integer.toString(idx,Character.MAX_RADIX));
    }
 else {
      toReturn=freeBackRefs.pop();
    }
    valueBackRefs.put(x,toReturn);
  }
  return toReturn;
}","byte[] makeBackRef(ValueCommand x){
  byte[] toReturn=valueBackRefs.get(x);
  if (toReturn == null) {
    if (freeBackRefs.isEmpty()) {
      int idx=valueBackRefs.size();
      toReturn=getBytes(BACKREF_IDENT + ""String_Node_Str"" + Integer.toString(idx,Character.MAX_RADIX));
    }
 else {
      toReturn=freeBackRefs.pop();
    }
    valueBackRefs.put(x,toReturn);
  }
  return toReturn;
}"
82510,"private JsExpression mapUnaryVariant(Node unOp) throws JsParserException {
switch (unOp.getIntDatum()) {
case TokenStream.SUB:
    return mapPrefixOperation(JsUnaryOperator.NEG,unOp);
case TokenStream.NOT:
  return mapPrefixOperation(JsUnaryOperator.NOT,unOp);
case TokenStream.BITNOT:
return mapPrefixOperation(JsUnaryOperator.BIT_NOT,unOp);
case TokenStream.TYPEOF:
return mapPrefixOperation(JsUnaryOperator.TYPEOF,unOp);
case TokenStream.ADD:
return mapExpression(unOp.getFirstChild());
case TokenStream.VOID:
return mapPrefixOperation(JsUnaryOperator.VOID,unOp);
default :
throw new JsParserException(""String_Node_Str"" + unOp.getIntDatum());
}
}","private JsExpression mapUnaryVariant(Node unOp) throws JsParserException {
switch (unOp.getIntDatum()) {
case TokenStream.SUB:
    return mapPrefixOperation(JsUnaryOperator.NEG,unOp);
case TokenStream.NOT:
  return mapPrefixOperation(JsUnaryOperator.NOT,unOp);
case TokenStream.BITNOT:
return mapPrefixOperation(JsUnaryOperator.BIT_NOT,unOp);
case TokenStream.TYPEOF:
return mapPrefixOperation(JsUnaryOperator.TYPEOF,unOp);
case TokenStream.ADD:
if (unOp.getFirstChild().getType() != TokenStream.NUMBER) {
return mapPrefixOperation(JsUnaryOperator.POS,unOp);
}
 else {
return mapExpression(unOp.getFirstChild());
}
case TokenStream.VOID:
return mapPrefixOperation(JsUnaryOperator.VOID,unOp);
default :
throw new JsParserException(""String_Node_Str"" + unOp.getIntDatum());
}
}"
82511,"private void doTest(String js) throws Exception {
  List<JsStatement> expected=JsParser.parse(SourceOrigin.UNKNOWN,new JsProgram().getScope(),new StringReader(js));
  List<JsStatement> actual=parse(expected,true);
  ComparingVisitor.exec(expected,actual);
  actual=parse(expected,false);
  ComparingVisitor.exec(expected,actual);
}","private void doTest(String js,String expectedJs) throws Exception {
  List<JsStatement> actual=JsParser.parse(SourceOrigin.UNKNOWN,new JsProgram().getScope(),new StringReader(js));
  List<JsStatement> expected=JsParser.parse(SourceOrigin.UNKNOWN,new JsProgram().getScope(),new StringReader(expectedJs));
  ComparingVisitor.exec(expected,actual);
}"
82512,"public void testUnaryOperations() throws Exception {
  doTest(""String_Node_Str"");
}","public void testUnaryOperations() throws Exception {
  doTest(""String_Node_Str"");
  doTest(""String_Node_Str"",""String_Node_Str"");
  doTest(""String_Node_Str"",""String_Node_Str"");
}"
82513,"private static String downloadGroup(int splitPoint){
  return ""String_Node_Str"" + splitPoint;
}","private String downloadGroup(int fragment){
  return (fragment == leftoversFragment()) ? LwmLabels.LEFTOVERS_DOWNLOAD : LwmLabels.downloadGroupForExclusive(fragment);
}"
82514,"private void logFragmentLoaded(int fragment){
  String logGroup=(fragment == leftoversFragment()) ? LwmLabels.LEFTOVERS_DOWNLOAD : LwmLabels.downloadGroup(fragment);
  logEventProgress(logGroup,LwmLabels.END,fragment,null);
}","private void logFragmentLoaded(int fragment){
  String logGroup=downloadGroup(fragment);
  logEventProgress(logGroup,LwmLabels.END,fragment,null);
}"
82515,"/** 
 * Start downloading the next fragment in the initial sequence, if there are any left.
 */
private void startLoadingNextInitial(){
  if (remainingInitialFragments == null) {
    remainingInitialFragments=new BoundedIntQueue(initialLoadSequence.length + 1);
    for (    int sp : initialLoadSequence) {
      remainingInitialFragments.add(sp);
    }
    remainingInitialFragments.add(leftoversFragment());
  }
  if (initialFragmentErrorHandlers.isEmpty() && waitingForInitialFragmentsErrorHandlers.isEmpty() && remainingInitialFragments.size() > 1) {
    initialFragmentsLoading=false;
    return;
  }
  if (remainingInitialFragments.size() > 0) {
    initialFragmentsLoading=true;
    int nextSplitPoint=remainingInitialFragments.peek();
    logEventProgress(LwmLabels.downloadGroup(nextSplitPoint),LwmLabels.BEGIN,nextSplitPoint,null);
    startLoadingFragment(nextSplitPoint,new InitialFragmentDownloadFailed());
    return;
  }
  initialFragmentsLoading=false;
  assert(haveInitialFragmentsLoaded());
  assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
  while (waitingForInitialFragments.size() > 0) {
    startLoadingFragment(waitingForInitialFragments.remove(),waitingForInitialFragmentsErrorHandlers.remove());
  }
}","/** 
 * Start downloading the next fragment in the initial sequence, if there are any left.
 */
private void startLoadingNextInitial(){
  if (remainingInitialFragments == null) {
    remainingInitialFragments=new BoundedIntQueue(initialLoadSequence.length + 1);
    for (    int sp : initialLoadSequence) {
      remainingInitialFragments.add(sp);
    }
    remainingInitialFragments.add(leftoversFragment());
  }
  if (initialFragmentErrorHandlers.isEmpty() && waitingForInitialFragmentsErrorHandlers.isEmpty() && remainingInitialFragments.size() > 1) {
    initialFragmentsLoading=false;
    return;
  }
  if (remainingInitialFragments.size() > 0) {
    initialFragmentsLoading=true;
    int nextSplitPoint=remainingInitialFragments.peek();
    logDownloadStart(nextSplitPoint);
    startLoadingFragment(nextSplitPoint,new InitialFragmentDownloadFailed());
    return;
  }
  initialFragmentsLoading=false;
  assert(haveInitialFragmentsLoaded());
  assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
  while (waitingForInitialFragments.size() > 0) {
    int nextSplitPoint=waitingForInitialFragments.remove();
    LoadErrorHandler handler=waitingForInitialFragmentsErrorHandlers.remove();
    logDownloadStart(nextSplitPoint);
    startLoadingFragment(nextSplitPoint,handler);
  }
}"
82516,"/** 
 * Loads the specified split point.
 * @param splitPoint the split point whose code needs to be loaded
 */
public void inject(int splitPoint,LoadErrorHandler loadErrorHandler){
  if (haveInitialFragmentsLoaded()) {
    logEventProgress(LwmLabels.downloadGroup(splitPoint),LwmLabels.BEGIN,splitPoint,null);
    startLoadingFragment(splitPoint,loadErrorHandler);
    return;
  }
  if (isInitial(splitPoint)) {
    initialFragmentErrorHandlers.put(splitPoint,loadErrorHandler);
  }
 else {
    assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
    waitingForInitialFragments.add(splitPoint);
    waitingForInitialFragmentsErrorHandlers.add(loadErrorHandler);
  }
  if (!initialFragmentsLoading) {
    startLoadingNextInitial();
  }
}","/** 
 * Loads the specified split point.
 * @param splitPoint the split point whose code needs to be loaded
 */
public void inject(int splitPoint,LoadErrorHandler loadErrorHandler){
  if (haveInitialFragmentsLoaded()) {
    logDownloadStart(splitPoint);
    startLoadingFragment(splitPoint,loadErrorHandler);
    return;
  }
  if (isInitial(splitPoint)) {
    initialFragmentErrorHandlers.put(splitPoint,loadErrorHandler);
  }
 else {
    assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
    waitingForInitialFragments.add(splitPoint);
    waitingForInitialFragmentsErrorHandlers.add(loadErrorHandler);
  }
  if (!initialFragmentsLoading) {
    startLoadingNextInitial();
  }
}"
82517,"/** 
 * This test catches a case in an earlier version of AsyncFragmentLoader where AsyncFragmentLoader.waitingForInitialFragments could exhaust its available space.
 */
public void testOverflowInWaitingForInitialFragments(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,NULL_LOGGER);
  for (int i=0; i < 10; i++) {
    MockErrorHandler error=new MockErrorHandler();
    loader.inject(4,error);
    reqs.assertFragmentsRequested(1);
    loadFailed(reqs,1);
    assertTrue(error.getWasCalled());
  }
}","/** 
 * This test catches a case in an earlier version of AsyncFragmentLoader where AsyncFragmentLoader.waitingForInitialFragments could exhaust its available space.
 */
public void testOverflowInWaitingForInitialFragments(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,progress);
  for (int i=0; i < 10; i++) {
    MockErrorHandler error=new MockErrorHandler();
    loader.inject(4,error);
    reqs.assertFragmentsRequested(1);
    progress.assertEvent(""String_Node_Str"",BEGIN,1);
    loadFailed(reqs,1);
    assertTrue(error.getWasCalled());
    progress.assertNoEvents();
  }
}"
82518,"/** 
 * Check the behavior when there are download failures.
 */
public void testDownloadFailures(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,NULL_LOGGER);
  MockErrorHandler error1try1=new MockErrorHandler();
  loader.inject(1,error1try1);
  reqs.assertFragmentsRequested(1);
  loadFailed(reqs,1);
  assertTrue(error1try1.getWasCalled());
  MockErrorHandler error1try2=new MockErrorHandler();
  loader.inject(1,error1try2);
  reqs.assertFragmentsRequested(1);
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested();
  assertFalse(error1try2.getWasCalled());
  MockErrorHandler error3try1=new MockErrorHandler();
  loader.inject(3,error3try1);
  reqs.assertFragmentsRequested(2);
  loadFailed(reqs,2);
  assertTrue(error3try1.wasCalled);
  MockErrorHandler error3try2=new MockErrorHandler();
  MockErrorHandler error5try1=new MockErrorHandler();
  loader.inject(3,error3try2);
  loader.inject(5,error5try1);
  reqs.assertFragmentsRequested(2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested(3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  loadFailed(reqs,numEntries);
  assertFalse(error3try2.getWasCalled());
  assertTrue(error5try1.getWasCalled());
  reqs.errorHandlers.get(numEntries);
  MockErrorHandler error5try2=new MockErrorHandler();
  loader.inject(5,error5try2);
  reqs.assertFragmentsRequested(numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  assertFalse(error5try2.getWasCalled());
}","/** 
 * Check the behavior when there are download failures.
 */
public void testDownloadFailures(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,progress);
  MockErrorHandler error1try1=new MockErrorHandler();
  loader.inject(1,error1try1);
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loadFailed(reqs,1);
  assertTrue(error1try1.getWasCalled());
  MockErrorHandler error1try2=new MockErrorHandler();
  loader.inject(1,error1try2);
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested();
  assertFalse(error1try2.getWasCalled());
  progress.assertEvent(""String_Node_Str"",END,1);
  MockErrorHandler error3try1=new MockErrorHandler();
  loader.inject(3,error3try1);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loadFailed(reqs,2);
  assertTrue(error3try1.wasCalled);
  MockErrorHandler error3try2=new MockErrorHandler();
  MockErrorHandler error5try1=new MockErrorHandler();
  loader.inject(3,error3try2);
  loader.inject(5,error5try1);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested(3);
  progress.assertEvent(""String_Node_Str"",END,2);
  progress.assertEvent(""String_Node_Str"",BEGIN,3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(""String_Node_Str"",END,3);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,BEGIN,numEntries);
  loadFailed(reqs,numEntries);
  assertFalse(error3try2.getWasCalled());
  assertTrue(error5try1.getWasCalled());
  reqs.errorHandlers.get(numEntries);
  MockErrorHandler error5try2=new MockErrorHandler();
  loader.inject(5,error5try2);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,BEGIN,numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(5);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,END,numEntries);
  progress.assertEvent(""String_Node_Str"",BEGIN,5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  assertFalse(error5try2.getWasCalled());
  progress.assertEvent(""String_Node_Str"",END,5);
  progress.assertNoEvents();
}"
82519,"/** 
 * A thorough exercise of loading with an initial load sequence specified.
 */
public void testWithInitialLoadSequence(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,NULL_LOGGER);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(1);
  loader.inject(3,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested();
  loader.inject(5,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested();
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested(2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested(3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  loader.inject(4,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(4);
  loader.fragmentHasLoaded(4);
  reqs.assertFragmentsRequested();
}","/** 
 * A thorough exercise of loading with an initial load sequence specified.
 */
public void testWithInitialLoadSequence(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,progress);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loader.inject(3,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested();
  progress.assertNoEvents();
  loader.inject(5,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested();
  progress.assertNoEvents();
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",END,1);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested(3);
  progress.assertEvent(""String_Node_Str"",END,2);
  progress.assertEvent(""String_Node_Str"",BEGIN,3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(""String_Node_Str"",END,3);
  progress.assertEvent(""String_Node_Str"",BEGIN,numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(5);
  progress.assertEvent(""String_Node_Str"",END,numEntries);
  progress.assertEvent(""String_Node_Str"",BEGIN,5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,5);
  progress.assertNoEvents();
  loader.inject(4,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(4);
  progress.assertEvent(""String_Node_Str"",BEGIN,4);
  loader.fragmentHasLoaded(4);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,4);
  progress.assertNoEvents();
}"
82520,"public void logEventProgress(String eventGroup,String type,Integer fragment,Integer size){
}","public void logEventProgress(String eventGroup,String type,Integer fragment,Integer size){
  events.add(new MockProgressEvent(eventGroup,type,fragment));
}"
82521,"public void testBasics(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=5;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{},reqs,NULL_LOGGER);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(1);
  loader.fragmentHasLoaded(1);
  loader.inject(2,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(2);
  loader.fragmentHasLoaded(2);
}","public void testBasics(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=5;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{},reqs,progress);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,BEGIN,numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,END,numEntries);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loader.fragmentHasLoaded(1);
  progress.assertEvent(""String_Node_Str"",END,1);
  loader.inject(2,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loader.fragmentHasLoaded(2);
  progress.assertEvent(""String_Node_Str"",END,2);
  progress.assertNoEvents();
}"
82522,"/** 
 * If only the first part of the initial load sequence is requested, then don't request more.
 */
public void testLoadingPartOfInitialSequence(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,NULL_LOGGER);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(1);
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested();
  loader.inject(2,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested();
  loader.inject(3,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  loader.fragmentHasLoaded(numEntries);
  reqs.assertFragmentsRequested();
  loader.inject(5,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
}","/** 
 * If only the first part of the initial load sequence is requested, then don't request more.
 */
public void testLoadingPartOfInitialSequence(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,progress);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,1);
  loader.inject(2,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,2);
  loader.inject(3,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(3);
  progress.assertEvent(""String_Node_Str"",BEGIN,3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(""String_Node_Str"",END,3);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,BEGIN,numEntries);
  loader.fragmentHasLoaded(numEntries);
  reqs.assertFragmentsRequested();
  progress.assertEvent(LEFTOVERS_DOWNLOAD,END,numEntries);
  loader.inject(5,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(5);
  progress.assertEvent(""String_Node_Str"",BEGIN,5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,5);
  progress.assertNoEvents();
}"
82523,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}"
82524,"public double getUnitSizeInPixels(Element parent,Unit unit,boolean vertical){
  if (unit == null) {
    return 1;
  }
switch (unit) {
default :
case PX:
    return 1;
case PCT:
  return (vertical ? parent.getClientHeight() : parent.getClientWidth()) / 100.0;
case EM:
return relativeRuler.getOffsetWidth();
case EX:
return relativeRuler.getOffsetHeight();
case CM:
return fixedRuler.getOffsetWidth();
case MM:
return fixedRuler.getOffsetWidth() / 10.0;
case IN:
return fixedRuler.getOffsetWidth() / 2.54;
case PT:
return fixedRuler.getOffsetWidth() / 28.4;
case PC:
return fixedRuler.getOffsetWidth() / 2.36;
}
}","public double getUnitSizeInPixels(Element parent,Unit unit,boolean vertical){
  if (unit == null) {
    return 1;
  }
switch (unit) {
case PCT:
    return (vertical ? parent.getClientHeight() : parent.getClientWidth()) / 100.0;
case EM:
  return relativeRuler.getOffsetWidth();
case EX:
return relativeRuler.getOffsetHeight();
case CM:
return fixedRuler.getOffsetWidth();
case MM:
return fixedRuler.getOffsetWidth() / 10.0;
case IN:
return fixedRuler.getOffsetWidth() / 2.54;
case PT:
return fixedRuler.getOffsetWidth() / 28.4;
case PC:
return fixedRuler.getOffsetWidth() / 2.36;
default :
case PX:
return 1;
}
}"
82525,"private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
}","private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
}"
82526,"/** 
 * Returns the Object associated with the given key in the (key, value) mapping associated with the given Object instance.
 * @param instance the source Object.
 * @param key a String key.
 * @return an Object associated with that key on the given instance, or null.
 */
public static void set(Object instance,String key,Object value){
}","/** 
 * Associates a value with a given key in the (key, value) mapping associated with the given Object instance. Note that the key space is module-wide, so some care should be taken to choose sufficiently unique identifiers.
 * @param instance the source Object.
 * @param key a String key.
 * @param value the Object to associate with the key on the given sourceObject.
 */
public static void set(Object instance,String key,Object value){
}"
82527,"/** 
 * Associates a value with a given key in the (key, value) mapping associated with the given Object instance. Note that the key space is module-wide, so some care should be taken to choose sufficiently unique identifiers.
 * @param instance the source Object.
 * @param key a String key.
 * @param value the Object to associate with the key on the given sourceObject.
 */
public static native Object get(Object instance,String key);","/** 
 * Returns the Object associated with the given key in the (key, value) mapping associated with the given Object instance.
 * @param instance the source Object.
 * @param key a String key.
 * @return an Object associated with that key on the given instance, or null.
 */
public static native Object get(Object instance,String key);"
82528,"/** 
 * Forward link type.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/struct/links.html#adef-rel"">W3C HTML Specification</a>
 */
public final native void setRel(String name);","/** 
 * Forward link type.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/struct/links.html#adef-rel"">W3C HTML Specification</a>
 */
public final native void setRel(String rel);"
82529,"private void writeArtifactToFile(TreeLogger logger,EmittedArtifact artifact,File outFile,Set<String> createdDirs) throws UnableToCompleteException {
  if (!outFile.exists() || (outFile.lastModified() <= artifact.getLastModified())) {
    if (!mkdirs(outFile.getParentFile(),createdDirs)) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"");
    }
 else {
      try {
        FileOutputStream out=new FileOutputStream(outFile);
        artifact.writeTo(logger,out);
        out.close();
      }
 catch (      IOException e) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"",e);
        throw new UnableToCompleteException();
      }
      outFile.setLastModified(artifact.getLastModified());
    }
  }
}","private void writeArtifactToFile(TreeLogger logger,EmittedArtifact artifact,File outFile,Set<String> createdDirs) throws UnableToCompleteException {
  if (!outFile.exists() || (outFile.lastModified() < artifact.getLastModified())) {
    if (!mkdirs(outFile.getParentFile(),createdDirs)) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"");
    }
 else {
      try {
        FileOutputStream out=new FileOutputStream(outFile);
        artifact.writeTo(logger,out);
        out.close();
      }
 catch (      IOException e) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"",e);
        throw new UnableToCompleteException();
      }
      outFile.setLastModified(artifact.getLastModified());
    }
  }
}"
82530,"/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  if (GWT.isScript()) {
    try {
      t.compareTo(d2);
      fail(""String_Node_Str"");
    }
 catch (    ClassCastException e) {
    }
  }
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(2);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}","/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  if (GWT.isScript()) {
    try {
      t.compareTo(d2);
      fail(""String_Node_Str"");
    }
 catch (    ClassCastException e) {
    }
  }
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(t.getNanos() + 1);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}"
82531,@Override public native Element eventGetToElement(Event evt);,"@Override public Element eventGetToElement(Event evt){
  if (evt.getType().equals(""String_Node_Str"")) {
    return evt.getTarget().cast();
  }
  if (evt.getType().equals(""String_Node_Str"")) {
    return evt.getRelatedTarget().cast();
  }
  return null;
}"
82532,@Override public native Element eventGetFromElement(Event evt);,"@Override public Element eventGetFromElement(Event evt){
  if (evt.getType().equals(""String_Node_Str"")) {
    return evt.getRelatedTarget().cast();
  }
  if (evt.getType().equals(""String_Node_Str"")) {
    return evt.getTarget().cast();
  }
  return null;
}"
82533,"/** 
 * Call the toSource() on the JSO
 */
public native String toSource();","/** 
 * Call the toSource() on the JSO.
 */
public native String toSource();"
82534,"/** 
 * Check whether the given date and time falls within a daylight savings time period
 * @param date and time to check.
 * @return true if daylight savings time is in effect.
 */
public boolean isDaylightTime(Date date){
  return getDaylightAdjustment(date) > 0;
}","/** 
 * Check whether the given date and time falls within a daylight savings time period.
 * @param date and time to check.
 * @return true if daylight savings time is in effect.
 */
public boolean isDaylightTime(Date date){
  return getDaylightAdjustment(date) > 0;
}"
82535,"/** 
 * Returns this locale in canonical form: <ul> <li>Deprecated language/region tags are replaced with official versions <li> </ul>
 * @return GwtLocale instance 
 */
public GwtLocale getCanonicalForm(){
  String canonLanguage=language;
  String canonScript=script;
  String canonRegion=region;
  String canonVariant=variant;
  int n=deprecatedLanguages.length;
  for (int i=0; i < n; i+=2) {
    if (deprecatedLanguages[i + 1].equals(canonLanguage)) {
      canonLanguage=deprecatedLanguages[i];
      break;
    }
  }
  n=deprecatedRegions.length;
  for (int i=0; i < n; i+=2) {
    if (deprecatedRegions[i + 1].equals(canonRegion)) {
      canonRegion=deprecatedRegions[i];
      break;
    }
  }
  if (""String_Node_Str"".equals(canonLanguage)) {
    if (canonRegion != null) {
      if (""String_Node_Str"".equals(canonRegion) && ""String_Node_Str"".equals(canonScript)) {
        canonScript=null;
      }
 else       if (""String_Node_Str"".equals(canonRegion) && ""String_Node_Str"".equals(canonScript)) {
        canonScript=null;
      }
    }
 else     if (""String_Node_Str"".equals(canonScript)) {
      canonRegion=""String_Node_Str"";
      canonScript=null;
    }
 else     if (""String_Node_Str"".equals(canonScript)) {
      canonRegion=""String_Node_Str"";
      canonScript=null;
    }
  }
  if (""String_Node_Str"".equals(canonLanguage)) {
    canonLanguage=""String_Node_Str"";
    canonVariant=null;
  }
 else   if (""String_Node_Str"".equals(canonLanguage)) {
    canonLanguage=""String_Node_Str"";
    canonVariant=null;
  }
 else   if (""String_Node_Str"".equals(canonLanguage)) {
    if (canonVariant == null || ""String_Node_Str"".equals(canonVariant)) {
      canonLanguage=""String_Node_Str"";
      canonVariant=null;
    }
 else     if (""String_Node_Str"".equals(canonVariant)) {
      canonLanguage=""String_Node_Str"";
      canonVariant=null;
    }
  }
  if (canonScript != null && canonScript.equals(DefaultLanguageScripts.getDefaultScript(canonLanguage))) {
    canonScript=null;
  }
  return factory.fromComponents(canonLanguage,canonScript,canonRegion,canonVariant);
}","/** 
 * Returns this locale in canonical form.  Changes for canonical form are: <ul> <li>Deprecated language/region tags are replaced with official versions </ul>
 * @return GwtLocale instance 
 */
public GwtLocale getCanonicalForm(){
  String canonLanguage=language;
  String canonScript=script;
  String canonRegion=region;
  String canonVariant=variant;
  int n=deprecatedLanguages.length;
  for (int i=0; i < n; i+=2) {
    if (deprecatedLanguages[i + 1].equals(canonLanguage)) {
      canonLanguage=deprecatedLanguages[i];
      break;
    }
  }
  n=deprecatedRegions.length;
  for (int i=0; i < n; i+=2) {
    if (deprecatedRegions[i + 1].equals(canonRegion)) {
      canonRegion=deprecatedRegions[i];
      break;
    }
  }
  if (""String_Node_Str"".equals(canonLanguage)) {
    if (canonRegion != null) {
      if (""String_Node_Str"".equals(canonRegion) && ""String_Node_Str"".equals(canonScript)) {
        canonScript=null;
      }
 else       if (""String_Node_Str"".equals(canonRegion) && ""String_Node_Str"".equals(canonScript)) {
        canonScript=null;
      }
    }
 else     if (""String_Node_Str"".equals(canonScript)) {
      canonRegion=""String_Node_Str"";
      canonScript=null;
    }
 else     if (""String_Node_Str"".equals(canonScript)) {
      canonRegion=""String_Node_Str"";
      canonScript=null;
    }
  }
  if (""String_Node_Str"".equals(canonLanguage)) {
    canonLanguage=""String_Node_Str"";
    canonVariant=null;
  }
 else   if (""String_Node_Str"".equals(canonLanguage)) {
    canonLanguage=""String_Node_Str"";
    canonVariant=null;
  }
 else   if (""String_Node_Str"".equals(canonLanguage)) {
    if (canonVariant == null || ""String_Node_Str"".equals(canonVariant)) {
      canonLanguage=""String_Node_Str"";
      canonVariant=null;
    }
 else     if (""String_Node_Str"".equals(canonVariant)) {
      canonLanguage=""String_Node_Str"";
      canonVariant=null;
    }
  }
  if (canonScript != null && canonScript.equals(DefaultLanguageScripts.getDefaultScript(canonLanguage))) {
    canonScript=null;
  }
  return factory.fromComponents(canonLanguage,canonScript,canonRegion,canonVariant);
}"
82536,"/** 
 * Creates a JMultiExpression from a set of JExpressionStatements, optionally terminated by a JReturnStatement. If the method doesn't match this pattern, it returns <code>null</code>. If a method has a non-void return statement and can be represented as a multi-expression, the output of the multi-expression will be the return expression of the method. If the method is void, the output of the multi-expression should be considered undefined.
 */
private JMultiExpression createMultiExpressionFromBody(JMethodBody body,boolean ignoringReturnValue){
  JMultiExpression multi=new JMultiExpression(body.getSourceInfo());
  CloneCalleeExpressionVisitor cloner=new CloneCalleeExpressionVisitor();
  for (  JStatement stmt : body.getStatements()) {
    if (stmt instanceof JExpressionStatement) {
      JExpressionStatement exprStmt=(JExpressionStatement)stmt;
      JExpression expr=exprStmt.getExpr();
      JExpression clone=cloner.cloneExpression(expr);
      multi.exprs.add(clone);
    }
 else     if (stmt instanceof JReturnStatement) {
      JReturnStatement returnStatement=(JReturnStatement)stmt;
      JExpression expr=returnStatement.getExpr();
      if (expr != null) {
        if (!ignoringReturnValue || expr.hasSideEffects()) {
          JExpression clone=cloner.cloneExpression(expr);
          multi.exprs.add(clone);
        }
      }
      break;
    }
 else {
      return null;
    }
  }
  return multi;
}","/** 
 * Creates a JMultiExpression from a set of JExpressionStatements, optionally terminated by a JReturnStatement. If the method doesn't match this pattern, it returns <code>null</code>. If a method has a non-void return statement and can be represented as a multi-expression, the output of the multi-expression will be the return expression of the method. If the method is void, the output of the multi-expression should be considered undefined.
 */
private JMultiExpression createMultiExpressionFromBody(JMethodBody body,boolean ignoringReturnValue){
  JMultiExpression multi=new JMultiExpression(body.getSourceInfo());
  CloneCalleeExpressionVisitor cloner=new CloneCalleeExpressionVisitor();
  for (  JStatement stmt : body.getStatements()) {
    if (stmt instanceof JExpressionStatement) {
      JExpressionStatement exprStmt=(JExpressionStatement)stmt;
      JExpression expr=exprStmt.getExpr();
      JExpression clone=cloner.cloneExpression(expr);
      multi.exprs.add(clone);
    }
 else     if (stmt instanceof JReturnStatement) {
      JReturnStatement returnStatement=(JReturnStatement)stmt;
      JExpression expr=returnStatement.getExpr();
      if (expr != null) {
        if (!ignoringReturnValue || expr.hasSideEffects()) {
          JExpression clone=cloner.cloneExpression(expr);
          clone=maybeCast(clone,body.getMethod().getType());
          multi.exprs.add(clone);
        }
      }
      break;
    }
 else {
      return null;
    }
  }
  return multi;
}"
82537,"public void testImplicitCastToLong(){
  long l=10;
  l+=5;
  assertEquals(15,l);
  assertTrue(15 == l);
}","public void testImplicitCastToLong(){
  long l=10;
  l+=5;
  assertEquals(15,l);
  assertTrue(15 == l);
  IntegerWrapper wrap=new IntegerWrapper(20);
  assertEquals(400L,wrap.longValue() * wrap.longValue());
}"
82538,"public void setText(String text){
  DOM.setElementProperty(getElement(),""String_Node_Str"",text != null ? text : ""String_Node_Str"");
}","/** 
 * Sets this object's text.  Note that some browsers will manipulate the text before adding it to the widget.  For example, most browsers will strip all <code>\r</code> from the text, except IE which will add a <code>\r</code> before each <code>\n</code>.  Use   {@link #getText()} to get the textdirectly from the widget.
 * @param text the object's new text
 */
public void setText(String text){
  DOM.setElementProperty(getElement(),""String_Node_Str"",text != null ? text : ""String_Node_Str"");
}"
82539,@Override public native int getTextAreaCursorPos(Element elem);,"/** 
 * The text reported in the text range does not include newline characters at the end of the selection. So, we need to create 2 ranges and subtract a character from one until the lengths are different. At that point, we know exactly how many \r\n were truncated from the selection.
 */
@Override public native int getTextAreaCursorPos(Element elem);"
82540,"@Override public native void setSelectionRange(Element elem,int pos,int length);","/** 
 * Moving the start 1 character will move across a \r\n, but \r\n counts as two characters, so we need to offset the position accordingly.
 */
@Override public native void setSelectionRange(Element elem,int pos,int length);"
82541,"/** 
 * This is the real implementation of <code>getModulePrefix</code> for this linker. The other versions forward to this one.
 */
private String getModulePrefix(LinkerContext context,String strongName,boolean supportRunAsync){
  DefaultTextOutput out=new DefaultTextOutput(context.isOutputCompact());
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + About.getGwtVersionNum() + ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + strongName + ""String_Node_Str"");
  out.newlineOpt();
  if (supportRunAsync) {
    out.print(""String_Node_Str"");
    out.indentIn();
    out.newlineOpt();
    out.print(""String_Node_Str"" + getFragmentSubdir() + ""String_Node_Str""+ FRAGMENT_EXTENSION+ ""String_Node_Str"");
    out.indentOut();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.indentIn();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.indentOut();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
  }
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + context.getModuleName() + ""String_Node_Str""+ ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newline();
  return out.toString();
}","/** 
 * This is the real implementation of <code>getModulePrefix</code> for this linker. The other versions forward to this one.
 */
private String getModulePrefix(LinkerContext context,String strongName,boolean supportRunAsync){
  DefaultTextOutput out=new DefaultTextOutput(context.isOutputCompact());
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + About.getGwtVersionNum() + ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + strongName + ""String_Node_Str"");
  out.newlineOpt();
  if (supportRunAsync) {
    out.print(""String_Node_Str"");
    out.indentIn();
    out.newlineOpt();
    out.print(""String_Node_Str"" + getFragmentSubdir() + ""String_Node_Str""+ FRAGMENT_EXTENSION+ ""String_Node_Str"");
    out.indentOut();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.indentIn();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.indentOut();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
  }
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + context.getModuleName() + ""String_Node_Str""+ ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newline();
  return out.toString();
}"
82542,"private byte[] findClassBytes(String className){
  if (JavaScriptHost.class.getName().equals(className)) {
    return javaScriptHostBytes;
  }
  if (classRewriter != null && classRewriter.isJsoIntf(className)) {
    byte[] newBytes=classRewriter.writeJsoIntf(className);
    if (CLASS_DUMP) {
      classDump(className,newBytes);
    }
    return newBytes;
  }
  String lookupClassName=canonicalizeClassName(className);
  CompiledClass compiledClass=compilationState.getClassFileMap().get(lookupClassName);
  CompilationUnit unit=(compiledClass == null) ? getUnitForClassName(lookupClassName) : compiledClass.getUnit();
  if (emmaAvailable) {
    List<JsniMethod> jsniMethods=(unit == null) ? null : unit.getJsniMethods();
    if (unit != null && !unit.isSuperSource() && !unit.isGenerated() && unit.hasAnonymousClasses() && jsniMethods != null && jsniMethods.size() > 0 && !unit.createdClassMapping()) {
      if (!unit.constructAnonymousClassMappings(logger)) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ className);
        return null;
      }
    }
  }
  byte classBytes[]=null;
  if (compiledClass != null) {
    classBytes=compiledClass.getBytes();
    if (!compiledClass.getUnit().isSuperSource()) {
      classBytes=emmaStrategy.getEmmaClassBytes(classBytes,lookupClassName,compiledClass.getUnit().getLastModified());
    }
 else {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
    }
  }
 else   if (emmaAvailable) {
    if (typeHasCompilationUnit(lookupClassName) && isClassnameGenerated(className)) {
      logger.log(TreeLogger.DEBUG,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
      classBytes=emmaStrategy.getEmmaClassBytes(null,lookupClassName,0);
    }
  }
  if (classBytes != null && classRewriter != null) {
    Map<String,String> anonymousClassMap=Collections.emptyMap();
    if (unit != null) {
      anonymousClassMap=unit.getAnonymousClassMap();
    }
    byte[] newBytes=classRewriter.rewrite(this,className,classBytes,anonymousClassMap);
    if (CLASS_DUMP) {
      if (!Arrays.equals(classBytes,newBytes)) {
        classDump(className,newBytes);
      }
    }
    classBytes=newBytes;
  }
  return classBytes;
}","private byte[] findClassBytes(String className){
  if (JavaScriptHost.class.getName().equals(className)) {
    return javaScriptHostBytes;
  }
  if (classRewriter != null && classRewriter.isJsoIntf(className)) {
    byte[] newBytes=classRewriter.writeJsoIntf(className);
    if (CLASS_DUMP) {
      classDump(className,newBytes);
    }
    return newBytes;
  }
  String lookupClassName=canonicalizeClassName(className);
  CompiledClass compiledClass=compilationState.getClassFileMap().get(lookupClassName);
  CompilationUnit unit=(compiledClass == null) ? getUnitForClassName(lookupClassName) : compiledClass.getUnit();
  if (emmaAvailable) {
    List<JsniMethod> jsniMethods=(unit == null) ? null : unit.getJsniMethods();
    if (unit != null && !unit.isSuperSource() && !unit.isGenerated() && unit.hasAnonymousClasses() && jsniMethods != null && jsniMethods.size() > 0 && !unit.createdClassMapping()) {
      if (!unit.constructAnonymousClassMappings(logger)) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ className);
        return null;
      }
    }
  }
  byte classBytes[]=null;
  if (compiledClass != null) {
    classBytes=compiledClass.getBytes();
    if (!compiledClass.getUnit().isSuperSource()) {
      classBytes=emmaStrategy.getEmmaClassBytes(classBytes,lookupClassName,compiledClass.getUnit().getLastModified());
    }
 else {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
    }
  }
 else   if (emmaAvailable) {
    if (typeHasCompilationUnit(lookupClassName) && isClassnameGenerated(className)) {
      logger.log(TreeLogger.DEBUG,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
      classBytes=emmaStrategy.getEmmaClassBytes(null,lookupClassName,0);
    }
  }
  if (classBytes != null && classRewriter != null) {
    Map<String,String> anonymousClassMap=Collections.emptyMap();
    if (unit != null) {
      anonymousClassMap=unit.getAnonymousClassMap();
    }
    byte[] newBytes=classRewriter.rewrite(typeOracle,className,classBytes,anonymousClassMap);
    if (CLASS_DUMP) {
      if (!Arrays.equals(classBytes,newBytes)) {
        classDump(className,newBytes);
      }
    }
    classBytes=newBytes;
  }
  return classBytes;
}"
82543,"/** 
 * Performs rewriting transformations on a class.
 * @param ccl the ClassLoader requesting the rewrite
 * @param className the name of the class
 * @param classBytes the bytes of the class
 * @param anonymousClassMap a map between the anonymous class names of javacompiler used to compile code and jdt. Emma-specific.
 */
public byte[] rewrite(ClassLoader ccl,String className,byte[] classBytes,Map<String,String> anonymousClassMap){
  String desc=toDescriptor(className);
  assert(!jsoIntfDescs.contains(desc));
  ClassWriter writer=new ClassWriter(0);
  ClassVisitor v=writer;
  v=new RewriteSingleJsoImplDispatches(v,ccl,singleJsoImplTypes,mangledNamesToImplementations);
  v=new RewriteRefsToJsoClasses(v,jsoIntfDescs,mapper);
  if (jsoImplDescs.contains(desc)) {
    v=WriteJsoImpl.create(v,desc,jsoIntfDescs,mapper,mangledNamesToImplementations);
  }
  v=new RewriteJsniMethods(v,anonymousClassMap);
  if (Double.parseDouble(System.getProperty(""String_Node_Str"")) < Opcodes.V1_6) {
    v=new ForceClassVersion15(v);
  }
  new ClassReader(classBytes).accept(v,0);
  return writer.toByteArray();
}","/** 
 * Performs rewriting transformations on a class.
 * @param typeOracle a typeOracle modeling the user classes
 * @param className the name of the class
 * @param classBytes the bytes of the class
 * @param anonymousClassMap a map between the anonymous class names of javacompiler used to compile code and jdt. Emma-specific.
 */
public byte[] rewrite(TypeOracle typeOracle,String className,byte[] classBytes,Map<String,String> anonymousClassMap){
  String desc=toDescriptor(className);
  assert(!jsoIntfDescs.contains(desc));
  ClassWriter writer=new ClassWriter(0);
  ClassVisitor v=writer;
  v=new RewriteSingleJsoImplDispatches(v,typeOracle,singleJsoImplTypes,mangledNamesToImplementations);
  v=new RewriteRefsToJsoClasses(v,jsoIntfDescs,mapper);
  if (jsoImplDescs.contains(desc)) {
    v=WriteJsoImpl.create(v,desc,jsoIntfDescs,mapper,mangledNamesToImplementations);
  }
  v=new RewriteJsniMethods(v,anonymousClassMap);
  if (Double.parseDouble(System.getProperty(""String_Node_Str"")) < Opcodes.V1_6) {
    v=new ForceClassVersion15(v);
  }
  new ClassReader(classBytes).accept(v,0);
  return writer.toByteArray();
}"
82544,"public RewriteSingleJsoImplDispatches(ClassVisitor v,ClassLoader ccl,Set<String> singleJsoImplTypes,SortedMap<String,Method> mangledNamesToImplementations){
  super(v);
  this.ccl=ccl;
  this.singleJsoImplTypes=Collections.unmodifiableSet(singleJsoImplTypes);
  this.mangledNamesToImplementations=Collections.unmodifiableSortedMap(mangledNamesToImplementations);
}","public RewriteSingleJsoImplDispatches(ClassVisitor v,TypeOracle typeOracle,Set<String> singleJsoImplTypes,SortedMap<String,Method> mangledNamesToImplementations){
  super(v);
  this.typeOracle=typeOracle;
  this.singleJsoImplTypes=Collections.unmodifiableSet(singleJsoImplTypes);
  this.mangledNamesToImplementations=Collections.unmodifiableSortedMap(mangledNamesToImplementations);
}"
82545,"private Set<String> computeAllInterfaces(String... interfaces){
}","private Set<String> computeAllInterfaces(String[] interfaces){
  Set<String> toReturn=new HashSet<String>();
  for (  String intfName : interfaces) {
    toReturn.addAll(computeAllInterfaces(intfName));
  }
  return toReturn;
}"
82546,"static int compute(String str){
  int n=str.length();
  int inc=(n < 64) ? 1 : (n / 32);
  int hashCode=0;
  for (int i=0; i < n; i+=inc) {
    hashCode<<=1;
    hashCode+=str.charAt(i);
  }
  hashCode|=0;
  return hashCode;
}","static int compute(String str){
  int hashCode=0;
  int n=str.length();
  int nBatch=n - 4;
  int i=0;
  while (i < nBatch) {
    hashCode=(str.charAt(i + 3) + 31 * (str.charAt(i + 2) + 31 * (str.charAt(i + 1) + 31 * (str.charAt(i) + 31 * hashCode)))) | 0;
    i+=4;
  }
  while (i < n) {
    hashCode=hashCode * 31 + str.charAt(i++);
  }
  return hashCode | 0;
}"
82547,"/** 
 * Tests hashing with strings. The specific strings used in this test used to trigger failures because we use a JavaScript object as a hash map to cache the computed hash codes. This conflicts with built-in properties defined on objects -- see issue #631.
 */
public void testHashCode(){
  String[] testStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] savedHash=new int[testStrings.length];
  for (int i=0; i < testStrings.length; ++i) {
    savedHash[i]=testStrings[i].hashCode();
    String str=Integer.toString(savedHash[i]);
    for (int j=0; j < str.length(); ++j) {
      char ch=str.charAt(j);
      assertTrue(""String_Node_Str"" + ch + ""String_Node_Str""+ Integer.toHexString(ch)+ ""String_Node_Str"",ch == '-' || ch == ' ' || Character.isDigit(ch));
    }
  }
  for (int i=0; i < testStrings.length; ++i) {
    assertEquals(savedHash[i],testStrings[i].hashCode());
  }
}","/** 
 * Tests hashing with strings. The specific strings used in this test used to trigger failures because we use a JavaScript object as a hash map to cache the computed hash codes. This conflicts with built-in properties defined on objects -- see issue #631.
 */
public void testHashCode(){
  String[] testStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] javaHashes={112903375,-274141738,-1776922004,-1781441930,3125404,231605032,-1588406278,2139739112,Integer.MIN_VALUE,3841,120,0};
  for (int i=0; i < testStrings.length; ++i) {
    String testString=testStrings[i];
    int expectedHash=javaHashes[i];
    assertEquals(""String_Node_Str"" + testString,expectedHash,testString.hashCode());
    String str=Integer.toString(expectedHash);
    for (int j=0; j < str.length(); ++j) {
      char ch=str.charAt(j);
      assertTrue(""String_Node_Str"" + ch + ""String_Node_Str""+ Integer.toHexString(ch)+ ""String_Node_Str"",ch == '-' || ch == ' ' || Character.isDigit(ch));
    }
    assertEquals(expectedHash,testStrings[i].hashCode());
  }
}"
82548,"/** 
 * Load the Google Gears BHO if possible.
 * @return true if Gears was successfully loaded and initialized
 */
public boolean startGears(){
  try {
    GUID appClsid=getClassID(""String_Node_Str"");
    if (appClsid == null) {
      return false;
    }
  }
 catch (  SWTException e) {
    return false;
  }
  int[] address=new int[1];
  if (COM.CoCreateInstance(appClsid,0,COM.CLSCTX_INPROC_SERVER,COM.IIDIUnknown,address) != COM.S_OK) {
    return false;
  }
  IUnknown obj=new IUnknown(address[0]);
  int[] ppvObject=new int[1];
  if (obj.QueryInterface(COM.IIDIObjectWithSite,ppvObject) == COM.S_OK) {
    IObjectWithSite objectWithSite=new IObjectWithSite(ppvObject[0]);
    objectWithSite.SetSite(objIUnknown);
    objectWithSite.Release();
    return true;
  }
  return false;
}","/** 
 * Load the Google Gears BHO if possible.
 * @return true if Gears was successfully loaded and initialized
 */
public boolean startGears(){
  GUID appClsid=null;
  try {
    appClsid=getClassID(""String_Node_Str"");
    if (appClsid == null) {
      return false;
    }
  }
 catch (  SWTException e) {
    return false;
  }
  int[] address=new int[1];
  if (COM.CoCreateInstance(appClsid,0,COM.CLSCTX_INPROC_SERVER,COM.IIDIUnknown,address) != COM.S_OK) {
    return false;
  }
  IUnknown obj=new IUnknown(address[0]);
  int[] ppvObject=new int[1];
  if (obj.QueryInterface(COM.IIDIObjectWithSite,ppvObject) == COM.S_OK) {
    IObjectWithSite objectWithSite=new IObjectWithSite(ppvObject[0]);
    objectWithSite.SetSite(objIUnknown);
    objectWithSite.Release();
    return true;
  }
  return false;
}"
82549,"public Precompilation newInstance(TreeLogger logger) throws UnableToCompleteException {
  Precompilation toReturn;
  try {
    toReturn=Util.readStreamAsObject(jarFile.getInputStream(zipEntry),Precompilation.class);
  }
 catch (  IOException e) {
    toReturn=null;
  }
catch (  ClassNotFoundException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
  if (toReturn == null) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"");
    throw new UnableToCompleteException();
  }
  return toReturn;
}","public Precompilation newInstance(TreeLogger logger) throws UnableToCompleteException {
  try {
    return Util.readStreamAsObject(jarFile.getInputStream(zipEntry),Precompilation.class);
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
catch (  ClassNotFoundException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}"
82550,"public <T>T readObject(long token,Class<T> type){
  try {
    byte[] bytes=readByteArray(token);
    ByteArrayInputStream in=new ByteArrayInputStream(bytes);
    return Util.readStreamAsObject(in,type);
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public <T>T readObject(long token,Class<T> type){
  try {
    byte[] bytes=readByteArray(token);
    ByteArrayInputStream in=new ByteArrayInputStream(bytes);
    return Util.readStreamAsObject(in,type);
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}"
82551,"/** 
 * Construct a new instance of the object stored in the backing file.
 * @param logger a sink for error messages
 * @return a new instance of the object stored in the backing file
 * @throws UnableToCompleteException if the backing store does not contain anobject of type <code>T</code>
 */
public T newInstance(TreeLogger logger) throws UnableToCompleteException {
  try {
    T toReturn=Util.readFileAsObject(backingFile,clazz);
    if (toReturn == null) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"");
      throw new UnableToCompleteException();
    }
    return toReturn;
  }
 catch (  ClassNotFoundException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}","/** 
 * Construct a new instance of the object stored in the backing file.
 * @param logger a sink for error messages
 * @return a new instance of the object stored in the backing file
 * @throws UnableToCompleteException if the backing store does not contain anobject of type <code>T</code>
 */
public T newInstance(TreeLogger logger) throws UnableToCompleteException {
  try {
    return Util.readFileAsObject(backingFile,clazz);
  }
 catch (  ClassNotFoundException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}"
82552,"public static <T>T readStreamAsObject(InputStream inputStream,Class<T> type) throws ClassNotFoundException {
  ObjectInputStream objectInputStream=null;
  try {
    objectInputStream=new ObjectInputStream(inputStream);
    return type.cast(objectInputStream.readObject());
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(objectInputStream);
  }
}","public static <T>T readStreamAsObject(InputStream inputStream,Class<T> type) throws ClassNotFoundException, IOException {
  ObjectInputStream objectInputStream=null;
  try {
    objectInputStream=new ObjectInputStream(inputStream);
    return type.cast(objectInputStream.readObject());
  }
  finally {
    Utility.close(objectInputStream);
  }
}"
82553,"public static <T extends Serializable>T readFileAsObject(File file,Class<T> type) throws ClassNotFoundException {
  FileInputStream fileInputStream=null;
  try {
    fileInputStream=new FileInputStream(file);
    return readStreamAsObject(fileInputStream,type);
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(fileInputStream);
  }
}","public static <T extends Serializable>T readFileAsObject(File file,Class<T> type) throws ClassNotFoundException, IOException {
  FileInputStream fileInputStream=null;
  try {
    fileInputStream=new FileInputStream(file);
    return readStreamAsObject(fileInputStream,type);
  }
  finally {
    Utility.close(fileInputStream);
  }
}"
82554,"/** 
 * The control is unavailable in this context.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-disabled"">W3C HTML Specification</a>
 */
public final native void setDisabled(String disabled);","/** 
 * The control is unavailable in this context.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-disabled"">W3C HTML Specification</a>
 * @deprecated use {@link #setDisabled(boolean)} instead
 */
public final native void setDisabled(String disabled);"
82555,"/** 
 * The control is unavailable in this context.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-disabled"">W3C HTML Specification</a>
 */
public final native String getDisabled();","/** 
 * The control is unavailable in this context.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-disabled"">W3C HTML Specification</a>
 * @deprecated use {@link #isDisabled()} instead.
 */
public final native String getDisabled();"
82556,"/** 
 * Enables/disables the link. This is currently only used for style sheet links, and may be used to activate or deactivate style sheets.
 */
public final native boolean getDisabled();","/** 
 * Enables/disables the link. This is currently only used for style sheet links, and may be used to activate or deactivate style sheets.
 * @deprecated use {@link #isDisabled()} instead.
 */
public final native boolean getDisabled();"
82557,"/** 
 * Enables/disables the style sheet.
 */
public final native boolean getDisabled();","/** 
 * Enables/disables the style sheet.
 * @deprecated use {@link #isDisabled()} instead
 */
public final native boolean getDisabled();"
82558,public final native boolean getDisabled();,"/** 
 * @deprecated use {@link #isDisabled()} instead
 */
public final native boolean getDisabled();"
82559,public final native boolean getReadOnly();,"/** 
 * @deprecated use {@link #isReadOnly()} instead.
 */
public final native boolean getReadOnly();"
82560,"/** 
 * Loads an image from the classpath, optionally prepending this package.
 * @param name name of an image file.
 * @param prependPackage true if {@link #PACKAGE_PATH} should be prepended tothis name.
 */
static ImageIcon loadImageIcon(String name,boolean prependPackage){
  ClassLoader cl=OophmHostedModeBase.class.getClassLoader();
  if (prependPackage) {
    name=PACKAGE_PATH + name;
  }
  URL url=cl.getResource(name);
  if (url != null) {
    ImageIcon image=new ImageIcon(url);
    return image;
  }
 else {
    return new ImageIcon();
  }
}","/** 
 * Loads an image from the classpath, optionally prepending this package.
 * @param name name of an image file.
 * @param prependPackage true if {@link #PACKAGE_PATH} should be prepended tothis name.
 */
static ImageIcon loadImageIcon(String name,boolean prependPackage){
  ClassLoader cl=OophmHostedModeBase.class.getClassLoader();
  if (prependPackage) {
    name=PACKAGE_PATH + name;
  }
  URL url=(name == null) ? null : cl.getResource(name);
  if (url != null) {
    ImageIcon image=new ImageIcon(url);
    return image;
  }
 else {
    return new ImageIcon();
  }
}"
82561,"private boolean removeWithState(K key,State<V> state){
  if (root == null) {
    return false;
  }
  Node<K,V> node;
  Node<K,V> found=null;
  Node<K,V> parent=null;
  Node<K,V> grandparent=null;
  Node<K,V> head=new Node<K,V>(null,null);
  int dir=1;
  head.child[RIGHT]=root;
  node=head;
  while (node.child[dir] != null) {
    int last=dir;
    grandparent=parent;
    parent=node;
    node=node.child[dir];
    int c=cmp.compare(node.key,key);
    dir=c < 0 ? RIGHT : LEFT;
    if (c == 0 && (!state.matchValue || node.value.equals(state.value))) {
      found=node;
    }
    if (!isRed(node) && !isRed(node.child[dir])) {
      if (isRed(node.child[otherChild(dir)])) {
        parent=parent.child[last]=rotateSingle(node,dir);
      }
 else       if (!isRed(node.child[otherChild(dir)])) {
        Node<K,V> sibling=parent.child[otherChild(last)];
        if (sibling != null) {
          if (!isRed(sibling.child[otherChild(last)]) && !isRed(sibling.child[last])) {
            parent.isRed=false;
            sibling.isRed=true;
            node.isRed=true;
          }
 else {
            int dir2=grandparent.child[RIGHT] == parent ? RIGHT : LEFT;
            if (isRed(sibling.child[last])) {
              grandparent.child[dir2]=rotateDouble(parent,last);
            }
 else             if (isRed(sibling.child[otherChild(last)])) {
              grandparent.child[dir2]=rotateSingle(parent,last);
            }
            node.isRed=grandparent.child[dir2].isRed=true;
            grandparent.child[dir2].child[LEFT].isRed=false;
            grandparent.child[dir2].child[RIGHT].isRed=false;
          }
        }
      }
    }
  }
  if (found != null) {
    if (state != null) {
      state.found=true;
      state.value=found.value;
    }
    found.key=node.key;
    found.value=node.value;
    parent.child[parent.child[RIGHT] == node ? RIGHT : LEFT]=node.child[node.child[LEFT] == null ? RIGHT : LEFT];
    size--;
  }
  root=head.child[RIGHT];
  if (root != null) {
    root.isRed=false;
  }
  return state.found;
}","private boolean removeWithState(K key,State<V> state){
  if (root == null) {
    return false;
  }
  Node<K,V> node;
  Node<K,V> found=null;
  Node<K,V> parent=null;
  Node<K,V> grandparent=null;
  Node<K,V> head=new Node<K,V>(null,null);
  int dir=1;
  head.child[RIGHT]=root;
  node=head;
  while (node.child[dir] != null) {
    int last=dir;
    grandparent=parent;
    parent=node;
    node=node.child[dir];
    int c=cmp.compare(node.key,key);
    dir=c < 0 ? RIGHT : LEFT;
    if (c == 0 && (!state.matchValue || node.value.equals(state.value))) {
      found=node;
    }
    if (!isRed(node) && !isRed(node.child[dir])) {
      if (isRed(node.child[otherChild(dir)])) {
        parent=parent.child[last]=rotateSingle(node,dir);
      }
 else       if (!isRed(node.child[otherChild(dir)])) {
        Node<K,V> sibling=parent.child[otherChild(last)];
        if (sibling != null) {
          if (!isRed(sibling.child[otherChild(last)]) && !isRed(sibling.child[last])) {
            parent.isRed=false;
            sibling.isRed=true;
            node.isRed=true;
          }
 else {
            int dir2=grandparent.child[RIGHT] == parent ? RIGHT : LEFT;
            if (isRed(sibling.child[last])) {
              grandparent.child[dir2]=rotateDouble(parent,last);
            }
 else             if (isRed(sibling.child[otherChild(last)])) {
              grandparent.child[dir2]=rotateSingle(parent,last);
            }
            node.isRed=grandparent.child[dir2].isRed=true;
            grandparent.child[dir2].child[LEFT].isRed=false;
            grandparent.child[dir2].child[RIGHT].isRed=false;
          }
        }
      }
    }
  }
  if (found != null) {
    if (state != null) {
      state.found=true;
      state.value=found.value;
    }
    if (node != found) {
      Node<K,V> newNode=new Node<K,V>(node.key,node.value);
      replaceNode(head,found,newNode);
      if (parent == found) {
        parent=newNode;
      }
    }
    parent.child[parent.child[RIGHT] == node ? RIGHT : LEFT]=node.child[node.child[LEFT] == null ? RIGHT : LEFT];
    size--;
  }
  root=head.child[RIGHT];
  if (root != null) {
    root.isRed=false;
  }
  return state.found;
}"
82562,"public static String slurpSource(SourcePosition position){
  FileReader fr=null;
  try {
    fr=new FileReader(position.file());
    BufferedReader br=new BufferedReader(fr);
    for (int i=0, n=position.line() - 1; i < n; ++i) {
      br.readLine();
    }
    StringBuffer lines=new StringBuffer();
    String line=br.readLine();
    int braceDepth=0;
    int indent=-1;
    boolean seenSemiColonOrBrace=false;
    while (line != null) {
      if (indent == -1) {
        for (indent=0; Character.isWhitespace(line.charAt(indent)); ++indent) {
        }
      }
      if (line.length() >= indent) {
        line=line.substring(indent);
      }
      lines.append(line + ""String_Node_Str"");
      for (int i=0, n=line.length(); i < n; ++i) {
        char c=line.charAt(i);
        if (c == '{') {
          seenSemiColonOrBrace=true;
          ++braceDepth;
        }
 else         if (c == '}') {
          --braceDepth;
        }
 else         if (c == ';') {
          seenSemiColonOrBrace=true;
        }
      }
      if (braceDepth > 0 || !seenSemiColonOrBrace) {
        line=br.readLine();
      }
 else {
        break;
      }
    }
    String code=lines.toString();
    return code;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      if (fr != null) {
        fr.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return ""String_Node_Str"";
}","public static String slurpSource(SourcePosition position){
  BufferedReader br=null;
  try {
    br=new BufferedReader(new FileReader(position.file()));
    for (int i=0, n=position.line() - 1; i < n; ++i) {
      br.readLine();
    }
    StringBuffer lines=new StringBuffer();
    String line=br.readLine();
    int braceDepth=0;
    int indent=-1;
    boolean seenSemiColonOrBrace=false;
    while (line != null) {
      if (indent == -1) {
        for (indent=0; Character.isWhitespace(line.charAt(indent)); ++indent) {
        }
      }
      if (line.length() >= indent) {
        line=line.substring(indent);
      }
      lines.append(line + ""String_Node_Str"");
      for (int i=0, n=line.length(); i < n; ++i) {
        char c=line.charAt(i);
        if (c == '{') {
          seenSemiColonOrBrace=true;
          ++braceDepth;
        }
 else         if (c == '}') {
          --braceDepth;
        }
 else         if (c == ';') {
          seenSemiColonOrBrace=true;
        }
      }
      if (braceDepth > 0 || !seenSemiColonOrBrace) {
        line=br.readLine();
      }
 else {
        break;
      }
    }
    String code=lines.toString();
    return code;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      if (br != null) {
        br.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return ""String_Node_Str"";
}"
82563,"public boolean copyFile(File in,File out){
  FileInputStream fis=null;
  FileOutputStream fos=null;
  try {
    fis=new FileInputStream(in);
    fos=new FileOutputStream(out);
    byte[] buf=new byte[4096];
    int i=0;
    while ((i=fis.read(buf)) != -1) {
      fos.write(buf,0,i);
    }
    return true;
  }
 catch (  Exception e) {
    return false;
  }
 finally {
    close(fis);
    close(fos);
  }
}","public boolean copyFile(File in,File out){
  FileInputStream fis=null;
  FileOutputStream fos=null;
  try {
    fis=new FileInputStream(in);
    fos=new FileOutputStream(out);
    byte[] buf=new byte[4096];
    int i=0;
    while ((i=fis.read(buf)) != -1) {
      fos.write(buf,0,i);
    }
    return true;
  }
 catch (  IOException e) {
    return false;
  }
 finally {
    close(fis);
    close(fos);
  }
}"
82564,"private String getFileFromClassPath(String filename){
  InputStream in=null;
  try {
    in=getClass().getClassLoader().getResourceAsStream(filename);
    try {
      if (in == null) {
        err.println(""String_Node_Str"" + filename);
        System.exit(-1);
      }
      StringWriter sw=new StringWriter();
      int ch;
      while ((ch=in.read()) != -1) {
        sw.write(ch);
      }
      return sw.toString();
    }
  finally {
      if (in != null) {
        in.close();
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","private String getFileFromClassPath(String filename){
  InputStream in=null;
  try {
    in=getClass().getClassLoader().getResourceAsStream(filename);
    try {
      if (in == null) {
        throw new RuntimeException(""String_Node_Str"" + filename);
      }
      StringWriter sw=new StringWriter();
      int ch;
      while ((ch=in.read()) != -1) {
        sw.write(ch);
      }
      return sw.toString();
    }
  finally {
      if (in != null) {
        in.close();
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
82565,"private static void split(String[] files) throws IOException {
  BufferedReader reader=null;
  String prefix=null;
  File inputFile=null;
  for (int i=0; i < files.length; i++) {
    if (reader != null) {
      reader.close();
    }
    String file=files[i];
    inputFile=new File(file);
    if (!inputFile.exists()) {
      System.err.println(""String_Node_Str"" + inputFile.getPath());
      return;
    }
    reader=new BufferedReader(new FileReader(inputFile));
    File outFile=null;
    PrintWriter writer=null;
    String line=reader.readLine();
    while (line != null) {
      if (prefix == null) {
        prefix=line.trim();
        if (prefix.length() == 0) {
          prefix=null;
        }
      }
 else       if (line.startsWith(prefix)) {
        if (writer != null) {
          writer.close();
        }
        String outPath=line.substring(prefix.length()).trim();
        outFile=new File(outPath);
        if (!outFile.isAbsolute()) {
          File absoluteParentDir=inputFile.getCanonicalFile().getParentFile();
          outFile=new File(absoluteParentDir,outPath);
          outFile.getParentFile().mkdirs();
        }
        writer=new PrintWriter(new FileWriter(outFile),true);
        writer.println(""String_Node_Str"");
      }
 else       if (writer != null) {
        writer.println(line);
      }
 else {
      }
      line=reader.readLine();
    }
    if (writer != null) {
      writer.close();
    }
  }
}","private static void split(String[] files) throws IOException {
  String prefix=null;
  File inputFile=null;
  for (int i=0; i < files.length; i++) {
    BufferedReader reader=null;
    try {
      String file=files[i];
      inputFile=new File(file);
      if (!inputFile.exists()) {
        System.err.println(""String_Node_Str"" + inputFile.getPath());
        return;
      }
      reader=new BufferedReader(new FileReader(inputFile));
      File outFile=null;
      PrintWriter writer=null;
      String line=reader.readLine();
      while (line != null) {
        if (prefix == null) {
          prefix=line.trim();
          if (prefix.length() == 0) {
            prefix=null;
          }
        }
 else         if (line.startsWith(prefix)) {
          if (writer != null) {
            writer.close();
          }
          String outPath=line.substring(prefix.length()).trim();
          outFile=new File(outPath);
          if (!outFile.isAbsolute()) {
            File absoluteParentDir=inputFile.getCanonicalFile().getParentFile();
            outFile=new File(absoluteParentDir,outPath);
            outFile.getParentFile().mkdirs();
          }
          writer=new PrintWriter(new FileWriter(outFile),true);
          writer.println(""String_Node_Str"");
        }
 else         if (writer != null) {
          writer.println(line);
        }
 else {
        }
        line=reader.readLine();
      }
      if (writer != null) {
        writer.close();
      }
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
}"
82566,"/** 
 * Determines whether or not the URL is relative.
 * @param src the test url
 * @return <code>true</code> if the URL is relative, <code>false</code> if not
 */
@SuppressWarnings(""String_Node_Str"") protected static boolean isRelativeURL(String src){
  if (src.startsWith(""String_Node_Str"")) {
    return false;
  }
  try {
    URL testUrl=new URL(src);
    return false;
  }
 catch (  MalformedURLException e) {
  }
  return true;
}","/** 
 * Determines whether or not the URL is relative.
 * @param src the test url
 * @return <code>true</code> if the URL is relative, <code>false</code> if not
 */
@SuppressWarnings(""String_Node_Str"") protected static boolean isRelativeURL(String src){
  if (src.startsWith(""String_Node_Str"")) {
    return false;
  }
  try {
    new URL(src);
    return false;
  }
 catch (  MalformedURLException e) {
  }
  return true;
}"
82567,"private void writeArtifactToFile(TreeLogger logger,EmittedArtifact artifact,File outFile,Set<String> createdDirs) throws UnableToCompleteException {
  if (!outFile.exists() || (outFile.lastModified() <= artifact.getLastModified())) {
    mkdirs(outFile.getParentFile(),createdDirs);
    try {
      FileOutputStream out=new FileOutputStream(outFile);
      artifact.writeTo(logger,out);
      out.close();
    }
 catch (    IOException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"",e);
      throw new UnableToCompleteException();
    }
    outFile.setLastModified(artifact.getLastModified());
  }
}","private void writeArtifactToFile(TreeLogger logger,EmittedArtifact artifact,File outFile,Set<String> createdDirs) throws UnableToCompleteException {
  if (!outFile.exists() || (outFile.lastModified() <= artifact.getLastModified())) {
    if (!mkdirs(outFile.getParentFile(),createdDirs)) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"");
    }
 else {
      try {
        FileOutputStream out=new FileOutputStream(outFile);
        artifact.writeTo(logger,out);
        out.close();
      }
 catch (      IOException e) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"",e);
        throw new UnableToCompleteException();
      }
      outFile.setLastModified(artifact.getLastModified());
    }
  }
}"
82568,"/** 
 * A faster bulk version of   {@link File#mkdirs()} that takes advantage ofcached state to avoid a lot of file system access.
 */
private static void mkdirs(File dir,Set<String> createdDirs){
  if (dir == null) {
    return;
  }
  String path=dir.getPath();
  if (createdDirs.contains(path)) {
    return;
  }
  if (!dir.exists()) {
    mkdirs(dir.getParentFile(),createdDirs);
    dir.mkdir();
  }
  createdDirs.add(path);
}","/** 
 * A faster bulk version of   {@link File#mkdirs()} that takes advantage ofcached state to avoid a lot of file system access.
 */
private static boolean mkdirs(File dir,Set<String> createdDirs){
  if (dir == null) {
    return true;
  }
  String path=dir.getPath();
  if (createdDirs.contains(path)) {
    return true;
  }
  if (!dir.exists()) {
    if (!mkdirs(dir.getParentFile(),createdDirs)) {
      return false;
    }
    if (!dir.mkdir()) {
      return false;
    }
  }
  createdDirs.add(path);
  return true;
}"
82569,"/** 
 * Used to record dependencies of a program.
 * @param jprogram
 * @param workDir
 * @param permutationId
 * @param logger
 * @return The file that the dependencies are recorded in
 */
public File recordDependencies(JProgram jprogram,File workDir,int permutationId,TreeLogger logger){
  logger=logger.branch(TreeLogger.INFO,""String_Node_Str"");
  ControlFlowAnalyzer dependencyAnalyzer=new ControlFlowAnalyzer(jprogram);
  dependencyAnalyzer.setDependencyRecorder(this);
  File appendDepFile=new File(workDir,""String_Node_Str"" + permutationId + ""String_Node_Str"");
  try {
    FileOutputStream stream=new FileOutputStream(appendDepFile,true);
    writer=new OutputStreamWriter(new GZIPOutputStream(stream),""String_Node_Str"");
    appendDepFile.getParentFile().mkdirs();
    pw=new PrintWriter(writer);
    htmlOut=new HtmlTextOutput(pw,false);
  }
 catch (  Throwable e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
  }
  printPre();
  for (  JMethod method : jprogram.getAllEntryMethods()) {
    dependencyAnalyzer.traverseFrom(method);
  }
  printPost();
  pw.close();
  Utility.close(writer);
  logger.log(TreeLogger.INFO,""String_Node_Str"");
  return appendDepFile;
}","/** 
 * Used to record dependencies of a program.
 * @param jprogram
 * @param workDir
 * @param permutationId
 * @param logger
 * @return The file that the dependencies are recorded in
 */
public File recordDependencies(JProgram jprogram,File workDir,int permutationId,TreeLogger logger){
  logger=logger.branch(TreeLogger.INFO,""String_Node_Str"");
  ControlFlowAnalyzer dependencyAnalyzer=new ControlFlowAnalyzer(jprogram);
  dependencyAnalyzer.setDependencyRecorder(this);
  File appendDepFile=new File(workDir,""String_Node_Str"" + permutationId + ""String_Node_Str"");
  try {
    appendDepFile.getParentFile().mkdirs();
    FileOutputStream stream=new FileOutputStream(appendDepFile,true);
    writer=new OutputStreamWriter(new GZIPOutputStream(stream),""String_Node_Str"");
    pw=new PrintWriter(writer);
    htmlOut=new HtmlTextOutput(pw,false);
  }
 catch (  Throwable e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
  }
  printPre();
  for (  JMethod method : jprogram.getAllEntryMethods()) {
    dependencyAnalyzer.traverseFrom(method);
  }
  printPost();
  pw.close();
  Utility.close(writer);
  logger.log(TreeLogger.INFO,""String_Node_Str"");
  return appendDepFile;
}"
82570,"/** 
 * Used to record (runAsync) split points of a program.
 * @param jprogram
 * @param workDir
 * @param permutationId
 * @param logger
 * @return The file that the dependencies are recorded in
 */
public File recordSplitPoints(JProgram jprogram,File workDir,int permutationId,TreeLogger logger){
  logger=logger.branch(TreeLogger.INFO,""String_Node_Str"");
  File splitPointsFile=new File(workDir,""String_Node_Str"" + Integer.toString(permutationId) + ""String_Node_Str"");
  try {
    stream=new FileOutputStream(splitPointsFile,true);
    writer=new OutputStreamWriter(new GZIPOutputStream(stream),""String_Node_Str"");
    splitPointsFile.getParentFile().mkdirs();
    pw=new PrintWriter(writer);
    htmlOut=new HtmlTextOutput(pw,false);
    String curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    htmlOut.indentIn();
    htmlOut.indentIn();
    Map<Integer,String> splitPointMap=jprogram.getSplitPointMap();
    if (splitPointMap.size() > 0) {
      curLine=""String_Node_Str"";
      htmlOut.printRaw(curLine);
      htmlOut.newline();
      htmlOut.indentIn();
      htmlOut.indentIn();
      for (      Integer splitPointCount : splitPointMap.keySet()) {
        curLine=""String_Node_Str"" + splitPointCount + ""String_Node_Str""+ splitPointMap.get(splitPointCount)+ ""String_Node_Str"";
        htmlOut.printRaw(curLine);
        htmlOut.newline();
      }
      htmlOut.indentOut();
      htmlOut.indentOut();
      curLine=""String_Node_Str"";
      htmlOut.printRaw(curLine);
      htmlOut.newline();
    }
    htmlOut.indentOut();
    htmlOut.indentOut();
    curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    Utility.close(writer);
    pw.close();
    logger.log(TreeLogger.INFO,""String_Node_Str"");
  }
 catch (  Throwable e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
  }
  return splitPointsFile;
}","/** 
 * Used to record (runAsync) split points of a program.
 * @param jprogram
 * @param workDir
 * @param permutationId
 * @param logger
 * @return The file that the dependencies are recorded in
 */
public File recordSplitPoints(JProgram jprogram,File workDir,int permutationId,TreeLogger logger){
  logger=logger.branch(TreeLogger.INFO,""String_Node_Str"");
  File splitPointsFile=new File(workDir,""String_Node_Str"" + Integer.toString(permutationId) + ""String_Node_Str"");
  try {
    splitPointsFile.getParentFile().mkdirs();
    stream=new FileOutputStream(splitPointsFile,true);
    writer=new OutputStreamWriter(new GZIPOutputStream(stream),""String_Node_Str"");
    pw=new PrintWriter(writer);
    htmlOut=new HtmlTextOutput(pw,false);
    String curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    htmlOut.indentIn();
    htmlOut.indentIn();
    Map<Integer,String> splitPointMap=jprogram.getSplitPointMap();
    if (splitPointMap.size() > 0) {
      curLine=""String_Node_Str"";
      htmlOut.printRaw(curLine);
      htmlOut.newline();
      htmlOut.indentIn();
      htmlOut.indentIn();
      for (      Map.Entry<Integer,String> entry : splitPointMap.entrySet()) {
        Integer splitPointCount=entry.getKey();
        curLine=""String_Node_Str"" + splitPointCount + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
        htmlOut.printRaw(curLine);
        htmlOut.newline();
      }
      htmlOut.indentOut();
      htmlOut.indentOut();
      curLine=""String_Node_Str"";
      htmlOut.printRaw(curLine);
      htmlOut.newline();
    }
    htmlOut.indentOut();
    htmlOut.indentOut();
    curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    Utility.close(writer);
    pw.close();
    logger.log(TreeLogger.INFO,""String_Node_Str"");
  }
 catch (  Throwable e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
  }
  return splitPointsFile;
}"
82571,"private void visitInNewContext(List<CssNode> nodes){
  MergeRulesByContentVisitor v=new MergeRulesByContentVisitor();
  v.accept(nodes);
  rulesInOrder.addAll(v.rulesInOrder);
}","private void visitInNewContext(List<CssNode> nodes){
  MergeRulesByContentVisitor v=new MergeRulesByContentVisitor();
  v.acceptWithInsertRemove(nodes);
  rulesInOrder.addAll(v.rulesInOrder);
}"
82572,"public void onClick(ClickEvent event){
  ValueChangeEvent.fireIfNotEqual(CheckBox.this,valueBeforeClick,getValue());
}","public void onClick(ClickEvent event){
  ValueChangeEvent.fire(CheckBox.this,getValue());
}"
82573,"public HandlerRegistration addValueChangeHandler(ValueChangeHandler<Boolean> handler){
  if (!valueChangeHandlerInitialized) {
    this.addKeyUpHandler(new KeyUpHandler(){
      public void onKeyUp(      KeyUpEvent event){
        valueBeforeClick=getValue();
      }
    }
);
    this.addMouseUpHandler(new MouseUpHandler(){
      public void onMouseUp(      MouseUpEvent event){
        valueBeforeClick=getValue();
      }
    }
);
    this.addClickHandler(new ClickHandler(){
      public void onClick(      ClickEvent event){
        ValueChangeEvent.fireIfNotEqual(CheckBox.this,valueBeforeClick,getValue());
      }
    }
);
    valueChangeHandlerInitialized=true;
  }
  return addHandler(handler,ValueChangeEvent.getType());
}","public HandlerRegistration addValueChangeHandler(ValueChangeHandler<Boolean> handler){
  if (!valueChangeHandlerInitialized) {
    ensureDomEventHandlers();
    valueChangeHandlerInitialized=true;
  }
  return addHandler(handler,ValueChangeEvent.getType());
}"
82574,"@Override public void sinkEvents(int eventBitsToAdd){
  if (isOrWasAttached()) {
    Event.sinkEvents(inputElem,eventBitsToAdd | Event.getEventsSunk(inputElem));
    Event.sinkEvents(labelElem,eventBitsToAdd | Event.getEventsSunk(labelElem));
  }
 else {
    super.sinkEvents(eventBitsToAdd);
  }
}","@Override public void sinkEvents(int eventBitsToAdd){
  if (isOrWasAttached()) {
    Event.sinkEvents(inputElem,eventBitsToAdd | Event.getEventsSunk(inputElem));
  }
 else {
    super.sinkEvents(eventBitsToAdd);
  }
}"
82575,"public void onClick(Widget sender){
  ++fired;
}","public void onClick(ClickEvent arg0){
  clickCount[0]++;
}"
82576,"/** 
 * Returns the permutation's strong name. This can be used to distinguish between different permutations of the same module. In hosted mode, this method will return   {@value #HOSTED_MODE_PERMUTATION_ID}.
 */
public static String getPermutationStrongName(){
  if (GWT.isScript()) {
    return Impl.getPermutationStrongName();
  }
 else {
    return HOSTED_MODE_PERMUTATION_STRONG_NAME;
  }
}","/** 
 * Returns the permutation's strong name. This can be used to distinguish between different permutations of the same module. In hosted mode, this method will return   {@value #HOSTED_MODE_PERMUTATION_STRONG_NAME}.
 */
public static String getPermutationStrongName(){
  if (GWT.isScript()) {
    return Impl.getPermutationStrongName();
  }
 else {
    return HOSTED_MODE_PERMUTATION_STRONG_NAME;
  }
}"
82577,"/** 
 * Gets the element to which the mouse pointer was moved (only valid for  {@link Event#ONMOUSEOUT}).
 * @deprecated use {@link NativeEvent#getRelatedTarget()} instead
 * @return the element to which the mouse pointer was moved
 */
@Deprecated public final Element getToElement(){
  return DOM.eventGetToElement(this);
}","/** 
 * Gets the element to which the mouse pointer was moved (only valid for  {@link Event#ONMOUSEOUT}).
 * @deprecated use {@link NativeEvent#getRelatedEventTarget()} instead
 * @return the element to which the mouse pointer was moved
 */
@Deprecated public final Element getToElement(){
  return DOM.eventGetToElement(this);
}"
82578,"/** 
 * Gets the element from which the mouse pointer was moved (only valid for  {@link Event#ONMOUSEOVER}).
 * @deprecated use {@link NativeEvent#getRelatedTarget()} instead
 * @return the element from which the mouse pointer was moved
 */
@Deprecated public final Element getFromElement(){
  return DOM.eventGetFromElement(this);
}","/** 
 * Gets the element from which the mouse pointer was moved (only valid for  {@link Event#ONMOUSEOVER}).
 * @deprecated use {@link NativeEvent#getRelatedEventTarget()} instead
 * @return the element from which the mouse pointer was moved
 */
@Deprecated public final Element getFromElement(){
  return DOM.eventGetFromElement(this);
}"
82579,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler} method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(DisclosureHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(DisclosureHandler handler);"
82580,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler} method on the object returned by an add*Handler method instead
 */
@Deprecated void removeFormHandler(FormHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeFormHandler(FormHandler handler);"
82581,"/** 
 * Adds a handler interface to receive click events.
 * @deprecated Use {@link FormPanel#addSubmitCompleteHandler FormPanel.addSubmitCompleteHandler} and{@link FormPanel#addSubmitHandler FormPanel.addSubmitHandler} instead
 * @param handler the handler interface to add
 */
@Deprecated void addFormHandler(FormHandler handler);","/** 
 * Adds a handler interface to receive click events.
 * @deprecated Use {@link FormPanel#addSubmitCompleteHandler} and{@link FormPanel#addSubmitHandler} instead
 * @param handler the handler interface to add
 */
@Deprecated void addFormHandler(FormHandler handler);"
82582,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler} method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(SuggestionHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(SuggestionHandler handler);"
82583,"/** 
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link addScrollHandler} instead
 */
@Deprecated public void removeScrollListener(ScrollListener listener){
  ListenerWrapper.WrappedScrollListener.remove(this,listener);
}","/** 
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link #addScrollHandler} instead
 */
@Deprecated public void removeScrollListener(ScrollListener listener){
  ListenerWrapper.WrappedScrollListener.remove(this,listener);
}"
82584,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link #addChangeHandler} instead
 */
@Deprecated void removeChangeListener(ChangeListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasChangeHandlers#addChangeHandler}instead
 */
@Deprecated void removeChangeListener(ChangeListener listener);"
82585,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link #addClickHandler} instead
 */
@Deprecated void removeClickListener(ClickListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasClickHandlers#addClickHandler}instead
 */
@Deprecated void removeClickListener(ClickListener listener);"
82586,"/** 
 * Adds a listener interface to receive focus events.
 * @param listener the listener interface to add
 * @deprecated use <code>addFocusHandler</code> and <cod>addBlurHandler</code>instead.
 */
@Deprecated void addFocusListener(FocusListener listener);","/** 
 * Adds a listener interface to receive focus events.
 * @param listener the listener interface to add
 * @deprecated use addFocusHandler and addBlurHandler instead.
 */
@Deprecated void addFocusListener(FocusListener listener);"
82587,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link #addFocusHandler} instead
 */
@Deprecated void removeFocusListener(FocusListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasFocusHandlers#addFocusHandler}instead
 */
@Deprecated void removeFocusListener(FocusListener listener);"
82588,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasLoadHandlers#addLoadListener} instead
 */
@Deprecated void removeLoadListener(LoadListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasLoadHandlers#addLoadHandler}instead
 */
@Deprecated void removeLoadListener(LoadListener listener);"
82589,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use add* methods of {@link com.google.gwt.event.dom.client.HasAllMouseHandlers}instead
 */
@Deprecated void addMouseListener(MouseListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use add* methods of {@link HasAllMouseHandlers} instead
 */
@Deprecated void addMouseListener(MouseListener listener);"
82590,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated Use {@link com.google.gwt.event.dom.client.HasMouseWheelHandlers#addMouseWheelHandler}instead
 */
@Deprecated void addMouseWheelListener(MouseWheelListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated Use {@link HasMouseWheelHandlers#addMouseWheelHandler} instead
 */
@Deprecated void addMouseWheelListener(MouseWheelListener listener);"
82591,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link com.google.gwt.event.dom.client.HasMouseWheelHandlers#addMouseWheelHandler}instead
 */
@Deprecated void removeMouseWheelListener(MouseWheelListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by  {@link HasMouseWheelHandlers#addMouseWheelHandler} instead
 */
@Deprecated void removeMouseWheelListener(MouseWheelListener listener);"
82592,"/** 
 * Adds a listener interface to receive popup events.
 * @param listener the listener interface to add.
 * @deprecated use {@link com.google.gwt.event.logical.shared.HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void addPopupListener(PopupListener listener);","/** 
 * Adds a listener interface to receive popup events.
 * @param listener the listener interface to add.
 * @deprecated use {@link HasCloseHandlers#addCloseHandler} instead
 */
@Deprecated void addPopupListener(PopupListener listener);"
82593,"/** 
 * Removes a previously added popup listener.
 * @param listener the listener interface to remove.
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link com.google.gwt.event.logical.shared.HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void removePopupListener(PopupListener listener);","/** 
 * Removes a previously added popup listener.
 * @param listener the listener interface to remove.
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void removePopupListener(PopupListener listener);"
82594,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(DisclosureHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(DisclosureHandler handler);"
82595,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeFormHandler(FormHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeFormHandler(FormHandler handler);"
82596,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(SuggestionHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(SuggestionHandler handler);"
82597,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasChangeHandlers#addChangeHandler}instead
 */
@Deprecated void removeChangeListener(ChangeListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasChangeHandlers#addChangeHandler}instead
 */
@Deprecated void removeChangeListener(ChangeListener listener);"
82598,"/** 
 * Adds a listener interface to receive change events.
 * @param listener the listener interface to add
 * @deprecated use <code>addChangeHandler</code> or<code>addValueChangeHandler</code> instead
 */
@Deprecated void addChangeListener(ChangeListener listener);","/** 
 * Adds a listener interface to receive change events.
 * @param listener the listener interface to add
 * @deprecated use addChangeHandler or addValueChangeHandler instead
 */
@Deprecated void addChangeListener(ChangeListener listener);"
82599,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasClickHandlers#addClickHandler}instead
 */
@Deprecated void removeClickListener(ClickListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasClickHandlers#addClickHandler}instead
 */
@Deprecated void removeClickListener(ClickListener listener);"
82600,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasFocusHandlers#addFocusHandler}instead
 */
@Deprecated void removeFocusListener(FocusListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasFocusHandlers#addFocusHandler}instead
 */
@Deprecated void removeFocusListener(FocusListener listener);"
82601,"/** 
 * Adds a listener interface to receive keyboard events.
 * @param listener the listener interface to add
 * @deprecated use<code>addKeyPressHandler/addKeyDownKeyDownHandler/addKeyUpHandler</code> instead
 */
@Deprecated void addKeyboardListener(KeyboardListener listener);","/** 
 * Adds a listener interface to receive keyboard events.
 * @param listener the listener interface to add
 * @deprecated use addKeyPressHandler/addKeyDownKeyDownHandler/addKeyUpHandlerinstead
 */
@Deprecated void addKeyboardListener(KeyboardListener listener);"
82602,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeKeyboardListener(KeyboardListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeKeyboardListener(KeyboardListener listener);"
82603,"/** 
 * Adds a listener interface to receive load events.
 * @param listener the listener interface to add
 * @deprecated use {@link HasLoadHandlers#addLoadHandler} instead
 */
@Deprecated void addLoadListener(LoadListener listener);","/** 
 * Adds a listener interface to receive load events.
 * @param listener the listener interface to add
 * @deprecated use{@link com.google.gwt.event.dom.client.HasLoadHandlers#addLoadHandler}instead
 */
@Deprecated void addLoadListener(LoadListener listener);"
82604,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasLoadHandlers#addLoadHandler}instead
 */
@Deprecated void removeLoadListener(LoadListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasLoadHandlers#addLoadHandler}instead
 */
@Deprecated void removeLoadListener(LoadListener listener);"
82605,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeMouseListener(MouseListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeMouseListener(MouseListener listener);"
82606,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use add* methods of {@link HasAllMouseHandlers} instead
 */
@Deprecated void addMouseListener(MouseListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use add* methods of{@link com.google.gwt.event.dom.client.HasAllMouseHandlers} instead
 */
@Deprecated void addMouseListener(MouseListener listener);"
82607,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated Use {@link HasMouseWheelHandlers#addMouseWheelHandler} instead
 */
@Deprecated void addMouseWheelListener(MouseWheelListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated Use{@link com.google.gwt.event.dom.client.HasMouseWheelHandlers#addMouseWheelHandler}instead
 */
@Deprecated void addMouseWheelListener(MouseWheelListener listener);"
82608,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by  {@link HasMouseWheelHandlers#addMouseWheelHandler} instead
 */
@Deprecated void removeMouseWheelListener(MouseWheelListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasMouseWheelHandlers#addMouseWheelHandler}instead
 */
@Deprecated void removeMouseWheelListener(MouseWheelListener listener);"
82609,"/** 
 * Adds a listener interface to receive popup events.
 * @param listener the listener interface to add.
 * @deprecated use {@link HasCloseHandlers#addCloseHandler} instead
 */
@Deprecated void addPopupListener(PopupListener listener);","/** 
 * Adds a listener interface to receive popup events.
 * @param listener the listener interface to add.
 * @deprecated use{@link com.google.gwt.event.logical.shared.HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void addPopupListener(PopupListener listener);"
82610,"/** 
 * Removes a previously added popup listener.
 * @param listener the listener interface to remove.
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void removePopupListener(PopupListener listener);","/** 
 * Removes a previously added popup listener.
 * @param listener the listener interface to remove.
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.logical.shared.HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void removePopupListener(PopupListener listener);"
82611,"public static long parseLong(String orig,int intRadix) throws NumberFormatException {
  if (orig == null) {
    throw new NumberFormatException(""String_Node_Str"");
  }
  if (orig.length() == 0) {
    throw NumberFormatException.forInputString(orig);
  }
  if (intRadix < Character.MIN_RADIX || intRadix > Character.MAX_RADIX) {
    throw new NumberFormatException(""String_Node_Str"" + intRadix + ""String_Node_Str"");
  }
  boolean neg=false;
  String s;
  if (orig.charAt(0) == '-') {
    neg=true;
    s=orig.substring(1);
  }
 else {
    s=orig;
  }
  long result=0;
  if (intRadix == 16) {
    result=parseHex(s);
  }
 else {
    long radix=intRadix;
    for (int i=0, len=s.length(); i < len; ++i) {
      if (result < 0) {
        throw NumberFormatException.forInputString(s);
      }
      result*=radix;
      char c=s.charAt(i);
      int value=Character.digit(c,intRadix);
      if (value < 0) {
        throw NumberFormatException.forInputString(s);
      }
      result+=value;
    }
  }
  if (result < 0 && result != MIN_VALUE) {
    throw NumberFormatException.forInputString(s);
  }
  if (neg) {
    return -result;
  }
 else {
    return result;
  }
}","public static long parseLong(String orig,int intRadix) throws NumberFormatException {
  if (orig == null) {
    throw new NumberFormatException(""String_Node_Str"");
  }
  if (orig.length() == 0) {
    throw NumberFormatException.forInputString(orig);
  }
  if (intRadix < Character.MIN_RADIX || intRadix > Character.MAX_RADIX) {
    throw new NumberFormatException(""String_Node_Str"" + intRadix + ""String_Node_Str"");
  }
  boolean neg=false;
  String s;
  if (orig.charAt(0) == '-') {
    neg=true;
    s=orig.substring(1);
    if (s.equals(""String_Node_Str"")) {
      throw NumberFormatException.forInputString(orig);
    }
  }
 else {
    s=orig;
  }
  long result=0;
  if (intRadix == 16) {
    result=parseHex(s);
  }
 else {
    long radix=intRadix;
    for (int i=0, len=s.length(); i < len; ++i) {
      if (result < 0) {
        throw NumberFormatException.forInputString(s);
      }
      result*=radix;
      char c=s.charAt(i);
      int value=Character.digit(c,intRadix);
      if (value < 0) {
        throw NumberFormatException.forInputString(s);
      }
      result+=value;
    }
  }
  if (result < 0 && result != MIN_VALUE) {
    throw NumberFormatException.forInputString(s);
  }
  if (neg) {
    return -result;
  }
 else {
    return result;
  }
}"
82612,"public void testParse(){
  assertEquals(0L,Long.parseLong(""String_Node_Str""));
  assertEquals(100000000000L,Long.parseLong(""String_Node_Str""));
  assertEquals(-100000000000L,Long.parseLong(""String_Node_Str""));
  assertEquals(10L,Long.parseLong(""String_Node_Str""));
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"",12);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  assertEquals(0L,Long.parseLong(""String_Node_Str"",12));
  assertEquals(73686780563L,Long.parseLong(""String_Node_Str"",12));
  assertEquals(-73686780563L,Long.parseLong(""String_Node_Str"",12));
  try {
    Long.parseLong(""String_Node_Str"",12);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  assertEquals(0L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(-1L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(1L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(0xdeadbeefdeadL,Long.parseLong(""String_Node_Str"",16));
  assertEquals(-0xdeadbeefdeadL,Long.parseLong(""String_Node_Str"",16));
  try {
    Long.parseLong(""String_Node_Str"",16);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"",16);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
}","public void testParse(){
  assertEquals(0L,Long.parseLong(""String_Node_Str""));
  assertEquals(100000000000L,Long.parseLong(""String_Node_Str""));
  assertEquals(-100000000000L,Long.parseLong(""String_Node_Str""));
  assertEquals(10L,Long.parseLong(""String_Node_Str""));
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"",12);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  assertEquals(0L,Long.parseLong(""String_Node_Str"",12));
  assertEquals(73686780563L,Long.parseLong(""String_Node_Str"",12));
  assertEquals(-73686780563L,Long.parseLong(""String_Node_Str"",12));
  try {
    Long.parseLong(""String_Node_Str"",12);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  assertEquals(0L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(-1L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(1L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(0xdeadbeefdeadL,Long.parseLong(""String_Node_Str"",16));
  assertEquals(-0xdeadbeefdeadL,Long.parseLong(""String_Node_Str"",16));
  try {
    Long.parseLong(""String_Node_Str"",16);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"",16);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
}"
82613,"/** 
 * Method subParseMonth parses Month field.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param cal DateRecord object that will hold parsed value
 * @param value numeric value if this field is expressed using numbericpattern
 * @param start from where parse start
 * @return <code>true</code> if parsing successful
 */
private boolean subParseMonth(String text,int[] pos,DateRecord cal,int value,int start){
  if (value < 0) {
    value=matchString(text,start,dateTimeConstants.months(),pos);
    if (value < 0) {
      value=matchString(text,start,dateTimeConstants.shortMonths(),pos);
    }
    if (value < 0) {
      return false;
    }
    cal.setMonth(value);
    return true;
  }
 else {
    cal.setMonth(value - 1);
    return true;
  }
}","/** 
 * Method subParseMonth parses Month field.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param cal DateRecord object that will hold parsed value
 * @param value numeric value if this field is expressed using numbericpattern
 * @param start from where parse start
 * @return <code>true</code> if parsing successful
 */
private boolean subParseMonth(String text,int[] pos,DateRecord cal,int value,int start){
  if (value < 0) {
    value=matchString(text,start,dateTimeConstants.months(),pos);
    if (value < 0) {
      value=matchString(text,start,dateTimeConstants.shortMonths(),pos);
    }
    if (value < 0) {
      return false;
    }
    cal.setMonth(value);
    return true;
  }
 else   if (value > 0) {
    cal.setMonth(value - 1);
    return true;
  }
  return false;
}"
82614,"/** 
 * Converts one field of the input string into a numeric field value. Returns <code>false</code> if failed.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param part the pattern part for this field
 * @param digitCount when greater than 0, numeric parsing must obey the count
 * @param cal DateRecord object that will hold parsed value
 * @return <code>true</code> if parsing successful
 */
@SuppressWarnings(""String_Node_Str"") private boolean subParse(String text,int[] pos,PatternPart part,int digitCount,DateRecord cal){
  skipSpace(text,pos);
  int start=pos[0];
  char ch=part.text.charAt(0);
  int value=-1;
  if (isNumeric(part)) {
    if (digitCount > 0) {
      if ((start + digitCount) > text.length()) {
        return false;
      }
      value=parseInt(text.substring(0,start + digitCount),pos);
    }
 else {
      value=parseInt(text,pos);
    }
  }
switch (ch) {
case 'G':
    value=matchString(text,start,dateTimeConstants.eras(),pos);
  cal.setEra(value);
return true;
case 'M':
return subParseMonth(text,pos,cal,value,start);
case 'E':
return subParseDayOfWeek(text,pos,start,cal);
case 'a':
value=matchString(text,start,dateTimeConstants.ampms(),pos);
cal.setAmpm(value);
return true;
case 'y':
return subParseYear(text,pos,start,value,part,cal);
case 'd':
cal.setDayOfMonth(value);
return true;
case 'S':
return subParseFractionalSeconds(value,start,pos[0],cal);
case 'h':
if (value == 12) {
value=0;
}
case 'K':
case 'H':
cal.setHours(value);
return true;
case 'k':
cal.setHours(value);
return true;
case 'm':
cal.setMinutes(value);
return true;
case 's':
cal.setSeconds(value);
return true;
case 'z':
case 'Z':
case 'v':
return subParseTimeZoneInGMT(text,start,pos,cal);
default :
return false;
}
}","/** 
 * Converts one field of the input string into a numeric field value. Returns <code>false</code> if failed.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param part the pattern part for this field
 * @param digitCount when greater than 0, numeric parsing must obey the count
 * @param cal DateRecord object that will hold parsed value
 * @return <code>true</code> if parsing successful
 */
@SuppressWarnings(""String_Node_Str"") private boolean subParse(String text,int[] pos,PatternPart part,int digitCount,DateRecord cal){
  skipSpace(text,pos);
  int start=pos[0];
  char ch=part.text.charAt(0);
  int value=-1;
  if (isNumeric(part)) {
    if (digitCount > 0) {
      if ((start + digitCount) > text.length()) {
        return false;
      }
      value=parseInt(text.substring(0,start + digitCount),pos);
    }
 else {
      value=parseInt(text,pos);
    }
  }
switch (ch) {
case 'G':
    value=matchString(text,start,dateTimeConstants.eras(),pos);
  cal.setEra(value);
return true;
case 'M':
return subParseMonth(text,pos,cal,value,start);
case 'E':
return subParseDayOfWeek(text,pos,start,cal);
case 'a':
value=matchString(text,start,dateTimeConstants.ampms(),pos);
cal.setAmpm(value);
return true;
case 'y':
return subParseYear(text,pos,start,value,part,cal);
case 'd':
if (value <= 0) {
return false;
}
cal.setDayOfMonth(value);
return true;
case 'S':
return subParseFractionalSeconds(value,start,pos[0],cal);
case 'h':
if (value == 12) {
value=0;
}
case 'K':
case 'H':
cal.setHours(value);
return true;
case 'k':
cal.setHours(value);
return true;
case 'm':
cal.setMinutes(value);
return true;
case 's':
cal.setSeconds(value);
return true;
case 'z':
case 'Z':
case 'v':
return subParseTimeZoneInGMT(text,start,pos,cal);
default :
return false;
}
}"
82615,"/** 
 * Maps each split point number to its corresponding generated <code>runAsync</code> method. If that method has been discarded, then map the split point number to <code>null</code>.
 */
private static Map<Integer,JMethod> findRunAsyncMethods(JProgram program) throws NumberFormatException {
  Map<Integer,JMethod> splitPointToLoadMethod=new HashMap<Integer,JMethod>();
  for (  JReferenceType type : program.getDeclaredTypes()) {
    Matcher matcher=LOADER_CLASS_PATTERN.matcher(type.getName());
    if (matcher.matches()) {
      int sp=Integer.parseInt(matcher.group(1));
      JMethod loadMethod=null;
      for (      JMethod meth : type.methods) {
        if (meth.getName().equals(FragmentLoaderCreator.LOADER_METHOD_RUN_ASYNC)) {
          loadMethod=meth;
        }
      }
      splitPointToLoadMethod.put(sp,loadMethod);
    }
  }
  return splitPointToLoadMethod;
}","/** 
 * Maps each split point number to its corresponding generated <code>runAsync</code> method. If that method has been discarded, then map the split point number to <code>null</code>.
 */
private static Map<Integer,JMethod> findRunAsyncMethods(JProgram program) throws NumberFormatException {
  Map<Integer,JMethod> splitPointToLoadMethod=new HashMap<Integer,JMethod>();
  for (  JDeclaredType type : program.getDeclaredTypes()) {
    Matcher matcher=LOADER_CLASS_PATTERN.matcher(type.getName());
    if (matcher.matches()) {
      int sp=Integer.parseInt(matcher.group(1));
      JMethod loadMethod=null;
      for (      JMethod meth : type.getMethods()) {
        if (meth.getName().equals(FragmentLoaderCreator.LOADER_METHOD_RUN_ASYNC)) {
          loadMethod=meth;
        }
      }
      splitPointToLoadMethod.put(sp,loadMethod);
    }
  }
  return splitPointToLoadMethod;
}"
82616,"public static double[] shr(double[] a,int n){
  n&=63;
  double shiftFact=pwrAsDouble(n);
  double newHigh=a[HIGH] / shiftFact;
  double newLow=Math.floor(a[LOW] / shiftFact);
  return create(newLow,newHigh);
}","public static double[] shr(double[] a,int n){
  n&=63;
  double shiftFact=pwrAsDouble(n);
  double newHigh=Math.floor(a[HIGH] / shiftFact);
  double newLow=Math.floor(a[LOW] / shiftFact);
  return create(newLow,newHigh);
}"
82617,"public void testShift(){
  assertEquals(longFromBits(0xd048d115,0x9d159c00),LongLib.shl(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0x48d04,0x8d1159d1),LongLib.shr(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0x48d04,0x8d1159d1),LongLib.shru(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0xd048d115,0x9d159c00),LongLib.shl(longFromBits(0x92341234,0x45674567),10));
  assertEquals(longFromBits(0xffe48d04,0x8d1159d1),LongLib.shr(longFromBits(0x92341234,0x45674567),10));
  assertEquals(longFromBits(0x248d04,0x8d1159d1),LongLib.shru(longFromBits(0x92341234,0x45674567),10));
  assertEquals(LongLib.fromInt(-1),LongLib.shr(LongLib.fromInt(-1),10));
  assertEquals(LongLib.fromInt(-1 << 5),LongLib.shl(LongLib.fromInt(-1),5));
  assertEquals(LongLib.fromInt(-1),LongLib.shl(LongLib.fromInt(-1),0));
  assertEquals(LongLib.neg(LongLib.typeChange(0x4000000000000000L)),LongLib.shr(LongLib.shl(LongLib.fromInt(1),63),1));
  assertEquals(LongLib.fromInt(0),LongLib.shl(LongLib.shl(LongLib.fromInt(-1),32),32));
  assertEquals(Const.MIN_VALUE,LongLib.shl(Const.MIN_VALUE,0));
  assertEquals(LongLib.fromInt(0),LongLib.shl(Const.MIN_VALUE,1));
  assertEquals(longFromBits(0xfffffffc,0x00000000),LongLib.shr(LongLib.neg(longFromBits(8,0)),1));
  assertEquals(longFromBits(0x7ffffffc,0x0),LongLib.shru(LongLib.neg(longFromBits(8,0)),1));
}","public void testShift(){
  assertEquals(longFromBits(0xd048d115,0x9d159c00),LongLib.shl(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0x48d04,0x8d1159d1),LongLib.shr(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0x48d04,0x8d1159d1),LongLib.shru(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0xd048d115,0x9d159c00),LongLib.shl(longFromBits(0x92341234,0x45674567),10));
  assertEquals(longFromBits(0xffe48d04,0x8d1159d1),LongLib.shr(longFromBits(0x92341234,0x45674567),10));
  assertEquals(LongLib.fromInt(67108863),LongLib.shr(longFromBits(0xFFFFFFF,0xFFFFFFFF),34));
  assertEquals(longFromBits(0x248d04,0x8d1159d1),LongLib.shru(longFromBits(0x92341234,0x45674567),10));
  assertEquals(LongLib.fromInt(-1),LongLib.shr(LongLib.fromInt(-1),10));
  assertEquals(LongLib.fromInt(-1),LongLib.shr(LongLib.fromInt(-1),63));
  assertEquals(LongLib.fromInt(-1 << 5),LongLib.shl(LongLib.fromInt(-1),5));
  assertEquals(LongLib.fromInt(-1),LongLib.shl(LongLib.fromInt(-1),0));
  assertEquals(LongLib.neg(LongLib.typeChange(0x4000000000000000L)),LongLib.shr(LongLib.shl(LongLib.fromInt(1),63),1));
  assertEquals(LongLib.fromInt(0),LongLib.shl(LongLib.shl(LongLib.fromInt(-1),32),32));
  assertEquals(Const.MIN_VALUE,LongLib.shl(Const.MIN_VALUE,0));
  assertEquals(LongLib.fromInt(0),LongLib.shl(Const.MIN_VALUE,1));
  assertEquals(longFromBits(0xfffffffc,0x00000000),LongLib.shr(LongLib.neg(longFromBits(8,0)),1));
  assertEquals(longFromBits(0x7ffffffc,0x0),LongLib.shru(LongLib.neg(longFromBits(8,0)),1));
}"
82618,"/** 
 * Parses text to produce a numeric value. <p> The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated <code>pos</code> can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of <code>pos</code> is not changed. </p>
 * @param text the string to be parsed
 * @param inOutPos position to pass in and get back
 * @return a double value representing the parsed number, or <code>0.0</code>if the parse fails
 * @throws NumberFormatException if the text segment could not be converted into a number
 */
public double parse(String text,int[] inOutPos) throws NumberFormatException {
  int start=inOutPos[0];
  double ret=0.0;
  boolean gotPositivePrefix=text.startsWith(positivePrefix,inOutPos[0]);
  boolean gotNegativePrefix=text.startsWith(negativePrefix,inOutPos[0]);
  boolean gotPositiveSuffix=text.endsWith(positiveSuffix);
  boolean gotNegativeSuffix=text.endsWith(negativeSuffix);
  boolean gotPositive=gotPositivePrefix && gotPositiveSuffix;
  boolean gotNegative=gotNegativePrefix && gotNegativeSuffix;
  if (gotPositive && gotNegative) {
    if (positivePrefix.length() > negativePrefix.length()) {
      gotNegative=false;
    }
 else     if (positivePrefix.length() < negativePrefix.length()) {
      gotPositive=false;
    }
 else     if (positiveSuffix.length() > negativeSuffix.length()) {
      gotNegative=false;
    }
 else     if (positiveSuffix.length() < negativeSuffix.length()) {
      gotPositive=false;
    }
 else {
      gotNegative=false;
    }
  }
 else   if (!gotPositive && !gotNegative) {
    throw new NumberFormatException(text + ""String_Node_Str"");
  }
  String valueOnly=null;
  if (gotPositive) {
    inOutPos[0]+=positivePrefix.length();
    valueOnly=text.substring(inOutPos[0],text.length() - positiveSuffix.length());
  }
 else {
    inOutPos[0]+=negativePrefix.length();
    valueOnly=text.substring(inOutPos[0],text.length() - negativeSuffix.length());
  }
  if (valueOnly.equals(numberConstants.infinity())) {
    inOutPos[0]+=numberConstants.infinity().length();
    ret=Double.POSITIVE_INFINITY;
  }
 else   if (valueOnly.equals(numberConstants.notANumber())) {
    inOutPos[0]+=numberConstants.notANumber().length();
    ret=Double.NaN;
  }
 else {
    int[] tempPos={0};
    ret=parseNumber(valueOnly,tempPos);
    inOutPos[0]+=tempPos[0];
  }
  if (gotPositive) {
    inOutPos[0]+=positiveSuffix.length();
  }
 else   if (gotNegative) {
    inOutPos[0]+=negativeSuffix.length();
  }
  if (gotNegative) {
    ret=-ret;
  }
  return ret;
}","/** 
 * Parses text to produce a numeric value. <p> The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated <code>pos</code> can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of <code>pos</code> is not changed. </p>
 * @param text the string to be parsed
 * @param inOutPos position to pass in and get back
 * @return a double value representing the parsed number, or <code>0.0</code>if the parse fails
 * @throws NumberFormatException if the text segment could not be converted into a number
 */
public double parse(String text,int[] inOutPos) throws NumberFormatException {
  double ret=0.0;
  boolean gotPositivePrefix=text.startsWith(positivePrefix,inOutPos[0]);
  boolean gotNegativePrefix=text.startsWith(negativePrefix,inOutPos[0]);
  boolean gotPositiveSuffix=text.endsWith(positiveSuffix);
  boolean gotNegativeSuffix=text.endsWith(negativeSuffix);
  boolean gotPositive=gotPositivePrefix && gotPositiveSuffix;
  boolean gotNegative=gotNegativePrefix && gotNegativeSuffix;
  if (gotPositive && gotNegative) {
    if (positivePrefix.length() > negativePrefix.length()) {
      gotNegative=false;
    }
 else     if (positivePrefix.length() < negativePrefix.length()) {
      gotPositive=false;
    }
 else     if (positiveSuffix.length() > negativeSuffix.length()) {
      gotNegative=false;
    }
 else     if (positiveSuffix.length() < negativeSuffix.length()) {
      gotPositive=false;
    }
 else {
      gotNegative=false;
    }
  }
 else   if (!gotPositive && !gotNegative) {
    throw new NumberFormatException(text + ""String_Node_Str"");
  }
  String valueOnly=null;
  if (gotPositive) {
    inOutPos[0]+=positivePrefix.length();
    valueOnly=text.substring(inOutPos[0],text.length() - positiveSuffix.length());
  }
 else {
    inOutPos[0]+=negativePrefix.length();
    valueOnly=text.substring(inOutPos[0],text.length() - negativeSuffix.length());
  }
  if (valueOnly.equals(numberConstants.infinity())) {
    inOutPos[0]+=numberConstants.infinity().length();
    ret=Double.POSITIVE_INFINITY;
  }
 else   if (valueOnly.equals(numberConstants.notANumber())) {
    inOutPos[0]+=numberConstants.notANumber().length();
    ret=Double.NaN;
  }
 else {
    int[] tempPos={0};
    ret=parseNumber(valueOnly,tempPos);
    inOutPos[0]+=tempPos[0];
  }
  if (gotPositive) {
    inOutPos[0]+=positiveSuffix.length();
  }
 else   if (gotNegative) {
    inOutPos[0]+=negativeSuffix.length();
  }
  if (gotNegative) {
    ret=-ret;
  }
  return ret;
}"
82619,"/** 
 * Returns the   {@link Class} which can serialize the given instance type. Notethat arrays never have custom field serializers.
 */
public static Class<?> hasCustomFieldSerializer(Class<?> instanceType){
  assert(instanceType != null);
  if (instanceType.isArray()) {
    return null;
  }
  Class<?> result=getCachedSerializerForClass(instanceType);
  if (result != null) {
    return result;
  }
  if (containsCachedSerializerForClass(instanceType)) {
    if (instanceType.getName().equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      System.err.println(""String_Node_Str"");
    }
    return null;
  }
  result=computeHasCustomFieldSerializer(instanceType);
  putCachedSerializerForClass(instanceType,result);
  return result;
}","/** 
 * Returns the   {@link Class} which can serialize the given instance type, or<code>null</code> if this class has no custom field serializer. Note that arrays never have custom field serializers.
 */
public static Class<?> hasCustomFieldSerializer(Class<?> instanceType){
  assert(instanceType != null);
  if (instanceType.isArray()) {
    return null;
  }
  Class<?> result;
synchronized (classCustomSerializerCache) {
    result=classCustomSerializerCache.get(instanceType);
    if (result == null) {
      result=computeHasCustomFieldSerializer(instanceType);
      if (result == null) {
        result=instanceType;
      }
      classCustomSerializerCache.put(instanceType,result);
    }
  }
  return (result == instanceType) ? null : result;
}"
82620,"public static Field[] applyFieldSerializationPolicy(Class<?> clazz){
  Field[] serializableFields=getCachedSerializableFieldsForClass(clazz);
  if (serializableFields == null) {
    ArrayList<Field> fieldList=new ArrayList<Field>();
    Field[] fields=clazz.getDeclaredFields();
    for (    Field field : fields) {
      if (fieldQualifiesForSerialization(field)) {
        fieldList.add(field);
      }
    }
    serializableFields=fieldList.toArray(new Field[fieldList.size()]);
    Arrays.sort(serializableFields,0,serializableFields.length,FIELD_COMPARATOR);
    putCachedSerializableFieldsForClass(clazz,serializableFields);
  }
  return serializableFields;
}","/** 
 * Returns the fields of a particular class that can be considered for serialization. The returned list will be sorted into a canonical order to ensure consistent answers. TODO: this method needs a better name, I think.
 */
public static Field[] applyFieldSerializationPolicy(Class<?> clazz){
  Field[] serializableFields;
synchronized (classSerializableFieldsCache) {
    serializableFields=classSerializableFieldsCache.get(clazz);
    if (serializableFields == null) {
      ArrayList<Field> fieldList=new ArrayList<Field>();
      Field[] fields=clazz.getDeclaredFields();
      for (      Field field : fields) {
        if (fieldQualifiesForSerialization(field)) {
          fieldList.add(field);
        }
      }
      serializableFields=fieldList.toArray(new Field[fieldList.size()]);
      Arrays.sort(serializableFields,0,serializableFields.length,FIELD_COMPARATOR);
      classSerializableFieldsCache.put(clazz,serializableFields);
    }
  }
  return serializableFields;
}"
82621,"public static String getSerializationSignature(Class<?> instanceType){
  String result=getCachedCRCForClass(instanceType);
  if (result == null) {
    CRC32 crc=new CRC32();
    try {
      generateSerializationSignature(instanceType,crc);
    }
 catch (    UnsupportedEncodingException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
    result=Long.toString(crc.getValue());
    putCachedCRCForClass(instanceType,result);
  }
  return result;
}","public static String getSerializationSignature(Class<?> instanceType){
  String result;
synchronized (classCRC32Cache) {
    result=classCRC32Cache.get(instanceType);
    if (result == null) {
      CRC32 crc=new CRC32();
      try {
        generateSerializationSignature(instanceType,crc);
      }
 catch (      UnsupportedEncodingException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
      result=Long.toString(crc.getValue());
      classCRC32Cache.put(instanceType,result);
    }
  }
  return result;
}"
82622,"String mangleNameForPolyImpl(JMethod x){
  String s=getNameString(x) + ""String_Node_Str"";
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    s+=type.getJavahSignatureName();
  }
  s+=x.getOriginalReturnType().getJavahSignatureName();
  return s;
}","String mangleNameForPolyImpl(JMethod x){
  StringBuffer sb=new StringBuffer();
  if (x.isPrivate() && !x.isStatic()) {
    sb.append(""String_Node_Str"");
    sb.append(getNameString(x.getEnclosingType()));
    sb.append(""String_Node_Str"");
  }
  sb.append(getNameString(x));
  sb.append(""String_Node_Str"");
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    sb.append(type.getJavahSignatureName());
  }
  sb.append(x.getOriginalReturnType().getJavahSignatureName());
  return sb.toString();
}"
82623,"/** 
 * Sets a cookie.
 * @param name the cookie's name
 * @param value the cookie's value
 * @param expires when the cookie expires
 * @param domain the domain to be associated with this cookie
 * @param path the path to be associated with this cookie
 * @param secure <code>true</code> to make this a secure cookie
 */
public static void setCookie(String name,String value,Date expires,String domain,String path,boolean secure){
  setCookieImpl(name,value,(expires == null) ? 0 : expires.getTime(),domain,path,secure);
}","/** 
 * Sets a cookie.
 * @param name the cookie's name
 * @param value the cookie's value
 * @param expires when the cookie expires
 * @param domain the domain to be associated with this cookie
 * @param path the path to be associated with this cookie
 * @param secure <code>true</code> to make this a secure cookie (that is,only accessible over an SSL connection)
 */
public static void setCookie(String name,String value,Date expires,String domain,String path,boolean secure){
  setCookieImpl(name,value,(expires == null) ? 0 : expires.getTime(),domain,path,secure);
}"
82624,"/** 
 * Find all Artifacts assignable to some base type. The returned value will be a snapshot of the values in the ArtifactSet. The following two examples result in an equivalent set: <pre> SortedSet&lt;EmittedArtifact&gt; search = artifactSet.find(PublicResource.class); search.addAll(artifactSet.find(GeneratedResource.class); </pre> or <pre> SortedSet&lt;EmittedArtifact&gt; search = artifactSet.find(EmittedArtifact.class); </pre>
 * @param < A > a type bound possibly wider than the desired type of artifact
 * @param < T > the desired type of Artifact
 * @param artifactType the desired type of Artifact
 * @return all Artifacts in the ArtifactSet assignable to the desired type
 */
public <A extends Artifact<?>,T extends A>SortedSet<A> find(Class<T> artifactType){
  SortedSet<A> toReturn=new TreeSet<A>();
  for (  Artifact<?> artifact : this) {
    if (artifactType.isInstance(artifact)) {
      toReturn.add(artifactType.cast(artifact));
    }
  }
  return toReturn;
}","/** 
 * Find all Artifacts assignable to some base type. The returned value will be a snapshot of the values in the ArtifactSet. An example of how this could be used: <pre> for (EmittedArtifact ea : artifactSet.find(EmittedArtifact.class)) { ... } </pre>
 * @param < T > the desired type of Artifact
 * @param artifactType the desired type of Artifact
 * @return all Artifacts in the ArtifactSet assignable to the desired type
 */
public <T extends Artifact<? super T>>SortedSet<T> find(Class<T> artifactType){
  SortedSet<T> toReturn=new TreeSet<T>();
  for (  Artifact<?> artifact : this) {
    if (artifactType.isInstance(artifact)) {
      toReturn.add(artifactType.cast(artifact));
    }
  }
  return toReturn;
}"
82625,"public int hashCode(){
  return treeSet.hashCode();
}","@Override public int hashCode(){
  return treeSet.hashCode();
}"
82626,"public boolean equals(Object o){
  return treeSet.equals(o);
}","@Override public boolean equals(Object o){
  return treeSet.equals(o);
}"
82627,"@Override public Widget createIssue(){
  htmlElement=DOM.getParent(RootPanel.getBodyElement());
  final SimplePanel positioner=new SimplePanel();
  positioner.setPixelSize(30,30);
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  final HTML echo=new HTML();
  final Label sandbox=new Label();
  sandbox.sinkEvents(Event.ONMOUSEMOVE);
  sandbox.setPixelSize(300,300);
  sandbox.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  sandbox.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  Event.addNativePreviewHandler(new NativePreviewHandler(){
    public void onPreviewNativeEvent(    NativePreviewEvent event){
      NativeEvent nativeEvent=event.getNativeEvent();
      Element target=nativeEvent.getTarget();
      if (!sandbox.getElement().isOrHasChild(target) && !positioner.getElement().isOrHasChild(target)) {
        positioner.removeFromParent();
        return;
      }
switch (Event.as(nativeEvent).getTypeInt()) {
case Event.ONMOUSEMOVE:
        int absX=nativeEvent.getClientX() + Window.getScrollLeft();
      int absY=nativeEvent.getClientY() + Window.getScrollTop();
    RootPanel.get().add(positioner,absX,absY);
  echo.setHTML(""String_Node_Str"" + nativeEvent.getClientX() + ""String_Node_Str""+ ""String_Node_Str""+ nativeEvent.getClientY()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteLeft()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteTop());
break;
}
}
}
);
VerticalPanel vPanel=new VerticalPanel();
vPanel.add(new ControlPanel());
vPanel.add(echo);
vPanel.add(sandbox);
return vPanel;
}","@Override public Widget createIssue(){
  htmlElement=DOM.getParent(RootPanel.getBodyElement());
  final SimplePanel positioner=new SimplePanel();
  positioner.setPixelSize(30,30);
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  final HTML echo=new HTML();
  final Label sandbox=new Label();
  sandbox.sinkEvents(Event.ONMOUSEMOVE);
  sandbox.setPixelSize(300,300);
  sandbox.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  sandbox.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  Event.addNativePreviewHandler(new NativePreviewHandler(){
    public void onPreviewNativeEvent(    NativePreviewEvent event){
      NativeEvent nativeEvent=event.getNativeEvent();
      Element target=Element.as(nativeEvent.getEventTarget());
      if (!sandbox.getElement().isOrHasChild(target) && !positioner.getElement().isOrHasChild(target)) {
        positioner.removeFromParent();
        return;
      }
switch (Event.as(nativeEvent).getTypeInt()) {
case Event.ONMOUSEMOVE:
        int absX=nativeEvent.getClientX() + Window.getScrollLeft();
      int absY=nativeEvent.getClientY() + Window.getScrollTop();
    RootPanel.get().add(positioner,absX,absY);
  echo.setHTML(""String_Node_Str"" + nativeEvent.getClientX() + ""String_Node_Str""+ ""String_Node_Str""+ nativeEvent.getClientY()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteLeft()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteTop());
break;
}
}
}
);
VerticalPanel vPanel=new VerticalPanel();
vPanel.add(new ControlPanel());
vPanel.add(echo);
vPanel.add(sandbox);
return vPanel;
}"
82628,"public void onPreviewNativeEvent(NativePreviewEvent event){
  NativeEvent nativeEvent=event.getNativeEvent();
  Element target=nativeEvent.getTarget();
  if (!sandbox.getElement().isOrHasChild(target) && !positioner.getElement().isOrHasChild(target)) {
    positioner.removeFromParent();
    return;
  }
switch (Event.as(nativeEvent).getTypeInt()) {
case Event.ONMOUSEMOVE:
    int absX=nativeEvent.getClientX() + Window.getScrollLeft();
  int absY=nativeEvent.getClientY() + Window.getScrollTop();
RootPanel.get().add(positioner,absX,absY);
echo.setHTML(""String_Node_Str"" + nativeEvent.getClientX() + ""String_Node_Str""+ ""String_Node_Str""+ nativeEvent.getClientY()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteLeft()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteTop());
break;
}
}","public void onPreviewNativeEvent(NativePreviewEvent event){
  NativeEvent nativeEvent=event.getNativeEvent();
  Element target=Element.as(nativeEvent.getEventTarget());
  if (!sandbox.getElement().isOrHasChild(target) && !positioner.getElement().isOrHasChild(target)) {
    positioner.removeFromParent();
    return;
  }
switch (Event.as(nativeEvent).getTypeInt()) {
case Event.ONMOUSEMOVE:
    int absX=nativeEvent.getClientX() + Window.getScrollLeft();
  int absY=nativeEvent.getClientY() + Window.getScrollTop();
RootPanel.get().add(positioner,absX,absY);
echo.setHTML(""String_Node_Str"" + nativeEvent.getClientX() + ""String_Node_Str""+ ""String_Node_Str""+ nativeEvent.getClientY()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteLeft()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteTop());
break;
}
}"
82629,"private String getBinaryOrPrimitiveName(JType type){
  JClassType asClass=type.isClassOrInterface();
  JPrimitiveType asPrimitive=type.isPrimitive();
  if (asClass != null) {
    return getBinaryName(asClass);
  }
 else   if (asPrimitive != null) {
    return asPrimitive.getQualifiedSourceName();
  }
 else {
    throw new InternalCompilerException(""String_Node_Str"" + type.getQualifiedSourceName());
  }
}","private String getBinaryOrPrimitiveName(JType type){
  JArrayType asArray=type.isArray();
  JClassType asClass=type.isClassOrInterface();
  JPrimitiveType asPrimitive=type.isPrimitive();
  if (asClass != null) {
    return getBinaryName(asClass);
  }
 else   if (asPrimitive != null) {
    return asPrimitive.getQualifiedSourceName();
  }
 else   if (asArray != null) {
    JType componentType=asArray.getComponentType();
    return getBinaryOrPrimitiveName(componentType) + ""String_Node_Str"";
  }
 else {
    throw new InternalCompilerException(""String_Node_Str"" + type.getQualifiedSourceName());
  }
}"
82630,"public JExpression conditional(JConditional original,SourceInfo sourceInfo,JType type,JExpression condExpr,JExpression thenExpr,JExpression elseExpr){
  if (condExpr instanceof JMultiExpression) {
    JMultiExpression condMulti=(JMultiExpression)condExpr;
    JMultiExpression newMulti=new JMultiExpression(program,sourceInfo);
    newMulti.exprs.addAll(allButLast(condMulti.exprs));
    newMulti.exprs.add(conditional(null,sourceInfo,type,last(condMulti.exprs),thenExpr,elseExpr));
    return newMulti;
  }
  if (condExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)condExpr).getValue()) {
      return thenExpr;
    }
 else {
      return elseExpr;
    }
  }
 else   if (thenExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)thenExpr).getValue()) {
      JBinaryOperation binOp=new JBinaryOperation(program,original.getSourceInfo(),original.getType(),JBinaryOperator.OR,condExpr,elseExpr);
      return binOp;
    }
 else {
      JPrefixOperation notCondExpr=new JPrefixOperation(program,condExpr.getSourceInfo(),JUnaryOperator.NOT,condExpr);
      JBinaryOperation binOp=new JBinaryOperation(program,original.getSourceInfo(),original.getType(),JBinaryOperator.AND,notCondExpr,elseExpr);
      return binOp;
    }
  }
 else   if (elseExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)elseExpr).getValue()) {
      JPrefixOperation notCondExpr=new JPrefixOperation(program,condExpr.getSourceInfo(),JUnaryOperator.NOT,condExpr);
      JBinaryOperation binOp=new JBinaryOperation(program,original.getSourceInfo(),original.getType(),JBinaryOperator.OR,notCondExpr,thenExpr);
      return binOp;
    }
 else {
      JBinaryOperation binOp=new JBinaryOperation(program,original.getSourceInfo(),original.getType(),JBinaryOperator.AND,condExpr,thenExpr);
      return binOp;
    }
  }
 else {
    JExpression unflipped=maybeUnflipBoolean(condExpr);
    if (unflipped != null) {
      return new JConditional(program,original.getSourceInfo(),original.getType(),unflipped,elseExpr,thenExpr);
    }
  }
  if (original != null) {
    return original;
  }
  return new JConditional(program,sourceInfo,type,condExpr,thenExpr,elseExpr);
}","public JExpression conditional(JConditional original,SourceInfo sourceInfo,JType type,JExpression condExpr,JExpression thenExpr,JExpression elseExpr){
  if (condExpr instanceof JMultiExpression) {
    JMultiExpression condMulti=(JMultiExpression)condExpr;
    JMultiExpression newMulti=new JMultiExpression(program,sourceInfo);
    newMulti.exprs.addAll(allButLast(condMulti.exprs));
    newMulti.exprs.add(conditional(null,sourceInfo,type,last(condMulti.exprs),thenExpr,elseExpr));
    return newMulti;
  }
  if (condExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)condExpr).getValue()) {
      return thenExpr;
    }
 else {
      return elseExpr;
    }
  }
 else   if (thenExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)thenExpr).getValue()) {
      JBinaryOperation binOp=new JBinaryOperation(program,sourceInfo,type,JBinaryOperator.OR,condExpr,elseExpr);
      return binOp;
    }
 else {
      JPrefixOperation notCondExpr=new JPrefixOperation(program,condExpr.getSourceInfo(),JUnaryOperator.NOT,condExpr);
      JBinaryOperation binOp=new JBinaryOperation(program,sourceInfo,type,JBinaryOperator.AND,notCondExpr,elseExpr);
      return binOp;
    }
  }
 else   if (elseExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)elseExpr).getValue()) {
      JPrefixOperation notCondExpr=new JPrefixOperation(program,condExpr.getSourceInfo(),JUnaryOperator.NOT,condExpr);
      JBinaryOperation binOp=new JBinaryOperation(program,sourceInfo,type,JBinaryOperator.OR,notCondExpr,thenExpr);
      return binOp;
    }
 else {
      JBinaryOperation binOp=new JBinaryOperation(program,sourceInfo,type,JBinaryOperator.AND,condExpr,thenExpr);
      return binOp;
    }
  }
 else {
    JExpression unflipped=maybeUnflipBoolean(condExpr);
    if (unflipped != null) {
      return new JConditional(program,sourceInfo,type,unflipped,elseExpr,thenExpr);
    }
  }
  if (original != null) {
    return original;
  }
  return new JConditional(program,sourceInfo,type,condExpr,thenExpr,elseExpr);
}"
82631,"/** 
 * Retrieve the DateTimeFormat object for short date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortDateFormat(){
  if (cachedShortDateFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[SHORT_DATE_FORMAT];
    cachedShortDateFormat=new DateTimeFormat(pattern);
  }
  return cachedShortDateFormat;
}","/** 
 * Retrieve the DateTimeFormat object for short date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortDateFormat(){
  if (cachedShortDateFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[SHORT_DATE_FORMAT];
    cachedShortDateFormat=new DateTimeFormat(pattern);
  }
  return cachedShortDateFormat;
}"
82632,"/** 
 * Retrieve the DateTimeFormat object for medium date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumDateFormat(){
  if (cachedMediumDateFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[MEDIUM_DATE_FORMAT];
    cachedMediumDateFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumDateFormat;
}","/** 
 * Retrieve the DateTimeFormat object for medium date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumDateFormat(){
  if (cachedMediumDateFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[MEDIUM_DATE_FORMAT];
    cachedMediumDateFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumDateFormat;
}"
82633,"/** 
 * Returns a DateTimeFormat object using the specified pattern. If you need to format or parse repeatedly using the same pattern, it is highly recommended that you cache the returned <code>DateTimeFormat</code> object and reuse it rather than calling this method repeatedly.
 * @param pattern string to specify how the date should be formatted
 * @return a <code>DateTimeFormat</code> object that can be used for format orparse date/time values matching the specified pattern
 * @throws IllegalArgumentException if the specified pattern could not beparsed
 */
public static DateTimeFormat getFormat(String pattern){
  return new DateTimeFormat(pattern,defaultDateTimeConstants);
}","/** 
 * Returns a DateTimeFormat object using the specified pattern. If you need to format or parse repeatedly using the same pattern, it is highly recommended that you cache the returned <code>DateTimeFormat</code> object and reuse it rather than calling this method repeatedly.
 * @param pattern string to specify how the date should be formatted
 * @return a <code>DateTimeFormat</code> object that can be used for format orparse date/time values matching the specified pattern
 * @throws IllegalArgumentException if the specified pattern could not beparsed
 */
public static DateTimeFormat getFormat(String pattern){
  return new DateTimeFormat(pattern,getDefaultDateTimeConstants());
}"
82634,"/** 
 * Retrieve the DateTimeFormat object for medium date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumDateTimeFormat(){
  if (cachedMediumDateTimeFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[MEDIUM_DATE_FORMAT] + ""String_Node_Str"" + defaultDateTimeConstants.timeFormats()[MEDIUM_TIME_FORMAT];
    cachedMediumDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumDateTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for medium date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumDateTimeFormat(){
  if (cachedMediumDateTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[MEDIUM_DATE_FORMAT] + ""String_Node_Str"" + getDefaultDateTimeConstants().timeFormats()[MEDIUM_TIME_FORMAT];
    cachedMediumDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumDateTimeFormat;
}"
82635,"/** 
 * Retrieve the DateTimeFormat object for short date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortDateTimeFormat(){
  if (cachedShortDateTimeFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[SHORT_DATE_FORMAT] + ""String_Node_Str"" + defaultDateTimeConstants.timeFormats()[SHORT_TIME_FORMAT];
    cachedShortDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedShortDateTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for short date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortDateTimeFormat(){
  if (cachedShortDateTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[SHORT_DATE_FORMAT] + ""String_Node_Str"" + getDefaultDateTimeConstants().timeFormats()[SHORT_TIME_FORMAT];
    cachedShortDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedShortDateTimeFormat;
}"
82636,"/** 
 * Retrieve the DateTimeFormat object for long date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongDateFormat(){
  if (cachedLongDateFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[LONG_DATE_FORMAT];
    cachedLongDateFormat=new DateTimeFormat(pattern);
  }
  return cachedLongDateFormat;
}","/** 
 * Retrieve the DateTimeFormat object for long date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongDateFormat(){
  if (cachedLongDateFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[LONG_DATE_FORMAT];
    cachedLongDateFormat=new DateTimeFormat(pattern);
  }
  return cachedLongDateFormat;
}"
82637,"/** 
 * Retrieve the DateTimeFormat object for short time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortTimeFormat(){
  if (cachedShortTimeFormat == null) {
    String pattern=defaultDateTimeConstants.timeFormats()[SHORT_TIME_FORMAT];
    cachedShortTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedShortTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for short time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortTimeFormat(){
  if (cachedShortTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().timeFormats()[SHORT_TIME_FORMAT];
    cachedShortTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedShortTimeFormat;
}"
82638,"/** 
 * Retrieve the DateTimeFormat object for long time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongTimeFormat(){
  if (cachedLongTimeFormat == null) {
    String pattern=defaultDateTimeConstants.timeFormats()[LONG_TIME_FORMAT];
    cachedLongTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedLongTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for long time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongTimeFormat(){
  if (cachedLongTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().timeFormats()[LONG_TIME_FORMAT];
    cachedLongTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedLongTimeFormat;
}"
82639,"/** 
 * Retrieve the DateTimeFormat object for full time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullTimeFormat(){
  if (cachedFullTimeFormat == null) {
    String pattern=defaultDateTimeConstants.timeFormats()[FULL_TIME_FORMAT];
    cachedFullTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedFullTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for full time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullTimeFormat(){
  if (cachedFullTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().timeFormats()[FULL_TIME_FORMAT];
    cachedFullTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedFullTimeFormat;
}"
82640,"/** 
 * Retrieve the DateTimeFormat object for full date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullDateTimeFormat(){
  if (cachedFullDateTimeFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[FULL_DATE_FORMAT] + ""String_Node_Str"" + defaultDateTimeConstants.timeFormats()[FULL_TIME_FORMAT];
    cachedFullDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedFullDateTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for full date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullDateTimeFormat(){
  if (cachedFullDateTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[FULL_DATE_FORMAT] + ""String_Node_Str"" + getDefaultDateTimeConstants().timeFormats()[FULL_TIME_FORMAT];
    cachedFullDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedFullDateTimeFormat;
}"
82641,"/** 
 * Retrieve the DateTimeFormat object for long date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongDateTimeFormat(){
  if (cachedLongDateTimeFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[LONG_DATE_FORMAT] + ""String_Node_Str"" + defaultDateTimeConstants.timeFormats()[LONG_TIME_FORMAT];
    cachedLongDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedLongDateTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for long date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongDateTimeFormat(){
  if (cachedLongDateTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[LONG_DATE_FORMAT] + ""String_Node_Str"" + getDefaultDateTimeConstants().timeFormats()[LONG_TIME_FORMAT];
    cachedLongDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedLongDateTimeFormat;
}"
82642,"/** 
 * Retrieve the DateTimeFormat object for medium time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumTimeFormat(){
  if (cachedMediumTimeFormat == null) {
    String pattern=defaultDateTimeConstants.timeFormats()[MEDIUM_TIME_FORMAT];
    cachedMediumTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for medium time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumTimeFormat(){
  if (cachedMediumTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().timeFormats()[MEDIUM_TIME_FORMAT];
    cachedMediumTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumTimeFormat;
}"
82643,"/** 
 * Retrieve the DateTimeFormat object for full date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullDateFormat(){
  if (cachedFullDateFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[FULL_DATE_FORMAT];
    cachedFullDateFormat=new DateTimeFormat(pattern);
  }
  return cachedFullDateFormat;
}","/** 
 * Retrieve the DateTimeFormat object for full date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullDateFormat(){
  if (cachedFullDateFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[FULL_DATE_FORMAT];
    cachedFullDateFormat=new DateTimeFormat(pattern);
  }
  return cachedFullDateFormat;
}"
82644,"/** 
 * Gets the day of week formatter.
 * @return the day of week formatter
 */
protected DateTimeFormat getDayOfWeekFormatter(){
  return dayOfWeekFormatter;
}","/** 
 * Gets the day of week formatter.
 * @return the day of week formatter
 */
protected DateTimeFormat getDayOfWeekFormatter(){
  return DateTimeFormat.getFormat(""String_Node_Str"");
}"
82645,"/** 
 * Gets the month and year formatter.
 * @return the month and year formatter
 */
protected DateTimeFormat getMonthAndYearFormatter(){
  return monthAndYearFormatter;
}","/** 
 * Gets the month and year formatter.
 * @return the month and year formatter
 */
protected DateTimeFormat getMonthAndYearFormatter(){
  return DateTimeFormat.getFormat(""String_Node_Str"");
}"
82646,"/** 
 * Gets the date of month formatter.
 * @return the day of month formatter
 */
protected DateTimeFormat getDayOfMonthFormatter(){
  return dayOfMonthFormatter;
}","/** 
 * Gets the date of month formatter.
 * @return the day of month formatter
 */
protected DateTimeFormat getDayOfMonthFormatter(){
  return DateTimeFormat.getFormat(""String_Node_Str"");
}"
82647,"private String generateRuntimeSelection(TreeLogger logger,GeneratorContext context,JClassType targetClass,GwtLocale compileLocale,Set<GwtLocale> locales) throws UnableToCompleteException {
  String packageName=targetClass.getPackage().getName();
  String className=targetClass.getName().replace('.','_') + ""String_Node_Str"" + compileLocale.getAsString()+ ""String_Node_Str"";
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.setSuperclass(targetClass.getQualifiedSourceName());
    factory.addImport(CURRENCY_LIST);
    factory.addImport(CURRENCY_DATA);
    factory.addImport(""String_Node_Str"");
    SourceWriter writer=factory.createSourceWriter(context,pw);
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.indent();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    boolean fetchedLocale=false;
    Map<String,Set<GwtLocale>> localeMap=new HashMap<String,Set<GwtLocale>>();
    String compileLocaleClass=processChildLocale(logger,context,targetClass,localeMap,compileLocale);
    if (compileLocaleClass == null) {
      return null;
    }
    for (    GwtLocale runtimeLocale : locales) {
      processChildLocale(logger,context,targetClass,localeMap,runtimeLocale);
    }
    for (    Entry<String,Set<GwtLocale>> entry : localeMap.entrySet()) {
      if (!fetchedLocale) {
        writer.println(""String_Node_Str"");
        fetchedLocale=true;
      }
      boolean firstLocale=true;
      String generatedClass=entry.getKey();
      if (compileLocaleClass.equals(generatedClass)) {
        continue;
      }
      writer.print(""String_Node_Str"");
      for (      GwtLocale locale : entry.getValue()) {
        if (firstLocale) {
          firstLocale=false;
        }
 else {
          writer.println();
          writer.print(""String_Node_Str"");
        }
        writer.print(""String_Node_Str"" + locale.toString() + ""String_Node_Str"");
      }
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"" + generatedClass + ""String_Node_Str"");
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"");
    }
    writer.println(""String_Node_Str"" + compileLocaleClass + ""String_Node_Str"");
    writer.outdent();
    writer.println(""String_Node_Str"");
    writer.commit(logger);
  }
  return packageName + ""String_Node_Str"" + className;
}","private String generateRuntimeSelection(TreeLogger logger,GeneratorContext context,JClassType targetClass,GwtLocale compileLocale,Set<GwtLocale> locales) throws UnableToCompleteException {
  String packageName=targetClass.getPackage().getName();
  String className=targetClass.getName().replace('.','_') + ""String_Node_Str"" + compileLocale.getAsString()+ ""String_Node_Str"";
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.setSuperclass(targetClass.getQualifiedSourceName());
    factory.addImport(CURRENCY_LIST);
    factory.addImport(CURRENCY_DATA);
    factory.addImport(""String_Node_Str"");
    SourceWriter writer=factory.createSourceWriter(context,pw);
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.indent();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    boolean fetchedLocale=false;
    Map<String,Set<GwtLocale>> localeMap=new HashMap<String,Set<GwtLocale>>();
    String compileLocaleClass=processChildLocale(logger,context,targetClass,localeMap,compileLocale);
    if (compileLocaleClass == null) {
      return null;
    }
    for (    GwtLocale runtimeLocale : locales) {
      processChildLocale(logger,context,targetClass,localeMap,runtimeLocale);
    }
    for (    Entry<String,Set<GwtLocale>> entry : localeMap.entrySet()) {
      if (!fetchedLocale) {
        writer.println(""String_Node_Str"");
        fetchedLocale=true;
      }
      boolean firstLocale=true;
      String generatedClass=entry.getKey();
      if (compileLocaleClass.equals(generatedClass)) {
        continue;
      }
      writer.print(""String_Node_Str"");
      for (      GwtLocale locale : entry.getValue()) {
        if (firstLocale) {
          firstLocale=false;
        }
 else {
          writer.println();
          writer.print(""String_Node_Str"");
        }
        writer.print(""String_Node_Str"" + locale.toString() + ""String_Node_Str"");
      }
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"" + generatedClass + ""String_Node_Str"");
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"");
    }
    writer.println(""String_Node_Str"" + compileLocaleClass + ""String_Node_Str"");
    writer.outdent();
    writer.println(""String_Node_Str"");
    writer.commit(logger);
  }
  return packageName + ""String_Node_Str"" + className;
}"
82648,"private void generateOnLoadMethod(PrintWriter srcWriter){
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(""String_Node_Str"" + getLoaderSimpleName() + ""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
}","private void generateOnLoadMethod(PrintWriter srcWriter){
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(""String_Node_Str"" + getLoaderSimpleName() + ""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
}"
82649,"/** 
 * Create an event object suitable for submitting to the lightweight metrics framework.
 */
private static native JavaScriptObject createStatsEvent(String eventGroup,String type);","private static native JavaScriptObject createStatsEvent(String eventGroup,String type,Integer fragment,Integer size);"
82650,"/** 
 * Logs an event with the GWT lightweight metrics framework.
 */
public static void logEventProgress(String eventGroup,String type){
  @SuppressWarnings(""String_Node_Str"") boolean toss=isStatsAvailable() && stats(createStatsEvent(eventGroup,type));
}","/** 
 * Log an event with the lightweight metrics framework. The <code>fragment</code> and <code>size</code> objects are allowed to be <code>null</code>.
 */
private static void logEventProgress(String eventGroup,String type,Integer fragment,Integer size){
  @SuppressWarnings(""String_Node_Str"") boolean toss=isStatsAvailable() && stats(createStatsEvent(eventGroup,type,fragment,size));
}"
82651,"/** 
 * Inform the loader that the ""leftovers"" fragment has loaded.
 */
public static void leftoversFragmentHasLoaded(){
  leftoversLoaded=true;
  leftoversLoading=false;
  while (!waitingForLeftovers.isEmpty()) {
    inject(waitingForLeftovers.remove());
  }
}","/** 
 * Inform the loader that the ""leftovers"" fragment has loaded.
 */
public static void leftoversFragmentHasLoaded(){
  leftoversLoaded=true;
  leftoversLoading=false;
  logEventProgress(LwmLabels.LEFTOVERS_DOWNLOAD,LwmLabels.END,leftoversFragmentNumber(),null);
  while (!waitingForLeftovers.isEmpty()) {
    inject(waitingForLeftovers.remove());
  }
}"
82652,"/** 
 * Inform the loader that the code for an entry point has now finished loading.
 * @param entry The entry whose code fragment is now loaded.
 */
public static void fragmentHasLoaded(int entry){
  if (base < 0) {
    base=entry;
    baseLoading=false;
    leftoversLoading=true;
    startLoadingFragment(numEntries + 2 * (entry - 1) + 1);
  }
}","/** 
 * Inform the loader that the code for an entry point has now finished loading.
 * @param entry The entry whose code fragment is now loaded.
 */
public static void fragmentHasLoaded(int entry){
  int fragment=base >= 0 ? entry : baseFragmentNumber(entry);
  logEventProgress(LwmLabels.downloadGroup(entry),LwmLabels.END,fragment,null);
  if (base < 0) {
    base=entry;
    baseLoading=false;
    leftoversLoading=true;
    logEventProgress(LwmLabels.LEFTOVERS_DOWNLOAD,LwmLabels.BEGIN,leftoversFragmentNumber(),null);
    startLoadingFragment(leftoversFragmentNumber());
  }
}"
82653,"/** 
 * Loads the specified split point.
 * @param splitPoint the fragment to load
 */
public static void inject(int splitPoint){
  if (leftoversLoaded) {
    startLoadingFragment(splitPoint);
    return;
  }
  if (baseLoading || leftoversLoading) {
    waitingForLeftovers.add(splitPoint);
    return;
  }
  baseLoading=true;
  startLoadingFragment(numEntries + 2 * (splitPoint - 1));
}","/** 
 * Loads the specified split point.
 * @param splitPoint the fragment to load
 */
public static void inject(int splitPoint){
  if (leftoversLoaded) {
    logEventProgress(LwmLabels.downloadGroup(splitPoint),LwmLabels.BEGIN,splitPoint,null);
    startLoadingFragment(splitPoint);
    return;
  }
  if (baseLoading || leftoversLoading) {
    waitingForLeftovers.add(splitPoint);
    return;
  }
  baseLoading=true;
  logEventProgress(LwmLabels.downloadGroup(splitPoint),LwmLabels.BEGIN,baseFragmentNumber(splitPoint),null);
  startLoadingFragment(baseFragmentNumber(splitPoint));
}"
82654,"private static void startLoadingFragment(int fragment){
  logEventProgress(""String_Node_Str"" + fragment,""String_Node_Str"");
  gwtStartLoadingFragment(fragment);
}","private static void startLoadingFragment(int fragment){
  gwtStartLoadingFragment(fragment);
}"
82655,"/** 
 * Compare two methods based on name and original argument types  {@link JMethod#getOriginalParamTypes()}. Note that nothing special is done here regarding methods with type parameters in their argument lists. The caller must be careful that this level of matching is sufficient.
 */
private static boolean methodsDoMatch(JMethod method1,JMethod method2){
  if (method1.isStatic() || method2.isStatic()) {
    return false;
  }
  if (!method1.getName().equals(method2.getName())) {
    return false;
  }
  List<JType> params1=method1.getOriginalParamTypes();
  List<JType> params2=method2.getOriginalParamTypes();
  int params1size=params1.size();
  if (params1size != params2.size()) {
    return false;
  }
  for (int i=0; i < params1size; ++i) {
    if (params1.get(i) != params2.get(i)) {
      return false;
    }
  }
  return true;
}","/** 
 * Compare two methods based on name and original argument types  {@link JMethod#getOriginalParamTypes()}. Note that nothing special is done here regarding methods with type parameters in their argument lists. The caller must be careful that this level of matching is sufficient.
 */
public static boolean methodsDoMatch(JMethod method1,JMethod method2){
  if (method1.isStatic() || method2.isStatic()) {
    return false;
  }
  if (!method1.getName().equals(method2.getName())) {
    return false;
  }
  List<JType> params1=method1.getOriginalParamTypes();
  List<JType> params2=method2.getOriginalParamTypes();
  int params1size=params1.size();
  if (params1size != params2.size()) {
    return false;
  }
  for (int i=0; i < params1size; ++i) {
    if (params1.get(i) != params2.get(i)) {
      return false;
    }
  }
  return true;
}"
82656,"@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes=findClassBytes(className);
  if (classBytes == null) {
    throw new ClassNotFoundException(className);
  }
  Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
  if (className.equals(JavaScriptHost.class.getName())) {
    javaScriptHostClass=newClass;
    updateJavaScriptHost();
  }
  if (!classRewriter.isJsoIntf(className)) {
    CompiledClass compiledClass=compilationState.getClassFileMap().get(canonicalizeClassName(className));
    if (compiledClass != null) {
      toInject.push(compiledClass);
    }
  }
  if (!isInjectingClass) {
    try {
      isInjectingClass=true;
      while (toInject.size() > 0) {
        injectJsniFor(toInject.remove(0));
      }
    }
  finally {
      isInjectingClass=false;
    }
  }
  if (className.equals(""String_Node_Str"")) {
    gwtClass=newClass;
    updateGwtClass();
  }
  return newClass;
}","@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes=findClassBytes(className);
  if (classBytes == null) {
    throw new ClassNotFoundException(className);
  }
  boolean localInjection;
  if (!isInjectingClass) {
    localInjection=isInjectingClass=true;
  }
 else {
    localInjection=false;
  }
  Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
  if (className.equals(JavaScriptHost.class.getName())) {
    javaScriptHostClass=newClass;
    updateJavaScriptHost();
  }
  if (!classRewriter.isJsoIntf(className)) {
    CompiledClass compiledClass=compilationState.getClassFileMap().get(canonicalizeClassName(className));
    if (compiledClass != null) {
      toInject.push(compiledClass);
    }
  }
  if (localInjection) {
    try {
      while (toInject.size() > 0) {
        injectJsniFor(toInject.remove(0));
      }
    }
  finally {
      isInjectingClass=false;
    }
  }
  if (className.equals(""String_Node_Str"")) {
    gwtClass=newClass;
    updateGwtClass();
  }
  return newClass;
}"
82657,"public void testStaticAccess(){
  Foo.field=3;
  assertEquals(3,Foo.field--);
  assertEquals(""String_Node_Str"",Foo.staticValue());
  assertEquals(""String_Node_Str"",Foo.staticNative());
  Bar.field=10;
  assertEquals(11,++Bar.field);
  assertEquals(""String_Node_Str"",Bar.staticValue());
  assertEquals(""String_Node_Str"",Bar.staticNative());
}","public void testStaticAccess(){
  Foo.field=3;
  assertEquals(3,Foo.field--);
  assertEquals(""String_Node_Str"",Foo.staticValue());
  assertEquals(""String_Node_Str"",Foo.staticNative());
  assertEquals(""String_Node_Str"",Foo.staticNativeToSub());
  Bar.field=10;
  assertEquals(11,++Bar.field);
  assertEquals(""String_Node_Str"",Bar.staticValue());
  assertEquals(""String_Node_Str"",Bar.staticNative());
}"
82658,"public void onMouseUp(Widget sender,int x,int y){
  dragging=false;
  DOM.releaseCapture(caption.getElement());
}","public void onMouseUp(Widget sender,int x,int y){
  dragging=false;
  DOM.releaseCapture(getElement());
}"
82659,"public void onMouseDown(Widget sender,int x,int y){
  dragging=true;
  DOM.setCapture(caption.getElement());
  dragStartX=x;
  dragStartY=y;
}","public void onMouseDown(Widget sender,int x,int y){
  dragging=true;
  DOM.setCapture(getElement());
  dragStartX=x;
  dragStartY=y;
}"
82660,"/** 
 * Creates an empty dialog box specifying its ""auto-hide"" property. It should not be shown until its child widget has been added using  {@link #add(Widget)}.
 * @param autoHide <code>true</code> if the dialog should be automaticallyhidden when the user clicks outside of it
 * @param modal <code>true</code> if keyboard and mouse events for widgetsnot contained by the dialog should be ignored
 */
public DialogBox(boolean autoHide,boolean modal){
  super(autoHide,modal,""String_Node_Str"");
  Element td=getCellElement(0,1);
  DOM.appendChild(td,caption.getElement());
  adopt(caption);
  caption.setStyleName(""String_Node_Str"");
  caption.addMouseListener(this);
  setStyleName(DEFAULT_STYLENAME);
}","/** 
 * Creates an empty dialog box specifying its ""auto-hide"" property. It should not be shown until its child widget has been added using  {@link #add(Widget)}.
 * @param autoHide <code>true</code> if the dialog should be automaticallyhidden when the user clicks outside of it
 * @param modal <code>true</code> if keyboard and mouse events for widgetsnot contained by the dialog should be ignored
 */
public DialogBox(boolean autoHide,boolean modal){
  super(autoHide,modal,""String_Node_Str"");
  Element td=getCellElement(0,1);
  DOM.appendChild(td,caption.getElement());
  adopt(caption);
  caption.setStyleName(""String_Node_Str"");
  mouseListeners.add(this);
  setStyleName(DEFAULT_STYLENAME);
  sinkEvents(Event.MOUSEEVENTS);
}"
82661,public native int getBodyOffsetTop();,@Override public native int getBodyOffsetTop();
82662,public native int getBodyOffsetLeft();,@Override public native int getBodyOffsetLeft();
82663,"@Override protected void nativeUpdate(String historyToken){
  if (isOldSafari) {
    nativeUpdateImpl(historyToken);
  }
 else {
    super.nativeUpdate(historyToken);
  }
}","@Override protected void nativeUpdate(String historyToken){
  if (isOldSafari) {
    oldNativeUpdate(historyToken);
  }
 else {
    newNativeUpdate(historyToken);
  }
}"
82664,"public void onHistoryChanged(String historyToken){
  if (historyToken == null) {
    fail(""String_Node_Str"");
  }
  assertEquals(token,historyToken);
  finishTest();
}","public void onHistoryChanged(String historyToken){
  counter.add(new Object());
  assertFalse(""String_Node_Str"",isBorked());
}"
82665,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new TestFireEvents());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new TreeVisuals());
  addIssue(new TestFireEvents());
}"
82666,"@Override void initializeClonableElements(){
  super.initializeClonableElements();
  if (GWT.isClient()) {
    DOM.setElementPropertyInt(BASE_INTERNAL_ELEM,""String_Node_Str"",0);
    DOM.setElementPropertyInt(BASE_INTERNAL_ELEM,""String_Node_Str"",0);
    BASE_INTERNAL_ELEM.getStyle().setPropertyPx(""String_Node_Str"",3);
    DOM.setStyleAttribute(BASE_BARE_ELEM,""String_Node_Str"",""String_Node_Str"");
    DOM.setStyleAttribute(BASE_BARE_ELEM,""String_Node_Str"",""String_Node_Str"");
  }
}","@Override void initializeClonableElements(){
  super.initializeClonableElements();
  if (GWT.isClient()) {
    DOM.setStyleAttribute(BASE_BARE_ELEM,""String_Node_Str"",""String_Node_Str"");
    DOM.setStyleAttribute(BASE_BARE_ELEM,""String_Node_Str"",""String_Node_Str"");
  }
}"
82667,"/** 
 * Called only from   {@link TreeItem}: Shows the leaf image on a tree item.
 * @param treeItem the tree item
 */
void showLeafImage(TreeItem treeItem){
  if (useLeafImages) {
    showImage(treeItem,images.treeLeaf());
  }
 else {
    DOM.setStyleAttribute(treeItem.getElement(),""String_Node_Str"",indentValue);
  }
}","/** 
 * Called only from   {@link TreeItem}: Shows the leaf image on a tree item.
 * @param treeItem the tree item
 */
void showLeafImage(TreeItem treeItem){
  if (useLeafImages || treeItem.isFullNode()) {
    showImage(treeItem,images.treeLeaf());
  }
 else {
    DOM.setStyleAttribute(treeItem.getElement(),""String_Node_Str"",indentValue);
  }
}"
82668,"Element getImageHolderElement(){
  if (imageHolder == null) {
    convertToFullNode();
  }
  return imageHolder;
}","Element getImageHolderElement(){
  if (!isFullNode()) {
    convertToFullNode();
  }
  return imageHolder;
}"
82669,"/** 
 * Gets the text currently selected within this text box.
 * @return the selected text, or an empty string if none is selected
 */
public String getSelectedText(){
  int start=getCursorPos(), length=getSelectionLength();
  return getText().substring(start,start + length);
}","/** 
 * Gets the text currently selected within this text box.
 * @return the selected text, or an empty string if none is selected
 */
public String getSelectedText(){
  int start=getCursorPos();
  if (start < 0) {
    return ""String_Node_Str"";
  }
  int length=getSelectionLength();
  return getText().substring(start,start + length);
}"
82670,"/** 
 * Sets the cursor position.
 * @param pos the new cursor position
 */
public void setCursorPos(int pos){
  setSelectionRange(pos,0);
}","/** 
 * Sets the cursor position. This will only work when the widget is attached to the document and not hidden.
 * @param pos the new cursor position
 */
public void setCursorPos(int pos){
  setSelectionRange(pos,0);
}"
82671,"/** 
 * Selects all of the text in the box. This will only work when the widget is attached to the document.
 */
public void selectAll(){
  int length=getText().length();
  if (length > 0) {
    setSelectionRange(0,length);
  }
}","/** 
 * Selects all of the text in the box. This will only work when the widget is attached to the document and not hidden.
 */
public void selectAll(){
  int length=getText().length();
  if (length > 0) {
    setSelectionRange(0,length);
  }
}"
82672,"/** 
 * Sets the range of text to be selected. This will only work when the widget is attached to the document.
 * @param pos the position of the first character to be selected
 * @param length the number of characters to be selected
 */
public void setSelectionRange(int pos,int length){
  if (!isAttached()) {
    return;
  }
  if (length < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + length);
  }
  if ((pos < 0) || (length + pos > getText().length())) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + pos + ""String_Node_Str""+ (pos + length)+ ""String_Node_Str""+ getText().length());
  }
  impl.setSelectionRange(getElement(),pos,length);
}","/** 
 * Sets the range of text to be selected. This will only work when the widget is attached to the document and not hidden.
 * @param pos the position of the first character to be selected
 * @param length the number of characters to be selected
 */
public void setSelectionRange(int pos,int length){
  if (!isAttached()) {
    return;
  }
  if (length < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + length);
  }
  if ((pos < 0) || (length + pos > getText().length())) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + pos + ""String_Node_Str""+ (pos + length)+ ""String_Node_Str""+ getText().length());
  }
  impl.setSelectionRange(getElement(),pos,length);
}"
82673,"/** 
 * Tests various text selection methods in text area.
 */
public void disabledTestSelection(){
  TextBoxBase area=createTextBoxBase();
  assertEquals(""String_Node_Str"",area.getSelectedText());
  area.selectAll();
  assertEquals(0,area.getSelectionLength());
  try {
    area.setSelectionRange(0,1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  RootPanel.get().add(area);
  area.setText(""String_Node_Str"");
  area.selectAll();
  assertEquals(1,area.getSelectionLength());
  area.setText(""String_Node_Str"");
  assertEquals(0,area.getSelectionLength());
  area.setText(""String_Node_Str"");
  area.setSelectionRange(2,2);
  assertEquals(2,area.getCursorPos());
  area.setSelectionRange(0,0);
}","/** 
 * Tests various text selection methods in text area.
 */
public void disabledTestSelection(){
  TextBoxBase area=createTextBoxBase();
  assertEquals(""String_Node_Str"",area.getSelectedText());
  area.selectAll();
  assertEquals(0,area.getSelectionLength());
  try {
    area.setSelectionRange(0,1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  RootPanel.get().add(area);
  area.setText(""String_Node_Str"");
  area.selectAll();
  assertEquals(1,area.getSelectionLength());
  area.setText(""String_Node_Str"");
  assertEquals(0,area.getSelectionLength());
  area.setText(""String_Node_Str"");
  area.setSelectionRange(2,2);
  assertEquals(2,area.getCursorPos());
  area.setSelectionRange(0,0);
{
    TextBoxBase area2=createTextBoxBase();
    area2.setVisible(false);
    RootPanel.get().add(area2);
    area.selectAll();
  }
}"
82674,"/** 
 * Attempts to get a named deferred binding property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return a value for the property
 */
String getPropertyValue(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return a value for the property
 */
String getPropertyValue(TreeLogger logger,String propertyName) throws BadPropertyValueException ;"
82675,"/** 
 * Attempts to get a named deferred binding property and returns the list of possible values. Throws <code>BadPropertyValueException</code> if the property is undefined.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return the possible values for the property
 */
String[] getPropertyValueSet(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property and returns the list of possible values. Throws <code>BadPropertyValueException</code> if the property is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return the possible values for the property
 */
String[] getPropertyValueSet(TreeLogger logger,String propertyName) throws BadPropertyValueException ;"
82676,"public DistillerRebindPermutationOracle(ArtifactSet generatorArtifacts,PropertyPermutations perms){
  rebindOracles=new CompilationRebindOracle[perms.size()];
  Property[] orderedProps=perms.getOrderedProperties();
  for (int i=0; i < rebindOracles.length; ++i) {
    String[] orderedPropValues=perms.getOrderedPropertyValues(i);
    StaticPropertyOracle propOracle=new StaticPropertyOracle(orderedProps,orderedPropValues);
    rebindOracles[i]=new CompilationRebindOracle(generatorArtifacts,propOracle);
  }
}","public DistillerRebindPermutationOracle(ArtifactSet generatorArtifacts,PropertyPermutations perms){
  propertyOracles=new StaticPropertyOracle[perms.size()];
  rebindOracles=new RebindOracle[perms.size()];
  Property[] orderedProps=perms.getOrderedProperties();
  for (int i=0; i < rebindOracles.length; ++i) {
    String[] orderedPropValues=perms.getOrderedPropertyValues(i);
    propertyOracles[i]=new StaticPropertyOracle(orderedProps,orderedPropValues);
    rebindOracles[i]=new StandardRebindOracle(compilationState,propertyOracles[i],module,rules,genDir,generatorResourcesDir,generatorArtifacts);
  }
}"
82677,"public String[] getAllPossibleRebindAnswers(TreeLogger logger,String requestTypeName) throws UnableToCompleteException {
  String msg=""String_Node_Str"" + requestTypeName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.DEBUG,msg,null);
  Set<String> answers=new HashSet<String>();
  for (  CompilationRebindOracle rebindOracle : rebindOracles) {
    String resultTypeName=rebindOracle.rebind(logger,requestTypeName);
    answers.add(resultTypeName);
  }
  return Util.toArray(String.class,answers);
}","public String[] getAllPossibleRebindAnswers(TreeLogger logger,String requestTypeName) throws UnableToCompleteException {
  String msg=""String_Node_Str"" + requestTypeName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.DEBUG,msg,null);
  Set<String> answers=new HashSet<String>();
  for (  RebindOracle rebindOracle : rebindOracles) {
    String resultTypeName=rebindOracle.rebind(logger,requestTypeName);
    answers.add(resultTypeName);
  }
  return Util.toArray(String.class,answers);
}"
82678,"public CompilationRebindOracle getRebindOracle(int permNumber){
  return rebindOracles[permNumber];
}","public RebindOracle getRebindOracle(int permNumber){
  return rebindOracles[permNumber];
}"
82679,"private void compilePermutations(TreeLogger logger,JavaToJavaScriptCompiler jjs,DistillerRebindPermutationOracle rpo,StandardLinkerContext linkerContext) throws UnableToCompleteException {
  int permCount=rpo.getPermuationCount();
  PerfLogger.start(""String_Node_Str"" + permCount + ""String_Node_Str"");
  Permutation[] perms=new Permutation[permCount];
  for (int i=0; i < permCount; ++i) {
    CompilationRebindOracle rebindOracle=rpo.getRebindOracle(i);
    perms[i]=new Permutation(i,rebindOracle,rebindOracle.getPropertyOracle());
  }
  PermutationCompiler permCompiler=new PermutationCompiler(logger,jjs,perms);
  permCompiler.go(linkerContext);
}","private void compilePermutations(TreeLogger logger,JavaToJavaScriptCompiler jjs,DistillerRebindPermutationOracle rpo,StandardLinkerContext linkerContext) throws UnableToCompleteException {
  int permCount=rpo.getPermuationCount();
  PerfLogger.start(""String_Node_Str"" + permCount + ""String_Node_Str"");
  Permutation[] perms=new Permutation[permCount];
  for (int i=0; i < permCount; ++i) {
    perms[i]=new Permutation(i,rpo.getRebindOracle(i),rpo.getPropertyOracle(i));
  }
  PermutationCompiler permCompiler=new PermutationCompiler(logger,jjs,perms);
  permCompiler.go(linkerContext);
}"
82680,"public StaticPropertyOracle getPropertyOracle(){
  return propOracle;
}","public StaticPropertyOracle getPropertyOracle(int permNumber){
  return propertyOracles[permNumber];
}"
82681,"public String rebind(TreeLogger logger,String typeName) throws UnableToCompleteException {
  logger=Messages.TRACE_TOPLEVEL_REBIND.branch(logger,typeName,null);
  Rebinder rebinder=new Rebinder();
  String result=rebinder.rebind(logger,typeName);
  Messages.TRACE_TOPLEVEL_REBIND_RESULT.log(logger,result,null);
  return result;
}","public String rebind(TreeLogger logger,String typeName) throws UnableToCompleteException {
  String result=cache.get(typeName);
  if (result == null) {
    logger=Messages.TRACE_TOPLEVEL_REBIND.branch(logger,typeName,null);
    Rebinder rebinder=new Rebinder();
    result=rebinder.rebind(logger,typeName);
    cache.put(typeName,result);
    Messages.TRACE_TOPLEVEL_REBIND_RESULT.log(logger,result,null);
  }
  return result;
}"
82682,"public void visitLocalVariable(final String name,final String desc,final String signature,final Label start,final Label end,final int index){
  if (signature != null) {
    if (localVarType == null) {
      localVarType=new ByteVector();
    }
    ++localVarTypeCount;
    localVarType.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature)).putShort(index);
  }
  if (localVar == null) {
    localVar=new ByteVector();
  }
  ++localVarCount;
  localVar.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc)).putShort(index);
  if (compute != NOTHING) {
    char c=desc.charAt(0);
    int n=index + (c == 'J' || c == 'D' ? 2 : 1);
    if (n > maxLocals) {
      maxLocals=n;
    }
  }
}","public void visitLocalVariable(final String name,final String desc,final String signature,final Label start,final Label end,final int index){
  if (((start.status & labels.RESOLVED) != 0) && ((end.status & labels.RESOLVED) != 0)) {
    if (signature != null) {
      if (localVarType == null) {
        localVarType=new ByteVector();
      }
      ++localVarTypeCount;
      localVarType.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature)).putShort(index);
    }
    if (localVar == null) {
      localVar=new ByteVector();
    }
    ++localVarCount;
    localVar.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc)).putShort(index);
  }
  if (compute != NOTHING) {
    char c=desc.charAt(0);
    int n=index + (c == 'J' || c == 'D' ? 2 : 1);
    if (n > maxLocals) {
      maxLocals=n;
    }
  }
}"
82683,"/** 
 * Embed a script on the outer window and use it to initialize an event.
 * @param initFunc the string representation of the init function
 * @param funcName the name to assign to the init function
 * @param cmd the command to execute the init function
 */
private static void initHandler(String initFunc,String funcName,Command cmd){
  if (GWT.isClient()) {
    maybeInitializeCloseHandlers();
    initFunc=initFunc.replaceFirst(""String_Node_Str"",""String_Node_Str"" + funcName);
    ScriptElement scriptElem=Document.get().createScriptElement(initFunc);
    Document.get().getBody().appendChild(scriptElem);
    cmd.execute();
    RootPanel.getBodyElement().removeChild(scriptElem);
  }
}","/** 
 * Initialize an event on the outer window.
 * @param initFunc the string representation of the init function
 * @param funcName the name to assign to the init function
 * @param cmd the command to execute the init function
 */
private static void initHandler(String initFunc,String funcName,Command cmd){
  if (GWT.isClient()) {
    maybeInitializeCloseHandlers();
    impl.initHandler(initFunc,funcName,cmd);
  }
}"
82684,"public static String getStackTraceAsString(Throwable e){
  StringBuffer message=new StringBuffer();
  Throwable currentCause=e;
  String causedBy=""String_Node_Str"";
  HashSet<Throwable> seenCauses=new HashSet<Throwable>();
  while (currentCause != null && !seenCauses.contains(currentCause)) {
    seenCauses.add(currentCause);
    message.append(causedBy);
    causedBy=""String_Node_Str"";
    message.append(currentCause.getClass().getName());
    message.append(""String_Node_Str"" + currentCause.getMessage());
    StackTraceElement[] stackElems=currentCause.getStackTrace();
    if (stackElems != null) {
      for (int i=0; i < stackElems.length; ++i) {
        message.append(""String_Node_Str"");
        message.append(stackElems[i].toString());
      }
    }
    currentCause=currentCause.getCause();
  }
  return message.toString();
}","public static String getStackTraceAsString(Throwable e){
  if (e == null || e instanceof UnableToCompleteException) {
    return null;
  }
  StringBuffer message=new StringBuffer();
  Throwable currentCause=e;
  String causedBy=""String_Node_Str"";
  HashSet<Throwable> seenCauses=new HashSet<Throwable>();
  while (currentCause != null && !seenCauses.contains(currentCause)) {
    seenCauses.add(currentCause);
    message.append(causedBy);
    causedBy=""String_Node_Str"";
    message.append(currentCause.getClass().getName());
    message.append(""String_Node_Str"" + currentCause.getMessage());
    StackTraceElement[] stackElems=currentCause.getStackTrace();
    if (stackElems != null) {
      for (int i=0; i < stackElems.length; ++i) {
        message.append(""String_Node_Str"");
        message.append(stackElems[i].toString());
      }
    }
    currentCause=currentCause.getCause();
  }
  return message.toString();
}"
82685,"public LogEvent(TreeItemLogger logger,boolean isBranchCommit,int index,Type type,String message,Throwable caught,HelpInfo helpInfo){
  this.logger=logger;
  this.isBranchCommit=isBranchCommit;
  this.index=index;
  this.type=type;
  this.message=message;
  this.caught=caught;
  this.helpInfo=helpInfo;
}","public LogEvent(TreeItemLogger logger,boolean isBranchCommit,int index,Type type,String message,Throwable caught,HelpInfo helpInfo){
  this.exceptionDetail=AbstractTreeLogger.getStackTraceAsString(caught);
  this.exceptionName=AbstractTreeLogger.getExceptionName(caught);
  this.logger=logger;
  this.isBranchCommit=isBranchCommit;
  this.index=index;
  this.type=type;
  this.message=message;
  this.helpInfo=helpInfo;
}"
82686,"/** 
 * Creates a tree item in a way that is sensitive to the log event and its position in the tree.
 */
private TreeItem createTreeItem(Tree tree){
  TreeItem treeItem=null;
  if (isBranchCommit) {
    TreeItemLogger parentLogger=(TreeItemLogger)logger.getParentLogger();
    if (parentLogger.lazyTreeItem == null) {
      treeItem=new TreeItem(tree,SWT.NONE);
      logger.lazyTreeItem=treeItem;
    }
 else     if (!parentLogger.lazyTreeItem.isDisposed()) {
      treeItem=new TreeItem(parentLogger.lazyTreeItem,SWT.NONE);
      logger.lazyTreeItem=treeItem;
    }
 else {
      parentLogger.markLoggerDead();
      return null;
    }
  }
 else {
    if (logger.lazyTreeItem == null) {
      treeItem=new TreeItem(tree,SWT.NONE);
    }
 else     if (!logger.lazyTreeItem.isDisposed()) {
      treeItem=new TreeItem(logger.lazyTreeItem,SWT.NONE);
    }
 else {
      logger.markLoggerDead();
      return null;
    }
  }
  String label=message;
  if (label == null) {
    if (caught != null) {
      label=caught.getMessage();
      if (label == null || label.trim().length() == 0) {
        label=caught.toString();
      }
    }
  }
  treeItem.setText(label);
  if (helpInfo != null) {
    URL url=helpInfo.getURL();
    if (url != null) {
      TreeItem helpItem=new TreeItem(treeItem,SWT.NONE);
      helpItem.setImage(imageLink);
      helpItem.setText(""String_Node_Str"" + url.toString());
      helpItem.setForeground(helpItem.getDisplay().getSystemColor(SWT.COLOR_BLUE));
      helpItem.setData(helpInfo);
      treeItem.setExpanded(true);
    }
  }
  treeItem.setData(this);
  return treeItem;
}","/** 
 * Creates a tree item in a way that is sensitive to the log event and its position in the tree.
 */
private TreeItem createTreeItem(Tree tree){
  TreeItem treeItem=null;
  if (isBranchCommit) {
    TreeItemLogger parentLogger=(TreeItemLogger)logger.getParentLogger();
    if (parentLogger.lazyTreeItem == null) {
      treeItem=new TreeItem(tree,SWT.NONE);
      logger.lazyTreeItem=treeItem;
    }
 else     if (!parentLogger.lazyTreeItem.isDisposed()) {
      treeItem=new TreeItem(parentLogger.lazyTreeItem,SWT.NONE);
      logger.lazyTreeItem=treeItem;
    }
 else {
      parentLogger.markLoggerDead();
      return null;
    }
  }
 else {
    if (logger.lazyTreeItem == null) {
      treeItem=new TreeItem(tree,SWT.NONE);
    }
 else     if (!logger.lazyTreeItem.isDisposed()) {
      treeItem=new TreeItem(logger.lazyTreeItem,SWT.NONE);
    }
 else {
      logger.markLoggerDead();
      return null;
    }
  }
  String label=message;
  if (label == null) {
    assert(exceptionName != null);
    label=exceptionName;
  }
  treeItem.setText(label);
  if (helpInfo != null) {
    URL url=helpInfo.getURL();
    if (url != null) {
      TreeItem helpItem=new TreeItem(treeItem,SWT.NONE);
      helpItem.setImage(imageLink);
      helpItem.setText(""String_Node_Str"" + url.toString());
      helpItem.setForeground(helpItem.getDisplay().getSystemColor(SWT.COLOR_BLUE));
      helpItem.setData(helpInfo);
      treeItem.setExpanded(true);
    }
  }
  treeItem.setData(this);
  return treeItem;
}"
82687,"private void syncDetailsPane(TreeItem item){
  TreeItemLogger.LogEvent logEvent=null;
  Object testLogEvent=item.getData();
  if (testLogEvent instanceof TreeItemLogger.LogEvent) {
    logEvent=(LogEvent)testLogEvent;
  }
  StringBuffer sb=new StringBuffer();
  if (logEvent != null && logEvent.type != null) {
    sb.append(""String_Node_Str"");
    sb.append(logEvent.type.getLabel());
    sb.append(""String_Node_Str"");
  }
  sb.append(item.getText());
  sb.append(""String_Node_Str"");
  if (logEvent != null && logEvent.caught != null) {
    if (!(logEvent.caught instanceof UnableToCompleteException)) {
      String stackTrace=AbstractTreeLogger.getStackTraceAsString(logEvent.caught);
      sb.append(stackTrace);
    }
  }
  details.setText(sb.toString());
}","private void syncDetailsPane(TreeItem item){
  TreeItemLogger.LogEvent logEvent=null;
  Object testLogEvent=item.getData();
  if (testLogEvent instanceof TreeItemLogger.LogEvent) {
    logEvent=(LogEvent)testLogEvent;
  }
  StringBuffer sb=new StringBuffer();
  if (logEvent != null && logEvent.type != null) {
    sb.append(""String_Node_Str"");
    sb.append(logEvent.type.getLabel());
    sb.append(""String_Node_Str"");
  }
  sb.append(item.getText());
  sb.append(""String_Node_Str"");
  if (logEvent != null && logEvent.exceptionDetail != null) {
    sb.append(logEvent.exceptionDetail);
  }
  details.setText(sb.toString());
}"
82688,"private static void maybeInitializeHandlers(){
  if (GWT.isClient() && !handlersAreInitialized) {
    ScriptElement scriptElem=Document.get().createScriptElement();
    scriptElem.setText(getInitHandlerMethodString());
    Document.get().getBody().appendChild(scriptElem);
    init();
    RootPanel.getBodyElement().removeChild(scriptElem);
    handlersAreInitialized=true;
  }
}","private static void maybeInitializeHandlers(){
  if (GWT.isClient() && !handlersAreInitialized) {
    handlersAreInitialized=true;
    ScriptElement scriptElem=Document.get().createScriptElement();
    String initFunc=getInitHandlerMethodString().replaceFirst(""String_Node_Str"",""String_Node_Str"");
    scriptElem.setText(initFunc);
    Document.get().getBody().appendChild(scriptElem);
    init();
    RootPanel.getBodyElement().removeChild(scriptElem);
  }
}"
82689,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new TestFireEvents());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new TestFireEvents());
}"
82690,"/** 
 * Initializes the split panel.
 * @param mainElem the root element for the split panel
 * @param splitElem the element that acts as the splitter
 * @param headElem the element to contain the top or left most widget
 * @param tailElem the element to contain the bottom or right most widget
 */
SplitPanel(Element mainElem,Element splitElem,Element headElem,Element tailElem){
  setElement(mainElem);
  this.splitElem=splitElem;
  elements[0]=headElem;
  elements[1]=tailElem;
  sinkEvents(Event.MOUSEEVENTS);
}","/** 
 * Initializes the split panel.
 * @param mainElem the root element for the split panel
 * @param splitElem the element that acts as the splitter
 * @param headElem the element to contain the top or left most widget
 * @param tailElem the element to contain the bottom or right most widget
 */
SplitPanel(Element mainElem,Element splitElem,Element headElem,Element tailElem){
  setElement(mainElem);
  this.splitElem=splitElem;
  elements[0]=headElem;
  elements[1]=tailElem;
  sinkEvents(Event.MOUSEEVENTS | Event.ONLOSECAPTURE);
  if (glassElem == null) {
    glassElem=DOM.createDiv();
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  }
}"
82691,"private void startResizingFrom(int x,int y){
  isResizing=true;
  onSplitterResizeStarted(x,y);
}","private void startResizingFrom(int x,int y){
  isResizing=true;
  onSplitterResizeStarted(x,y);
  int height=RootPanel.getBodyElement().getScrollHeight() - 1;
  int width=RootPanel.getBodyElement().getScrollWidth() - 1;
  glassElem.getStyle().setProperty(""String_Node_Str"",height + ""String_Node_Str"");
  glassElem.getStyle().setProperty(""String_Node_Str"",width + ""String_Node_Str"");
  RootPanel.getBodyElement().appendChild(glassElem);
}"
82692,"private void stopResizing(){
  isResizing=false;
}","private void stopResizing(){
  isResizing=false;
  RootPanel.getBodyElement().removeChild(glassElem);
}"
82693,"/** 
 * Loads a new module into <code>moduleDef</code> as an included module.
 * @param logger Logs the process.
 * @param moduleName The module to load.
 * @param moduleDef The module to add the new module to.
 * @throws UnableToCompleteException
 */
void nestedLoad(TreeLogger logger,String moduleName,ModuleDef moduleDef) throws UnableToCompleteException {
  if (alreadyLoadedModules.contains(moduleName)) {
    logger.log(TreeLogger.TRACE,""String_Node_Str"" + moduleName + ""String_Node_Str"",null);
    return;
  }
 else {
    alreadyLoadedModules.add(moduleName);
  }
  String slashedModuleName=moduleName.replace('.','/');
  String resName=slashedModuleName + ""String_Node_Str"";
  URL moduleURL=classLoader.getResource(resName);
  if (moduleURL != null) {
    String externalForm=moduleURL.toExternalForm();
    logger.log(TreeLogger.TRACE,""String_Node_Str"" + externalForm,null);
    try {
      if ((!(externalForm.startsWith(""String_Node_Str""))) && (!(externalForm.startsWith(""String_Node_Str""))) && (!(externalForm.startsWith(""String_Node_Str"")))&& (!(externalForm.startsWith(""String_Node_Str"")))) {
        File gwtXmlFile=new File(new URI(externalForm));
        moduleDef.addGwtXmlFile(gwtXmlFile);
      }
    }
 catch (    URISyntaxException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
      throw new UnableToCompleteException();
    }
  }
  if (moduleURL == null) {
    String msg=""String_Node_Str"" + resName + ""String_Node_Str"";
    logger.log(TreeLogger.ERROR,msg,null);
    throw new UnableToCompleteException();
  }
  String moduleDir=""String_Node_Str"";
  int i=slashedModuleName.lastIndexOf('/');
  if (i != -1) {
    moduleDir=slashedModuleName.substring(0,i) + ""String_Node_Str"";
  }
  Reader r=null;
  try {
    r=Util.createReader(logger,moduleURL);
    ModuleDefSchema schema=new ModuleDefSchema(logger,this,moduleURL,moduleDir,moduleDef);
    ReflectiveParser.parse(logger,schema,r);
  }
  finally {
    Utility.close(r);
  }
}","/** 
 * Loads a new module into <code>moduleDef</code> as an included module.
 * @param logger Logs the process.
 * @param moduleName The module to load.
 * @param moduleDef The module to add the new module to.
 * @throws UnableToCompleteException
 */
void nestedLoad(TreeLogger logger,String moduleName,ModuleDef moduleDef) throws UnableToCompleteException {
  if (alreadyLoadedModules.contains(moduleName)) {
    logger.log(TreeLogger.TRACE,""String_Node_Str"" + moduleName + ""String_Node_Str"",null);
    return;
  }
 else {
    alreadyLoadedModules.add(moduleName);
  }
  String slashedModuleName=moduleName.replace('.','/');
  String resName=slashedModuleName + ModuleDefLoader.GWT_MODULE_XML_SUFFIX;
  URL moduleURL=classLoader.getResource(resName);
  if (moduleURL != null) {
    String externalForm=moduleURL.toExternalForm();
    logger.log(TreeLogger.TRACE,""String_Node_Str"" + externalForm,null);
    try {
      if ((!(externalForm.startsWith(""String_Node_Str""))) && (!(externalForm.startsWith(""String_Node_Str""))) && (!(externalForm.startsWith(""String_Node_Str"")))&& (!(externalForm.startsWith(""String_Node_Str"")))) {
        File gwtXmlFile=new File(new URI(externalForm));
        moduleDef.addGwtXmlFile(gwtXmlFile);
      }
    }
 catch (    URISyntaxException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
      throw new UnableToCompleteException();
    }
  }
  if (moduleURL == null) {
    String msg=""String_Node_Str"" + resName + ""String_Node_Str"";
    logger.log(TreeLogger.ERROR,msg,null);
    throw new UnableToCompleteException();
  }
  String moduleDir=""String_Node_Str"";
  int i=slashedModuleName.lastIndexOf('/');
  if (i != -1) {
    moduleDir=slashedModuleName.substring(0,i) + ""String_Node_Str"";
  }
  Reader r=null;
  try {
    r=Util.createReader(logger,moduleURL);
    ModuleDefSchema schema=new ModuleDefSchema(logger,this,moduleURL,moduleDir,moduleDef);
    ReflectiveParser.parse(logger,schema,r);
  }
  finally {
    Utility.close(r);
  }
}"
82694,"public void onWindowResized(int width,int height){
  if (width == windowWidth) {
    return;
  }
  windowWidth=width;
  int menuWidth=mainMenu.getOffsetWidth();
  int contentWidth=width - menuWidth - 30;
  int contentWidthInner=contentWidth - 10;
  bottomPanel.setCellWidth(mainMenu,menuWidth + ""String_Node_Str"");
  bottomPanel.setCellWidth(contentLayout,contentWidth + ""String_Node_Str"");
  contentLayout.getCellFormatter().setWidth(0,0,contentWidthInner + ""String_Node_Str"");
  contentLayout.getCellFormatter().setWidth(1,0,contentWidthInner + ""String_Node_Str"");
}","public void onWindowResized(int width,int height){
  if (width == windowWidth) {
    return;
  }
  windowWidth=width;
  onWindowResizedImpl(width);
}"
82695,"@Override public void run(){
  styleTester.setVisible(false);
  styleTester.setVisible(true);
  if (styleTester.getOffsetWidth() > 0) {
    RootPanel.getBodyElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    RootPanel.getBodyElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    schedule(25);
  }
}","@Override public void run(){
  styleTester.setVisible(false);
  styleTester.setVisible(true);
  if (styleTester.getOffsetWidth() > 0) {
    RootPanel.getBodyElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    RootPanel.getBodyElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    app.onWindowResizedImpl(Window.getClientWidth());
  }
 else {
    schedule(25);
  }
}"
82696,"/** 
 * Update the style sheets to reflect the current theme and direction.
 */
private void updateStyleSheets(){
  String gwtStyleSheet=""String_Node_Str"" + CUR_THEME + ""String_Node_Str""+ CUR_THEME+ ""String_Node_Str"";
  String showcaseStyleSheet=CUR_THEME + ""String_Node_Str"";
  if (LocaleInfo.getCurrentLocale().isRTL()) {
    gwtStyleSheet=gwtStyleSheet.replace(""String_Node_Str"",""String_Node_Str"");
    showcaseStyleSheet=showcaseStyleSheet.replace(""String_Node_Str"",""String_Node_Str"");
  }
  HeadElement headElem=getHeadElement();
  NodeList<Node> children=headElem.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    Node node=children.getItem(i);
    if (node.getNodeType() == Node.ELEMENT_NODE) {
      Element elem=Element.as(node);
      if (elem.getTagName().equalsIgnoreCase(""String_Node_Str"") && elem.getPropertyString(""String_Node_Str"").equalsIgnoreCase(""String_Node_Str"")) {
        String href=elem.getPropertyString(""String_Node_Str"");
        if (gwtStyleSheet != null && href.contains(gwtStyleSheet)) {
          gwtStyleSheet=null;
        }
 else         if (showcaseStyleSheet != null && href.contains(showcaseStyleSheet)) {
          showcaseStyleSheet=null;
        }
 else {
          headElem.removeChild(elem);
          i--;
        }
      }
    }
  }
  String modulePath=GWT.getModuleBaseURL();
  if (gwtStyleSheet != null) {
    styleTesterTimer.schedule(25);
    loadStyleSheet(modulePath + gwtStyleSheet);
  }
  if (showcaseStyleSheet != null) {
    loadStyleSheet(modulePath + showcaseStyleSheet);
  }
}","/** 
 * Update the style sheets to reflect the current theme and direction.
 */
private void updateStyleSheets(){
  String gwtStyleSheet=""String_Node_Str"" + CUR_THEME + ""String_Node_Str""+ CUR_THEME+ ""String_Node_Str"";
  String showcaseStyleSheet=CUR_THEME + ""String_Node_Str"";
  if (LocaleInfo.getCurrentLocale().isRTL()) {
    gwtStyleSheet=gwtStyleSheet.replace(""String_Node_Str"",""String_Node_Str"");
    showcaseStyleSheet=showcaseStyleSheet.replace(""String_Node_Str"",""String_Node_Str"");
  }
  HeadElement headElem=getHeadElement();
  NodeList<Node> children=headElem.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    Node node=children.getItem(i);
    if (node.getNodeType() == Node.ELEMENT_NODE) {
      Element elem=Element.as(node);
      if (elem.getTagName().equalsIgnoreCase(""String_Node_Str"") && elem.getPropertyString(""String_Node_Str"").equalsIgnoreCase(""String_Node_Str"")) {
        String href=elem.getPropertyString(""String_Node_Str"");
        if (gwtStyleSheet != null && href.contains(gwtStyleSheet)) {
          gwtStyleSheet=null;
        }
 else         if (showcaseStyleSheet != null && href.contains(showcaseStyleSheet)) {
          showcaseStyleSheet=null;
        }
 else {
          headElem.removeChild(elem);
          i--;
        }
      }
    }
  }
  styleTesterTimer.schedule(25);
  String modulePath=GWT.getModuleBaseURL();
  if (gwtStyleSheet != null) {
    loadStyleSheet(modulePath + gwtStyleSheet);
  }
  if (showcaseStyleSheet != null) {
    loadStyleSheet(modulePath + showcaseStyleSheet);
  }
}"
82697,"/** 
 * Generates the client's asynchronous proxy method.
 */
private void generateProxyMethod(SourceWriter w,SerializableTypeOracle serializableTypeOracle,JMethod syncMethod,JMethod asyncMethod){
  w.println();
  JType asyncReturnType=asyncMethod.getReturnType();
  w.print(""String_Node_Str"");
  w.print(asyncReturnType.getQualifiedSourceName());
  w.print(""String_Node_Str"");
  w.print(asyncMethod.getName() + ""String_Node_Str"");
  boolean needsComma=false;
  boolean needsTryCatchBlock=false;
  NameFactory nameFactory=new NameFactory();
  JParameter[] asyncParams=asyncMethod.getParameters();
  for (int i=0; i < asyncParams.length; ++i) {
    JParameter param=asyncParams[i];
    if (needsComma) {
      w.print(""String_Node_Str"");
    }
 else {
      needsComma=true;
    }
    JType paramType=param.getType();
    if (i < asyncParams.length - 1 && paramType.isPrimitive() == null && !paramType.getQualifiedSourceName().equals(String.class.getCanonicalName())) {
      needsTryCatchBlock=true;
    }
    w.print(paramType.getParameterizedQualifiedSourceName());
    w.print(""String_Node_Str"");
    String paramName=param.getName();
    nameFactory.addName(paramName);
    w.print(paramName);
  }
  w.println(""String_Node_Str"");
  w.indent();
  String requestIdName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + requestIdName + ""String_Node_Str"");
  String statsMethodExpr=getProxySimpleName() + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"";
  String tossName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + tossName + ""String_Node_Str""+ statsMethodExpr+ ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.print(ClientSerializationStreamWriter.class.getSimpleName());
  w.print(""String_Node_Str"");
  String streamWriterName=nameFactory.createName(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  w.println(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  if (needsTryCatchBlock) {
    w.println(""String_Node_Str"");
    w.indent();
  }
  if (!shouldEnforceTypeVersioning()) {
    w.println(streamWriterName + ""String_Node_Str"" + ClientSerializationStreamReader.class.getName()+ ""String_Node_Str"");
  }
  w.println(streamWriterName + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"");
  JParameter[] syncParams=syncMethod.getParameters();
  w.println(streamWriterName + ""String_Node_Str"" + syncParams.length+ ""String_Node_Str"");
  for (  JParameter param : syncParams) {
    w.println(streamWriterName + ""String_Node_Str"" + serializableTypeOracle.getSerializedTypeName(param.getType())+ ""String_Node_Str"");
  }
  for (int i=0; i < asyncParams.length - 1; ++i) {
    JParameter asyncParam=asyncParams[i];
    w.print(streamWriterName + ""String_Node_Str"");
    w.print(Shared.getStreamWriteMethodNameFor(asyncParam.getType()));
    w.println(""String_Node_Str"" + asyncParam.getName() + ""String_Node_Str"");
  }
  JParameter callbackParam=asyncParams[asyncParams.length - 1];
  String callbackName=callbackParam.getName();
  if (needsTryCatchBlock) {
    w.outdent();
    w.print(""String_Node_Str"");
    String exceptionName=nameFactory.createName(""String_Node_Str"");
    w.println(exceptionName + ""String_Node_Str"");
    w.indent();
    w.println(callbackName + ""String_Node_Str"" + exceptionName+ ""String_Node_Str"");
    w.outdent();
    w.println(""String_Node_Str"");
  }
  w.println();
  String payloadName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + payloadName + ""String_Node_Str""+ streamWriterName+ ""String_Node_Str"");
  w.println(tossName + ""String_Node_Str"" + statsMethodExpr+ ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  if (asyncReturnType == JPrimitiveType.VOID) {
    w.print(""String_Node_Str"");
  }
 else   if (asyncReturnType.getQualifiedSourceName().equals(RequestBuilder.class.getName())) {
    w.print(""String_Node_Str"");
  }
 else   if (asyncReturnType.getQualifiedSourceName().equals(Request.class.getName())) {
    w.print(""String_Node_Str"");
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + asyncReturnType.getQualifiedSourceName());
  }
  JType returnType=syncMethod.getReturnType();
  w.print(""String_Node_Str"" + getResponseReaderFor(returnType).name());
  w.println(""String_Node_Str"" + getProxySimpleName() + ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str""+ payloadName+ ""String_Node_Str""+ callbackName+ ""String_Node_Str"");
  w.outdent();
  w.println(""String_Node_Str"");
}","/** 
 * Generates the client's asynchronous proxy method.
 */
private void generateProxyMethod(SourceWriter w,SerializableTypeOracle serializableTypeOracle,JMethod syncMethod,JMethod asyncMethod){
  w.println();
  JType asyncReturnType=asyncMethod.getReturnType().getErasedType();
  w.print(""String_Node_Str"");
  w.print(asyncReturnType.getQualifiedSourceName());
  w.print(""String_Node_Str"");
  w.print(asyncMethod.getName() + ""String_Node_Str"");
  boolean needsComma=false;
  boolean needsTryCatchBlock=false;
  NameFactory nameFactory=new NameFactory();
  JParameter[] asyncParams=asyncMethod.getParameters();
  for (int i=0; i < asyncParams.length; ++i) {
    JParameter param=asyncParams[i];
    if (needsComma) {
      w.print(""String_Node_Str"");
    }
 else {
      needsComma=true;
    }
    JType paramType=param.getType();
    paramType=paramType.getErasedType();
    if (i < asyncParams.length - 1 && paramType.isPrimitive() == null && !paramType.getQualifiedSourceName().equals(String.class.getCanonicalName())) {
      needsTryCatchBlock=true;
    }
    w.print(paramType.getQualifiedSourceName());
    w.print(""String_Node_Str"");
    String paramName=param.getName();
    nameFactory.addName(paramName);
    w.print(paramName);
  }
  w.println(""String_Node_Str"");
  w.indent();
  String requestIdName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + requestIdName + ""String_Node_Str"");
  String statsMethodExpr=getProxySimpleName() + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"";
  String tossName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + tossName + ""String_Node_Str""+ statsMethodExpr+ ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.print(ClientSerializationStreamWriter.class.getSimpleName());
  w.print(""String_Node_Str"");
  String streamWriterName=nameFactory.createName(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  w.println(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  if (needsTryCatchBlock) {
    w.println(""String_Node_Str"");
    w.indent();
  }
  if (!shouldEnforceTypeVersioning()) {
    w.println(streamWriterName + ""String_Node_Str"" + ClientSerializationStreamReader.class.getName()+ ""String_Node_Str"");
  }
  w.println(streamWriterName + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"");
  JParameter[] syncParams=syncMethod.getParameters();
  w.println(streamWriterName + ""String_Node_Str"" + syncParams.length+ ""String_Node_Str"");
  for (  JParameter param : syncParams) {
    w.println(streamWriterName + ""String_Node_Str"" + serializableTypeOracle.getSerializedTypeName(param.getType().getErasedType())+ ""String_Node_Str"");
  }
  for (int i=0; i < asyncParams.length - 1; ++i) {
    JParameter asyncParam=asyncParams[i];
    w.print(streamWriterName + ""String_Node_Str"");
    w.print(Shared.getStreamWriteMethodNameFor(asyncParam.getType()));
    w.println(""String_Node_Str"" + asyncParam.getName() + ""String_Node_Str"");
  }
  JParameter callbackParam=asyncParams[asyncParams.length - 1];
  String callbackName=callbackParam.getName();
  if (needsTryCatchBlock) {
    w.outdent();
    w.print(""String_Node_Str"");
    String exceptionName=nameFactory.createName(""String_Node_Str"");
    w.println(exceptionName + ""String_Node_Str"");
    w.indent();
    w.println(callbackName + ""String_Node_Str"" + exceptionName+ ""String_Node_Str"");
    w.outdent();
    w.println(""String_Node_Str"");
  }
  w.println();
  String payloadName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + payloadName + ""String_Node_Str""+ streamWriterName+ ""String_Node_Str"");
  w.println(tossName + ""String_Node_Str"" + statsMethodExpr+ ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  if (asyncReturnType == JPrimitiveType.VOID) {
    w.print(""String_Node_Str"");
  }
 else   if (asyncReturnType.getQualifiedSourceName().equals(RequestBuilder.class.getName())) {
    w.print(""String_Node_Str"");
  }
 else   if (asyncReturnType.getQualifiedSourceName().equals(Request.class.getName())) {
    w.print(""String_Node_Str"");
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + asyncReturnType.getQualifiedSourceName());
  }
  JType returnType=syncMethod.getReturnType();
  w.print(""String_Node_Str"" + getResponseReaderFor(returnType).name());
  w.println(""String_Node_Str"" + getProxySimpleName() + ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str""+ payloadName+ ""String_Node_Str""+ callbackName+ ""String_Node_Str"");
  w.outdent();
  w.println(""String_Node_Str"");
}"
82698,"private void generateProxyMethods(SourceWriter w,SerializableTypeOracle serializableTypeOracle,Map<JMethod,JMethod> syncMethToAsyncMethMap){
  JMethod[] syncMethods=serviceIntf.getOverridableMethods();
  for (  JMethod syncMethod : syncMethods) {
    JMethod asyncMethod=syncMethToAsyncMethMap.get(syncMethod);
    assert(asyncMethod != null);
    generateProxyMethod(w,serializableTypeOracle,syncMethod,asyncMethod);
  }
}","private void generateProxyMethods(SourceWriter w,SerializableTypeOracle serializableTypeOracle,Map<JMethod,JMethod> syncMethToAsyncMethMap){
  JMethod[] syncMethods=serviceIntf.getOverridableMethods();
  for (  JMethod syncMethod : syncMethods) {
    JMethod asyncMethod=syncMethToAsyncMethMap.get(syncMethod);
    assert(asyncMethod != null);
    JClassType enclosingType=syncMethod.getEnclosingType();
    JParameterizedType isParameterizedType=enclosingType.isParameterized();
    if (isParameterizedType != null) {
      JMethod[] methods=isParameterizedType.getMethods();
      for (int i=0; i < methods.length; ++i) {
        if (methods[i] == syncMethod) {
          syncMethod=isParameterizedType.getBaseType().getMethods()[i];
        }
      }
    }
    generateProxyMethod(w,serializableTypeOracle,syncMethod,asyncMethod);
  }
}"
82699,"private SourceWriter getSourceWriter(TreeLogger logger,GeneratorContext ctx,JClassType serviceAsync){
  JPackage serviceIntfPkg=serviceAsync.getPackage();
  String packageName=serviceIntfPkg == null ? ""String_Node_Str"" : serviceIntfPkg.getName();
  PrintWriter printWriter=ctx.tryCreate(logger,packageName,getProxySimpleName());
  if (printWriter == null) {
    return null;
  }
  ClassSourceFileComposerFactory composerFactory=new ClassSourceFileComposerFactory(packageName,getProxySimpleName());
  String[] imports=new String[]{RemoteServiceProxy.class.getCanonicalName(),ClientSerializationStreamWriter.class.getCanonicalName(),GWT.class.getCanonicalName(),ResponseReader.class.getCanonicalName(),SerializationException.class.getCanonicalName()};
  for (  String imp : imports) {
    composerFactory.addImport(imp);
  }
  composerFactory.setSuperclass(RemoteServiceProxy.class.getSimpleName());
  composerFactory.addImplementedInterface(serviceAsync.getParameterizedQualifiedSourceName());
  return composerFactory.createSourceWriter(ctx,printWriter);
}","private SourceWriter getSourceWriter(TreeLogger logger,GeneratorContext ctx,JClassType serviceAsync){
  JPackage serviceIntfPkg=serviceAsync.getPackage();
  String packageName=serviceIntfPkg == null ? ""String_Node_Str"" : serviceIntfPkg.getName();
  PrintWriter printWriter=ctx.tryCreate(logger,packageName,getProxySimpleName());
  if (printWriter == null) {
    return null;
  }
  ClassSourceFileComposerFactory composerFactory=new ClassSourceFileComposerFactory(packageName,getProxySimpleName());
  String[] imports=new String[]{RemoteServiceProxy.class.getCanonicalName(),ClientSerializationStreamWriter.class.getCanonicalName(),GWT.class.getCanonicalName(),ResponseReader.class.getCanonicalName(),SerializationException.class.getCanonicalName()};
  for (  String imp : imports) {
    composerFactory.addImport(imp);
  }
  composerFactory.setSuperclass(RemoteServiceProxy.class.getSimpleName());
  composerFactory.addImplementedInterface(serviceAsync.getErasedType().getQualifiedSourceName());
  return composerFactory.createSourceWriter(ctx,printWriter);
}"
82700,"/** 
 * Check the argument to a parameterized type to see if it will make the type it is applied to be serializable. As a side effect, populates  {@link #typeToTypeInfoComputed} in the same way as{@link #checkTypeInstantiable(TreeLogger,JType,boolean)}.
 * @param logger
 * @param baseType - The generic type the parameter is on
 * @param paramIndex - The index of the parameter in the generic type
 * @param typeArg - An upper bound on the actual argument being applied to thegeneric type
 * @param isSpeculative
 * @return Whether the a parameterized type can be serializable if<code>baseType</code> is the base type and the <code>paramIndex</code>th type argument is a subtype of <code>typeArg</code>.
 */
private boolean checkTypeArgument(TreeLogger logger,JGenericType baseType,int paramIndex,JClassType typeArg,boolean isSpeculative,Path parent){
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && flowInfoForArrayParam.infiniteArrayExpansionPathBetween(otherFlowInfo)) {
          logger.branch(getLogLevel(isSpeculative),""String_Node_Str"" + baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ typeArg.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
          return false;
        }
      }
    }
  }
  Path path=createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case EXPOSURE_DIRECT:
    return checkTypeInstantiable(logger,typeArg,true,path) || mightNotBeExposed(baseType,paramIndex);
case EXPOSURE_NONE:
  return true;
default :
assert(exposure >= EXPOSURE_MIN_BOUNDED_ARRAY);
return checkTypeInstantiable(logger,getArrayType(typeOracle,exposure,typeArg),true,path) || mightNotBeExposed(baseType,paramIndex);
}
}","/** 
 * Check the argument to a parameterized type to see if it will make the type it is applied to be serializable. As a side effect, populates  {@link #typeToTypeInfoComputed} in the same way as{@link #checkTypeInstantiable(TreeLogger,JType,boolean)}.
 * @param logger
 * @param baseType - The generic type the parameter is on
 * @param paramIndex - The index of the parameter in the generic type
 * @param typeArg - An upper bound on the actual argument being applied to thegeneric type
 * @param isSpeculative
 * @return Whether the a parameterized type can be serializable if<code>baseType</code> is the base type and the <code>paramIndex</code>th type argument is a subtype of <code>typeArg</code>.
 */
private boolean checkTypeArgument(TreeLogger logger,JGenericType baseType,int paramIndex,JClassType typeArg,boolean isSpeculative,Path parent){
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && flowInfoForArrayParam.infiniteArrayExpansionPathBetween(otherFlowInfo)) {
          logger.branch(getLogLevel(isSpeculative),""String_Node_Str"" + baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ typeArg.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
          return false;
        }
      }
    }
  }
  Path path=createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case EXPOSURE_DIRECT:
{
      TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
      return checkTypeInstantiable(branch,typeArg,true,path) || mightNotBeExposed(baseType,paramIndex);
    }
case EXPOSURE_NONE:
  logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
return true;
default :
{
assert(exposure >= EXPOSURE_MIN_BOUNDED_ARRAY);
TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ exposure+ ""String_Node_Str"");
return checkTypeInstantiable(branch,getArrayType(typeOracle,exposure,typeArg),true,path) || mightNotBeExposed(baseType,paramIndex);
}
}
}"
82701,"private boolean checkFields(TreeLogger logger,JClassType classOrInterface,boolean isSpeculative,Path parent){
  TypeInfoComputed typeInfo=getTypeInfoComputed(classOrInterface,parent);
  JClassType superType=classOrInterface.getSuperclass();
  if (superType != null && getTypeInfoComputed(superType,parent).isDeclaredSerializable()) {
    boolean superTypeOk=checkFields(logger,superType,isSpeculative,parent);
    if (!superTypeOk && !typeInfo.isDirectlySerializable()) {
      return false;
    }
  }
  if (typeInfo.isManuallySerializable()) {
    isSpeculative=true;
  }
  boolean allSucceeded=true;
  JField[] fields=classOrInterface.getFields();
  if (fields.length > 0) {
    TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
    for (    JField field : fields) {
      if (!qualfiesForSerialization(localLogger,field)) {
        continue;
      }
      TreeLogger fieldLogger=localLogger.branch(TreeLogger.DEBUG,field.toString(),null);
      JType fieldType=field.getType();
      Path path=createFieldPath(parent,field);
      if (typeInfo.isManuallySerializable() && fieldType.getLeafType() == typeOracle.getJavaLangObject()) {
        checkAllSubtypesOfObject(fieldLogger.branch(TreeLogger.WARN,""String_Node_Str"",null),path);
      }
 else {
        allSucceeded&=checkTypeInstantiable(fieldLogger,fieldType,isSpeculative,path);
      }
    }
  }
  boolean succeeded=allSucceeded || typeInfo.isManuallySerializable();
  if (succeeded) {
    getTypeInfoComputed(classOrInterface,parent).setFieldSerializable();
  }
  return succeeded;
}","private boolean checkFields(TreeLogger logger,JClassType classOrInterface,boolean isSpeculative,Path parent){
  TypeInfoComputed typeInfo=getTypeInfoComputed(classOrInterface,parent);
  JClassType superType=classOrInterface.getSuperclass();
  if (superType != null && getTypeInfoComputed(superType,parent).isDeclaredSerializable()) {
    boolean superTypeOk=checkFields(logger,superType,isSpeculative,parent);
    if (!superTypeOk && !typeInfo.isDirectlySerializable()) {
      return false;
    }
  }
  if (typeInfo.isManuallySerializable()) {
    isSpeculative=true;
  }
  boolean allSucceeded=true;
  JField[] fields=classOrInterface.getFields();
  if (fields.length > 0) {
    TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classOrInterface.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
    for (    JField field : fields) {
      if (!qualfiesForSerialization(localLogger,field)) {
        continue;
      }
      TreeLogger fieldLogger=localLogger.branch(TreeLogger.DEBUG,field.toString(),null);
      JType fieldType=field.getType();
      Path path=createFieldPath(parent,field);
      if (typeInfo.isManuallySerializable() && fieldType.getLeafType() == typeOracle.getJavaLangObject()) {
        checkAllSubtypesOfObject(fieldLogger.branch(TreeLogger.WARN,""String_Node_Str"",null),path);
      }
 else {
        allSucceeded&=checkTypeInstantiable(fieldLogger,fieldType,isSpeculative,path);
      }
    }
  }
  boolean succeeded=allSucceeded || typeInfo.isManuallySerializable();
  if (succeeded) {
    getTypeInfoComputed(classOrInterface,parent).setFieldSerializable();
  }
  return succeeded;
}"
82702,"/** 
 * This method determines whether a type can be serialized by GWT. To do so, it must traverse all subtypes as well as all field types of those types, transitively. It returns a boolean indicating whether this type or any of its subtypes are instantiable. As a side effect, all types needed--plus some--to serialize this type are accumulated in   {@link #typeToTypeInfoComputed}. The method is exposed using default access to enable testing.
 */
final boolean checkTypeInstantiable(TreeLogger logger,JType type,boolean isSpeculative,final Path path){
  assert(type != null);
  if (type.isPrimitive() != null) {
    return true;
  }
  assert(type instanceof JClassType);
  JClassType classType=(JClassType)type;
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,classType.getParameterizedQualifiedSourceName(),null);
  if (!isAllowedByFilter(localLogger,classType,isSpeculative)) {
    return false;
  }
  JTypeParameter isTypeParameter=classType.isTypeParameter();
  if (isTypeParameter != null) {
    if (typeParametersInRootTypes.contains(isTypeParameter)) {
      return checkTypeInstantiable(localLogger,isTypeParameter.getFirstBound(),isSpeculative,path);
    }
    return true;
  }
  JWildcardType isWildcard=classType.isWildcard();
  if (isWildcard != null) {
    boolean success=true;
    for (    JClassType bound : isWildcard.getUpperBounds()) {
      success&=checkTypeInstantiable(localLogger,bound,isSpeculative,path);
    }
    return success;
  }
  TypeInfoComputed tic=getTypeInfoComputed(classType,path);
  if (tic.isPendingInstantiable()) {
    return true;
  }
 else   if (tic.isDone()) {
    return tic.hasInstantiableSubtypes();
  }
  tic.setPendingInstantiable();
  JArrayType isArray=classType.isArray();
  if (isArray != null) {
    JType leafType=isArray.getLeafType();
    JTypeParameter isLeafTypeParameter=leafType.isTypeParameter();
    if (isLeafTypeParameter != null && !typeParametersInRootTypes.contains(isLeafTypeParameter)) {
      tic.setInstantiable(false);
      tic.setInstantiableSubytpes(true);
      return true;
    }
    boolean succeeded=checkArrayInstantiable(localLogger,isArray,isSpeculative,path);
    if (succeeded) {
      JClassType leafClass=leafType.isClassOrInterface();
      if (leafClass != null) {
        JClassType[] leafSubtypes=leafClass.getErasedType().getSubtypes();
        for (        JClassType leafSubtype : leafSubtypes) {
          JArrayType covariantArray=getArrayType(typeOracle,isArray.getRank(),leafSubtype);
          checkTypeInstantiable(localLogger,covariantArray,true,path);
        }
      }
    }
    tic.setInstantiable(succeeded);
    return succeeded;
  }
  if (classType == typeOracle.getJavaLangObject()) {
    localLogger.branch(getLogLevel(isSpeculative),""String_Node_Str"",null);
    tic.setInstantiable(false);
    return false;
  }
  if (classType.isRawType() != null) {
    TreeLogger rawTypeLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classType.getQualifiedSourceName() + ""String_Node_Str"",null);
    if (classType.isAssignableTo(collectionClass) || classType.isAssignableTo(mapClass)) {
      checkAllSubtypesOfObject(rawTypeLogger,path);
    }
  }
  JClassType originalType=(JClassType)type;
  JRealClassType baseType;
  if (type.isRawType() != null) {
    baseType=type.isRawType().getBaseType();
  }
 else   if (type.isParameterized() != null) {
    baseType=type.isParameterized().getBaseType();
  }
 else {
    baseType=(JRealClassType)originalType;
  }
  if (isSpeculative && tic.isDirectlySerializable()) {
    isSpeculative=false;
  }
  boolean isInstantiable=checkTypeInstantiableNoSubtypes(localLogger,baseType,isSpeculative,path);
  JClassType[] typeArgs=NO_JCLASSES;
  JParameterizedType isParameterized=originalType.isParameterized();
  JGenericType baseAsGenericType=baseType.isGenericType();
  if (isParameterized != null) {
    typeArgs=isParameterized.getTypeArgs();
  }
 else   if (baseAsGenericType != null) {
    List<JClassType> arguments=new ArrayList<JClassType>();
    for (    JTypeParameter typeParameter : baseAsGenericType.getTypeParameters()) {
      arguments.add(typeParameter.getFirstBound());
    }
    typeArgs=arguments.toArray(NO_JCLASSES);
  }
  boolean parametersOkay=true;
  JRawType isRaw=originalType.isRawType();
  if (isParameterized != null || isRaw != null) {
    assert(baseAsGenericType != null);
    int numDeclaredParams=baseAsGenericType.getTypeParameters().length;
    if (numDeclaredParams == typeArgs.length) {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeArgument(localLogger,baseAsGenericType,i,typeArg,isSpeculative,path);
      }
    }
 else {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeInstantiable(localLogger,typeArg,isSpeculative,path);
      }
    }
  }
  isInstantiable&=parametersOkay;
  boolean anySubtypes=false;
  if (parametersOkay) {
    JClassType[] subtypes=baseType.getSubtypes();
    if (subtypes.length > 0) {
      TreeLogger subtypesLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
      for (      JClassType subtype : subtypes) {
        TreeLogger subtypeLogger=subtypesLogger.branch(TreeLogger.DEBUG,subtype.getParameterizedQualifiedSourceName(),null);
        Path subtypePath=createSubtypePath(path,subtype,originalType);
        boolean subInstantiable=checkTypeInstantiableNoSubtypes(subtypeLogger,subtype,true,subtypePath);
        JGenericType genericSub=subtype.isGenericType();
        if (genericSub != null) {
          TreeLogger paramsLogger=subtypeLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + genericSub.getParameterizedQualifiedSourceName() + ""String_Node_Str"");
          Map<JTypeParameter,Set<JTypeParameter>> subParamsConstrainedBy=subParamsConstrainedBy(baseType,genericSub);
          for (int i=0; i < genericSub.getTypeParameters().length; i++) {
            JTypeParameter param=genericSub.getTypeParameters()[i];
            TreeLogger paramLogger=paramsLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + param.getParameterizedQualifiedSourceName() + ""String_Node_Str"");
            Set<JTypeParameter> constBy=subParamsConstrainedBy.get(param);
            if (constBy == null) {
              subInstantiable&=checkTypeArgument(paramLogger,genericSub,i,param.getFirstBound(),true,path);
            }
 else {
              boolean paramOK=false;
              for (              JTypeParameter constrained : constBy) {
                paramOK|=checkTypeArgument(paramLogger,genericSub,i,typeArgs[constrained.getOrdinal()],true,path);
              }
              subInstantiable&=paramOK;
            }
          }
        }
 else {
          if (subInstantiable && isParameterized != null) {
            HashSet<JTypeParameter> typeParamsInQueryType=new HashSet<JTypeParameter>();
            recordTypeParametersIn(isParameterized,typeParamsInQueryType);
            if (typeParamsInQueryType.isEmpty()) {
              if (!isParameterized.isAssignableFrom(subtype)) {
                subtypeLogger.log(TreeLogger.DEBUG,""String_Node_Str"" + subtype.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ isParameterized.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
                subInstantiable=false;
              }
            }
          }
        }
        if (subInstantiable) {
          getTypeInfoComputed(subtype,path).setInstantiable(true);
          anySubtypes=true;
        }
      }
    }
  }
  anySubtypes|=isInstantiable;
  tic.setInstantiable(isInstantiable);
  tic.setInstantiableSubytpes(anySubtypes);
  if (!anySubtypes && !isSpeculative) {
    localLogger.branch(getLogLevel(isSpeculative),""String_Node_Str"" + classType.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
  }
  return tic.hasInstantiableSubtypes();
}","/** 
 * This method determines whether a type can be serialized by GWT. To do so, it must traverse all subtypes as well as all field types of those types, transitively. It returns a boolean indicating whether this type or any of its subtypes are instantiable. As a side effect, all types needed--plus some--to serialize this type are accumulated in   {@link #typeToTypeInfoComputed}. The method is exposed using default access to enable testing.
 */
final boolean checkTypeInstantiable(TreeLogger logger,JType type,boolean isSpeculative,final Path path){
  assert(type != null);
  if (type.isPrimitive() != null) {
    return true;
  }
  assert(type instanceof JClassType);
  JClassType classType=(JClassType)type;
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,classType.getParameterizedQualifiedSourceName(),null);
  if (!isAllowedByFilter(localLogger,classType,isSpeculative)) {
    return false;
  }
  JTypeParameter isTypeParameter=classType.isTypeParameter();
  if (isTypeParameter != null) {
    if (typeParametersInRootTypes.contains(isTypeParameter)) {
      return checkTypeInstantiable(localLogger,isTypeParameter.getFirstBound(),isSpeculative,path);
    }
    return true;
  }
  JWildcardType isWildcard=classType.isWildcard();
  if (isWildcard != null) {
    boolean success=true;
    for (    JClassType bound : isWildcard.getUpperBounds()) {
      success&=checkTypeInstantiable(localLogger,bound,isSpeculative,path);
    }
    return success;
  }
  TypeInfoComputed tic=getTypeInfoComputed(classType,path);
  if (tic.isPendingInstantiable()) {
    return true;
  }
 else   if (tic.isDone()) {
    return tic.hasInstantiableSubtypes();
  }
  tic.setPendingInstantiable();
  JArrayType isArray=classType.isArray();
  if (isArray != null) {
    JType leafType=isArray.getLeafType();
    JTypeParameter isLeafTypeParameter=leafType.isTypeParameter();
    if (isLeafTypeParameter != null && !typeParametersInRootTypes.contains(isLeafTypeParameter)) {
      tic.setInstantiable(false);
      tic.setInstantiableSubytpes(true);
      return true;
    }
    boolean succeeded=checkArrayInstantiable(localLogger,isArray,isSpeculative,path);
    if (succeeded) {
      JClassType leafClass=leafType.isClassOrInterface();
      if (leafClass != null) {
        JClassType[] leafSubtypes=leafClass.getErasedType().getSubtypes();
        for (        JClassType leafSubtype : leafSubtypes) {
          if (leafSubtype.isRawType() != null) {
            JGenericType leafGenericSub=leafSubtype.isRawType().getBaseType();
            leafSubtype=typeOracle.getParameterizedType(leafGenericSub,leafGenericSub.getTypeParameters());
          }
          if (!isAccessibleToClassesInSamePackage(leafSubtype)) {
            continue;
          }
          JArrayType covariantArray=getArrayType(typeOracle,isArray.getRank(),leafSubtype);
          checkTypeInstantiable(localLogger,covariantArray,true,path);
        }
      }
    }
    tic.setInstantiable(succeeded);
    return succeeded;
  }
  if (classType == typeOracle.getJavaLangObject()) {
    localLogger.branch(getLogLevel(isSpeculative),""String_Node_Str"",null);
    tic.setInstantiable(false);
    return false;
  }
  if (classType.isRawType() != null) {
    TreeLogger rawTypeLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classType.getQualifiedSourceName() + ""String_Node_Str"",null);
    if (classType.isAssignableTo(collectionClass) || classType.isAssignableTo(mapClass)) {
      checkAllSubtypesOfObject(rawTypeLogger,path);
    }
  }
  JClassType originalType=(JClassType)type;
  JRealClassType baseType;
  if (type.isRawType() != null) {
    baseType=type.isRawType().getBaseType();
  }
 else   if (type.isParameterized() != null) {
    baseType=type.isParameterized().getBaseType();
  }
 else {
    baseType=(JRealClassType)originalType;
  }
  if (isSpeculative && tic.isDirectlySerializable()) {
    isSpeculative=false;
  }
  boolean isInstantiable=checkTypeInstantiableNoSubtypes(localLogger,baseType,isSpeculative,path);
  JClassType[] typeArgs=NO_JCLASSES;
  JParameterizedType isParameterized=originalType.isParameterized();
  JGenericType baseAsGenericType=baseType.isGenericType();
  if (isParameterized != null) {
    typeArgs=isParameterized.getTypeArgs();
  }
 else   if (baseAsGenericType != null) {
    List<JClassType> arguments=new ArrayList<JClassType>();
    for (    JTypeParameter typeParameter : baseAsGenericType.getTypeParameters()) {
      arguments.add(typeParameter.getFirstBound());
    }
    typeArgs=arguments.toArray(NO_JCLASSES);
  }
  boolean parametersOkay=true;
  JRawType isRaw=originalType.isRawType();
  if (isParameterized != null || isRaw != null) {
    assert(baseAsGenericType != null);
    int numDeclaredParams=baseAsGenericType.getTypeParameters().length;
    if (numDeclaredParams == typeArgs.length) {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeArgument(localLogger,baseAsGenericType,i,typeArg,isSpeculative,path);
      }
    }
 else {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeInstantiable(localLogger,typeArg,isSpeculative,path);
      }
    }
  }
  isInstantiable&=parametersOkay;
  boolean anySubtypes=false;
  if (parametersOkay) {
    JClassType[] subtypes=baseType.getSubtypes();
    if (subtypes.length > 0) {
      TreeLogger subtypesLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
      for (      JClassType subtype : subtypes) {
        TreeLogger subtypeLogger=subtypesLogger.branch(TreeLogger.DEBUG,subtype.getParameterizedQualifiedSourceName(),null);
        Path subtypePath=createSubtypePath(path,subtype,originalType);
        boolean subInstantiable=checkTypeInstantiableNoSubtypes(subtypeLogger,subtype,true,subtypePath);
        if (!subInstantiable) {
          continue;
        }
        JGenericType genericSub=subtype.isGenericType();
        if (genericSub != null) {
          TreeLogger paramsLogger=subtypeLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + genericSub.getParameterizedQualifiedSourceName() + ""String_Node_Str"");
          Map<JTypeParameter,Set<JTypeParameter>> subParamsConstrainedBy=subParamsConstrainedBy(baseType,genericSub);
          for (int i=0; i < genericSub.getTypeParameters().length; i++) {
            JTypeParameter param=genericSub.getTypeParameters()[i];
            TreeLogger paramLogger=paramsLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + param.getParameterizedQualifiedSourceName() + ""String_Node_Str"");
            Set<JTypeParameter> constBy=subParamsConstrainedBy.get(param);
            if (constBy == null) {
              subInstantiable&=checkTypeArgument(paramLogger,genericSub,i,param.getFirstBound(),true,path);
            }
 else {
              boolean paramOK=false;
              for (              JTypeParameter constrained : constBy) {
                paramOK|=checkTypeArgument(paramLogger,genericSub,i,typeArgs[constrained.getOrdinal()],true,path);
              }
              subInstantiable&=paramOK;
            }
          }
        }
 else {
          if (isParameterized != null) {
            HashSet<JTypeParameter> typeParamsInQueryType=new HashSet<JTypeParameter>();
            recordTypeParametersIn(isParameterized,typeParamsInQueryType);
            if (typeParamsInQueryType.isEmpty()) {
              if (!isParameterized.isAssignableFrom(subtype)) {
                subtypeLogger.log(TreeLogger.DEBUG,""String_Node_Str"" + subtype.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ isParameterized.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
                subInstantiable=false;
              }
            }
          }
        }
        if (subInstantiable) {
          getTypeInfoComputed(subtype,path).setInstantiable(true);
          anySubtypes=true;
        }
      }
    }
  }
  anySubtypes|=isInstantiable;
  tic.setInstantiable(isInstantiable);
  tic.setInstantiableSubytpes(anySubtypes);
  if (!anySubtypes && !isSpeculative) {
    localLogger.branch(getLogLevel(isSpeculative),""String_Node_Str"" + classType.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
  }
  return tic.hasInstantiableSubtypes();
}"
82703,"/** 
 * Returns <code>true</code> if the query type is accessible to classes in the same package.
 */
private static boolean isAccessibleToClassesInSamePackage(JClassType type){
  if (type.isPrivate()) {
    return false;
  }
  if (type.isMemberType()) {
    return isAccessibleToClassesInSamePackage(type.getEnclosingType());
  }
  return true;
}","/** 
 * Returns <code>true</code> if the query type is accessible to classes in the same package.
 */
private static boolean isAccessibleToClassesInSamePackage(JClassType type){
  if (type.isPrivate() || type.isLocalType()) {
    return false;
  }
  if (type.isMemberType()) {
    return isAccessibleToClassesInSamePackage(type.getEnclosingType());
  }
  return true;
}"
82704,"private Map<String,Resource> rerootResourcePaths(Map<String,AbstractResource> newInternalMap){
  Map<String,Resource> externalMap;
  externalMap=new HashMap<String,Resource>();
  for (  AbstractResource resource : newInternalMap.values()) {
    String path=resource.getPath();
    if (externalMap.get(path) instanceof ResourceWrapper) {
      continue;
    }
    for (    PathPrefix pathPrefix : pathPrefixSet.values()) {
      if (pathPrefix.allows(path)) {
        assert(path.startsWith(pathPrefix.getPrefix()));
        if (pathPrefix.shouldReroot()) {
          path=pathPrefix.getRerootedPath(path);
          AbstractResource wrapper=new ResourceWrapper(path,resource);
          externalMap.put(path,wrapper);
        }
 else {
          externalMap.put(path,resource);
        }
        break;
      }
    }
    assert(externalMap.containsKey(path));
  }
  return externalMap;
}","private Map<String,Resource> rerootResourcePaths(Map<String,AbstractResource> newInternalMap){
  Map<String,Resource> externalMap;
  externalMap=new HashMap<String,Resource>();
  for (  AbstractResource resource : newInternalMap.values()) {
    String path=resource.getPath();
    if (externalMap.get(path) instanceof ResourceWrapper) {
      continue;
    }
    for (    PathPrefix pathPrefix : pathPrefixSet.values()) {
      if (pathPrefix.allows(path)) {
        assert(path.startsWith(pathPrefix.getPrefix()));
        if (pathPrefix.shouldReroot()) {
          path=pathPrefix.getRerootedPath(path);
          Resource exposed=exposedResourceMap.get(path);
          if (exposed instanceof ResourceWrapper) {
            ResourceWrapper exposedWrapper=(ResourceWrapper)exposed;
            if (exposedWrapper.resource == resource) {
              externalMap.put(path,exposedWrapper);
              break;
            }
          }
          AbstractResource wrapper=new ResourceWrapper(path,resource);
          externalMap.put(path,wrapper);
        }
 else {
          externalMap.put(path,resource);
        }
        break;
      }
    }
    assert(externalMap.containsKey(path));
  }
  return externalMap;
}"
82705,"public void testReplaceString(){
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
}","public void testReplaceString(){
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
}"
82706,private static native void initUrlCheckTimer();,private native void initUrlCheckTimer();
82707,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new TestFireEvents());
}"
82708,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new TestFireEvents());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2392());
  addIssue(new TestFireEvents());
}"
82709,private static native boolean detectOldSafari();,static native boolean detectOldSafari();
82710,"public void testTokenEscaping(){
  final String escToken=""String_Node_Str"";
  delayTestFinish(5000);
  History.addHistoryListener(new HistoryListener(){
    public void onHistoryChanged(    String token){
      assertEquals(escToken,token);
      finishTest();
      History.removeHistoryListener(this);
    }
  }
);
  History.newItem(escToken);
}","public void testTokenEscaping(){
  final String shouldBeEncoded=""String_Node_Str"";
  final String shouldBeEncodedAs=""String_Node_Str"";
  delayTestFinish(5000);
  History.addHistoryListener(new HistoryListener(){
    public void onHistoryChanged(    String token){
      assertEquals(shouldBeEncodedAs,getCurrentLocationHash());
      assertEquals(shouldBeEncoded,token);
      finishTest();
      History.removeHistoryListener(this);
    }
  }
);
  History.newItem(shouldBeEncoded);
}"
82711,"/** 
 * This method formats a <code>double</code> into a fractional representation.
 * @param number value need to be formated
 * @param result result will be written here
 * @param minIntDigits minimum integer digits
 */
private void subformatFixed(double number,StringBuffer result,int minIntDigits){
  double power=Math.pow(10,maximumFractionDigits);
  number=Math.round(number * power);
  double intValue=(double)Math.floor(number / power);
  double fracValue=(double)Math.floor(number - intValue * power);
  boolean fractionPresent=(minimumFractionDigits > 0) || (fracValue > 0);
  String intPart=String.valueOf(intValue);
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  int zeroDelta=numberConstants.zeroDigit().charAt(0) - '0';
  int digitLen=intPart.length();
  if (intValue > 0 || minIntDigits > 0) {
    for (int i=digitLen; i < minIntDigits; i++) {
      result.append(numberConstants.zeroDigit());
    }
    for (int i=0; i < digitLen; i++) {
      result.append((char)(intPart.charAt(i) + zeroDelta));
      if (digitLen - i > 1 && groupingSize > 0 && ((digitLen - i) % groupingSize == 1)) {
        result.append(grouping);
      }
    }
  }
 else   if (!fractionPresent) {
    result.append(numberConstants.zeroDigit());
  }
  if (decimalSeparatorAlwaysShown || fractionPresent) {
    result.append(decimal);
  }
  String fracPart=String.valueOf(fracValue + power);
  int fracLen=fracPart.length();
  while (fracPart.charAt(fracLen - 1) == '0' && fracLen > minimumFractionDigits + 1) {
    fracLen--;
  }
  for (int i=1; i < fracLen; i++) {
    result.append((char)(fracPart.charAt(i) + zeroDelta));
  }
}","/** 
 * This method formats a <code>double</code> into a fractional representation.
 * @param number value need to be formated
 * @param result result will be written here
 * @param minIntDigits minimum integer digits
 */
private void subformatFixed(double number,StringBuffer result,int minIntDigits){
  double power=Math.pow(10,maximumFractionDigits);
  double intValue=(double)Math.floor(number);
  double fracValue=(double)Math.floor((number - intValue) * power + 0.5d);
  if (fracValue >= power) {
    intValue+=1.0;
    fracValue-=power;
  }
  boolean fractionPresent=(minimumFractionDigits > 0) || (fracValue > 0);
  String intPart=makeIntString(intValue);
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  int zeroDelta=numberConstants.zeroDigit().charAt(0) - '0';
  int digitLen=intPart.length();
  if (intValue > 0 || minIntDigits > 0) {
    for (int i=digitLen; i < minIntDigits; i++) {
      result.append(numberConstants.zeroDigit());
    }
    for (int i=0; i < digitLen; i++) {
      result.append((char)(intPart.charAt(i) + zeroDelta));
      if (digitLen - i > 1 && groupingSize > 0 && ((digitLen - i) % groupingSize == 1)) {
        result.append(grouping);
      }
    }
  }
 else   if (!fractionPresent) {
    result.append(numberConstants.zeroDigit());
  }
  if (decimalSeparatorAlwaysShown || fractionPresent) {
    result.append(decimal);
  }
  String fracPart=makeIntString(Math.floor(fracValue + power + 0.5d));
  int fracLen=fracPart.length();
  while (fracPart.charAt(fracLen - 1) == '0' && fracLen > minimumFractionDigits + 1) {
    fracLen--;
  }
  for (int i=1; i < fracLen; i++) {
    result.append((char)(fracPart.charAt(i) + zeroDelta));
  }
}"
82712,"public synchronized void refresh(TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  lazyPublicOracle.refresh(logger);
  compilationState.refresh();
  if (lazyTypeOracle != null) {
    updateTypeOracle(logger);
  }
  PerfLogger.end();
}","public synchronized void refresh(TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  lazyPublicOracle.refresh(logger);
  lazySourceOracle.refresh(logger);
  compilationState.refresh();
  if (lazyTypeOracle != null) {
    updateTypeOracle(logger);
  }
  PerfLogger.end();
}"
82713,"/** 
 * Runs a particular test case.
 */
private void runTestImpl(String moduleName,TestCase testCase,TestResult testResult,Strategy strategy) throws UnableToCompleteException {
  if (lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  String syntheticModuleName=moduleName + ""String_Node_Str"" + strategy.getSyntheticModuleExtension();
  boolean sameTest=(currentModule != null) && syntheticModuleName.equals(currentModule.getName());
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  if (!sameTest) {
    currentModule=ModuleDefLoader.createSyntheticModule(getTopLogger(),syntheticModuleName,new String[]{moduleName,strategy.getModuleInherit()},true);
    currentModule.clearEntryPoints();
    currentModule.addEntryPointTypeName(GWTRunner.class.getName());
    Property moduleNameProp=currentModule.getProperties().create(""String_Node_Str"");
    moduleNameProp.addKnownValue(moduleName);
    moduleNameProp.setActiveValue(moduleName);
    runStyle.maybeCompileModule(syntheticModuleName);
  }
  messageQueue.setNextTest(new TestInfo(currentModule.getName(),testCase.getClass().getName(),testCase.getName()));
  try {
    if (firstLaunch) {
      runStyle.launchModule(currentModule.getName());
    }
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTime=System.currentTimeMillis();
    testBeginTimeout=testBeginTime + TEST_BEGIN_TIMEOUT_MILLIS;
    pumpEventLoop();
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  assert(messageQueue.hasResult());
  Map<String,JUnitResult> results=messageQueue.getResults();
  boolean parallelTesting=numClients > 1;
  for (  Entry<String,JUnitResult> entry : results.entrySet()) {
    String clientId=entry.getKey();
    JUnitResult result=entry.getValue();
    Throwable exception=result.getException();
    if (parallelTesting && exception != null) {
      String msg=""String_Node_Str"" + clientId;
      if (exception instanceof AssertionFailedError) {
        AssertionFailedError newException=new AssertionFailedError(msg + ""String_Node_Str"" + exception.getMessage());
        newException.setStackTrace(exception.getStackTrace());
        exception=newException;
      }
 else {
        exception=new RuntimeException(msg,exception);
      }
    }
    if (exception instanceof AssertionFailedError) {
      testResult.addFailure(testCase,(AssertionFailedError)exception);
    }
 else     if (exception != null) {
      if (exception instanceof JUnitFatalLaunchException) {
        lastLaunchFailed=true;
      }
      testResult.addError(testCase,exception);
    }
    strategy.processResult(testCase,result);
  }
}","/** 
 * Runs a particular test case.
 */
private void runTestImpl(String moduleName,TestCase testCase,TestResult testResult,Strategy strategy) throws UnableToCompleteException {
  if (lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  String syntheticModuleName=moduleName + ""String_Node_Str"" + strategy.getSyntheticModuleExtension();
  boolean sameTest=(currentModule != null) && syntheticModuleName.equals(currentModule.getName());
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  if (!sameTest) {
    currentModule=ModuleDefLoader.createSyntheticModule(getTopLogger(),syntheticModuleName,new String[]{moduleName,strategy.getModuleInherit()},true);
    currentModule.clearEntryPoints();
    currentModule.addEntryPointTypeName(GWTRunner.class.getName());
    Property moduleNameProp=currentModule.getProperties().create(""String_Node_Str"");
    moduleNameProp.addKnownValue(moduleName);
    moduleNameProp.setActiveValue(moduleName);
    runStyle.maybeCompileModule(syntheticModuleName);
  }
  messageQueue.setNextTest(new TestInfo(currentModule.getName(),testCase.getClass().getName(),testCase.getName()));
  try {
    if (firstLaunch) {
      runStyle.launchModule(currentModule.getName());
    }
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTime=System.currentTimeMillis();
    testBeginTimeout=testBeginTime + TEST_BEGIN_TIMEOUT_MILLIS;
    pumpEventLoop();
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  assert(messageQueue.hasResult());
  Map<String,JUnitResult> results=messageQueue.getResults();
  boolean parallelTesting=numClients > 1;
  for (  Entry<String,JUnitResult> entry : results.entrySet()) {
    String clientId=entry.getKey();
    JUnitResult result=entry.getValue();
    Throwable exception=null;
    if (result == null) {
      String msg=""String_Node_Str"" + clientId;
      exception=new RuntimeException();
    }
 else {
      exception=result.getException();
      if (parallelTesting && exception != null) {
        String msg=""String_Node_Str"" + clientId;
        if (exception instanceof AssertionFailedError) {
          AssertionFailedError newException=new AssertionFailedError(msg + ""String_Node_Str"" + exception.getMessage());
          newException.setStackTrace(exception.getStackTrace());
          exception=newException;
        }
 else {
          exception=new RuntimeException(msg,exception);
        }
      }
    }
    if (exception instanceof AssertionFailedError) {
      testResult.addFailure(testCase,(AssertionFailedError)exception);
    }
 else     if (exception != null) {
      if (exception instanceof JUnitFatalLaunchException) {
        lastLaunchFailed=true;
      }
      testResult.addError(testCase,exception);
    }
    strategy.processResult(testCase,result);
  }
}"
82714,"@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes;
  try {
    String lookupClassName=className;
    if (classRewriter != null && classRewriter.isJsoImpl(className)) {
      lookupClassName=className.substring(0,className.length() - 1);
    }
    classBytes=compiler.getClassBytes(logger,lookupClassName);
    if (classRewriter != null) {
      classBytes=classRewriter.rewrite(className,classBytes);
    }
    Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
    if (className.equals(JavaScriptHost.class.getName())) {
      javaScriptHostClass=newClass;
      updateJavaScriptHost();
    }
    return newClass;
  }
 catch (  UnableToCompleteException e) {
    throw new ClassNotFoundException(className);
  }
}","@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes;
  try {
    ++stackDepth;
    String lookupClassName=className;
    if (classRewriter != null && classRewriter.isJsoImpl(className)) {
      lookupClassName=className.substring(0,className.length() - 1);
    }
    classBytes=compiler.getClassBytes(logger,lookupClassName);
    if (classRewriter != null) {
      classBytes=classRewriter.rewrite(className,classBytes);
    }
    Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
    if (className.equals(JavaScriptHost.class.getName())) {
      javaScriptHostClass=newClass;
      updateJavaScriptHost();
    }
    return newClass;
  }
 catch (  UnableToCompleteException e) {
    throw new ClassNotFoundException(className);
  }
 finally {
    --stackDepth;
  }
}"
82715,"/** 
 * Overridden to process JSNI annotations.
 */
@Override protected synchronized Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {
  Class<?> newClass=super.loadClass(name,resolve);
  JsniMethods jsniMethods=newClass.getAnnotation(JsniMethods.class);
  if (jsniMethods != null) {
    for (    JsniMethod jsniMethod : jsniMethods.value()) {
      String[] bodyParts=jsniMethod.body();
      int size=0;
      for (      String bodyPart : bodyParts) {
        size+=bodyPart.length();
      }
      StringBuilder body=new StringBuilder(size);
      for (      String bodyPart : bodyParts) {
        body.append(bodyPart);
      }
      shellJavaScriptHost.createNative(jsniMethod.file(),jsniMethod.line(),jsniMethod.name(),jsniMethod.paramNames(),body.toString());
    }
  }
  return newClass;
}","/** 
 * Overridden to process JSNI annotations.
 */
@Override protected synchronized Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {
  Class<?> newClass=super.loadClass(name,resolve);
  if (!newClass.isInterface() && !newClass.isLocalClass()) {
    pendingJsniInjectionClasses.add(newClass);
  }
  if (stackDepth == 0 && !pendingJsniInjectionClasses.isEmpty()) {
    Class<?>[] toCheck=pendingJsniInjectionClasses.toArray(new Class<?>[pendingJsniInjectionClasses.size()]);
    pendingJsniInjectionClasses.clear();
    for (    Class<?> checkClass : toCheck) {
      JsniMethods jsniMethods=checkClass.getAnnotation(JsniMethods.class);
      if (jsniMethods != null) {
        for (        JsniMethod jsniMethod : jsniMethods.value()) {
          String[] bodyParts=jsniMethod.body();
          int size=0;
          for (          String bodyPart : bodyParts) {
            size+=bodyPart.length();
          }
          StringBuilder body=new StringBuilder(size);
          for (          String bodyPart : bodyParts) {
            body.append(bodyPart);
          }
          shellJavaScriptHost.createNative(jsniMethod.file(),jsniMethod.line(),jsniMethod.name(),jsniMethod.paramNames(),body.toString());
        }
      }
    }
  }
  return newClass;
}"
82716,"protected static void validateDeclaredAnnotations(Annotation[] expected,Annotation[] actual){
  assertArraysEqual(expected,actual);
}","protected static void validateDeclaredAnnotations(Annotation[] expected,Annotation[] actual){
  Arrays.sort(expected,ANNOTATION_COMPARATOR);
  Arrays.sort(actual,ANNOTATION_COMPARATOR);
  assertArraysEqual(expected,actual);
}"
82717,"protected static void validateAnnotations(Annotation[] expected,Annotation[] actual){
  assertArraysEqual(expected,actual);
}","protected static void validateAnnotations(Annotation[] expected,Annotation[] actual){
  Arrays.sort(expected,ANNOTATION_COMPARATOR);
  Arrays.sort(actual,ANNOTATION_COMPARATOR);
  assertArraysEqual(expected,actual);
}"
82718,"protected static void validateMetaDataTags(HasMetaData md1,HasMetaData md2){
  assertEquals(md1.getMetaDataTags().length,md2.getMetaDataTags().length);
}","@SuppressWarnings(""String_Node_Str"") protected static void validateMetaDataTags(HasMetaData md1,HasMetaData md2){
  assertEquals(md1.getMetaDataTags().length,md2.getMetaDataTags().length);
}"
82719,"protected static void validateMetaData(HasMetaData md1,HasMetaData md2){
  validateMetaDataTags(md1,md2);
  String[] md1TagNames=md1.getMetaDataTags();
  String[] md2TagNames=md2.getMetaDataTags();
  for (int i=0; i < md1TagNames.length; ++i) {
    assertEquals(md1TagNames[i],md2TagNames[i]);
    String[][] md1TagValues=md1.getMetaData(md1TagNames[i]);
    String[][] md2TagValues=md2.getMetaData(md2TagNames[i]);
    assertTrue(Arrays.deepEquals(md1TagValues,md2TagValues));
  }
}","@SuppressWarnings(""String_Node_Str"") protected static void validateMetaData(HasMetaData md1,HasMetaData md2){
  validateMetaDataTags(md1,md2);
  String[] md1TagNames=md1.getMetaDataTags();
  String[] md2TagNames=md2.getMetaDataTags();
  for (int i=0; i < md1TagNames.length; ++i) {
    assertEquals(md1TagNames[i],md2TagNames[i]);
    String[][] md1TagValues=md1.getMetaData(md1TagNames[i]);
    String[][] md2TagValues=md2.getMetaData(md2TagNames[i]);
    assertTrue(Arrays.deepEquals(md1TagValues,md2TagValues));
  }
}"
82720,"public boolean execute(){
  if (++executionCount >= 10) {
    fail(""String_Node_Str"");
  }
  if (executionCount == 9) {
    finishTest();
  }
  return executionCount < 10;
}","public boolean execute(){
  if (++executionCount > 10) {
    fail(""String_Node_Str"");
  }
  if (executionCount == 10) {
    finishTest();
  }
  return executionCount < 10;
}"
82721,"/** 
 * Test method for  {@link com.google.gwt.user.client.CommandExecutor#submit(com.google.gwt.user.client.IncrementalCommand)}. <p/> Cases: <ul> <li>Submit <code>null</code></li> <li>Submit   {@link IncrementalCommand} and make sure that it fires as manytimes as we want it to</li> </ul>
 */
public void testSubmitIncrementalCommand(){
  CommandExecutor ce=new CommandExecutor();
  ce.submit((Command)null);
  delayTestFinish(TEST_FINISH_DELAY_MILLIS);
  ce.submit(new IncrementalCommand(){
    private int executionCount=0;
    public boolean execute(){
      if (++executionCount >= 10) {
        fail(""String_Node_Str"");
      }
      if (executionCount == 9) {
        finishTest();
      }
      return executionCount < 10;
    }
  }
);
}","/** 
 * Test method for  {@link com.google.gwt.user.client.CommandExecutor#submit(com.google.gwt.user.client.IncrementalCommand)}. <p/> Cases: <ul> <li>Submit <code>null</code></li> <li>Submit   {@link IncrementalCommand} and make sure that it fires as manytimes as we want it to</li> </ul>
 */
public void testSubmitIncrementalCommand(){
  CommandExecutor ce=new CommandExecutor();
  ce.submit((Command)null);
  delayTestFinish(TEST_FINISH_DELAY_MILLIS);
  ce.submit(new IncrementalCommand(){
    private int executionCount=0;
    public boolean execute(){
      if (++executionCount > 10) {
        fail(""String_Node_Str"");
      }
      if (executionCount == 10) {
        finishTest();
      }
      return executionCount < 10;
    }
  }
);
}"
82722,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
}"
82723,"@Override public void onStart(){
  onUpdate(0.0);
  UIObject.setVisible(container1,true);
  UIObject.setVisible(container2,true);
}","@Override public void onStart(){
  com.google.gwt.dom.client.Element deckElem=container1.getParentElement();
  int deckHeight=deckElem.getOffsetHeight();
  if (growing) {
    fixedHeight=container2.getOffsetHeight();
    container2.getStyle().setPropertyPx(""String_Node_Str"",fixedHeight - 1);
  }
 else {
    fixedHeight=container1.getOffsetHeight();
    container1.getStyle().setPropertyPx(""String_Node_Str"",fixedHeight - 1);
  }
  if (deckElem.getOffsetHeight() != deckHeight) {
    fixedHeight=-1;
  }
  onUpdate(0.0);
  UIObject.setVisible(container1,true);
  UIObject.setVisible(container2,true);
}"
82724,"@Override public void onUpdate(double progress){
  if (!growing) {
    progress=1.0 - progress;
  }
  int height1;
  int height2;
  if (fixedHeight == -1) {
    height1=(int)(progress * DOM.getElementPropertyInt(container1,""String_Node_Str""));
    height2=(int)((1.0 - progress) * DOM.getElementPropertyInt(container2,""String_Node_Str""));
  }
 else {
    height1=(int)(progress * fixedHeight);
    height2=fixedHeight - height1;
  }
  DOM.setStyleAttribute(container1,""String_Node_Str"",height1 + ""String_Node_Str"");
  DOM.setStyleAttribute(container2,""String_Node_Str"",height2 + ""String_Node_Str"");
}","@Override public void onUpdate(double progress){
  if (!growing) {
    progress=1.0 - progress;
  }
  int height1;
  int height2;
  if (fixedHeight == -1) {
    height1=(int)(progress * DOM.getElementPropertyInt(container1,""String_Node_Str""));
    height2=(int)((1.0 - progress) * DOM.getElementPropertyInt(container2,""String_Node_Str""));
  }
 else {
    height1=(int)(progress * fixedHeight);
    height2=fixedHeight - height1;
  }
  if (height1 == 0) {
    height1=1;
    height2=Math.max(1,height2 - 1);
  }
 else   if (height2 == 0) {
    height2=1;
    height1=Math.max(1,height1 - 1);
  }
  DOM.setStyleAttribute(container1,""String_Node_Str"",height1 + ""String_Node_Str"");
  DOM.setStyleAttribute(container2,""String_Node_Str"",height2 + ""String_Node_Str"");
}"
82725,"/** 
 * Returns a pretty printed list of clients that have not retrieved the current test. Used for error reporting.
 * @return a string containing the list of clients that have not retrieved thecurrent test.
 */
String getUnretrievedClients(){
  StringBuilder buf=new StringBuilder();
synchronized (clientStatusesLock) {
    int lineCount=0;
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      if (!clientStatus.hasRequestedCurrentTest) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(clientStatus.clientId);
      lineCount++;
    }
    int difference=numClients - numClientsHaveRequestedTest;
    if (difference > 0) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      buf.append(""String_Node_Str"" + difference + ""String_Node_Str"");
    }
  }
  return buf.toString();
}","/** 
 * Returns a pretty printed list of clients that have not retrieved the current test. Used for error reporting.
 * @return a string containing the list of clients that have not retrieved thecurrent test.
 */
String getUnretrievedClients(){
synchronized (clientStatusesLock) {
    StringBuilder buf=new StringBuilder();
    int lineCount=0;
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      if (!clientStatus.hasRequestedCurrentTest) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(clientStatus.clientId);
      lineCount++;
    }
    int difference=numClients - numClientsHaveRequestedTest;
    if (difference > 0) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      buf.append(""String_Node_Str"" + difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}"
82726,"/** 
 * Called by the servlet to query for for the next method to test.
 * @param timeout how long to wait for an answer
 * @return the next test to run, or <code>null</code> if<code>timeout</code> is exceeded or the next test does not match <code>testClassName</code>
 */
public TestInfo getNextTestInfo(String clientId,long timeout) throws TimeoutException {
synchronized (clientStatusesLock) {
    ClientStatus clientStatus=clientStatuses.get(clientId);
    if (clientStatus == null) {
      clientStatus=new ClientStatus(clientId);
      clientStatuses.put(clientId,clientStatus);
    }
    long startTime=System.currentTimeMillis();
    long stopTime=startTime + timeout;
    while (clientStatus.hasRequestedCurrentTest == true) {
      long timeToWait=stopTime - System.currentTimeMillis();
      if (timeToWait < 1) {
        double elapsed=(System.currentTimeMillis() - startTime) / 1000.0;
        throw new TimeoutException(""String_Node_Str"" + ""String_Node_Str"" + timeout + ""String_Node_Str""+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
      }
      try {
        clientStatusesLock.wait(timeToWait);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
        return null;
      }
    }
    clientStatus.hasRequestedCurrentTest=true;
    ++numClientsHaveRequestedTest;
    return currentTest;
  }
}","/** 
 * Called by the servlet to query for for the next method to test.
 * @param timeout how long to wait for an answer
 * @return the next test to run, or <code>null</code> if<code>timeout</code> is exceeded or the next test does not match <code>testClassName</code>
 */
public TestInfo getNextTestInfo(String clientId,long timeout) throws TimeoutException {
synchronized (clientStatusesLock) {
    ClientStatus clientStatus=clientStatuses.get(clientId);
    if (clientStatus == null) {
      clientStatus=new ClientStatus(clientId);
      clientStatuses.put(clientId,clientStatus);
    }
    long startTime=System.currentTimeMillis();
    long stopTime=startTime + timeout;
    while (clientStatus.currentTestResults != null) {
      long timeToWait=stopTime - System.currentTimeMillis();
      if (timeToWait < 1) {
        double elapsed=(System.currentTimeMillis() - startTime) / 1000.0;
        throw new TimeoutException(""String_Node_Str"" + ""String_Node_Str"" + timeout + ""String_Node_Str""+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
      }
      try {
        clientStatusesLock.wait(timeToWait);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
        return null;
      }
    }
    clientStatus.hasRequestedCurrentTest=true;
    ++numClientsHaveRequestedTest;
    return currentTest;
  }
}"
82727,"/** 
 * Fetches the results of a completed test.
 * @return A map of results from all clients.
 */
Map<String,JUnitResult> getResults(){
  Map<String,JUnitResult> result=new HashMap<String,JUnitResult>();
synchronized (clientStatusesLock) {
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      result.put(clientStatus.clientId,clientStatus.currentTestResults);
    }
  }
  return result;
}","/** 
 * Fetches the results of a completed test.
 * @return A map of results from all clients.
 */
Map<String,JUnitResult> getResults(){
synchronized (clientStatusesLock) {
    Map<String,JUnitResult> result=new HashMap<String,JUnitResult>();
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      result.put(clientStatus.clientId,clientStatus.currentTestResults);
    }
    return result;
  }
}"
82728,"/** 
 * Only instantiable within this package.
 * @param numClients The number of parallel clients being served by thisqueue.
 */
JUnitMessageQueue(int numClients){
  this.numClients=numClients;
}","/** 
 * Only instantiable within this package.
 * @param numClients The number of parallel clients being served by thisqueue.
 */
JUnitMessageQueue(int numClients){
synchronized (clientStatusesLock) {
    this.numClients=numClients;
  }
}"
82729,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
}"
82730,"@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",height + ""String_Node_Str"");
  int scrollWidth=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",scrollWidth + ""String_Node_Str"");
}","@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  height=Math.max(height,1);
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",height + ""String_Node_Str"");
  int scrollWidth=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",scrollWidth + ""String_Node_Str"");
}"
82731,"public CompilingClassLoader(TreeLogger logger,ByteCodeCompiler compiler,TypeOracle typeOracle) throws UnableToCompleteException {
  super(null);
  this.logger=logger;
  this.compiler=compiler;
  this.typeOracle=typeOracle;
  setDefaultAssertionStatus(true);
  for (int i=0; i < CacheManager.BOOTSTRAP_CLASSES.length; i++) {
    Class<?> clazz=CacheManager.BOOTSTRAP_CLASSES[i];
    String className=clazz.getName();
    try {
      String path=clazz.getName().replace('.','/').concat(""String_Node_Str"");
      ClassLoader cl=Thread.currentThread().getContextClassLoader();
      URL url=cl.getResource(path);
      if (url != null) {
        byte classBytes[]=getClassBytesFromStream(url.openStream());
        String loc=url.toExternalForm();
        compiler.putClassBytes(logger,className,classBytes,loc);
      }
 else {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + className + ""String_Node_Str"",null);
        throw new UnableToCompleteException();
      }
    }
 catch (    IOException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + className,e);
      throw new UnableToCompleteException();
    }
  }
  compiler.removeStaleByteCode(logger);
  JClassType jsoType=typeOracle.findType(JsValueGlue.JSO_CLASS);
  if (jsoType != null) {
    Set<JClassType> jsoTypes=new HashSet<JClassType>();
    JClassType[] jsoSubtypes=jsoType.getSubtypes();
    Collections.addAll(jsoTypes,jsoSubtypes);
    jsoTypes.add(jsoType);
    Set<String> jsoTypeNames=new HashSet<String>();
    for (    JClassType type : jsoTypes) {
      jsoTypeNames.add(getBinaryName(type));
    }
    MyInstanceMethodOracle mapper=new MyInstanceMethodOracle(jsoTypes,typeOracle.getJavaLangObject());
    classRewriter=new HostedModeClassRewriter(jsoTypeNames,mapper);
  }
 else {
    classRewriter=null;
  }
}","public CompilingClassLoader(TreeLogger logger,ByteCodeCompiler compiler,TypeOracle typeOracle,ShellJavaScriptHost javaScriptHost) throws UnableToCompleteException {
  super(null);
  this.logger=logger;
  this.compiler=compiler;
  this.typeOracle=typeOracle;
  this.shellJavaScriptHost=javaScriptHost;
  setDefaultAssertionStatus(true);
  for (  Class<?> clazz : CacheManager.BOOTSTRAP_CLASSES) {
    String className=clazz.getName();
    try {
      String path=clazz.getName().replace('.','/').concat(""String_Node_Str"");
      ClassLoader cl=Thread.currentThread().getContextClassLoader();
      URL url=cl.getResource(path);
      if (url != null) {
        byte classBytes[]=getClassBytesFromStream(url.openStream());
        String loc=url.toExternalForm();
        compiler.putClassBytes(logger,className,classBytes,loc);
      }
 else {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + className + ""String_Node_Str"",null);
        throw new UnableToCompleteException();
      }
    }
 catch (    IOException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + className,e);
      throw new UnableToCompleteException();
    }
  }
  compiler.removeStaleByteCode(logger);
  JClassType jsoType=typeOracle.findType(JsValueGlue.JSO_CLASS);
  if (jsoType != null) {
    Set<JClassType> jsoTypes=new HashSet<JClassType>();
    JClassType[] jsoSubtypes=jsoType.getSubtypes();
    Collections.addAll(jsoTypes,jsoSubtypes);
    jsoTypes.add(jsoType);
    Set<String> jsoTypeNames=new HashSet<String>();
    for (    JClassType type : jsoTypes) {
      jsoTypeNames.add(getBinaryName(type));
    }
    MyInstanceMethodOracle mapper=new MyInstanceMethodOracle(jsoTypes,typeOracle.getJavaLangObject());
    classRewriter=new HostedModeClassRewriter(jsoTypeNames,mapper);
  }
 else {
    classRewriter=null;
  }
}"
82732,"void clear(){
  weakJsoCache.clear();
  weakJavaWrapperCache.clear();
  dispClassInfoOracle.clear();
}","void clear(){
  shellJavaScriptHost=null;
  updateJavaScriptHost();
  weakJsoCache.clear();
  weakJavaWrapperCache.clear();
  dispClassInfoOracle.clear();
}"
82733,"@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (className.equals(ShellJavaScriptHost.class.getName())) {
    return ShellJavaScriptHost.class;
  }
  byte[] classBytes;
  try {
    String lookupClassName=className;
    if (classRewriter != null && classRewriter.isJsoImpl(className)) {
      lookupClassName=className.substring(0,className.length() - 1);
    }
    classBytes=compiler.getClassBytes(logger,lookupClassName);
    if (classRewriter != null) {
      classBytes=classRewriter.rewrite(className,classBytes);
    }
    return defineClass(className,classBytes,0,classBytes.length);
  }
 catch (  UnableToCompleteException e) {
    throw new ClassNotFoundException(className);
  }
}","@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes;
  try {
    String lookupClassName=className;
    if (classRewriter != null && classRewriter.isJsoImpl(className)) {
      lookupClassName=className.substring(0,className.length() - 1);
    }
    classBytes=compiler.getClassBytes(logger,lookupClassName);
    if (classRewriter != null) {
      classBytes=classRewriter.rewrite(className,classBytes);
    }
    Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
    if (className.equals(JavaScriptHost.class.getName())) {
      javaScriptHostClass=newClass;
      updateJavaScriptHost();
    }
    JsniMethods jsniMethods=newClass.getAnnotation(JsniMethods.class);
    if (jsniMethods != null) {
      for (      JsniMethod jsniMethod : jsniMethods.value()) {
        shellJavaScriptHost.createNative(jsniMethod.file(),jsniMethod.line(),jsniMethod.name(),jsniMethod.paramNames(),jsniMethod.body());
      }
    }
    return newClass;
  }
 catch (  UnableToCompleteException e) {
    throw new ClassNotFoundException(className);
  }
}"
82734,"/** 
 * This method is called via reflection from the shell, providing the hosted mode application with all of the methods it needs to interface with the browser and the server (for deferred binding).
 */
public static void setHost(ShellJavaScriptHost host){
  sHost=host;
}","/** 
 * This method is called via reflection from the   {@link CompilingClassLoader}, providing the hosted mode application with all of the methods it needs to interface with the browser and the server (for deferred binding).
 */
public static void setHost(ShellJavaScriptHost host){
  sHost=host;
}"
82735,"@Override public void uninitElement(){
  unhookEvents();
  String html=getHTML();
  beforeInitPlaceholder=DOM.createDiv();
  DOM.setInnerHTML(beforeInitPlaceholder,html);
}","@Override public void uninitElement(){
  if (initializing) {
    initializing=false;
    return;
  }
  unhookEvents();
  String html=getHTML();
  beforeInitPlaceholder=DOM.createDiv();
  DOM.setInnerHTML(beforeInitPlaceholder,html);
}"
82736,"@Override protected void onElementInitialized(){
  super.onElementInitialized();
  if (beforeInitPlaceholder != null) {
    setHTMLImpl(DOM.getInnerHTML(beforeInitPlaceholder));
    beforeInitPlaceholder=null;
  }
}","@Override protected void onElementInitialized(){
  if (!initializing) {
    return;
  }
  initializing=false;
  super.onElementInitialized();
  if (beforeInitPlaceholder != null) {
    setHTMLImpl(DOM.getInnerHTML(beforeInitPlaceholder));
    beforeInitPlaceholder=null;
  }
}"
82737,"/** 
 * Test that an immediate set of text is reflected immediately and after a delay. Some platforms have timing subtleties that need to be tested.
 */
public void testSetTextBeforeInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  richTextArea.setText(""String_Node_Str"");
  assertEquals(""String_Node_Str"",richTextArea.getText());
  new Timer(){
    public void run(){
      assertEquals(""String_Node_Str"",richTextArea.getText());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}","/** 
 * Test that an immediate set of text is reflected immediately and after a delay. Some platforms have timing subtleties that need to be tested.
 */
public void testSetTextBeforeInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  richTextArea.setText(""String_Node_Str"");
  assertEquals(""String_Node_Str"",richTextArea.getText());
  new Timer(){
    @Override public void run(){
      assertEquals(""String_Node_Str"",richTextArea.getText());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}"
82738,"/** 
 * Test that a delayed set of HTML is reflected. Some platforms have timing subtleties that need to be tested.
 */
public void testSetHTMLAfterInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  new Timer(){
    public void run(){
      richTextArea.setHTML(""String_Node_Str"");
      assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}","/** 
 * Test that a delayed set of HTML is reflected. Some platforms have timing subtleties that need to be tested.
 */
public void testSetHTMLAfterInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  new Timer(){
    @Override public void run(){
      richTextArea.setHTML(""String_Node_Str"");
      assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}"
82739,"/** 
 * Test that delayed set of text is reflected. Some platforms have timing subtleties that need to be tested.
 */
public void testSetTextAfterInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  new Timer(){
    public void run(){
      richTextArea.setText(""String_Node_Str"");
      assertEquals(""String_Node_Str"",richTextArea.getText());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}","/** 
 * Test that delayed set of text is reflected. Some platforms have timing subtleties that need to be tested.
 */
public void testSetTextAfterInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  new Timer(){
    @Override public void run(){
      richTextArea.setText(""String_Node_Str"");
      assertEquals(""String_Node_Str"",richTextArea.getText());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}"
82740,"public void run(){
  assertEquals(""String_Node_Str"",richTextArea.getText());
  finishTest();
}","@Override public void run(){
  assertEquals(""String_Node_Str"",richTextArea.getText());
  finishTest();
}"
82741,"/** 
 * Test that an immediate set of HTML is reflected immediately and after a delay. Some platforms have timing subtleties that need to be tested.
 */
public void testSetHTMLBeforeInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  richTextArea.setHTML(""String_Node_Str"");
  assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
  new Timer(){
    public void run(){
      assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}","/** 
 * Test that an immediate set of HTML is reflected immediately and after a delay. Some platforms have timing subtleties that need to be tested.
 */
public void testSetHTMLBeforeInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  richTextArea.setHTML(""String_Node_Str"");
  assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
  new Timer(){
    @Override public void run(){
      assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}"
82742,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}"
82743,"/** 
 * Test that removing and re-adding an RTA doesn't destroy its contents (Only IE actually preserves dynamically-created iframe contents across DOM removal/re-adding).
 */
public void testAddEditRemoveAdd(){
  final RichTextArea area=new RichTextArea();
  RootPanel.get().add(area);
  area.setHTML(""String_Node_Str"");
  this.delayTestFinish(1000);
  new Timer(){
    public void run(){
      RootPanel.get().remove(area);
      RootPanel.get().add(area);
      assertEquals(""String_Node_Str"",area.getHTML());
      finishTest();
    }
  }
.schedule(500);
}","/** 
 * Test that removing and re-adding an RTA doesn't destroy its contents (Only IE actually preserves dynamically-created iframe contents across DOM removal/re-adding).
 */
public void testAddEditRemoveAdd(){
  final RichTextArea area=new RichTextArea();
  RootPanel.get().add(area);
  area.setHTML(""String_Node_Str"");
  this.delayTestFinish(1000);
  new Timer(){
    @Override public void run(){
      RootPanel.get().remove(area);
      RootPanel.get().add(area);
      assertEquals(""String_Node_Str"",area.getHTML());
      finishTest();
    }
  }
.schedule(500);
}"
82744,"/** 
 * @see HasAnimation#isAnimationEnabled()
 */
public boolean isAnimationEnabled(){
  return isAnimationEnabled;
}","public boolean isAnimationEnabled(){
  return isAnimationEnabled;
}"
82745,"/** 
 * @see HasAnimation#setAnimationEnabled(boolean)
 */
public void setAnimationEnabled(boolean enable){
  isAnimationEnabled=enable;
}","public void setAnimationEnabled(boolean enable){
  isAnimationEnabled=enable;
}"
82746,"@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curPanel.contentWrapper.getElement(),""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  DOM.setStyleAttribute(curPanel.contentWrapper.getElement(),""String_Node_Str"",height + ""String_Node_Str"");
  DOM.setStyleAttribute(curPanel.contentWrapper.getElement(),""String_Node_Str"",""String_Node_Str"");
}","@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curPanel.contentWrapper.getElement(),""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  height=Math.max(height,1);
  DOM.setStyleAttribute(curPanel.contentWrapper.getElement(),""String_Node_Str"",height + ""String_Node_Str"");
  DOM.setStyleAttribute(curPanel.contentWrapper.getElement(),""String_Node_Str"",""String_Node_Str"");
}"
82747,"public boolean addAll(int index,Collection<? extends E> c){
  Iterator<? extends E> iter=c.iterator();
  while (iter.hasNext()) {
    add(index,iter.next());
    ++index;
  }
  return !c.isEmpty();
}","public boolean addAll(int index,Collection<? extends E> c){
  Iterator<? extends E> iter=c.iterator();
  while (iter.hasNext()) {
    add(index++,iter.next());
  }
  return !c.isEmpty();
}"
82748,"@Override public boolean addAll(Collection<? extends E> c){
  Iterator<? extends E> iter=c.iterator();
  boolean changed=iter.hasNext();
  while (iter.hasNext()) {
    setImpl(array,size++,iter.next());
  }
  return changed;
}","public boolean addAll(int index,Collection<? extends E> c){
  if (c.isEmpty()) {
    return false;
  }
  if (index < 0 || index > size) {
    indexOutOfBounds(index,size);
  }
  insertImpl(array,index,c.toArray());
  size+=c.size();
  return true;
}"
82749,"public boolean removeAll(Collection<?> c){
  Iterator<?> iter=c.iterator();
  boolean changed=false;
  while (iter.hasNext()) {
    if (remove(iter.next())) {
      changed=true;
    }
  }
  return changed;
}","public boolean removeAll(Collection<?> c){
  Iterator<?> iter=iterator();
  boolean changed=false;
  while (iter.hasNext()) {
    if (c.contains(iter.next())) {
      iter.remove();
      changed=true;
    }
  }
  return changed;
}"
82750,"public static Boolean valueOf(String s){
  if (s != null && s.equalsIgnoreCase(""String_Node_Str"")) {
    return TRUE;
  }
 else {
    return FALSE;
  }
}","public static Boolean valueOf(String s){
  return valueOf(parseBoolean(s));
}"
82751,"@Override public int hashCode(){
  final int hashCodeForTrue=1231;
  final int hashCodeForFalse=1237;
  return value ? hashCodeForTrue : hashCodeForFalse;
}","@Override public int hashCode(){
  return value ? 1231 : 1237;
}"
82752,"public int compareTo(Boolean other){
  if (!value) {
    return other.value ? -1 : 0;
  }
 else {
    return other.value ? 0 : 1;
  }
}","public int compareTo(Boolean other){
  return (this.value == other.value) ? 0 : (this.value ? 1 : -1);
}"
82753,"public Boolean(String s){
  this((s != null) && s.equalsIgnoreCase(""String_Node_Str""));
}","public Boolean(String s){
  this(parseBoolean(s));
}"
82754,"@Override public <T>T[] toArray(T[] a){
  if (a.length < size) {
    a=Array.clonify(a,size);
  }
  for (int i=0; i < size; ++i) {
    a[i]=ArrayList.<T>getImpl(array,i);
  }
  if (a.length > size) {
    a[size]=null;
  }
  return a;
}","@Override public <T>T[] toArray(T[] out){
  if (out.length < size) {
    out=Array.clonify(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=ArrayList.<T>getImpl(array,i);
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}"
82755,"public static <T>List<T> asList(T... array){
  List<T> accum=new ArrayList<T>();
  for (int i=0; i < array.length; i++) {
    accum.add(array[i]);
  }
  return accum;
}","public static <T>List<T> asList(T... array){
  return new ArrayList<T>(array);
}"
82756,"/** 
 * Tests   {@link Arrays#asList(Object[])}.
 */
public void testAsList(){
  Object[] test={};
  List result=Arrays.asList(test);
  assertEquals(test,result);
  Object[] test2={new Integer(0),new Integer(1),new Integer(2)};
  List result2=Arrays.asList(test2);
  assertEquals(test2,result2);
  Object[] test3={""String_Node_Str""};
  List result3=Arrays.asList(test3);
  assertEquals(test3,result3);
}","/** 
 * Tests   {@link Arrays#asList(Object[])}.
 */
@SuppressWarnings(""String_Node_Str"") public void testAsList(){
  Object[] test={};
  List result=Arrays.asList(test);
  assertEquals(test,result);
  Object[] test2={0,1,2};
  List result2=Arrays.asList(test2);
  assertEquals(test2,result2);
  Object[] test3={""String_Node_Str""};
  List result3=Arrays.asList(test3);
  assertEquals(test3,result3);
}"
82757,"/** 
 * Test Arrays.binarySearch(Object[], Object, Comparator). <pre> Verify the following cases: empty array odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements Comparator uses natural ordering as a default </pre>
 */
public void testBinarySearchObjectComparator(){
  Comparator inverseSort=new Comparator(){
    public int compare(    Object o1,    Object o2){
      return ((Comparable)o2).compareTo(o1);
    }
  }
;
  Object[] a1={};
  int ret=Arrays.binarySearch(a1,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  Object[] a2={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(-3,ret);
  ret=Arrays.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(2,ret);
  Object[] a3={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-5,ret);
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(0,ret);
  Object[] a4={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a4,""String_Node_Str"",null);
  assertEquals(3,ret);
}","/** 
 * Test Arrays.binarySearch(Object[], Object, Comparator). <pre> Verify the following cases: empty array odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements Comparator uses natural ordering as a default </pre>
 */
@SuppressWarnings(""String_Node_Str"") public void testBinarySearchObjectComparator(){
  Comparator inverseSort=new Comparator(){
    public int compare(    Object o1,    Object o2){
      return ((Comparable)o2).compareTo(o1);
    }
  }
;
  Object[] a1={};
  int ret=Arrays.binarySearch(a1,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  Object[] a2={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(-3,ret);
  ret=Arrays.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(2,ret);
  Object[] a3={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-5,ret);
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(0,ret);
  Object[] a4={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a4,""String_Node_Str"",null);
  assertEquals(3,ret);
}"
82758,"/** 
 * Tests sorting a subrange of a primitive array.
 */
public void testPrimitiveSubrangeSort(){
  int[] x=new int[]{3,11,2,1,22,3};
  Arrays.sort(x,1,5);
  assertEquals(3,x[0]);
  assertEquals(1,x[1]);
  assertEquals(2,x[2]);
  assertEquals(11,x[3]);
  assertEquals(22,x[4]);
  assertEquals(3,x[5]);
}","/** 
 * Tests sorting a subrange of a primitive array.
 */
public void testPrimitiveSubrangeSort(){
  int[] x={3,11,2,1,22,3};
  Arrays.sort(x,1,5);
  assertEquals(3,x[0]);
  assertEquals(1,x[1]);
  assertEquals(2,x[2]);
  assertEquals(11,x[3]);
  assertEquals(22,x[4]);
  assertEquals(3,x[5]);
}"
82759,"/** 
 * Verifies that values are sorted numerically rather than as strings.
 */
public void testNumericSort(){
  Integer[] x=new Integer[]{new Integer(3),new Integer(11),new Integer(2),new Integer(1)};
  Arrays.sort(x);
  assertEquals(2,x[1].intValue());
  assertEquals(11,x[3].intValue());
}","/** 
 * Verifies that values are sorted numerically rather than as strings.
 */
public void testNumericSort(){
  Integer[] x={3,11,2,1};
  Arrays.sort(x);
  assertEquals(2,x[1].intValue());
  assertEquals(11,x[3].intValue());
}"
82760,"/** 
 * Tests sorting primitives.
 */
public void testPrimitiveSort(){
  int[] x=new int[]{3,11,2,1,22,3};
  Arrays.sort(x);
  assertEquals(1,x[0]);
  assertEquals(2,x[1]);
  assertEquals(3,x[2]);
  assertEquals(3,x[3]);
  assertEquals(11,x[4]);
  assertEquals(22,x[5]);
}","/** 
 * Tests sorting primitives.
 */
public void testPrimitiveSort(){
  int[] x={3,11,2,1,22,3};
  Arrays.sort(x);
  assertEquals(1,x[0]);
  assertEquals(2,x[1]);
  assertEquals(3,x[2]);
  assertEquals(3,x[3]);
  assertEquals(11,x[4]);
  assertEquals(22,x[5]);
}"
82761,"/** 
 * Tests   {@link Arrays#sort(Object[],Comparator)}.
 */
public void testSort(){
  Object[] x={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int hash=x[1].hashCode();
  Arrays.sort(x);
  int hash2=x[1].hashCode();
  assertEquals(hash,hash2);
  Object[] sorted={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,sorted);
  Comparator<Object> t=new Comparator<Object>(){
    public int compare(    Object o1,    Object o2){
      return ((Comparable<Object>)o2).compareTo(o1);
    }
  }
;
  Arrays.sort(x,t);
  int hash3=x[1].hashCode();
  assertEquals(hash,hash3);
  Object[] reverseSorted={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,reverseSorted);
}","/** 
 * Tests   {@link Arrays#sort(Object[],Comparator)}.
 */
public void testSort(){
  Object[] x={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int hash=x[1].hashCode();
  Arrays.sort(x);
  int hash2=x[1].hashCode();
  assertEquals(hash,hash2);
  Object[] sorted={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,sorted);
  Comparator<Object> t=new Comparator<Object>(){
    @SuppressWarnings(""String_Node_Str"") public int compare(    Object o1,    Object o2){
      return ((Comparable<Object>)o2).compareTo(o1);
    }
  }
;
  Arrays.sort(x,t);
  int hash3=x[1].hashCode();
  assertEquals(hash,hash3);
  Object[] reverseSorted={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,reverseSorted);
}"
82762,"/** 
 * Tests simple use cases for   {@link Arrays#sort(Object[])}.
 */
public void testSimpleSort(){
  Object[] test={};
  Arrays.sort(test);
  assertEquals(test.length,0);
  Integer[] test2={new Integer(1)};
  Arrays.sort(test2);
  assertEquals(1,test2[0].intValue());
  Number[] test3={new Integer(3),new Integer(0),new Integer(2),new Integer(4),new Integer(1)};
  Arrays.sort(test3);
  for (int i=0; i < test3.length; i++) {
    assertEquals(i,test3[i].intValue());
  }
}","/** 
 * Tests simple use cases for   {@link Arrays#sort(Object[])}.
 */
public void testSimpleSort(){
  Object[] test={};
  Arrays.sort(test);
  assertEquals(test.length,0);
  Integer[] test2={1};
  Arrays.sort(test2);
  assertEquals(1,test2[0].intValue());
  Number[] test3={3,0,2,4,1};
  Arrays.sort(test3);
  for (int i=0; i < test3.length; i++) {
    assertEquals(i,test3[i].intValue());
  }
}"
82763,"protected final void rememberDecodedObject(Object o){
  seenArray.add(o);
}","protected final void rememberDecodedObject(int index,Object o){
  seenArray.set(index - 1,o);
}"
82764,"@Override protected Object deserialize(String typeSignature) throws SerializationException {
  Object instance=serializer.instantiate(this,typeSignature);
  rememberDecodedObject(instance);
  serializer.deserialize(this,instance,typeSignature);
  return instance;
}","@Override protected Object deserialize(String typeSignature) throws SerializationException {
  int id=reserveDecodedObjectIndex();
  Object instance=serializer.instantiate(this,typeSignature);
  rememberDecodedObject(id,instance);
  serializer.deserialize(this,instance,typeSignature);
  return instance;
}"
82765,"@Override protected Object deserialize(String typeSignature) throws SerializationException {
  Object instance=null;
  SerializedInstanceReference serializedInstRef=SerializabilityUtil.decodeSerializedInstanceReference(typeSignature);
  try {
    Class<?> instanceClass=Class.forName(serializedInstRef.getName(),false,classLoader);
    assert(serializationPolicy != null);
    serializationPolicy.validateDeserialize(instanceClass);
    validateTypeVersions(instanceClass,serializedInstRef);
    Class<?> customSerializer=SerializabilityUtil.hasCustomFieldSerializer(instanceClass);
    instance=instantiate(customSerializer,instanceClass);
    rememberDecodedObject(instance);
    Object replacement=deserializeImpl(customSerializer,instanceClass,instance);
    if (instance != replacement) {
      replaceRememberedObject(instance,replacement);
      instance=replacement;
    }
    return instance;
  }
 catch (  ClassNotFoundException e) {
    throw new SerializationException(e);
  }
catch (  InstantiationException e) {
    throw new SerializationException(e);
  }
catch (  IllegalAccessException e) {
    throw new SerializationException(e);
  }
catch (  IllegalArgumentException e) {
    throw new SerializationException(e);
  }
catch (  InvocationTargetException e) {
    throw new SerializationException(e);
  }
catch (  NoSuchMethodException e) {
    throw new SerializationException(e);
  }
}","@Override protected Object deserialize(String typeSignature) throws SerializationException {
  Object instance=null;
  SerializedInstanceReference serializedInstRef=SerializabilityUtil.decodeSerializedInstanceReference(typeSignature);
  try {
    Class<?> instanceClass=Class.forName(serializedInstRef.getName(),false,classLoader);
    assert(serializationPolicy != null);
    serializationPolicy.validateDeserialize(instanceClass);
    validateTypeVersions(instanceClass,serializedInstRef);
    Class<?> customSerializer=SerializabilityUtil.hasCustomFieldSerializer(instanceClass);
    int index=reserveDecodedObjectIndex();
    instance=instantiate(customSerializer,instanceClass);
    rememberDecodedObject(index,instance);
    Object replacement=deserializeImpl(customSerializer,instanceClass,instance);
    if (instance != replacement) {
      rememberDecodedObject(index,replacement);
      instance=replacement;
    }
    return instance;
  }
 catch (  ClassNotFoundException e) {
    throw new SerializationException(e);
  }
catch (  InstantiationException e) {
    throw new SerializationException(e);
  }
catch (  IllegalAccessException e) {
    throw new SerializationException(e);
  }
catch (  IllegalArgumentException e) {
    throw new SerializationException(e);
  }
catch (  InvocationTargetException e) {
    throw new SerializationException(e);
  }
catch (  NoSuchMethodException e) {
    throw new SerializationException(e);
  }
}"
82766,"public void onFailure(Throwable caught){
  fail(""String_Node_Str"");
}","public void onFailure(Throwable caught){
  fail(""String_Node_Str"" + caught);
}"
82767,"public void onSuccess(Object result){
  assertNotNull(result);
  assertTrue(CustomFieldSerializerTestSetValidator.isValid((SerializableSubclass)result));
  finishTest();
}","public void onSuccess(Object result){
  assertNotNull(result);
  assertTrue(CustomFieldSerializerTestSetValidator.isValid((ManuallySerializedImmutableClass[])result));
  finishTest();
}"
82768,"private void generateClassLiterals(JsVars vars){
  for (  JType type : classLits.keySet()) {
    JsName jsName=classLits.get(type);
    JsExpression classObjectAlloc=classObjects.get(jsName);
    JsVar var=new JsVar(jsName);
    var.setInitExpr(classObjectAlloc);
    vars.add(var);
  }
}","private void generateClassLiterals(JsVars vars){
  JClassType objType=program.getTypeJavaLangObject();
  if (classLits.containsKey(objType)) {
    generateClassLiteral(objType,vars);
  }
  for (  JType type : classLits.keySet()) {
    if (type != objType) {
      generateClassLiteral(type,vars);
    }
  }
}"
82769,"/** 
 * Adds the specified widget to the deck.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element container=DOM.createDiv();
  DOM.appendChild(getElement(),container);
  initChildWidget(w);
  initWidgetContainer(container);
  super.add(w,container);
}","/** 
 * Adds the specified widget to the deck.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element container=createWidgetContainer();
  DOM.appendChild(getElement(),container);
  super.add(w,container);
  finishWidgetInitialization(container,w);
}"
82770,"/** 
 * Inserts a widget before the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  Element container=DOM.createDiv();
  DOM.insertChild(getElement(),container,beforeIndex);
  initChildWidget(w);
  initWidgetContainer(container);
  super.insert(w,container,beforeIndex,true);
}","/** 
 * Inserts a widget before the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  Element container=createWidgetContainer();
  DOM.insertChild(getElement(),container,beforeIndex);
  super.insert(w,container,beforeIndex,true);
  finishWidgetInitialization(container,w);
}"
82771,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  return suite;
}"
82772,"private boolean computeHasClinitRecursive(JReferenceType type,Set<JReferenceType> computed,Set<JReferenceType> alreadySeen){
  alreadySeen.add(type);
  if (computed.contains(type)) {
    return hasClinitSet.contains(type);
  }
  JMethod method=type.methods.get(0);
  assert(JProgram.isClinit(method));
  CheckClinitVisitor v=new CheckClinitVisitor();
  v.accept(method);
  if (v.hasNonClinitCalls()) {
    return true;
  }
  for (  JReferenceType target : v.getClinitTargets()) {
    if (alreadySeen.contains(target)) {
      continue;
    }
    if (computeHasClinitRecursive(target,computed,alreadySeen)) {
      return true;
    }
 else {
      continue;
    }
  }
  return false;
}","private boolean computeHasClinitRecursive(JReferenceType type,Set<JReferenceType> computed,Set<JReferenceType> alreadySeen){
  alreadySeen.add(type);
  if (computed.contains(type)) {
    return hasClinitSet.contains(type);
  }
  JMethod method=type.methods.get(0);
  assert(JProgram.isClinit(method));
  CheckClinitVisitor v=new CheckClinitVisitor();
  v.accept(method);
  if (v.hasLiveCode()) {
    return true;
  }
  for (  JReferenceType target : v.getClinitTargets()) {
    if (alreadySeen.contains(target)) {
      continue;
    }
    if (computeHasClinitRecursive(target,computed,alreadySeen)) {
      return true;
    }
 else {
      continue;
    }
  }
  return false;
}"
82773,"@Override public boolean visit(JMultiExpression x,Context ctx){
  for (  JExpression expr : x.exprs) {
    if (canContainClinitCalls(expr)) {
      accept(expr);
    }
 else {
      hasNonClinitCalls=true;
    }
  }
  return false;
}","@Override public boolean visit(JMultiExpression x,Context ctx){
  for (  JExpression expr : x.exprs) {
    if (mightBeDeadCode(expr)) {
      accept(expr);
    }
 else {
      hasLiveCode=true;
    }
  }
  return false;
}"
82774,"public <T>T[] toArray(T[] a){
  int size=size();
  if (a.length < size) {
    a=Array.clonify(a,size);
  }
  Object[] result=a;
  Iterator<E> it=iterator();
  for (int i=0; i < size; ++i) {
    result[i]=it.next();
  }
  if (a.length > size) {
    a[size]=null;
  }
  return a;
}","public <T>T[] toArray(T[] a){
  int size=size();
  if (a.length < size) {
    a=Array.createFrom(a,size);
  }
  Object[] result=a;
  Iterator<E> it=iterator();
  for (int i=0; i < size; ++i) {
    result[i]=it.next();
  }
  if (a.length > size) {
    a[size]=null;
  }
  return a;
}"
82775,"@Override public <T>T[] toArray(T[] out){
  if (out.length < size) {
    out=Array.clonify(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=ArrayList.<T>getImpl(array,i);
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}","@Override public <T>T[] toArray(T[] out){
  if (out.length < size) {
    out=Array.createFrom(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=ArrayList.<T>getImpl(array,i);
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}"
82776,"@SuppressWarnings(""String_Node_Str"") @Override public <T>T[] toArray(T[] out){
  int size=size();
  if (out.length < size) {
    out=Array.clonify(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=(T)array[i];
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}","@SuppressWarnings(""String_Node_Str"") @Override public <T>T[] toArray(T[] out){
  int size=size();
  if (out.length < size) {
    out=Array.createFrom(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=(T)array[i];
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}"
82777,"public Entry<K,V> next(){
  key=it.next();
  return new MapEntryImpl<K,V>(key,values.get(key.ordinal()));
}","public Entry<K,V> next(){
  key=it.next();
  return new MapEntry(key);
}"
82778,"/** 
 * Returns <code>key</code> as <code>K</code>. Doesn't actually perform any runtime checks. Should only be called when you are sure <code>key</code> is of type <code>K</code>.
 */
@SuppressWarnings(""String_Node_Str"") private K asKey(Object key){
  return (K)key;
}","/** 
 * Returns <code>key</code> as <code>K</code>. Only runtime checks that key is an Enum, not that it's the particular Enum K. Should only be called when you are sure <code>key</code> is of type <code>K</code>.
 */
@SuppressWarnings(""String_Node_Str"") private K asKey(Object key){
  return (K)key;
}"
82779,"private void init(EnumMap<K,? extends V> m){
  allEnums=m.allEnums;
  keySet=m.keySet.clone();
  values=new ArrayList<V>(m.values);
}","private void init(EnumMap<K,? extends V> m){
  keySet=m.keySet.clone();
  values=Array.clone(m.values);
}"
82780,"@Override public void clear(){
  keySet.clear();
  Collections.fill(values,null);
}","@SuppressWarnings(""String_Node_Str"") @Override public void clear(){
  keySet.clear();
  values=(V[])new Object[values.length];
}"
82781,"@Override public V remove(Object key){
  return keySet.remove(key) ? values.set(asKey(key).ordinal(),null) : null;
}","@Override public V remove(Object key){
  return keySet.remove(key) ? set(asOrdinal(key),null) : null;
}"
82782,"@Override public boolean containsValue(Object value){
  if (value != null) {
    return values.contains(value);
  }
  for (int i=0, n=values.size(); i < n; ++i) {
    V v=values.get(i);
    if (v == null && keySet.contains(allEnums[i])) {
      return true;
    }
  }
  return false;
}","@Override public boolean containsValue(Object value){
  for (  K key : keySet) {
    if (Utility.equalsWithNullCheck(value,values[key.ordinal()])) {
      return true;
    }
  }
  return false;
}"
82783,"@Override public V put(K key,V value){
  keySet.add(key);
  return values.set(key.ordinal(),value);
}","@Override public V put(K key,V value){
  keySet.add(key);
  return set(key.ordinal(),value);
}"
82784,"public Iterator<Map.Entry<K,V>> iterator(){
  return new Iterator<Entry<K,V>>(){
    Iterator<K> it=keySet.iterator();
    K key;
    public boolean hasNext(){
      return it.hasNext();
    }
    public Entry<K,V> next(){
      key=it.next();
      return new MapEntryImpl<K,V>(key,values.get(key.ordinal()));
    }
    public void remove(){
      if (key == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      EnumMap.this.remove(key);
      key=null;
    }
  }
;
}","@Override public Iterator<Entry<K,V>> iterator(){
  return new EntrySetIterator();
}"
82785,"@Override public V get(Object k){
  return keySet.contains(k) ? values.get(asKey(k).ordinal()) : null;
}","@Override public V get(Object k){
  return keySet.contains(k) ? values[asOrdinal(k)] : null;
}"
82786,"private static native void addAllStringEntries(JavaScriptObject stringMap,Collection<?> dest);",private native void addAllStringEntries(Collection<?> dest);
82787,"private static native void addAllHashEntries(JavaScriptObject hashCodeMap,Collection<?> dest);",private native void addAllHashEntries(Collection<?> dest);
82788,"/** 
 * Constructor for <code>EntrySetIterator</code>.
 */
public EntrySetIterator(){
  List<Map.Entry<K,V>> list=new ArrayList<Map.Entry<K,V>>();
  if (nullSlotLive) {
    MapEntryImpl<K,V> entryImpl=new MapEntryImpl<K,V>(null,nullSlot);
    list.add(entryImpl);
  }
  addAllStringEntries(stringMap,list);
  addAllHashEntries(hashCodeMap,list);
  this.iter=list.iterator();
}","/** 
 * Constructor for <code>EntrySetIterator</code>.
 */
public EntrySetIterator(){
  List<Map.Entry<K,V>> list=new ArrayList<Map.Entry<K,V>>();
  if (nullSlotLive) {
    list.add(new MapEntryNull());
  }
  addAllStringEntries(list);
  addAllHashEntries(list);
  this.iter=list.iterator();
}"
82789,"/** 
 * Ensure a number is displayed with two digits.
 * @return A two-character representation of the number.
 */
@SuppressWarnings(""String_Node_Str"") private static String padTwo(int number){
  if (number < 10) {
    return ""String_Node_Str"" + number;
  }
 else {
    return String.valueOf(number);
  }
}","/** 
 * Ensure a number is displayed with two digits.
 * @return a two-character base 10 representation of the number
 */
protected static String padTwo(int number){
  if (number < 10) {
    return ""String_Node_Str"" + number;
  }
 else {
    return String.valueOf(number);
  }
}"
82790,"/** 
 * Evaluates a trusted JSON string and returns its JSONValue representation. CAUTION! For efficiency, this method is implemented using the JavaScript <code>eval()</code> function, which can execute arbitrary script. DO NOT pass an untrusted string into this method.
 * @param jsonString a JSON object to parse
 * @return a JSONValue that has been built by parsing the JSON string
 * @throws NullPointerException if <code>jsonString</code> is<code>null</code>
 * @throws IllegalArgumentException if <code>jsonString</code> is empty
 */
public static JSONValue parse(String jsonString){
  if (jsonString == null) {
    throw new NullPointerException();
  }
  if (jsonString == ""String_Node_Str"") {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return evaluate(jsonString);
  }
 catch (  JavaScriptException ex) {
    throw new JSONException(ex);
  }
}","/** 
 * Evaluates a trusted JSON string and returns its JSONValue representation. CAUTION! For efficiency, this method is implemented using the JavaScript <code>eval()</code> function, which can execute arbitrary script. DO NOT pass an untrusted string into this method.
 * @param jsonString a JSON object to parse
 * @return a JSONValue that has been built by parsing the JSON string
 * @throws NullPointerException if <code>jsonString</code> is<code>null</code>
 * @throws IllegalArgumentException if <code>jsonString</code> is empty
 */
public static JSONValue parse(String jsonString){
  if (jsonString == null) {
    throw new NullPointerException();
  }
  if (jsonString.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return evaluate(jsonString);
  }
 catch (  JavaScriptException ex) {
    throw new JSONException(ex);
  }
}"
82791,"@Override public void onBrowserEvent(Event event){
  int eventType=DOM.eventGetType(event);
switch (eventType) {
case Event.ONCLICK:
{
      Element e=DOM.eventGetTarget(event);
      if (shouldTreeDelegateFocusToElement(e)) {
      }
 else {
        setFocus(true);
      }
      break;
    }
case Event.ONMOUSEDOWN:
{
    if (mouseListeners != null) {
      mouseListeners.fireMouseEvent(this,event);
    }
    if (DOM.eventGetCurrentTarget(event) == getElement()) {
      elementClicked(DOM.eventGetTarget(event));
    }
    break;
  }
case Event.ONMOUSEUP:
{
  if (mouseListeners != null) {
    mouseListeners.fireMouseEvent(this,event);
  }
  break;
}
case Event.ONMOUSEMOVE:
{
if (mouseListeners != null) {
  mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEOVER:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEOUT:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONFOCUS:
if (focusListeners != null) {
focusListeners.fireFocusEvent(this,event);
}
break;
case Event.ONBLUR:
{
if (focusListeners != null) {
focusListeners.fireFocusEvent(this,event);
}
break;
}
case Event.ONKEYDOWN:
if (DOM.eventGetAltKey(event) || DOM.eventGetMetaKey(event)) {
super.onBrowserEvent(event);
return;
}
if (curSelection == null) {
if (root.getChildCount() > 0) {
onSelection(root.getChild(0),true,true);
}
super.onBrowserEvent(event);
return;
}
if (lastEventType == Event.ONKEYDOWN) {
return;
}
if (isKeyboardNavigationEnabled(curSelection)) {
switch (DOM.eventGetKeyCode(event)) {
case KeyboardListener.KEY_UP:
{
moveSelectionUp(curSelection);
DOM.eventPreventDefault(event);
break;
}
case KeyboardListener.KEY_DOWN:
{
moveSelectionDown(curSelection,true);
DOM.eventPreventDefault(event);
break;
}
case KeyboardListener.KEY_LEFT:
{
if (LocaleInfo.getCurrentLocale().isRTL()) {
maybeExpandTreeItem();
}
 else {
maybeCollapseTreeItem();
}
DOM.eventPreventDefault(event);
break;
}
case KeyboardListener.KEY_RIGHT:
{
if (LocaleInfo.getCurrentLocale().isRTL()) {
maybeCollapseTreeItem();
}
 else {
maybeExpandTreeItem();
}
DOM.eventPreventDefault(event);
break;
}
}
}
case Event.ONKEYUP:
if (eventType == Event.ONKEYUP) {
if (DOM.eventGetKeyCode(event) == KeyboardListener.KEY_TAB) {
ArrayList<Element> chain=new ArrayList<Element>();
collectElementChain(chain,getElement(),DOM.eventGetTarget(event));
TreeItem item=findItemByChain(chain,0,root);
if (item != getSelectedItem()) {
setSelectedItem(item,true);
}
}
}
case Event.ONKEYPRESS:
{
if (keyboardListeners != null) {
keyboardListeners.fireKeyboardEvent(this,event);
}
break;
}
}
super.onBrowserEvent(event);
lastEventType=eventType;
}","@Override @SuppressWarnings(""String_Node_Str"") public void onBrowserEvent(Event event){
  int eventType=DOM.eventGetType(event);
switch (eventType) {
case Event.ONKEYDOWN:
{
      if (curSelection == null) {
        if (root.getChildCount() > 0) {
          onSelection(root.getChild(0),true,true);
        }
        super.onBrowserEvent(event);
        return;
      }
    }
case Event.ONKEYPRESS:
case Event.ONKEYUP:
  if (DOM.eventGetAltKey(event) || DOM.eventGetMetaKey(event)) {
    super.onBrowserEvent(event);
    return;
  }
break;
}
switch (eventType) {
case Event.ONCLICK:
{
Element e=DOM.eventGetTarget(event);
if (shouldTreeDelegateFocusToElement(e)) {
}
 else {
  setFocus(true);
}
break;
}
case Event.ONMOUSEDOWN:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
if (DOM.eventGetCurrentTarget(event) == getElement()) {
elementClicked(DOM.eventGetTarget(event));
}
break;
}
case Event.ONMOUSEUP:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEMOVE:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEOVER:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEOUT:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONFOCUS:
if (focusListeners != null) {
focusListeners.fireFocusEvent(this,event);
}
break;
case Event.ONBLUR:
{
if (focusListeners != null) {
focusListeners.fireFocusEvent(this,event);
}
break;
}
case Event.ONKEYDOWN:
{
keyboardNavigation(event);
lastWasKeyDown=true;
break;
}
case Event.ONKEYPRESS:
{
if (!lastWasKeyDown) {
keyboardNavigation(event);
}
lastWasKeyDown=false;
break;
}
case Event.ONKEYUP:
{
if (DOM.eventGetKeyCode(event) == KeyboardListener.KEY_TAB) {
ArrayList<Element> chain=new ArrayList<Element>();
collectElementChain(chain,getElement(),DOM.eventGetTarget(event));
TreeItem item=findItemByChain(chain,0,root);
if (item != getSelectedItem()) {
setSelectedItem(item,true);
}
}
lastWasKeyDown=false;
break;
}
}
switch (eventType) {
case Event.ONKEYDOWN:
case Event.ONKEYUP:
case Event.ONKEYPRESS:
{
if (keyboardListeners != null) {
keyboardListeners.fireKeyboardEvent(this,event);
}
if (isArrowKey(DOM.eventGetKeyCode(event))) {
DOM.eventCancelBubble(event,true);
DOM.eventPreventDefault(event);
}
break;
}
}
super.onBrowserEvent(event);
}"
82792,"/** 
 * Open the specified   {@link TreeItem}.
 * @param item the {@link TreeItem} to open
 * @param animate true to animate, false to open instantly
 */
public void setItemState(TreeItem item,boolean animate){
  cancel();
  curItem=item;
  opening=item.open;
  if (animate) {
    run(350);
  }
 else {
    onInstantaneousRun();
  }
}","/** 
 * Open the specified   {@link TreeItem}.
 * @param item the {@link TreeItem} to open
 * @param animate true to animate, false to open instantly
 */
public void setItemState(TreeItem item,boolean animate){
  cancel();
  curItem=item;
  opening=item.open;
  if (animate) {
    run(Math.min(200,75 * curItem.getChildCount()));
  }
 else {
    onInstantaneousRun();
  }
}"
82793,"@Override public void onStart(){
  onUpdate(0.0);
  if (opening) {
    UIObject.setVisible(curItem.childSpanElem,true);
  }
}","@Override public void onStart(){
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",""String_Node_Str"");
  onUpdate(0.0);
  if (opening) {
    UIObject.setVisible(curItem.childSpanElem,true);
  }
}"
82794,"@Override public void onComplete(){
  if (curItem != null) {
    if (opening) {
      UIObject.setVisible(curItem.childSpanElem,true);
      onUpdate(1.0);
      DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",""String_Node_Str"");
    }
 else {
      UIObject.setVisible(curItem.childSpanElem,false);
    }
    curItem=null;
  }
}","@Override public void onComplete(){
  if (curItem != null) {
    if (opening) {
      UIObject.setVisible(curItem.childSpanElem,true);
      onUpdate(1.0);
      DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",""String_Node_Str"");
    }
 else {
      UIObject.setVisible(curItem.childSpanElem,false);
    }
    DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",""String_Node_Str"");
    DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",""String_Node_Str"");
    curItem=null;
  }
}"
82795,"@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",height + ""String_Node_Str"");
}","@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",height + ""String_Node_Str"");
  int scrollWidth=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",scrollWidth + ""String_Node_Str"");
}"
82796,"@Override protected void onTypeRef(SourceTypeBinding referencedType,CompilationUnitDeclaration unitOfReferrer){
  String referencedFn=String.valueOf(referencedType.getFileName());
  CompilationUnitDeclaration referencedCud=cudsByFileName.get(referencedFn);
  if (referencedCud == null) {
    String referrerFn=String.valueOf(unitOfReferrer.getFileName());
    if (cudsByFileName.containsKey(referrerFn) && !pendingRemovals.contains(referrerFn)) {
      TreeLogger branch=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + referrerFn + ""String_Node_Str"",null);
      final String badTypeName=CharOperation.toString(referencedType.compoundName);
      branch.branch(TreeLogger.TRACE,""String_Node_Str"" + badTypeName,null);
      pendingRemovals.add(referrerFn);
    }
  }
}","@Override protected void onTypeRef(SourceTypeBinding referencedType,CompilationUnitDeclaration unitOfReferrer){
  String referencedFn=String.valueOf(referencedType.getFileName());
  if (!unchangedCudsByFileName.containsKey(referencedFn) && !changedCudsByFileName.containsKey(referencedFn)) {
    String referrerFn=String.valueOf(unitOfReferrer.getFileName());
    if (changedCudsByFileName.containsKey(referrerFn) && !pendingRemovals.contains(referrerFn)) {
      TreeLogger branch=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + referrerFn + ""String_Node_Str"",null);
      final String badTypeName=CharOperation.toString(referencedType.compoundName);
      branch.branch(TreeLogger.TRACE,""String_Node_Str"" + badTypeName,null);
      pendingRemovals.add(referrerFn);
    }
  }
}"
82797,"private static void removeUnitsWithErrors(TreeLogger logger,Map<String,CompilationUnitDeclaration> cudsByFileName){
  boolean anyRemoved=false;
  for (Iterator<CompilationUnitDeclaration> iter=cudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    CompilationResult result=cud.compilationResult;
    IProblem[] errors=result.getErrors();
    if (errors != null && errors.length > 0) {
      anyRemoved=true;
      iter.remove();
      String fileName=CharOperation.charToString(cud.getFileName());
      char[] source=cud.compilationResult.compilationUnit.getContents();
      Util.maybeDumpSource(logger,fileName,source,String.valueOf(cud.getMainTypeName()));
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + fileName + ""String_Node_Str"",null);
    }
  }
  if (anyRemoved) {
    removeInfectedUnits(logger,cudsByFileName);
  }
}","private static void removeUnitsWithErrors(TreeLogger logger,Map<String,CompilationUnitDeclaration> changedCudsByFileName,Map<String,CompilationUnitDeclaration> unchangedCudsByFileName){
  boolean anyRemoved=false;
  for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    CompilationResult result=cud.compilationResult;
    IProblem[] errors=result.getErrors();
    if (errors != null && errors.length > 0) {
      anyRemoved=true;
      iter.remove();
      String fileName=CharOperation.charToString(cud.getFileName());
      char[] source=cud.compilationResult.compilationUnit.getContents();
      Util.maybeDumpSource(logger,fileName,source,String.valueOf(cud.getMainTypeName()));
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + fileName + ""String_Node_Str"",null);
    }
  }
  if (anyRemoved) {
    removeInfectedUnits(logger,changedCudsByFileName,unchangedCudsByFileName);
  }
}"
82798,"public TypeOracle build(final TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  Set<CompilationUnitProvider> addedCups=cacheManager.getAddedCups();
  TypeOracle oracle=cacheManager.getTypeOracle();
  for (Iterator<CompilationUnitProvider> iter=addedCups.iterator(); iter.hasNext(); ) {
    CompilationUnitProvider cup=iter.next();
    String location=cup.getLocation();
    if (!((location.indexOf(""String_Node_Str"") != -1) || (location.indexOf(""String_Node_Str"") != -1))) {
      location=Util.findFileName(location);
      if (!(new File(location).exists() || cup.isTransient())) {
        iter.remove();
        logger.log(TreeLogger.TRACE,""String_Node_Str"" + location + ""String_Node_Str"",null);
      }
    }
  }
  CompilationUnitProvider[] cups=Util.toArray(CompilationUnitProvider.class,addedCups);
  Arrays.sort(cups,CompilationUnitProvider.LOCATION_COMPARATOR);
  boolean foundJavaLangPackage=oracle.findPackage(""String_Node_Str"") != null;
  ICompilationUnit[] units=new ICompilationUnit[cups.length];
  for (int i=0; i < cups.length; i++) {
    if (!foundJavaLangPackage && cups[i].getPackageName().equals(""String_Node_Str"")) {
      foundJavaLangPackage=true;
    }
    units[i]=cacheManager.findUnitForCup(cups[i]);
  }
  if (!foundJavaLangPackage) {
    Util.logMissingTypeErrorWithHints(logger,""String_Node_Str"");
    throw new UnableToCompleteException();
  }
  PerfLogger.start(""String_Node_Str"");
  CompilationUnitDeclaration[] cuds=cacheManager.getAstCompiler().getChangedCompilationUnitDeclarations(logger,units);
  PerfLogger.end();
  final Map<String,CompilationUnitDeclaration> cudsByFileName=new TreeMap<String,CompilationUnitDeclaration>();
  for (int i=0; i < cuds.length; i++) {
    CompilationUnitDeclaration cud=cuds[i];
    char[] location=cud.getFileName();
    cudsByFileName.put(String.valueOf(location),cud);
  }
  cacheManager.getCudsByFileName().putAll(cudsByFileName);
  removeUnitsWithErrors(logger,cudsByFileName);
  final CacheManager.Mapper identityMapper=cacheManager.getIdentityMapper();
  for (Iterator<CompilationUnitDeclaration> iter=cudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,true);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,false);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        processType(typeDecl,null,false);
        return true;
      }
    }
,cud.scope);
  }
  for (Iterator<CompilationUnitDeclaration> iter=cudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    String loc=String.valueOf(cud.getFileName());
    String processing=""String_Node_Str"" + loc;
    final TreeLogger cudLogger=logger.branch(TreeLogger.SPAM,processing,null);
    final char[] source=cud.compilationResult.compilationUnit.getContents();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
    }
,cud.scope);
  }
  Util.invokeInaccessableMethod(TypeOracle.class,""String_Node_Str"",new Class[]{TreeLogger.class},oracle,new Object[]{logger});
  PerfLogger.end();
  return oracle;
}","public TypeOracle build(final TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  Set<CompilationUnitProvider> addedCups=cacheManager.getAddedCups();
  TypeOracle oracle=cacheManager.getTypeOracle();
  for (Iterator<CompilationUnitProvider> iter=addedCups.iterator(); iter.hasNext(); ) {
    CompilationUnitProvider cup=iter.next();
    String location=cup.getLocation();
    if (!((location.indexOf(""String_Node_Str"") != -1) || (location.indexOf(""String_Node_Str"") != -1))) {
      location=Util.findFileName(location);
      if (!(new File(location).exists() || cup.isTransient())) {
        iter.remove();
        logger.log(TreeLogger.TRACE,""String_Node_Str"" + location + ""String_Node_Str"",null);
      }
    }
  }
  CompilationUnitProvider[] cups=Util.toArray(CompilationUnitProvider.class,addedCups);
  Arrays.sort(cups,CompilationUnitProvider.LOCATION_COMPARATOR);
  boolean foundJavaLangPackage=oracle.findPackage(""String_Node_Str"") != null;
  ICompilationUnit[] units=new ICompilationUnit[cups.length];
  for (int i=0; i < cups.length; i++) {
    if (!foundJavaLangPackage && cups[i].getPackageName().equals(""String_Node_Str"")) {
      foundJavaLangPackage=true;
    }
    units[i]=cacheManager.findUnitForCup(cups[i]);
  }
  if (!foundJavaLangPackage) {
    Util.logMissingTypeErrorWithHints(logger,""String_Node_Str"");
    throw new UnableToCompleteException();
  }
  PerfLogger.start(""String_Node_Str"");
  CompilationUnitDeclaration[] cuds=cacheManager.getAstCompiler().getChangedCompilationUnitDeclarations(logger,units);
  PerfLogger.end();
  final Map<String,CompilationUnitDeclaration> unchangedCudsByFileName=new TreeMap<String,CompilationUnitDeclaration>();
  unchangedCudsByFileName.putAll(cacheManager.getCudsByFileName());
  final Map<String,CompilationUnitDeclaration> changedCudsByFileName=new TreeMap<String,CompilationUnitDeclaration>();
  for (int i=0; i < cuds.length; i++) {
    CompilationUnitDeclaration cud=cuds[i];
    String fileName=String.valueOf(cud.getFileName());
    changedCudsByFileName.put(fileName,cud);
    unchangedCudsByFileName.remove(fileName);
  }
  cacheManager.getCudsByFileName().putAll(changedCudsByFileName);
  removeUnitsWithErrors(logger,changedCudsByFileName,unchangedCudsByFileName);
  final CacheManager.Mapper identityMapper=cacheManager.getIdentityMapper();
  for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,true);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,false);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        processType(typeDecl,null,false);
        return true;
      }
    }
,cud.scope);
  }
  for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    String loc=String.valueOf(cud.getFileName());
    String processing=""String_Node_Str"" + loc;
    final TreeLogger cudLogger=logger.branch(TreeLogger.SPAM,processing,null);
    final char[] source=cud.compilationResult.compilationUnit.getContents();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
    }
,cud.scope);
  }
  Util.invokeInaccessableMethod(TypeOracle.class,""String_Node_Str"",new Class[]{TreeLogger.class},oracle,new Object[]{logger});
  PerfLogger.end();
  return oracle;
}"
82799,"private static void removeInfectedUnits(final TreeLogger logger,final Map<String,CompilationUnitDeclaration> cudsByFileName){
  final Set<String> pendingRemovals=new HashSet<String>();
  TypeRefVisitor trv=new TypeRefVisitor(){
    @Override protected void onTypeRef(    SourceTypeBinding referencedType,    CompilationUnitDeclaration unitOfReferrer){
      String referencedFn=String.valueOf(referencedType.getFileName());
      CompilationUnitDeclaration referencedCud=cudsByFileName.get(referencedFn);
      if (referencedCud == null) {
        String referrerFn=String.valueOf(unitOfReferrer.getFileName());
        if (cudsByFileName.containsKey(referrerFn) && !pendingRemovals.contains(referrerFn)) {
          TreeLogger branch=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + referrerFn + ""String_Node_Str"",null);
          final String badTypeName=CharOperation.toString(referencedType.compoundName);
          branch.branch(TreeLogger.TRACE,""String_Node_Str"" + badTypeName,null);
          pendingRemovals.add(referrerFn);
        }
      }
    }
  }
;
  do {
    for (Iterator<String> iter=pendingRemovals.iterator(); iter.hasNext(); ) {
      String fnToRemove=iter.next();
      Object removed=cudsByFileName.remove(fnToRemove);
      assert(removed != null);
    }
    pendingRemovals.clear();
    for (Iterator<CompilationUnitDeclaration> iter=cudsByFileName.values().iterator(); iter.hasNext(); ) {
      CompilationUnitDeclaration cud=iter.next();
      cud.traverse(trv,cud.scope);
    }
  }
 while (!pendingRemovals.isEmpty());
}","private static void removeInfectedUnits(final TreeLogger logger,final Map<String,CompilationUnitDeclaration> changedCudsByFileName,final Map<String,CompilationUnitDeclaration> unchangedCudsByFileName){
  final Set<String> pendingRemovals=new HashSet<String>();
  TypeRefVisitor trv=new TypeRefVisitor(){
    @Override protected void onTypeRef(    SourceTypeBinding referencedType,    CompilationUnitDeclaration unitOfReferrer){
      String referencedFn=String.valueOf(referencedType.getFileName());
      if (!unchangedCudsByFileName.containsKey(referencedFn) && !changedCudsByFileName.containsKey(referencedFn)) {
        String referrerFn=String.valueOf(unitOfReferrer.getFileName());
        if (changedCudsByFileName.containsKey(referrerFn) && !pendingRemovals.contains(referrerFn)) {
          TreeLogger branch=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + referrerFn + ""String_Node_Str"",null);
          final String badTypeName=CharOperation.toString(referencedType.compoundName);
          branch.branch(TreeLogger.TRACE,""String_Node_Str"" + badTypeName,null);
          pendingRemovals.add(referrerFn);
        }
      }
    }
  }
;
  do {
    for (Iterator<String> iter=pendingRemovals.iterator(); iter.hasNext(); ) {
      String fnToRemove=iter.next();
      Object removed=changedCudsByFileName.remove(fnToRemove);
      assert(removed != null);
    }
    pendingRemovals.clear();
    for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
      CompilationUnitDeclaration cud=iter.next();
      cud.traverse(trv,cud.scope);
    }
  }
 while (!pendingRemovals.isEmpty());
}"
82800,"public String getLocation(){
  return ""String_Node_Str"" + this.packageName + ""String_Node_Str""+ this.typeNames[0];
}","public String getLocation(){
  return ""String_Node_Str"" + cup.getLocation();
}"
82801,"public long getLastModified() throws UnableToCompleteException {
  return 0;
}","public long getLastModified() throws UnableToCompleteException {
  return cup.getLastModified();
}"
82802,"public char[] getSource(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString().toCharArray();
}","@Override public char[] getSource(){
  StringBuffer sb=new StringBuffer();
  if (!goBad) {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"");
    goBad=true;
  }
 else {
    sb.append(""String_Node_Str"");
  }
  return sb.toString().toCharArray();
}"
82803,"public String getMainTypeName(){
  return typeNames[0];
}","public String getMainTypeName(){
  return cup.getMainTypeName();
}"
82804,"public String getPackageName(){
  return packageName;
}","public String getPackageName(){
  return cup.getPackageName();
}"
82805,"public boolean isTransient(){
  return true;
}","public boolean isTransient(){
  return false;
}"
82806,"public boolean execImpl(){
  StaticEvalVisitor evalVisitor=new StaticEvalVisitor();
  evalVisitor.accept(program);
  return evalVisitor.didChange();
}","public boolean execImpl(){
  EvalFunctionsAtTopScope fev=new EvalFunctionsAtTopScope();
  fev.accept(program);
  StaticEvalVisitor sev=new StaticEvalVisitor();
  sev.accept(program);
  return fev.didChange() || sev.didChange();
}"
82807,"/** 
 * Prune while (false) statements.
 */
@Override public void endVisit(JsWhile x,JsContext<JsStatement> ctx){
  JsExpression expr=x.getCondition();
  if (expr instanceof CanBooleanEval) {
    CanBooleanEval cond=(CanBooleanEval)expr;
    if (cond.isBooleanFalse()) {
      ctx.replaceMe(expr.makeStmt());
    }
  }
}","/** 
 * Prune while (false) statements.
 */
@Override public void endVisit(JsWhile x,JsContext<JsStatement> ctx){
  JsExpression expr=x.getCondition();
  if (expr instanceof CanBooleanEval) {
    CanBooleanEval cond=(CanBooleanEval)expr;
    if (cond.isBooleanFalse()) {
      JsBlock block=new JsBlock();
      block.getStatements().add(expr.makeStmt());
      JsStatement decls=ensureDeclarations(x.getBody());
      if (decls != null) {
        block.getStatements().add(decls);
      }
      ctx.replaceMe(accept(block));
    }
  }
}"
82808,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AnnotationsTest.class);
  suite.addTestSuite(AutoboxTest.class);
  suite.addTestSuite(BlankInterfaceTest.class);
  suite.addTestSuite(ClassCastTest.class);
  suite.addTestSuite(ClassObjectTest.class);
  suite.addTestSuite(CompilerTest.class);
  suite.addTestSuite(CoverageTest.class);
  suite.addTestSuite(EnhancedForLoopTest.class);
  suite.addTestSuite(EnumsTest.class);
  suite.addTestSuite(HostedTest.class);
  suite.addTestSuite(InnerClassTest.class);
  suite.addTestSuite(InnerOuterSuperTest.class);
  suite.addTestSuite(JsniConstructorTest.class);
  suite.addTestSuite(JsoTest.class);
  suite.addTestSuite(MemberShadowingTest.class);
  suite.addTestSuite(MethodBindTest.class);
  suite.addTestSuite(MethodCallTest.class);
  suite.addTestSuite(MethodInterfaceTest.class);
  suite.addTestSuite(MiscellaneousTest.class);
  suite.addTestSuite(NativeLongTest.class);
  suite.addTestSuite(VarargsTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AnnotationsTest.class);
  suite.addTestSuite(AutoboxTest.class);
  suite.addTestSuite(BlankInterfaceTest.class);
  suite.addTestSuite(ClassCastTest.class);
  suite.addTestSuite(ClassObjectTest.class);
  suite.addTestSuite(CompilerTest.class);
  suite.addTestSuite(CoverageTest.class);
  suite.addTestSuite(EnhancedForLoopTest.class);
  suite.addTestSuite(EnumsTest.class);
  suite.addTestSuite(HostedTest.class);
  suite.addTestSuite(InnerClassTest.class);
  suite.addTestSuite(InnerOuterSuperTest.class);
  suite.addTestSuite(JsniConstructorTest.class);
  suite.addTestSuite(JsoTest.class);
  suite.addTestSuite(JsStaticEvalTest.class);
  suite.addTestSuite(MemberShadowingTest.class);
  suite.addTestSuite(MethodBindTest.class);
  suite.addTestSuite(MethodCallTest.class);
  suite.addTestSuite(MethodInterfaceTest.class);
  suite.addTestSuite(MiscellaneousTest.class);
  suite.addTestSuite(NativeLongTest.class);
  suite.addTestSuite(VarargsTest.class);
  return suite;
}"
82809,"public float invokeNativeFloat(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Float value=JsValueGlue.get(result,null,Float.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.floatValue();
}","public float invokeNativeFloat(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Float value=JsValueGlue.get(result,null,Float.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.floatValue();
}"
82810,"public short invokeNativeShort(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Short value=JsValueGlue.get(result,null,Short.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.shortValue();
}","public short invokeNativeShort(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Short value=JsValueGlue.get(result,null,Short.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.shortValue();
}"
82811,"public char invokeNativeChar(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Character value=JsValueGlue.get(result,null,Character.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.charValue();
}","public char invokeNativeChar(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Character value=JsValueGlue.get(result,null,Character.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.charValue();
}"
82812,"public double invokeNativeDouble(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Double value=JsValueGlue.get(result,null,Double.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.doubleValue();
}","public double invokeNativeDouble(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Double value=JsValueGlue.get(result,null,Double.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.doubleValue();
}"
82813,"public int invokeNativeInt(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Integer value=JsValueGlue.get(result,null,Integer.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.intValue();
}","public int invokeNativeInt(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Integer value=JsValueGlue.get(result,null,Integer.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.intValue();
}"
82814,"public byte invokeNativeByte(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Byte value=JsValueGlue.get(result,null,Byte.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.byteValue();
}","public byte invokeNativeByte(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Byte value=JsValueGlue.get(result,null,Byte.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.byteValue();
}"
82815,"public Object invokeNativeObject(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  return JsValueGlue.get(result,getIsolatedClassLoader(),Object.class,""String_Node_Str"" + name + ""String_Node_Str"");
}","public Object invokeNativeObject(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  return JsValueGlue.get(result,getIsolatedClassLoader(),Object.class,msgPrefix);
}"
82816,"public boolean invokeNativeBoolean(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Boolean value=JsValueGlue.get(result,getIsolatedClassLoader(),boolean.class,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.booleanValue();
}","public boolean invokeNativeBoolean(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Boolean value=JsValueGlue.get(result,getIsolatedClassLoader(),boolean.class,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.booleanValue();
}"
82817,"public long invokeNativeLong(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Long value=JsValueGlue.get(result,null,Long.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.longValue();
}","public long invokeNativeLong(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Long value=JsValueGlue.get(result,null,Long.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.longValue();
}"
82818,"/** 
 * Assert that the given   {@link Element} is compatible with this class andautomatically typecast it.
 */
public static HeadElement as(Element elem){
}","/** 
 * Assert that the given   {@link Element} is compatible with this class andautomatically typecast it.
 */
public static LinkElement as(Element elem){
}"
82819,"private native void sinkEventsImpl(Element elem,int bits);","protected native void sinkEventsImpl(Element elem,int bits);"
82820,"/** 
 * Gets a JParameter iterator for a constructor method over its synthetic parameters.
 */
private static Iterator<JParameter> getSyntheticsIterator(JMethod method){
  Iterator<JParameter> it=method.params.iterator();
  for (int i=0, c=method.getOriginalParamTypes().size(); i < c; ++i) {
    it.next();
  }
  return it;
}","/** 
 * Gets a JParameter iterator for a constructor method over its synthetic parameters.
 */
private Iterator<JParameter> getSyntheticsIterator(){
  Iterator<JParameter> it=currentMethod.params.iterator();
  for (int i=0, c=currentMethod.getOriginalParamTypes().size(); i < c; ++i) {
    it.next();
  }
  return it;
}"
82821,"JMethodCall processThisConstructorCall(ExplicitConstructorCall x){
  SourceInfo info=makeSourceInfo(x);
  JMethod ctor=(JMethod)typeMap.get(x.binding);
  JExpression trueQualifier=createThisRef(info,currentClass);
  JMethodCall call=new JMethodCall(program,info,trueQualifier,ctor);
  assert(x.qualification == null);
  addCallArgs(x.arguments,call,x.binding);
  ReferenceBinding declaringClass=x.binding.declaringClass;
  if (declaringClass instanceof NestedTypeBinding) {
    Iterator<JParameter> paramIt=getSyntheticsIterator(currentMethod);
    NestedTypeBinding nestedBinding=(NestedTypeBinding)declaringClass;
    if (nestedBinding.enclosingInstances != null) {
      for (int i=0; i < nestedBinding.enclosingInstances.length; ++i) {
        call.getArgs().add(createVariableRef(info,paramIt.next()));
      }
    }
    if (nestedBinding.outerLocalVariables != null) {
      for (int i=0; i < nestedBinding.outerLocalVariables.length; ++i) {
        call.getArgs().add(createVariableRef(info,paramIt.next()));
      }
    }
  }
  return call;
}","JMethodCall processThisConstructorCall(ExplicitConstructorCall x){
  SourceInfo info=makeSourceInfo(x);
  JMethod ctor=(JMethod)typeMap.get(x.binding);
  JExpression trueQualifier=createThisRef(info,currentClass);
  JMethodCall call=new JMethodCall(program,info,trueQualifier,ctor);
  assert(x.qualification == null);
  addCallArgs(x.arguments,call,x.binding);
  ReferenceBinding declaringClass=x.binding.declaringClass;
  if (declaringClass.isNestedType() && !declaringClass.isStatic()) {
    Iterator<JParameter> paramIt=getSyntheticsIterator();
    NestedTypeBinding nestedBinding=(NestedTypeBinding)erasure(declaringClass);
    if (nestedBinding.enclosingInstances != null) {
      for (int i=0; i < nestedBinding.enclosingInstances.length; ++i) {
        call.getArgs().add(createVariableRef(info,paramIt.next()));
      }
    }
    if (nestedBinding.outerLocalVariables != null) {
      for (int i=0; i < nestedBinding.outerLocalVariables.length; ++i) {
        call.getArgs().add(createVariableRef(info,paramIt.next()));
      }
    }
  }
  return call;
}"
82822,"@SuppressWarnings(""String_Node_Str"") JMethodCall processSuperConstructorCall(ExplicitConstructorCall x){
  SourceInfo info=makeSourceInfo(x);
  JMethod ctor=(JMethod)typeMap.get(x.binding);
  JExpression trueQualifier=createThisRef(info,currentClass);
  JMethodCall call=new JMethodCall(program,info,trueQualifier,ctor);
  addCallArgs(x.arguments,call,x.binding);
  ReferenceBinding superClass=x.binding.declaringClass;
  if (superClass.isNestedType() && !superClass.isStatic()) {
    ReferenceBinding myBinding=currentClassScope.referenceType().binding;
    ReferenceBinding superBinding=superClass;
    if (superBinding.syntheticEnclosingInstanceTypes() != null) {
      JExpression qualifier=dispProcessExpression(x.qualification);
      for (      ReferenceBinding arg : superBinding.syntheticEnclosingInstanceTypes()) {
        JClassType classType=(JClassType)typeMap.get(arg);
        if (qualifier == null) {
          List<JExpression> workList=new ArrayList<JExpression>();
          Iterator<JParameter> paramIt=getSyntheticsIterator(currentMethod);
          for (          ReferenceBinding b : myBinding.syntheticEnclosingInstanceTypes()) {
            workList.add(createVariableRef(info,paramIt.next()));
          }
          call.getArgs().add(createThisRef(classType,workList));
        }
 else {
          call.getArgs().add(createThisRef(classType,qualifier));
        }
      }
    }
    if (superBinding.syntheticOuterLocalVariables() != null) {
      for (      SyntheticArgumentBinding arg : superBinding.syntheticOuterLocalVariables()) {
        JType varType=(JType)typeMap.get(arg.type);
        String varName=String.valueOf(arg.name);
        JParameter param=null;
        for (int i=0; i < currentMethod.params.size(); ++i) {
          JParameter paramIt=currentMethod.params.get(i);
          if (varType == paramIt.getType() && varName.equals(paramIt.getName())) {
            param=paramIt;
          }
        }
        if (param == null) {
          throw new InternalCompilerException(""String_Node_Str"");
        }
        call.getArgs().add(createVariableRef(info,param));
      }
    }
  }
  return call;
}","@SuppressWarnings(""String_Node_Str"") JMethodCall processSuperConstructorCall(ExplicitConstructorCall x){
  SourceInfo info=makeSourceInfo(x);
  JMethod ctor=(JMethod)typeMap.get(x.binding);
  JExpression trueQualifier=createThisRef(info,currentClass);
  JMethodCall call=new JMethodCall(program,info,trueQualifier,ctor);
  addCallArgs(x.arguments,call,x.binding);
  ReferenceBinding superClass=x.binding.declaringClass;
  if (superClass.isNestedType() && !superClass.isStatic()) {
    ReferenceBinding myBinding=currentClassScope.referenceType().binding;
    ReferenceBinding superBinding=superClass;
    if (superBinding.syntheticEnclosingInstanceTypes() != null) {
      JExpression qualifier=dispProcessExpression(x.qualification);
      for (      ReferenceBinding arg : superBinding.syntheticEnclosingInstanceTypes()) {
        JClassType classType=(JClassType)typeMap.get(arg);
        if (qualifier == null) {
          List<JExpression> workList=new ArrayList<JExpression>();
          Iterator<JParameter> paramIt=getSyntheticsIterator();
          for (          ReferenceBinding b : myBinding.syntheticEnclosingInstanceTypes()) {
            workList.add(createVariableRef(info,paramIt.next()));
          }
          call.getArgs().add(createThisRef(classType,workList));
        }
 else {
          call.getArgs().add(createThisRef(classType,qualifier));
        }
      }
    }
    if (superBinding.syntheticOuterLocalVariables() != null) {
      for (      SyntheticArgumentBinding arg : superBinding.syntheticOuterLocalVariables()) {
        JType varType=(JType)typeMap.get(arg.type);
        String varName=String.valueOf(arg.name);
        JParameter param=null;
        for (int i=0; i < currentMethod.params.size(); ++i) {
          JParameter paramIt=currentMethod.params.get(i);
          if (varType == paramIt.getType() && varName.equals(paramIt.getName())) {
            param=paramIt;
          }
        }
        if (param == null) {
          throw new InternalCompilerException(""String_Node_Str"");
        }
        call.getArgs().add(createVariableRef(info,param));
      }
    }
  }
  return call;
}"
82823,"/** 
 * Weird: we used to have JConstructor (and JConstructorCall) in our AST, but we got rid of them completely and instead model them as instance methods whose qualifier is a naked no-argument new operation. There are several reasons we do it this way: 1) When spitting our AST back to Java code (for verification purposes), we found it was impossible to correctly emulate nested classes as non-nested classes using traditional constructor syntax. It boiled down to the fact that you really HAVE to assign your synthetic arguments to your synthetic fields BEFORE calling your superclass constructor (because it might call you back polymorphically). And trying to do that in straight Java is a semantic error, a super call must be the first statement of your constructor. 2) It's a lot more like how we'll be generating JavaScript eventually. 3) It's a lot easier to optimize; the same optimizations work on our synthetic fields as work on any user fields. In fact, once we're past AST generation, we throw away all information about what's synthetic. The order of emulation is: - assign all synthetic fields from synthetic args - call our super constructor emulation method - call our instance initializer emulation method - run user code - return this
 */
void processConstructor(ConstructorDeclaration x){
  JMethod ctor=(JMethod)typeMap.get(x.binding);
  try {
    SourceInfo info=ctor.getSourceInfo();
    currentMethod=ctor;
    currentMethodBody=(JMethodBody)ctor.getBody();
    currentMethodScope=x.scope;
    JMethodCall superOrThisCall=null;
    ExplicitConstructorCall ctorCall=x.constructorCall;
    if (ctorCall != null) {
      superOrThisCall=(JMethodCall)dispatch(""String_Node_Str"",ctorCall);
    }
    boolean hasExplicitThis=(ctorCall != null) && !ctorCall.isSuperAccess();
    JClassType enclosingType=(JClassType)ctor.getEnclosingType();
    JMethod clinitMethod=enclosingType.methods.get(0);
    JMethodCall clinitCall=new JMethodCall(program,info,null,clinitMethod);
    JMethodBody body=(JMethodBody)ctor.getBody();
    List<JStatement> statements=body.getStatements();
    statements.add(clinitCall.makeStatement());
    if (!hasExplicitThis) {
      ReferenceBinding declaringClass=x.binding.declaringClass;
      if (declaringClass instanceof NestedTypeBinding) {
        Iterator<JParameter> paramIt=getSyntheticsIterator(ctor);
        NestedTypeBinding nestedBinding=(NestedTypeBinding)declaringClass;
        if (nestedBinding.enclosingInstances != null) {
          for (int i=0; i < nestedBinding.enclosingInstances.length; ++i) {
            SyntheticArgumentBinding arg=nestedBinding.enclosingInstances[i];
            JParameter param=paramIt.next();
            if (arg.matchingField != null) {
              JField field=(JField)typeMap.get(arg);
              statements.add(program.createAssignmentStmt(info,createVariableRef(info,field),createVariableRef(info,param)));
            }
          }
        }
        if (nestedBinding.outerLocalVariables != null) {
          for (int i=0; i < nestedBinding.outerLocalVariables.length; ++i) {
            SyntheticArgumentBinding arg=nestedBinding.outerLocalVariables[i];
            JParameter param=paramIt.next();
            JField field=(JField)typeMap.get(arg);
            statements.add(program.createAssignmentStmt(info,createVariableRef(info,field),createVariableRef(info,param)));
          }
        }
      }
    }
    if (enclosingType.isEnumOrSubclass() != null) {
      assert(superOrThisCall != null);
      JVariableRef enumNameRef=createVariableRef(superOrThisCall.getSourceInfo(),ctor.params.get(0));
      superOrThisCall.getArgs().add(0,enumNameRef);
      JVariableRef enumOrdinalRef=createVariableRef(superOrThisCall.getSourceInfo(),ctor.params.get(1));
      superOrThisCall.getArgs().add(1,enumOrdinalRef);
    }
    if (superOrThisCall != null) {
      statements.add(superOrThisCall.makeStatement());
    }
    JExpression thisRef=createThisRef(info,enclosingType);
    if (!hasExplicitThis) {
      JMethod initMethod=enclosingType.methods.get(1);
      JMethodCall initCall=new JMethodCall(program,info,thisRef,initMethod);
      statements.add(initCall.makeStatement());
    }
    if (x.statements != null) {
      for (int i=0, n=x.statements.length; i < n; ++i) {
        Statement origStmt=x.statements[i];
        JStatement jstmt=dispProcessStatement(origStmt);
        if (jstmt != null) {
          statements.add(jstmt);
        }
      }
    }
    currentMethodScope=null;
    currentMethod=null;
    statements.add(new JReturnStatement(program,null,thisRef));
  }
 catch (  Throwable e) {
    throw translateException(ctor,e);
  }
}","/** 
 * Weird: we used to have JConstructor (and JConstructorCall) in our AST, but we got rid of them completely and instead model them as instance methods whose qualifier is a naked no-argument new operation. There are several reasons we do it this way: 1) When spitting our AST back to Java code (for verification purposes), we found it was impossible to correctly emulate nested classes as non-nested classes using traditional constructor syntax. It boiled down to the fact that you really HAVE to assign your synthetic arguments to your synthetic fields BEFORE calling your superclass constructor (because it might call you back polymorphically). And trying to do that in straight Java is a semantic error, a super call must be the first statement of your constructor. 2) It's a lot more like how we'll be generating JavaScript eventually. 3) It's a lot easier to optimize; the same optimizations work on our synthetic fields as work on any user fields. In fact, once we're past AST generation, we throw away all information about what's synthetic. The order of emulation is: - assign all synthetic fields from synthetic args - call our super constructor emulation method - call our instance initializer emulation method - run user code - return this
 */
void processConstructor(ConstructorDeclaration x){
  JMethod ctor=(JMethod)typeMap.get(x.binding);
  try {
    SourceInfo info=ctor.getSourceInfo();
    currentMethod=ctor;
    currentMethodBody=(JMethodBody)ctor.getBody();
    currentMethodScope=x.scope;
    JMethodCall superOrThisCall=null;
    ExplicitConstructorCall ctorCall=x.constructorCall;
    if (ctorCall != null) {
      superOrThisCall=(JMethodCall)dispatch(""String_Node_Str"",ctorCall);
    }
    boolean hasExplicitThis=(ctorCall != null) && !ctorCall.isSuperAccess();
    JClassType enclosingType=(JClassType)ctor.getEnclosingType();
    JMethod clinitMethod=enclosingType.methods.get(0);
    JMethodCall clinitCall=new JMethodCall(program,info,null,clinitMethod);
    JMethodBody body=(JMethodBody)ctor.getBody();
    List<JStatement> statements=body.getStatements();
    statements.add(clinitCall.makeStatement());
    if (!hasExplicitThis) {
      ReferenceBinding declaringClass=x.binding.declaringClass;
      if (declaringClass instanceof NestedTypeBinding) {
        Iterator<JParameter> paramIt=getSyntheticsIterator();
        NestedTypeBinding nestedBinding=(NestedTypeBinding)declaringClass;
        if (nestedBinding.enclosingInstances != null) {
          for (int i=0; i < nestedBinding.enclosingInstances.length; ++i) {
            SyntheticArgumentBinding arg=nestedBinding.enclosingInstances[i];
            JParameter param=paramIt.next();
            if (arg.matchingField != null) {
              JField field=(JField)typeMap.get(arg);
              statements.add(program.createAssignmentStmt(info,createVariableRef(info,field),createVariableRef(info,param)));
            }
          }
        }
        if (nestedBinding.outerLocalVariables != null) {
          for (int i=0; i < nestedBinding.outerLocalVariables.length; ++i) {
            SyntheticArgumentBinding arg=nestedBinding.outerLocalVariables[i];
            JParameter param=paramIt.next();
            JField field=(JField)typeMap.get(arg);
            statements.add(program.createAssignmentStmt(info,createVariableRef(info,field),createVariableRef(info,param)));
          }
        }
      }
    }
    if (enclosingType.isEnumOrSubclass() != null) {
      assert(superOrThisCall != null);
      JVariableRef enumNameRef=createVariableRef(superOrThisCall.getSourceInfo(),ctor.params.get(0));
      superOrThisCall.getArgs().add(0,enumNameRef);
      JVariableRef enumOrdinalRef=createVariableRef(superOrThisCall.getSourceInfo(),ctor.params.get(1));
      superOrThisCall.getArgs().add(1,enumOrdinalRef);
    }
    if (superOrThisCall != null) {
      statements.add(superOrThisCall.makeStatement());
    }
    JExpression thisRef=createThisRef(info,enclosingType);
    if (!hasExplicitThis) {
      JMethod initMethod=enclosingType.methods.get(1);
      JMethodCall initCall=new JMethodCall(program,info,thisRef,initMethod);
      statements.add(initCall.makeStatement());
    }
    if (x.statements != null) {
      for (int i=0, n=x.statements.length; i < n; ++i) {
        Statement origStmt=x.statements[i];
        JStatement jstmt=dispProcessStatement(origStmt);
        if (jstmt != null) {
          statements.add(jstmt);
        }
      }
    }
    currentMethodScope=null;
    currentMethod=null;
    statements.add(new JReturnStatement(program,null,thisRef));
  }
 catch (  Throwable e) {
    throw translateException(ctor,e);
  }
}"
82824,"public void testInnerClassLoop(){
  final StringBuffer b=new StringBuffer();
  List results=new ArrayList();
abstract class AppendToStringBuffer {
    public AppendToStringBuffer(    int i){
      this.num=i;
    }
    public abstract void act();
    int num;
  }
  for (int i=0; i < 10; i++) {
    AppendToStringBuffer ap=new AppendToStringBuffer(i){
      public void act(){
        b.append(num);
      }
    }
;
    results.add(ap);
  }
  for (Iterator it=results.iterator(); it.hasNext(); ) {
    AppendToStringBuffer theAp=(AppendToStringBuffer)it.next();
    theAp.act();
  }
  assertEquals(""String_Node_Str"",b.toString());
}","public void testInnerClassLoop(){
  final StringBuffer b=new StringBuffer();
abstract class AppendToStringBuffer {
    int num;
    public AppendToStringBuffer(    int i){
      this.num=i;
    }
    public abstract void act();
  }
  List<AppendToStringBuffer> results=new ArrayList<AppendToStringBuffer>();
  for (int i=0; i < 10; i++) {
    AppendToStringBuffer ap=new AppendToStringBuffer(i){
      public void act(){
        b.append(num);
      }
    }
;
    results.add(ap);
  }
  for (  AppendToStringBuffer theAp : results) {
    theAp.act();
  }
  assertEquals(""String_Node_Str"",b.toString());
}"
82825,"public void testInnerClassInitialization(){
  assertEquals(""String_Node_Str"",testAppend.toString());
}","public void testInnerClassInitialization(){
  testAppend=new StringBuffer();
  new InnerClass();
  assertEquals(""String_Node_Str"",testAppend.toString());
}"
82826,"void callInner(){
  testAppend.append(""String_Node_Str"");
class ReallyInnerClass {
    void callReallyInner(){
      testAppend.append(""String_Node_Str"");
    }
{
      callReallyInner();
    }
  }
  new ReallyInnerClass();
}","void callInner(){
  testAppend.append(""String_Node_Str"");
class ReallyInnerClass {
{
      callReallyInner();
    }
    void callReallyInner(){
      testAppend.append(""String_Node_Str"");
    }
  }
  new ReallyInnerClass();
}"
82827,"/** 
 * Returns the content of an   {@link HttpServletRequest} by decoding it usingthe UTF-8 charset.
 * @param request the servlet request whose content we want to read
 * @return the content of an {@link HttpServletRequest} by decoding it usingthe UTF-8 charset
 * @throws IOException if the requests input stream cannot be accessed, readfrom or closed
 * @throws ServletException if the content length of the request is notspecified of if the request's content type is not 'text/x-gwt-rpc' and 'charset=utf-8'
 */
public static String readContentAsUtf8(HttpServletRequest request) throws IOException, ServletException {
  int contentLength=request.getContentLength();
  if (contentLength == -1) {
    throw new ServletException(""String_Node_Str"");
  }
  String contentType=request.getContentType();
  boolean contentTypeIsOkay=false;
  if (contentType != null) {
    contentType=contentType.toLowerCase();
    if (contentType.startsWith(EXPECTED_CONTENT_TYPE)) {
      if (contentType.indexOf(EXPECTED_CHARSET) != -1) {
        contentTypeIsOkay=true;
      }
    }
  }
  if (!contentTypeIsOkay) {
    throw new ServletException(""String_Node_Str"" + EXPECTED_CONTENT_TYPE + ""String_Node_Str""+ EXPECTED_CHARSET+ ""String_Node_Str"");
  }
  InputStream in=request.getInputStream();
  try {
    byte[] payload=new byte[contentLength];
    int offset=0;
    int len=contentLength;
    int byteCount;
    while (offset < contentLength) {
      byteCount=in.read(payload,offset,len);
      if (byteCount == -1) {
        throw new ServletException(""String_Node_Str"" + contentLength + ""String_Node_Str"");
      }
      offset+=byteCount;
      len-=byteCount;
    }
    return new String(payload,CHARSET_UTF8);
  }
  finally {
    if (in != null) {
      in.close();
    }
  }
}","/** 
 * Returns the content of an   {@link HttpServletRequest} by decoding it usingthe UTF-8 charset.
 * @param request the servlet request whose content we want to read
 * @return the content of an {@link HttpServletRequest} by decoding it usingthe UTF-8 charset
 * @throws IOException if the requests input stream cannot be accessed, readfrom or closed
 * @throws ServletException if the content length of the request is notspecified of if the request's content type is not 'text/x-gwt-rpc' and 'charset=utf-8'
 */
public static String readContentAsUtf8(HttpServletRequest request) throws IOException, ServletException {
  int contentLength=request.getContentLength();
  if (contentLength == -1) {
    throw new ServletException(""String_Node_Str"");
  }
  String contentType=request.getContentType();
  boolean contentTypeIsOkay=false;
  if (contentType != null) {
    contentType=contentType.toLowerCase();
    if (contentType.startsWith(EXPECTED_CONTENT_TYPE)) {
      String characterEncoding=request.getCharacterEncoding();
      if (characterEncoding != null) {
        if (characterEncoding.toLowerCase().indexOf(CHARSET_UTF8.toLowerCase()) != -1) {
          contentTypeIsOkay=true;
        }
      }
    }
  }
  if (!contentTypeIsOkay) {
    throw new ServletException(""String_Node_Str"" + EXPECTED_CONTENT_TYPE + ""String_Node_Str""+ EXPECTED_CHARSET+ ""String_Node_Str"");
  }
  InputStream in=request.getInputStream();
  try {
    byte[] payload=new byte[contentLength];
    int offset=0;
    int len=contentLength;
    int byteCount;
    while (offset < contentLength) {
      byteCount=in.read(payload,offset,len);
      if (byteCount == -1) {
        throw new ServletException(""String_Node_Str"" + contentLength + ""String_Node_Str"");
      }
      offset+=byteCount;
      len-=byteCount;
    }
    return new String(payload,CHARSET_UTF8);
  }
  finally {
    if (in != null) {
      in.close();
    }
  }
}"
82828,"private void processDim(JNewArray x,Context ctx,JArrayType arrayType){
  JMethodCall call=new JMethodCall(program,x.getSourceInfo(),null,initDim,arrayType);
  JLiteral classLit=program.getLiteralClass(arrayType);
  JLiteral typeIdLit=program.getLiteralInt(program.getTypeId(arrayType));
  JLiteral queryIdLit=program.getLiteralInt(tryGetQueryId(arrayType));
  JType leafType=arrayType.getLeafType();
  JExpression dim=x.dims.get(0);
  call.getArgs().add(classLit);
  call.getArgs().add(typeIdLit);
  call.getArgs().add(queryIdLit);
  call.getArgs().add(dim);
  call.getArgs().add(getSeedTypeLiteralFor(leafType));
  ctx.replaceMe(call);
}","private void processDim(JNewArray x,Context ctx,JArrayType arrayType){
  JMethodCall call=new JMethodCall(program,x.getSourceInfo(),null,initDim,arrayType);
  JLiteral classLit=program.getLiteralClass(arrayType);
  JLiteral typeIdLit=program.getLiteralInt(program.getTypeId(arrayType));
  JLiteral queryIdLit=program.getLiteralInt(tryGetQueryId(arrayType));
  JExpression dim=x.dims.get(0);
  JType elementType=arrayType.getElementType();
  call.getArgs().add(classLit);
  call.getArgs().add(typeIdLit);
  call.getArgs().add(queryIdLit);
  call.getArgs().add(dim);
  call.getArgs().add(getSeedTypeLiteralFor(elementType));
  ctx.replaceMe(call);
}"
82829,"private void processDims(JNewArray x,Context ctx,JArrayType arrayType){
  JMethodCall call=new JMethodCall(program,x.getSourceInfo(),null,initDims,arrayType);
  JsonArray classLitList=new JsonArray(program);
  JsonArray typeIdList=new JsonArray(program);
  JsonArray queryIdList=new JsonArray(program);
  JsonArray dimList=new JsonArray(program);
  JType leafType=arrayType.getLeafType();
  int outstandingDims=arrayType.getDims();
  for (int i=0; i < x.dims.size(); ++i) {
    JExpression dim=x.dims.get(i);
    if (dim instanceof JAbsentArrayDimension) {
      break;
    }
    JArrayType cur=program.getTypeArray(leafType,outstandingDims--);
    JLiteral classLit=program.getLiteralClass(cur);
    classLitList.exprs.add(classLit);
    JLiteral typeIdLit=program.getLiteralInt(program.getTypeId(cur));
    typeIdList.exprs.add(typeIdLit);
    JLiteral queryIdLit=program.getLiteralInt(tryGetQueryId(cur));
    queryIdList.exprs.add(queryIdLit);
    dimList.exprs.add(dim);
  }
  JType targetType=leafType;
  if (outstandingDims > 0) {
    targetType=program.getTypeArray(targetType,outstandingDims);
  }
  call.getArgs().add(classLitList);
  call.getArgs().add(typeIdList);
  call.getArgs().add(queryIdList);
  call.getArgs().add(dimList);
  call.getArgs().add(getSeedTypeLiteralFor(targetType));
  ctx.replaceMe(call);
}","private void processDims(JNewArray x,Context ctx,JArrayType arrayType,int dims){
  JMethodCall call=new JMethodCall(program,x.getSourceInfo(),null,initDims,arrayType);
  JsonArray classLitList=new JsonArray(program);
  JsonArray typeIdList=new JsonArray(program);
  JsonArray queryIdList=new JsonArray(program);
  JsonArray dimList=new JsonArray(program);
  JType cur=arrayType;
  for (int i=0; i < dims; ++i) {
    JArrayType curArrayType=(JArrayType)cur;
    JLiteral classLit=program.getLiteralClass(cur);
    classLitList.exprs.add(classLit);
    JLiteral typeIdLit=program.getLiteralInt(program.getTypeId(curArrayType));
    typeIdList.exprs.add(typeIdLit);
    JLiteral queryIdLit=program.getLiteralInt(tryGetQueryId(curArrayType));
    queryIdList.exprs.add(queryIdLit);
    dimList.exprs.add(x.dims.get(i));
    cur=curArrayType.getElementType();
  }
  call.getArgs().add(classLitList);
  call.getArgs().add(typeIdList);
  call.getArgs().add(queryIdList);
  call.getArgs().add(dimList);
  call.getArgs().add(program.getLiteralInt(dims));
  call.getArgs().add(getSeedTypeLiteralFor(cur));
  ctx.replaceMe(call);
}"
82830,"@Override public void endVisit(JNewArray x,Context ctx){
  JArrayType type=x.getArrayType();
  if (x.initializers != null) {
    processInitializers(x,ctx,type);
  }
 else   if (type.getDims() == 1) {
    processDim(x,ctx,type);
  }
 else {
    processDims(x,ctx,type);
  }
}","@Override public void endVisit(JNewArray x,Context ctx){
  JArrayType type=x.getArrayType();
  if (x.initializers != null) {
    processInitializers(x,ctx,type);
  }
 else {
    int realDims=0;
    for (    JExpression dim : x.dims) {
      if (dim instanceof JAbsentArrayDimension) {
        break;
      }
      ++realDims;
    }
    assert(realDims >= 1);
    if (realDims == 1) {
      processDim(x,ctx,type);
    }
 else {
      processDims(x,ctx,type,realDims);
    }
  }
}"
82831,"/** 
 * @see com.google.gwt.lang.Array regarding seed types
 */
private JIntLiteral getSeedTypeLiteralFor(JType type){
  if (type instanceof JPrimitiveType) {
    if (type == program.getTypePrimitiveBoolean()) {
      return program.getLiteralInt(2);
    }
 else {
      return program.getLiteralInt(1);
    }
  }
  return program.getLiteralInt(0);
}","/** 
 * @see com.google.gwt.lang.Array regarding seed types
 */
private JIntLiteral getSeedTypeLiteralFor(JType type){
  if (type instanceof JPrimitiveType) {
    if (type == program.getTypePrimitiveLong()) {
      return program.getLiteralInt(3);
    }
 else     if (type == program.getTypePrimitiveBoolean()) {
      return program.getLiteralInt(2);
    }
 else {
      return program.getLiteralInt(1);
    }
  }
  return program.getLiteralInt(0);
}"
82832,"private static Array initDims(Class arrayClasses[],int[] typeIdExprs,int[] queryIdExprs,int[] dimExprs,int index,int count,int seedType){
  int length=dimExprs[index];
  if (length < 0) {
    throw new NegativeArraySizeException();
  }
  boolean isLastDim=(index == (count - 1));
  Array result=createFromSeed(isLastDim ? seedType : NULL_SEED_TYPE,length);
  initValues(arrayClasses[index],typeIdExprs[index],queryIdExprs[index],result);
  if (!isLastDim) {
    ++index;
    for (int i=0; i < length; ++i) {
      set(result,i,initDims(arrayClasses,typeIdExprs,queryIdExprs,dimExprs,index,count,seedType));
    }
  }
  return result;
}","private static Array initDims(Class arrayClasses[],int[] typeIdExprs,int[] queryIdExprs,int[] dimExprs,int index,int count,int seedType){
  int length=dimExprs[index];
  boolean isLastDim=(index == (count - 1));
  Array result=createFromSeed(isLastDim ? seedType : NULL_SEED_TYPE,length);
  initValues(arrayClasses[index],typeIdExprs[index],queryIdExprs[index],result);
  if (!isLastDim) {
    ++index;
    for (int i=0; i < length; ++i) {
      set(result,i,initDims(arrayClasses,typeIdExprs,queryIdExprs,dimExprs,index,count,seedType));
    }
  }
  return result;
}"
82833,"private void maybeDispatch(Scope referencedFrom,Expression expression,TypeBinding binding){
  if (binding instanceof SourceTypeBinding) {
    SourceTypeBinding type=(SourceTypeBinding)binding;
    CompilationUnitScope from=findUnitScope(referencedFrom);
    onTypeRef(type,from.referenceContext);
  }
 else   if (binding instanceof ArrayBinding) {
    maybeDispatch(referencedFrom,expression,((ArrayBinding)binding).leafComponentType);
  }
 else   if (binding instanceof BinaryTypeBinding) {
    CompilationUnitScope from=findUnitScope(referencedFrom);
    onBinaryTypeRef((BinaryTypeBinding)binding,from.referenceContext,expression);
  }
 else {
  }
}","private void maybeDispatch(Scope referencedFrom,Expression expression,TypeBinding binding){
  assert(referencedFrom != null);
  assert(binding != null);
  if (binding instanceof SourceTypeBinding) {
    SourceTypeBinding type=(SourceTypeBinding)binding;
    CompilationUnitScope from=findUnitScope(referencedFrom);
    onTypeRef(type,from.referenceContext);
  }
 else   if (binding instanceof ArrayBinding) {
    maybeDispatch(referencedFrom,expression,((ArrayBinding)binding).leafComponentType);
  }
 else   if (binding instanceof BinaryTypeBinding) {
    CompilationUnitScope from=findUnitScope(referencedFrom);
    onBinaryTypeRef((BinaryTypeBinding)binding,from.referenceContext,expression);
  }
 else   if (binding instanceof ParameterizedTypeBinding) {
    ParameterizedTypeBinding ptBinding=(ParameterizedTypeBinding)binding;
    maybeDispatch(referencedFrom,expression,ptBinding.genericType());
  }
 else   if (binding instanceof RawTypeBinding) {
    RawTypeBinding rawTypeBinding=(RawTypeBinding)binding;
    maybeDispatch(referencedFrom,expression,rawTypeBinding.genericType());
  }
 else {
  }
}"
82834,"/** 
 * Generates the client's asynchronous proxy method.
 */
private void generateProxyMethod(SourceWriter w,SerializableTypeOracle serializableTypeOracle,JMethod syncMethod,JMethod asyncMethod){
  w.println();
  JType asyncReturnType=asyncMethod.getReturnType();
  w.print(""String_Node_Str"");
  w.print(asyncReturnType.getQualifiedSourceName());
  w.print(""String_Node_Str"");
  w.print(asyncMethod.getName() + ""String_Node_Str"");
  boolean needsComma=false;
  boolean needsTryCatchBlock=false;
  NameFactory nameFactory=new NameFactory();
  JParameter[] asyncParams=asyncMethod.getParameters();
  for (int i=0; i < asyncParams.length; ++i) {
    JParameter param=asyncParams[i];
    if (needsComma) {
      w.print(""String_Node_Str"");
    }
 else {
      needsComma=true;
    }
    JType paramType=param.getType();
    if (i < asyncParams.length - 1 && paramType.isPrimitive() == null && !paramType.getQualifiedSourceName().equals(String.class.getCanonicalName())) {
      needsTryCatchBlock=true;
    }
    w.print(paramType.getParameterizedQualifiedSourceName());
    w.print(""String_Node_Str"");
    String paramName=param.getName();
    nameFactory.addName(paramName);
    w.print(paramName);
  }
  w.println(""String_Node_Str"");
  w.indent();
  w.println(""String_Node_Str"");
  String statsMethodExpr=getProxySimpleName() + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"";
  w.println(""String_Node_Str"" + statsMethodExpr + ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.print(ClientSerializationStreamWriter.class.getSimpleName());
  w.print(""String_Node_Str"");
  String streamWriterName=nameFactory.createName(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  w.println(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  if (needsTryCatchBlock) {
    w.println(""String_Node_Str"");
    w.indent();
  }
  if (!shouldEnforceTypeVersioning()) {
    w.println(streamWriterName + ""String_Node_Str"" + ClientSerializationStreamReader.class.getName()+ ""String_Node_Str"");
  }
  w.println(streamWriterName + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"");
  JParameter[] syncParams=syncMethod.getParameters();
  w.println(streamWriterName + ""String_Node_Str"" + syncParams.length+ ""String_Node_Str"");
  for (  JParameter param : syncParams) {
    w.println(streamWriterName + ""String_Node_Str"" + serializableTypeOracle.getSerializedTypeName(param.getType())+ ""String_Node_Str"");
  }
  for (int i=0; i < asyncParams.length - 1; ++i) {
    JParameter asyncParam=asyncParams[i];
    w.print(streamWriterName + ""String_Node_Str"");
    w.print(Shared.getStreamWriteMethodNameFor(asyncParam.getType()));
    w.println(""String_Node_Str"" + asyncParam.getName() + ""String_Node_Str"");
  }
  JParameter callbackParam=asyncParams[asyncParams.length - 1];
  String callbackName=callbackParam.getName();
  if (needsTryCatchBlock) {
    w.outdent();
    w.print(""String_Node_Str"");
    String exceptionName=nameFactory.createName(""String_Node_Str"");
    w.println(exceptionName + ""String_Node_Str"");
    w.indent();
    w.println(callbackName + ""String_Node_Str"" + exceptionName+ ""String_Node_Str"");
    w.outdent();
    w.println(""String_Node_Str"");
  }
  w.println();
  if (asyncReturnType != JPrimitiveType.VOID) {
    w.print(""String_Node_Str"");
  }
  w.println(""String_Node_Str"" + streamWriterName + ""String_Node_Str"");
  w.println(""String_Node_Str"" + statsMethodExpr + ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.print(""String_Node_Str"");
  JType returnType=syncMethod.getReturnType();
  w.print(""String_Node_Str"" + getResponseReaderFor(returnType).name());
  w.print(""String_Node_Str"" + getProxySimpleName() + ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.println(callbackName + ""String_Node_Str"");
  w.outdent();
  w.println(""String_Node_Str"");
}","/** 
 * Generates the client's asynchronous proxy method.
 */
private void generateProxyMethod(SourceWriter w,SerializableTypeOracle serializableTypeOracle,JMethod syncMethod,JMethod asyncMethod){
  w.println();
  JType asyncReturnType=asyncMethod.getReturnType();
  w.print(""String_Node_Str"");
  w.print(asyncReturnType.getQualifiedSourceName());
  w.print(""String_Node_Str"");
  w.print(asyncMethod.getName() + ""String_Node_Str"");
  boolean needsComma=false;
  boolean needsTryCatchBlock=false;
  NameFactory nameFactory=new NameFactory();
  JParameter[] asyncParams=asyncMethod.getParameters();
  for (int i=0; i < asyncParams.length; ++i) {
    JParameter param=asyncParams[i];
    if (needsComma) {
      w.print(""String_Node_Str"");
    }
 else {
      needsComma=true;
    }
    JType paramType=param.getType();
    if (i < asyncParams.length - 1 && paramType.isPrimitive() == null && !paramType.getQualifiedSourceName().equals(String.class.getCanonicalName())) {
      needsTryCatchBlock=true;
    }
    w.print(paramType.getParameterizedQualifiedSourceName());
    w.print(""String_Node_Str"");
    String paramName=param.getName();
    nameFactory.addName(paramName);
    w.print(paramName);
  }
  w.println(""String_Node_Str"");
  w.indent();
  w.println(""String_Node_Str"");
  String statsMethodExpr=getProxySimpleName() + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"";
  w.println(""String_Node_Str"" + statsMethodExpr + ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.print(ClientSerializationStreamWriter.class.getSimpleName());
  w.print(""String_Node_Str"");
  String streamWriterName=nameFactory.createName(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  w.println(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  if (needsTryCatchBlock) {
    w.println(""String_Node_Str"");
    w.indent();
  }
  if (!shouldEnforceTypeVersioning()) {
    w.println(streamWriterName + ""String_Node_Str"" + ClientSerializationStreamReader.class.getName()+ ""String_Node_Str"");
  }
  w.println(streamWriterName + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"");
  JParameter[] syncParams=syncMethod.getParameters();
  w.println(streamWriterName + ""String_Node_Str"" + syncParams.length+ ""String_Node_Str"");
  for (  JParameter param : syncParams) {
    w.println(streamWriterName + ""String_Node_Str"" + serializableTypeOracle.getSerializedTypeName(param.getType())+ ""String_Node_Str"");
  }
  for (int i=0; i < asyncParams.length - 1; ++i) {
    JParameter asyncParam=asyncParams[i];
    w.print(streamWriterName + ""String_Node_Str"");
    w.print(Shared.getStreamWriteMethodNameFor(asyncParam.getType()));
    w.println(""String_Node_Str"" + asyncParam.getName() + ""String_Node_Str"");
  }
  JParameter callbackParam=asyncParams[asyncParams.length - 1];
  String callbackName=callbackParam.getName();
  if (needsTryCatchBlock) {
    w.outdent();
    w.print(""String_Node_Str"");
    String exceptionName=nameFactory.createName(""String_Node_Str"");
    w.println(exceptionName + ""String_Node_Str"");
    w.indent();
    w.println(callbackName + ""String_Node_Str"" + exceptionName+ ""String_Node_Str"");
    w.outdent();
    w.println(""String_Node_Str"");
  }
  w.println();
  w.println(""String_Node_Str"" + streamWriterName + ""String_Node_Str"");
  w.println(""String_Node_Str"" + statsMethodExpr + ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  if (asyncReturnType != JPrimitiveType.VOID) {
    w.print(""String_Node_Str"");
  }
  w.print(""String_Node_Str"");
  JType returnType=syncMethod.getReturnType();
  w.print(""String_Node_Str"" + getResponseReaderFor(returnType).name());
  w.print(""String_Node_Str"" + getProxySimpleName() + ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.println(callbackName + ""String_Node_Str"");
  w.outdent();
  w.println(""String_Node_Str"");
}"
82835,"public void testServiceInterfaceLocation(){
  RemoteServiceServletTestServiceAsync service=getAsyncService();
  delayTestFinish(TEST_DELAY);
  service.test(new AsyncCallback(){
    public void onFailure(    Throwable caught){
      TestSetValidator.rethrowException(caught);
    }
    public void onSuccess(    Object result){
      finishTest();
    }
  }
);
}","public void testServiceInterfaceLocation(){
  RemoteServiceServletTestServiceAsync service=getAsyncService();
  delayTestFinish(TEST_DELAY);
  req=service.test(new AsyncCallback<Object>(){
    public void onFailure(    Throwable caught){
      TestSetValidator.rethrowException(caught);
    }
    public void onSuccess(    Object result){
      assertTrue(!req.isPending());
      finishTest();
    }
  }
);
  assertTrue(req.isPending());
}"
82836,"public void onSuccess(Object result){
  finishTest();
}","public void onSuccess(Object result){
  assertTrue(!req.isPending());
  finishTest();
}"
82837,void test(AsyncCallback callback);,Request test(AsyncCallback callback);
82838,"/** 
 * This function parses a ""localized"" text into a <code>double</code>. It needs to handle locale specific decimal, grouping, exponent and digit.
 * @param text the text that need to be parsed
 * @param pos in/out parsing position. in case of failure, this shouldn't bechanged
 * @return double value, could be 0.0 if nothing can be parsed
 */
private double parseNumber(String text,int[] pos){
  double ret;
  boolean sawDecimal=false;
  boolean sawExponent=false;
  boolean sawDigit=false;
  int scale=1;
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String exponentChar=numberConstants.exponentialSymbol();
  StringBuffer normalizedText=new StringBuffer();
  for (; pos[0] < text.length(); ++pos[0]) {
    char ch=text.charAt(pos[0]);
    int digit=getDigit(ch);
    if (digit >= 0 && digit <= 9) {
      normalizedText.append((char)(digit + '0'));
      sawDigit=true;
    }
 else     if (ch == decimal.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      normalizedText.append('.');
      sawDecimal=true;
    }
 else     if (ch == grouping.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      continue;
    }
 else     if (ch == exponentChar.charAt(0)) {
      if (sawExponent) {
        break;
      }
      normalizedText.append('E');
      sawExponent=true;
    }
 else     if (ch == '+' || ch == '-') {
      normalizedText.append(ch);
    }
 else     if (ch == numberConstants.percent().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=100;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else     if (ch == numberConstants.perMill().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=1000;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else {
      break;
    }
  }
  try {
    ret=Double.parseDouble(normalizedText.toString());
    ret=ret / scale;
    return ret;
  }
 catch (  NumberFormatException e) {
    return 0.0;
  }
}","/** 
 * This function parses a ""localized"" text into a <code>double</code>. It needs to handle locale specific decimal, grouping, exponent and digit.
 * @param text the text that need to be parsed
 * @param pos in/out parsing position. in case of failure, this shouldn't bechanged
 * @return double value, could be 0.0 if nothing can be parsed
 */
private double parseNumber(String text,int[] pos){
  double ret;
  boolean sawDecimal=false;
  boolean sawExponent=false;
  boolean sawDigit=false;
  int scale=1;
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String exponentChar=numberConstants.exponentialSymbol();
  StringBuffer normalizedText=new StringBuffer();
  for (; pos[0] < text.length(); ++pos[0]) {
    char ch=text.charAt(pos[0]);
    int digit=getDigit(ch);
    if (digit >= 0 && digit <= 9) {
      normalizedText.append((char)(digit + '0'));
      sawDigit=true;
    }
 else     if (ch == decimal.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      normalizedText.append('.');
      sawDecimal=true;
    }
 else     if (ch == grouping.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      continue;
    }
 else     if (ch == exponentChar.charAt(0)) {
      if (sawExponent) {
        break;
      }
      normalizedText.append('E');
      sawExponent=true;
    }
 else     if (ch == '+' || ch == '-') {
      normalizedText.append(ch);
    }
 else     if (ch == numberConstants.percent().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=100;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else     if (ch == numberConstants.perMill().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=1000;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else {
      break;
    }
  }
  ret=Double.parseDouble(normalizedText.toString());
  ret=ret / scale;
  return ret;
}"
82839,"/** 
 * Parses text to produce a numeric value. <p> The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated <code>pos</code> can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of <code>pos</code> is not changed. </p>
 * @param text the string to be parsed
 * @param inOutPos position to pass in and get back
 * @return a double value representing the parsed number, or <code>0.0</code>if the parse fails
 */
public double parse(String text,int[] inOutPos){
  int start=inOutPos[0];
  boolean gotPositive, gotNegative;
  double ret=0.0;
  gotPositive=(text.indexOf(positivePrefix,inOutPos[0]) == inOutPos[0]);
  gotNegative=(text.indexOf(negativePrefix,inOutPos[0]) == inOutPos[0]);
  if (gotPositive && gotNegative) {
    if (positivePrefix.length() > negativePrefix.length()) {
      gotNegative=false;
    }
 else     if (positivePrefix.length() < negativePrefix.length()) {
      gotPositive=false;
    }
  }
  if (gotPositive) {
    inOutPos[0]+=positivePrefix.length();
  }
 else   if (gotNegative) {
    inOutPos[0]+=negativePrefix.length();
  }
  if (text.indexOf(numberConstants.infinity(),inOutPos[0]) == inOutPos[0]) {
    inOutPos[0]+=numberConstants.infinity().length();
    ret=Double.POSITIVE_INFINITY;
  }
 else   if (text.indexOf(numberConstants.notANumber(),inOutPos[0]) == inOutPos[0]) {
    inOutPos[0]+=numberConstants.notANumber().length();
    ret=Double.NaN;
  }
 else {
    ret=parseNumber(text,inOutPos);
  }
  if (gotPositive) {
    if (!(text.indexOf(positiveSuffix,inOutPos[0]) == inOutPos[0])) {
      inOutPos[0]=start;
      return 0.0;
    }
    inOutPos[0]+=positiveSuffix.length();
  }
 else   if (gotNegative) {
    if (!(text.indexOf(negativeSuffix,inOutPos[0]) == inOutPos[0])) {
      inOutPos[0]=start;
      return 0.0;
    }
    inOutPos[0]+=negativeSuffix.length();
  }
  if (gotNegative) {
    ret=-ret;
  }
  return ret;
}","/** 
 * Parses text to produce a numeric value. <p> The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated <code>pos</code> can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of <code>pos</code> is not changed. </p>
 * @param text the string to be parsed
 * @param inOutPos position to pass in and get back
 * @return a double value representing the parsed number, or <code>0.0</code>if the parse fails
 * @throws NumberFormatException if the text segment could not be converted into a number
 */
public double parse(String text,int[] inOutPos) throws NumberFormatException {
  int start=inOutPos[0];
  boolean gotPositive, gotNegative;
  double ret=0.0;
  gotPositive=(text.indexOf(positivePrefix,inOutPos[0]) == inOutPos[0]);
  gotNegative=(text.indexOf(negativePrefix,inOutPos[0]) == inOutPos[0]);
  if (gotPositive && gotNegative) {
    if (positivePrefix.length() > negativePrefix.length()) {
      gotNegative=false;
    }
 else     if (positivePrefix.length() < negativePrefix.length()) {
      gotPositive=false;
    }
  }
  if (gotPositive) {
    inOutPos[0]+=positivePrefix.length();
  }
 else   if (gotNegative) {
    inOutPos[0]+=negativePrefix.length();
  }
  if (text.indexOf(numberConstants.infinity(),inOutPos[0]) == inOutPos[0]) {
    inOutPos[0]+=numberConstants.infinity().length();
    ret=Double.POSITIVE_INFINITY;
  }
 else   if (text.indexOf(numberConstants.notANumber(),inOutPos[0]) == inOutPos[0]) {
    inOutPos[0]+=numberConstants.notANumber().length();
    ret=Double.NaN;
  }
 else {
    ret=parseNumber(text,inOutPos);
  }
  if (gotPositive) {
    if (!(text.indexOf(positiveSuffix,inOutPos[0]) == inOutPos[0])) {
      inOutPos[0]=start;
      return 0.0;
    }
    inOutPos[0]+=positiveSuffix.length();
  }
 else   if (gotNegative) {
    if (!(text.indexOf(negativeSuffix,inOutPos[0]) == inOutPos[0])) {
      inOutPos[0]=start;
      return 0.0;
    }
    inOutPos[0]+=negativeSuffix.length();
  }
  if (gotNegative) {
    ret=-ret;
  }
  return ret;
}"
82840,"public void testBasicParse(){
  Number value;
  value=numberParse(""String_Node_Str"",""String_Node_Str"");
  assertTrue(value.doubleValue() == 123.4579);
  value=numberParse(""String_Node_Str"",""String_Node_Str"");
  assertTrue(value.doubleValue() == 123.4579);
  value=numberParse(""String_Node_Str"",""String_Node_Str"");
  assertTrue(value.doubleValue() == -123.4579);
}","public void testBasicParse(){
  Number value;
  value=numberParse(""String_Node_Str"",""String_Node_Str"");
  assertTrue(value.doubleValue() == 123.4579);
  value=numberParse(""String_Node_Str"",""String_Node_Str"");
  assertTrue(value.doubleValue() == 123.4579);
  value=numberParse(""String_Node_Str"",""String_Node_Str"");
  assertTrue(value.doubleValue() == -123.4579);
  try {
    NumberFormat.getDecimalFormat().parse(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}"
82841,"private JExpression unbox(JExpression toUnbox,JPrimitiveType primitiveType){
  String wrapperTypeName=primitiveType.getWrapperTypeName();
  JClassType wrapperType=(JClassType)program.getFromTypeMap(wrapperTypeName);
  if (wrapperType == null) {
    throw new InternalCompilerException(toUnbox,""String_Node_Str"" + wrapperTypeName + ""String_Node_Str""+ primitiveType.getName()+ ""String_Node_Str"",null);
  }
  return unbox(toUnbox,wrapperType);
}","private JExpression unbox(JExpression toUnbox,JClassType wrapperType){
  JPrimitiveType primitiveType=getPrimitiveTypeForWrapperType(wrapperType);
  if (primitiveType == null) {
    throw new InternalCompilerException(toUnbox,""String_Node_Str"" + wrapperType.getName() + ""String_Node_Str"",null);
  }
  String valueMethodName=primitiveType.getName() + ""String_Node_Str"";
  JMethod valueMethod=null;
  for (  Object element : wrapperType.methods) {
    JMethod method=(JMethod)element;
    if (method.getName().equals(valueMethodName)) {
      if (method.params.isEmpty()) {
        valueMethod=method;
        break;
      }
    }
  }
  if (valueMethod == null) {
    throw new InternalCompilerException(toUnbox,""String_Node_Str"" + wrapperType.getName() + ""String_Node_Str""+ primitiveType.getName()+ ""String_Node_Str""+ valueMethodName+ ""String_Node_Str"",null);
  }
  JMethodCall unboxCall=new JMethodCall(program,toUnbox.getSourceInfo(),toUnbox,valueMethod);
  return unboxCall;
}"
82842,"private JExpression box(JExpression toBox,JPrimitiveType primitiveType){
  String wrapperTypeName=primitiveType.getWrapperTypeName();
  JClassType wrapperType=(JClassType)program.getFromTypeMap(wrapperTypeName);
  if (wrapperType == null) {
    throw new InternalCompilerException(toBox,""String_Node_Str"" + wrapperTypeName + ""String_Node_Str""+ primitiveType.getName()+ ""String_Node_Str"",null);
  }
  return box(toBox,wrapperType);
}","private JExpression box(JExpression toBox,JPrimitiveType primitiveType){
  String wrapperTypeName=primitiveType.getWrapperTypeName();
  JClassType wrapperType=(JClassType)program.getFromTypeMap(wrapperTypeName);
  if (wrapperType == null) {
    throw new InternalCompilerException(toBox,""String_Node_Str"" + wrapperTypeName + ""String_Node_Str""+ primitiveType.getName()+ ""String_Node_Str"",null);
  }
  JMethod valueOfMethod=null;
  for (  JMethod method : wrapperType.methods) {
    if (""String_Node_Str"".equals(method.getName())) {
      if (method.params.size() == 1) {
        JParameter param=method.params.get(0);
        if (param.getType() == primitiveType) {
          valueOfMethod=method;
          break;
        }
      }
    }
  }
  if (valueOfMethod == null || !valueOfMethod.isStatic() || valueOfMethod.getType() != wrapperType) {
    throw new InternalCompilerException(toBox,""String_Node_Str"" + wrapperType.getName() + ""String_Node_Str""+ wrapperType.getName()+ ""String_Node_Str""+ primitiveType.getName()+ ""String_Node_Str"",null);
  }
  JMethodCall call=new JMethodCall(program,toBox.getSourceInfo(),null,valueOfMethod);
  call.getArgs().add(toBox);
  return call;
}"
82843,"public void testBoxing(){
  List<Integer> items=Arrays.asList(1,2,3,4,5);
  List<Integer> out=new ArrayList<Integer>();
  for (  int i : items) {
    out.add(i);
  }
  assertTrue(out.equals(items));
  int[] unboxedItems=new int[]{1,2,3,4,5};
  out.clear();
  for (  Integer i : unboxedItems) {
    out.add(i);
  }
  for (int i=0; i < 5; ++i) {
    assertTrue(out.get(i).intValue() == unboxedItems[i]);
  }
}","public void testBoxing(){
  List<Integer> items=Arrays.asList(1,2,3,4,5);
  List<Integer> out=new ArrayList<Integer>();
  for (  int i : items) {
    out.add(i);
  }
  assertTrue(out.equals(items));
  List<Long> itemsL=Arrays.asList(1L,2L,3L,4L,5L);
  List<Long> outL=new ArrayList<Long>();
  for (  long l : items) {
    outL.add(l);
  }
  assertTrue(outL.equals(itemsL));
  int[] unboxedItems=new int[]{1,2,3,4,5};
  out.clear();
  for (  Integer i : unboxedItems) {
    out.add(i);
  }
  for (int i=0; i < 5; ++i) {
    assertTrue(out.get(i).intValue() == unboxedItems[i]);
  }
}"
82844,"public void freezeParamTypes(){
  if (originalParamTypes != null) {
    throw new InternalCompilerException(""String_Node_Str"");
  }
  originalParamTypes=new ArrayList<JType>();
  for (int i=0; i < params.size(); ++i) {
    JParameter param=params.get(i);
    originalParamTypes.add(param.getType());
  }
}","public void freezeParamTypes(){
  if (originalParamTypes != null) {
    throw new InternalCompilerException(""String_Node_Str"");
  }
  originalParamTypes=new ArrayList<JType>();
  for (int i=0; i < params.size(); ++i) {
    JParameter param=params.get(i);
    originalParamTypes.add(param.getType());
  }
  if (enclosingType != null) {
    String jsniSig=JProgram.getJsniSig(this);
    Set<String> set=JProgram.traceMethods.get(enclosingType.getName());
    if (set != null && (set.contains(name) || set.contains(jsniSig))) {
      trace=true;
    }
    if (!trace && enclosingType != null) {
      set=JProgram.traceMethods.get(enclosingType.getShortName());
      if (set != null && (set.contains(name) || set.contains(jsniSig))) {
        trace=true;
      }
    }
  }
}"
82845,"public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    visitor.accept(params);
    if (body != null) {
      body=(JAbstractMethodBody)visitor.accept(body);
    }
  }
  visitor.endVisit(this,ctx);
}","public void traverse(JVisitor visitor,Context ctx){
  String before=null;
  if (trace && visitor instanceof JModVisitor) {
    before=this.toSource();
    if (traceFirst) {
      traceFirst=false;
      trace(""String_Node_Str"",before);
    }
  }
  if (visitor.visit(this,ctx)) {
    visitor.accept(params);
    if (body != null) {
      body=(JAbstractMethodBody)visitor.accept(body);
    }
  }
  visitor.endVisit(this,ctx);
  if (trace && visitor instanceof JModVisitor) {
    String after=this.toSource();
    if (!after.equals(before)) {
      String title=visitor.getClass().getSimpleName();
      trace(title,after);
    }
  }
}"
82846,"public void putStaticImpl(JMethod method,JMethod staticImpl){
  instanceToStaticMap.put(method,staticImpl);
  staticToInstanceMap.put(staticImpl,method);
}","public void putStaticImpl(JMethod method,JMethod staticImpl){
  instanceToStaticMap.put(method,staticImpl);
  staticToInstanceMap.put(staticImpl,method);
  staticImpl.copyTraceStatusFrom(method);
}"
82847,"private HasEnclosingType parseJsniRef(SourceInfo info,String ident){
  String[] parts=ident.substring(1).split(""String_Node_Str"");
  assert(parts.length == 2);
  String className=parts[0];
  JReferenceType type=null;
  if (!className.equals(""String_Node_Str"")) {
    type=program.getFromTypeMap(className);
    if (type == null) {
      reportJsniError(info,methodDecl,""String_Node_Str"" + className + ""String_Node_Str"");
      return null;
    }
  }
  String rhs=parts[1];
  int parenPos=rhs.indexOf('(');
  if (parenPos < 0) {
    if (type == null) {
      if (rhs.equals(""String_Node_Str"")) {
        return program.getNullField();
      }
    }
 else {
      for (int i=0; i < type.fields.size(); ++i) {
        JField field=type.fields.get(i);
        if (field.getName().equals(rhs)) {
          return field;
        }
      }
    }
    reportJsniError(info,methodDecl,""String_Node_Str"" + rhs + ""String_Node_Str""+ className+ ""String_Node_Str"");
  }
 else {
    String almostMatches=null;
    String methodName=rhs.substring(0,parenPos);
    if (type == null) {
      if (rhs.equals(""String_Node_Str"")) {
        return program.getNullMethod();
      }
    }
 else {
      for (int i=0; i < type.methods.size(); ++i) {
        JMethod method=type.methods.get(i);
        if (method.getName().equals(methodName)) {
          String jsniSig=getJsniSig(method);
          if (jsniSig.equals(rhs)) {
            return method;
          }
 else           if (almostMatches == null) {
            almostMatches=""String_Node_Str"" + jsniSig + ""String_Node_Str"";
          }
 else {
            almostMatches+=""String_Node_Str"" + jsniSig + ""String_Node_Str"";
          }
        }
      }
    }
    if (almostMatches == null) {
      reportJsniError(info,methodDecl,""String_Node_Str"" + methodName + ""String_Node_Str""+ className+ ""String_Node_Str"");
    }
 else {
      reportJsniError(info,methodDecl,""String_Node_Str"" + methodName + ""String_Node_Str""+ className+ ""String_Node_Str""+ almostMatches+ ""String_Node_Str"");
    }
  }
  return null;
}","private HasEnclosingType parseJsniRef(SourceInfo info,String ident){
  String[] parts=ident.substring(1).split(""String_Node_Str"");
  assert(parts.length == 2);
  String className=parts[0];
  JReferenceType type=null;
  if (!className.equals(""String_Node_Str"")) {
    type=program.getFromTypeMap(className);
    if (type == null) {
      reportJsniError(info,methodDecl,""String_Node_Str"" + className + ""String_Node_Str"");
      return null;
    }
  }
  String rhs=parts[1];
  int parenPos=rhs.indexOf('(');
  if (parenPos < 0) {
    if (type == null) {
      if (rhs.equals(""String_Node_Str"")) {
        return program.getNullField();
      }
    }
 else {
      for (int i=0; i < type.fields.size(); ++i) {
        JField field=type.fields.get(i);
        if (field.getName().equals(rhs)) {
          return field;
        }
      }
    }
    reportJsniError(info,methodDecl,""String_Node_Str"" + rhs + ""String_Node_Str""+ className+ ""String_Node_Str"");
  }
 else {
    String almostMatches=null;
    String methodName=rhs.substring(0,parenPos);
    if (type == null) {
      if (rhs.equals(""String_Node_Str"")) {
        return program.getNullMethod();
      }
    }
 else {
      for (int i=0; i < type.methods.size(); ++i) {
        JMethod method=type.methods.get(i);
        if (method.getName().equals(methodName)) {
          String jsniSig=JProgram.getJsniSig(method);
          if (jsniSig.equals(rhs)) {
            return method;
          }
 else           if (almostMatches == null) {
            almostMatches=""String_Node_Str"" + jsniSig + ""String_Node_Str"";
          }
 else {
            almostMatches+=""String_Node_Str"" + jsniSig + ""String_Node_Str"";
          }
        }
      }
    }
    if (almostMatches == null) {
      reportJsniError(info,methodDecl,""String_Node_Str"" + methodName + ""String_Node_Str""+ className+ ""String_Node_Str"");
    }
 else {
      reportJsniError(info,methodDecl,""String_Node_Str"" + methodName + ""String_Node_Str""+ className+ ""String_Node_Str""+ almostMatches+ ""String_Node_Str"");
    }
  }
  return null;
}"
82848,"@Override public void process(CompilationUnitDeclaration cud,int index){
  long processBeginNanos=System.nanoTime();
  if (!cachePolicy.shouldProcess(cud)) {
    jdtProcessNanos+=System.nanoTime() - processBeginNanos;
    return;
  }
{
    this.parser.getMethodBodies(cud);
    if (cud.scope != null) {
      cud.scope.faultInTypes();
    }
    if (cud.scope != null) {
      cud.scope.verifyMethods(lookupEnvironment.methodVerifier());
    }
    cud.resolve();
    cud.analyseCode();
    if (doGenerateBytes) {
      cud.generateCode();
    }
    if (options.produceReferenceInfo && cud.scope != null) {
      cud.scope.storeDependencyInfo();
    }
    cud.compilationResult.totalUnitsKnown=totalUnits;
  }
  ICompilationUnit cu=cud.compilationResult.compilationUnit;
  String loc=String.valueOf(cu.getFileName());
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + loc,null);
  String[] typeNames=doFindAdditionalTypesUsingJsni(logger,cud);
  for (int i=0; i < typeNames.length; i++) {
    String typeName=typeNames[i];
    final String msg=""String_Node_Str"" + typeName + ""String_Node_Str"";
    logger.log(TreeLogger.SPAM,msg,null);
    resolvePossiblyNestedType(typeName);
  }
  typeNames=doFindAdditionalTypesUsingRebinds(logger,cud);
  for (int i=0; i < typeNames.length; i++) {
    String typeName=typeNames[i];
    final String msg=""String_Node_Str"" + typeName + ""String_Node_Str"";
    logger.log(TreeLogger.SPAM,msg,null);
    resolvePossiblyNestedType(typeName);
  }
  JSORestrictionsChecker.check(cud);
  if (cuds != null) {
    cuds.add(cud);
  }
  jdtProcessNanos+=System.nanoTime() - processBeginNanos;
}","@Override public void process(CompilationUnitDeclaration cud,int index){
  long processBeginNanos=System.nanoTime();
  if (!cachePolicy.shouldProcess(cud)) {
    jdtProcessNanos+=System.nanoTime() - processBeginNanos;
    return;
  }
{
    this.parser.getMethodBodies(cud);
    if (cud.scope != null) {
      cud.scope.faultInTypes();
    }
    if (cud.scope != null) {
      cud.scope.verifyMethods(lookupEnvironment.methodVerifier());
    }
    cud.resolve();
    cud.analyseCode();
    if (doGenerateBytes) {
      cud.generateCode();
    }
    if (options.produceReferenceInfo && cud.scope != null) {
      cud.scope.storeDependencyInfo();
    }
    cud.compilationResult.totalUnitsKnown=totalUnits;
  }
  ICompilationUnit cu=cud.compilationResult.compilationUnit;
  String loc=String.valueOf(cu.getFileName());
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + loc,null);
  String[] typeNames=doFindAdditionalTypesUsingJsni(logger,cud);
  for (int i=0; i < typeNames.length; i++) {
    String typeName=typeNames[i];
    final String msg=""String_Node_Str"" + typeName + ""String_Node_Str"";
    logger.log(TreeLogger.SPAM,msg,null);
    resolvePossiblyNestedType(typeName);
  }
  typeNames=doFindAdditionalTypesUsingRebinds(logger,cud);
  for (int i=0; i < typeNames.length; i++) {
    String typeName=typeNames[i];
    final String msg=""String_Node_Str"" + typeName + ""String_Node_Str"";
    logger.log(TreeLogger.SPAM,msg,null);
    resolvePossiblyNestedType(typeName);
  }
  JSORestrictionsChecker.check(cud);
  BinaryTypeReferenceRestrictionsChecker.check(cud);
  if (cuds != null) {
    cuds.add(cud);
  }
  jdtProcessNanos+=System.nanoTime() - processBeginNanos;
}"
82849,"private void maybeDispatch(Scope referencedFrom,TypeBinding binding){
  if (binding instanceof SourceTypeBinding) {
    SourceTypeBinding type=(SourceTypeBinding)binding;
    CompilationUnitScope from=findUnitScope(referencedFrom);
    onTypeRef(type,from.referenceContext);
  }
 else   if (binding instanceof ArrayBinding) {
    maybeDispatch(referencedFrom,((ArrayBinding)binding).leafComponentType);
  }
 else {
  }
}","private void maybeDispatch(Scope referencedFrom,Expression expression,TypeBinding binding){
  if (binding instanceof SourceTypeBinding) {
    SourceTypeBinding type=(SourceTypeBinding)binding;
    CompilationUnitScope from=findUnitScope(referencedFrom);
    onTypeRef(type,from.referenceContext);
  }
 else   if (binding instanceof ArrayBinding) {
    maybeDispatch(referencedFrom,expression,((ArrayBinding)binding).leafComponentType);
  }
 else   if (binding instanceof BinaryTypeBinding) {
    CompilationUnitScope from=findUnitScope(referencedFrom);
    onBinaryTypeRef((BinaryTypeBinding)binding,from.referenceContext,expression);
  }
 else {
  }
}"
82850,"@Override public void endVisit(Wildcard x,ClassScope scope){
  maybeDispatch(scope,x.resolvedType);
}","@Override public void endVisit(Wildcard x,ClassScope scope){
  maybeDispatch(scope,x,x.resolvedType);
}"
82851,"/** 
 * Add a checkpoint message to the current test. If this test fails, all checkpoint messages will be appended to the getException description. This can be useful in web mode for determining how far test execution progressed before a failure occurs.
 * @param msg the checkpoint message to add
 * @deprecated This method will be removed when web mode supports stacktraces. It can be useful for debugging web mode failures, but production code should not depend on it.
 */
public final void addCheckpoint(String msg){
}","/** 
 * Add a checkpoint message to the current test. If this test fails, all checkpoint messages will be appended to the getException description. This can be useful in web mode for determining how far test execution progressed before a failure occurs.
 * @param msg the checkpoint message to add
 * @deprecated This method will be removed when web mode supports stacktraces. It can be useful for debugging web mode failures, but production code should not depend on it.
 */
@Deprecated public final void addCheckpoint(String msg){
}"
82852,"/** 
 * Clears the accumulated list of checkpoint messages.
 * @see #addCheckpoint(String)
 * @deprecated This method will be removed when web mode supports stacktraces. It can be useful for debugging web mode failures, but production code should not depend on it.
 */
public final void clearCheckpoints(){
}","/** 
 * Clears the accumulated list of checkpoint messages.
 * @see #addCheckpoint(String)
 * @deprecated This method will be removed when web mode supports stacktraces. It can be useful for debugging web mode failures, but production code should not depend on it.
 */
@Deprecated public final void clearCheckpoints(){
}"
82853,"/** 
 * Returns the current set of checkpoint messages.
 * @return a non-<code>null</code> array of checkpoint messages
 * @see #addCheckpoint(String)
 * @deprecated This method will be removed when web mode supports stacktraces. It can be useful for debugging web mode failures, but production code should not depend on it.
 */
public final String[] getCheckpoints(){
  return null;
}","/** 
 * Returns the current set of checkpoint messages.
 * @return a non-<code>null</code> array of checkpoint messages
 * @see #addCheckpoint(String)
 * @deprecated This method will be removed when web mode supports stacktraces. It can be useful for debugging web mode failures, but production code should not depend on it.
 */
@Deprecated public final String[] getCheckpoints(){
  return null;
}"
82854,"/** 
 * Creates an empty absolute panel.
 */
public AbsolutePanel(){
  setElement(DOM.createDiv());
  DOM.setStyleAttribute(getElement(),""String_Node_Str"",""String_Node_Str"");
  DOM.setStyleAttribute(getElement(),""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Creates an AbsolutePanel with the given element. This is package-protected so that it can be used by   {@link RootPanel}.
 * @param elem the element to be used for this panel
 */
AbsolutePanel(Element elem){
  setElement(elem);
  DOM.setStyleAttribute(getElement(),""String_Node_Str"",""String_Node_Str"");
  DOM.setStyleAttribute(getElement(),""String_Node_Str"",""String_Node_Str"");
}"
82855,"@Override protected void onAttach(){
  widget.onAttach();
  onLoad();
}","@Override protected void onAttach(){
  widget.onAttach();
  DOM.setEventListener(getElement(),this);
  onLoad();
}"
82856,"ClippedState(Image image,String url,int left,int top,int width,int height){
  this.left=left;
  this.top=top;
  this.width=width;
  this.height=height;
  this.url=url;
  image.setElement(impl.createStructure(url,left,top,width,height));
  image.sinkEvents(Event.ONCLICK | Event.MOUSEEVENTS | Event.ONMOUSEWHEEL);
  fireSyntheticLoadEvent(image);
}","ClippedState(Image image,String url,int left,int top,int width,int height){
  this.left=left;
  this.top=top;
  this.width=width;
  this.height=height;
  this.url=url;
  image.replaceElement(impl.createStructure(url,left,top,width,height));
  image.sinkEvents(Event.ONCLICK | Event.MOUSEEVENTS | Event.ONMOUSEWHEEL);
  fireSyntheticLoadEvent(image);
}"
82857,"/** 
 * Constructs a frame with the given name.
 * @param name the name of the frame, which must contain at least onenon-whitespace character and must not contain reserved HTML markup characters such as '<code>&lt;</code>', '<code>&gt;</code>', or '<code>&amp;</code>'
 * @throws IllegalArgumentException if the supplied name is not allowed 
 */
public NamedFrame(String name){
  if (name == null || !isValidName(name.trim())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Element div=DOM.createDiv();
  DOM.setInnerHTML(div,""String_Node_Str"" + name + ""String_Node_Str"");
  Element iframe=DOM.getFirstChild(div);
  setElement(iframe);
}","/** 
 * Constructs a frame with the given name.
 * @param name the name of the frame, which must contain at least onenon-whitespace character and must not contain reserved HTML markup characters such as '<code>&lt;</code>', '<code>&gt;</code>', or '<code>&amp;</code>'
 * @throws IllegalArgumentException if the supplied name is not allowed 
 */
public NamedFrame(String name){
  if (name == null || !isValidName(name.trim())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Element div=DOM.createDiv();
  DOM.setInnerHTML(div,""String_Node_Str"" + name + ""String_Node_Str"");
  Element iframe=DOM.getFirstChild(div);
  replaceElement(iframe);
}"
82858,"/** 
 * Gets the root panel associated with a given browser element. For this to work, the HTML document into which the application is loaded must have specified an element with the given id.
 * @param id the id of the element to be wrapped with a root panel
 * @return the root panel, or <code>null</code> if no such element was found
 */
public static RootPanel get(String id){
  RootPanel gwt=rootPanels.get(id);
  if (gwt != null) {
    return gwt;
  }
  Element elem=null;
  if (id != null) {
    if (null == (elem=DOM.getElementById(id))) {
      return null;
    }
  }
  if (rootPanels.size() == 0) {
    hookWindowClosing();
  }
  rootPanels.put(id,gwt=new RootPanel(elem));
  return gwt;
}","/** 
 * Gets the root panel associated with a given browser element. For this to work, the HTML document into which the application is loaded must have specified an element with the given id.
 * @param id the id of the element to be wrapped with a root panel
 * @return the root panel, or <code>null</code> if no such element was found
 */
public static RootPanel get(String id){
  RootPanel rp=rootPanels.get(id);
  if (rp != null) {
    return rp;
  }
  Element elem=null;
  if (id != null) {
    if (null == (elem=DOM.getElementById(id))) {
      return null;
    }
  }
  if (rootPanels.size() == 0) {
    hookWindowClosing();
  }
  if (elem == null) {
    elem=getBodyElement();
  }
  rootPanels.put(id,rp=new RootPanel(elem));
  return rp;
}"
82859,"private RootPanel(Element elem){
  if (elem == null) {
    elem=getBodyElement();
  }
  setElement(elem);
  onAttach();
}","private RootPanel(Element elem){
  super(elem);
  onAttach();
}"
82860,"/** 
 * Gets the object's offset width in pixels. This is the total width of the object, including decorations such as border, margin, and padding.
 * @return the object's offset width
 */
public int getOffsetWidth(){
  return DOM.getElementPropertyInt(element,""String_Node_Str"");
}","/** 
 * Gets the object's offset width in pixels. This is the total width of the object, including decorations such as border, margin, and padding.
 * @return the object's offset width
 */
public int getOffsetWidth(){
  return DOM.getElementPropertyInt(getElement(),""String_Node_Str"");
}"
82861,"/** 
 * Gets the title associated with this object. The title is the 'tool-tip' displayed to users when they hover over the object.
 * @return the object's title
 */
public String getTitle(){
  return DOM.getElementProperty(element,""String_Node_Str"");
}","/** 
 * Gets the title associated with this object. The title is the 'tool-tip' displayed to users when they hover over the object.
 * @return the object's title
 */
public String getTitle(){
  return DOM.getElementProperty(getElement(),""String_Node_Str"");
}"
82862,"/** 
 * Sets this object's browser element. UIObject subclasses must call this method before attempting to call any other methods. If the browser element has already been set, then the current element's position is located in the DOM and removed. The new element is added into the previous element's position.
 * @param elem the object's new element
 */
protected void setElement(Element elem){
  if (this.element != null) {
    replaceNode(this.element,elem);
  }
  this.element=elem;
}","/** 
 * Sets this object's browser element. UIObject subclasses must call this method before attempting to call any other methods, and it may only be called once.
 * @param elem the object's element
 */
protected void setElement(Element elem){
}"
82863,"/** 
 * Sets whether this object is visible.
 * @param visible <code>true</code> to show the object, <code>false</code>to hide it
 */
public void setVisible(boolean visible){
  setVisible(element,visible);
}","/** 
 * Sets whether this object is visible.
 * @param visible <code>true</code> to show the object, <code>false</code>to hide it
 */
public void setVisible(boolean visible){
  setVisible(getElement(),visible);
}"
82864,"/** 
 * Sets the title associated with this object. The title is the 'tool-tip' displayed to users when they hover over the object.
 * @param title the object's new title
 */
public void setTitle(String title){
  if (title == null || title.length() == 0) {
    DOM.removeElementAttribute(element,""String_Node_Str"");
  }
 else {
    DOM.setElementAttribute(element,""String_Node_Str"",title);
  }
}","/** 
 * Sets the title associated with this object. The title is the 'tool-tip' displayed to users when they hover over the object.
 * @param title the object's new title
 */
public void setTitle(String title){
  if (title == null || title.length() == 0) {
    DOM.removeElementAttribute(getElement(),""String_Node_Str"");
  }
 else {
    DOM.setElementAttribute(getElement(),""String_Node_Str"",title);
  }
}"
82865,"/** 
 * Template method that returns the element to which style names will be applied. By default it returns the root element, but this method may be overridden to apply styles to a child element.
 * @return the element to which style names will be applied
 */
protected Element getStyleElement(){
  return element;
}","/** 
 * Template method that returns the element to which style names will be applied. By default it returns the root element, but this method may be overridden to apply styles to a child element.
 * @return the element to which style names will be applied
 */
protected Element getStyleElement(){
  return getElement();
}"
82866,"/** 
 * Determines whether or not this object is visible.
 * @return <code>true</code> if the object is visible
 */
public boolean isVisible(){
  return isVisible(element);
}","/** 
 * Determines whether or not this object is visible.
 * @return <code>true</code> if the object is visible
 */
public boolean isVisible(){
  return isVisible(getElement());
}"
82867,"/** 
 * Gets the object's offset height in pixels. This is the total height of the object, including decorations such as border, margin, and padding.
 * @return the object's offset height
 */
public int getOffsetHeight(){
  return DOM.getElementPropertyInt(element,""String_Node_Str"");
}","/** 
 * Gets the object's offset height in pixels. This is the total height of the object, including decorations such as border, margin, and padding.
 * @return the object's offset height
 */
public int getOffsetHeight(){
  return DOM.getElementPropertyInt(getElement(),""String_Node_Str"");
}"
82868,"/** 
 * Gets a handle to the object's underlying DOM element.
 * @return the object's browser element
 */
public Element getElement(){
  return element;
}","/** 
 * Gets a handle to the object's underlying DOM element. This method should not be overridden. It is non-final solely to support legacy code that depends upon overriding it. If it is overridden, the subclass implementation must not return a different element than was previously set using   {@link #setElement(Element)}.
 * @return the object's browser element
 */
public Element getElement(){
}"
82869,"/** 
 * This method is overridden so that any object can be viewed in the debugger as an HTML snippet.
 * @return a string representation of the object
 */
@Override public String toString(){
  if (element == null) {
    return ""String_Node_Str"";
  }
  return DOM.toString(element);
}","/** 
 * This method is overridden so that any object can be viewed in the debugger as an HTML snippet.
 * @return a string representation of the object
 */
@Override public String toString(){
  if (getElement() == null) {
    return ""String_Node_Str"";
  }
  return DOM.toString(getElement());
}"
82870,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TitledPanelTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TitledPanelTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  return suite;
}"
82871,"private BufferedImage drawBundledImage(){
  SortedMap<String,ImageRect> sortedImageNameToImageRectMap=new TreeMap<String,ImageRect>();
  sortedImageNameToImageRectMap.putAll(imageNameToImageRectMap);
  Collection<ImageRect> orderedImageRects=sortedImageNameToImageRectMap.values();
  int nextLeft=0;
  int maxHeight=0;
  for (  ImageRect imageRect : orderedImageRects) {
    imageRect.left=nextLeft;
    nextLeft+=imageRect.width;
    if (imageRect.height > maxHeight) {
      maxHeight=imageRect.height;
    }
  }
  BufferedImage bundledImage=new BufferedImage(nextLeft,maxHeight,BufferedImage.TYPE_INT_ARGB_PRE);
  Graphics2D g2d=bundledImage.createGraphics();
  for (  ImageRect imageRect : orderedImageRects) {
    g2d.drawImage(imageRect.image,imageRect.left,0,null);
  }
  g2d.dispose();
  return bundledImage;
}","/** 
 * This method creates the bundled image through the composition of the other images. In this particular implementation, we use NFDHDW (see  {@link #arrangeImages()}) to get an approximate optimal image packing. The most important aspect of drawing the bundled image is that it be drawn in a deterministic way. The drawing of the image should not rely on implementation details of the Generator system which may be subject to change.
 */
private BufferedImage drawBundledImage(){
  Collection<ImageRect> imageRects=imageNameToImageRectMap.values();
  final Size size=arrangeImages(imageRects);
  BufferedImage bundledImage=new BufferedImage(size.width,size.height,BufferedImage.TYPE_INT_ARGB_PRE);
  Graphics2D g2d=bundledImage.createGraphics();
  for (  ImageRect imageRect : imageRects) {
    g2d.drawImage(imageRect.image,imageRect.left,imageRect.top,null);
  }
  g2d.dispose();
  return bundledImage;
}"
82872,"public ImageRect(BufferedImage image){
  this.image=image;
  this.width=image.getWidth();
  this.height=image.getHeight();
}","public ImageRect(String name,BufferedImage image){
  this.name=name;
  this.image=image;
  this.width=image.getWidth();
  this.height=image.getHeight();
}"
82873,"private ImageRect addImage(TreeLogger logger,String imageName) throws UnableToCompleteException {
  logger=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + imageName + ""String_Node_Str"",null);
  try {
    URL imageUrl=getClass().getClassLoader().getResource(imageName);
    if (imageUrl == null) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"",null);
      throw new UnableToCompleteException();
    }
    BufferedImage image;
    try {
      image=ImageIO.read(imageUrl);
    }
 catch (    IllegalArgumentException iex) {
      if (imageName.toLowerCase().endsWith(""String_Node_Str"") && iex.getMessage() != null && iex.getStackTrace()[0].getClassName().equals(""String_Node_Str"")) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
        throw new UnableToCompleteException();
      }
 else {
        throw iex;
      }
    }
    if (image == null) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",null);
      throw new UnableToCompleteException();
    }
    return new ImageRect(image);
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",null);
    throw new UnableToCompleteException();
  }
}","private ImageRect addImage(TreeLogger logger,String imageName) throws UnableToCompleteException {
  logger=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + imageName + ""String_Node_Str"",null);
  try {
    URL imageUrl=getClass().getClassLoader().getResource(imageName);
    if (imageUrl == null) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"",null);
      throw new UnableToCompleteException();
    }
    BufferedImage image;
    try {
      image=ImageIO.read(imageUrl);
    }
 catch (    IllegalArgumentException iex) {
      if (imageName.toLowerCase().endsWith(""String_Node_Str"") && iex.getMessage() != null && iex.getStackTrace()[0].getClassName().equals(""String_Node_Str"")) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
        throw new UnableToCompleteException();
      }
 else {
        throw iex;
      }
    }
    if (image == null) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",null);
      throw new UnableToCompleteException();
    }
    return new ImageRect(imageName,image);
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",null);
    throw new UnableToCompleteException();
  }
}"
82874,"private void generateImageMethod(TreeLogger logger,ImageBundleBuilder compositeImage,SourceWriter sw,JMethod method,String imgResName) throws UnableToCompleteException {
  String decl=method.getReadableDeclaration(false,true,true,true,true);
{
    sw.indent();
    ImageBundleBuilder.ImageRect imageRect=compositeImage.getMapping(imgResName);
    String singletonName=method.getName() + ""String_Node_Str"";
    sw.print(""String_Node_Str"");
    sw.print(singletonName);
    sw.print(""String_Node_Str"");
    sw.print(Integer.toString(imageRect.left));
    sw.print(""String_Node_Str"");
    sw.print(Integer.toString(imageRect.width));
    sw.print(""String_Node_Str"");
    sw.print(Integer.toString(imageRect.height));
    sw.println(""String_Node_Str"");
    sw.print(decl);
    sw.println(""String_Node_Str"");
{
      sw.indent();
      sw.print(""String_Node_Str"");
      sw.print(singletonName);
      sw.println(""String_Node_Str"");
      sw.outdent();
    }
    sw.println(""String_Node_Str"");
    sw.outdent();
  }
}","private void generateImageMethod(TreeLogger logger,ImageBundleBuilder compositeImage,SourceWriter sw,JMethod method,String imgResName) throws UnableToCompleteException {
  String decl=method.getReadableDeclaration(false,true,true,true,true);
{
    sw.indent();
    ImageBundleBuilder.ImageRect imageRect=compositeImage.getMapping(imgResName);
    String singletonName=method.getName() + ""String_Node_Str"";
    sw.print(""String_Node_Str"");
    sw.print(singletonName);
    sw.print(""String_Node_Str"");
    sw.print(Integer.toString(imageRect.getLeft()));
    sw.print(""String_Node_Str"");
    sw.print(Integer.toString(imageRect.getTop()));
    sw.print(""String_Node_Str"");
    sw.print(Integer.toString(imageRect.getWidth()));
    sw.print(""String_Node_Str"");
    sw.print(Integer.toString(imageRect.getHeight()));
    sw.println(""String_Node_Str"");
    sw.print(decl);
    sw.println(""String_Node_Str"");
{
      sw.indent();
      sw.print(""String_Node_Str"");
      sw.print(singletonName);
      sw.println(""String_Node_Str"");
      sw.outdent();
    }
    sw.println(""String_Node_Str"");
    sw.outdent();
  }
}"
82875,"/** 
 * Removes the specified menu item from the bar.
 * @param item the item to be removed
 */
public void removeItem(MenuItem item){
  if (removeItemElement(item)) {
    setItemColSpan(item,1);
    items.remove(item);
    item.setParentMenu(null);
  }
}","/** 
 * Removes the specified menu item from the bar.
 * @param item the item to be removed
 */
public void removeItem(MenuItem item){
  if (selectedItem == item) {
    selectItem(null);
  }
  if (removeItemElement(item)) {
    setItemColSpan(item,1);
    items.remove(item);
    item.setParentMenu(null);
  }
}"
82876,"/** 
 * Removes all menu items from this menu bar.
 */
public void clearItems(){
  Element container=getItemContainerElement();
  while (DOM.getChildCount(container) > 0) {
    DOM.removeChild(container,DOM.getChild(container,0));
  }
  for (  UIObject item : allItems) {
    setItemColSpan(item,1);
    if (item instanceof MenuItemSeparator) {
      ((MenuItemSeparator)item).setParentMenu(null);
    }
 else {
      ((MenuItem)item).setParentMenu(null);
    }
  }
  items.clear();
  allItems.clear();
}","/** 
 * Removes all menu items from this menu bar.
 */
public void clearItems(){
  selectItem(null);
  Element container=getItemContainerElement();
  while (DOM.getChildCount(container) > 0) {
    DOM.removeChild(container,DOM.getChild(container,0));
  }
  for (  UIObject item : allItems) {
    setItemColSpan(item,1);
    if (item instanceof MenuItemSeparator) {
      ((MenuItemSeparator)item).setParentMenu(null);
    }
 else {
      ((MenuItem)item).setParentMenu(null);
    }
  }
  items.clear();
  allItems.clear();
}"
82877,"public void execute(){
  UIObjectTest.assertDebugIdContents(""String_Node_Str"",""String_Node_Str"");
  UIObjectTest.assertDebugIdContents(""String_Node_Str"",""String_Node_Str"");
  UIObjectTest.assertDebugIdContents(""String_Node_Str"",""String_Node_Str"");
  UIObjectTest.assertDebugIdContents(""String_Node_Str"",""String_Node_Str"");
  UIObjectTest.assertDebugIdContents(""String_Node_Str"",""String_Node_Str"");
  UIObjectTest.assertDebugIdContents(""String_Node_Str"",""String_Node_Str"");
  finishTest();
}","public void execute(){
}"
82878,"/** 
 * Create a parameterized type along with any necessary enclosing parameterized types. Enclosing parameterized types are necessary when the base type is a non-static member and the enclosing type is also generic.
 */
private static JParameterizedType createParameterizedTypeRecursive(JGenericType baseType,Map<JTypeParameter,JClassType> substitutionMap){
  JClassType enclosingType=baseType.getEnclosingType();
  if (baseType.isMemberType() && !baseType.isStatic()) {
    JGenericType isGenericEnclosingType=enclosingType.isGenericType();
    if (isGenericEnclosingType != null) {
      enclosingType=createParameterizedTypeRecursive(isGenericEnclosingType,substitutionMap);
    }
  }
  JTypeParameter[] typeParameters=baseType.getTypeParameters();
  JClassType[] newTypeArgs=new JClassType[typeParameters.length];
  TypeOracle oracle=baseType.getOracle();
  for (int i=0; i < newTypeArgs.length; ++i) {
    JClassType newTypeArg=substitutionMap.get(typeParameters[i]);
    if (newTypeArg == null) {
      newTypeArg=oracle.getWildcardType(true,typeParameters[i].getFirstBound());
    }
    newTypeArgs[i]=newTypeArg;
  }
  JParameterizedType parameterizedType=oracle.getParameterizedType(baseType,enclosingType,newTypeArgs);
  return parameterizedType;
}","/** 
 * Create a parameterized type along with any necessary enclosing parameterized types. Enclosing parameterized types are necessary when the base type is a non-static member and the enclosing type is also generic.
 */
private static JParameterizedType createParameterizedTypeRecursive(JGenericType baseType,Map<JTypeParameter,JClassType> substitutionMap){
  JClassType enclosingType=baseType.getEnclosingType();
  if (baseType.isMemberType() && !baseType.isStatic()) {
    JGenericType isGenericEnclosingType=enclosingType.isGenericType();
    if (isGenericEnclosingType != null) {
      enclosingType=createParameterizedTypeRecursive(isGenericEnclosingType,substitutionMap);
    }
  }
  JTypeParameter[] typeParameters=baseType.getTypeParameters();
  JClassType[] newTypeArgs=new JClassType[typeParameters.length];
  TypeOracle oracle=baseType.getOracle();
  for (int i=0; i < newTypeArgs.length; ++i) {
    JClassType newTypeArg=substitutionMap.get(typeParameters[i]);
    if (newTypeArg == null) {
      newTypeArg=oracle.getWildcardType(BoundType.EXTENDS,typeParameters[i].getFirstBound());
    }
    newTypeArgs[i]=newTypeArg;
  }
  JParameterizedType parameterizedType=oracle.getParameterizedType(baseType,enclosingType,newTypeArgs);
  return parameterizedType;
}"
82879,"/** 
 * Returns the lower bounds of this wildcard type. If no lower bounds were declared, an empty array is returned.
 * @return the lower bounds of this wildcard type
 */
public JClassType[] getLowerBounds(){
  if (lazyLowerBounds == null) {
    if (isUpperBound) {
      lazyLowerBounds=TypeOracle.NO_JCLASSES;
    }
 else {
      lazyLowerBounds=new JClassType[]{getFirstBound()};
    }
  }
  return lazyLowerBounds;
}","/** 
 * Returns the lower bounds of this wildcard type. If no lower bounds were declared, an empty array is returned.
 * @return the lower bounds of this wildcard type
 */
public JClassType[] getLowerBounds(){
  if (lazyLowerBounds == null) {
    if (isUpperBound()) {
      lazyLowerBounds=TypeOracle.NO_JCLASSES;
    }
 else {
      lazyLowerBounds=new JClassType[]{getFirstBound()};
    }
  }
  return lazyLowerBounds;
}"
82880,"@Override JClassType getSubstitutedType(JParameterizedType parameterizedType){
  return getOracle().getWildcardType(isUpperBound,getFirstBound().getSubstitutedType(parameterizedType));
}","@Override JClassType getSubstitutedType(JParameterizedType parameterizedType){
  return getOracle().getWildcardType(boundType,getFirstBound().getSubstitutedType(parameterizedType));
}"
82881,"/** 
 * Returns <code>true</code> if this instance has the same bounds that are requested.
 * @param otherWildcard
 * @return <code>true</code> if this instance has the same bounds that arerequested
 */
boolean boundsMatch(JWildcardType otherWildcard){
  return isUpperBound == otherWildcard.isUpperBound && getFirstBound() == otherWildcard.getFirstBound();
}","/** 
 * Returns <code>true</code> if this instance has the same bounds that are requested.
 * @param otherWildcard
 * @return <code>true</code> if this instance has the same bounds that arerequested
 */
boolean boundsMatch(JWildcardType otherWildcard){
  return isUpperBound() == otherWildcard.isUpperBound() && getFirstBound() == otherWildcard.getFirstBound();
}"
82882,"private String toString(boolean simpleName){
  String str=""String_Node_Str"" + (isUpperBound ? ""String_Node_Str"" : ""String_Node_Str"");
  if (simpleName) {
    return str + getFirstBound().getSimpleSourceName();
  }
 else {
    return str + getFirstBound().getParameterizedQualifiedSourceName();
  }
}","private String toString(boolean simpleName){
  String str=""String_Node_Str"";
  if (isUnbound()) {
    return str;
  }
 else {
    str+=(isUpperBound() ? ""String_Node_Str"" : ""String_Node_Str"");
    if (simpleName) {
      return str + getFirstBound().getSimpleSourceName();
    }
 else {
      return str + getFirstBound().getParameterizedQualifiedSourceName();
    }
  }
}"
82883,"public JWildcardType(boolean isUpperBound,JClassType typeBound){
  this.isUpperBound=isUpperBound;
  super.setBaseType(typeBound);
}","public JWildcardType(BoundType boundType,JClassType typeBound){
  this.boundType=boundType;
  super.setBaseType(typeBound);
}"
82884,"@Override public JClassType getErasedType(){
  if (isUpperBound) {
    return getFirstBound().getErasedType();
  }
  return getOracle().getJavaLangObject();
}","@Override public JClassType getErasedType(){
  if (isUpperBound()) {
    return getFirstBound().getErasedType();
  }
  return getOracle().getJavaLangObject();
}"
82885,"@Override public JClassType[] getSubtypes(){
  if (isUpperBound) {
    return getFirstBound().getSubtypes();
  }
  return TypeOracle.NO_JCLASSES;
}","@Override public JClassType[] getSubtypes(){
  if (isUpperBound()) {
    return getFirstBound().getSubtypes();
  }
  return TypeOracle.NO_JCLASSES;
}"
82886,"@Override public JClassType getSuperclass(){
  if (isUpperBound) {
    return getFirstBound();
  }
  return getOracle().getJavaLangObject();
}","@Override public JClassType getSuperclass(){
  if (isUpperBound()) {
    return getFirstBound();
  }
  return getOracle().getJavaLangObject();
}"
82887,"/** 
 * Returns the upper bounds of this wildcard type. If no upper bounds were declared, an array containing   {@link Object} is returned.
 * @return the upper bounds of this wildcard type
 */
public JClassType[] getUpperBounds(){
  if (lazyUpperBounds == null) {
    if (isUpperBound) {
      lazyUpperBounds=new JClassType[]{getFirstBound()};
    }
 else {
      lazyUpperBounds=new JClassType[]{getOracle().getJavaLangObject()};
    }
  }
  return lazyUpperBounds;
}","/** 
 * Returns the upper bounds of this wildcard type. If no upper bounds were declared, an array containing   {@link Object} is returned.
 * @return the upper bounds of this wildcard type
 */
public JClassType[] getUpperBounds(){
  if (lazyUpperBounds == null) {
    if (isUpperBound()) {
      lazyUpperBounds=new JClassType[]{getFirstBound()};
    }
 else {
      lazyUpperBounds=new JClassType[]{getOracle().getJavaLangObject()};
    }
  }
  return lazyUpperBounds;
}"
82888,"public JWildcardType getWildcardType(boolean isUpperBound,JClassType typeBound){
  JWildcardType wildcardType=new JWildcardType(isUpperBound,typeBound);
  String sig=wildcardType.getQualifiedSourceName();
  List<JWildcardType> candidates=wildcardTypes.get(sig);
  if (candidates == null) {
    candidates=new ArrayList<JWildcardType>();
    wildcardTypes.put(sig,candidates);
  }
 else {
    for (    JWildcardType candidate : candidates) {
      if (candidate.boundsMatch(wildcardType)) {
        return candidate;
      }
    }
  }
  candidates.add(wildcardType);
  return wildcardType;
}","public JWildcardType getWildcardType(JWildcardType.BoundType boundType,JClassType typeBound){
  JWildcardType wildcardType=new JWildcardType(boundType,typeBound);
  String sig=wildcardType.getQualifiedSourceName();
  List<JWildcardType> candidates=wildcardTypes.get(sig);
  if (candidates == null) {
    candidates=new ArrayList<JWildcardType>();
    wildcardTypes.put(sig,candidates);
  }
 else {
    for (    JWildcardType candidate : candidates) {
      if (candidate.boundsMatch(wildcardType)) {
        return candidate;
      }
    }
  }
  candidates.add(wildcardType);
  return wildcardType;
}"
82889,"public void testGenericClass_UpperBoundWildcard() throws NotFoundException {
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericType=getGenericTestType();
  JWildcardType upperBoundWildcard=oracle.getWildcardType(true,integerType);
  JClassType type=oracle.getParameterizedType(genericType,new JClassType[]{upperBoundWildcard});
  JParameterizedType parameterizedType=type.isParameterized();
  validateTypeSubstitution(genericType,parameterizedType,new ParameterizedSubstitution(parameterizedType));
}","public void testGenericClass_UpperBoundWildcard() throws NotFoundException {
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericType=getGenericTestType();
  JWildcardType upperBoundWildcard=oracle.getWildcardType(BoundType.EXTENDS,integerType);
  JClassType type=oracle.getParameterizedType(genericType,new JClassType[]{upperBoundWildcard});
  JParameterizedType parameterizedType=type.isParameterized();
  validateTypeSubstitution(genericType,parameterizedType,new ParameterizedSubstitution(parameterizedType));
}"
82890,"/** 
 * Test method for  {@link com.google.gwt.core.ext.typeinfo.JParameterizedType#isAssignableFrom(JClassType)}.
 */
@Override public void testIsAssignableFrom() throws NotFoundException {
  JParameterizedType testType=getTestType();
  JClassType rawType=testType.getRawType();
  assertTrue(testType.isAssignableFrom(rawType));
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericList=(JGenericType)oracle.getType(List.class.getName());
  JWildcardType unboundWildcard=oracle.getWildcardType(true,oracle.getJavaLangObject());
  JWildcardType numUpperBoundWildcard=oracle.getWildcardType(true,oracle.getType(Number.class.getName()));
  JParameterizedType unboundList=oracle.getParameterizedType(genericList,new JClassType[]{unboundWildcard});
  JParameterizedType listOfExtendsNumber=oracle.getParameterizedType(genericList,new JClassType[]{numUpperBoundWildcard});
  assertTrue(unboundList.isAssignableFrom(listOfExtendsNumber));
  assertFalse(unboundList.isAssignableTo(listOfExtendsNumber));
  assertFalse(listOfExtendsNumber.isAssignableFrom(unboundList));
  assertTrue(listOfExtendsNumber.isAssignableTo(unboundList));
  JWildcardType intUpperBoundWildcard=oracle.getWildcardType(true,integerType);
  JParameterizedType listOfExtendsInteger=oracle.getParameterizedType(genericList,new JClassType[]{intUpperBoundWildcard});
  assertTrue(listOfExtendsNumber.isAssignableFrom(listOfExtendsInteger));
  assertFalse(listOfExtendsNumber.isAssignableTo(listOfExtendsInteger));
  assertFalse(listOfExtendsInteger.isAssignableFrom(listOfExtendsNumber));
  assertTrue(listOfExtendsInteger.isAssignableTo(listOfExtendsNumber));
  JWildcardType numLowerBoundWildcard=oracle.getWildcardType(false,oracle.getType(Number.class.getName()));
  JWildcardType intLowerBoundWildcard=oracle.getWildcardType(false,integerType);
  JParameterizedType listOfSuperNumber=oracle.getParameterizedType(genericList,new JClassType[]{numLowerBoundWildcard});
  JParameterizedType listOfSuperInteger=oracle.getParameterizedType(genericList,new JClassType[]{intLowerBoundWildcard});
  assertTrue(listOfSuperInteger.isAssignableFrom(listOfSuperNumber));
  assertFalse(listOfSuperInteger.isAssignableTo(listOfSuperNumber));
  assertFalse(listOfSuperNumber.isAssignableFrom(listOfSuperInteger));
  assertTrue(listOfSuperNumber.isAssignableTo(listOfSuperInteger));
  JParameterizedType listOfObject=oracle.getParameterizedType(genericList,new JClassType[]{oracle.getJavaLangObject()});
  JClassType stringType=oracle.getType(String.class.getName());
  JParameterizedType listOfString=oracle.getParameterizedType(genericList,new JClassType[]{stringType});
  assertFalse(listOfObject.isAssignableFrom(listOfString));
  assertFalse(listOfString.isAssignableFrom(listOfObject));
  JParameterizedType listOfListOfString=oracle.getParameterizedType(genericList,new JClassType[]{listOfString});
  JGenericType genericVector=oracle.getType(Vector.class.getName()).isGenericType();
  JParameterizedType vectorOfString=oracle.getParameterizedType(genericVector,new JClassType[]{stringType});
  JParameterizedType listOfVectorOfString=oracle.getParameterizedType(genericList,new JClassType[]{vectorOfString});
  assertFalse(listOfListOfString.isAssignableFrom(listOfVectorOfString));
  assertFalse(listOfVectorOfString.isAssignableFrom(listOfListOfString));
  JClassType listOfRawList=oracle.getParameterizedType(genericList,new JClassType[]{genericList.getRawType()});
  assertFalse(listOfRawList.isAssignableFrom(listOfListOfString));
  assertFalse(listOfListOfString.isAssignableFrom(listOfRawList));
  JGenericType genericClass=oracle.getType(GenericClass.class.getName()).isGenericType();
  JParameterizedType parameterizedGenericClass=oracle.getParameterizedType(genericClass,new JClassType[]{stringType});
  JClassType extendsRawGenericClass=oracle.getType(ExtendsRawGenericClass.class.getName());
  assertTrue(parameterizedGenericClass.isAssignableFrom(extendsRawGenericClass));
  assertFalse(extendsRawGenericClass.isAssignableFrom(parameterizedGenericClass));
  JClassType listOfListOfExtendsNumber=oracle.getParameterizedType(genericList,new JClassType[]{listOfExtendsNumber});
  JClassType listOfListOfExtendsInteger=oracle.getParameterizedType(genericList,new JClassType[]{listOfExtendsInteger});
  assertFalse(listOfListOfExtendsNumber.isAssignableFrom(listOfListOfExtendsInteger));
  JClassType listOfInteger=oracle.getParameterizedType(genericList,new JClassType[]{integerType});
  assertTrue(listOfExtendsNumber.isAssignableFrom(listOfInteger));
  assertFalse(listOfExtendsNumber.isAssignableFrom(listOfObject));
  assertFalse(listOfSuperNumber.isAssignableFrom(listOfInteger));
  assertTrue(listOfSuperNumber.isAssignableFrom(listOfObject));
}","/** 
 * Test method for  {@link com.google.gwt.core.ext.typeinfo.JParameterizedType#isAssignableFrom(JClassType)}.
 */
@Override public void testIsAssignableFrom() throws NotFoundException {
  JParameterizedType testType=getTestType();
  JClassType rawType=testType.getRawType();
  assertTrue(testType.isAssignableFrom(rawType));
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericList=(JGenericType)oracle.getType(List.class.getName());
  JWildcardType unboundWildcard=oracle.getWildcardType(BoundType.EXTENDS,oracle.getJavaLangObject());
  JWildcardType numUpperBoundWildcard=oracle.getWildcardType(BoundType.EXTENDS,oracle.getType(Number.class.getName()));
  JParameterizedType unboundList=oracle.getParameterizedType(genericList,new JClassType[]{unboundWildcard});
  JParameterizedType listOfExtendsNumber=oracle.getParameterizedType(genericList,new JClassType[]{numUpperBoundWildcard});
  assertTrue(unboundList.isAssignableFrom(listOfExtendsNumber));
  assertFalse(unboundList.isAssignableTo(listOfExtendsNumber));
  assertFalse(listOfExtendsNumber.isAssignableFrom(unboundList));
  assertTrue(listOfExtendsNumber.isAssignableTo(unboundList));
  JWildcardType intUpperBoundWildcard=oracle.getWildcardType(BoundType.EXTENDS,integerType);
  JParameterizedType listOfExtendsInteger=oracle.getParameterizedType(genericList,new JClassType[]{intUpperBoundWildcard});
  assertTrue(listOfExtendsNumber.isAssignableFrom(listOfExtendsInteger));
  assertFalse(listOfExtendsNumber.isAssignableTo(listOfExtendsInteger));
  assertFalse(listOfExtendsInteger.isAssignableFrom(listOfExtendsNumber));
  assertTrue(listOfExtendsInteger.isAssignableTo(listOfExtendsNumber));
  JWildcardType numLowerBoundWildcard=oracle.getWildcardType(BoundType.SUPER,oracle.getType(Number.class.getName()));
  JWildcardType intLowerBoundWildcard=oracle.getWildcardType(BoundType.SUPER,integerType);
  JParameterizedType listOfSuperNumber=oracle.getParameterizedType(genericList,new JClassType[]{numLowerBoundWildcard});
  JParameterizedType listOfSuperInteger=oracle.getParameterizedType(genericList,new JClassType[]{intLowerBoundWildcard});
  assertTrue(listOfSuperInteger.isAssignableFrom(listOfSuperNumber));
  assertFalse(listOfSuperInteger.isAssignableTo(listOfSuperNumber));
  assertFalse(listOfSuperNumber.isAssignableFrom(listOfSuperInteger));
  assertTrue(listOfSuperNumber.isAssignableTo(listOfSuperInteger));
  JParameterizedType listOfObject=oracle.getParameterizedType(genericList,new JClassType[]{oracle.getJavaLangObject()});
  JClassType stringType=oracle.getType(String.class.getName());
  JParameterizedType listOfString=oracle.getParameterizedType(genericList,new JClassType[]{stringType});
  assertFalse(listOfObject.isAssignableFrom(listOfString));
  assertFalse(listOfString.isAssignableFrom(listOfObject));
  JParameterizedType listOfListOfString=oracle.getParameterizedType(genericList,new JClassType[]{listOfString});
  JGenericType genericVector=oracle.getType(Vector.class.getName()).isGenericType();
  JParameterizedType vectorOfString=oracle.getParameterizedType(genericVector,new JClassType[]{stringType});
  JParameterizedType listOfVectorOfString=oracle.getParameterizedType(genericList,new JClassType[]{vectorOfString});
  assertFalse(listOfListOfString.isAssignableFrom(listOfVectorOfString));
  assertFalse(listOfVectorOfString.isAssignableFrom(listOfListOfString));
  JClassType listOfRawList=oracle.getParameterizedType(genericList,new JClassType[]{genericList.getRawType()});
  assertFalse(listOfRawList.isAssignableFrom(listOfListOfString));
  assertFalse(listOfListOfString.isAssignableFrom(listOfRawList));
  JGenericType genericClass=oracle.getType(GenericClass.class.getName()).isGenericType();
  JParameterizedType parameterizedGenericClass=oracle.getParameterizedType(genericClass,new JClassType[]{stringType});
  JClassType extendsRawGenericClass=oracle.getType(ExtendsRawGenericClass.class.getName());
  assertTrue(parameterizedGenericClass.isAssignableFrom(extendsRawGenericClass));
  assertFalse(extendsRawGenericClass.isAssignableFrom(parameterizedGenericClass));
  JClassType listOfListOfExtendsNumber=oracle.getParameterizedType(genericList,new JClassType[]{listOfExtendsNumber});
  JClassType listOfListOfExtendsInteger=oracle.getParameterizedType(genericList,new JClassType[]{listOfExtendsInteger});
  assertFalse(listOfListOfExtendsNumber.isAssignableFrom(listOfListOfExtendsInteger));
  JClassType listOfInteger=oracle.getParameterizedType(genericList,new JClassType[]{integerType});
  assertTrue(listOfExtendsNumber.isAssignableFrom(listOfInteger));
  assertFalse(listOfExtendsNumber.isAssignableFrom(listOfObject));
  assertFalse(listOfSuperNumber.isAssignableFrom(listOfInteger));
  assertTrue(listOfSuperNumber.isAssignableFrom(listOfObject));
}"
82891,"public void testGenericClass_LowerBoundWildcard() throws NotFoundException {
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericType=getGenericTestType();
  JWildcardType lowerBoundWildcard=oracle.getWildcardType(false,integerType);
  JClassType type=oracle.getParameterizedType(genericType,new JClassType[]{lowerBoundWildcard});
  JParameterizedType parameterizedType=type.isParameterized();
  validateTypeSubstitution(genericType,parameterizedType,new ParameterizedSubstitution(parameterizedType));
}","public void testGenericClass_LowerBoundWildcard() throws NotFoundException {
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericType=getGenericTestType();
  JWildcardType lowerBoundWildcard=oracle.getWildcardType(BoundType.SUPER,integerType);
  JClassType type=oracle.getParameterizedType(genericType,new JClassType[]{lowerBoundWildcard});
  JParameterizedType parameterizedType=type.isParameterized();
  validateTypeSubstitution(genericType,parameterizedType,new ParameterizedSubstitution(parameterizedType));
}"
82892,"public void testGenericClass_UnboundWildcard() throws NotFoundException {
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericType=getGenericTestType();
  JWildcardType upperBoundWildcard=oracle.getWildcardType(true,oracle.getJavaLangObject());
  JClassType type=oracle.getParameterizedType(genericType,new JClassType[]{upperBoundWildcard});
  JParameterizedType parameterizedType=type.isParameterized();
  validateTypeSubstitution(genericType,parameterizedType,new ParameterizedSubstitution(parameterizedType));
}","public void testGenericClass_UnboundWildcard() throws NotFoundException {
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericType=getGenericTestType();
  JWildcardType upperBoundWildcard=oracle.getWildcardType(BoundType.EXTENDS,oracle.getJavaLangObject());
  JClassType type=oracle.getParameterizedType(genericType,new JClassType[]{upperBoundWildcard});
  JParameterizedType parameterizedType=type.isParameterized();
  validateTypeSubstitution(genericType,parameterizedType,new ParameterizedSubstitution(parameterizedType));
}"
82893,"/** 
 * Tests the subtypes of MyList<Integer>. These should be: <ul> <li><code>MyIntegerList</code></li> <li><code>MyCustomList&lt;? extends Serializable, Integer&gt;</code></li> </ul>
 * @throws NotFoundException
 */
@Override public void testGetSubtypes() throws NotFoundException {
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericType=oracle.getType(MyList.class.getName()).isGenericType();
  JParameterizedType parameterizedType=oracle.getParameterizedType(genericType,new JClassType[]{integerType});
  JClassType[] actualSubtypes=parameterizedType.getSubtypes();
  JGenericType myCustomListType=oracle.getType(MyCustomList.class.getName()).isGenericType();
  JParameterizedType parameterizedMyCustomList=oracle.getParameterizedType(myCustomListType,new JClassType[]{oracle.getWildcardType(true,oracle.getType(Serializable.class.getName())),integerType});
  JClassType[] expected={oracle.getType(MyIntegerList.class.getName()),parameterizedMyCustomList};
  validateEquals(oracle,expected,actualSubtypes);
}","/** 
 * Tests the subtypes of MyList<Integer>. These should be: <ul> <li><code>MyIntegerList</code></li> <li><code>MyCustomList&lt;? extends Serializable, Integer&gt;</code></li> </ul>
 * @throws NotFoundException
 */
@Override public void testGetSubtypes() throws NotFoundException {
  TypeOracle oracle=moduleContext.getOracle();
  JGenericType genericType=oracle.getType(MyList.class.getName()).isGenericType();
  JParameterizedType parameterizedType=oracle.getParameterizedType(genericType,new JClassType[]{integerType});
  JClassType[] actualSubtypes=parameterizedType.getSubtypes();
  JGenericType myCustomListType=oracle.getType(MyCustomList.class.getName()).isGenericType();
  JParameterizedType parameterizedMyCustomList=oracle.getParameterizedType(myCustomListType,new JClassType[]{oracle.getWildcardType(BoundType.EXTENDS,oracle.getType(Serializable.class.getName())),integerType});
  JClassType[] expected={oracle.getType(MyIntegerList.class.getName()),parameterizedMyCustomList};
  validateEquals(oracle,expected,actualSubtypes);
}"
82894,"/** 
 * Extracts a string from an (OLECHAR*) type.
 */
public static String extractStringFromOleCharPtr(int pOleChar){
  int size=COM.SysStringByteLen(pOleChar);
  if (size > 8192) {
    size=8192;
  }
  char[] buffer=new char[(size + 1) / 2];
  OS.MoveMemory(buffer,pOleChar,size);
  String s=new String(buffer);
  if (s.indexOf('\0') != -1) {
    return s.substring(0,s.indexOf('\0'));
  }
 else {
    return s;
  }
}","/** 
 * Extracts a string from an (OLECHAR*) type.
 */
public static String extractStringFromOleCharPtr(int pOleChar){
  int length=OS.wcslen(pOleChar);
  char[] buffer=new char[length];
  OS.MoveMemory(buffer,pOleChar,length);
  return String.valueOf(buffer);
}"
82895,"/** 
 * Create the data for JSON table to capture the mapping from a class to its query types.
 */
private void computeSourceClass(JClassType type){
  if (type == null || alreadyRan.contains(type)) {
    return;
  }
  alreadyRan.add(type);
  computeSourceClass(type.extnds);
  if (!program.typeOracle.isInstantiatedType(type) || program.isJavaScriptObject(type)) {
    return;
  }
  Set<JReferenceType> yesSet=null;
  for (  JReferenceType qType : queriedTypes.keySet()) {
    Set<JReferenceType> querySet=queriedTypes.get(qType);
    if (program.typeOracle.canTriviallyCast(type,qType)) {
      for (      JReferenceType argType : querySet) {
        if (program.typeOracle.canTriviallyCast(type,argType)) {
          if (yesSet == null) {
            yesSet=new HashSet<JReferenceType>();
          }
          yesSet.add(qType);
          break;
        }
      }
    }
  }
  if (yesSet == null && type != program.getTypeJavaLangObject()) {
    return;
  }
  JReferenceType[] yesArray=new JReferenceType[nextQueryId];
  if (yesSet != null) {
    for (    JReferenceType yesType : yesSet) {
      yesArray[queryIds.get(yesType)]=yesType;
    }
  }
  JsonObject jsonObject=new JsonObject(program);
  for (int i=0; i < nextQueryId; ++i) {
    if (yesArray[i] != null) {
      JIntLiteral labelExpr=program.getLiteralInt(i);
      JIntLiteral valueExpr=program.getLiteralInt(1);
      jsonObject.propInits.add(new JsonPropInit(program,labelExpr,valueExpr));
    }
  }
  classes.add(type);
  jsonObjects.add(jsonObject);
}","/** 
 * Create the data for JSON table to capture the mapping from a class to its query types.
 */
private void computeSourceClass(JClassType type){
  if (type == null || alreadyRan.contains(type)) {
    return;
  }
  alreadyRan.add(type);
  computeSourceClass(type.extnds);
  if (!program.typeOracle.isInstantiatedType(type) || program.isJavaScriptObject(type)) {
    return;
  }
  Set<JReferenceType> yesSet=null;
  for (  JReferenceType qType : queriedTypes.keySet()) {
    Set<JReferenceType> querySet=queriedTypes.get(qType);
    if (program.typeOracle.canTriviallyCast(type,qType)) {
      for (      JReferenceType argType : querySet) {
        if (program.typeOracle.canTriviallyCast(type,argType)) {
          if (yesSet == null) {
            yesSet=new HashSet<JReferenceType>();
          }
          yesSet.add(qType);
          break;
        }
      }
    }
  }
  JReferenceType[] yesArray=new JReferenceType[nextQueryId];
  if (yesSet != null) {
    for (    JReferenceType yesType : yesSet) {
      yesArray[queryIds.get(yesType)]=yesType;
    }
  }
  JsonObject jsonObject=new JsonObject(program);
  for (int i=1; i < nextQueryId; ++i) {
    if (yesArray[i] != null) {
      JIntLiteral labelExpr=program.getLiteralInt(i);
      JIntLiteral valueExpr=program.getLiteralInt(1);
      jsonObject.propInits.add(new JsonPropInit(program,labelExpr,valueExpr));
    }
  }
  if (jsonObject.propInits.isEmpty() && type != program.getTypeJavaLangObject() && type != program.getTypeJavaLangString()) {
    return;
  }
  classes.add(type);
  jsonObjects.add(jsonObject);
}"
82896,"public void testArrayStore(){
  JavaScriptObject[] jsoArray=new JavaScriptObject[1];
  jsoArray[0]=makeJSO();
  jsoArray[0]=makeFoo();
  jsoArray[0]=makeBar();
  Foo[] fooArray=new Foo[1];
  fooArray[0]=(Foo)makeJSO();
  fooArray[0]=makeFoo();
  fooArray[0]=makeBar().cast();
  Bar[] barArray=new Bar[1];
  barArray[0]=(Bar)makeJSO();
  barArray[0]=makeBar();
  barArray[0]=makeFoo().cast();
  Object[] objArray=jsoArray;
  try {
    objArray[0]=new Object();
    fail(""String_Node_Str"");
  }
 catch (  ArrayStoreException expected) {
  }
}","public void testArrayStore(){
  JavaScriptObject[] jsoArray=new JavaScriptObject[1];
  jsoArray[0]=makeJSO();
  jsoArray[0]=makeFoo();
  jsoArray[0]=makeBar();
  Foo[] fooArray=new Foo[1];
  fooArray[0]=(Foo)makeJSO();
  fooArray[0]=makeFoo();
  fooArray[0]=makeBar().cast();
  Bar[] barArray=new Bar[1];
  barArray[0]=(Bar)makeJSO();
  barArray[0]=makeBar();
  barArray[0]=makeFoo().cast();
  Object[] objArray=jsoArray;
  try {
    objArray[0]=new Object();
    fail(""String_Node_Str"");
  }
 catch (  ArrayStoreException expected) {
  }
  objArray=new Object[1];
  objArray[0]=makeJSO();
  objArray[0]=makeFoo();
  objArray[0]=makeBar();
}"
82897,private native String escapeValue(String toEscape);,static native String escapeValue(String toEscape);
82898,"public void onWindowResized(int width,int height){
  int shortcutHeight=height - shortcuts.getAbsoluteTop() - 8;
  if (shortcutHeight < 1) {
    shortcutHeight=1;
  }
  shortcuts.setHeight(""String_Node_Str"" + shortcutHeight);
  mailDetail.adjustSize(width,height);
}","public void onWindowResized(int width,int height){
  int shortcutHeight=height - shortcuts.getAbsoluteTop() - 8;
  if (shortcutHeight < 1) {
    shortcutHeight=1;
  }
  shortcuts.setHeight(shortcutHeight + ""String_Node_Str"");
  mailDetail.adjustSize(width,height);
}"
82899,"/** 
 * Adjusts the widget's size such that it fits within the window's client area.
 */
public void adjustSize(int windowWidth,int windowHeight){
  int scrollWidth=windowWidth - scroller.getAbsoluteLeft() - 9;
  if (scrollWidth < 1) {
    scrollWidth=1;
  }
  int scrollHeight=windowHeight - scroller.getAbsoluteTop() - 9;
  if (scrollHeight < 1) {
    scrollHeight=1;
  }
  scroller.setSize(""String_Node_Str"" + scrollWidth,""String_Node_Str"" + scrollHeight);
}","/** 
 * Adjusts the widget's size such that it fits within the window's client area.
 */
public void adjustSize(int windowWidth,int windowHeight){
  int scrollWidth=windowWidth - scroller.getAbsoluteLeft() - 9;
  if (scrollWidth < 1) {
    scrollWidth=1;
  }
  int scrollHeight=windowHeight - scroller.getAbsoluteTop() - 9;
  if (scrollHeight < 1) {
    scrollHeight=1;
  }
  scroller.setPixelSize(scrollWidth,scrollHeight);
}"
82900,"public NameEnvironmentAnswer findType(char[][] compoundTypeName){
  String qname=CharOperation.toString(compoundTypeName);
  if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
    return (nameEnvironmentAnswerForTypeName.get(qname));
  }
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + qname + ""String_Node_Str"",null);
  if (sourceOracle.isPackage(qname)) {
    logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
    return null;
  }
  ByteCode byteCode=doGetByteCodeFromCache(logger,qname);
  if (byteCode != null) {
    byte[] classBytes=byteCode.getBytes();
    char[] loc=byteCode.getLocation().toCharArray();
    try {
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      ClassFileReader cfr=new ClassFileReader(classBytes,loc);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 catch (    ClassFormatException e) {
      String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
      compiler.problemReporter.abortDueToInternalError(msg);
      return null;
    }
  }
  String className=qname;
  int pos=qname.indexOf('$');
  if (pos >= 0) {
    qname=qname.substring(0,pos);
  }
  CompilationUnitProvider cup;
  try {
    cup=sourceOracle.findCompilationUnit(logger,qname);
    if (cup != null) {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + cup.getLocation(),null);
      ICompilationUnitAdapter unit=new ICompilationUnitAdapter(cup);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(unit,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 else {
      ClassLoader contextClassLoader=Thread.currentThread().getContextClassLoader();
      if (isBinaryType(contextClassLoader,className)) {
        URL resourceURL=contextClassLoader.getResource(className.replace('.','/') + ""String_Node_Str"");
        if (resourceURL != null) {
          byte[] classBytes=Util.readURLAsBytes(resourceURL);
          ClassFileReader cfr;
          try {
            cfr=new ClassFileReader(classBytes,null);
            NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
            nameEnvironmentAnswerForTypeName.put(qname,out);
            return out;
          }
 catch (          ClassFormatException e) {
          }
        }
      }
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      return null;
    }
  }
 catch (  UnableToCompleteException e) {
    String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
    compiler.problemReporter.abortDueToInternalError(msg);
    return null;
  }
}","public NameEnvironmentAnswer findType(char[][] compoundTypeName){
  String qname=CharOperation.toString(compoundTypeName);
  if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
    return (nameEnvironmentAnswerForTypeName.get(qname));
  }
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + qname + ""String_Node_Str"",null);
  if (sourceOracle.isPackage(qname)) {
    logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
    return null;
  }
  ByteCode byteCode=doGetByteCodeFromCache(logger,qname);
  if (byteCode != null) {
    byte[] classBytes=byteCode.getBytes();
    char[] loc=byteCode.getLocation().toCharArray();
    try {
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      ClassFileReader cfr=new ClassFileReader(classBytes,loc);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 catch (    ClassFormatException e) {
      String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
      compiler.problemReporter.abortDueToInternalError(msg);
      return null;
    }
  }
  String className=qname;
  int pos=qname.indexOf('$');
  if (pos >= 0) {
    qname=qname.substring(0,pos);
    if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
      return (nameEnvironmentAnswerForTypeName.get(qname));
    }
  }
  CompilationUnitProvider cup;
  try {
    cup=sourceOracle.findCompilationUnit(logger,qname);
    if (cup != null) {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + cup.getLocation(),null);
      ICompilationUnitAdapter unit=new ICompilationUnitAdapter(cup);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(unit,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 else {
      ClassLoader contextClassLoader=Thread.currentThread().getContextClassLoader();
      if (isBinaryType(contextClassLoader,className)) {
        URL resourceURL=contextClassLoader.getResource(className.replace('.','/') + ""String_Node_Str"");
        if (resourceURL != null) {
          byte[] classBytes=Util.readURLAsBytes(resourceURL);
          ClassFileReader cfr;
          try {
            cfr=new ClassFileReader(classBytes,null);
            NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
            nameEnvironmentAnswerForTypeName.put(qname,out);
            return out;
          }
 catch (          ClassFormatException e) {
          }
        }
      }
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      return null;
    }
  }
 catch (  UnableToCompleteException e) {
    String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
    compiler.problemReporter.abortDueToInternalError(msg);
    return null;
  }
}"
82901,"@Override public void process(CompilationUnitDeclaration cud,int index){
  long processBeginNanos=System.nanoTime();
  if (!cachePolicy.shouldProcess(cud)) {
    jdtProcessNanos+=System.nanoTime() - processBeginNanos;
    return;
  }
{
    this.parser.getMethodBodies(cud);
    if (cud.scope != null) {
      cud.scope.faultInTypes();
    }
    if (cud.scope != null) {
      cud.scope.verifyMethods(lookupEnvironment.methodVerifier());
    }
    cud.resolve();
    cud.analyseCode();
    if (doGenerateBytes) {
      cud.generateCode();
    }
    if (options.produceReferenceInfo && cud.scope != null) {
      cud.scope.storeDependencyInfo();
    }
    cud.compilationResult.totalUnitsKnown=totalUnits;
  }
  ICompilationUnit cu=cud.compilationResult.compilationUnit;
  String loc=String.valueOf(cu.getFileName());
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + loc,null);
  String[] typeNames=doFindAdditionalTypesUsingJsni(logger,cud);
  for (int i=0; i < typeNames.length; i++) {
    String typeName=typeNames[i];
    final String msg=""String_Node_Str"" + typeName + ""String_Node_Str"";
    logger.log(TreeLogger.SPAM,msg,null);
    char[][] chars=CharOperation.splitOn('.',typeName.toCharArray());
    lookupEnvironment.getType(chars);
  }
  typeNames=doFindAdditionalTypesUsingRebinds(logger,cud);
  for (int i=0; i < typeNames.length; i++) {
    String typeName=typeNames[i];
    final String msg=""String_Node_Str"" + typeName + ""String_Node_Str"";
    logger.log(TreeLogger.SPAM,msg,null);
    resolvePossiblyNestedType(typeName);
  }
  if (cuds != null) {
    cuds.add(cud);
  }
  jdtProcessNanos+=System.nanoTime() - processBeginNanos;
}","@Override public void process(CompilationUnitDeclaration cud,int index){
  long processBeginNanos=System.nanoTime();
  if (!cachePolicy.shouldProcess(cud)) {
    jdtProcessNanos+=System.nanoTime() - processBeginNanos;
    return;
  }
{
    this.parser.getMethodBodies(cud);
    if (cud.scope != null) {
      cud.scope.faultInTypes();
    }
    if (cud.scope != null) {
      cud.scope.verifyMethods(lookupEnvironment.methodVerifier());
    }
    cud.resolve();
    cud.analyseCode();
    if (doGenerateBytes) {
      cud.generateCode();
    }
    if (options.produceReferenceInfo && cud.scope != null) {
      cud.scope.storeDependencyInfo();
    }
    cud.compilationResult.totalUnitsKnown=totalUnits;
  }
  ICompilationUnit cu=cud.compilationResult.compilationUnit;
  String loc=String.valueOf(cu.getFileName());
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + loc,null);
  String[] typeNames=doFindAdditionalTypesUsingJsni(logger,cud);
  for (int i=0; i < typeNames.length; i++) {
    String typeName=typeNames[i];
    final String msg=""String_Node_Str"" + typeName + ""String_Node_Str"";
    logger.log(TreeLogger.SPAM,msg,null);
    resolvePossiblyNestedType(typeName);
  }
  typeNames=doFindAdditionalTypesUsingRebinds(logger,cud);
  for (int i=0; i < typeNames.length; i++) {
    String typeName=typeNames[i];
    final String msg=""String_Node_Str"" + typeName + ""String_Node_Str"";
    logger.log(TreeLogger.SPAM,msg,null);
    resolvePossiblyNestedType(typeName);
  }
  if (cuds != null) {
    cuds.add(cud);
  }
  jdtProcessNanos+=System.nanoTime() - processBeginNanos;
}"
82902,"public JsniFieldRef(JProgram program,SourceInfo info,JField field,JReferenceType enclosingType){
  super(program,info,field.isStatic() ? null : program.getLiteralNull(),field,enclosingType);
}","public JsniFieldRef(JProgram program,SourceInfo info,String ident,JField field,JReferenceType enclosingType){
  super(program,info,field.isStatic() ? null : program.getLiteralNull(),field,enclosingType);
  this.ident=ident;
}"
82903,"public JsniMethodRef(JProgram program,SourceInfo info,JMethod method){
  super(program,info,method.isStatic() ? null : program.getLiteralNull(),method);
}","public JsniMethodRef(JProgram program,SourceInfo info,String ident,JMethod method){
  super(program,info,method.isStatic() ? null : program.getLiteralNull(),method);
  this.ident=ident;
}"
82904,"public NameEnvironmentAnswer findType(char[][] compoundTypeName){
  String qname=CharOperation.toString(compoundTypeName);
  if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
    return (nameEnvironmentAnswerForTypeName.get(qname));
  }
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + qname + ""String_Node_Str"",null);
  if (sourceOracle.isPackage(qname)) {
    logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
    return null;
  }
  ByteCode byteCode=doGetByteCodeFromCache(logger,qname);
  if (byteCode != null) {
    byte[] classBytes=byteCode.getBytes();
    char[] loc=byteCode.getLocation().toCharArray();
    try {
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      ClassFileReader cfr=new ClassFileReader(classBytes,loc);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 catch (    ClassFormatException e) {
      String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
      compiler.problemReporter.abortDueToInternalError(msg);
      return null;
    }
  }
  String className=qname;
  int pos=qname.indexOf('$');
  if (pos >= 0) {
    qname=qname.substring(0,pos);
    if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
      return (nameEnvironmentAnswerForTypeName.get(qname));
    }
  }
  CompilationUnitProvider cup;
  try {
    cup=sourceOracle.findCompilationUnit(logger,qname);
    if (cup != null) {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + cup.getLocation(),null);
      ICompilationUnitAdapter unit=new ICompilationUnitAdapter(cup);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(unit,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 else {
      ClassLoader contextClassLoader=Thread.currentThread().getContextClassLoader();
      if (isBinaryType(contextClassLoader,className)) {
        URL resourceURL=contextClassLoader.getResource(className.replace('.','/') + ""String_Node_Str"");
        if (resourceURL != null) {
          byte[] classBytes=Util.readURLAsBytes(resourceURL);
          ClassFileReader cfr;
          try {
            cfr=new ClassFileReader(classBytes,null);
            NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
            nameEnvironmentAnswerForTypeName.put(qname,out);
            return out;
          }
 catch (          ClassFormatException e) {
          }
        }
      }
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      return null;
    }
  }
 catch (  UnableToCompleteException e) {
    String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
    compiler.problemReporter.abortDueToInternalError(msg);
    return null;
  }
}","public NameEnvironmentAnswer findType(char[][] compoundTypeName){
  String qname=CharOperation.toString(compoundTypeName);
  if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
    return (nameEnvironmentAnswerForTypeName.get(qname));
  }
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + qname + ""String_Node_Str"",null);
  if (sourceOracle.isPackage(qname)) {
    logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
    return null;
  }
  ByteCode byteCode=doGetByteCodeFromCache(logger,qname);
  if (byteCode != null) {
    byte[] classBytes=byteCode.getBytes();
    char[] loc=byteCode.getLocation().toCharArray();
    try {
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      ClassFileReader cfr=new ClassFileReader(classBytes,loc);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 catch (    ClassFormatException e) {
      String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
      compiler.problemReporter.abortDueToInternalError(msg);
      return null;
    }
  }
  String className=qname;
  int pos=qname.indexOf('$');
  if (pos >= 0) {
    qname=qname.substring(0,pos);
    if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
      return (nameEnvironmentAnswerForTypeName.get(qname));
    }
  }
  CompilationUnitProvider cup;
  try {
    cup=sourceOracle.findCompilationUnit(logger,qname);
    if (cup != null) {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + cup.getLocation(),null);
      ICompilationUnitAdapter unit=new ICompilationUnitAdapter(cup);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(unit,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 else {
      ClassLoader classLoader=getClassLoader();
      URL resourceURL=classLoader.getResource(className.replace('.','/') + ""String_Node_Str"");
      if (resourceURL != null) {
        if (isBinaryType(classLoader,className)) {
          byte[] classBytes=Util.readURLAsBytes(resourceURL);
          ClassFileReader cfr;
          try {
            cfr=new ClassFileReader(classBytes,null);
            NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
            nameEnvironmentAnswerForTypeName.put(qname,out);
            return out;
          }
 catch (          ClassFormatException e) {
          }
        }
      }
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      return null;
    }
  }
 catch (  UnableToCompleteException e) {
    String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
    compiler.problemReporter.abortDueToInternalError(msg);
    return null;
  }
}"
82905,"public boolean isPackage(char[][] parentPkg,char[] pkg){
  final char[] pathChars=CharOperation.concatWith(parentPkg,pkg,'.');
  String packageName=String.valueOf(pathChars);
  if (knownPackages.contains(packageName)) {
    return true;
  }
 else   if (sourceOracle.isPackage(packageName)) {
    rememberPackage(packageName);
    return true;
  }
 else {
    return false;
  }
}","private boolean isPackage(ClassLoader classLoader,String packageName){
  String packageAsPath=packageName.replace('.','/');
  return classLoader.getResource(packageAsPath) != null;
}"
82906,"private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  if (""String_Node_Str"".equalsIgnoreCase(parts.moduleName)) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"");
    return;
  }
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=request.getParameterMap();
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
}","private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  if (""String_Node_Str"".equalsIgnoreCase(parts.moduleName)) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"");
    return;
  }
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
}"
82907,"@Override protected void service(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  TreeLogger logger=getLogger();
  int id=allocateRequestId();
  if (logger.isLoggable(TreeLogger.TRACE)) {
    StringBuffer url=request.getRequestURL();
    logger=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + id + ""String_Node_Str""+ url,null);
  }
  String servletClassName=null;
  ModuleDef moduleDef=null;
  try {
    RequestParts parts=new RequestParts(request);
    moduleDef=loadedModulesByName.get(parts.moduleName);
    if (moduleDef != null) {
      String servletPath=""String_Node_Str"" + parts.partialPath;
      servletClassName=moduleDef.findServletForPath(servletPath);
    }
 else {
    }
  }
 catch (  UnableToCompleteException e) {
  }
  if (servletClassName == null) {
    String path=request.getPathInfo();
    moduleDef=modulesByServletPath.get(path);
    if (moduleDef != null) {
      servletClassName=moduleDef.findServletForPath(path);
      if (servletClassName != null) {
        TreeLogger branch=logger.branch(TreeLogger.WARN,""String_Node_Str"",null);
        branch.log(TreeLogger.WARN,""String_Node_Str"" + path,null);
        branch.log(TreeLogger.WARN,""String_Node_Str"" + moduleDef.getName() + path,null);
        branch.log(TreeLogger.WARN,""String_Node_Str"",null);
      }
    }
 else {
    }
  }
  if (servletClassName != null) {
    HttpServlet delegatee=tryGetOrLoadServlet(logger,moduleDef,servletClassName);
    if (delegatee == null) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",null);
      sendErrorResponse(response,HttpServletResponse.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"" + servletClassName + ""String_Node_Str"");
      return;
    }
    delegatee.service(request,response);
  }
 else {
    super.service(request,response);
  }
}","@Override protected void service(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  TreeLogger logger=getLogger();
  int id=allocateRequestId();
  if (logger.isLoggable(TreeLogger.TRACE)) {
    StringBuffer url=request.getRequestURL();
    logger=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + id + ""String_Node_Str""+ url,null);
  }
  String servletClassName=null;
  ModuleDef moduleDef=null;
  try {
    RequestParts parts=new RequestParts(request);
    moduleDef=getModuleDef(logger,parts.moduleName);
    if (moduleDef != null) {
      String servletPath=""String_Node_Str"" + parts.partialPath;
      servletClassName=moduleDef.findServletForPath(servletPath);
    }
 else {
    }
  }
 catch (  UnableToCompleteException e) {
  }
  if (servletClassName == null) {
    String path=request.getPathInfo();
    moduleDef=modulesByServletPath.get(path);
    if (moduleDef != null) {
      servletClassName=moduleDef.findServletForPath(path);
      if (servletClassName != null) {
        TreeLogger branch=logger.branch(TreeLogger.WARN,""String_Node_Str"",null);
        branch.log(TreeLogger.WARN,""String_Node_Str"" + path,null);
        branch.log(TreeLogger.WARN,""String_Node_Str"" + moduleDef.getName() + path,null);
        branch.log(TreeLogger.WARN,""String_Node_Str"",null);
      }
    }
 else {
    }
  }
  if (servletClassName != null) {
    HttpServlet delegatee=tryGetOrLoadServlet(logger,moduleDef,servletClassName);
    if (delegatee == null) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",null);
      sendErrorResponse(response,HttpServletResponse.SC_INTERNAL_SERVER_ERROR,""String_Node_Str"" + servletClassName + ""String_Node_Str"");
      return;
    }
    delegatee.service(request,response);
  }
 else {
    super.service(request,response);
  }
}"
82908,"/** 
 * Runs a particular test case.
 */
private void runTestImpl(String moduleName,TestCase testCase,TestResult testResult) throws UnableToCompleteException {
  String syntheticModuleName=moduleName + ""String_Node_Str"";
  boolean sameTest=syntheticModuleName.equals(currentModuleName);
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  currentModuleName=syntheticModuleName;
  if (!sameTest) {
    ModuleDef synthetic=ModuleDefLoader.createSyntheticModule(getTopLogger(),currentModuleName,new String[]{moduleName,""String_Node_Str""},true);
    synthetic.clearEntryPoints();
    synthetic.addEntryPointTypeName(GWTRunner.class.getName());
    Property moduleNameProp=synthetic.getProperties().create(""String_Node_Str"");
    moduleNameProp.addKnownValue(moduleName);
    moduleNameProp.setActiveValue(moduleName);
  }
  lastLaunchFailed=false;
  messageQueue.setNextTestName(currentModuleName,testCase.getClass().getName(),testCase.getName());
  try {
    runStyle.maybeLaunchModule(currentModuleName,!sameTest);
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  try {
    testBeginTimeout=System.currentTimeMillis() + TEST_BEGIN_TIMEOUT_MILLIS;
    pumpEventLoop();
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  List<TestResults> results=messageQueue.getResults(currentModuleName);
  if (results == null) {
    return;
  }
  boolean parallelTesting=numClients > 1;
  for (  TestResults result : results) {
    Trial firstTrial=result.getTrials().get(0);
    Throwable exception=firstTrial.getException();
    if (parallelTesting && exception != null) {
      String msg=""String_Node_Str"" + result.getHost() + ""String_Node_Str""+ result.getAgent();
      if (exception instanceof AssertionFailedError) {
        AssertionFailedError newException=new AssertionFailedError(msg + ""String_Node_Str"" + exception.getMessage());
        newException.setStackTrace(exception.getStackTrace());
        exception=newException;
      }
 else {
        exception=new RuntimeException(msg,exception);
      }
    }
    if (exception instanceof AssertionFailedError) {
      testResult.addFailure(testCase,(AssertionFailedError)exception);
    }
 else     if (exception != null) {
      testResult.addError(testCase,exception);
    }
    if (testCase instanceof Benchmark) {
      report.addBenchmarkResults(testCase,result);
    }
  }
}","/** 
 * Runs a particular test case.
 */
private void runTestImpl(String moduleName,TestCase testCase,TestResult testResult) throws UnableToCompleteException {
  String syntheticModuleName=moduleName + ""String_Node_Str"";
  boolean sameTest=syntheticModuleName.equals(currentModuleName);
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  currentModuleName=syntheticModuleName;
  if (!sameTest) {
    ModuleDef synthetic=ModuleDefLoader.createSyntheticModule(getTopLogger(),currentModuleName,new String[]{moduleName,""String_Node_Str""},true);
    synthetic.clearEntryPoints();
    synthetic.addEntryPointTypeName(GWTRunner.class.getName());
    Property moduleNameProp=synthetic.getProperties().create(""String_Node_Str"");
    moduleNameProp.addKnownValue(moduleName);
    moduleNameProp.setActiveValue(moduleName);
  }
  lastLaunchFailed=false;
  messageQueue.setNextTestName(currentModuleName,testCase.getClass().getName(),testCase.getName());
  try {
    runStyle.maybeLaunchModule(currentModuleName,!sameTest);
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTimeout=System.currentTimeMillis() + TEST_BEGIN_TIMEOUT_MILLIS;
    pumpEventLoop();
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  List<TestResults> results=messageQueue.getResults(currentModuleName);
  if (results == null) {
    return;
  }
  boolean parallelTesting=numClients > 1;
  for (  TestResults result : results) {
    Trial firstTrial=result.getTrials().get(0);
    Throwable exception=firstTrial.getException();
    if (parallelTesting && exception != null) {
      String msg=""String_Node_Str"" + result.getHost() + ""String_Node_Str""+ result.getAgent();
      if (exception instanceof AssertionFailedError) {
        AssertionFailedError newException=new AssertionFailedError(msg + ""String_Node_Str"" + exception.getMessage());
        newException.setStackTrace(exception.getStackTrace());
        exception=newException;
      }
 else {
        exception=new RuntimeException(msg,exception);
      }
    }
    if (exception instanceof AssertionFailedError) {
      testResult.addFailure(testCase,(AssertionFailedError)exception);
    }
 else     if (exception != null) {
      if (exception instanceof JUnitFatalLaunchException) {
        lastLaunchFailed=true;
      }
      testResult.addError(testCase,exception);
    }
    if (testCase instanceof Benchmark) {
      report.addBenchmarkResults(testCase,result);
    }
  }
}"
82909,"/** 
 * Possibly launches a browser window to run the specified module.
 * @param moduleName The module to run.
 * @param forceLaunch If <code>true</code>, forces a new browser window tobe launched (because <code>testCaseClassName</code> changed)
 * @throws UnableToCompleteException
 */
public abstract void maybeLaunchModule(String moduleName,boolean forceLaunch) throws UnableToCompleteException ;","/** 
 * Possibly launches a browser window to run the specified module.
 * @param moduleName the module to run
 * @param forceLaunch If <code>true</code>, forces a new browser window tobe launched (because <code>testCaseClassName</code> changed)
 * @throws UnableToCompleteException
 */
public abstract void maybeLaunchModule(String moduleName,boolean forceLaunch) throws UnableToCompleteException ;"
82910,"@Override public void maybeLaunchModule(String moduleName,boolean forceLaunch) throws UnableToCompleteException {
  if (forceLaunch) {
    launchUrl(moduleName + ""String_Node_Str"");
  }
}","@Override public void maybeLaunchModule(String moduleName,boolean forceLaunch) throws UnableToCompleteException {
  if (forceLaunch) {
    launchUrl(getUrlSuffix(moduleName));
  }
}"
82911,"@Override public void maybeLaunchModule(String moduleName,boolean forceLaunch) throws UnableToCompleteException {
  if (forceLaunch) {
    BrowserWidget browserWindow=getBrowserWindow();
    shell.compileForWebMode(moduleName,browserWindow.getUserAgent());
    launchUrl(moduleName + ""String_Node_Str"" + PROP_GWT_HYBRID_MODE);
  }
}","@Override public void maybeLaunchModule(String moduleName,boolean forceLaunch) throws UnableToCompleteException {
  if (forceLaunch) {
    BrowserWidget browserWindow=getBrowserWindow();
    shell.compileForWebMode(moduleName,browserWindow.getUserAgent());
    launchUrl(getUrlSuffix(moduleName) + ""String_Node_Str"" + PROP_GWT_HYBRID_MODE);
  }
}"
82912,"@Override public void maybeLaunchModule(String moduleName,boolean forceLaunch) throws UnableToCompleteException {
  if (forceLaunch || !running) {
    shell.compileForWebMode(moduleName,null);
    String localhost;
    try {
      localhost=InetAddress.getLocalHost().getHostAddress();
    }
 catch (    UnknownHostException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
    String url=""String_Node_Str"" + localhost + ""String_Node_Str""+ shell.getPort()+ ""String_Node_Str""+ moduleName;
    try {
      for (int i=0; i < remoteTokens.length; ++i) {
        int remoteToken=remoteTokens[i];
        BrowserManager mgr=browserManagers[i];
        if (remoteToken != 0) {
          mgr.killBrowser(remoteToken);
        }
        remoteTokens[i]=mgr.launchNewBrowser(url,INITIAL_KEEPALIVE_MS);
      }
    }
 catch (    Exception e) {
      shell.getTopLogger().log(TreeLogger.ERROR,""String_Node_Str"",e);
      throw new UnableToCompleteException();
    }
    running=true;
  }
}","@Override public void maybeLaunchModule(String moduleName,boolean forceLaunch) throws UnableToCompleteException {
  if (forceLaunch || !running) {
    shell.compileForWebMode(moduleName,null);
    String localhost;
    try {
      localhost=InetAddress.getLocalHost().getHostAddress();
    }
 catch (    UnknownHostException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
    String url=""String_Node_Str"" + localhost + ""String_Node_Str""+ shell.getPort()+ ""String_Node_Str""+ getUrlSuffix(moduleName);
    try {
      for (int i=0; i < remoteTokens.length; ++i) {
        int remoteToken=remoteTokens[i];
        BrowserManager mgr=browserManagers[i];
        if (remoteToken != 0) {
          mgr.killBrowser(remoteToken);
        }
        remoteTokens[i]=mgr.launchNewBrowser(url,INITIAL_KEEPALIVE_MS);
      }
    }
 catch (    Exception e) {
      shell.getTopLogger().log(TreeLogger.ERROR,""String_Node_Str"",e);
      throw new UnableToCompleteException();
    }
    running=true;
  }
}"
82913,"public boolean isAssignableTo(JClassType possibleSupertype){
  return areClassTypesAssignable(possibleSupertype,this);
}","/** 
 * Returns <code>true</code> if this   {@link JClassType} is assignable to thespecified  {@link JClassType} parameter.
 * @param possibleSupertype possible supertype of this {@link JClassType}
 * @return <code>true</code> if this {@link JClassType} is assignable to thespecified  {@link JClassType} parameter
 * @throws NullPointerException if <code>possibleSupertype</code> is<code>null</code>
 */
public boolean isAssignableTo(JClassType possibleSupertype){
  if (possibleSupertype == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  return areClassTypesAssignable(possibleSupertype,this);
}"
82914,"public boolean isAssignableFrom(JClassType possibleSubtype){
  return areClassTypesAssignable(this,possibleSubtype);
}","/** 
 * Returns <code>true</code> if this   {@link JClassType} is assignable fromthe specified  {@link JClassType} parameter.
 * @param possibleSubtype possible subtype of this {@link JClassType}
 * @return <code>true</code> if this {@link JClassType} is assignable fromthe specified  {@link JClassType} parameter
 * @throws NullPointerException if <code>possibleSubtype</code> is<code>null</code>
 */
public boolean isAssignableFrom(JClassType possibleSubtype){
  if (possibleSubtype == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  return areClassTypesAssignable(this,possibleSubtype);
}"
82915,"/** 
 * Returns all of the annotations declared on this instance.  NOTE: This method is for testing purposes only.
 */
abstract Annotation[] getDeclaredAnnotations();","/** 
 * Returns all of the annotations declared on this instance. NOTE: This method is for testing purposes only.
 */
abstract Annotation[] getDeclaredAnnotations();"
82916,"/** 
 * Returns all of the annotations declared or inherited by this instance.  NOTE: This method is for testing purposes only.
 */
abstract Annotation[] getAnnotations();","/** 
 * Returns all of the annotations declared or inherited by this instance. NOTE: This method is for testing purposes only.
 */
abstract Annotation[] getAnnotations();"
82917,"/** 
 * Adds a child widget to the panel, contained within the HTML element specified by a given id.
 * @param widget the widget to be added
 * @param id the id of the element within which it will be contained
 */
public void add(Widget widget,String id){
  Element elem=getElementById(getElement(),id);
  if (elem == null) {
    throw new NoSuchElementException(id);
  }
  super.add(widget,elem);
}","/** 
 * Adds a child widget to the panel, contained within the HTML element specified by a given id.
 * @param widget the widget to be added
 * @param id the id of the element within which it will be contained
 */
public void add(Widget widget,String id){
  final Element elem=(isAttached()) ? DOM.getElementById(id) : attachToDomAndGetElement(id);
  if (elem == null) {
    throw new NoSuchElementException(id);
  }
  super.add(widget,elem);
}"
82918,"/** 
 * Tests that   {@link DOM#isOrHasChild(Element,Element)} works consistentlyacross browsers.
 */
public void testIsOrHasChild(){
  Element div=DOM.createDiv();
  Element childDiv=DOM.createDiv();
  assertFalse(DOM.isOrHasChild(div,childDiv));
  DOM.appendChild(div,childDiv);
  assertTrue(DOM.isOrHasChild(div,childDiv));
  assertFalse(DOM.isOrHasChild(childDiv,div));
}","/** 
 * Tests that   {@link DOM#isOrHasChild(Element,Element)} works consistentlyacross browsers.
 */
public void testIsOrHasChild(){
  Element div=DOM.createDiv();
  Element childDiv=DOM.createDiv();
  assertFalse(DOM.isOrHasChild(div,childDiv));
  assertTrue(DOM.isOrHasChild(div,div));
  DOM.appendChild(div,childDiv);
  assertTrue(DOM.isOrHasChild(div,childDiv));
  assertFalse(DOM.isOrHasChild(childDiv,div));
  DOM.appendChild(RootPanel.getBodyElement(),div);
  assertTrue(DOM.isOrHasChild(div,childDiv));
  assertTrue(DOM.isOrHasChild(div,div));
  assertFalse(DOM.isOrHasChild(childDiv,div));
}"
82919,"/** 
 * Adds additional metadata.
 */
void addMetaData(String tagName,String[] values);","/** 
 * Adds additional metadata.
 * @deprecated Javadoc comment metadata has been deprecated in favor of properJava annotations. The only way to add a Java annotation is via the source code.
 */
@Deprecated void addMetaData(String tagName,String[] values);"
82920,"/** 
 * Gets each list of metadata for the specified tag name.
 */
String[][] getMetaData(String tagName);","/** 
 * Gets each list of metadata for the specified tag name.
 * @deprecated Javadoc comment metadata has been deprecated in favor of properJava annotations. See {@link HasAnnotations#getAnnotation(Class)} for equivalentfunctionality.
 */
@Deprecated String[][] getMetaData(String tagName);"
82921,"/** 
 * Gets the name of available metadata tags.
 */
String[] getMetaDataTags();","/** 
 * Gets the name of available metadata tags.
 * @deprecated Javadoc comment metadata has been deprecated in favor of properJava annotations. The  {@link HasAnnotations} interface does notsupport a mechanism to enumerate all of the annotations on a member; the type of the desired annotation must be known.
 */
@Deprecated String[] getMetaDataTags();"
82922,"private void consumeTypeArgMetaData(TreeLogger logger,JMethod[] methods){
  TreeLogger branch;
  for (int i=0; i < methods.length; i++) {
    JMethod method=methods[i];
    String[][] tokensArray=method.getMetaData(TAG_TYPEARGS);
    if (tokensArray.length == 0) {
      continue;
    }
    try {
      String msg=""String_Node_Str"" + method.getReadableDeclaration();
      branch=logger.branch(TreeLogger.TRACE,msg,null);
      boolean returnTypeHandled=false;
      Set<JParameter> paramsAlreadySet=new HashSet<JParameter>();
      for (int j=0; j < tokensArray.length; j++) {
        String[] tokens=tokensArray[j];
        if (tokens.length == 0) {
          branch.log(TreeLogger.WARN,""String_Node_Str"" + TAG_TYPEARGS,null);
          throw new UnableToCompleteException();
        }
        JParameter param=method.findParameter(tokens[0]);
        if (param != null) {
          if (!paramsAlreadySet.contains(param)) {
            JType resultingType=determineActualType(branch,param.getType(),tokens,1);
            param.setType(resultingType);
            paramsAlreadySet.add(param);
          }
 else {
            msg=""String_Node_Str"" + param.getName() + ""String_Node_Str"";
            branch.log(TreeLogger.WARN,msg,null);
            throw new UnableToCompleteException();
          }
        }
 else {
          if (!returnTypeHandled) {
            JType resultingType=determineActualType(branch,method.getReturnType(),tokens,0);
            method.setReturnType(resultingType);
            returnTypeHandled=true;
          }
 else {
            msg=""String_Node_Str"";
            branch.log(TreeLogger.WARN,msg,null);
          }
        }
      }
    }
 catch (    UnableToCompleteException e) {
    }
  }
}","private void consumeTypeArgMetaData(TreeLogger logger,JMethod[] methods){
  TreeLogger branch;
  for (int i=0; i < methods.length; i++) {
    JMethod method=methods[i];
    String[][] tokensArray=method.getMetaData(TAG_TYPEARGS);
    if (tokensArray.length == 0) {
      continue;
    }
    try {
      String msg=""String_Node_Str"" + method.getReadableDeclaration();
      branch=logger.branch(TreeLogger.TRACE,msg,null);
      boolean returnTypeHandled=false;
      Set<JParameter> paramsAlreadySet=new HashSet<JParameter>();
      for (int j=0; j < tokensArray.length; j++) {
        String[] tokens=tokensArray[j];
        if (tokens.length == 0) {
          branch.log(TreeLogger.WARN,""String_Node_Str"" + TAG_TYPEARGS,null);
          throw new UnableToCompleteException();
        }
        JParameter param=method.findParameter(tokens[0]);
        if (param != null) {
          if (!paramsAlreadySet.contains(param)) {
            JType resultingType=determineActualType(branch,param.getType(),tokens,1);
            param.setType(resultingType);
            branch.log(TreeLogger.WARN,""String_Node_Str"" + TAG_TYPEARGS + ""String_Node_Str""+ param.getName()+ ""String_Node_Str""+ resultingType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"",null);
            paramsAlreadySet.add(param);
          }
 else {
            msg=""String_Node_Str"" + param.getName() + ""String_Node_Str"";
            branch.log(TreeLogger.WARN,msg,null);
            throw new UnableToCompleteException();
          }
        }
 else {
          if (!returnTypeHandled) {
            JType resultingType=determineActualType(branch,method.getReturnType(),tokens,0);
            method.setReturnType(resultingType);
            branch.log(TreeLogger.WARN,""String_Node_Str"" + TAG_TYPEARGS + ""String_Node_Str""+ resultingType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"",null);
            returnTypeHandled=true;
          }
 else {
            msg=""String_Node_Str"";
            branch.log(TreeLogger.WARN,msg,null);
          }
        }
      }
    }
 catch (    UnableToCompleteException e) {
    }
  }
}"
82923,"JMethodCall processSuperConstructorCall(ExplicitConstructorCall x){
  SourceInfo info=makeSourceInfo(x);
  JMethod ctor=(JMethod)typeMap.get(x.binding);
  JExpression trueQualifier=createThisRef(info,currentClass);
  JMethodCall call=new JMethodCall(program,info,trueQualifier,ctor);
  addCallArgs(x.arguments,call,x.binding);
  ReferenceBinding superClass=x.binding.declaringClass;
  if (superClass.isNestedType() && !superClass.isStatic()) {
    ReferenceBinding myBinding=currentClassScope.referenceType().binding;
    ReferenceBinding superBinding=superClass;
    if (superBinding.syntheticEnclosingInstanceTypes() != null) {
      JExpression qualifier=dispProcessExpression(x.qualification);
      for (      ReferenceBinding arg : superBinding.syntheticEnclosingInstanceTypes()) {
        JClassType classType=(JClassType)typeMap.get(arg);
        if (qualifier == null) {
          List<JExpression> workList=new ArrayList<JExpression>();
          Iterator<JParameter> paramIt=getSyntheticsIterator(currentMethod);
          for (          @SuppressWarnings(""String_Node_Str"") ReferenceBinding b : myBinding.syntheticEnclosingInstanceTypes()) {
            workList.add(createVariableRef(info,paramIt.next()));
          }
          call.getArgs().add(createThisRef(classType,workList));
        }
 else {
          call.getArgs().add(createThisRef(classType,qualifier));
        }
      }
    }
    if (superBinding.syntheticOuterLocalVariables() != null) {
      for (      SyntheticArgumentBinding arg : superBinding.syntheticOuterLocalVariables()) {
        JType varType=(JType)typeMap.get(arg.type);
        String varName=String.valueOf(arg.name);
        JParameter param=null;
        for (int i=0; i < currentMethod.params.size(); ++i) {
          JParameter paramIt=currentMethod.params.get(i);
          if (varType == paramIt.getType() && varName.equals(paramIt.getName())) {
            param=paramIt;
          }
        }
        if (param == null) {
          throw new InternalCompilerException(""String_Node_Str"");
        }
        call.getArgs().add(createVariableRef(info,param));
      }
    }
  }
  return call;
}","@SuppressWarnings(""String_Node_Str"") JMethodCall processSuperConstructorCall(ExplicitConstructorCall x){
  SourceInfo info=makeSourceInfo(x);
  JMethod ctor=(JMethod)typeMap.get(x.binding);
  JExpression trueQualifier=createThisRef(info,currentClass);
  JMethodCall call=new JMethodCall(program,info,trueQualifier,ctor);
  addCallArgs(x.arguments,call,x.binding);
  ReferenceBinding superClass=x.binding.declaringClass;
  if (superClass.isNestedType() && !superClass.isStatic()) {
    ReferenceBinding myBinding=currentClassScope.referenceType().binding;
    ReferenceBinding superBinding=superClass;
    if (superBinding.syntheticEnclosingInstanceTypes() != null) {
      JExpression qualifier=dispProcessExpression(x.qualification);
      for (      ReferenceBinding arg : superBinding.syntheticEnclosingInstanceTypes()) {
        JClassType classType=(JClassType)typeMap.get(arg);
        if (qualifier == null) {
          List<JExpression> workList=new ArrayList<JExpression>();
          Iterator<JParameter> paramIt=getSyntheticsIterator(currentMethod);
          for (          ReferenceBinding b : myBinding.syntheticEnclosingInstanceTypes()) {
            workList.add(createVariableRef(info,paramIt.next()));
          }
          call.getArgs().add(createThisRef(classType,workList));
        }
 else {
          call.getArgs().add(createThisRef(classType,qualifier));
        }
      }
    }
    if (superBinding.syntheticOuterLocalVariables() != null) {
      for (      SyntheticArgumentBinding arg : superBinding.syntheticOuterLocalVariables()) {
        JType varType=(JType)typeMap.get(arg.type);
        String varName=String.valueOf(arg.name);
        JParameter param=null;
        for (int i=0; i < currentMethod.params.size(); ++i) {
          JParameter paramIt=currentMethod.params.get(i);
          if (varType == paramIt.getType() && varName.equals(paramIt.getName())) {
            param=paramIt;
          }
        }
        if (param == null) {
          throw new InternalCompilerException(""String_Node_Str"");
        }
        call.getArgs().add(createVariableRef(info,param));
      }
    }
  }
  return call;
}"
82924,"public static SourceInfo translateInfo(JsSourceInfo info){
  return null;
}","@SuppressWarnings(""String_Node_Str"") public static SourceInfo translateInfo(JsSourceInfo info){
  return null;
}"
82925,"public static char[] readFileAsChars(File file){
  if (!file.exists()) {
    return null;
  }
  Reader fileReader=null;
  try {
    fileReader=new InputStreamReader(new FileInputStream(file),DEFAULT_ENCODING);
    int length=(int)file.length();
    if (length < 0) {
      return null;
    }
    char[] fileContents=new char[length];
    int charsRead=fileReader.read(fileContents);
    if (charsRead < fileContents.length) {
      char[] trimmed=new char[charsRead];
      System.arraycopy(fileContents,0,trimmed,0,charsRead);
      fileContents=trimmed;
    }
    return fileContents;
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(fileReader);
  }
}","public static char[] readFileAsChars(File file){
  String string=readFileAsString(file);
  if (string != null) {
    return string.toCharArray();
  }
  return null;
}"
82926,"/** 
 * @return null if the file could not be read
 */
public static char[] readURLAsChars(URL url){
  InputStreamReader reader=null;
  try {
    URLConnection connection=url.openConnection();
    connection.setUseCaches(false);
    reader=new InputStreamReader(connection.getInputStream(),DEFAULT_ENCODING);
    int contentLength=connection.getContentLength();
    if (contentLength < 0) {
      return null;
    }
    char[] fileContents=new char[contentLength];
    int charsRead=reader.read(fileContents);
    if (charsRead < fileContents.length) {
      char[] trimmed=new char[charsRead];
      System.arraycopy(fileContents,0,trimmed,0,charsRead);
      fileContents=trimmed;
    }
    return fileContents;
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(reader);
  }
}","/** 
 * @return null if the file could not be read
 */
public static char[] readURLAsChars(URL url){
  byte[] bytes=readURLAsBytes(url);
  if (bytes != null) {
    return toString(bytes,DEFAULT_ENCODING).toCharArray();
  }
  return null;
}"
82927,"public static String readFileAsString(File file){
  try {
    URL toURL=file.toURI().toURL();
    char[] buf=readURLAsChars(toURL);
    if (buf == null) {
      return null;
    }
    return String.valueOf(buf);
  }
 catch (  MalformedURLException e) {
    return null;
  }
}","public static String readFileAsString(File file){
  byte[] bytes=readFileAsBytes(file);
  if (bytes != null) {
    return toString(bytes,DEFAULT_ENCODING);
  }
  return null;
}"
82928,"public static byte[] readFileAsBytes(File file){
  FileInputStream fileInputStream=null;
  try {
    fileInputStream=new FileInputStream(file);
    int length=(int)file.length();
    byte[] data=new byte[length];
    fileInputStream.read(data);
    return data;
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(fileInputStream);
  }
}","public static byte[] readFileAsBytes(File file){
  FileInputStream fileInputStream=null;
  try {
    fileInputStream=new FileInputStream(file);
    int length=(int)file.length();
    return readBytesFromInputStream(fileInputStream,length);
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(fileInputStream);
  }
}"
82929,"/** 
 * @return null if the file could not be read
 */
public static byte[] readURLAsBytes(URL url){
  InputStream input=null;
  try {
    URLConnection connection=url.openConnection();
    connection.setUseCaches(false);
    input=connection.getInputStream();
    int contentLength=connection.getContentLength();
    if (contentLength < 0) {
      return null;
    }
    byte[] data=new byte[contentLength];
    input.read(data);
    return data;
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(input);
  }
}","/** 
 * @return null if the file could not be read
 */
public static byte[] readURLAsBytes(URL url){
  InputStream input=null;
  try {
    URLConnection connection=url.openConnection();
    connection.setUseCaches(false);
    input=connection.getInputStream();
    int contentLength=connection.getContentLength();
    if (contentLength < 0) {
      return null;
    }
    return readBytesFromInputStream(input,contentLength);
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(input);
  }
}"
82930,"public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  String name=method.getName();
  Object value=identifierToValue.get(name);
  if (value != null) {
    assert(method.getReturnType().isAssignableFrom(value.getClass()));
    return value;
  }
  JMethod jMethod=annotationType.findMethod(name,new JType[0]);
  if (jMethod != null) {
    JAnnotationMethod annotationMethod=jMethod.isAnnotationMethod();
    assert(annotationMethod != null);
    return annotationMethod.getDefaultValue();
  }
  if (method.getDeclaringClass() == Annotation.class && ""String_Node_Str"".equals(method.getName())) {
    return annotationClass;
  }
  return method.invoke(this,args);
}","public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  String name=method.getName();
  Object value=null;
  if (identifierToValue.containsKey(name)) {
    value=identifierToValue.get(name);
    assert(value != null);
  }
 else {
    JMethod jMethod=annotationType.findMethod(name,new JType[0]);
    if (jMethod != null) {
      JAnnotationMethod annotationMethod=jMethod.isAnnotationMethod();
      assert(annotationMethod != null);
      value=annotationMethod.getDefaultValue();
      assert(value != null);
    }
 else     if (method.getDeclaringClass() == Annotation.class && ""String_Node_Str"".equals(method.getName())) {
      value=annotationClass;
    }
  }
  if (value != null) {
    assert(isValidReturnType(method.getReturnType(),value.getClass()));
    return value;
  }
  return method.invoke(this,args);
}"
82931,"/** 
 * Called when the user sets the id using the   {@link #ensureDebugId(String)}method. Subclasses of   {@link UIObject} can override this method to add IDsto their sub elements.  If a subclass does override this method, it should list the IDs (relative to the base ID), that will be applied to each sub {@link Element} with a short description.  For example:<ul> <li>-mysubelement = Applies to my sub element.</li> </ul>  Subclasses should make a super call to this method to ensure that the ID of the main element is set. This method will not be called unless you inherit the DebugID module in your gwt.xml file by adding the following line: <pre class=""code""> &lt;inherits name=""com.google.gwt.user.DebugID""/&gt;</pre>
 * @param baseID the base ID used by the main element
 */
protected void onEnsureDebugId(String baseID){
  ensureDebugId(getElement(),""String_Node_Str"",baseID);
}","/** 
 * Called when the user sets the id using the   {@link #ensureDebugId(String)}method. Subclasses of   {@link UIObject} can override this method to add IDsto their sub elements.  If a subclass does override this method, it should list the IDs (relative to the base ID), that will be applied to each sub {@link Element} with a short description.  For example:<ul> <li>-mysubelement = Applies to my sub element.</li> </ul>  Subclasses should make a super call to this method to ensure that the ID of the main element is set. This method will not be called unless you inherit the DebugID module in your gwt.xml file by adding the following line: <pre class=""code""> &lt;inherits name=""com.google.gwt.user.Debug""/&gt;</pre>
 * @param baseID the base ID used by the main element
 */
protected void onEnsureDebugId(String baseID){
  ensureDebugId(getElement(),""String_Node_Str"",baseID);
}"
82932,"/** 
 * Ensure that the main   {@link Element} for this {@link UIObject} has an IDproperty set, which allows it to integrate with third-party libraries and test tools. Complex  {@link Widget}s will also set the IDs of their important sub-elements. If the main element already has an ID, this method will NOT override it. The debugID is only used when no other ID is present on the   {@link Element}. The ID that you specify will be prefixed by the static string  {@link #DEBUG_ID_PREFIX}. This method will be compiled out and will have no effect unless you inherit the DebugID module in your gwt.xml file by adding the following line: <pre class=""code""> &lt;inherits name=""com.google.gwt.user.DebugID""/&gt;</pre>
 * @param id the ID to set on the main element
 */
public final void ensureDebugId(String id){
  debugIdImpl.ensureDebugId(this,id);
}","/** 
 * Ensure that the main   {@link Element} for this {@link UIObject} has an IDproperty set, which allows it to integrate with third-party libraries and test tools. Complex  {@link Widget}s will also set the IDs of their important sub-elements. If the main element already has an ID, this method will NOT override it. The debugID is only used when no other ID is present on the   {@link Element}. The ID that you specify will be prefixed by the static string  {@link #DEBUG_ID_PREFIX}. This method will be compiled out and will have no effect unless you inherit the DebugID module in your gwt.xml file by adding the following line: <pre class=""code""> &lt;inherits name=""com.google.gwt.user.Debug""/&gt;</pre>
 * @param id the ID to set on the main element
 */
public final void ensureDebugId(String id){
  debugIdImpl.ensureDebugId(this,id);
}"
82933,"private List<JsStatement> parse(List<JsStatement> expected,boolean compact) throws Exception {
  TextOutput text=new DefaultTextOutput(compact);
  JsVisitor generator=new JsToStringGenerationVisitor(text);
  generator.acceptList(expected);
  return parser.parse(new JsProgram().getScope(),new StringReader(text.toString()),0);
}","private List<JsStatement> parse(List<JsStatement> expected,boolean compact) throws Exception {
  TextOutput text=new DefaultTextOutput(compact);
  JsVisitor generator=new JsSourceGenerationVisitor(text);
  generator.acceptList(expected);
  return parser.parse(new JsProgram().getScope(),new StringReader(text.toString()),0);
}"
82934,public abstract boolean isAssignableTo(JClassType possibleSupertype);,"public boolean isAssignableTo(JClassType possibleSupertype){
  return areClassTypesAssignable(possibleSupertype,this);
}"
82935,public abstract boolean isAssignableFrom(JClassType possibleSubtype);,"public boolean isAssignableFrom(JClassType possibleSubtype){
  return areClassTypesAssignable(this,possibleSubtype);
}"
82936,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-label => label next to checkbox</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  ensureDebugId(labelElem,baseID,""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-label = label next to checkbox.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  ensureDebugId(labelElem,baseID,""String_Node_Str"");
}"
82937,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-caption => text at the top of the  {@link DialogBox}</li> <li>-content => the table cell around the content</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  caption.ensureDebugId(baseID + ""String_Node_Str"");
  ensureDebugId(panel.getCellFormatter().getElement(1,0),baseID,""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-caption = text at the top of the   {@link DialogBox}.</li> <li>-content = the table cell around the content.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  caption.ensureDebugId(baseID + ""String_Node_Str"");
  ensureDebugId(panel.getCellFormatter().getElement(1,0),baseID,""String_Node_Str"");
}"
82938,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-header => the clickable header</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  header.ensureDebugId(baseID + ""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-header = the clickable header.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  header.ensureDebugId(baseID + ""String_Node_Str"");
}"
82939,"/** 
 * @see UIObject#onEnsureDebugId(String) {@link DockPanel}s support adding more than one cell in a direction, so an integer will be appended to the end of the debug id. For example, the first north cell is labeled ""north1"", the second is ""north2"", and the third is ""north3"". This widget recreates its structure every time a   {@link Widget} is added,so you must call this method after adding new  {@link Widget}s or all debug IDs will be lost. <ul> <li>-center => the center cell</li> <li>-north# => the northern cell</li> <li>-south# => the southern cell</li> <li>-east# => the eastern cell</li> <li>-west# => the western cell</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  Map<DockLayoutConstant,Integer> dirCount=new HashMap<DockLayoutConstant,Integer>();
  Iterator<Widget> it=getChildren().iterator();
  while (it.hasNext()) {
    Widget child=it.next();
    DockLayoutConstant dir=((LayoutData)child.getLayoutData()).direction;
    Integer count=dirCount.get(dir);
    if (count == null) {
      count=new Integer(1);
    }
    String debugID=generateDebugId(dir,count.intValue());
    ensureDebugId(DOM.getParent(child.getElement()),baseID,debugID);
    dirCount.put(dir,count.intValue() + 1);
  }
}","/** 
 * {@link DockPanel} supports adding more than one cell in a direction, so aninteger will be appended to the end of the debug id. For example, the first north cell is labeled ""north1"", the second is ""north2"", and the third is ""north3"". This widget recreates its structure every time a  {@link Widget} is added,so you must call this method after adding a new  {@link Widget} or all debugIDs will be lost. <p> <b>Affected Elements:</b> <ul> <li>-center = the center cell.</li> <li>-north# = the northern cell.</li> <li>-south# = the southern cell.</li> <li>-east# = the eastern cell.</li> <li>-west# = the western cell.</li> </ul> </p>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  Map<DockLayoutConstant,Integer> dirCount=new HashMap<DockLayoutConstant,Integer>();
  Iterator<Widget> it=getChildren().iterator();
  while (it.hasNext()) {
    Widget child=it.next();
    DockLayoutConstant dir=((LayoutData)child.getLayoutData()).direction;
    Integer count=dirCount.get(dir);
    if (count == null) {
      count=new Integer(1);
    }
    String debugID=generateDebugId(dir,count.intValue());
    ensureDebugId(DOM.getParent(child.getElement()),baseID,debugID);
    dirCount.put(dir,count.intValue() + 1);
  }
}"
82940,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-(row)#-(cell)# => the cell at the given row and cell index</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int rowCount=getRowCount();
  for (int row=0; row < rowCount; row++) {
    int cellCount=getCellCount(row);
    for (int cell=0; cell < cellCount; cell++) {
      Element cellElem=cellFormatter.getRawElement(row,cell);
      ensureDebugId(cellElem,baseID,row + ""String_Node_Str"" + cell);
    }
  }
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-(row)#-(cell)# = the cell at the given row and cell index.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int rowCount=getRowCount();
  for (int row=0; row < rowCount; row++) {
    int cellCount=getCellCount(row);
    for (int cell=0; cell < cellCount; cell++) {
      Element cellElem=cellFormatter.getRawElement(row,cell);
      ensureDebugId(cellElem,baseID,row + ""String_Node_Str"" + cell);
    }
  }
}"
82941,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-# => the cell at the given index</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int numChildren=getWidgetCount();
  for (int i=0; i < numChildren; i++) {
    ensureDebugId(getWidgetTd(getWidget(i)),baseID,""String_Node_Str"" + i);
  }
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-# = the cell at the given index.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int numChildren=getWidgetCount();
  for (int i=0; i < numChildren; i++) {
    ensureDebugId(getWidgetTd(getWidget(i)),baseID,""String_Node_Str"" + i);
  }
}"
82942,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-splitter => the container containing the splitter element</li> <li>-right => the container on the right side of the splitter</li> <li>-left => the container on the left side of the splitter</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  ensureDebugId(getElement(LEFT),baseID,""String_Node_Str"");
  ensureDebugId(getElement(RIGHT),baseID,""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-splitter = the container containing the splitter element.</li> <li>-right = the container on the right side of the splitter.</li> <li>-left = the container on the left side of the splitter.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  ensureDebugId(getElement(LEFT),baseID,""String_Node_Str"");
  ensureDebugId(getElement(RIGHT),baseID,""String_Node_Str"");
}"
82943,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-wrapper => the div around the link</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  ensureDebugId(anchorElem,""String_Node_Str"",baseID);
  ensureDebugId(getElement(),baseID,""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-wrapper = the div around the link.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  ensureDebugId(anchorElem,""String_Node_Str"",baseID);
  ensureDebugId(getElement(),baseID,""String_Node_Str"");
}"
82944,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-item# => the option at the specified index</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  Element selectElem=getElement();
  int numItems=getItemCount();
  for (int i=0; i < numItems; i++) {
    ensureDebugId(impl.getItemElement(selectElem,i),baseID,""String_Node_Str"" + i);
  }
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-item# = the option at the specified index.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  Element selectElem=getElement();
  int numItems=getItemCount();
  for (int i=0; i < numItems; i++) {
    ensureDebugId(impl.getItemElement(selectElem,i),baseID,""String_Node_Str"" + i);
  }
}"
82945,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-item# => the  {@link MenuItem} at the specified index</li></ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  setMenuItemDebugIds(baseID);
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-item# = the   {@link MenuItem} at the specified index.</li></ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  setMenuItemDebugIds(baseID);
}"
82946,"/** 
 * @see UIObject#onEnsureDebugId(String) Also sets the Debug IDs of  {@link MenuItem}s in the submenu of this  {@link MenuItem}, if one exists.
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  if (subMenu != null) {
    subMenu.setMenuItemDebugIds(baseID);
  }
}","/** 
 * Also sets the Debug IDs of MenuItems in the submenu of this  {@link MenuItem} if a submenu exists.
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  if (subMenu != null) {
    subMenu.setMenuItemDebugIds(baseID);
  }
}"
82947,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-splitter => the container containing the splitter element</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  ensureDebugId(splitElem,baseID,""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-splitter = the container containing the splitter element.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  ensureDebugId(splitElem,baseID,""String_Node_Str"");
}"
82948,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-text# => The element around the header at the specified index</li> <li>-content# => The element around the body at the specified index</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int numHeaders=DOM.getChildCount(body) / 2;
  for (int i=0; i < numHeaders; i++) {
    Element headerElem=DOM.getFirstChild(DOM.getChild(body,2 * i));
    Element bodyElem=DOM.getFirstChild(DOM.getChild(body,2 * i + 1));
    ensureDebugId(headerElem,baseID,""String_Node_Str"" + i);
    ensureDebugId(bodyElem,baseID,""String_Node_Str"" + i);
  }
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-text# = The element around the header at the specified index.</li> <li>-content# = The element around the body at the specified index.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int numHeaders=DOM.getChildCount(body) / 2;
  for (int i=0; i < numHeaders; i++) {
    Element headerElem=DOM.getFirstChild(DOM.getChild(body,2 * i));
    Element bodyElem=DOM.getFirstChild(DOM.getChild(body,2 * i + 1));
    ensureDebugId(headerElem,baseID,""String_Node_Str"" + i);
    ensureDebugId(bodyElem,baseID,""String_Node_Str"" + i);
  }
}"
82949,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-popup => The popup that appears with suggestions</li> <li>-items-item# => The suggested item at the specified index</li> </ul> 
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  suggestionPopup.ensureDebugId(baseID + ""String_Node_Str"");
  suggestionMenu.setMenuItemDebugIds(baseID);
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-popup = The popup that appears with suggestions.</li> <li>-items-item# = The suggested item at the specified index.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  suggestionPopup.ensureDebugId(baseID + ""String_Node_Str"");
  suggestionMenu.setMenuItemDebugIds(baseID);
}"
82950,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-tab# => The element containing the contents of the tab</li> <li>-tab-wrapper# => The cell containing the tab at the index</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int numTabs=getTabCount();
  for (int i=0; i < numTabs; i++) {
    Element widgetElem=panel.getWidget(i + 1).getElement();
    ensureDebugId(widgetElem,baseID,""String_Node_Str"" + i);
    ensureDebugId(DOM.getParent(widgetElem),baseID,""String_Node_Str"" + i);
  }
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-tab# = The element containing the contents of the tab.</li> <li>-tab-wrapper# = The cell containing the tab at the index.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int numTabs=getTabCount();
  for (int i=0; i < numTabs; i++) {
    Element widgetElem=panel.getWidget(i + 1).getElement();
    ensureDebugId(widgetElem,baseID,""String_Node_Str"" + i);
    ensureDebugId(DOM.getParent(widgetElem),baseID,""String_Node_Str"" + i);
  }
}"
82951,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-bar => The tab bar</li> <li>-bar-tab# => The element containing the contents of the tab itself</li> <li>-bar-tab#-wrapper => The cell containing the tab at the index</li> <li>-bottom => The panel beneath the tab bar</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  tabBar.ensureDebugId(baseID + ""String_Node_Str"");
  deck.ensureDebugId(baseID + ""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-bar = The tab bar.</li> <li>-bar-tab# = The element containing the content of the tab itself.</li> <li>-bar-tab#-wrapper = The cell containing the tab at the index.</li> <li>-bottom = The panel beneath the tab bar.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  tabBar.ensureDebugId(baseID + ""String_Node_Str"");
  deck.ensureDebugId(baseID + ""String_Node_Str"");
}"
82952,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-root => The root  {@link TreeItem}</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  root.ensureDebugId(baseID + ""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-root = The root   {@link TreeItem}.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  root.ensureDebugId(baseID + ""String_Node_Str"");
}"
82953,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-image => The status image</li> <li>-content => The text or  {@link Widget} next to the image</li><li>-child# => The child at the specified index</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  statusImage.ensureDebugId(baseID + ""String_Node_Str"");
  ensureDebugId(contentElem,baseID,""String_Node_Str"");
  int childCount=0;
  for (  TreeItem child : children) {
    child.ensureDebugId(baseID + ""String_Node_Str"" + childCount);
    childCount++;
  }
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-image = The status image.</li> <li>-content = The text or   {@link Widget} next to the image.</li><li>-child# = The child at the specified index.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  statusImage.ensureDebugId(baseID + ""String_Node_Str"");
  ensureDebugId(contentElem,baseID,""String_Node_Str"");
  int childCount=0;
  for (  TreeItem child : children) {
    child.ensureDebugId(baseID + ""String_Node_Str"" + childCount);
    childCount++;
  }
}"
82954,"/** 
 * Called when the user sets the id using the   {@link #ensureDebugId(String)}method. Subclasses of   {@link UIObject} can override this method to add IDsto their sub elements.  If a subclass does override this method, it should list the IDs (relative to the base ID), that will be applied to each sub {@link Element} with a short description.  For example:<ul> <li>-mysubelement => Applies to my sub element</li> </ul>  Subclasses should make a super call to this method to ensure that the ID of the main element is set. This method will not be called unless you inherit the DebugID module in your gwt.xml file by adding the following line: <inherits name=""com.google.gwt.user.DebugID""/>
 * @param baseID the base ID used by the main element
 */
protected void onEnsureDebugId(String baseID){
  ensureDebugId(getElement(),""String_Node_Str"",baseID);
}","/** 
 * Called when the user sets the id using the   {@link #ensureDebugId(String)}method. Subclasses of   {@link UIObject} can override this method to add IDsto their sub elements.  If a subclass does override this method, it should list the IDs (relative to the base ID), that will be applied to each sub {@link Element} with a short description.  For example:<ul> <li>-mysubelement = Applies to my sub element.</li> </ul>  Subclasses should make a super call to this method to ensure that the ID of the main element is set. This method will not be called unless you inherit the DebugID module in your gwt.xml file by adding the following line: <pre class=""code""> &lt;inherits name=""com.google.gwt.user.DebugID""/&gt;</pre>
 * @param baseID the base ID used by the main element
 */
protected void onEnsureDebugId(String baseID){
  ensureDebugId(getElement(),""String_Node_Str"",baseID);
}"
82955,"/** 
 * Ensure that the main   {@link Element} for this {@link UIObject} has an IDproperty set, which allows it to integrate with third-party libraries and test tools. Complex  {@link Widget}s will also set the IDs of their important sub-elements. If the main element already has an ID, this method will NOT override it. The debugID is only used when no other ID is present on the   {@link Element}. The ID that you specify will be prefixed by the static string  {@link #DEBUG_ID_PREFIX}. This method will be compiled out and will have no effect unless you inherit the DebugID module in your gwt.xml file by adding the following line: <inherits name=""com.google.gwt.user.DebugID""/>
 * @param id the ID to set on the main element
 */
public final void ensureDebugId(String id){
  debugIdImpl.ensureDebugId(this,id);
}","/** 
 * Ensure that the main   {@link Element} for this {@link UIObject} has an IDproperty set, which allows it to integrate with third-party libraries and test tools. Complex  {@link Widget}s will also set the IDs of their important sub-elements. If the main element already has an ID, this method will NOT override it. The debugID is only used when no other ID is present on the   {@link Element}. The ID that you specify will be prefixed by the static string  {@link #DEBUG_ID_PREFIX}. This method will be compiled out and will have no effect unless you inherit the DebugID module in your gwt.xml file by adding the following line: <pre class=""code""> &lt;inherits name=""com.google.gwt.user.DebugID""/&gt;</pre>
 * @param id the ID to set on the main element
 */
public final void ensureDebugId(String id){
  debugIdImpl.ensureDebugId(this,id);
}"
82956,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-# => the cell at the given index</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int numChildren=getWidgetCount();
  for (int i=0; i < numChildren; i++) {
    ensureDebugId(getWidgetTd(getWidget(i)),baseID,""String_Node_Str"" + i);
  }
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-# = the cell at the given index.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  int numChildren=getWidgetCount();
  for (int i=0; i < numChildren; i++) {
    ensureDebugId(getWidgetTd(getWidget(i)),baseID,""String_Node_Str"" + i);
  }
}"
82957,"/** 
 * @see UIObject#onEnsureDebugId(String) <ul> <li>-splitter => the container containing the splitter element</li> <li>-top => the container above the splitter</li> <li>-bottom => the container below the splitter</li> </ul>
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  ensureDebugId(getElement(TOP),baseID,""String_Node_Str"");
  ensureDebugId(getElement(BOTTOM),baseID,""String_Node_Str"");
}","/** 
 * <b>Affected Elements:</b> <ul> <li>-splitter = the container containing the splitter element.</li> <li>-top = the container above the splitter.</li> <li>-bottom = the container below the splitter.</li> </ul>
 * @see UIObject#onEnsureDebugId(String)
 */
@Override protected void onEnsureDebugId(String baseID){
  super.onEnsureDebugId(baseID);
  ensureDebugId(getElement(TOP),baseID,""String_Node_Str"");
  ensureDebugId(getElement(BOTTOM),baseID,""String_Node_Str"");
}"
82958,"private boolean _spaceCalc(JsOperator op,JsExpression arg){
  if (op.isKeyword()) {
    return true;
  }
  if (arg instanceof JsPrefixOperation) {
    JsOperator op2=((JsPrefixOperation)arg).getOperator();
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (op2 == JsUnaryOperator.DEC || op2 == JsUnaryOperator.NEG) || (op == JsBinaryOperator.ADD && op2 == JsUnaryOperator.INC);
  }
  return false;
}","private boolean _spaceCalc(JsOperator op,JsExpression arg){
  if (op.isKeyword()) {
    return true;
  }
  if (arg instanceof JsPrefixOperation) {
    JsOperator op2=((JsPrefixOperation)arg).getOperator();
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (op2 == JsUnaryOperator.DEC || op2 == JsUnaryOperator.NEG) || (op == JsBinaryOperator.ADD && op2 == JsUnaryOperator.INC);
  }
  if (arg instanceof JsIntegralLiteral) {
    JsIntegralLiteral literal=(JsIntegralLiteral)arg;
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (literal.getValue().signum() == -1);
  }
  if (arg instanceof JsDecimalLiteral) {
    JsDecimalLiteral literal=(JsDecimalLiteral)arg;
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (literal.getValue().startsWith(""String_Node_Str""));
  }
  return false;
}"
82959,"protected void printJsBlockOptionalTruncate(JsBlock x,boolean truncate){
  boolean needBraces=!x.isGlobalBlock();
  if (needBraces) {
    _blockOpen();
  }
  int count=0;
  for (Iterator<JsStatement> iter=x.getStatements().iterator(); iter.hasNext(); ++count) {
    if (truncate && count > JSBLOCK_LINES_TO_PRINT) {
      p.print(""String_Node_Str"");
      _newlineOpt();
      break;
    }
    JsStatement stmt=iter.next();
    needSemi=true;
    accept(stmt);
    if (needSemi) {
      if (stmt instanceof JsExprStmt && ((JsExprStmt)stmt).getExpression() instanceof JsFunction) {
        _newline();
      }
 else {
        _semi();
        _newlineOpt();
      }
    }
  }
  if (needBraces) {
    _blockClose();
  }
  needSemi=false;
}","protected void printJsBlockOptionalTruncate(JsBlock x,boolean truncate){
  boolean needBraces=!x.isGlobalBlock();
  if (needBraces) {
    _blockOpen();
  }
  int count=0;
  for (Iterator<JsStatement> iter=x.getStatements().iterator(); iter.hasNext(); ++count) {
    if (truncate && count > JSBLOCK_LINES_TO_PRINT) {
      p.print(""String_Node_Str"");
      _newlineOpt();
      break;
    }
    JsStatement stmt=iter.next();
    needSemi=true;
    accept(stmt);
    if (needSemi) {
      boolean functionStmt=stmt instanceof JsExprStmt && ((JsExprStmt)stmt).getExpression() instanceof JsFunction;
      boolean lastStatement=!iter.hasNext() && needBraces && !JsRequiresSemiVisitor.exec(stmt);
      if (functionStmt) {
        if (lastStatement) {
          _newlineOpt();
        }
 else {
          _newline();
        }
      }
 else {
        if (lastStatement) {
          _semiOpt();
        }
 else {
          _semi();
        }
        _newlineOpt();
      }
    }
  }
  if (needBraces) {
    _blockClose();
  }
  needSemi=false;
}"
82960,"public NameEnvironmentAnswer findType(char[][] compoundTypeName){
  String qname=CharOperation.toString(compoundTypeName);
  if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
    return (nameEnvironmentAnswerForTypeName.get(qname));
  }
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + qname + ""String_Node_Str"",null);
  if (sourceOracle.isPackage(qname)) {
    logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
    return null;
  }
  ByteCode byteCode=doGetByteCodeFromCache(logger,qname);
  if (byteCode != null) {
    byte[] classBytes=byteCode.getBytes();
    char[] loc=byteCode.getLocation().toCharArray();
    try {
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      ClassFileReader cfr=new ClassFileReader(classBytes,loc);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 catch (    ClassFormatException e) {
      String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
      compiler.problemReporter.abortDueToInternalError(msg);
      return null;
    }
  }
  int pos=qname.indexOf('$');
  if (pos >= 0) {
    qname=qname.substring(0,pos);
  }
  CompilationUnitProvider cup;
  try {
    cup=sourceOracle.findCompilationUnit(logger,qname);
    if (cup != null) {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + cup.getLocation(),null);
      ICompilationUnitAdapter unit=new ICompilationUnitAdapter(cup);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(unit,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 else {
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      return null;
    }
  }
 catch (  UnableToCompleteException e) {
    String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
    compiler.problemReporter.abortDueToInternalError(msg);
    return null;
  }
}","public NameEnvironmentAnswer findType(char[][] compoundTypeName){
  String qname=CharOperation.toString(compoundTypeName);
  if (nameEnvironmentAnswerForTypeName.containsKey(qname)) {
    return (nameEnvironmentAnswerForTypeName.get(qname));
  }
  TreeLogger logger=threadLogger.branch(TreeLogger.SPAM,""String_Node_Str"" + qname + ""String_Node_Str"",null);
  if (sourceOracle.isPackage(qname)) {
    logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
    return null;
  }
  ByteCode byteCode=doGetByteCodeFromCache(logger,qname);
  if (byteCode != null) {
    byte[] classBytes=byteCode.getBytes();
    char[] loc=byteCode.getLocation().toCharArray();
    try {
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      ClassFileReader cfr=new ClassFileReader(classBytes,loc);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 catch (    ClassFormatException e) {
      String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
      compiler.problemReporter.abortDueToInternalError(msg);
      return null;
    }
  }
  String className=qname;
  int pos=qname.indexOf('$');
  if (pos >= 0) {
    qname=qname.substring(0,pos);
  }
  CompilationUnitProvider cup;
  try {
    cup=sourceOracle.findCompilationUnit(logger,qname);
    if (cup != null) {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + cup.getLocation(),null);
      ICompilationUnitAdapter unit=new ICompilationUnitAdapter(cup);
      NameEnvironmentAnswer out=new NameEnvironmentAnswer(unit,null);
      nameEnvironmentAnswerForTypeName.put(qname,out);
      return out;
    }
 else {
      ClassLoader contextClassLoader=Thread.currentThread().getContextClassLoader();
      if (isBinaryType(contextClassLoader,className)) {
        URL resourceURL=contextClassLoader.getResource(className.replace('.','/') + ""String_Node_Str"");
        if (resourceURL != null) {
          byte[] classBytes=Util.readURLAsBytes(resourceURL);
          ClassFileReader cfr;
          try {
            cfr=new ClassFileReader(classBytes,null);
            NameEnvironmentAnswer out=new NameEnvironmentAnswer(cfr,null);
            nameEnvironmentAnswerForTypeName.put(qname,out);
            return out;
          }
 catch (          ClassFormatException e) {
          }
        }
      }
      logger.log(TreeLogger.SPAM,""String_Node_Str"",null);
      return null;
    }
  }
 catch (  UnableToCompleteException e) {
    String msg=""String_Node_Str"" + qname + ""String_Node_Str"";
    compiler.problemReporter.abortDueToInternalError(msg);
    return null;
  }
}"
82961,"/** 
 * Gets the   {@link SerializationPolicy} for given module base URL and strongname if there is one. Override this method to provide a  {@link SerializationPolicy} using analternative approach.
 * @param request the HTTP request being serviced
 * @param moduleBaseURL as specified in the incoming payload
 * @param strongName a strong name that uniquely identifies a serializationpolicy file
 * @return a {@link SerializationPolicy} for the given module base URL andstrong name, or <code>null</code> if there is none
 */
protected SerializationPolicy doGetSerializationPolicy(HttpServletRequest request,String moduleBaseURL,String strongName){
  String contextPath=request.getContextPath();
  String modulePath=null;
  if (moduleBaseURL != null) {
    try {
      modulePath=new URL(moduleBaseURL).getPath();
    }
 catch (    MalformedURLException ex) {
      getServletContext().log(""String_Node_Str"" + moduleBaseURL,ex);
    }
  }
  SerializationPolicy serializationPolicy=null;
  if (modulePath == null || !modulePath.startsWith(contextPath)) {
    String message=""String_Node_Str"" + modulePath + ""String_Node_Str""+ contextPath+ ""String_Node_Str"";
    getServletContext().log(message);
  }
 else {
    String contextRelativePath=modulePath.substring(contextPath.length());
    String serializationPolicyFilePath=SerializationPolicyLoader.getSerializationPolicyFileName(contextRelativePath + strongName);
    InputStream is=getServletContext().getResourceAsStream(serializationPolicyFilePath);
    try {
      if (is != null) {
        try {
          serializationPolicy=SerializationPolicyLoader.loadFromStream(is);
        }
 catch (        ParseException e) {
          getServletContext().log(""String_Node_Str"" + serializationPolicyFilePath + ""String_Node_Str"",e);
        }
catch (        ClassNotFoundException e) {
          getServletContext().log(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ serializationPolicyFilePath+ ""String_Node_Str""+ ""String_Node_Str"",e);
        }
catch (        IOException e) {
          getServletContext().log(""String_Node_Str"" + serializationPolicyFilePath + ""String_Node_Str"",e);
        }
      }
 else {
        String message=""String_Node_Str"" + serializationPolicyFilePath + ""String_Node_Str"";
        getServletContext().log(message);
      }
    }
  finally {
      if (is != null) {
        try {
          is.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  return serializationPolicy;
}","/** 
 * Gets the   {@link SerializationPolicy} for given module base URL and strongname if there is one. Override this method to provide a  {@link SerializationPolicy} using analternative approach.
 * @param request the HTTP request being serviced
 * @param moduleBaseURL as specified in the incoming payload
 * @param strongName a strong name that uniquely identifies a serializationpolicy file
 * @return a {@link SerializationPolicy} for the given module base URL andstrong name, or <code>null</code> if there is none
 */
protected SerializationPolicy doGetSerializationPolicy(HttpServletRequest request,String moduleBaseURL,String strongName){
  String contextPath=request.getContextPath();
  String modulePath=null;
  if (moduleBaseURL != null) {
    try {
      modulePath=new URL(moduleBaseURL).getPath();
    }
 catch (    MalformedURLException ex) {
      getServletContext().log(""String_Node_Str"" + moduleBaseURL,ex);
    }
  }
  SerializationPolicy serializationPolicy=null;
  if (modulePath == null || !modulePath.startsWith(contextPath)) {
    String message=""String_Node_Str"" + modulePath + ""String_Node_Str""+ contextPath+ ""String_Node_Str"";
    getServletContext().log(message);
  }
 else {
    String contextRelativePath=modulePath.substring(contextPath.length());
    String serializationPolicyFilePath=SerializationPolicyLoader.getSerializationPolicyFileName(contextRelativePath + strongName);
    InputStream is=getServletContext().getResourceAsStream(serializationPolicyFilePath);
    try {
      if (is != null) {
        try {
          serializationPolicy=SerializationPolicyLoader.loadFromStream(is,null);
        }
 catch (        ParseException e) {
          getServletContext().log(""String_Node_Str"" + serializationPolicyFilePath + ""String_Node_Str"",e);
        }
catch (        IOException e) {
          getServletContext().log(""String_Node_Str"" + serializationPolicyFilePath + ""String_Node_Str"",e);
        }
      }
 else {
        String message=""String_Node_Str"" + serializationPolicyFilePath + ""String_Node_Str"";
        getServletContext().log(message);
      }
    }
  finally {
      if (is != null) {
        try {
          is.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  return serializationPolicy;
}"
82962,"/** 
 * Loads a SerializationPolicy from an input stream.
 * @param inputStream stream to load from
 * @return a {@link SerializationPolicy} loaded from the input stream
 * @throws IOException if an error occurs while reading the stream
 * @throws ParseException if the input stream is not properly formatted
 * @throws ClassNotFoundException if a class specified in the serializationpolicy cannot be loaded
 */
public static SerializationPolicy loadFromStream(InputStream inputStream) throws IOException, ParseException, ClassNotFoundException {
  if (inputStream == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  Map<Class<?>,Boolean> whitelist=new HashMap<Class<?>,Boolean>();
  InputStreamReader isr=new InputStreamReader(inputStream,SERIALIZATION_POLICY_FILE_ENCODING);
  BufferedReader br=new BufferedReader(isr);
  String line=br.readLine();
  int lineNum=1;
  while (line != null) {
    line=line.trim();
    if (line.length() > 0) {
      String[] components=line.split(""String_Node_Str"");
      if (components.length != 2) {
        throw new ParseException(FORMAT_ERROR_MESSAGE,lineNum);
      }
      String binaryTypeName=components[0].trim();
      String instantiable=components[1].trim();
      if (binaryTypeName.length() == 0 || instantiable.length() == 0) {
        throw new ParseException(FORMAT_ERROR_MESSAGE,lineNum);
      }
      ClassLoader contextClassLoader=Thread.currentThread().getContextClassLoader();
      Class<?> clazz=Class.forName(binaryTypeName,false,contextClassLoader);
      whitelist.put(clazz,Boolean.valueOf(instantiable));
    }
    line=br.readLine();
    lineNum++;
  }
  return new StandardSerializationPolicy(whitelist);
}","/** 
 * Loads a SerializationPolicy from an input stream and optionally record any  {@link ClassNotFoundException}s.
 * @param inputStream stream to load the SerializationPolicy from.
 * @param classNotFoundExceptions if not <code>null</code>, all of the{@link ClassNotFoundException}s thrown while loading this serialization policy will be added to this list
 * @return a {@link SerializationPolicy} loaded from the input stream.
 * @throws IOException if an error occurs while reading the stream
 * @throws ParseException if the input stream is not properly formatted
 */
public static SerializationPolicy loadFromStream(InputStream inputStream,List<ClassNotFoundException> classNotFoundExceptions) throws IOException, ParseException {
  if (inputStream == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  Map<Class<?>,Boolean> whitelist=new HashMap<Class<?>,Boolean>();
  InputStreamReader isr=new InputStreamReader(inputStream,SERIALIZATION_POLICY_FILE_ENCODING);
  BufferedReader br=new BufferedReader(isr);
  String line=br.readLine();
  int lineNum=1;
  while (line != null) {
    line=line.trim();
    if (line.length() > 0) {
      String[] components=line.split(""String_Node_Str"");
      if (components.length != 2) {
        throw new ParseException(FORMAT_ERROR_MESSAGE,lineNum);
      }
      String binaryTypeName=components[0].trim();
      String instantiable=components[1].trim();
      if (binaryTypeName.length() == 0 || instantiable.length() == 0) {
        throw new ParseException(FORMAT_ERROR_MESSAGE,lineNum);
      }
      ClassLoader contextClassLoader=Thread.currentThread().getContextClassLoader();
      try {
        Class<?> clazz=Class.forName(binaryTypeName,false,contextClassLoader);
        whitelist.put(clazz,Boolean.valueOf(instantiable));
      }
 catch (      ClassNotFoundException ex) {
        if (classNotFoundExceptions != null) {
          classNotFoundExceptions.add(ex);
        }
      }
    }
    line=br.readLine();
    lineNum++;
  }
  return new StandardSerializationPolicy(whitelist);
}"
82963,"public void testPolicyFileTriggersClassNotFound() throws IOException, ParseException {
  InputStream is=getInputStreamFromString(POLICY_FILE_TRIGGERS_CLASSNOTFOUND);
  try {
    SerializationPolicyLoader.loadFromStream(is);
    fail(""String_Node_Str"");
  }
 catch (  ClassNotFoundException e) {
  }
}","public void testPolicyFileTriggersClassNotFound() throws IOException, ParseException {
  InputStream is=getInputStreamFromString(POLICY_FILE_TRIGGERS_CLASSNOTFOUND);
  try {
    SerializationPolicyLoader.loadFromStream(is);
    fail(""String_Node_Str"");
  }
 catch (  ClassNotFoundException e) {
  }
  is.reset();
  SerializationPolicyLoader.loadFromStream(is,null);
  List<ClassNotFoundException> classNotFoundExceptions=new ArrayList<ClassNotFoundException>();
  is.reset();
  SerializationPolicyLoader.loadFromStream(is,classNotFoundExceptions);
  assertEquals(1,classNotFoundExceptions.size());
  assertNotNull(classNotFoundExceptions.get(0));
}"
82964,"public void setHTML(String html){
  caption.setHTML(html);
}","/** 
 * Sets the html string inside the caption. Use   {@link #setWidget(Widget)} to set the contents inside the{@link DialogBox}.
 * @param html the object's new HTML
 */
public void setHTML(String html){
  caption.setHTML(html);
}"
82965,"public void setText(String text){
  caption.setText(text);
}","/** 
 * Sets the text inside the caption. Use   {@link #setWidget(Widget)} to set the contents inside the{@link DialogBox}.
 * @param text the object's new text
 */
public void setText(String text){
  caption.setText(text);
}"
82966,"public static <T>void fill(List<? super T> list,T obj){
  for (ListIterator<? super T> it=list.listIterator(); it.hasNext(); ) {
    it.set(obj);
  }
}","public static <T>void fill(List<? super T> list,T obj){
  for (ListIterator<? super T> it=list.listIterator(); it.hasNext(); ) {
    it.next();
    it.set(obj);
  }
}"
82967,"private void addCallArgs(Expression[] args,JMethodCall call,MethodBinding binding){
  if (args != null) {
    TypeBinding[] params=binding.parameters;
    int n=params.length;
    if (binding.isVarargs()) {
      --n;
    }
    for (int i=0; i < n; ++i) {
      call.getArgs().add(dispProcessExpression(args[i]));
    }
    if (binding.isVarargs()) {
      JArrayType type=(JArrayType)typeMap.get(params[n]);
      if (args.length == n + 1) {
        JType lastArgType=(JType)typeMap.get(args[n].resolvedType);
        if (lastArgType instanceof JArrayType) {
          JArrayType lastArgArrayType=(JArrayType)lastArgType;
          if (lastArgArrayType.getDims() == type.getDims()) {
            call.getArgs().add(dispProcessExpression(args[n]));
            return;
          }
        }
      }
      SourceInfo info=makeSourceInfo(args[n]);
      JNewArray newArray=new JNewArray(program,info,type);
      newArray.initializers=new ArrayList<JExpression>();
      for (int i=n; i < args.length; ++i) {
        newArray.initializers.add(dispProcessExpression(args[i]));
      }
      call.getArgs().add(newArray);
    }
  }
}","private void addCallArgs(Expression[] args,JMethodCall call,MethodBinding binding){
  if (args == null) {
    args=new Expression[0];
  }
  TypeBinding[] params=binding.parameters;
  int n=params.length;
  if (binding.isVarargs()) {
    --n;
  }
  if (args.length < n) {
    assert(call.getTarget().getName().equals(""String_Node_Str""));
    return;
  }
  ArrayList<JExpression> callArgs=call.getArgs();
  for (int i=0; i < n; ++i) {
    callArgs.add(dispProcessExpression(args[i]));
  }
  if (binding.isVarargs()) {
    JArrayType type=(JArrayType)typeMap.get(params[n]);
    if (args.length == n + 1) {
      JType lastArgType=(JType)typeMap.get(args[n].resolvedType);
      if (lastArgType instanceof JArrayType) {
        JArrayType lastArgArrayType=(JArrayType)lastArgType;
        if (lastArgArrayType.getDims() == type.getDims()) {
          callArgs.add(dispProcessExpression(args[n]));
          return;
        }
      }
    }
    JNewArray newArray=new JNewArray(program,call.getSourceInfo(),type);
    newArray.initializers=new ArrayList<JExpression>();
    for (int i=n; i < args.length; ++i) {
      newArray.initializers.add(dispProcessExpression(args[i]));
    }
    callArgs.add(newArray);
  }
}"
82968,"public void testVarargBoxing(){
  int[] ints=new int[]{1,2,3};
  int[] results=varargUnboxed(1,2,3);
  assertTrue(Arrays.equals(results,ints));
  int[] results2=varargUnboxed(new Integer(1),2,new Integer(3));
  assertTrue(Arrays.equals(ints,results2));
}","public void testVarargBoxing(){
  int[] expected=new int[]{1,2,3};
  int[] actual=varargUnboxed(1,2,3);
  assertTrue(Arrays.equals(expected,actual));
  actual=varargUnboxed(new Integer(1),2,new Integer(3));
  assertTrue(Arrays.equals(expected,actual));
  expected=new int[]{};
  actual=varargUnboxed();
  assertTrue(Arrays.equals(expected,actual));
}"
82969,"public void testVararg(){
  String[] strings=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String[] results=vararg(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertTrue(Arrays.equals(results,strings));
}","public void testVararg(){
  String[] expected=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String[] actual=vararg(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertTrue(Arrays.equals(expected,actual));
  expected=new String[]{};
  actual=vararg();
  assertTrue(Arrays.equals(expected,actual));
}"
82970,"void doItemAction(final MenuItem item,boolean fireCommand){
  if ((shownChildMenu != null) && (item.getSubMenu() == shownChildMenu)) {
    return;
  }
  if (shownChildMenu != null) {
    shownChildMenu.onHide();
    popup.hide();
  }
  if (item.getSubMenu() == null) {
    if (fireCommand) {
      closeAllParents();
      Command cmd=item.getCommand();
      if (cmd != null) {
        DeferredCommand.addCommand(cmd);
      }
    }
    return;
  }
  selectItem(item);
  popup=new PopupPanel(true){
{
      setWidget(item.getSubMenu());
      item.getSubMenu().onShow();
    }
    @Override public boolean onEventPreview(    Event event){
switch (DOM.eventGetType(event)) {
case Event.ONCLICK:
        Element target=DOM.eventGetTarget(event);
      Element parentMenuElement=item.getParentMenu().getElement();
    if (DOM.isOrHasChild(parentMenuElement,target)) {
      return false;
    }
  break;
}
return super.onEventPreview(event);
}
}
;
popup.addPopupListener(this);
if (vertical) {
popup.setPopupPosition(item.getAbsoluteLeft() + item.getOffsetWidth(),item.getAbsoluteTop());
}
 else {
popup.setPopupPosition(item.getAbsoluteLeft(),item.getAbsoluteTop() + item.getOffsetHeight());
}
shownChildMenu=item.getSubMenu();
item.getSubMenu().parentMenu=this;
popup.show();
}","void doItemAction(final MenuItem item,boolean fireCommand){
  if ((shownChildMenu != null) && (item.getSubMenu() == shownChildMenu)) {
    return;
  }
  if (shownChildMenu != null) {
    shownChildMenu.onHide();
    popup.hide();
  }
  if (item.getSubMenu() == null) {
    if (fireCommand) {
      closeAllParents();
      Command cmd=item.getCommand();
      if (cmd != null) {
        DeferredCommand.addCommand(cmd);
      }
    }
    return;
  }
  selectItem(item);
  popup=new PopupPanel(true){
{
      setWidget(item.getSubMenu());
      item.getSubMenu().onShow();
    }
    @Override public boolean onEventPreview(    Event event){
switch (DOM.eventGetType(event)) {
case Event.ONCLICK:
        Element target=DOM.eventGetTarget(event);
      Element parentMenuElement=item.getParentMenu().getElement();
    if (DOM.isOrHasChild(parentMenuElement,target)) {
      return false;
    }
  break;
}
return super.onEventPreview(event);
}
}
;
popup.addPopupListener(this);
if (vertical) {
popup.setPopupPosition(this.getAbsoluteLeft() + this.getOffsetWidth() - 1,item.getAbsoluteTop());
}
 else {
popup.setPopupPosition(item.getAbsoluteLeft(),this.getAbsoluteTop() + this.getOffsetHeight() - 1);
}
shownChildMenu=item.getSubMenu();
item.getSubMenu().parentMenu=this;
popup.show();
}"
82971,"/** 
 * Creates an empty menu bar.
 * @param vertical <code>true</code> to orient the menu bar vertically
 */
public MenuBar(boolean vertical){
  super();
  Element table=DOM.createTable();
  body=DOM.createTBody();
  DOM.appendChild(table,body);
  if (!vertical) {
    Element tr=DOM.createTR();
    DOM.appendChild(body,tr);
  }
  this.vertical=vertical;
  Element outer=DOM.createDiv();
  DOM.appendChild(outer,table);
  setElement(outer);
  sinkEvents(Event.ONCLICK | Event.ONMOUSEOVER | Event.ONMOUSEOUT);
  setStyleName(""String_Node_Str"");
}","/** 
 * Creates an empty menu bar.
 * @param vertical <code>true</code> to orient the menu bar vertically
 */
public MenuBar(boolean vertical){
  super();
  Element table=DOM.createTable();
  body=DOM.createTBody();
  DOM.appendChild(table,body);
  if (!vertical) {
    Element tr=DOM.createTR();
    DOM.appendChild(body,tr);
  }
  this.vertical=vertical;
  Element outer=DOM.createDiv();
  DOM.appendChild(outer,table);
  setElement(outer);
  sinkEvents(Event.ONCLICK | Event.ONMOUSEOVER | Event.ONMOUSEOUT);
  setStyleName(""String_Node_Str"");
  if (vertical) {
    addStyleName(""String_Node_Str"");
  }
 else {
    addStyleName(""String_Node_Str"");
  }
}"
82972,"public int compare(JType o1,JType o2){
  String n1=o1.getQualifiedSourceName();
  String n2=o2.getQualifiedSourceName();
  return n1.compareTo(n2);
}","public int compare(JClassType t1,JClassType t2){
  return t1.getQualifiedSourceName().compareTo(t2.getQualifiedSourceName());
}"
82973,"private static void logSerializableTypes(TreeLogger logger,JType[] types){
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + types.length + ""String_Node_Str""+ ((types.length == 1) ? ""String_Node_Str"" : ""String_Node_Str""),null);
  for (int i=0; i < types.length; ++i) {
    localLogger.branch(TreeLogger.DEBUG,types[i].getParameterizedQualifiedSourceName(),null);
  }
}","private static void logSerializableTypes(TreeLogger logger,Set<JClassType> fieldSerializableTypes){
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + fieldSerializableTypes.size() + ""String_Node_Str""+ ((fieldSerializableTypes.size() == 1) ? ""String_Node_Str"" : ""String_Node_Str""),null);
  for (  JClassType fieldSerializableType : fieldSerializableTypes) {
    localLogger.branch(TreeLogger.DEBUG,fieldSerializableType.getParameterizedQualifiedSourceName(),null);
  }
}"
82974,"private boolean checkTypeInstantiable(TreeLogger logger,JType type,boolean isSpeculative){
  assert(type != null);
  if (type.isPrimitive() != null) {
    return true;
  }
  assert(type instanceof JClassType);
  JClassType classType=(JClassType)type;
  if (classType.isGenericType() != null) {
    classType=classType.isGenericType().getRawType();
  }
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,classType.getParameterizedQualifiedSourceName(),null);
  TypeInfoComputed tic=getTypeInfoComputed(classType);
  if (tic.isPendingInstantiable()) {
    return true;
  }
 else   if (tic.isDone()) {
    return tic.isInstantiable();
  }
  tic.setPendingInstantiable();
  if (classType.getLeafType() == typeOracle.getJavaLangObject()) {
    markAsUninstantiableAndLog(logger,isSpeculative,""String_Node_Str"",tic);
    return false;
  }
  if (classType.isArray() != null) {
    return checkArrayInstantiable(logger,classType.isArray(),tic,isSpeculative);
  }
 else   if (classType.isWildcard() != null) {
    return checkWildcardInstantiable(logger,classType.isWildcard(),tic,isSpeculative);
  }
 else   if (classType.isClassOrInterface() != null) {
    TypeInfo typeInfo=getTypeInfo(classType);
    if (isSpeculative && typeInfo.isDirectlySerializable()) {
      isSpeculative=false;
    }
    boolean anySubtypes=false;
    if (checkClassOrInterfaceInstantiable(localLogger,classType,isSpeculative)) {
      tic.setInstantiable(true);
      anySubtypes=true;
    }
    if (classType.isParameterized() != null) {
      JParameterizedType parameterizedType=classType.isParameterized();
      if (!checkTypeArgumentsInstantiable(localLogger,parameterizedType,isSpeculative)) {
        return false;
      }
    }
 else     if (classType.isRawType() != null) {
      TreeLogger rawTypeLogger=logger.branch(TreeLogger.WARN,""String_Node_Str"" + classType.getQualifiedSourceName() + ""String_Node_Str"",null);
      if (classType.isAssignableTo(collectionClass) || classType.isAssignableTo(mapClass)) {
        checkAllSubtypesOfObject(rawTypeLogger);
      }
    }
    JClassType[] subtypes=classType.getSubtypes();
    if (subtypes.length > 0) {
      TreeLogger subLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
      for (      JClassType subType : subtypes) {
        if (checkClassOrInterfaceInstantiable(subLogger.branch(TreeLogger.DEBUG,subType.getParameterizedQualifiedSourceName(),null),subType,true)) {
          getTypeInfoComputed(subType).setInstantiable(true);
          anySubtypes=true;
        }
      }
    }
    if (!anySubtypes && !isSpeculative) {
      markAsUninstantiableAndLog(logger,isSpeculative,""String_Node_Str"" + classType.getParameterizedQualifiedSourceName() + ""String_Node_Str"",tic);
    }
    return anySubtypes;
  }
 else {
    assert(false);
    return false;
  }
}","private boolean checkTypeInstantiable(TreeLogger logger,JType type,boolean isSpeculative){
  assert(type != null);
  if (type.isPrimitive() != null) {
    return true;
  }
  assert(type instanceof JClassType);
  JClassType classType=(JClassType)type;
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,classType.getParameterizedQualifiedSourceName(),null);
  TypeInfoComputed tic=getTypeInfoComputed(classType);
  if (tic.isPendingInstantiable()) {
    return true;
  }
 else   if (tic.isDone()) {
    return tic.isInstantiable();
  }
  tic.setPendingInstantiable();
  if (classType.getLeafType() == typeOracle.getJavaLangObject()) {
    markAsUninstantiableAndLog(logger,isSpeculative,""String_Node_Str"",tic);
    return false;
  }
  if (classType.isArray() != null) {
    return checkArrayInstantiable(logger,classType.isArray(),tic,isSpeculative);
  }
 else   if (classType.isWildcard() != null) {
    return checkWildcardInstantiable(logger,classType.isWildcard(),tic,isSpeculative);
  }
 else   if (classType.isClassOrInterface() != null) {
    TypeInfo typeInfo=getTypeInfo(classType);
    if (isSpeculative && typeInfo.isDirectlySerializable()) {
      isSpeculative=false;
    }
    boolean anySubtypes=false;
    if (checkClassOrInterfaceInstantiable(localLogger,classType,isSpeculative)) {
      tic.setInstantiable(true);
      anySubtypes=true;
    }
    if (classType.isParameterized() != null) {
      JParameterizedType parameterizedType=classType.isParameterized();
      if (!checkTypeArgumentsInstantiable(localLogger,parameterizedType,isSpeculative)) {
        return false;
      }
    }
 else     if (classType.isRawType() != null) {
      TreeLogger rawTypeLogger=logger.branch(TreeLogger.WARN,""String_Node_Str"" + classType.getQualifiedSourceName() + ""String_Node_Str"",null);
      if (classType.isAssignableTo(collectionClass) || classType.isAssignableTo(mapClass)) {
        checkAllSubtypesOfObject(rawTypeLogger);
      }
    }
    JClassType[] subtypes=classType.getSubtypes();
    if (subtypes.length > 0) {
      TreeLogger subLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
      for (      JClassType subType : subtypes) {
        if (checkClassOrInterfaceInstantiable(subLogger.branch(TreeLogger.DEBUG,subType.getParameterizedQualifiedSourceName(),null),subType,true)) {
          getTypeInfoComputed(subType).setInstantiable(true);
          anySubtypes=true;
        }
      }
    }
    if (!anySubtypes && !isSpeculative) {
      markAsUninstantiableAndLog(logger,isSpeculative,""String_Node_Str"" + classType.getParameterizedQualifiedSourceName() + ""String_Node_Str"",tic);
    }
    return anySubtypes;
  }
 else {
    assert(false);
    return false;
  }
}"
82975,"/** 
 * Builds a   {@link SerializableTypeOracle} for a give{@link com.google.gwt.user.client.rpc.RemoteService} interface.
 * @param propertyOracle property oracle used for initializing properties
 * @param remoteService {@link com.google.gwt.user.client.rpc.RemoteService RemoteService}interface to build the oracle for
 * @return a {@link SerializableTypeOracle} for the specified{@link com.google.gwt.user.client.rpc.RemoteService RemoteService}interface
 * @throws UnableToCompleteException if the the remote service is consideredinvalid due to serialization problem or a missing or ill formed remote service asynchronous interface
 */
public SerializableTypeOracle build(PropertyOracle propertyOracle,JClassType remoteService) throws UnableToCompleteException {
  try {
    JClassType stringType=typeOracle.getType(String.class.getName());
    if (!checkTypeInstantiable(rootLogger,stringType,false)) {
      throw new UnableToCompleteException();
    }
    JClassType icseType=typeOracle.getType(IncompatibleRemoteServiceException.class.getName());
    if (!checkTypeInstantiable(rootLogger,icseType,false)) {
      throw new UnableToCompleteException();
    }
  }
 catch (  NotFoundException e) {
    rootLogger.log(TreeLogger.ERROR,null,e);
    throw new UnableToCompleteException();
  }
  TreeLogger logger=rootLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + remoteService.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
  alreadyCheckedObject=false;
  validateRemoteService(logger,remoteService);
  List<TypeInfoComputed> typeInfoComputed=new ArrayList<TypeInfoComputed>(typeToTypeInfoComputed.values());
  for (  TypeInfoComputed tic : typeInfoComputed) {
    if (tic.isInstantiable()) {
      JArrayType arrayType=tic.getType().isArray();
      if (arrayType != null) {
        JType leafType=arrayType.getLeafType();
        int rank=arrayType.getRank();
        JClassType classType=leafType.isClassOrInterface();
        if (classType != null) {
          List<JClassType> instantiableSubTypes=new ArrayList<JClassType>();
          JClassType[] subTypes=classType.getSubtypes();
          for (int i=0; i < subTypes.length; ++i) {
            if (getTypeInfoComputed(subTypes[i]).isInstantiable()) {
              instantiableSubTypes.add(subTypes[i]);
            }
          }
          List<JClassType> covariantTypes=getAllTypesBetweenRootTypeAndLeaves(classType,instantiableSubTypes);
          for (int i=0, c=covariantTypes.size(); i < c; ++i) {
            JArrayType covariantArray=getArrayType(typeOracle,rank,covariantTypes.get(i));
            getTypeInfoComputed(covariantArray).setInstantiable(true);
          }
        }
      }
    }
  }
  Set<JClassType> possiblyInstantiatedTypes=new HashSet<JClassType>();
  List<JClassType> serializableTypesList=new ArrayList<JClassType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    JClassType type=tic.getType();
    if (type.isTypeParameter() != null || type.isWildcard() != null) {
      continue;
    }
    if (type.isParameterized() != null) {
      type=type.isParameterized().getRawType();
    }
    if (tic.isInstantiable()) {
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      serializableTypesList.add(type);
    }
  }
  JClassType[] serializableTypes=new JClassType[serializableTypesList.size()];
  serializableTypesList.toArray(serializableTypes);
  Arrays.sort(serializableTypes,new Comparator<JType>(){
    public int compare(    JType o1,    JType o2){
      String n1=o1.getQualifiedSourceName();
      String n2=o2.getQualifiedSourceName();
      return n1.compareTo(n2);
    }
  }
);
  logSerializableTypes(logger,serializableTypes);
  return new SerializableTypeOracleImpl(typeOracle,serializableTypes,possiblyInstantiatedTypes);
}","/** 
 * Builds a   {@link SerializableTypeOracle} for a give{@link com.google.gwt.user.client.rpc.RemoteService} interface.
 * @param propertyOracle property oracle used for initializing properties
 * @param remoteService {@link com.google.gwt.user.client.rpc.RemoteService RemoteService}interface to build the oracle for
 * @return a {@link SerializableTypeOracle} for the specified{@link com.google.gwt.user.client.rpc.RemoteService RemoteService}interface
 * @throws UnableToCompleteException if the the remote service is consideredinvalid due to serialization problem or a missing or ill formed remote service asynchronous interface
 */
public SerializableTypeOracle build(PropertyOracle propertyOracle,JClassType remoteService) throws UnableToCompleteException {
  try {
    JClassType stringType=typeOracle.getType(String.class.getName());
    if (!checkTypeInstantiable(rootLogger,stringType,false)) {
      throw new UnableToCompleteException();
    }
    JClassType icseType=typeOracle.getType(IncompatibleRemoteServiceException.class.getName());
    if (!checkTypeInstantiable(rootLogger,icseType,false)) {
      throw new UnableToCompleteException();
    }
  }
 catch (  NotFoundException e) {
    rootLogger.log(TreeLogger.ERROR,null,e);
    throw new UnableToCompleteException();
  }
  TreeLogger logger=rootLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + remoteService.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
  alreadyCheckedObject=false;
  validateRemoteService(logger,remoteService);
  List<TypeInfoComputed> typeInfoComputed=new ArrayList<TypeInfoComputed>(typeToTypeInfoComputed.values());
  for (  TypeInfoComputed tic : typeInfoComputed) {
    if (tic.isInstantiable()) {
      JArrayType arrayType=tic.getType().isArray();
      if (arrayType != null) {
        JType leafType=arrayType.getLeafType();
        int rank=arrayType.getRank();
        JClassType classType=leafType.isClassOrInterface();
        if (classType != null) {
          List<JClassType> instantiableSubTypes=new ArrayList<JClassType>();
          JClassType[] subTypes=classType.getSubtypes();
          for (int i=0; i < subTypes.length; ++i) {
            if (getTypeInfoComputed(subTypes[i]).isInstantiable()) {
              instantiableSubTypes.add(subTypes[i]);
            }
          }
          List<JClassType> covariantTypes=getAllTypesBetweenRootTypeAndLeaves(classType,instantiableSubTypes);
          for (int i=0, c=covariantTypes.size(); i < c; ++i) {
            JArrayType covariantArray=getArrayType(typeOracle,rank,covariantTypes.get(i));
            getTypeInfoComputed(covariantArray).setInstantiable(true);
          }
        }
      }
    }
  }
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JCLASS_TYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JCLASS_TYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    JClassType type=tic.getType();
    if (type.isTypeParameter() != null || type.isWildcard() != null) {
      continue;
    }
    if (type.isParameterized() != null) {
      type=type.isParameterized().getRawType();
    }
 else     if (type.isGenericType() != null) {
      type=type.isGenericType().getRawType();
    }
    if (tic.isInstantiable()) {
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      fieldSerializableTypes.add(type);
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(typeOracle,fieldSerializableTypes,possiblyInstantiatedTypes);
}"
82976,"public int compare(JType t1,JType t2){
  return t1.getParameterizedQualifiedSourceName().compareTo(t2.getParameterizedQualifiedSourceName());
}","public int compare(JField f1,JField f2){
  return f1.getName().compareTo(f2.getName());
}"
82977,"public SerializableTypeOracleImpl(TypeOracle typeOracle,JClassType[] serializableTypes,Set<JClassType> possiblyInstantiatedTypes){
  serializableTypesSet=new TreeSet<JClassType>(TYPE_COMPARATOR);
  serializableTypesSet.addAll(Arrays.asList(serializableTypes));
  this.typeOracle=typeOracle;
  this.possiblyInstantiatedTypes=possiblyInstantiatedTypes;
}","public SerializableTypeOracleImpl(TypeOracle typeOracle,Set<JClassType> serializableTypes,Set<JClassType> possiblyInstantiatedTypes){
  serializableTypesSet=serializableTypes;
  this.typeOracle=typeOracle;
  this.possiblyInstantiatedTypes=possiblyInstantiatedTypes;
}"
82978,"@Override public String getPurpose(){
  return ""String_Node_Str"" + ""String_Node_Str"";
}","@Override public String getPurpose(){
  return ""String_Node_Str"";
}"
82979,"/** 
 * @param fullInterfaceName Name of the fully-qualified Java class to createas an Application.
 * @param outDir Where to put the output files
 * @param eclipse The name of a project to attach a .launch config to
 * @param overwrite Overwrite an existing files if they exist.
 * @param ignore Ignore existing files if they exist.
 * @throws IOException
 */
static void createLocalizable(String fullInterfaceName,File outDir,String eclipse,boolean createMessagesInterface,boolean overwrite,boolean ignore) throws IOException {
  String installPath=Utility.getInstallPath();
  String gwtUserPath=installPath + '/' + ""String_Node_Str"";
  String gwtDevPath=installPath + '/' + Utility.getDevJarName();
  boolean isWindows=gwtDevPath.substring(gwtDevPath.lastIndexOf('/') + 1).indexOf(""String_Node_Str"") >= 0;
  String basePathEnv;
  if (!new File(installPath).isAbsolute()) {
    if (isWindows) {
      basePathEnv=""String_Node_Str"";
    }
 else {
      basePathEnv=""String_Node_Str"";
    }
  }
 else {
    basePathEnv=""String_Node_Str"";
  }
  int pos=fullInterfaceName.lastIndexOf('.');
  String clientPackageName=fullInterfaceName.substring(0,pos);
  String interfaceName=fullInterfaceName.substring(pos + 1);
  pos=clientPackageName.lastIndexOf('.');
  File clientDir=Utility.getDirectory(outDir,""String_Node_Str"",true);
  if (pos >= 0) {
    String clientPackage=clientPackageName.replace('.','/');
    clientDir=Utility.getDirectory(clientDir,clientPackage,true);
  }
  Map<String,String> replacements=new HashMap<String,String>();
  replacements.put(""String_Node_Str"",fullInterfaceName);
  replacements.put(""String_Node_Str"",interfaceName);
  replacements.put(""String_Node_Str"",basePathEnv + gwtUserPath);
  replacements.put(""String_Node_Str"",basePathEnv + gwtDevPath);
  replacements.put(""String_Node_Str"",""String_Node_Str"");
  replacements.put(""String_Node_Str"",""String_Node_Str"");
  if (createMessagesInterface) {
    replacements.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    replacements.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (createMessagesInterface) {
    File i18nMessageProperties=Utility.createNormalFile(clientDir,interfaceName + ""String_Node_Str"",overwrite,ignore);
    if (i18nMessageProperties != null) {
      String out=Utility.getFileFromClassPath(PACKAGE_PATH + ""String_Node_Str"");
      Utility.writeTemplateFile(i18nMessageProperties,out,replacements);
    }
  }
 else {
    File i18nConstantProperties=Utility.createNormalFile(clientDir,interfaceName + ""String_Node_Str"",overwrite,ignore);
    if (i18nConstantProperties != null) {
      String out=Utility.getFileFromClassPath(PACKAGE_PATH + ""String_Node_Str"");
      Utility.writeTemplateFile(i18nConstantProperties,out,replacements);
    }
  }
  if (eclipse != null) {
    replacements.put(""String_Node_Str"",eclipse);
    File updateLaunchConfig=Utility.createNormalFile(outDir,interfaceName + ""String_Node_Str"" + ""String_Node_Str"",overwrite,ignore);
    if (updateLaunchConfig != null) {
      String out=Utility.getFileFromClassPath(PACKAGE_PATH + ""String_Node_Str"");
      Utility.writeTemplateFile(updateLaunchConfig,out,replacements);
    }
  }
  String extension;
  if (isWindows) {
    extension=""String_Node_Str"";
  }
 else {
    extension=""String_Node_Str"";
  }
  File gwti18n=Utility.createNormalFile(outDir,interfaceName + ""String_Node_Str"" + extension,overwrite,ignore);
  if (gwti18n != null) {
    String out=Utility.getFileFromClassPath(PACKAGE_PATH + ""String_Node_Str"" + extension+ ""String_Node_Str"");
    Utility.writeTemplateFile(gwti18n,out,replacements);
    if (extension.length() == 0) {
      Runtime.getRuntime().exec(""String_Node_Str"" + gwti18n.getAbsolutePath());
    }
  }
}","/** 
 * @param fullInterfaceName Name of the fully-qualified Java class to createas an Application.
 * @param outDir Where to put the output files
 * @param eclipse The name of a project to attach a .launch config to
 * @param overwrite Overwrite an existing files if they exist.
 * @param ignore Ignore existing files if they exist.
 * @param interfaceToCreate the class instance to create - Constants,ConstantsWithLookup, or Messages
 * @throws IOException
 */
static void createLocalizable(String fullInterfaceName,File outDir,String eclipse,boolean overwrite,boolean ignore,Class<? extends Localizable> interfaceToCreate) throws IOException {
  String installPath=Utility.getInstallPath();
  String gwtUserPath=installPath + '/' + ""String_Node_Str"";
  String gwtDevPath=installPath + '/' + Utility.getDevJarName();
  boolean isWindows=gwtDevPath.substring(gwtDevPath.lastIndexOf('/') + 1).indexOf(""String_Node_Str"") >= 0;
  String basePathEnv;
  if (!new File(installPath).isAbsolute()) {
    if (isWindows) {
      basePathEnv=""String_Node_Str"";
    }
 else {
      basePathEnv=""String_Node_Str"";
    }
  }
 else {
    basePathEnv=""String_Node_Str"";
  }
  int pos=fullInterfaceName.lastIndexOf('.');
  String clientPackageName=fullInterfaceName.substring(0,pos);
  String interfaceName=fullInterfaceName.substring(pos + 1);
  pos=clientPackageName.lastIndexOf('.');
  File clientDir=Utility.getDirectory(outDir,""String_Node_Str"",true);
  if (pos >= 0) {
    String clientPackage=clientPackageName.replace('.','/');
    clientDir=Utility.getDirectory(clientDir,clientPackage,true);
  }
  Map<String,String> replacements=new HashMap<String,String>();
  replacements.put(""String_Node_Str"",fullInterfaceName);
  replacements.put(""String_Node_Str"",interfaceName);
  replacements.put(""String_Node_Str"",basePathEnv + gwtUserPath);
  replacements.put(""String_Node_Str"",basePathEnv + gwtDevPath);
  replacements.put(""String_Node_Str"",""String_Node_Str"");
  replacements.put(""String_Node_Str"",""String_Node_Str"");
  String templateData=null;
  if (Messages.class == interfaceToCreate) {
    replacements.put(""String_Node_Str"",""String_Node_Str"");
    templateData=Utility.getFileFromClassPath(PACKAGE_PATH + ""String_Node_Str"");
  }
 else {
    if (ConstantsWithLookup.class == interfaceToCreate) {
      replacements.put(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (Constants.class == interfaceToCreate) {
      replacements.put(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + interfaceToCreate.getName());
    }
    templateData=Utility.getFileFromClassPath(PACKAGE_PATH + ""String_Node_Str"");
  }
  File i18nPropertiesFile=Utility.createNormalFile(clientDir,interfaceName + ""String_Node_Str"",overwrite,ignore);
  if (i18nPropertiesFile != null && templateData != null) {
    Utility.writeTemplateFile(i18nPropertiesFile,templateData,replacements);
  }
  if (eclipse != null) {
    replacements.put(""String_Node_Str"",eclipse);
    File updateLaunchConfig=Utility.createNormalFile(outDir,interfaceName + ""String_Node_Str"" + ""String_Node_Str"",overwrite,ignore);
    if (updateLaunchConfig != null) {
      String out=Utility.getFileFromClassPath(PACKAGE_PATH + ""String_Node_Str"");
      Utility.writeTemplateFile(updateLaunchConfig,out,replacements);
    }
  }
  String extension;
  if (isWindows) {
    extension=""String_Node_Str"";
  }
 else {
    extension=""String_Node_Str"";
  }
  File gwti18n=Utility.createNormalFile(outDir,interfaceName + ""String_Node_Str"" + extension,overwrite,ignore);
  if (gwti18n != null) {
    String out=Utility.getFileFromClassPath(PACKAGE_PATH + ""String_Node_Str"" + extension+ ""String_Node_Str"");
    Utility.writeTemplateFile(gwti18n,out,replacements);
    if (extension.length() == 0) {
      Runtime.getRuntime().exec(""String_Node_Str"" + gwti18n.getAbsolutePath());
    }
  }
}"
82980,"protected boolean run(){
  try {
    createLocalizable(fullInterfaceName,outDir,eclipse,createMessagesInterface,overwrite,ignore);
    return true;
  }
 catch (  IOException e) {
    System.err.println(e.getClass().getName() + ""String_Node_Str"" + e.getMessage());
    return false;
  }
}","protected boolean run(){
  try {
    createLocalizable(fullInterfaceName,outDir,eclipse,overwrite,ignore,chooser.getArgValue());
    return true;
  }
 catch (  IOException e) {
    System.err.println(e.getClass().getName() + ""String_Node_Str"" + e.getMessage());
    return false;
  }
}"
82981,"protected I18NCreator(){
  registerHandler(new ArgHandlerEclipse(){
    @Override public String getPurpose(){
      return ""String_Node_Str"";
    }
    @Override public boolean setString(    String str){
      eclipse=str;
      return true;
    }
  }
);
  registerHandler(new ArgHandlerOutDir(){
    @Override public void setDir(    File dir){
      outDir=dir;
    }
  }
);
  registerHandler(new ArgHandlerOverwrite(){
    @Override public boolean setFlag(){
      if (ignore) {
        System.err.println(""String_Node_Str"");
        return false;
      }
      overwrite=true;
      return true;
    }
  }
);
  registerHandler(new ArgHandlerFlag(){
    @Override public String getPurpose(){
      return ""String_Node_Str"" + ""String_Node_Str"";
    }
    @Override public String getTag(){
      return ""String_Node_Str"";
    }
    @Override public boolean setFlag(){
      createMessagesInterface=true;
      return true;
    }
  }
);
  registerHandler(new ArgHandlerIgnore(){
    @Override public boolean setFlag(){
      if (overwrite) {
        System.err.println(""String_Node_Str"");
        return false;
      }
      ignore=true;
      return true;
    }
  }
);
  registerHandler(new ArgHandlerClassName());
}","protected I18NCreator(){
  registerHandler(new ArgHandlerEclipse(){
    @Override public String getPurpose(){
      return ""String_Node_Str"";
    }
    @Override public boolean setString(    String str){
      eclipse=str;
      return true;
    }
  }
);
  registerHandler(new ArgHandlerOutDir(){
    @Override public void setDir(    File dir){
      outDir=dir;
    }
  }
);
  registerHandler(new ArgHandlerOverwrite(){
    @Override public boolean setFlag(){
      if (ignore) {
        System.err.println(""String_Node_Str"");
        return false;
      }
      overwrite=true;
      return true;
    }
  }
);
  chooser=new ArgHandlerValueChooser();
  registerHandler(chooser.getConstantsWithLookupArgHandler());
  registerHandler(chooser.getMessagesArgHandler());
  registerHandler(new ArgHandlerIgnore(){
    @Override public boolean setFlag(){
      if (overwrite) {
        System.err.println(""String_Node_Str"");
        return false;
      }
      ignore=true;
      return true;
    }
  }
);
  registerHandler(new ArgHandlerClassName());
}"
82982,"private boolean execImpl(){
  boolean madeChanges=false;
  while (true) {
    RescueVisitor rescuer=new RescueVisitor();
    rescuer.rescue(program.getIndexedType(""String_Node_Str""),true,true);
    for (    JReferenceType type : program.codeGenTypes) {
      rescuer.rescue(type,true,saveCodeGenTypes);
    }
    for (    JMethod method : program.entryMethods) {
      rescuer.rescue(method);
    }
    UpRefVisitor upRefer=new UpRefVisitor(rescuer);
    do {
      rescuer.commitInstantiatedTypes();
      upRefer.accept(program);
    }
 while (upRefer.didRescue());
    PruneVisitor pruner=new PruneVisitor();
    pruner.accept(program);
    if (!pruner.didChange()) {
      break;
    }
    CleanupRefsVisitor cleaner=new CleanupRefsVisitor();
    cleaner.accept(program);
    referencedTypes.clear();
    referencedNonTypes.clear();
    removedMethodParamsMap.clear();
    madeChanges=true;
  }
  return madeChanges;
}","private boolean execImpl(){
  boolean madeChanges=false;
  while (true) {
    RescueVisitor rescuer=new RescueVisitor();
    rescuer.rescue(program.getIndexedType(""String_Node_Str""),true,true);
    for (    JReferenceType type : program.codeGenTypes) {
      rescuer.rescue(type,true,saveCodeGenTypes);
    }
    for (    JMethod method : program.entryMethods) {
      rescuer.rescue(method);
    }
    UpRefVisitor upRefer=new UpRefVisitor(rescuer);
    do {
      rescuer.commitInstantiatedTypes();
      upRefer.accept(program);
    }
 while (upRefer.didRescue());
    PruneVisitor pruner=new PruneVisitor();
    pruner.accept(program);
    if (!pruner.didChange()) {
      break;
    }
    CleanupRefsVisitor cleaner=new CleanupRefsVisitor();
    cleaner.accept(program);
    referencedTypes.clear();
    referencedNonTypes.clear();
    methodToOriginalParamsMap.clear();
    madeChanges=true;
  }
  return madeChanges;
}"
82983,"/** 
 * Replace the current input element with a new one.
 * @param elem the new input element
 */
protected void replaceInputElement(Element elem){
  int tabIndex=getTabIndex();
  boolean checked=isChecked();
  boolean enabled=isEnabled();
  String uid=DOM.getElementProperty(inputElem,""String_Node_Str"");
  String accessKey=DOM.getElementProperty(inputElem,""String_Node_Str"");
  setChecked(false);
  DOM.setElementProperty(inputElem,""String_Node_Str"",""String_Node_Str"");
  DOM.setElementProperty(inputElem,""String_Node_Str"",""String_Node_Str"");
  DOM.removeChild(getElement(),inputElem);
  DOM.insertChild(getElement(),elem,0);
  inputElem=elem;
  DOM.sinkEvents(inputElem,DOM.getEventsSunk(this.getElement()));
  DOM.setEventListener(inputElem,this);
  DOM.setElementProperty(inputElem,""String_Node_Str"",uid);
  if (accessKey != ""String_Node_Str"") {
    DOM.setElementProperty(inputElem,""String_Node_Str"",accessKey);
  }
  setTabIndex(tabIndex);
  setChecked(checked);
  setEnabled(enabled);
}","/** 
 * Replace the current input element with a new one.
 * @param elem the new input element
 */
protected void replaceInputElement(Element elem){
  int tabIndex=getTabIndex();
  boolean checked=isChecked();
  boolean enabled=isEnabled();
  String uid=DOM.getElementProperty(inputElem,""String_Node_Str"");
  String accessKey=DOM.getElementProperty(inputElem,""String_Node_Str"");
  setChecked(false);
  DOM.setElementProperty(inputElem,""String_Node_Str"",""String_Node_Str"");
  DOM.setElementProperty(inputElem,""String_Node_Str"",""String_Node_Str"");
  DOM.setEventListener(inputElem,null);
  DOM.removeChild(getElement(),inputElem);
  DOM.insertChild(getElement(),elem,0);
  DOM.sinkEvents(elem,DOM.getEventsSunk(inputElem));
  DOM.sinkEvents(inputElem,0);
  inputElem=elem;
  DOM.setElementProperty(inputElem,""String_Node_Str"",uid);
  if (accessKey != ""String_Node_Str"") {
    DOM.setElementProperty(inputElem,""String_Node_Str"",accessKey);
  }
  setTabIndex(tabIndex);
  setChecked(checked);
  setEnabled(enabled);
  if (isAttached()) {
    DOM.setEventListener(inputElem,this);
  }
}"
82984,"/** 
 * Sets the currently selected index. <p> Note that setting the selected index programmatically does <em>not</em> cause the   {@link ChangeListener#onChange(Widget)} event to be fired.</p>
 * @param index the index of the item to be selected
 */
public void setSelectedIndex(int index){
  DOM.setElementPropertyInt(getElement(),""String_Node_Str"",index);
}","/** 
 * Sets the currently selected index. After calling this method, only the specified item in the list will remain selected.  For a ListBox with multiple selection enabled, see  {@link #setItemSelected(int,boolean)} to select multiple items at a time.<p> Note that setting the selected index programmatically does <em>not</em> cause the  {@link ChangeListener#onChange(Widget)} event to be fired.</p>
 * @param index the index of the item to be selected
 */
public void setSelectedIndex(int index){
  DOM.setElementPropertyInt(getElement(),""String_Node_Str"",index);
}"
82985,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(AutoboxTest.class);
  suite.addTestSuite(ClassCastTestCase.class);
  suite.addTestSuite(ClassObjectTest.class);
  suite.addTestSuite(CompilerTest.class);
  suite.addTestSuite(Coverage.class);
  suite.addTestSuite(EnhancedForLoopTest.class);
  suite.addTestSuite(EnumsTest.class);
  suite.addTestSuite(HostedTest.class);
  suite.addTestSuite(InnerClassTest.class);
  suite.addTestSuite(InnerOuterSuperTest.class);
  suite.addTestSuite(MemberShadowingTest.class);
  suite.addTestSuite(MethodBindTest.class);
  suite.addTestSuite(MethodCallTest.class);
  suite.addTestSuite(MethodInterfaceTest.class);
  suite.addTestSuite(MiscellaneousTest.class);
  suite.addTestSuite(NativeLongTest.class);
  suite.addTestSuite(TestBlankInterface.class);
  suite.addTestSuite(VarargsTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(AutoboxTest.class);
  suite.addTestSuite(ClassCastTest.class);
  suite.addTestSuite(ClassObjectTest.class);
  suite.addTestSuite(CompilerTest.class);
  suite.addTestSuite(CoverageTest.class);
  suite.addTestSuite(EnhancedForLoopTest.class);
  suite.addTestSuite(EnumsTest.class);
  suite.addTestSuite(HostedTest.class);
  suite.addTestSuite(InnerClassTest.class);
  suite.addTestSuite(InnerOuterSuperTest.class);
  suite.addTestSuite(MemberShadowingTest.class);
  suite.addTestSuite(MethodBindTest.class);
  suite.addTestSuite(MethodCallTest.class);
  suite.addTestSuite(MethodInterfaceTest.class);
  suite.addTestSuite(MiscellaneousTest.class);
  suite.addTestSuite(NativeLongTest.class);
  suite.addTestSuite(BlankInterfaceTest.class);
  suite.addTestSuite(VarargsTest.class);
  return suite;
}"
82986,"public void testGenerics(){
  String s=genericSimple(""String_Node_Str"");
  assertEquals(""String_Node_Str"",s);
  String v=genericGet(s);
  assertEquals(""String_Node_Str"",v);
  List<String> list=new ArrayList<String>();
  list.add(""String_Node_Str"");
  Object obj=genericWildcard(list);
  assertTrue(obj instanceof String);
  assertEquals(""String_Node_Str"",obj);
  obj=genericSubtype(""String_Node_Str"");
  List<Object> list2=genericSubtype(new GenericListTest());
  assertTrue(list2 instanceof GenericListTest);
  assertEquals(42,list2.size());
  assertEquals(list2,list2.get(0));
  String[] array=new String[]{""String_Node_Str"",""String_Node_Str""};
  String[] ret=genericArray(array);
  assertEquals(2,ret.length);
  assertEquals(""String_Node_Str"",ret[1]);
  assertTrue(Arrays.deepEquals(array,ret));
}","public void testGenerics(){
  String s=genericSimple(""String_Node_Str"");
  assertEquals(""String_Node_Str"",s);
  String v=genericGet(s);
  assertEquals(""String_Node_Str"",v);
  List<String> list=new ArrayList<String>();
  list.add(""String_Node_Str"");
  Object obj=genericWildcard(list);
  assertTrue(obj instanceof String);
  assertEquals(""String_Node_Str"",obj);
  obj=genericSubtype(""String_Node_Str"");
  List<Object> list2=genericSubtype(new TestGenericList());
  assertTrue(list2 instanceof TestGenericList);
  assertEquals(42,list2.size());
  assertEquals(list2,list2.get(0));
  String[] array=new String[]{""String_Node_Str"",""String_Node_Str""};
  String[] ret=genericArray(array);
  assertEquals(2,ret.length);
  assertEquals(""String_Node_Str"",ret[1]);
  assertTrue(Arrays.deepEquals(array,ret));
}"
82987,"private static <E extends Enum<E>>void enumTests(Class<E> e){
  E[] enums=e.getEnumConstants();
  EnumMap<E,Integer> numbers=new EnumMap<E,Integer>(e);
  HashMap<E,Integer> numberMap=new HashMap<E,Integer>();
  assertEquals(numberMap,numbers);
  numbers.put(enums[1],1);
  numberMap.put(enums[1],1);
  numbers.put(enums[2],2);
  numberMap.put(enums[2],2);
  assertEquals(numberMap,numbers);
  numbers.put(enums[23],23);
  numberMap.put(enums[23],23);
  assertEquals(numberMap,numbers);
  numbers.remove(enums[1]);
  numberMap.remove(enums[1]);
  assertEquals(numberMap,numbers);
  numbers.put(enums[0],0);
  numberMap.put(enums[0],0);
  assertEquals(numberMap,numbers);
  numbers.put(enums[enums.length - 1],enums.length - 1);
  numberMap.put(enums[enums.length - 1],enums.length - 1);
  assertEquals(numberMap,numbers);
  numbers.remove(enums[15]);
  numberMap.remove(enums[15]);
  assertEquals(numberMap,numbers);
  numbers.put(enums[23],23);
  numberMap.put(enums[23],23);
  assertEquals(numberMap,numbers);
  numbers.clear();
  numberMap.clear();
  for (  E val : enums) {
    numbers.put(val,val.ordinal());
    numberMap.put(val,val.ordinal());
  }
  assertEquals(numberMap,numbers);
  assertEquals(numberMap,numbers.clone());
  assertEquals(numberMap,new EnumMap<E,Integer>(numberMap));
  Set<Map.Entry<E,Integer>> numbersEntrySet=numbers.entrySet();
  Set<Map.Entry<E,Integer>> mapEntrySet=numberMap.entrySet();
  assertEquals(mapEntrySet,numbersEntrySet);
  Map.Entry<E,Integer> entry=numbers.entrySet().iterator().next();
  numbersEntrySet.remove(entry);
  mapEntrySet.remove(entry);
  assertEquals(mapEntrySet,numbersEntrySet);
  assertEquals(numberMap,numbers);
  Set<E> numbersKeySet=numbers.keySet();
  Set<E> mapKeySet=numberMap.keySet();
  assertEquals(mapKeySet,numbersKeySet);
  numbersKeySet.remove(enums[2]);
  mapKeySet.remove(enums[2]);
  assertEquals(mapKeySet,numbersKeySet);
  assertEquals(numberMap,numbers);
  Collection<Integer> numbersValues=numbers.values();
  Collection<Integer> mapValues=numberMap.values();
  assertEquals(sort(mapValues),sort(numbersValues));
  numbersValues.remove(23);
  mapValues.remove(23);
  assertEquals(sort(mapValues),sort(numbersValues));
  assertEquals(numberMap,numbers);
}","private static <E extends Enum<E>>void enumTests(Class<E> e){
  E[] enums=e.getEnumConstants();
  EnumMap<E,Integer> numbers=new EnumMap<E,Integer>(e);
  HashMap<E,Integer> numberMap=new HashMap<E,Integer>();
  assertEquals(numberMap,numbers);
  numbers.put(enums[1],1);
  numberMap.put(enums[1],1);
  numbers.put(enums[2],2);
  numberMap.put(enums[2],2);
  assertEquals(numberMap,numbers);
  numbers.put(enums[23],23);
  numberMap.put(enums[23],23);
  assertEquals(numberMap,numbers);
  numbers.remove(enums[1]);
  numberMap.remove(enums[1]);
  assertEquals(numberMap,numbers);
  numbers.put(enums[0],0);
  numberMap.put(enums[0],0);
  assertEquals(numberMap,numbers);
  numbers.put(enums[enums.length - 1],enums.length - 1);
  numberMap.put(enums[enums.length - 1],enums.length - 1);
  assertEquals(numberMap,numbers);
  numbers.remove(enums[15]);
  numberMap.remove(enums[15]);
  assertEquals(numberMap,numbers);
  numbers.put(enums[23],23);
  numberMap.put(enums[23],23);
  assertEquals(numberMap,numbers);
  numbers.clear();
  numberMap.clear();
  for (  E val : enums) {
    numbers.put(val,val.ordinal());
    numberMap.put(val,val.ordinal());
  }
  assertEquals(numberMap,numbers);
  assertEquals(numberMap,numbers.clone());
  assertEquals(numberMap,new EnumMap<E,Integer>(numberMap));
  Set<Map.Entry<E,Integer>> numbersEntrySet=numbers.entrySet();
  Set<Map.Entry<E,Integer>> mapEntrySet=numberMap.entrySet();
  assertEquals(mapEntrySet,numbersEntrySet);
  final Map.Entry<E,Integer> entry=numbers.entrySet().iterator().next();
  Map.Entry<E,Integer> entryCopy=new Map.Entry<E,Integer>(){
    E key=entry.getKey();
    Integer value=entry.getValue();
    public E getKey(){
      return key;
    }
    public Integer getValue(){
      return value;
    }
    public Integer setValue(    Integer value){
      Integer oldValue=this.value;
      this.value=value;
      return oldValue;
    }
  }
;
  numbersEntrySet.remove(entry);
  mapEntrySet.remove(entryCopy);
  assertEquals(mapEntrySet,numbersEntrySet);
  assertEquals(numberMap,numbers);
  Set<E> numbersKeySet=numbers.keySet();
  Set<E> mapKeySet=numberMap.keySet();
  assertEquals(mapKeySet,numbersKeySet);
  numbersKeySet.remove(enums[2]);
  mapKeySet.remove(enums[2]);
  assertEquals(mapKeySet,numbersKeySet);
  assertEquals(numberMap,numbers);
  Collection<Integer> numbersValues=numbers.values();
  Collection<Integer> mapValues=numberMap.values();
  assertEquals(sort(mapValues),sort(numbersValues));
  numbersValues.remove(23);
  mapValues.remove(23);
  assertEquals(sort(mapValues),sort(numbersValues));
  assertEquals(numberMap,numbers);
}"
82988,"protected final CompilationUnitDeclaration[] compile(TreeLogger logger,ICompilationUnit[] units){
  threadLogger.set(logger);
  Set<CompilationUnitDeclaration> cuds=new HashSet<CompilationUnitDeclaration>();
  compiler.compile(units,cuds);
  int size=cuds.size();
  CompilationUnitDeclaration[] cudArray=new CompilationUnitDeclaration[size];
  return cuds.toArray(cudArray);
}","protected final CompilationUnitDeclaration[] compile(TreeLogger logger,ICompilationUnit[] units){
  TreeLogger oldLogger=threadLogger.push(logger);
  try {
    Set<CompilationUnitDeclaration> cuds=new HashSet<CompilationUnitDeclaration>();
    compiler.compile(units,cuds);
    int size=cuds.size();
    CompilationUnitDeclaration[] cudArray=new CompilationUnitDeclaration[size];
    return cuds.toArray(cudArray);
  }
  finally {
    threadLogger.pop(oldLogger);
  }
}"
82989,"/** 
 * Get the bytecode for the specified type.
 * @param binaryTypeName the binary type name to look up or compile
 */
public byte[] getClassBytes(TreeLogger logger,String binaryTypeName) throws UnableToCompleteException {
  String msg=""String_Node_Str"" + binaryTypeName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.SPAM,msg,null);
  setLogger(logger);
  ByteCode byteCode=doGetByteCodeFromCache(logger,binaryTypeName);
  if (byteCode != null) {
    return byteCode.getBytes();
  }
  ICompilationUnit start=getCompilationUnitForType(logger,binaryTypeName);
  compile(logger,new ICompilationUnit[]{start});
  byteCode=doGetByteCodeFromCache(logger,binaryTypeName);
  if (byteCode != null) {
    return byteCode.getBytes();
  }
 else {
    throw new UnableToCompleteException();
  }
}","/** 
 * Get the bytecode for the specified type.
 * @param binaryTypeName the binary type name to look up or compile
 */
public byte[] getClassBytes(TreeLogger logger,String binaryTypeName) throws UnableToCompleteException {
  String msg=""String_Node_Str"" + binaryTypeName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.SPAM,msg,null);
  TreeLogger oldLogger=threadLogger.push(logger);
  try {
    ByteCode byteCode=doGetByteCodeFromCache(logger,binaryTypeName);
    if (byteCode != null) {
      return byteCode.getBytes();
    }
    ICompilationUnit start=getCompilationUnitForType(logger,binaryTypeName);
    compile(logger,new ICompilationUnit[]{start});
    byteCode=doGetByteCodeFromCache(logger,binaryTypeName);
    if (byteCode != null) {
      return byteCode.getBytes();
    }
 else {
      throw new UnableToCompleteException();
    }
  }
  finally {
    threadLogger.pop(oldLogger);
  }
}"
82990,"/** 
 * Pull in types implicitly referenced through rebind answers.
 */
protected String[] doFindAdditionalTypesUsingRebinds(TreeLogger logger,CompilationUnitDeclaration cud){
  Set dependentTypeNames=new HashSet();
  Map requestedTypes=new HashMap();
  FindDeferredBindingSitesVisitor v=new FindDeferredBindingSitesVisitor(requestedTypes);
  cud.traverse(v,cud.scope);
  for (Iterator iter=requestedTypes.keySet().iterator(); iter.hasNext(); ) {
    String reqType=(String)iter.next();
    DeferredBindingSite site=(DeferredBindingSite)requestedTypes.get(reqType);
    try {
      String[] resultTypes=rebindPermOracle.getAllPossibleRebindAnswers(getLogger(),reqType);
      for (int i=0; i < resultTypes.length; ++i) {
        String typeName=resultTypes[i];
        ReferenceBinding type=resolvePossiblyNestedType(typeName);
        if (type == null) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (!type.isClass()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isAbstract()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isNestedType() && !type.isStatic()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isLocalType()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        MethodBinding noArgCtor=type.getExactMethod(""String_Node_Str"".toCharArray(),TypeBinding.NoParameters,cud.scope);
        if (noArgCtor == null) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        dependentTypeNames.add(typeName);
      }
      Util.addAll(dependentTypeNames,resultTypes);
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + reqType + ""String_Node_Str"");
    }
  }
  return (String[])dependentTypeNames.toArray(Empty.STRINGS);
}","/** 
 * Pull in types implicitly referenced through rebind answers.
 */
protected String[] doFindAdditionalTypesUsingRebinds(TreeLogger logger,CompilationUnitDeclaration cud){
  Set dependentTypeNames=new HashSet();
  Map requestedTypes=new HashMap();
  FindDeferredBindingSitesVisitor v=new FindDeferredBindingSitesVisitor(requestedTypes);
  cud.traverse(v,cud.scope);
  for (Iterator iter=requestedTypes.keySet().iterator(); iter.hasNext(); ) {
    String reqType=(String)iter.next();
    DeferredBindingSite site=(DeferredBindingSite)requestedTypes.get(reqType);
    try {
      String[] resultTypes=rebindPermOracle.getAllPossibleRebindAnswers(logger,reqType);
      for (int i=0; i < resultTypes.length; ++i) {
        String typeName=resultTypes[i];
        ReferenceBinding type=resolvePossiblyNestedType(typeName);
        if (type == null) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (!type.isClass()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isAbstract()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isNestedType() && !type.isStatic()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isLocalType()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        MethodBinding noArgCtor=type.getExactMethod(""String_Node_Str"".toCharArray(),TypeBinding.NoParameters,cud.scope);
        if (noArgCtor == null) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        dependentTypeNames.add(typeName);
      }
      Util.addAll(dependentTypeNames,resultTypes);
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + reqType + ""String_Node_Str"");
    }
  }
  return (String[])dependentTypeNames.toArray(Empty.STRINGS);
}"
82991,"public ThreadLocalTreeLoggerProxy(TreeLogger logger){
  set(logger);
}","public ThreadLocalTreeLoggerProxy(TreeLogger logger){
  push(logger);
}"
82992,"/** 
 * Sets the height of the panel's child widget. If the panel's child widget has not been set, the height passed in will be cached and used to set the height immediately after the child widget is set.
 * @param height the object's new height, in CSS units (e.g. ""10px"", ""1em"")
 */
@Override public void setHeight(String height){
  desiredHeight=height;
  maybeUpdateSize();
  if (height.length() == 0) {
    desiredHeight=null;
  }
}","/** 
 * Sets the height of the panel's child widget. If the panel's child widget has not been set, the height passed in will be cached and used to set the height immediately after the child widget is set. <p> Note that subclasses may have a different behavior. A subclass may decide not to change the height of the child widget. It may instead decide to change the height of an internal panel widget, which contains the child widget. </p>
 * @param height the object's new height, in CSS units (e.g. ""10px"", ""1em"")
 */
@Override public void setHeight(String height){
  desiredHeight=height;
  maybeUpdateSize();
  if (height.length() == 0) {
    desiredHeight=null;
  }
}"
82993,"/** 
 * Sets the width of the panel's child widget. If the panel's child widget has not been set, the width passed in will be cached and used to set the width immediately after the child widget is set.
 * @param width the object's new width, in CSS units (e.g. ""10px"", ""1em"")
 */
@Override public void setWidth(String width){
  desiredWidth=width;
  maybeUpdateSize();
  if (width.length() == 0) {
    desiredWidth=null;
  }
}","/** 
 * Sets the width of the panel's child widget. If the panel's child widget has not been set, the width passed in will be cached and used to set the width immediately after the child widget is set. <p> Note that subclasses may have a different behavior. A subclass may decide not to change the width of the child widget. It may instead decide to change the width of an internal panel widget, which contains the child widget. </p>
 * @param width the object's new width, in CSS units (e.g. ""10px"", ""1em"")
 */
@Override public void setWidth(String width){
  desiredWidth=width;
  maybeUpdateSize();
  if (width.length() == 0) {
    desiredWidth=null;
  }
}"
82994,"/** 
 * We control size by setting our child widget's size. However, if we don't currently have a child, we record the size the user wanted so that when we do get a child, we can set it correctly. Until size is explicitly cleared, any child put into the popup will be given that size.
 */
private void maybeUpdateSize(){
  Widget w=getWidget();
  if (w != null) {
    if (desiredHeight != null) {
      w.setHeight(desiredHeight);
    }
    if (desiredWidth != null) {
      w.setWidth(desiredWidth);
    }
  }
}","/** 
 * We control size by setting our child widget's size. However, if we don't currently have a child, we record the size the user wanted so that when we do get a child, we can set it correctly. Until size is explicitly cleared, any child put into the popup will be given that size.
 */
private void maybeUpdateSize(){
  Widget w=super.getWidget();
  if (w != null) {
    if (desiredHeight != null) {
      w.setHeight(desiredHeight);
    }
    if (desiredWidth != null) {
      w.setWidth(desiredWidth);
    }
  }
}"
82995,"/** 
 * Wraps a JSO-typed argument if the target type is a different type.
 */
private JExpression checkAndReplaceJso(JExpression arg,JType targetType){
  JType argType=arg.getType();
  if (argType == targetType) {
    return arg;
  }
  if (!(targetType instanceof JReferenceType)) {
    return arg;
  }
  if (!program.isJavaScriptObject(argType)) {
    return arg;
  }
  JCastOperation cast=new JCastOperation(program,arg.getSourceInfo(),argType,arg);
  return cast;
}","/** 
 * Wraps a JSO-typed argument if the target type is a different type.
 */
private JExpression checkAndReplaceJso(JExpression arg,JType targetType,boolean nowrapJso){
  JType argType=arg.getType();
  if (argType == targetType) {
    return arg;
  }
  if (!(targetType instanceof JReferenceType)) {
    return arg;
  }
  if (!program.isJavaScriptObject(argType)) {
    return arg;
  }
  if (nowrapJso && program.isJavaScriptObject(targetType)) {
    return arg;
  }
  JCastOperation cast=new JCastOperation(program,arg.getSourceInfo(),argType,arg);
  return cast;
}"
82996,"private String getHtmlPrefix(){
  DefaultTextOutput out=new DefaultTextOutput(obfuscate);
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newline();
  return out.toString();
}","private String getHtmlPrefix(){
  DefaultTextOutput out=new DefaultTextOutput(obfuscate);
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + About.GWT_VERSION_NUM + ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newline();
  return out.toString();
}"
82997,"private String getJsPrefix(){
  DefaultTextOutput out=new DefaultTextOutput(obfuscate);
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  return out.toString();
}","private String getJsPrefix(){
  DefaultTextOutput out=new DefaultTextOutput(obfuscate);
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + About.GWT_VERSION_NUM + ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  return out.toString();
}"
82998,"private void ctorAddKnownGlobalSymbols(){
  String[] commonBuiltins=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < commonBuiltins.length; i++) {
    String ident=commonBuiltins[i];
    this.doCreateName(ident,ident);
  }
}","private void ctorAddKnownGlobalSymbols(){
  String[] commonBuiltins=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < commonBuiltins.length; i++) {
    String ident=commonBuiltins[i];
    this.doCreateName(ident,ident);
  }
}"
82999,"public static void doPost(String url,String postData){
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,url);
  try {
    Request response=builder.sendRequest(postData,new RequestCallback(){
      public void onError(      Request request,      Throwable exception){
      }
      public void onResponseReceived(      Request request,      Response response){
      }
    }
);
  }
 catch (  RequestException e) {
    Window.alert(""String_Node_Str"" + e.getMessage());
  }
}","public static void doPost(String url,String postData){
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,url);
  try {
    builder.setHeader(""String_Node_Str"",""String_Node_Str"");
    Request response=builder.sendRequest(postData,new RequestCallback(){
      public void onError(      Request request,      Throwable exception){
      }
      public void onResponseReceived(      Request request,      Response response){
      }
    }
);
  }
 catch (  RequestException e) {
    Window.alert(""String_Node_Str"" + e.getMessage());
  }
}"
83000,"/** 
 * Gets the height of the browser window's client area excluding the scroll bar.
 * @return the window's client height
 */
public native int windowGetClientHeight();","/** 
 * Gets the height of the browser window's client area excluding the scroll bar.
 * @return the window's client height
 */
public abstract int windowGetClientHeight();"
