record_number,buggy_code,fixed_code
49001,"public static boolean setBaseNodeForVm(BaseNode vNode,VcVirtualMachine vm){
  boolean success=true;
  String vmName=vm.getName();
  vm=VcCache.getIgnoreMissing(vm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmName + ""String_Node_Str"");
  }
  String ip=null;
  if (vm != null) {
    ip=VcVmUtil.getIpAddress(vm,false);
  }
  if (ip != null) {
    vNode.setSuccess(true);
    vNode.setIpAddress(ip);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOff()) {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    }
 else {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
  }
 else {
    vNode.setSuccess(false);
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  String haFlag=vNode.getNodeGroup().getHaFlag();
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    if (vm.getFTState() == null || vm.getFTState() != FaultToleranceState.running) {
      logger.fatal(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      success=false;
    }
  }
  return success;
}","public static boolean setBaseNodeForVm(BaseNode vNode,VcVirtualMachine vm){
  boolean success=true;
  String vmName=vm.getName();
  vm=VcCache.getIgnoreMissing(vm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmName + ""String_Node_Str"");
  }
  String ip=null;
  if (vm != null) {
    ip=VcVmUtil.getIpAddress(vm,false);
  }
  if (ip != null) {
    vNode.setSuccess(true);
    vNode.setIpAddress(ip);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOff()) {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    }
 else {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
  }
 else {
    vNode.setSuccess(false);
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  if (success) {
    String haFlag=vNode.getNodeGroup().getHaFlag();
    if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
      logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      return verifyFTState(vm);
    }
  }
  return success;
}"
49002,"public List<String> getVolumns(){
  List<String> volumns=new ArrayList<String>();
  for (  DiskEntity disk : disks) {
    volumns.add(disk.getDeviceName());
  }
  return volumns;
}","public List<String> getVolumns(){
  List<String> volumns=new ArrayList<String>();
  for (  DiskEntity disk : disks) {
    if (!DiskType.SWAP_DISK.getType().equals(disk.getDiskType()))     volumns.add(disk.getDeviceName());
  }
  return volumns;
}"
49003,"private void convertStorage(NodeGroupCreate group,NodeGroupEntity groupEntity,Set<String> roles){
  if (group.getStorage() != null) {
    groupEntity.setStorageSize(group.getStorage().getSizeGB());
    List<String> groupRoles=group.getRoles();
    if (groupRoles.contains(HadoopRole.ZOOKEEPER_ROLE.toString()) && groupRoles.size() == 1) {
      groupEntity.setDiskBisect(true);
    }
 else {
      groupEntity.setDiskBisect(false);
    }
    String storageType=group.getStorage().getType();
    if (storageType != null) {
      if (storageType.equalsIgnoreCase(DatastoreType.TEMPFS.name())) {
        groupEntity.setStorageType(DatastoreType.TEMPFS);
        roles.add(HadoopRole.TEMPFS_CLIENT_ROLE.toString());
      }
 else       if (storageType.equalsIgnoreCase(DatastoreType.LOCAL.name())) {
        groupEntity.setStorageType(DatastoreType.LOCAL);
      }
 else {
        groupEntity.setStorageType(DatastoreType.SHARED);
      }
    }
    groupEntity.setVcDatastoreNameList(group.getStorage().getDsNames());
  }
  if (groupEntity.getStorageType() == DatastoreType.LOCAL) {
    if (group.getHaFlag() != null && Constants.HA_FLAG_FT.equals(group.getHaFlag().toLowerCase())) {
      throw ClusterConfigException.LOCAL_STORAGE_USED_FOR_FT_GROUP(group.getName());
    }
  }
}","private void convertStorage(NodeGroupCreate group,NodeGroupEntity groupEntity,Set<String> roles){
  if (group.getStorage() != null) {
    groupEntity.setStorageSize(group.getStorage().getSizeGB());
    List<String> groupRoles=group.getRoles();
    String storageType=group.getStorage().getType();
    if (storageType != null) {
      if (storageType.equalsIgnoreCase(DatastoreType.TEMPFS.name())) {
        groupEntity.setStorageType(DatastoreType.TEMPFS);
        roles.add(HadoopRole.TEMPFS_CLIENT_ROLE.toString());
      }
 else       if (storageType.equalsIgnoreCase(DatastoreType.LOCAL.name())) {
        groupEntity.setStorageType(DatastoreType.LOCAL);
      }
 else {
        groupEntity.setStorageType(DatastoreType.SHARED);
      }
    }
    groupEntity.setVcDatastoreNameList(group.getStorage().getDsNames());
  }
  if (groupEntity.getStorageType() == DatastoreType.LOCAL) {
    if (group.getHaFlag() != null && Constants.HA_FLAG_FT.equals(group.getHaFlag().toLowerCase())) {
      throw ClusterConfigException.LOCAL_STORAGE_USED_FOR_FT_GROUP(group.getName());
    }
  }
}"
49004,"private void expandGroupStorage(NodeGroupEntity ngEntity,NodeGroupCreate group,EnumSet<HadoopRole> enumRoles){
  int storageSize=ngEntity.getStorageSize();
  DatastoreType storageType=ngEntity.getStorageType();
  boolean storageBisect=ngEntity.getDiskBisect();
  List<String> storeNames=ngEntity.getVcDatastoreNameList();
  if (storageSize <= 0 && storageType == null && (storeNames == null || storeNames.isEmpty())) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
  }
  logger.debug(""String_Node_Str"" + storageSize + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storageType + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storeNames + ""String_Node_Str""+ ngEntity.getName());
  StorageRead storage=new StorageRead();
  group.setStorage(storage);
  storage.setSizeGB(storageSize);
  storage.setDiskBisect(storageBisect);
  if (storageType != null) {
    storage.setType(storageType.toString().toLowerCase());
  }
  storage.setNamePattern(getStoreNamePattern(storageType,storeNames));
  storage.setDsNames(storeNames);
  if (enumRoles.size() == 1 && (enumRoles.contains(HadoopRole.ZOOKEEPER_ROLE) || enumRoles.contains(HadoopRole.MAPR_ZOOKEEPER_ROLE))) {
    logger.debug(""String_Node_Str"");
    storage.setSplitPolicy(DiskSplitPolicy.BI_SECTOR);
  }
 else {
    if (storage.getType().equalsIgnoreCase(DatastoreType.LOCAL.toString())) {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.EVEN_SPLIT);
    }
 else {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.AGGREGATE);
    }
  }
  setDiskAttributes(storageType,storage,storeNames);
}","private void expandGroupStorage(NodeGroupEntity ngEntity,NodeGroupCreate group,EnumSet<HadoopRole> enumRoles){
  int storageSize=ngEntity.getStorageSize();
  DatastoreType storageType=ngEntity.getStorageType();
  List<String> storeNames=ngEntity.getVcDatastoreNameList();
  if (storageSize <= 0 && storageType == null && (storeNames == null || storeNames.isEmpty())) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
  }
  logger.debug(""String_Node_Str"" + storageSize + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storageType + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storeNames + ""String_Node_Str""+ ngEntity.getName());
  StorageRead storage=new StorageRead();
  group.setStorage(storage);
  storage.setSizeGB(storageSize);
  if (storageType != null) {
    storage.setType(storageType.toString().toLowerCase());
  }
  storage.setNamePattern(getStoreNamePattern(storageType,storeNames));
  storage.setDsNames(storeNames);
  if (enumRoles.size() == 1 && (enumRoles.contains(HadoopRole.ZOOKEEPER_ROLE) || enumRoles.contains(HadoopRole.MAPR_ZOOKEEPER_ROLE))) {
    logger.debug(""String_Node_Str"");
    storage.setSplitPolicy(DiskSplitPolicy.BI_SECTOR);
  }
 else {
    if (storage.getType().equalsIgnoreCase(DatastoreType.LOCAL.toString())) {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.EVEN_SPLIT);
    }
 else {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.AGGREGATE);
    }
  }
  setDiskAttributes(storageType,storage,storeNames);
}"
49005,"public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedPattern(null);
  spec.setLocalPattern(null);
  spec.setNetworking(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkName(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setNamePattern(null);
      group.getStorage().setDiskBisect(false);
      group.setVmFolderPath(null);
    }
  }
  return spec;
}","public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedPattern(null);
  spec.setLocalPattern(null);
  spec.setNetworking(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkName(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
    }
  }
  return spec;
}"
49006,"private String createVcResourcePools(List<BaseNode> vNodes){
  logger.info(""String_Node_Str"");
  String clusterName=vNodes.get(0).getClusterName();
  String uuid=ConfigInfo.getSerengetiUUID();
  String clusterRpName=uuid + ""String_Node_Str"" + clusterName;
  Map<String,List<String>> vcClusterRpNamesMap=new HashMap<String,List<String>>();
  Map<Long,List<String>> rpNodeGroupNamesMap=new HashMap<Long,List<String>>();
  Map<String,Integer> countResult=collectResourcePoolInfo(vNodes,vcClusterRpNamesMap,rpNodeGroupNamesMap);
  try {
    int resourcePoolNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] clusterSPs=new Callable[resourcePoolNameCount];
    int i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,resourcePoolName);
        CreateResourcePoolSP clusterSP=new CreateResourcePoolSP(parentVcResourcePool,clusterRpName);
        clusterSPs[i]=clusterSP;
        i++;
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(clusterSPs,""String_Node_Str"",clusterName);
    int nodeGroupNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] nodeGroupSPs=new Callable[nodeGroupNameCount];
    i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=null;
        String vcRPName=CommonUtil.isBlank(resourcePoolName) ? clusterRpName : resourcePoolName + ""String_Node_Str"" + clusterRpName;
        parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,vcRPName);
        long rpHashCode=vcClusterName.hashCode() ^ (vcClusterName + resourcePoolName).hashCode();
        for (        String nodeGroupName : rpNodeGroupNamesMap.get(rpHashCode)) {
          CreateResourcePoolSP nodeGroupSP=new CreateResourcePoolSP(parentVcResourcePool,nodeGroupName);
          nodeGroupSPs[i]=nodeGroupSP;
          i++;
        }
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(nodeGroupSPs,""String_Node_Str"",clusterName);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  return clusterRpName;
}","private String createVcResourcePools(List<BaseNode> vNodes){
  logger.info(""String_Node_Str"");
  String clusterName=vNodes.get(0).getClusterName();
  String uuid=ConfigInfo.getSerengetiUUID();
  String clusterRpName=uuid + ""String_Node_Str"" + clusterName;
  Map<String,List<String>> vcClusterRpNamesMap=new HashMap<String,List<String>>();
  Map<Long,List<String>> rpNodeGroupNamesMap=new HashMap<Long,List<String>>();
  Map<String,Integer> countResult=collectResourcePoolInfo(vNodes,vcClusterRpNamesMap,rpNodeGroupNamesMap);
  try {
    int resourcePoolNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] clusterSPs=new Callable[resourcePoolNameCount];
    int i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,resourcePoolName);
        CreateResourcePoolSP clusterSP=new CreateResourcePoolSP(parentVcResourcePool,clusterRpName);
        clusterSPs[i]=clusterSP;
        i++;
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(clusterSPs,""String_Node_Str"",clusterName);
    int nodeGroupNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] nodeGroupSPs=new Callable[nodeGroupNameCount];
    i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      VcCluster vcCluster=VcResourceUtils.findVcCluster(vcClusterName);
      if (!vcCluster.getConfig().getDRSEnabled()) {
        continue;
      }
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=null;
        String vcRPName=CommonUtil.isBlank(resourcePoolName) ? clusterRpName : resourcePoolName + ""String_Node_Str"" + clusterRpName;
        parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,vcRPName);
        long rpHashCode=vcClusterName.hashCode() ^ (vcClusterName + resourcePoolName).hashCode();
        for (        String nodeGroupName : rpNodeGroupNamesMap.get(rpHashCode)) {
          CreateResourcePoolSP nodeGroupSP=new CreateResourcePoolSP(parentVcResourcePool,nodeGroupName);
          nodeGroupSPs[i]=nodeGroupSP;
          i++;
        }
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(nodeGroupSPs,""String_Node_Str"",clusterName);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  return clusterRpName;
}"
49007,"private Map<String,Integer> collectResourcePoolInfo(List<BaseNode> vNodes,Map<String,List<String>> vcClusterRpNamesMap,Map<Long,List<String>> rpNodeGroupNamesMap){
  List<String> resourcePoolNames=null;
  List<String> nodeGroupNames=null;
  int resourcePoolNameCount=0;
  int nodeGroupNameCount=0;
  for (  BaseNode baseNode : vNodes) {
    String vcCluster=baseNode.getTargetVcCluster();
    AuAssert.check(!CommonUtil.isBlank(vcCluster),""String_Node_Str"");
    if (!vcClusterRpNamesMap.containsKey(vcCluster)) {
      resourcePoolNames=new ArrayList<String>();
    }
 else {
      resourcePoolNames=vcClusterRpNamesMap.get(vcCluster);
    }
    String vcRp=baseNode.getTargetRp();
    long rpHashCode=vcCluster.hashCode() ^ (vcCluster + vcRp).hashCode();
    if (!rpNodeGroupNamesMap.containsKey(rpHashCode)) {
      nodeGroupNames=new ArrayList<String>();
    }
 else {
      nodeGroupNames=rpNodeGroupNamesMap.get(rpHashCode);
    }
    String nodeGroupName=baseNode.getNodeGroup().getName();
    if (!nodeGroupNames.contains(nodeGroupName)) {
      nodeGroupNames.add(nodeGroupName);
      rpNodeGroupNamesMap.put(rpHashCode,nodeGroupNames);
      nodeGroupNameCount++;
    }
    if (!resourcePoolNames.contains(vcRp)) {
      resourcePoolNames.add(vcRp);
      vcClusterRpNamesMap.put(vcCluster,resourcePoolNames);
      resourcePoolNameCount++;
    }
  }
  Map<String,Integer> countResult=new HashMap<String,Integer>();
  countResult.put(""String_Node_Str"",resourcePoolNameCount);
  countResult.put(""String_Node_Str"",nodeGroupNameCount);
  return countResult;
}","private Map<String,Integer> collectResourcePoolInfo(List<BaseNode> vNodes,Map<String,List<String>> vcClusterRpNamesMap,Map<Long,List<String>> rpNodeGroupNamesMap){
  List<String> resourcePoolNames=null;
  List<String> nodeGroupNames=null;
  int resourcePoolNameCount=0;
  int nodeGroupNameCount=0;
  for (  BaseNode baseNode : vNodes) {
    String vcCluster=baseNode.getTargetVcCluster();
    VcCluster cluster=VcResourceUtils.findVcCluster(vcCluster);
    if (!cluster.getConfig().getDRSEnabled()) {
      logger.debug(""String_Node_Str"" + vcCluster + ""String_Node_Str"");
      continue;
    }
    AuAssert.check(!CommonUtil.isBlank(vcCluster),""String_Node_Str"");
    if (!vcClusterRpNamesMap.containsKey(vcCluster)) {
      resourcePoolNames=new ArrayList<String>();
    }
 else {
      resourcePoolNames=vcClusterRpNamesMap.get(vcCluster);
    }
    String vcRp=baseNode.getTargetRp();
    long rpHashCode=vcCluster.hashCode() ^ (vcCluster + vcRp).hashCode();
    if (!rpNodeGroupNamesMap.containsKey(rpHashCode)) {
      nodeGroupNames=new ArrayList<String>();
    }
 else {
      nodeGroupNames=rpNodeGroupNamesMap.get(rpHashCode);
    }
    String nodeGroupName=baseNode.getNodeGroup().getName();
    if (!nodeGroupNames.contains(nodeGroupName)) {
      nodeGroupNames.add(nodeGroupName);
      rpNodeGroupNamesMap.put(rpHashCode,nodeGroupNames);
      nodeGroupNameCount++;
    }
    if (!resourcePoolNames.contains(vcRp)) {
      resourcePoolNames.add(vcRp);
      vcClusterRpNamesMap.put(vcCluster,resourcePoolNames);
      resourcePoolNameCount++;
    }
  }
  Map<String,Integer> countResult=new HashMap<String,Integer>();
  countResult.put(""String_Node_Str"",resourcePoolNameCount);
  countResult.put(""String_Node_Str"",nodeGroupNameCount);
  return countResult;
}"
49008,"private VcResourcePool getVcResourcePool(BaseNode vNode,final String clusterRpName){
  try {
    String vcRPName=""String_Node_Str"";
    if (CommonUtil.isBlank(vNode.getTargetRp())) {
      vcRPName=clusterRpName + ""String_Node_Str"" + vNode.getNodeGroup().getName();
    }
 else {
      vcRPName=vNode.getTargetRp() + ""String_Node_Str"" + clusterRpName+ ""String_Node_Str""+ vNode.getNodeGroup().getName();
    }
    VcResourcePool rp=VcResourceUtils.findRPInVCCluster(vNode.getTargetVcCluster(),vcRPName);
    if (rp == null) {
      throw ClusteringServiceException.TARGET_VC_RP_NOT_FOUND(vNode.getTargetVcCluster(),vNode.getTargetRp());
    }
    return rp;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + vNode.getTargetRp() + ""String_Node_Str""+ vNode.getTargetVcCluster(),e);
    throw ClusteringServiceException.TARGET_VC_RP_NOT_FOUND(vNode.getTargetVcCluster(),vNode.getTargetRp());
  }
}","private VcResourcePool getVcResourcePool(BaseNode vNode,final String clusterRpName){
  try {
    String vcRPName=""String_Node_Str"";
    VcCluster cluster=VcResourceUtils.findVcCluster(vNode.getTargetVcCluster());
    if (!cluster.getConfig().getDRSEnabled()) {
      logger.debug(""String_Node_Str"" + vNode.getTargetVcCluster() + ""String_Node_Str"");
      return cluster.getRootRP();
    }
    if (CommonUtil.isBlank(vNode.getTargetRp())) {
      vcRPName=clusterRpName + ""String_Node_Str"" + vNode.getNodeGroup().getName();
    }
 else {
      vcRPName=vNode.getTargetRp() + ""String_Node_Str"" + clusterRpName+ ""String_Node_Str""+ vNode.getNodeGroup().getName();
    }
    VcResourcePool rp=VcResourceUtils.findRPInVCCluster(vNode.getTargetVcCluster(),vcRPName);
    if (rp == null) {
      throw ClusteringServiceException.TARGET_VC_RP_NOT_FOUND(vNode.getTargetVcCluster(),vNode.getTargetRp());
    }
    return rp;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + vNode.getTargetRp() + ""String_Node_Str""+ vNode.getTargetVcCluster(),e);
    throw ClusteringServiceException.TARGET_VC_RP_NOT_FOUND(vNode.getTargetVcCluster(),vNode.getTargetRp());
  }
}"
49009,"private void executeResourcePoolStoreProcedures(Callable<Void>[] defineSPs,String type,String clusterName) throws InterruptedException {
  NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
  ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,defineSPs,callback);
  if (result == null) {
    logger.error(""String_Node_Str"" + type + ""String_Node_Str"");
    throw ClusteringServiceException.CREATE_RESOURCE_POOL_FAILED(clusterName);
  }
  int total=0;
  boolean success=true;
  for (int i=0; i < defineSPs.length; i++) {
    if (result[i].finished && result[i].throwable == null) {
      ++total;
    }
 else     if (result[i].throwable != null) {
      logger.error(""String_Node_Str"" + type + ""String_Node_Str"",result[i].throwable);
      success=false;
    }
  }
  logger.info(total + ""String_Node_Str"" + type+ ""String_Node_Str"");
  if (!success) {
    throw ClusteringServiceException.CREATE_RESOURCE_POOL_FAILED(clusterName);
  }
}","private void executeResourcePoolStoreProcedures(Callable<Void>[] defineSPs,String type,String clusterName) throws InterruptedException {
  if (defineSPs.length == 0) {
    logger.debug(""String_Node_Str"");
    return;
  }
  NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
  ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,defineSPs,callback);
  if (result == null) {
    logger.error(""String_Node_Str"" + type + ""String_Node_Str"");
    throw ClusteringServiceException.CREATE_RESOURCE_POOL_FAILED(clusterName);
  }
  int total=0;
  boolean success=true;
  for (int i=0; i < defineSPs.length; i++) {
    if (result[i].finished && result[i].throwable == null) {
      ++total;
    }
 else     if (result[i].throwable != null) {
      logger.error(""String_Node_Str"" + type + ""String_Node_Str"",result[i].throwable);
      success=false;
    }
  }
  logger.info(total + ""String_Node_Str"" + type+ ""String_Node_Str"");
  if (!success) {
    throw ClusteringServiceException.CREATE_RESOURCE_POOL_FAILED(clusterName);
  }
}"
49010,"public static void expandGroupInstanceType(NodeGroupEntity ngEntity,GroupType groupType,Set<String> sharedPattern,Set<String> localPattern){
  logger.debug(""String_Node_Str"" + ngEntity.getName());
  InstanceType instanceType=ngEntity.getNodeType();
  if (instanceType == null) {
    if (groupType == GroupType.MASTER_GROUP || groupType == GroupType.MASTER_JOBTRACKER_GROUP || groupType == GroupType.HBASE_MASTER_GROUP || groupType == GroupType.ZOOKEEPER_GROUP) {
      instanceType=InstanceType.MEDIUM;
    }
 else {
      instanceType=InstanceType.SMALL;
    }
  }
  logger.debug(""String_Node_Str"" + instanceType.toString());
  int memory=ngEntity.getMemorySize();
  if (memory <= 0) {
    ngEntity.setMemorySize(instanceType.getMemoryMB());
  }
  int cpu=ngEntity.getCpuNum();
  if (cpu <= 0) {
    ngEntity.setCpuNum(instanceType.getCpuNum());
  }
  if (ngEntity.getStorageSize() <= 0) {
    ngEntity.setStorageSize(getStorage(instanceType,groupType));
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
 else {
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
  if (ngEntity.getStorageType() == null) {
    DatastoreType storeType=groupType.getStorageEnumType();
    if ((sharedPattern == null || sharedPattern.isEmpty()) && storeType == DatastoreType.SHARED) {
      storeType=DatastoreType.LOCAL;
    }
    if ((localPattern == null || localPattern.isEmpty()) && storeType == DatastoreType.LOCAL) {
      storeType=DatastoreType.SHARED;
    }
    ngEntity.setStorageType(storeType);
  }
 else {
    if ((sharedPattern == null || sharedPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.SHARED))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
    if ((localPattern == null || localPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.LOCAL))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
  }
  if (groupType == GroupType.ZOOKEEPER_GROUP) {
    ngEntity.setDiskBisect(true);
  }
 else {
    ngEntity.setDiskBisect(false);
  }
}","public static void expandGroupInstanceType(NodeGroupEntity ngEntity,GroupType groupType,Set<String> sharedPattern,Set<String> localPattern){
  logger.debug(""String_Node_Str"" + ngEntity.getName());
  InstanceType instanceType=ngEntity.getNodeType();
  if (instanceType == null) {
    if (groupType == GroupType.MASTER_GROUP || groupType == GroupType.MASTER_JOBTRACKER_GROUP || groupType == GroupType.HBASE_MASTER_GROUP || groupType == GroupType.ZOOKEEPER_GROUP) {
      instanceType=InstanceType.MEDIUM;
    }
 else {
      instanceType=InstanceType.SMALL;
    }
  }
  logger.debug(""String_Node_Str"" + instanceType.toString());
  int memory=ngEntity.getMemorySize();
  if (memory <= 0) {
    ngEntity.setMemorySize(instanceType.getMemoryMB());
  }
  int cpu=ngEntity.getCpuNum();
  if (cpu <= 0) {
    ngEntity.setCpuNum(instanceType.getCpuNum());
  }
  if (ngEntity.getStorageSize() <= 0) {
    ngEntity.setStorageSize(getStorage(instanceType,groupType));
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
 else {
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
  if (ngEntity.getStorageType() == null) {
    DatastoreType storeType=groupType.getStorageEnumType();
    if ((sharedPattern == null || sharedPattern.isEmpty()) && storeType == DatastoreType.SHARED) {
      storeType=DatastoreType.LOCAL;
    }
    if ((localPattern == null || localPattern.isEmpty()) && storeType == DatastoreType.LOCAL) {
      storeType=DatastoreType.SHARED;
    }
    ngEntity.setStorageType(storeType);
  }
 else {
    if ((sharedPattern == null || sharedPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.SHARED))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
    if ((localPattern == null || localPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.LOCAL))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
  }
}"
49011,"private static VmOperation getOperation(Callable<Void> sp){
  if (sp instanceof CreateVMFolderSP) {
    return VmOperation.CREATE_FOLDER;
  }
 else   if (sp instanceof StartVmSP) {
    return VmOperation.START_VM;
  }
 else   if (sp instanceof StopVmSP) {
    return VmOperation.STOP_VM;
  }
 else   if (sp instanceof DeleteVMFolderSP) {
    return VmOperation.DELETE_FOLDER;
  }
 else   if (sp instanceof DeleteVmByIdSP) {
    return VmOperation.DELETE_VM;
  }
 else   if (sp instanceof CreateVmSP) {
    return VmOperation.CREATE_VM;
  }
 else   if (sp instanceof ConfigIOShareSP) {
    return VmOperation.RECONFIGURE_VM;
  }
 else {
    logger.error(""String_Node_Str"" + sp);
    return null;
  }
}","private static VmOperation getOperation(Callable<Void> sp){
  if (sp instanceof CreateVMFolderSP) {
    return VmOperation.CREATE_FOLDER;
  }
 else   if (sp instanceof StartVmSP) {
    return VmOperation.START_VM;
  }
 else   if (sp instanceof StopVmSP) {
    return VmOperation.STOP_VM;
  }
 else   if (sp instanceof DeleteVMFolderSP) {
    return VmOperation.DELETE_FOLDER;
  }
 else   if (sp instanceof DeleteVmByIdSP) {
    return VmOperation.DELETE_VM;
  }
 else   if (sp instanceof CreateVmSP) {
    return VmOperation.CREATE_VM;
  }
 else   if (sp instanceof ConfigIOShareSP) {
    return VmOperation.RECONFIGURE_VM;
  }
 else   if (sp instanceof CreateResourcePoolSP) {
    return VmOperation.CREATE_RP;
  }
 else {
    logger.error(""String_Node_Str"" + sp);
    return null;
  }
}"
49012,"public NodeGroupRead toNodeGroupRead(){
  NodeGroupRead nodeGroupRead=new NodeGroupRead();
  nodeGroupRead.setName(this.name);
  nodeGroupRead.setCpuNum(this.cpuNum);
  nodeGroupRead.setMemCapacityMB(this.memorySize);
  nodeGroupRead.setSwapRatio(this.swapRatio);
  nodeGroupRead.setInstanceNum(this.getRealInstanceNum());
  nodeGroupRead.setIoShares(this.ioShares);
  Gson gson=new Gson();
  @SuppressWarnings(""String_Node_Str"") List<String> groupRoles=gson.fromJson(roles,List.class);
  Collections.sort(groupRoles,new Comparator<String>(){
    @Override public int compare(    String str1,    String str2){
      if (HadoopRole.fromString(str1).shouldRunAfterHDFS()) {
        return 1;
      }
 else       if (HadoopRole.fromString(str2).shouldRunAfterHDFS()) {
        return -1;
      }
 else {
        return 0;
      }
    }
  }
);
  nodeGroupRead.setRoles(groupRoles);
  StorageRead storage=new StorageRead();
  storage.setType(this.storageType.toString());
  storage.setSizeGB(this.storageSize);
  storage.setDiskBisect(this.diskBisect);
  storage.setDsNames(getVcDatastoreNameList());
  nodeGroupRead.setStorage(storage);
  List<NodeRead> nodeList=new ArrayList<NodeRead>();
  for (  NodeEntity node : this.nodes) {
    nodeList.add(node.toNodeRead());
  }
  nodeGroupRead.setInstances(nodeList);
  List<GroupAssociation> associations=new ArrayList<GroupAssociation>();
  for (  NodeGroupAssociation relation : groupAssociations) {
    GroupAssociation association=new GroupAssociation();
    association.setReference(relation.getReferencedGroup());
    association.setType(relation.getAssociationType());
    associations.add(association);
  }
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(instancePerHost);
  policy.setGroupAssociations(associations);
  policy.setGroupRacks(new Gson().fromJson(groupRacks,GroupRacks.class));
  nodeGroupRead.setPlacementPolicies(policy);
  return nodeGroupRead;
}","public NodeGroupRead toNodeGroupRead(){
  NodeGroupRead nodeGroupRead=new NodeGroupRead();
  nodeGroupRead.setName(this.name);
  nodeGroupRead.setCpuNum(this.cpuNum);
  nodeGroupRead.setMemCapacityMB(this.memorySize);
  nodeGroupRead.setSwapRatio(this.swapRatio);
  nodeGroupRead.setInstanceNum(this.getRealInstanceNum());
  nodeGroupRead.setIoShares(this.ioShares);
  Gson gson=new Gson();
  @SuppressWarnings(""String_Node_Str"") List<String> groupRoles=gson.fromJson(roles,List.class);
  Collections.sort(groupRoles,new Comparator<String>(){
    @Override public int compare(    String str1,    String str2){
      if (HadoopRole.fromString(str1).shouldRunAfterHDFS()) {
        return 1;
      }
 else       if (HadoopRole.fromString(str2).shouldRunAfterHDFS()) {
        return -1;
      }
 else {
        return 0;
      }
    }
  }
);
  nodeGroupRead.setRoles(groupRoles);
  StorageRead storage=new StorageRead();
  storage.setType(this.storageType.toString());
  storage.setSizeGB(this.storageSize);
  storage.setDsNames(getVcDatastoreNameList());
  nodeGroupRead.setStorage(storage);
  List<NodeRead> nodeList=new ArrayList<NodeRead>();
  for (  NodeEntity node : this.nodes) {
    nodeList.add(node.toNodeRead());
  }
  nodeGroupRead.setInstances(nodeList);
  List<GroupAssociation> associations=new ArrayList<GroupAssociation>();
  for (  NodeGroupAssociation relation : groupAssociations) {
    GroupAssociation association=new GroupAssociation();
    association.setReference(relation.getReferencedGroup());
    association.setType(relation.getAssociationType());
    associations.add(association);
  }
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(instancePerHost);
  policy.setGroupAssociations(associations);
  policy.setGroupRacks(new Gson().fromJson(groupRacks,GroupRacks.class));
  nodeGroupRead.setPlacementPolicies(policy);
  return nodeGroupRead;
}"
49013,"public void callInternal() throws Exception {
  final VcVirtualMachine template=VcCache.get(vmSchema.diskSchema.getParent());
  VcSnapshot snap=template.getSnapshotByName(vmSchema.diskSchema.getParentSnap());
  ConfigSpecImpl configSpec=new ConfigSpecImpl();
  HashMap<String,Disk.Operation> diskMap=new HashMap<String,Disk.Operation>();
  final VcVirtualMachine.CreateSpec vmSpec=new VcVirtualMachine.CreateSpec(newVmName,snap,targetRp,targetDs,vmFolder,linkedClone,configSpec);
  List<VcHost> hostList=new ArrayList<VcHost>();
  List<DiskCreateSpec> addDisks=DiskSchemaUtil.getDisksToAdd(hostList,targetRp,targetDs,vmSchema.diskSchema,diskMap);
  vcVm=template.cloneVm(vmSpec,null);
  if (host != null) {
    vcVm.disableDrs();
  }
  DiskCreateSpec[] tmpAddDisks=new DiskCreateSpec[addDisks.size()];
  tmpAddDisks=addDisks.toArray(tmpAddDisks);
  if (hostList.size() > 0 && !hostList.contains(vcVm.getHost())) {
    vcVm.migrate(hostList.get(0));
  }
  vcVm.changeDisks(null,tmpAddDisks);
  if (linkedClone) {
    ArrayList<DeviceId> disksToPromote=new ArrayList<DeviceId>();
    for (    Entry<String,Disk.Operation> entry : diskMap.entrySet()) {
      if (entry.getValue() == Disk.Operation.PROMOTE) {
        disksToPromote.add(new DeviceId(entry.getKey()));
      }
    }
    if (disksToPromote.size() >= 1) {
      vcVm.promoteDisks(disksToPromote.toArray(new DeviceId[0]));
    }
  }
  ConfigSpecImpl newConfigSpec=new ConfigSpecImpl();
  NetworkSchemaUtil.setNetworkSchema(newConfigSpec,targetRp.getVcCluster(),vmSchema.networkSchema);
  ResourceSchemaUtil.setResourceSchema(newConfigSpec,vmSchema.resourceSchema);
  vcVm.reconfigure(newConfigSpec);
  if (bootupConfigs != null) {
    vcVm.setGuestConfigs(bootupConfigs);
  }
  if (prePowerOn != null) {
    prePowerOn.setVm(vcVm);
    prePowerOn.call();
  }
  vcVm.powerOn(host);
  if (postPowerOn != null) {
    postPowerOn.setVm(vcVm);
    postPowerOn.call();
  }
}","public void callInternal() throws Exception {
  final VcVirtualMachine template=VcCache.get(vmSchema.diskSchema.getParent());
  VcSnapshot snap=template.getSnapshotByName(vmSchema.diskSchema.getParentSnap());
  ConfigSpecImpl configSpec=new ConfigSpecImpl();
  HashMap<String,Disk.Operation> diskMap=new HashMap<String,Disk.Operation>();
  final VcVirtualMachine.CreateSpec vmSpec=new VcVirtualMachine.CreateSpec(newVmName,snap,targetRp,targetDs,vmFolder,linkedClone,configSpec);
  List<VcHost> hostList=new ArrayList<VcHost>();
  List<DiskCreateSpec> addDisks=DiskSchemaUtil.getDisksToAdd(hostList,targetRp,targetDs,vmSchema.diskSchema,diskMap);
  vcVm=template.cloneVm(vmSpec,null);
  if (host != null) {
    vcVm.disableDrs();
  }
  DiskCreateSpec[] tmpAddDisks=new DiskCreateSpec[addDisks.size()];
  tmpAddDisks=addDisks.toArray(tmpAddDisks);
  if (hostList.size() > 0 && !hostList.contains(vcVm.getHost())) {
    vcVm.migrate(hostList.get(0));
  }
  vcVm.changeDisks(null,tmpAddDisks);
  if (linkedClone) {
    ArrayList<DeviceId> disksToPromote=new ArrayList<DeviceId>();
    for (    Entry<String,Disk.Operation> entry : diskMap.entrySet()) {
      if (entry.getValue() == Disk.Operation.PROMOTE) {
        disksToPromote.add(new DeviceId(entry.getKey()));
      }
    }
    if (disksToPromote.size() >= 1) {
      vcVm.promoteDisks(disksToPromote.toArray(new DeviceId[0]));
    }
  }
  ConfigSpecImpl newConfigSpec=new ConfigSpecImpl();
  NetworkSchemaUtil.setNetworkSchema(newConfigSpec,targetRp.getVcCluster(),vmSchema.networkSchema,vcVm);
  ResourceSchemaUtil.setResourceSchema(newConfigSpec,vmSchema.resourceSchema);
  vcVm.reconfigure(newConfigSpec);
  if (bootupConfigs != null) {
    vcVm.setGuestConfigs(bootupConfigs);
  }
  if (prePowerOn != null) {
    prePowerOn.setVm(vcVm);
    prePowerOn.call();
  }
  vcVm.powerOn(host);
  if (postPowerOn != null) {
    postPowerOn.setVm(vcVm);
    postPowerOn.call();
  }
}"
49014,"public static void setNetworkSchema(ConfigSpecImpl spec,VcCluster cluster,NetworkSchema networkSchema) throws Exception {
  List<VirtualDeviceSpec> changes=new ArrayList<VirtualDeviceSpec>();
  for (  NetworkSchema.Network network : networkSchema.networks) {
    VcNetwork vN=cluster.getNetwork(network.vcNetwork);
    AuAssert.check(vN != null);
    VirtualDeviceSpec deviceSpec=VmConfigUtil.createNetworkDevice(VmConfigUtil.EthernetControllerType.VMXNET3,network.nicLabel,vN);
    changes.add(deviceSpec);
  }
  spec.setDeviceChange(changes.toArray(new VirtualDeviceSpec[changes.size()]));
}","public static void setNetworkSchema(ConfigSpecImpl spec,VcCluster cluster,NetworkSchema networkSchema,VcVirtualMachine vcVm) throws Exception {
  List<VirtualDeviceSpec> changes=new ArrayList<VirtualDeviceSpec>();
  for (  NetworkSchema.Network network : networkSchema.networks) {
    VcNetwork vN=cluster.getNetwork(network.vcNetwork);
    AuAssert.check(vN != null);
    if (network.nicLabel != null && vcVm.getDeviceByLabel(network.nicLabel) != null) {
      changes.add(vcVm.reconfigNetworkSpec(network.nicLabel,vN));
    }
 else {
      VirtualDeviceSpec deviceSpec=VmConfigUtil.createNetworkDevice(VmConfigUtil.EthernetControllerType.VMXNET3,network.nicLabel,vN);
      changes.add(deviceSpec);
    }
  }
  spec.setDeviceChange(changes.toArray(new VirtualDeviceSpec[changes.size()]));
}"
49015,"/** 
 * Get a virtual device by device label.
 * @param label virtual device label
 * @return virtual device, null if not found
 */
protected VirtualDevice getDeviceByLabel(String label){
  VirtualDevice target=null;
  for (  VirtualDevice device : getDevice()) {
    if (device.getDeviceInfo().getLabel().equalsIgnoreCase(label)) {
      target=device;
      break;
    }
  }
  return target;
}","/** 
 * Get a virtual device by device label.
 * @param label virtual device label
 * @return virtual device, null if not found
 */
public VirtualDevice getDeviceByLabel(String label){
  VirtualDevice target=null;
  for (  VirtualDevice device : getDevice()) {
    if (device.getDeviceInfo().getLabel().equalsIgnoreCase(label)) {
      target=device;
      break;
    }
  }
  return target;
}"
49016,"@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(NetworkAdd networkAdd,List<BaseNode> vNodes,StatusUpdater statusUpdator,Set<String> occupiedIps){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  allocateStaticIp(networkAdd,vNodes,occupiedIps);
  Pair<Callable<Void>,Callable<Void>>[] storeProcedures=new Pair[vNodes.size()];
  for (int i=0; i < vNodes.size(); i++) {
    BaseNode vNode=vNodes.get(i);
    VmSchema createSchema=getVmSchema(vNode);
    Map<String,String> guestVariable=getNetworkGuestVariable(networkAdd,vNode);
    QueryIpAddress query=new QueryIpAddress(Constants.VM_POWER_ON_WAITING_SEC);
    CreateVmPrePowerOn prePowerOn=getPrePowerOnFunc(vNode);
    CreateVmSP cloneVmSp=new CreateVmSP(vNode.getVmName(),createSchema,getVcResourcePool(vNode,clusterRpName),getVcDatastore(vNode),prePowerOn,query,guestVariable,false,folders.get(vNode.getGroupName()),VcResourceUtils.findHost(vNode.getTargetHost()));
    CompensateCreateVmSP deleteVmSp=new CompensateCreateVmSP(cloneVmSp);
    storeProcedures[i]=new Pair<Callable<Void>,Callable<Void>>(cloneVmSp,deleteVmSp);
  }
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    logger.info(""String_Node_Str"");
    Pair<ExecutionResult,ExecutionResult>[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,storeProcedures.length - 1,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    int total=0;
    boolean success=true;
    List<BaseNode> failedNodes=new ArrayList<BaseNode>();
    for (int i=0; i < storeProcedures.length; i++) {
      Pair<ExecutionResult,ExecutionResult> pair=result[i];
      BaseNode vNode=vNodes.get(i);
      CreateVmSP sp=(CreateVmSP)storeProcedures[i].first;
      if (pair.first.finished && pair.first.throwable == null && pair.second.finished == false) {
        ++total;
        VcVirtualMachine vm=sp.getVM();
        AuAssert.check(vm != null);
        boolean vmSucc=VcVmUtil.setBaseNodeForVm(vNode,vm);
        if (!vmSucc) {
          success=vmSucc;
        }
      }
 else       if (pair.first.throwable != null) {
        processException(pair.first.throwable);
        logger.error(""String_Node_Str"" + vNode.getVmName(),pair.first.throwable);
        vNode.setSuccess(false);
        if (sp.getVM() != null) {
          vNode.setVmMobId(sp.getVM().getId());
        }
        failedNodes.add(vNode);
        success=false;
      }
      vNode.setFinished(true);
    }
    logger.info(total + ""String_Node_Str"");
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(NetworkAdd networkAdd,List<BaseNode> vNodes,StatusUpdater statusUpdator,Set<String> occupiedIps){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  setNetworkSchema(vNodes);
  allocateStaticIp(networkAdd,vNodes,occupiedIps);
  Pair<Callable<Void>,Callable<Void>>[] storeProcedures=new Pair[vNodes.size()];
  for (int i=0; i < vNodes.size(); i++) {
    BaseNode vNode=vNodes.get(i);
    VmSchema createSchema=getVmSchema(vNode);
    Map<String,String> guestVariable=getNetworkGuestVariable(networkAdd,vNode);
    QueryIpAddress query=new QueryIpAddress(Constants.VM_POWER_ON_WAITING_SEC);
    CreateVmPrePowerOn prePowerOn=getPrePowerOnFunc(vNode);
    CreateVmSP cloneVmSp=new CreateVmSP(vNode.getVmName(),createSchema,getVcResourcePool(vNode,clusterRpName),getVcDatastore(vNode),prePowerOn,query,guestVariable,false,folders.get(vNode.getGroupName()),VcResourceUtils.findHost(vNode.getTargetHost()));
    CompensateCreateVmSP deleteVmSp=new CompensateCreateVmSP(cloneVmSp);
    storeProcedures[i]=new Pair<Callable<Void>,Callable<Void>>(cloneVmSp,deleteVmSp);
  }
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    logger.info(""String_Node_Str"");
    Pair<ExecutionResult,ExecutionResult>[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,storeProcedures.length - 1,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    int total=0;
    boolean success=true;
    List<BaseNode> failedNodes=new ArrayList<BaseNode>();
    for (int i=0; i < storeProcedures.length; i++) {
      Pair<ExecutionResult,ExecutionResult> pair=result[i];
      BaseNode vNode=vNodes.get(i);
      CreateVmSP sp=(CreateVmSP)storeProcedures[i].first;
      if (pair.first.finished && pair.first.throwable == null && pair.second.finished == false) {
        ++total;
        VcVirtualMachine vm=sp.getVM();
        AuAssert.check(vm != null);
        boolean vmSucc=VcVmUtil.setBaseNodeForVm(vNode,vm);
        if (!vmSucc) {
          success=vmSucc;
        }
      }
 else       if (pair.first.throwable != null) {
        processException(pair.first.throwable);
        logger.error(""String_Node_Str"" + vNode.getVmName(),pair.first.throwable);
        vNode.setSuccess(false);
        if (sp.getVM() != null) {
          vNode.setVmMobId(sp.getVM().getId());
        }
        failedNodes.add(vNode);
        success=false;
      }
      vNode.setFinished(true);
    }
    logger.info(total + ""String_Node_Str"");
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
49017,"public synchronized void init(){
  if (!initialized) {
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.ALLOWED);
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.FINALIZED);
    VcContext.initVcContext();
    new VcEventRouter();
    CmsWorker.addPeriodic(new VcInventory.SyncInventoryRequest());
    VcInventory.loadInventory();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    new VcEventProcessor(getClusterEntityMgr());
    Scheduler.init(50,50);
    CmsWorker.addPeriodic(new ClusterNodeUpdator(getClusterEntityMgr()));
    snapshotTemplateVM();
    convertTemplateVm();
    initialized=true;
  }
}","public synchronized void init(){
  if (!initialized) {
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.ALLOWED);
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.FINALIZED);
    VcContext.initVcContext();
    new VcEventRouter();
    CmsWorker.addPeriodic(new VcInventory.SyncInventoryRequest());
    VcInventory.loadInventory();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    new VcEventProcessor(getClusterEntityMgr());
    Scheduler.init(50,50);
    CmsWorker.addPeriodic(new ClusterNodeUpdator(getClusterEntityMgr()));
    snapshotTemplateVM();
    loadTemplateNetworkLable();
    convertTemplateVm();
    initialized=true;
  }
}"
49018,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
  addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
  removeDeletedNode(clusterName,deletedNodeNames);
  Boolean deleted=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETE_VM_OPERATION_SUCCESS,Boolean.class);
  Boolean created=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_CREATE_VM_OPERATION_SUCCESS,Boolean.class);
  if (deleted != null && !deleted) {
    logger.error(""String_Node_Str"");
    throw ClusteringServiceException.DELETE_CLUSTER_VM_FAILED(clusterName);
  }
  if (created != null && !created) {
    throw ClusteringServiceException.VM_CREATION_FAILED(clusterName);
  }
  if (created != null) {
    String verifyScope=getJobParameters(chunkContext).getString(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM);
    if (verifyScope != null && verifyScope.equals(JobConstants.GROUP_NODE_SCOPE_VALUE)) {
      String groupName=getJobParameters(chunkContext).getString(JobConstants.GROUP_NAME_JOB_PARAM);
      long oldInstanceNum=getJobParameters(chunkContext).getLong(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM);
      verifyGroupVmReady(clusterName,groupName,oldInstanceNum);
    }
 else {
      verifyAllVmReady(clusterName);
    }
  }
  updateVhmMasterMoid(clusterName);
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
  addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
  removeDeletedNode(clusterName,deletedNodeNames);
  updateVhmMasterMoid(clusterName);
  return RepeatStatus.FINISHED;
}"
49019,"public boolean isStrictAssociated(){
  return strictAssociated;
}","public boolean isStrictAssociated(){
  return strictAssociated == null ? false : strictAssociated;
}"
49020,"public static boolean setBaseNodeForVm(BaseNode vNode,VcVirtualMachine vm){
  boolean success=true;
  String vmName=vm.getName();
  vm=VcCache.getIgnoreMissing(vm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmName + ""String_Node_Str"");
  }
  String ip=null;
  if (vm != null) {
    ip=VcVmUtil.getIpAddress(vm,false);
  }
  if (ip != null) {
    vNode.setSuccess(true);
    vNode.setIpAddress(ip);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setTargetRp(vm.getResourcePool().getName());
    vNode.setTargetVcCluster(vm.getResourcePool().getVcCluster().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOff()) {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    }
 else {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
  }
 else {
    vNode.setSuccess(false);
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  String haFlag=vNode.getNodeGroup().getHaFlag();
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    if (vm.getFTState() == null || vm.getFTState() != FaultToleranceState.running) {
      logger.fatal(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      success=false;
    }
  }
  return success;
}","public static boolean setBaseNodeForVm(BaseNode vNode,VcVirtualMachine vm){
  boolean success=true;
  String vmName=vm.getName();
  vm=VcCache.getIgnoreMissing(vm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmName + ""String_Node_Str"");
  }
  String ip=null;
  if (vm != null) {
    ip=VcVmUtil.getIpAddress(vm,false);
  }
  if (ip != null) {
    vNode.setSuccess(true);
    vNode.setIpAddress(ip);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOff()) {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    }
 else {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
  }
 else {
    vNode.setSuccess(false);
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  String haFlag=vNode.getNodeGroup().getHaFlag();
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    if (vm.getFTState() == null || vm.getFTState() != FaultToleranceState.running) {
      logger.fatal(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      success=false;
    }
  }
  return success;
}"
49021,"public Long resizeCluster(String clusterName,String nodeGroupName,int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  List<String> dsNames=getUsedDS(cluster.getVcDatastoreNameList());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(cluster.getVcRpNameList());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(clusterName,cluster.getNetwork().getName(),vcClusters);
  NodeGroupEntity group=clusterEntityMgr.findByName(cluster,nodeGroupName);
  if (group == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
    throw ClusterManagerException.NODEGROUP_NOT_FOUND_ERROR(nodeGroupName);
  }
  List<String> roles=group.getRoleNameList();
  List<String> unsupportedRoles=new ArrayList<String>();
  AuAssert.check(!roles.isEmpty(),""String_Node_Str"");
  if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.ZOOKEEPER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.ZOOKEEPER_ROLE.toString());
  }
  if (!unsupportedRoles.isEmpty()) {
    logger.info(""String_Node_Str"" + unsupportedRoles);
    throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (instanceNum <= group.getDefineInstanceNum()) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
    throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
  }
  Integer instancePerHost=group.getInstancePerHost();
  if (instancePerHost != null && instanceNum % instancePerHost != 0) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
  }
  ValidationUtils.validHostNumber(clusterEntityMgr,group,instanceNum);
  ValidationUtils.hasEnoughHost(rackDao,group,instanceNum);
  int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  clusterEntityMgr.update(group);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.GROUP_NAME_JOB_PARAM,new JobParameter(nodeGroupName));
  param.put(JobConstants.GROUP_INSTANCE_NEW_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(instanceNum)));
  param.put(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(oldInstanceNum)));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.GROUP_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPDATING);
  try {
    return jobManager.runJob(JobConstants.RESIZE_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.RUNNING);
    group.setDefineInstanceNum(oldInstanceNum);
    clusterEntityMgr.update(group);
    throw e;
  }
}","public Long resizeCluster(String clusterName,String nodeGroupName,int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  List<String> dsNames=getUsedDS(cluster.getVcDatastoreNameList());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(cluster.getVcRpNameList());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(clusterName,cluster.getNetwork().getName(),vcClusters);
  NodeGroupEntity group=clusterEntityMgr.findByName(cluster,nodeGroupName);
  if (group == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
    throw ClusterManagerException.NODEGROUP_NOT_FOUND_ERROR(nodeGroupName);
  }
  List<String> roles=group.getRoleNameList();
  List<String> unsupportedRoles=new ArrayList<String>();
  AuAssert.check(!roles.isEmpty(),""String_Node_Str"");
  if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.ZOOKEEPER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.ZOOKEEPER_ROLE.toString());
  }
  if (!unsupportedRoles.isEmpty()) {
    logger.info(""String_Node_Str"" + unsupportedRoles);
    throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (instanceNum <= group.getDefineInstanceNum()) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
    throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
  }
  Integer instancePerHost=group.getInstancePerHost();
  if (instancePerHost != null && instanceNum % instancePerHost != 0) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
  }
  ValidationUtils.validHostNumber(clusterEntityMgr,group,instanceNum);
  ValidationUtils.hasEnoughHost(rackInfoMgr,clusterEntityMgr,group,instanceNum);
  int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  clusterEntityMgr.update(group);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.GROUP_NAME_JOB_PARAM,new JobParameter(nodeGroupName));
  param.put(JobConstants.GROUP_INSTANCE_NEW_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(instanceNum)));
  param.put(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(oldInstanceNum)));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.GROUP_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPDATING);
  try {
    return jobManager.runJob(JobConstants.RESIZE_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.RUNNING);
    group.setDefineInstanceNum(oldInstanceNum);
    clusterEntityMgr.update(group);
    throw e;
  }
}"
49022,"public void setAutoElasticity(String clusterName,boolean enableAutoElasticity,Integer minComputeNodeNum,ElasticityOperation op) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  Boolean preEnableSetting=cluster.getAutomationEnable();
  int preMinComputeNodeNum=cluster.getVhmMinNum();
  if (preEnableSetting == null) {
    if (op != ElasticityOperation.OP_SET_AUTO) {
      return;
    }
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  cluster.setAutomationEnable(enableAutoElasticity);
  if (minComputeNodeNum != null) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  clusterEntityMgr.update(cluster);
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  JobParameters jobParameters=new JobParameters(param);
  try {
    jobManager.runJob(JobConstants.SET_AUTO_ELASTICITY_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    throw e;
  }
}","public void setAutoElasticity(String clusterName,boolean enableAutoElasticity,Integer minComputeNodeNum,ElasticityOperation op) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  Boolean preEnableSetting=cluster.getAutomationEnable();
  if (preEnableSetting == null) {
    if (op != ElasticityOperation.OP_SET_AUTO) {
      return;
    }
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  cluster.setAutomationEnable(enableAutoElasticity);
  if (minComputeNodeNum != null) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  clusterEntityMgr.update(cluster);
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  JobParameters jobParameters=new JobParameters(param);
  try {
    jobManager.runJob(JobConstants.SET_AUTO_ELASTICITY_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    throw e;
  }
}"
49023,"@Transactional(propagation=Propagation.MANDATORY) public static void hasEnoughHost(IRackDAO rackDao,NodeGroupEntity nodeGroup,int instanceNum){
  if (nodeGroup.getInstancePerHost() != null) {
    int requiredHostNum=instanceNum / nodeGroup.getInstancePerHost();
    if (nodeGroup.getGroupRacks() != null) {
      GroupRacks groupRacks=new Gson().fromJson(nodeGroup.getGroupRacks(),GroupRacks.class);
      GroupRacksType rackType=groupRacks.getType();
      List<RackInfo> racksInfo=new ArrayList<RackInfo>();
      List<RackEntity> racks=rackDao.findAll();
      for (      RackEntity rack : racks) {
        List<PhysicalHostEntity> hostEntities=rack.getHosts();
        if (hostEntities != null && !hostEntities.isEmpty()) {
          List<String> hosts=new ArrayList<String>(hostEntities.size());
          for (          PhysicalHostEntity he : hostEntities) {
            hosts.add(he.getName());
          }
          RackInfo rackInfo=new RackInfo();
          rackInfo.setName(rack.getName());
          rackInfo.setHosts(hosts);
          racksInfo.add(rackInfo);
        }
      }
      Set<String> specifiedRacks=new HashSet<String>(Arrays.asList(groupRacks.getRacks()));
      List<String> IntersecRacks=new ArrayList<String>();
      Integer IntersecHostNum=0;
      Integer maxIntersecHostNum=0;
      for (      RackInfo rackInfo : racksInfo) {
        if (specifiedRacks.isEmpty() || specifiedRacks.size() == 0 || specifiedRacks.contains(rackInfo.getName())) {
          IntersecHostNum+=rackInfo.getHosts().size();
          IntersecRacks.add(rackInfo.getName());
          if (rackInfo.getHosts().size() > maxIntersecHostNum) {
            maxIntersecHostNum=rackInfo.getHosts().size();
          }
        }
      }
      if (rackType.equals(GroupRacksType.ROUNDROBIN) && IntersecHostNum < requiredHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(nodeGroup.getName(),requiredHostNum,IntersecHostNum);
      }
 else       if (rackType.equals(GroupRacksType.SAMERACK) && requiredHostNum > maxIntersecHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(nodeGroup.getName(),requiredHostNum,maxIntersecHostNum);
      }
      if (specifiedRacks.isEmpty()) {
        groupRacks.setRacks(new String[0]);
      }
 else {
        groupRacks.setRacks(IntersecRacks.toArray(new String[IntersecRacks.size()]));
      }
      nodeGroup.setGroupRacks((new Gson()).toJson(groupRacks));
    }
  }
}","public static void hasEnoughHost(RackInfoManager rackInfoMgr,ClusterEntityManager clusterEntityMgr,NodeGroupEntity nodeGroup,int instanceNum){
  if (nodeGroup.getInstancePerHost() != null) {
    int requiredHostNum=instanceNum / nodeGroup.getInstancePerHost();
    if (nodeGroup.getGroupRacks() != null) {
      GroupRacks groupRacks=new Gson().fromJson(nodeGroup.getGroupRacks(),GroupRacks.class);
      GroupRacksType rackType=groupRacks.getType();
      List<RackInfo> racksInfo=rackInfoMgr.getRackInfos();
      Set<String> specifiedRacks=new HashSet<String>(Arrays.asList(groupRacks.getRacks()));
      List<String> IntersecRacks=new ArrayList<String>();
      Integer IntersecHostNum=0;
      Integer maxIntersecHostNum=0;
      for (      RackInfo rackInfo : racksInfo) {
        if (specifiedRacks.isEmpty() || specifiedRacks.size() == 0 || specifiedRacks.contains(rackInfo.getName())) {
          IntersecHostNum+=rackInfo.getHosts().size();
          IntersecRacks.add(rackInfo.getName());
          if (rackInfo.getHosts().size() > maxIntersecHostNum) {
            maxIntersecHostNum=rackInfo.getHosts().size();
          }
        }
      }
      if (rackType.equals(GroupRacksType.ROUNDROBIN) && IntersecHostNum < requiredHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(nodeGroup.getName(),requiredHostNum,IntersecHostNum);
      }
 else       if (rackType.equals(GroupRacksType.SAMERACK) && requiredHostNum > maxIntersecHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(nodeGroup.getName(),requiredHostNum,maxIntersecHostNum);
      }
      if (specifiedRacks.isEmpty()) {
        groupRacks.setRacks(new String[0]);
      }
 else {
        groupRacks.setRacks(IntersecRacks.toArray(new String[IntersecRacks.size()]));
      }
      nodeGroup.setGroupRacks((new Gson()).toJson(groupRacks));
      clusterEntityMgr.update(nodeGroup);
    }
  }
}"
49024,"@Transactional(propagation=Propagation.MANDATORY) public static void validHostNumber(ClusterEntityManager clusterEntityMgr,NodeGroupEntity nodeGroup,int instanceNum){
  Set<NodeGroupAssociation> associations=nodeGroup.getGroupAssociations();
  if (associations != null && !associations.isEmpty()) {
    AuAssert.check(associations.size() == 1,""String_Node_Str"");
    NodeGroupAssociation association=associations.iterator().next();
    if (association.getAssociationType() == GroupAssociationType.STRICT) {
      NodeGroupEntity refGroup=clusterEntityMgr.findByName(nodeGroup.getCluster(),association.getReferencedGroup());
      AuAssert.check(refGroup != null,""String_Node_Str"");
      int hostNum=1;
      int refHostNum=refGroup.getDefineInstanceNum();
      if (nodeGroup.getInstancePerHost() != null) {
        hostNum=instanceNum / nodeGroup.getInstancePerHost();
      }
      if (refGroup.getInstancePerHost() != null) {
        refHostNum=refGroup.getDefineInstanceNum() / refGroup.getInstancePerHost();
      }
      if (hostNum > refHostNum) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"" + ""String_Node_Str"").toString());
      }
    }
  }
}","public static void validHostNumber(ClusterEntityManager clusterEntityMgr,NodeGroupEntity nodeGroup,int instanceNum){
  Set<NodeGroupAssociation> associations=nodeGroup.getGroupAssociations();
  if (associations != null && !associations.isEmpty()) {
    AuAssert.check(associations.size() == 1,""String_Node_Str"");
    NodeGroupAssociation association=associations.iterator().next();
    if (association.getAssociationType() == GroupAssociationType.STRICT) {
      NodeGroupEntity refGroup=clusterEntityMgr.findByName(nodeGroup.getCluster(),association.getReferencedGroup());
      AuAssert.check(refGroup != null,""String_Node_Str"");
      int hostNum=1;
      int refHostNum=refGroup.getDefineInstanceNum();
      if (nodeGroup.getInstancePerHost() != null) {
        hostNum=instanceNum / nodeGroup.getInstancePerHost();
      }
      if (refGroup.getInstancePerHost() != null) {
        refHostNum=refGroup.getDefineInstanceNum() / refGroup.getInstancePerHost();
      }
      if (hostNum > refHostNum) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"" + ""String_Node_Str"").toString());
      }
    }
  }
}"
49025,"@Override public boolean deleteCluster(final String name,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"" + name);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(name);
  List<BaseNode> vNodes=JobUtils.convertNodeEntities(null,null,nodes);
  boolean deleted=syncDeleteVMs(vNodes,statusUpdator);
  if (nodes.size() > 0) {
    try {
      deleteFolders(vNodes.get(0));
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return deleted;
}","@Override public boolean deleteCluster(final String name,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"" + name);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(name);
  List<BaseNode> vNodes=JobUtils.convertNodeEntities(null,null,nodes);
  boolean deleted=syncDeleteVMs(vNodes,statusUpdator);
  if (nodes.size() > 0) {
    try {
      deleteChildRps(name,vNodes);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
    try {
      deleteFolders(vNodes.get(0));
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return deleted;
}"
49026,"@Override public Void call() throws Exception {
  final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return null;
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
      if (info != null && info.getRole() == 1) {
        logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
        vcVm.turnOffFT();
      }
      vcVm.destroy();
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}","@Override public Void call() throws Exception {
  final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return null;
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
      if (info != null && info.getRole() == 1) {
        logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
        vcVm.turnOffFT();
      }
      if (vcVm.isPoweredOn()) {
        vcVm.powerOff();
      }
      vcVm.destroy();
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}"
49027,"@Override protected Void body() throws Exception {
  FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
  if (info != null && info.getRole() == 1) {
    logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
    vcVm.turnOffFT();
  }
  vcVm.destroy();
  return null;
}","@Override protected Void body() throws Exception {
  FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
  if (info != null && info.getRole() == 1) {
    logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
    vcVm.turnOffFT();
  }
  if (vcVm.isPoweredOn()) {
    vcVm.powerOff();
  }
  vcVm.destroy();
  return null;
}"
49028,"public static void verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  for (  NodeEntity node : nodes) {
    if (node.getStatus() != expectedStatus) {
      if (ignoreMissing && node.getStatus() == NodeStatus.NOT_EXIST) {
        continue;
      }
      throw ClusteringServiceException.VM_STATUS_ERROR(node.getVmName(),node.getStatus().toString(),expectedStatus.toString());
    }
  }
}","public static void verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  for (  NodeEntity node : nodes) {
    if (node.getStatus() != expectedStatus) {
      if (ignoreMissing && node.getStatus() == NodeStatus.NOT_EXIST) {
        continue;
      }
      if (expectedStatus == NodeStatus.VM_READY) {
        VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
        if (vm != null && vm.isPoweredOn() && (VcVmUtil.getIpAddress(vm,false) != null)) {
          continue;
        }
      }
      throw ClusteringServiceException.VM_STATUS_ERROR(node.getVmName(),node.getStatus().toString(),expectedStatus.toString());
    }
  }
}"
49029,"public boolean supportedWithHdfs2(){
  if (this.getDistroVendor().equalsIgnoreCase(Constants.CDH_VENDOR)) {
    Pattern pattern=Pattern.compile(Constants.CDH4_1_PATTERN);
    if (pattern.matcher(this.getDistroVersion()).matches()) {
      return true;
    }
  }
  return false;
}","public boolean supportedWithHdfs2(){
  if (this.getDistroVendor().equalsIgnoreCase(Constants.CDH_VENDOR)) {
    Pattern pattern=Pattern.compile(Constants.CDH4_PATTERN);
    if (pattern.matcher(this.getDistroVersion()).matches()) {
      return true;
    }
  }
  return false;
}"
49030,"@Test public void testSupportedWithHdfs2(){
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.DEFAULT_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVendor(Constants.CDH_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
}","@Test public void testSupportedWithHdfs2(){
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.DEFAULT_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVendor(Constants.CDH_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
}"
49031,"private void updateVhmJobTrackerPort(ClusterCreate cluster,ClusterEntity clusterEntity){
  clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
  if (cluster.getConfiguration().containsKey(""String_Node_Str"")) {
    @SuppressWarnings(""String_Node_Str"") Map<String,Object> hadoopConfig=(Map<String,Object>)cluster.getConfiguration().get(""String_Node_Str"");
    if (hadoopConfig.containsKey(""String_Node_Str"")) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> maprConfig=(Map<String,Object>)hadoopConfig.get(""String_Node_Str"");
      String jobtrackerAddress=(String)maprConfig.get(""String_Node_Str"");
      if (jobtrackerAddress != null) {
        String[] items=jobtrackerAddress.split(""String_Node_Str"");
        String port=items[items.length - 1];
        Pattern pattern=Pattern.compile(""String_Node_Str"");
        Matcher matcher=pattern.matcher(port);
        if (matcher.matches()) {
          clusterEntity.setVhmJobTrackerPort(port);
        }
      }
    }
  }
}","private void updateVhmJobTrackerPort(ClusterCreate cluster,ClusterEntity clusterEntity){
  if (cluster.getConfiguration().containsKey(""String_Node_Str"")) {
    @SuppressWarnings(""String_Node_Str"") Map<String,Object> hadoopConfig=(Map<String,Object>)cluster.getConfiguration().get(""String_Node_Str"");
    if (hadoopConfig.containsKey(""String_Node_Str"")) {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> maprConfig=(Map<String,Object>)hadoopConfig.get(""String_Node_Str"");
      String jobtrackerAddress=(String)maprConfig.get(""String_Node_Str"");
      if (jobtrackerAddress != null) {
        String[] items=jobtrackerAddress.split(""String_Node_Str"");
        String port=items[items.length - 1];
        Pattern pattern=Pattern.compile(""String_Node_Str"");
        Matcher matcher=pattern.matcher(port);
        if (matcher.matches()) {
          clusterEntity.setVhmJobTrackerPort(port);
        }
      }
    }
  }
}"
49032,"@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  if (cluster.getDistro() == null || distroMgr.getDistroByName(cluster.getDistro()) == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  if (!cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
    cluster.validateClusterCreate(failedMsgList,warningMsgList,distroMgr.getDistroByName(cluster.getDistro()).getRoles());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    String networkName=cluster.getNetworkName();
    NetworkEntity networkEntity=null;
    if (networkName == null || networkName.isEmpty()) {
      List<NetworkEntity> nets=networkMgr.getAllNetworkEntities();
      if (nets.isEmpty() || nets.size() > 1) {
        throw ClusterConfigException.NETWORK_IS_NOT_SPECIFIED(nets.size(),name);
      }
 else {
        networkEntity=nets.get(0);
      }
    }
 else {
      networkEntity=networkMgr.getNetworkEntityByName(networkName);
    }
    if (networkEntity == null) {
      throw ClusterConfigException.NETWORK_IS_NOT_FOUND(networkName,name);
    }
    clusterEntity.setNetwork(networkEntity);
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,EnumSet.noneOf(HadoopRole.class),cluster.isValidateConfig()));
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  if (cluster.getDistro() == null || distroMgr.getDistroByName(cluster.getDistro()) == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  if (!cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
    cluster.validateClusterCreate(failedMsgList,warningMsgList,distroMgr.getDistroByName(cluster.getDistro()).getRoles());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    String networkName=cluster.getNetworkName();
    NetworkEntity networkEntity=null;
    if (networkName == null || networkName.isEmpty()) {
      List<NetworkEntity> nets=networkMgr.getAllNetworkEntities();
      if (nets.isEmpty() || nets.size() > 1) {
        throw ClusterConfigException.NETWORK_IS_NOT_SPECIFIED(nets.size(),name);
      }
 else {
        networkEntity=nets.get(0);
      }
    }
 else {
      networkEntity=networkMgr.getNetworkEntityByName(networkName);
    }
    if (networkEntity == null) {
      throw ClusterConfigException.NETWORK_IS_NOT_FOUND(networkName,name);
    }
    clusterEntity.setNetwork(networkEntity);
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,EnumSet.noneOf(HadoopRole.class),cluster.isValidateConfig()));
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
49033,"@SuppressWarnings(""String_Node_Str"") public boolean validatePlacementPolicies(ClusterCreate cluster,Map<String,NodeGroupCreate> groups,List<String> failedMsgList,List<String> warningMsgList){
  boolean valid=true;
  TopologyType topologyType=cluster.getTopologyPolicy();
  if (topologyType != null && (topologyType.equals(TopologyType.HVE) || topologyType.equals(TopologyType.RACK_AS_RACK)) && isWorkerGroup()) {
    if (getPlacementPolicies() == null) {
      setPlacementPolicies(new PlacementPolicy());
    }
    if (getPlacementPolicies().getGroupRacks() == null && getPlacementPolicies().getGroupAssociations() == null) {
      GroupRacks groupRacks=new GroupRacks();
      groupRacks.setType(GroupRacksType.ROUNDROBIN);
      groupRacks.setRacks(new String[0]);
      getPlacementPolicies().setGroupRacks(groupRacks);
    }
  }
  PlacementPolicy policies=getPlacementPolicies();
  if (policies != null) {
    if (policies.getInstancePerHost() != null) {
      if (policies.getInstancePerHost() <= 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).toString());
      }
 else       if (calculateHostNum() < 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupRacks() != null) {
      GroupRacks r=policies.getGroupRacks();
      if (r.getType() == null) {
        r.setType(GroupRacksType.ROUNDROBIN);
      }
      if (r.getRacks() == null) {
        r.setRacks(new String[0]);
      }
      if (getStorage() == null || getStorage().getType() == null || getStorage().getType().equals(DatastoreType.SHARED.toString())) {
        warningMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getName()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupAssociations() != null) {
      if (policies.getGroupRacks() != null) {
        warningMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getName()).append(""String_Node_Str"").toString());
      }
      if (policies.getGroupAssociations().size() != 1) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
      }
 else {
        GroupAssociation a=policies.getGroupAssociations().get(0);
        if (a.getType() == null) {
          a.setType(GroupAssociationType.WEAK);
        }
        if (a.getReference() == null) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (a.getReference().equals(getName())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (!groups.containsKey(a.getReference())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).toString());
        }
 else {
          if (a.getType() == GroupAssociationType.STRICT) {
            int hostNum=1;
            int refHostNum=groups.get(a.getReference()).getInstanceNum();
            if (calculateHostNum() != null) {
              hostNum=calculateHostNum();
            }
            if (groups.get(a.getReference()).calculateHostNum() != null) {
              refHostNum=groups.get(a.getReference()).calculateHostNum();
            }
            if (hostNum > refHostNum) {
              valid=false;
              failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"" + ""String_Node_Str"").append(a.getReference()).toString());
            }
          }
          PlacementPolicy refPolicies=groups.get(a.getReference()).getPlacementPolicies();
          if (refPolicies != null && refPolicies.getGroupAssociations() != null && !refPolicies.getGroupAssociations().isEmpty()) {
            valid=false;
            failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
          }
        }
      }
    }
  }
  return valid;
}","@SuppressWarnings(""String_Node_Str"") public boolean validatePlacementPolicies(ClusterCreate cluster,Map<String,NodeGroupCreate> groups,List<String> failedMsgList,List<String> warningMsgList){
  boolean valid=true;
  TopologyType topologyType=cluster.getTopologyPolicy();
  if (topologyType != null && (topologyType.equals(TopologyType.HVE) || topologyType.equals(TopologyType.RACK_AS_RACK)) && isWorkerGroup()) {
    if (getPlacementPolicies() == null) {
      setPlacementPolicies(new PlacementPolicy());
    }
    if (getPlacementPolicies().getGroupRacks() == null && getPlacementPolicies().getGroupAssociations() == null) {
      GroupRacks groupRacks=new GroupRacks();
      groupRacks.setType(GroupRacksType.ROUNDROBIN);
      groupRacks.setRacks(new String[0]);
      getPlacementPolicies().setGroupRacks(groupRacks);
    }
  }
  PlacementPolicy policies=getPlacementPolicies();
  if (policies != null) {
    if (policies.getInstancePerHost() != null) {
      if (policies.getInstancePerHost() <= 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).toString());
      }
 else       if (calculateHostNum() < 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupRacks() != null) {
      GroupRacks r=policies.getGroupRacks();
      if (r.getType() == null) {
        r.setType(GroupRacksType.ROUNDROBIN);
      }
      if (r.getRacks() == null) {
        r.setRacks(new String[0]);
      }
      if (getStorage() != null && getStorage().getType() != null && getStorage().getType().equals(DatastoreType.SHARED.toString())) {
        warningMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getName()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupAssociations() != null) {
      if (policies.getGroupRacks() != null) {
        warningMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getName()).append(""String_Node_Str"").toString());
      }
      if (policies.getGroupAssociations().size() != 1) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
      }
 else {
        GroupAssociation a=policies.getGroupAssociations().get(0);
        if (a.getType() == null) {
          a.setType(GroupAssociationType.WEAK);
        }
        if (a.getReference() == null) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (a.getReference().equals(getName())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (!groups.containsKey(a.getReference())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).toString());
        }
 else {
          if (a.getType() == GroupAssociationType.STRICT) {
            int hostNum=1;
            int refHostNum=groups.get(a.getReference()).getInstanceNum();
            if (calculateHostNum() != null) {
              hostNum=calculateHostNum();
            }
            if (groups.get(a.getReference()).calculateHostNum() != null) {
              refHostNum=groups.get(a.getReference()).calculateHostNum();
            }
            if (hostNum > refHostNum) {
              valid=false;
              failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"" + ""String_Node_Str"").append(a.getReference()).toString());
            }
          }
          PlacementPolicy refPolicies=groups.get(a.getReference()).getPlacementPolicies();
          if (refPolicies != null && refPolicies.getGroupAssociations() != null && !refPolicies.getGroupAssociations().isEmpty()) {
            valid=false;
            failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
          }
        }
      }
    }
  }
  return valid;
}"
49034,"public static void expandGroupInstanceType(NodeGroupEntity ngEntity,GroupType groupType,Set<String> sharedPattern,Set<String> localPattern){
  logger.debug(""String_Node_Str"" + ngEntity.getName());
  InstanceType instanceType=ngEntity.getNodeType();
  if (instanceType == null) {
    if (groupType == GroupType.MASTER_GROUP || groupType == GroupType.MASTER_JOBTRACKER_GROUP || groupType == GroupType.HBASE_MASTER_GROUP || groupType == GroupType.ZOOKEEPER_GROUP) {
      instanceType=InstanceType.MEDIUM;
    }
 else {
      instanceType=InstanceType.SMALL;
    }
  }
  logger.debug(""String_Node_Str"" + instanceType.toString());
  int memory=ngEntity.getMemorySize();
  if (memory <= 0) {
    ngEntity.setMemorySize(instanceType.getMemoryMB());
  }
  int cpu=ngEntity.getCpuNum();
  if (cpu <= 0) {
    ngEntity.setCpuNum(instanceType.getCpuNum());
  }
  if (ngEntity.getStorageSize() <= 0) {
    ngEntity.setStorageSize(getStorage(instanceType,groupType));
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
 else {
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
  if (ngEntity.getStorageType() == null) {
    DatastoreType storeType=groupType.getStorageEnumType();
    if ((sharedPattern == null || sharedPattern.isEmpty()) && storeType == DatastoreType.SHARED) {
      storeType=DatastoreType.LOCAL;
    }
    if ((localPattern == null || localPattern.isEmpty()) && storeType == DatastoreType.LOCAL) {
      storeType=DatastoreType.SHARED;
    }
    ngEntity.setStorageType(storeType);
  }
  if (groupType == GroupType.ZOOKEEPER_GROUP) {
    ngEntity.setDiskBisect(true);
  }
 else {
    ngEntity.setDiskBisect(false);
  }
}","public static void expandGroupInstanceType(NodeGroupEntity ngEntity,GroupType groupType,Set<String> sharedPattern,Set<String> localPattern){
  logger.debug(""String_Node_Str"" + ngEntity.getName());
  InstanceType instanceType=ngEntity.getNodeType();
  if (instanceType == null) {
    if (groupType == GroupType.MASTER_GROUP || groupType == GroupType.MASTER_JOBTRACKER_GROUP || groupType == GroupType.HBASE_MASTER_GROUP || groupType == GroupType.ZOOKEEPER_GROUP) {
      instanceType=InstanceType.MEDIUM;
    }
 else {
      instanceType=InstanceType.SMALL;
    }
  }
  logger.debug(""String_Node_Str"" + instanceType.toString());
  int memory=ngEntity.getMemorySize();
  if (memory <= 0) {
    ngEntity.setMemorySize(instanceType.getMemoryMB());
  }
  int cpu=ngEntity.getCpuNum();
  if (cpu <= 0) {
    ngEntity.setCpuNum(instanceType.getCpuNum());
  }
  if (ngEntity.getStorageSize() <= 0) {
    ngEntity.setStorageSize(getStorage(instanceType,groupType));
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
 else {
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
  if (ngEntity.getStorageType() == null) {
    DatastoreType storeType=groupType.getStorageEnumType();
    if ((sharedPattern == null || sharedPattern.isEmpty()) && storeType == DatastoreType.SHARED) {
      storeType=DatastoreType.LOCAL;
    }
    if ((localPattern == null || localPattern.isEmpty()) && storeType == DatastoreType.LOCAL) {
      storeType=DatastoreType.SHARED;
    }
    ngEntity.setStorageType(storeType);
  }
 else {
    if ((sharedPattern == null || sharedPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.SHARED))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
    if ((localPattern == null || localPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.LOCAL))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
  }
  if (groupType == GroupType.ZOOKEEPER_GROUP) {
    ngEntity.setDiskBisect(true);
  }
 else {
    ngEntity.setDiskBisect(false);
  }
}"
49035,"public Long resizeCluster(final String clusterName,final String nodeGroupName,final int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  final ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  final NodeGroupEntity group=DAL.inRoTransactionDo(new Saveable<NodeGroupEntity>(){
    @Override public NodeGroupEntity body() throws Exception {
      NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
      if (group == null) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
        throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
      }
      List<String> roles=group.getRoleNameList();
      List<String> unsupportedRoles=new ArrayList<String>();
      AuAssert.check(!roles.isEmpty(),""String_Node_Str"");
      if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
      }
      if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
      }
      if (roles.contains(HadoopRole.ZOOKEEPER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.ZOOKEEPER_ROLE.toString());
      }
      if (!unsupportedRoles.isEmpty()) {
        logger.info(""String_Node_Str"" + unsupportedRoles);
        throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
      }
      if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
        throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
      }
      if (instanceNum <= group.getDefineInstanceNum()) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
        throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
      }
      Integer instancePerHost=group.getInstancePerHost();
      if (instancePerHost != null && instanceNum % instancePerHost != 0) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
      }
      group.validateHostNumber(instanceNum);
      group.validateIfHostCanSatisfied(instanceNum);
      return group;
    }
  }
);
  final int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  DAL.inTransactionUpdate(group);
  UpdateClusterListener listener=new UpdateClusterListener(clusterName);
  try {
    return createClusterMgmtTask(cluster,listener,ClusterStatus.UPDATING);
  }
 catch (  Exception ex) {
    DAL.inTransactionDo(new Saveable<Void>(){
      @Override public Void body(){
        NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
        if (group == null) {
          logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
          throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
        }
        group.setDefineInstanceNum(oldInstanceNum);
        Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
        if (group.getHadoopNodes() != null) {
          for (          HadoopNodeEntity node : group.getHadoopNodes()) {
            if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
              logger.info(""String_Node_Str"" + node.getVmName());
              toRemove.add(node);
              DAL.delete(node);
            }
          }
          group.getHadoopNodes().removeAll(toRemove);
        }
        return null;
      }
    }
);
    throw ex;
  }
}","public Long resizeCluster(final String clusterName,final String nodeGroupName,final int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  final ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  final NodeGroupEntity group=DAL.inRoTransactionDo(new Saveable<NodeGroupEntity>(){
    @Override public NodeGroupEntity body() throws Exception {
      NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
      if (group == null) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
        throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
      }
      List<String> roles=group.getRoleNameList();
      List<String> unsupportedRoles=new ArrayList<String>();
      AuAssert.check(!roles.isEmpty(),""String_Node_Str"");
      if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
      }
      if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
      }
      if (roles.contains(HadoopRole.ZOOKEEPER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.ZOOKEEPER_ROLE.toString());
      }
      if (!unsupportedRoles.isEmpty()) {
        logger.info(""String_Node_Str"" + unsupportedRoles);
        throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
      }
      if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
        throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
      }
      if (instanceNum <= group.getDefineInstanceNum()) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
        throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
      }
      Integer instancePerHost=group.getInstancePerHost();
      if (instancePerHost != null && instanceNum % instancePerHost != 0) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
      }
      group.validateHostNumber(instanceNum);
      group.validateIfHostCanSatisfied(instanceNum);
      return group;
    }
  }
);
  final int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  DAL.inTransactionUpdate(group);
  UpdateClusterListener listener=new UpdateClusterListener(clusterName,nodeGroupName,oldInstanceNum);
  try {
    return createClusterMgmtTask(cluster,listener,ClusterStatus.UPDATING);
  }
 catch (  Exception ex) {
    DAL.inTransactionDo(new Saveable<Void>(){
      @Override public Void body(){
        NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
        if (group == null) {
          logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
          throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
        }
        group.setDefineInstanceNum(oldInstanceNum);
        Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
        if (group.getHadoopNodes() != null) {
          for (          HadoopNodeEntity node : group.getHadoopNodes()) {
            if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
              logger.info(""String_Node_Str"" + node.getVmName());
              toRemove.add(node);
              DAL.delete(node);
            }
          }
          group.getHadoopNodes().removeAll(toRemove);
        }
        return null;
      }
    }
);
    throw ex;
  }
}"
49036,"@Override public void onFailure(){
  logger.debug(""String_Node_Str"");
  DAL.inRwTransactionDo(new Saveable<Void>(){
    @Override public Void body() throws Exception {
      ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
      AuAssert.check(cluster != null);
      cluster.setStatus(ClusterStatus.RUNNING);
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return null;
    }
  }
);
}","@Override public void onFailure(){
  logger.debug(""String_Node_Str"");
  DAL.inRwTransactionDo(new Saveable<Void>(){
    @Override public Void body() throws Exception {
      ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
      AuAssert.check(cluster != null);
      NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
      AuAssert.check(group != null);
      cluster.setStatus(ClusterStatus.RUNNING);
      group.setDefineInstanceNum(oldInstanceNum);
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return null;
    }
  }
);
}"
49037,"public UpdateClusterListener(String clusterName){
  super();
  this.clusterName=clusterName;
}","public UpdateClusterListener(String clusterName,String nodeGroupName,int oldInstanceNum){
  super();
  this.clusterName=clusterName;
  this.nodeGroupName=nodeGroupName;
  this.oldInstanceNum=oldInstanceNum;
}"
49038,"@Override public Void body() throws Exception {
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  AuAssert.check(cluster != null);
  cluster.setStatus(ClusterStatus.RUNNING);
  logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  return null;
}","@Override public Void body() throws Exception {
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  AuAssert.check(cluster != null);
  NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
  AuAssert.check(group != null);
  cluster.setStatus(ClusterStatus.RUNNING);
  group.setDefineInstanceNum(oldInstanceNum);
  logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  return null;
}"
49039,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.OK) public void addNetworks(@RequestBody final NetworkAdd na){
  if (CommonUtil.isBlank(na.getName()) || !CommonUtil.validateName(na.getName())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getName());
  }
  if (CommonUtil.isBlank(na.getPortGroup()) || !CommonUtil.validateName(na.getPortGroup())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getPortGroup());
  }
  if (na.isDhcp()) {
    networkManager.addDhcpNetwork(na.getName(),na.getPortGroup());
  }
 else {
    if (!IpAddressUtil.isValidNetmask(na.getNetmask())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getNetmask());
    }
    long netmask=IpAddressUtil.getAddressAsLong(na.getNetmask());
    if (!IpAddressUtil.isValidIp(netmask,IpAddressUtil.getAddressAsLong(na.getGateway()))) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getGateway());
    }
    if (na.getDns1() != null && !IpAddressUtil.isValidIp(na.getDns1())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getDns1());
    }
    if (na.getDns2() != null && !IpAddressUtil.isValidIp(na.getDns2())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getDns2());
    }
    AuAssert.check(na.getIp() != null,""String_Node_Str"");
    for (    IpBlock blk : na.getIp()) {
      Long begin=IpAddressUtil.getAddressAsLong(blk.getBeginIp());
      Long end=IpAddressUtil.getAddressAsLong(blk.getEndIp());
      if (begin == null || end == null || begin > end || !IpAddressUtil.isValidIp(netmask,begin) || !IpAddressUtil.isValidIp(netmask,end)) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",""String_Node_Str"" + blk.getBeginIp() + ""String_Node_Str""+ blk.getEndIp()+ ""String_Node_Str"");
      }
    }
    networkManager.addIpPoolNetwork(na.getName(),na.getPortGroup(),na.getNetmask(),na.getGateway(),na.getDns1(),na.getDns2(),na.getIp());
  }
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.OK) public void addNetworks(@RequestBody final NetworkAdd na){
  if (CommonUtil.isBlank(na.getName()) || !CommonUtil.validateName(na.getName())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getName());
  }
  if (CommonUtil.isBlank(na.getPortGroup()) || !CommonUtil.validatePortGroupName(na.getPortGroup())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getPortGroup());
  }
  if (na.isDhcp()) {
    networkManager.addDhcpNetwork(na.getName(),na.getPortGroup());
  }
 else {
    if (!IpAddressUtil.isValidNetmask(na.getNetmask())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getNetmask());
    }
    long netmask=IpAddressUtil.getAddressAsLong(na.getNetmask());
    if (!IpAddressUtil.isValidIp(netmask,IpAddressUtil.getAddressAsLong(na.getGateway()))) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getGateway());
    }
    if (na.getDns1() != null && !IpAddressUtil.isValidIp(na.getDns1())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getDns1());
    }
    if (na.getDns2() != null && !IpAddressUtil.isValidIp(na.getDns2())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getDns2());
    }
    AuAssert.check(na.getIp() != null,""String_Node_Str"");
    for (    IpBlock blk : na.getIp()) {
      Long begin=IpAddressUtil.getAddressAsLong(blk.getBeginIp());
      Long end=IpAddressUtil.getAddressAsLong(blk.getEndIp());
      if (begin == null || end == null || begin > end || !IpAddressUtil.isValidIp(netmask,begin) || !IpAddressUtil.isValidIp(netmask,end)) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",""String_Node_Str"" + blk.getBeginIp() + ""String_Node_Str""+ blk.getEndIp()+ ""String_Node_Str"");
      }
    }
    networkManager.addIpPoolNetwork(na.getName(),na.getPortGroup(),na.getNetmask(),na.getGateway(),na.getDns1(),na.getDns2(),na.getIp());
  }
}"
49040,"@Test public void testValidateVcDataStoreNames(){
  List<String> vcDataStoreNames=new ArrayList<String>();
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(vcDataStoreNames),true);
  List<String> errorVcDataStoreNames1=new ArrayList<String>();
  errorVcDataStoreNames1.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(errorVcDataStoreNames1),false);
  List<String> errorVcDataStoreNames2=new ArrayList<String>();
  errorVcDataStoreNames2.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(errorVcDataStoreNames2),false);
}","@Test public void testValidateVcDataStoreNames(){
  List<String> vcDataStoreNames=new ArrayList<String>();
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(vcDataStoreNames),true);
  List<String> errorVcDataStoreNames1=new ArrayList<String>();
  errorVcDataStoreNames1.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(errorVcDataStoreNames1),false);
  List<String> errorVcDataStoreNames2=new ArrayList<String>();
  errorVcDataStoreNames2.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(errorVcDataStoreNames2),false);
}"
49041,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void getCluster(@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean detail){
  try {
    if (name == null) {
      ClusterRead[] clusters=restClient.getAll(detail);
      if (clusters != null) {
        prettyOutputClustersInfo(clusters,detail);
      }
    }
 else {
      ClusterRead cluster=restClient.get(name,detail);
      if (cluster != null) {
        prettyOutputClusterInfo(cluster,detail);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_LIST,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void getCluster(@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean detail){
  try {
    if (name == null) {
      ClusterRead[] clusters=restClient.getAll(detail);
      if (clusters != null) {
        Arrays.sort(clusters);
        prettyOutputClustersInfo(clusters,detail);
      }
    }
 else {
      ClusterRead cluster=restClient.get(name,detail);
      if (cluster != null) {
        prettyOutputClusterInfo(cluster,detail);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_LIST,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49042,"private void prettyOutputDistrosInfo(DistroRead[] distros){
  if (distros != null) {
    LinkedHashMap<String,List<String>> distroColumnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NAME,Arrays.asList(""String_Node_Str""));
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_VENDOR,Arrays.asList(""String_Node_Str""));
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_VERSION,Arrays.asList(""String_Node_Str""));
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_HVE,Arrays.asList(""String_Node_Str""));
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_ROLES,Arrays.asList(""String_Node_Str""));
    try {
      CommandsUtils.printInTableFormat(distroColumnNamesWithGetMethodNames,distros,Constants.OUTPUT_INDENT);
    }
 catch (    Exception e) {
      String distroName=null;
      if (distros.length == 1) {
        distroName=distros[0].getName();
      }
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_DISTRO,distroName,Constants.OUTPUT_OP_LIST,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
}","private void prettyOutputDistrosInfo(DistroRead[] distros){
  if (distros != null) {
    Arrays.sort(distros);
    LinkedHashMap<String,List<String>> distroColumnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NAME,Arrays.asList(""String_Node_Str""));
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_VENDOR,Arrays.asList(""String_Node_Str""));
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_VERSION,Arrays.asList(""String_Node_Str""));
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_HVE,Arrays.asList(""String_Node_Str""));
    distroColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_ROLES,Arrays.asList(""String_Node_Str""));
    try {
      CommandsUtils.printInTableFormat(distroColumnNamesWithGetMethodNames,distros,Constants.OUTPUT_INDENT);
    }
 catch (    Exception e) {
      String distroName=null;
      if (distros.length == 1) {
        distroName=distros[0].getName();
      }
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_DISTRO,distroName,Constants.OUTPUT_OP_LIST,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
}"
49043,"@Test public void testValidateVcDataStoreNames(){
  List<String> vcDataStoreNames=new ArrayList<String>();
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(vcDataStoreNames),true);
  List<String> errorVcDataStoreNames1=new ArrayList<String>();
  errorVcDataStoreNames1.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(errorVcDataStoreNames1),false);
  List<String> errorVcDataStoreNames2=new ArrayList<String>();
  errorVcDataStoreNames2.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(errorVcDataStoreNames2),false);
}","@Test public void testValidateVcDataStoreNames(){
  List<String> vcDataStoreNames=new ArrayList<String>();
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  vcDataStoreNames.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(vcDataStoreNames),true);
  List<String> errorVcDataStoreNames1=new ArrayList<String>();
  errorVcDataStoreNames1.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(errorVcDataStoreNames1),false);
  List<String> errorVcDataStoreNames2=new ArrayList<String>();
  errorVcDataStoreNames2.add(""String_Node_Str"");
  assertEquals(CommonUtil.validateVcDataStoreNames(errorVcDataStoreNames2),false);
}"
49044,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateTempfs(failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            masterCount++;
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (zookeeperCount > 1) || (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateStorageType(failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            masterCount++;
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (zookeeperCount > 1) || (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}
}"
49045,"private void showFailedMsg(String name,List<String> failedMsgList){
  StringBuilder failedMsg=new StringBuilder();
  failedMsg.append(Constants.INVALID_VALUE);
  if (failedMsgList.size() > 1) {
    failedMsg.append(""String_Node_Str"");
  }
  failedMsg.append(""String_Node_Str"");
  StringBuilder tmpMsg=new StringBuilder();
  for (  String msg : failedMsgList) {
    tmpMsg.append(""String_Node_Str"").append(msg);
  }
  tmpMsg.replace(0,1,""String_Node_Str"");
  failedMsg.append(tmpMsg);
  CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,failedMsg.toString());
}","private void showFailedMsg(String name,List<String> failedMsgList){
  StringBuilder failedMsg=new StringBuilder();
  failedMsg.append(Constants.INVALID_VALUE);
  if (failedMsgList.size() > 1) {
    failedMsg.append(""String_Node_Str"");
  }
  failedMsg.append(""String_Node_Str"");
  StringBuilder tmpMsg=new StringBuilder();
  for (  String msg : failedMsgList) {
    tmpMsg.append(""String_Node_Str"").append(msg);
  }
  tmpMsg.replace(0,1,""String_Node_Str"");
  failedMsg.append(tmpMsg);
  failedMsg.append(""String_Node_Str"");
  CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,failedMsg.toString());
}"
49046,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setVendor(distroRead.getVendor());
  clusterCreate.setVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49047,"@Test public void testCreateClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.BAD_REQUEST,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}","@Test public void testCreateClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"" + distro.getName(),HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.BAD_REQUEST,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}"
49048,"@Test public void testCreateClusterBySpecFile() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  distro.setRoles(roles);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  CookieCache.clear();
}","@Test public void testCreateClusterBySpecFile() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  distro.setRoles(roles);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"" + distro.getName(),HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"" + distro.getName(),HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"" + distro.getName(),HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"" + distro.getName(),HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  CookieCache.clear();
}"
49049,"@Test public void testClusterCreateOutput() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.ACCEPTED,""String_Node_Str"",""String_Node_Str"");
  TaskRead task=new TaskRead();
  task.setId(12l);
  task.setType(Type.INNER);
  task.setProgress(0.8);
  task.setProgressMessage(""String_Node_Str"");
  task.setStatus(Status.RUNNING);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  ClusterRead cluster=new ClusterRead();
  List<NodeGroupRead> nodeGroups=new ArrayList<NodeGroupRead>();
  NodeGroupRead workerGroup=new NodeGroupRead();
  workerGroup.setName(""String_Node_Str"");
  workerGroup.setInstanceNum(1);
  List<NodeRead> instances=new ArrayList<NodeRead>();
  NodeRead instance1=new NodeRead();
  instance1.setName(""String_Node_Str"");
  instance1.setStatus(""String_Node_Str"");
  instance1.setAction(""String_Node_Str"");
  instances.add(instance1);
  workerGroup.setInstances(instances);
  nodeGroups.add(workerGroup);
  cluster.setNodeGroups(nodeGroups);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  task.setProgress(1.0);
  task.setStatus(Status.SUCCESS);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  instance1.setStatus(""String_Node_Str"");
  instance1.setIp(""String_Node_Str"");
  instance1.setAction(null);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}","@Test public void testClusterCreateOutput() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"" + distro.getName(),HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.ACCEPTED,""String_Node_Str"",""String_Node_Str"");
  TaskRead task=new TaskRead();
  task.setId(12l);
  task.setType(Type.INNER);
  task.setProgress(0.8);
  task.setProgressMessage(""String_Node_Str"");
  task.setStatus(Status.RUNNING);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  ClusterRead cluster=new ClusterRead();
  List<NodeGroupRead> nodeGroups=new ArrayList<NodeGroupRead>();
  NodeGroupRead workerGroup=new NodeGroupRead();
  workerGroup.setName(""String_Node_Str"");
  workerGroup.setInstanceNum(1);
  List<NodeRead> instances=new ArrayList<NodeRead>();
  NodeRead instance1=new NodeRead();
  instance1.setName(""String_Node_Str"");
  instance1.setStatus(""String_Node_Str"");
  instance1.setAction(""String_Node_Str"");
  instances.add(instance1);
  workerGroup.setInstances(instances);
  nodeGroups.add(workerGroup);
  cluster.setNodeGroups(nodeGroups);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  task.setProgress(1.0);
  task.setStatus(Status.SUCCESS);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  instance1.setStatus(""String_Node_Str"");
  instance1.setIp(""String_Node_Str"");
  instance1.setAction(null);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}"
49050,"@Test public void testCreateCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}","@Test public void testCreateCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"" + distro.getName(),HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}"
49051,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateTempfs(failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            int numOfInstance=nodeGroupCreate.getInstanceNum();
          if (numOfInstance >= 0 && numOfInstance != 1) {
            if (numOfInstance != 2) {
              collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
            }
 else {
              namenodeHACheck=true;
            }
          }
        break;
case JOB_TRACKER:
      jobtrackerCount++;
    if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
      failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
    }
  break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (zookeeperCount > 1) || (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateTempfs(failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            masterCount++;
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (zookeeperCount > 1) || (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
}
}"
49052,"public Long createCluster(ClusterCreate createSpec) throws Exception {
  if (CommonUtil.isBlank(createSpec.getDistro())) {
    setDefaultDistro(createSpec);
  }
  setVendorInfo(createSpec);
  createSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  String name=createSpec.getName();
  logger.info(""String_Node_Str"" + name);
  final ClusterEntity cluster=clusterConfigMgr.createClusterConfig(createSpec);
  CreateClusterListener listener=new CreateClusterListener(name);
  try {
    return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.PROVISIONING);
  }
 catch (  BddException e) {
    logger.error(""String_Node_Str"",e);
    DAL.inTransactionDo(new Saveable<Void>(){
      public Void body() throws Exception {
        NetworkEntity network=cluster.getNetwork();
        DAL.refresh(network);
        if (network.getAllocType() == AllocType.IP_POOL) {
          networkManager.free(network,cluster.getId());
        }
        cluster.delete();
        return null;
      }
    }
);
    throw e;
  }
}","public Long createCluster(ClusterCreate createSpec) throws Exception {
  if (CommonUtil.isBlank(createSpec.getDistro())) {
    setDefaultDistro(createSpec);
  }
  DistroRead distroRead=this.getDistroManager().getDistroByName(createSpec.getDistro());
  createSpec.setVendor(distroRead.getVendor());
  createSpec.setVersion(distroRead.getVersion());
  createSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  String name=createSpec.getName();
  logger.info(""String_Node_Str"" + name);
  final ClusterEntity cluster=clusterConfigMgr.createClusterConfig(createSpec);
  CreateClusterListener listener=new CreateClusterListener(name);
  try {
    return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.PROVISIONING);
  }
 catch (  BddException e) {
    logger.error(""String_Node_Str"",e);
    DAL.inTransactionDo(new Saveable<Void>(){
      public Void body() throws Exception {
        NetworkEntity network=cluster.getNetwork();
        DAL.refresh(network);
        if (network.getAllocType() == AllocType.IP_POOL) {
          networkManager.free(network,cluster.getId());
        }
        cluster.delete();
        return null;
      }
    }
);
    throw e;
  }
}"
49053,"public DistroRead convert(){
  DistroRead dr=new DistroRead();
  Set<String> roles=new TreeSet<String>();
  if (this.getPackages() == null) {
    return null;
  }
  for (  RolePackageMapping pkg : this.getPackages()) {
    if (pkg.getRoles() == null) {
      return null;
    }
    for (    String r : pkg.getRoles()) {
      if (r == null || r.isEmpty()) {
        return null;
      }
      if (!roles.contains(r)) {
        roles.add(r);
      }
 else {
        logger.error(""String_Node_Str"" + r);
      }
    }
  }
  dr.setName(this.getName());
  dr.setVendor(this.getVendor());
  dr.setHveSupported(this.getHveSupported() == null ? false : this.getHveSupported());
  dr.setRoles(new ArrayList<String>(roles));
  return dr;
}","public DistroRead convert(){
  DistroRead dr=new DistroRead();
  Set<String> roles=new TreeSet<String>();
  if (this.getPackages() == null) {
    return null;
  }
  for (  RolePackageMapping pkg : this.getPackages()) {
    if (pkg.getRoles() == null) {
      return null;
    }
    for (    String r : pkg.getRoles()) {
      if (r == null || r.isEmpty()) {
        return null;
      }
      if (!roles.contains(r)) {
        roles.add(r);
      }
 else {
        logger.error(""String_Node_Str"" + r);
      }
    }
  }
  dr.setName(this.getName());
  dr.setVendor(this.getVendor());
  dr.setVersion(this.getVersion());
  dr.setHveSupported(this.getHveSupported() == null ? false : this.getHveSupported());
  dr.setRoles(new ArrayList<String>(roles));
  return dr;
}"
49054,"/** 
 * There are two approach to create a cluster: 1) specify a cluster type and optionally overwriting the parameters 2) specify a customized spec with cluster type not specified
 * @param spec spec with customized field
 * @return customized cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate getCustomizedSpec(ClusterCreate spec) throws FileNotFoundException {
  if (spec.getType() == null) {
    return spec;
  }
  ClusterCreate newSpec=createDefaultSpec(spec.getType(),spec.getVendor());
  if (spec.getName() != null) {
    newSpec.setName(spec.getName());
  }
  if (spec.getDistro() != null) {
    newSpec.setDistro(spec.getDistro());
  }
  if (spec.getVendor() != null) {
    newSpec.setVendor(spec.getVendor());
  }
  if (spec.getDsNames() != null) {
    newSpec.setDsNames(spec.getDsNames());
  }
  if (spec.getRpNames() != null) {
    newSpec.setRpNames(spec.getRpNames());
  }
  if (spec.getNetworkName() != null) {
    newSpec.setNetworkName(spec.getNetworkName());
  }
  if (spec.getTopologyPolicy() != null) {
    newSpec.setTopologyPolicy(spec.getTopologyPolicy());
  }
  return newSpec;
}","/** 
 * There are two approach to create a cluster: 1) specify a cluster type and optionally overwriting the parameters 2) specify a customized spec with cluster type not specified
 * @param spec spec with customized field
 * @return customized cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate getCustomizedSpec(ClusterCreate spec) throws FileNotFoundException {
  if (spec.getType() == null) {
    return spec;
  }
  ClusterCreate newSpec=createDefaultSpec(spec.getType(),spec.getVendor());
  if (spec.getName() != null) {
    newSpec.setName(spec.getName());
  }
  if (spec.getDistro() != null) {
    newSpec.setDistro(spec.getDistro());
  }
  if (spec.getVendor() != null) {
    newSpec.setVendor(spec.getVendor());
  }
  if (spec.getVersion() != null) {
    newSpec.setVersion(spec.getVersion());
  }
  if (spec.getDsNames() != null) {
    newSpec.setDsNames(spec.getDsNames());
  }
  if (spec.getRpNames() != null) {
    newSpec.setRpNames(spec.getRpNames());
  }
  if (spec.getNetworkName() != null) {
    newSpec.setNetworkName(spec.getNetworkName());
  }
  if (spec.getTopologyPolicy() != null) {
    newSpec.setTopologyPolicy(spec.getTopologyPolicy());
  }
  return newSpec;
}"
49055,"@Test public void testValidateNodeGroupName(){
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
}","@Test public void testValidateNodeGroupName(){
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
}"
49056,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateTempfs(failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            masterCount++;
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (zookeeperCount > 1) || (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateTempfs(failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            masterCount++;
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (zookeeperCount > 1) || (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}
}"
49057,"public List<DistroRead> getDistros(){
  loadManifest(false);
  List<DistroRead> drs=new ArrayList<DistroRead>();
  String vendorStr=Configuration.getStrings(VENDOR,""String_Node_Str"");
  vendorStr=vendorStr.toLowerCase();
  List<String> vendors=Arrays.asList(vendorStr.indexOf(""String_Node_Str"") != -1 ? vendorStr.split(""String_Node_Str"") : new String[]{vendorStr});
  List<String> errorVendors=new ArrayList<String>();
  for (  Distro distro : distros.values()) {
    DistroRead dr=distro.convert();
    if (!vendors.contains(dr.getVendor().toLowerCase())) {
      errorVendors.add(dr.getVendor());
    }
    if (dr != null) {
      drs.add(dr);
    }
 else {
      logger.error(""String_Node_Str"" + distro);
    }
  }
  StringBuffer errorMsg=new StringBuffer();
  if (!errorVendors.isEmpty()) {
    String errorVendorsStr=errorVendors.toString().substring(1,errorVendors.toString().length() - 1);
    errorMsg.append(errorVendorsStr).append(""String_Node_Str"");
  }
  if (errorMsg.length() > 0) {
    throw BddException.INTERNAL(null,errorMsg.toString());
  }
  return drs;
}","public List<DistroRead> getDistros(){
  loadManifest(false);
  List<DistroRead> drs=new ArrayList<DistroRead>();
  String vendorStr=Configuration.getStrings(VENDOR,""String_Node_Str"");
  String vendorStrTmp=vendorStr.toLowerCase();
  List<String> vendors=Arrays.asList(vendorStrTmp.indexOf(""String_Node_Str"") != -1 ? vendorStrTmp.split(""String_Node_Str"") : new String[]{vendorStrTmp});
  List<String> errorVendors=new ArrayList<String>();
  for (  Distro distro : distros.values()) {
    DistroRead dr=distro.convert();
    if (!vendors.contains(dr.getVendor().toLowerCase())) {
      if (!errorVendors.contains(dr.getVendor())) {
        errorVendors.add(dr.getVendor());
      }
    }
    if (dr != null) {
      drs.add(dr);
    }
 else {
      logger.error(""String_Node_Str"" + distro);
    }
  }
  StringBuffer errorMsg=new StringBuffer();
  if (!errorVendors.isEmpty()) {
    errorMsg.append(""String_Node_Str"").append(vendorStr).append(""String_Node_Str"");
    String errorVendorsStr=errorVendors.toString();
    errorMsg.append(""String_Node_Str"").append(errorVendorsStr).append(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (errorMsg.length() > 0) {
    throw BddException.INTERNAL(null,errorMsg.toString());
  }
  return drs;
}"
49058,"private void updateHostproperty(final String host) throws IOException {
  FileOutputStream hostFile=null;
  try {
    Properties hostProperty=new Properties();
    hostProperty.setProperty(Constants.PROPERTY_HOST,host);
    hostFile=new FileOutputStream(Constants.PROPERTY_FILE);
    hostProperty.store(hostFile,Constants.PROPERTY_FILE_HOST_COMMENT);
  }
 catch (  IOException e) {
    throw new IOException(Constants.PROPERTY_FILE_HOST_FAILURE);
  }
 finally {
    if (hostFile != null) {
      try {
        hostFile.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","private void updateHostproperty(final String host) throws IOException {
  FileOutputStream hostFile=null;
  try {
    Properties hostProperty=new Properties();
    hostProperty.setProperty(Constants.PROPERTY_HOST,host);
    hostFile=new FileOutputStream(Constants.PROPERTY_FILE);
    hostProperty.store(hostFile,Constants.PROPERTY_FILE_HOST_COMMENT);
  }
 catch (  IOException e) {
    StringBuilder exceptionMsg=new StringBuilder();
    exceptionMsg.append(Constants.PROPERTY_FILE_HOST_FAILURE);
    if (!CommonUtil.isBlank(e.getMessage())) {
      exceptionMsg.append(""String_Node_Str"").append(e.getMessage());
    }
    throw new IOException(exceptionMsg.toString());
  }
 finally {
    if (hostFile != null) {
      try {
        hostFile.close();
      }
 catch (      IOException e) {
      }
    }
  }
}"
49059,"/** 
 * connect to a Serengeti server
 * @param host host url with optional port
 * @param username serengeti login user name
 * @param password serengeti password
 */
public Connect.ConnectType connect(final String host,final String username,final String password){
  String oldHostUri=hostUri;
  hostUri=Constants.HTTP_CONNECTION_PREFIX + host + Constants.HTTP_CONNECTION_LOGIN_SUFFIX;
  try {
    ResponseEntity<String> response=login(Constants.REST_PATH_LOGIN,String.class,username,password);
    if (response.getStatusCode() == HttpStatus.OK) {
      updateHostproperty(host);
      String cookieValue=response.getHeaders().getFirst(""String_Node_Str"");
      if (cookieValue.contains(""String_Node_Str"")) {
        cookieValue=cookieValue.split(""String_Node_Str"")[0];
      }
      writeCookieInfo(cookieValue);
      System.out.println(Constants.CONNECT_SUCCESS);
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE);
      hostUri=oldHostUri;
      return Connect.ConnectType.ERROR;
    }
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      System.out.println(Constants.CONNECT_UNAUTHORIZATION);
      hostUri=oldHostUri;
      return Connect.ConnectType.UNAUTHORIZATION;
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + cliRestException.getStatus()+ ""String_Node_Str""+ cliRestException.getMessage().toLowerCase());
      return Connect.ConnectType.ERROR;
    }
  }
catch (  Exception e) {
    System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + e.getCause().getMessage().toLowerCase());
    return Connect.ConnectType.ERROR;
  }
  return Connect.ConnectType.SUCCESS;
}","/** 
 * connect to a Serengeti server
 * @param host host url with optional port
 * @param username serengeti login user name
 * @param password serengeti password
 */
public Connect.ConnectType connect(final String host,final String username,final String password){
  String oldHostUri=hostUri;
  hostUri=Constants.HTTP_CONNECTION_PREFIX + host + Constants.HTTP_CONNECTION_LOGIN_SUFFIX;
  try {
    ResponseEntity<String> response=login(Constants.REST_PATH_LOGIN,String.class,username,password);
    if (response.getStatusCode() == HttpStatus.OK) {
      updateHostproperty(host);
      String cookieValue=response.getHeaders().getFirst(""String_Node_Str"");
      if (cookieValue.contains(""String_Node_Str"")) {
        cookieValue=cookieValue.split(""String_Node_Str"")[0];
      }
      writeCookieInfo(cookieValue);
      System.out.println(Constants.CONNECT_SUCCESS);
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE);
      hostUri=oldHostUri;
      return Connect.ConnectType.ERROR;
    }
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      System.out.println(Constants.CONNECT_UNAUTHORIZATION);
      hostUri=oldHostUri;
      return Connect.ConnectType.UNAUTHORIZATION;
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + cliRestException.getStatus()+ ""String_Node_Str""+ cliRestException.getMessage().toLowerCase());
      return Connect.ConnectType.ERROR;
    }
  }
catch (  Exception e) {
    System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + (e.getCause() != null ? e.getCause().getMessage().toLowerCase() : e.getMessage()));
    return Connect.ConnectType.ERROR;
  }
  return Connect.ConnectType.SUCCESS;
}"
49060,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addDatastore(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String spec,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"" + ""String_Node_Str"") final String type){
  try {
    DatastoreAdd datastoreAdd=new DatastoreAdd();
    datastoreAdd.setName(name);
    if (CommandsUtils.inputsConvert(spec).isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_DATASTORE,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_SPEC_PARAM + Constants.MULTI_INPUTS_CHECK);
    }
 else {
      datastoreAdd.setSpec(CommandsUtils.inputsConvert(spec));
      datastoreAdd.setType(DatastoreType.valueOf(type));
      restClient.add(datastoreAdd);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_DATASTORE,name,Constants.OUTPUT_OP_RESULT_ADD);
    }
  }
 catch (  IllegalArgumentException ex) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_DATASTORE,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
  }
catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_DATASTORE,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addDatastore(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String spec,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"" + ""String_Node_Str"") final String type){
  try {
    DatastoreAdd datastoreAdd=new DatastoreAdd();
    datastoreAdd.setName(name);
    if (CommandsUtils.inputsConvert(spec).isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_DATASTORE,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_SPEC_PARAM + Constants.MULTI_INPUTS_CHECK);
    }
 else {
      datastoreAdd.setSpec(CommandsUtils.inputsConvert(spec));
      datastoreAdd.setType(DatastoreType.valueOf(type.toUpperCase()));
      restClient.add(datastoreAdd);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_DATASTORE,name,Constants.OUTPUT_OP_RESULT_ADD);
    }
  }
 catch (  IllegalArgumentException ex) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_DATASTORE,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
  }
catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_DATASTORE,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49061,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  groupEntity.setCluster(clusterEntity);
  groupEntity.setCpuNum(group.getCpuNum());
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new TreeSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  if (group.getStorage() != null) {
    groupEntity.setStorageSize(group.getStorage().getSizeGB());
    List<String> groupRoles=group.getRoles();
    if (groupRoles.contains(HadoopRole.ZOOKEEPER_ROLE.toString()) && groupRoles.size() == 1) {
      groupEntity.setDiskBisect(true);
    }
 else {
      groupEntity.setDiskBisect(false);
    }
    String storageType=group.getStorage().getType();
    if (storageType != null) {
      if (storageType.equals(DatastoreType.TEMPFS.name())) {
        groupEntity.setStorageType(DatastoreType.TEMPFS);
        roles.add(HadoopRole.TEMPFS_CLIENT_ROLE.toString());
      }
 else       if (storageType.equals(DatastoreType.LOCAL.name())) {
        groupEntity.setStorageType(DatastoreType.LOCAL);
      }
 else {
        groupEntity.setStorageType(DatastoreType.SHARED);
      }
    }
    groupEntity.setVcDatastoreNameList(group.getStorage().getDsNames());
  }
  roles.addAll(group.getRoles());
  List<String> sortedRolesByDependency=new ArrayList<String>();
  sortedRolesByDependency.addAll(roles);
  Collections.sort(sortedRolesByDependency,new RoleComparactor());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  boolean removeIt=validateGroupInstanceNum(clusterEntity.getName(),groupType,group,allRoles);
  if (removeIt) {
    return null;
  }
  allRoles.addAll(enumRoles);
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  groupEntity.setCluster(clusterEntity);
  groupEntity.setCpuNum(group.getCpuNum());
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new TreeSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  if (group.getStorage() != null) {
    groupEntity.setStorageSize(group.getStorage().getSizeGB());
    List<String> groupRoles=group.getRoles();
    if (groupRoles.contains(HadoopRole.ZOOKEEPER_ROLE.toString()) && groupRoles.size() == 1) {
      groupEntity.setDiskBisect(true);
    }
 else {
      groupEntity.setDiskBisect(false);
    }
    String storageType=group.getStorage().getType();
    if (storageType != null) {
      if (storageType.equalsIgnoreCase(DatastoreType.TEMPFS.name())) {
        groupEntity.setStorageType(DatastoreType.TEMPFS);
        roles.add(HadoopRole.TEMPFS_CLIENT_ROLE.toString());
      }
 else       if (storageType.equalsIgnoreCase(DatastoreType.LOCAL.name())) {
        groupEntity.setStorageType(DatastoreType.LOCAL);
      }
 else {
        groupEntity.setStorageType(DatastoreType.SHARED);
      }
    }
    groupEntity.setVcDatastoreNameList(group.getStorage().getDsNames());
  }
  roles.addAll(group.getRoles());
  List<String> sortedRolesByDependency=new ArrayList<String>();
  sortedRolesByDependency.addAll(roles);
  Collections.sort(sortedRolesByDependency,new RoleComparactor());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  boolean removeIt=validateGroupInstanceNum(clusterEntity.getName(),groupType,group,allRoles);
  if (removeIt) {
    return null;
  }
  allRoles.addAll(enumRoles);
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
49062,"private void transformHDFSUrl(ClusterCreate cluster){
  if (cluster.hasHDFSUrlConfigured()) {
    if (cluster.validateHDFSUrl()) {
      Map<String,Object> conf=cluster.getConfiguration();
      if (conf == null) {
        conf=new HashMap<String,Object>();
        cluster.setConfiguration(conf);
      }
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> hadoopConf=(Map<String,Object>)conf.get(""String_Node_Str"");
      if (hadoopConf == null) {
        hadoopConf=new HashMap<String,Object>();
        conf.put(""String_Node_Str"",hadoopConf);
      }
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> coreSiteConf=(Map<String,Object>)hadoopConf.get(""String_Node_Str"");
      if (coreSiteConf == null) {
        coreSiteConf=new HashMap<String,Object>();
        hadoopConf.put(""String_Node_Str"",coreSiteConf);
      }
      coreSiteConf.put(""String_Node_Str"",cluster.getExternalHDFS());
    }
 else {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getExternalHDFS());
    }
  }
}","private void transformHDFSUrl(ClusterCreate cluster){
  if (cluster.hasHDFSUrlConfigured()) {
    if (cluster.validateHDFSUrl()) {
      changeNodeGroupHDFSUrl(cluster.getNodeGroups(),cluster.getExternalHDFS());
      changeClusterHDFSUrl(cluster);
    }
 else {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getExternalHDFS());
    }
  }
}"
49063,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  List<String> distroNames=getDistroNames();
  if (distro != null) {
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
 else {
    int index=distroNames.indexOf(Constants.DEFAULT_DISTRO);
    if (index == -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
      return;
    }
 else {
      clusterCreate.setDistro(distroNames.get(index));
    }
  }
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  List<String> distroNames=getDistroNames();
  if (distro != null) {
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
 else {
    int index=distroNames.indexOf(Constants.DEFAULT_DISTRO);
    if (index == -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
      return;
    }
 else {
      clusterCreate.setDistro(distroNames.get(index));
    }
  }
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49064,"@Test public void testValidateClusterName(){
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
}","@Test public void testValidateClusterName(){
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
}"
49065,"@Test public void testValidateNodeGroupName(){
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateClusterName(""String_Node_Str""),false);
}","@Test public void testValidateNodeGroupName(){
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),false);
  assertEquals(CommonUtil.validateNodeGroupName(""String_Node_Str""),true);
}"
49066,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.ACCEPTED) public void createCluster(@RequestBody ClusterCreate createSpec,HttpServletRequest request,HttpServletResponse response) throws Exception {
  Long taskId=clusterMgr.createCluster(createSpec);
  redirectRequest(taskId,request,response);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.ACCEPTED) public void createCluster(@RequestBody ClusterCreate createSpec,HttpServletRequest request,HttpServletResponse response) throws Exception {
  String clusterName=createSpec.getName();
  if (!CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  Long taskId=clusterMgr.createCluster(createSpec);
  redirectRequest(taskId,request,response);
}"
49067,"private boolean connect(final String hostName,final Map<String,String> loginInfo,int count) throws Exception {
  if (count <= 0) {
    return false;
  }
 else {
    ConnectType connectType=conn.connect(hostName,loginInfo.get(""String_Node_Str""),loginInfo.get(""String_Node_Str""));
    if (connectType == ConnectType.UNAUTHORIZATION) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return false;
      }
 else {
        count--;
        connect(hostName,loginInfo,count);
      }
    }
  }
  return true;
}","private boolean connect(final String hostName,final Map<String,String> loginInfo,int count) throws Exception {
  if (count < 0) {
    return false;
  }
  ConnectType connectType=conn.connect(hostName,loginInfo.get(""String_Node_Str""),loginInfo.get(""String_Node_Str""));
  if (connectType == ConnectType.UNAUTHORIZATION) {
    if (count == 0) {
      return false;
    }
    if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
      return false;
    }
 else {
      count--;
      connect(hostName,loginInfo,count);
    }
  }
  return true;
}"
49068,"public boolean validateNodeGroupRoles(List<String> failedMsgList){
  boolean valid=true;
  Set<String> roles=new HashSet<String>();
  for (  NodeGroupCreate ngc : getNodeGroups()) {
    roles.addAll(ngc.getRoles());
  }
  if (validateHDFSUrl()) {
    if (getNodeGroups() == null) {
      valid=false;
      failedMsgList.add(""String_Node_Str"");
    }
 else {
      if (roles.contains(""String_Node_Str"") || roles.contains(""String_Node_Str"")) {
        valid=false;
        failedMsgList.add(""String_Node_Str"");
      }
      if (!roles.contains(""String_Node_Str"") || !roles.contains(""String_Node_Str"")) {
        valid=false;
        failedMsgList.add(""String_Node_Str"");
      }
    }
  }
 else {
    EnumSet<ServiceType> serviceTypes=EnumSet.noneOf(ServiceType.class);
    for (    ServiceType service : ServiceType.values()) {
      int matched=0;
      for (      HadoopRole role : service.getRoles()) {
        if (roles.contains(role.toString())) {
          matched++;
        }
      }
      if (matched == service.getRoles().size()) {
        serviceTypes.add(service);
      }
 else       if (matched != 0) {
        failedMsgList.add(""String_Node_Str"" + service + ""String_Node_Str""+ service.getRoles()+ ""String_Node_Str"");
        valid=false;
      }
    }
    if (valid == true && !serviceTypes.isEmpty()) {
      for (      ServiceType service : serviceTypes) {
        EnumSet<ServiceType> dependency=service.depend();
        if (dependency != null && !serviceTypes.containsAll(dependency)) {
          failedMsgList.add(""String_Node_Str"" + dependency + ""String_Node_Str""+ service+ ""String_Node_Str"");
          valid=false;
        }
      }
    }
  }
  return valid;
}","public boolean validateNodeGroupRoles(List<String> failedMsgList){
  boolean valid=true;
  Set<String> roles=new HashSet<String>();
  for (  NodeGroupCreate ngc : getNodeGroups()) {
    List<String> nodeGroupRoles=ngc.getRoles();
    if (nodeGroupRoles == null || nodeGroupRoles.isEmpty()) {
      valid=false;
      failedMsgList.add(""String_Node_Str"" + ngc.getName() + ""String_Node_Str"");
    }
 else {
      roles.addAll(ngc.getRoles());
    }
  }
  if (validateHDFSUrl()) {
    if (getNodeGroups() == null) {
      valid=false;
      failedMsgList.add(""String_Node_Str"");
    }
 else {
      if (roles.contains(""String_Node_Str"") || roles.contains(""String_Node_Str"")) {
        valid=false;
        failedMsgList.add(""String_Node_Str"");
      }
      if (!roles.contains(""String_Node_Str"") || !roles.contains(""String_Node_Str"")) {
        valid=false;
        failedMsgList.add(""String_Node_Str"");
      }
    }
  }
 else {
    EnumSet<ServiceType> serviceTypes=EnumSet.noneOf(ServiceType.class);
    for (    ServiceType service : ServiceType.values()) {
      int matched=0;
      for (      HadoopRole role : service.getRoles()) {
        if (roles.contains(role.toString())) {
          matched++;
        }
      }
      if (matched == service.getRoles().size()) {
        serviceTypes.add(service);
      }
 else       if (matched != 0) {
        failedMsgList.add(""String_Node_Str"" + service + ""String_Node_Str""+ service.getRoles()+ ""String_Node_Str"");
        valid=false;
      }
    }
    if (valid == true && !serviceTypes.isEmpty()) {
      for (      ServiceType service : serviceTypes) {
        EnumSet<ServiceType> dependency=service.depend();
        if (dependency != null && !serviceTypes.containsAll(dependency)) {
          failedMsgList.add(""String_Node_Str"" + dependency + ""String_Node_Str""+ service+ ""String_Node_Str"");
          valid=false;
        }
      }
    }
  }
  return valid;
}"
49069,"private boolean checkNodeGroupRoles(NodeGroupCreate nodeGroup,List<String> distroRoles,List<String> failedMsgList){
  List<String> roles=nodeGroup.getRoles();
  boolean validated=true;
  StringBuilder rolesMsg=new StringBuilder();
  for (  String role : roles) {
    if (!distroRoles.contains(role)) {
      validated=false;
      rolesMsg.append(""String_Node_Str"").append(role);
    }
  }
  if (!validated) {
    rolesMsg.replace(0,1,""String_Node_Str"");
    failedMsgList.add(new StringBuilder().append(nodeGroup.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(rolesMsg.toString()).append(""String_Node_Str"").toString());
  }
  return validated;
}","private boolean checkNodeGroupRoles(NodeGroupCreate nodeGroup,List<String> distroRoles,List<String> failedMsgList){
  List<String> roles=nodeGroup.getRoles();
  boolean validated=true;
  StringBuilder rolesMsg=new StringBuilder();
  if (roles != null) {
    for (    String role : roles) {
      if (!distroRoles.contains(role)) {
        validated=false;
        rolesMsg.append(""String_Node_Str"").append(role);
      }
    }
  }
  if (!validated) {
    rolesMsg.replace(0,1,""String_Node_Str"");
    failedMsgList.add(new StringBuilder().append(nodeGroup.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(rolesMsg.toString()).append(""String_Node_Str"").toString());
  }
  return validated;
}"
49070,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateTempfs(failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATANODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (zookeeperCount > 1) || (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateTempfs(failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            int numOfInstance=nodeGroupCreate.getInstanceNum();
          if (numOfInstance >= 0 && numOfInstance != 1) {
            if (numOfInstance != 2) {
              collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
            }
 else {
              namenodeHACheck=true;
            }
          }
        break;
case JOB_TRACKER:
      jobtrackerCount++;
    if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
      failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
    }
  break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATANODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (zookeeperCount > 1) || (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
}
}"
49071,"private List<NodeGroupRole> getNodeGroupRoles(NodeGroupCreate nodeGroupCreate){
  List<NodeGroupRole> groupRoles=new ArrayList<NodeGroupRole>();
  List<String> roles=nodeGroupCreate.getRoles();
  for (  NodeGroupRole role : NodeGroupRole.values()) {
    if (matchRole(role,roles)) {
      groupRoles.add(role);
    }
  }
  if (groupRoles.size() == 0) {
    groupRoles.add(NodeGroupRole.NONE);
  }
  return groupRoles;
}","private List<NodeGroupRole> getNodeGroupRoles(NodeGroupCreate nodeGroupCreate){
  List<NodeGroupRole> groupRoles=new ArrayList<NodeGroupRole>();
  List<String> roles=nodeGroupCreate.getRoles();
  for (  NodeGroupRole role : NodeGroupRole.values()) {
    if (roles != null && matchRole(role,roles)) {
      groupRoles.add(role);
    }
  }
  if (groupRoles.size() == 0) {
    groupRoles.add(NodeGroupRole.NONE);
  }
  return groupRoles;
}"
49072,"@SuppressWarnings(""String_Node_Str"") private static <T>void validateBySameFileName(final String fileName,Object configProperties,Map<String,List<T>> listFileMap,ValidateResult validateResult,ValidationType validationType){
  if (configProperties instanceof Map) {
    Map<String,Object> configPropertyMap=(Map<String,Object>)configProperties;
    List<String> removeList=new ArrayList<String>();
    for (    Entry<String,Object> configProperty : configPropertyMap.entrySet()) {
      for (      Entry<String,List<T>> listFileEntry : listFileMap.entrySet()) {
        if (listFileEntry.getValue() instanceof List) {
          List<T> propertiesPerListFile=(List<T>)listFileEntry.getValue();
          if (validationType == ValidationType.BLACK_LIST) {
            validateBlackListPropertis(fileName,propertiesPerListFile,configProperty.getKey(),validateResult,removeList);
          }
 else           if (validationType == ValidationType.WHITE_LIST) {
            validateWhiteListPropertis(propertiesPerListFile,configProperty.getKey(),String.valueOf(configProperty.getValue()),validateResult);
          }
        }
      }
    }
    for (    String pName : removeList) {
      configPropertyMap.remove(pName);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private static <T>void validateBySameFileName(final String fileName,Object configProperties,Map<String,List<T>> listFileMap,ValidateResult validateResult,ValidationType validationType){
  if (configProperties instanceof Map) {
    Map<String,Object> configPropertyMap=(Map<String,Object>)configProperties;
    List<String> removeList=new ArrayList<String>();
    for (    Entry<String,Object> configProperty : configPropertyMap.entrySet()) {
      for (      Entry<String,List<T>> listFileEntry : listFileMap.entrySet()) {
        if (listFileEntry.getKey().equals(fileName) && listFileEntry.getValue() instanceof List) {
          List<T> propertiesPerListFile=(List<T>)listFileEntry.getValue();
          if (validationType == ValidationType.BLACK_LIST) {
            validateBlackListPropertis(fileName,propertiesPerListFile,configProperty.getKey(),validateResult,removeList);
          }
 else           if (validationType == ValidationType.WHITE_LIST) {
            validateWhiteListPropertis(propertiesPerListFile,configProperty.getKey(),String.valueOf(configProperty.getValue()),validateResult);
          }
        }
      }
    }
    for (    String pName : removeList) {
      configPropertyMap.remove(pName);
    }
  }
}"
49073,"@Test public void testWhiteListHandle(){
  ValidateResult hadoopValidateResult=AppConfigValidationFactory.whiteListHandle(cluster.getNodeGroups()[0].getConfiguration());
  assertEquals(hadoopValidateResult.getType(),ValidateResult.Type.WHITE_LIST_INVALID_NAME);
  assertEquals(hadoopValidateResult.getFailureNames().get(0),""String_Node_Str"");
  assertEquals(hadoopValidateResult.getFailureNames().get(1),""String_Node_Str"");
  ValidateResult zookeeperValidateResult=AppConfigValidationFactory.whiteListHandle(cluster.getNodeGroups()[1].getConfiguration());
  assertEquals(zookeeperValidateResult.getType(),ValidateResult.Type.WHITE_LIST_INVALID_NAME);
  assertEquals(zookeeperValidateResult.getFailureNames().get(0),""String_Node_Str"");
  ValidateResult noExistingValidateResult=AppConfigValidationFactory.whiteListHandle(cluster.getNodeGroups()[2].getConfiguration());
  assertEquals(noExistingValidateResult.getType(),ValidateResult.Type.WHITE_LIST_NO_EXIST_FILE_NAME);
  assertEquals(noExistingValidateResult.getNoExistFileNames().get(""String_Node_Str"").size(),3);
}","@Test public void testWhiteListHandle(){
  ValidateResult hadoopValidateResult=AppConfigValidationFactory.whiteListHandle(cluster.getNodeGroups()[0].getConfiguration());
  assertEquals(hadoopValidateResult.getType(),ValidateResult.Type.WHITE_LIST_INVALID_NAME);
  assertEquals(hadoopValidateResult.getFailureNames().get(0),""String_Node_Str"");
  assertEquals(hadoopValidateResult.getFailureNames().get(1),""String_Node_Str"");
  ValidateResult zookeeperValidateResult=AppConfigValidationFactory.whiteListHandle(cluster.getNodeGroups()[1].getConfiguration());
  assertEquals(zookeeperValidateResult.getType(),ValidateResult.Type.WHITE_LIST_INVALID_NAME);
  assertEquals(zookeeperValidateResult.getFailureNames().size(),1);
  assertEquals(zookeeperValidateResult.getFailureNames().get(0),""String_Node_Str"");
  ValidateResult noExistingValidateResult=AppConfigValidationFactory.whiteListHandle(cluster.getNodeGroups()[2].getConfiguration());
  assertEquals(noExistingValidateResult.getType(),ValidateResult.Type.WHITE_LIST_NO_EXIST_FILE_NAME);
  assertEquals(noExistingValidateResult.getNoExistFileNames().get(""String_Node_Str"").size(),3);
}"
49074,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
private boolean validateClusterCreate(ClusterCreate clusterCreate,final boolean alwaysAnswerYes){
  boolean validated=true;
  boolean warning=false;
  int masterCount=0, jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0;
  NodeGroupCreate[] nodeGroupCreates=clusterCreate.getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.MULTI_INPUTS_CHECK);
    return !validated;
  }
 else {
    List<String> failedMsgList=new LinkedList<String>();
    List<String> warningMsgList=new LinkedList<String>();
    List<String> distroRoles=findDistroRoles(clusterCreate);
    if (distroRoles == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NO_DISTRO_AVAILABLE);
      return !validated;
    }
    if (clusterCreate.hasHDFSUrlConfigured() && !clusterCreate.validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(clusterCreate.getExternalHDFS()).toString());
      validated=false;
    }
    if (!clusterCreate.validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList)) {
      validated=false;
    }
    if (!clusterCreate.validateNodeGroupRoles(failedMsgList)) {
      validated=false;
    }
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      if (!checkInstanceNum(nodeGroupCreate,failedMsgList)) {
        validated=false;
      }
      if (!checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList)) {
        validated=false;
      }
      NodeGroupRole role=getNodeGroupRole(nodeGroupCreate);
switch (role) {
case MASTER:
        masterCount++;
      if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
        validated=false;
        collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  validated=false;
  collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
validated=false;
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
validated=false;
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
warning=true;
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
validated=false;
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warning=true;
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
warning=true;
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warning=true;
}
break;
case NONE:
warning=true;
break;
default :
}
}
if ((masterCount > 1) || (jobtrackerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)|| (workerCount == 0)) {
warningMsgList.add(Constants.WRONG_NUM_OF_NODES);
warning=true;
}
if (!validated) {
showFailedMsg(clusterCreate.getName(),failedMsgList);
}
 else if (warning || warningMsgList != null) {
if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
validated=false;
}
}
return validated;
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
private boolean validateClusterCreate(ClusterCreate clusterCreate,final boolean alwaysAnswerYes){
  boolean validated=true;
  boolean warning=false;
  int masterCount=0, jobtrackerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0;
  NodeGroupCreate[] nodeGroupCreates=clusterCreate.getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.MULTI_INPUTS_CHECK);
    return !validated;
  }
 else {
    List<String> failedMsgList=new LinkedList<String>();
    List<String> warningMsgList=new LinkedList<String>();
    List<String> distroRoles=findDistroRoles(clusterCreate);
    if (distroRoles == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NO_DISTRO_AVAILABLE);
      return !validated;
    }
    if (clusterCreate.hasHDFSUrlConfigured() && !clusterCreate.validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(clusterCreate.getExternalHDFS()).toString());
      validated=false;
    }
    if (!clusterCreate.validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList)) {
      validated=false;
    }
    if (!clusterCreate.validateNodeGroupRoles(failedMsgList)) {
      validated=false;
    }
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      if (!checkInstanceNum(nodeGroupCreate,failedMsgList)) {
        validated=false;
      }
      if (!checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList)) {
        validated=false;
      }
      NodeGroupRole role=getNodeGroupRole(nodeGroupCreate);
switch (role) {
case MASTER:
        masterCount++;
      if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
        validated=false;
        collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  validated=false;
  collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
validated=false;
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
validated=false;
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
warning=true;
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
validated=false;
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warning=true;
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
warning=true;
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warning=true;
}
break;
case NONE:
warning=true;
break;
default :
}
}
if ((masterCount > 1) || (jobtrackerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODES);
validated=false;
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_NODES);
warning=true;
}
if (!validated) {
showFailedMsg(clusterCreate.getName(),failedMsgList);
}
 else if (warning || warningMsgList != null) {
if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
validated=false;
}
}
return validated;
}
}"
49075,"public static NetworkException NETWORK_IN_USE(){
  return new NetworkException(null,""String_Node_Str"");
}","public static NetworkException NETWORK_IN_USE(List<String> clusterNames){
  return new NetworkException(null,""String_Node_Str"",clusterNames);
}"
49076,"private void assertNetworkNotUsed(NetworkEntity network) throws NetworkException {
  if (!network.getClusters().isEmpty()) {
    logger.error(""String_Node_Str"");
    throw NetworkException.NETWORK_IN_USE();
  }
  if (ConfigInfo.isDebugEnabled()) {
    if (network.getAllocType() == AllocType.IP_POOL && network.getClusters().isEmpty()) {
      AuAssert.check(network.getTotal() == network.getFree(),""String_Node_Str"" + network.getTotal() + ""String_Node_Str""+ network.getFree());
    }
  }
}","private void assertNetworkNotUsed(NetworkEntity network) throws NetworkException {
  if (!network.getClusters().isEmpty()) {
    logger.error(""String_Node_Str"");
    List<String> clusterNames=new ArrayList<String>();
    for (    ClusterEntity entity : network.getClusters()) {
      clusterNames.add(entity.getName());
    }
    throw NetworkException.NETWORK_IN_USE(clusterNames);
  }
  if (ConfigInfo.isDebugEnabled()) {
    if (network.getAllocType() == AllocType.IP_POOL && network.getClusters().isEmpty()) {
      AuAssert.check(network.getTotal() == network.getFree(),""String_Node_Str"" + network.getTotal() + ""String_Node_Str""+ network.getFree());
    }
  }
}"
49077,"@Override public Void body(){
  DAL.refresh(group);
  group.setDefineInstanceNum(oldInstanceNum);
  Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
  if (group.getHadoopNodes() != null) {
    for (    HadoopNodeEntity node : group.getHadoopNodes()) {
      if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
        logger.info(""String_Node_Str"" + node.getVmName());
        toRemove.add(node);
        DAL.delete(node);
      }
    }
    group.getHadoopNodes().removeAll(toRemove);
  }
  return null;
}","@Override public Void body(){
  NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
  if (group == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
    throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
  }
  group.setDefineInstanceNum(oldInstanceNum);
  Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
  if (group.getHadoopNodes() != null) {
    for (    HadoopNodeEntity node : group.getHadoopNodes()) {
      if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
        logger.info(""String_Node_Str"" + node.getVmName());
        toRemove.add(node);
        DAL.delete(node);
      }
    }
    group.getHadoopNodes().removeAll(toRemove);
  }
  return null;
}"
49078,"public Long resizeCluster(final String clusterName,final String nodeGroupName,final int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  final ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  final NodeGroupEntity group=DAL.inRoTransactionDo(new Saveable<NodeGroupEntity>(){
    @Override public NodeGroupEntity body() throws Exception {
      NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
      if (group == null) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
        throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
      }
      List<String> roles=group.getRoleNameList();
      List<String> unsupportedRoles=new ArrayList<String>();
      AuAssert.check(!roles.isEmpty(),""String_Node_Str"");
      if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
      }
      if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
      }
      if (roles.contains(HadoopRole.ZOOKEEPER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.ZOOKEEPER_ROLE.toString());
      }
      if (!unsupportedRoles.isEmpty()) {
        logger.info(""String_Node_Str"" + unsupportedRoles);
        throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
      }
      if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
        throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
      }
      if (instanceNum <= group.getDefineInstanceNum()) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
        throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
      }
      Integer instancePerHost=group.getInstancePerHost();
      if (instancePerHost != null && instanceNum % instancePerHost != 0) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
      }
      group.validateHostNumber(instanceNum);
      group.validateIfHostCanSatisfied(instanceNum);
      return group;
    }
  }
);
  final int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  DAL.inTransactionUpdate(group);
  UpdateClusterListener listener=new UpdateClusterListener(clusterName);
  try {
    return createClusterMgmtTask(cluster,listener,ClusterStatus.UPDATING);
  }
 catch (  Exception ex) {
    DAL.inTransactionDo(new Saveable<Void>(){
      @Override public Void body(){
        DAL.refresh(group);
        group.setDefineInstanceNum(oldInstanceNum);
        Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
        if (group.getHadoopNodes() != null) {
          for (          HadoopNodeEntity node : group.getHadoopNodes()) {
            if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
              logger.info(""String_Node_Str"" + node.getVmName());
              toRemove.add(node);
              DAL.delete(node);
            }
          }
          group.getHadoopNodes().removeAll(toRemove);
        }
        return null;
      }
    }
);
    throw ex;
  }
}","public Long resizeCluster(final String clusterName,final String nodeGroupName,final int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  final ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  final NodeGroupEntity group=DAL.inRoTransactionDo(new Saveable<NodeGroupEntity>(){
    @Override public NodeGroupEntity body() throws Exception {
      NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
      if (group == null) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
        throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
      }
      List<String> roles=group.getRoleNameList();
      List<String> unsupportedRoles=new ArrayList<String>();
      AuAssert.check(!roles.isEmpty(),""String_Node_Str"");
      if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
      }
      if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
      }
      if (roles.contains(HadoopRole.ZOOKEEPER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.ZOOKEEPER_ROLE.toString());
      }
      if (!unsupportedRoles.isEmpty()) {
        logger.info(""String_Node_Str"" + unsupportedRoles);
        throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
      }
      if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
        throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
      }
      if (instanceNum <= group.getDefineInstanceNum()) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
        throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
      }
      Integer instancePerHost=group.getInstancePerHost();
      if (instancePerHost != null && instanceNum % instancePerHost != 0) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
      }
      group.validateHostNumber(instanceNum);
      group.validateIfHostCanSatisfied(instanceNum);
      return group;
    }
  }
);
  final int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  DAL.inTransactionUpdate(group);
  UpdateClusterListener listener=new UpdateClusterListener(clusterName);
  try {
    return createClusterMgmtTask(cluster,listener,ClusterStatus.UPDATING);
  }
 catch (  Exception ex) {
    DAL.inTransactionDo(new Saveable<Void>(){
      @Override public Void body(){
        NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
        if (group == null) {
          logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
          throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
        }
        group.setDefineInstanceNum(oldInstanceNum);
        Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
        if (group.getHadoopNodes() != null) {
          for (          HadoopNodeEntity node : group.getHadoopNodes()) {
            if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
              logger.info(""String_Node_Str"" + node.getVmName());
              toRemove.add(node);
              DAL.delete(node);
            }
          }
          group.getHadoopNodes().removeAll(toRemove);
        }
        return null;
      }
    }
);
    throw ex;
  }
}"
49079,"public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedPattern(null);
  spec.setLocalPattern(null);
  spec.setNetworking(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkName(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setNamePattern(null);
      group.setVmFolderPath(null);
    }
  }
  return spec;
}","public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedPattern(null);
  spec.setLocalPattern(null);
  spec.setNetworking(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkName(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setNamePattern(null);
      group.setVmFolderPath(null);
    }
  }
  return spec;
}"
49080,"public void validateIfHostCanSatisfied(int instanceNum){
  if (getInstancePerHost() != null) {
    int requiredHostNum=instanceNum / getInstancePerHost();
    if (getGroupRacks() != null) {
      GroupRacks groupRacks=(GroupRacks)new Gson().fromJson(getGroupRacks(),GroupRacks.class);
      GroupRacksType rackType=groupRacks.getType();
      List<RackInfo> racksInfo=new RackInfoManager().exportRackInfo();
      Set<String> specifiedRacks=new HashSet<String>(Arrays.asList(groupRacks.getRacks()));
      List<String> IntersecRacks=new ArrayList<String>();
      Integer IntersecHostNum=0;
      Integer maxIntersecHostNum=0;
      for (      RackInfo rackInfo : racksInfo) {
        if (specifiedRacks.isEmpty() || specifiedRacks.size() == 0 || specifiedRacks.contains(rackInfo.getName())) {
          IntersecHostNum+=rackInfo.getHosts().size();
          IntersecRacks.add(rackInfo.getName());
          if (rackInfo.getHosts().size() > maxIntersecHostNum) {
            maxIntersecHostNum=rackInfo.getHosts().size();
          }
        }
      }
      if (rackType.equals(GroupRacksType.ROUNDROBIN) && IntersecHostNum < requiredHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(this.name,requiredHostNum,IntersecHostNum);
      }
 else       if (rackType.equals(GroupRacksType.SAMERACK) && requiredHostNum > maxIntersecHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(this.name,requiredHostNum,maxIntersecHostNum);
      }
      groupRacks.setRacks(IntersecRacks.toArray(new String[IntersecRacks.size()]));
      setGroupRacks((new Gson()).toJson(groupRacks));
    }
  }
}","public void validateIfHostCanSatisfied(int instanceNum){
  if (getInstancePerHost() != null) {
    int requiredHostNum=instanceNum / getInstancePerHost();
    if (getGroupRacks() != null) {
      GroupRacks groupRacks=(GroupRacks)new Gson().fromJson(getGroupRacks(),GroupRacks.class);
      GroupRacksType rackType=groupRacks.getType();
      List<RackInfo> racksInfo=new RackInfoManager().exportRackInfo();
      Set<String> specifiedRacks=new HashSet<String>(Arrays.asList(groupRacks.getRacks()));
      List<String> IntersecRacks=new ArrayList<String>();
      Integer IntersecHostNum=0;
      Integer maxIntersecHostNum=0;
      for (      RackInfo rackInfo : racksInfo) {
        if (specifiedRacks.isEmpty() || specifiedRacks.size() == 0 || specifiedRacks.contains(rackInfo.getName())) {
          IntersecHostNum+=rackInfo.getHosts().size();
          IntersecRacks.add(rackInfo.getName());
          if (rackInfo.getHosts().size() > maxIntersecHostNum) {
            maxIntersecHostNum=rackInfo.getHosts().size();
          }
        }
      }
      if (rackType.equals(GroupRacksType.ROUNDROBIN) && IntersecHostNum < requiredHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(this.name,requiredHostNum,IntersecHostNum);
      }
 else       if (rackType.equals(GroupRacksType.SAMERACK) && requiredHostNum > maxIntersecHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(this.name,requiredHostNum,maxIntersecHostNum);
      }
      if (specifiedRacks.isEmpty()) {
        groupRacks.setRacks(new String[0]);
      }
 else {
        groupRacks.setRacks(IntersecRacks.toArray(new String[IntersecRacks.size()]));
      }
      setGroupRacks((new Gson()).toJson(groupRacks));
    }
  }
}"
49081,"private boolean validateRacksInfo(ClusterCreate cluster,List<String> failedMsgList){
  boolean valid=true;
  Map<String,NodeGroupCreate> allGroups=new TreeMap<String,NodeGroupCreate>();
  if (cluster.getNodeGroups() == null) {
    return valid;
  }
  List<RackInfo> racksInfo=rackInfoMgr.exportRackInfo();
  if ((cluster.getTopologyPolicy() == TopologyType.HVE || cluster.getTopologyPolicy() == TopologyType.RACK_AS_RACK) && racksInfo.isEmpty()) {
    valid=false;
    throw ClusterConfigException.TOPOLOGY_WITH_NO_MAPPING_INFO_EXIST(cluster.getTopologyPolicy().toString());
  }
  for (  NodeGroupCreate nodeGroupCreate : cluster.getNodeGroups()) {
    allGroups.put(nodeGroupCreate.getName(),nodeGroupCreate);
  }
  for (  NodeGroupCreate ngc : cluster.getNodeGroups()) {
    PlacementPolicy policies=ngc.getPlacementPolicies();
    if (policies != null && policies.getGroupAssociations() != null) {
      continue;
    }
    if (ngc.getStorage() != null && ngc.getStorage().getType() != null && ngc.getStorage().getType().equals(DatastoreType.SHARED.toString())) {
      continue;
    }
    if (policies != null && policies.getGroupRacks() != null) {
      if (racksInfo.isEmpty()) {
        valid=false;
        throw ClusterConfigException.RACKPOLICY_WITH_NO_MAPPING_INFO_EXIST(ngc.getName());
      }
      GroupRacks r=policies.getGroupRacks();
      GroupRacksType rackType=r.getType();
      Set<String> specifiedRacks=new HashSet<String>(Arrays.asList(r.getRacks()));
      List<String> intersecRacks=new ArrayList<String>();
      int intersecHostNum=0;
      int maxIntersecHostNum=0;
      for (      RackInfo rackInfo : racksInfo) {
        if (specifiedRacks.isEmpty() || specifiedRacks.size() == 0 || specifiedRacks.contains(rackInfo.getName())) {
          intersecHostNum+=rackInfo.getHosts().size();
          intersecRacks.add(rackInfo.getName());
          if (rackInfo.getHosts().size() > maxIntersecHostNum) {
            maxIntersecHostNum=rackInfo.getHosts().size();
          }
        }
      }
      if (intersecRacks.size() == 0) {
        valid=false;
        throw ClusterConfigException.NO_VALID_RACK(ngc.getName());
      }
      if (ngc.calculateHostNum() != null) {
        if (rackType.equals(GroupRacksType.ROUNDROBIN) && ngc.calculateHostNum() > intersecHostNum) {
          valid=false;
          throw ClusterConfigException.LACK_PHYSICAL_HOSTS(ngc.getName(),ngc.calculateHostNum(),intersecHostNum);
        }
 else         if (rackType.equals(GroupRacksType.SAMERACK) && ngc.calculateHostNum() > maxIntersecHostNum) {
          valid=false;
          throw ClusterConfigException.LACK_PHYSICAL_HOSTS(ngc.getName(),ngc.calculateHostNum(),maxIntersecHostNum);
        }
      }
      r.setRacks(intersecRacks.toArray(new String[intersecRacks.size()]));
    }
  }
  return valid;
}","private boolean validateRacksInfo(ClusterCreate cluster,List<String> failedMsgList){
  boolean valid=true;
  Map<String,NodeGroupCreate> allGroups=new TreeMap<String,NodeGroupCreate>();
  if (cluster.getNodeGroups() == null) {
    return valid;
  }
  List<RackInfo> racksInfo=rackInfoMgr.exportRackInfo();
  if ((cluster.getTopologyPolicy() == TopologyType.HVE || cluster.getTopologyPolicy() == TopologyType.RACK_AS_RACK) && racksInfo.isEmpty()) {
    valid=false;
    throw ClusterConfigException.TOPOLOGY_WITH_NO_MAPPING_INFO_EXIST(cluster.getTopologyPolicy().toString());
  }
  for (  NodeGroupCreate nodeGroupCreate : cluster.getNodeGroups()) {
    allGroups.put(nodeGroupCreate.getName(),nodeGroupCreate);
  }
  for (  NodeGroupCreate ngc : cluster.getNodeGroups()) {
    PlacementPolicy policies=ngc.getPlacementPolicies();
    if (policies != null && policies.getGroupAssociations() != null) {
      continue;
    }
    if (ngc.getStorage() != null && ngc.getStorage().getType() != null && ngc.getStorage().getType().equals(DatastoreType.SHARED.toString())) {
      continue;
    }
    if (policies != null && policies.getGroupRacks() != null) {
      if (racksInfo.isEmpty()) {
        valid=false;
        throw ClusterConfigException.RACKPOLICY_WITH_NO_MAPPING_INFO_EXIST(ngc.getName());
      }
      GroupRacks r=policies.getGroupRacks();
      GroupRacksType rackType=r.getType();
      Set<String> specifiedRacks=new HashSet<String>(Arrays.asList(r.getRacks()));
      List<String> intersecRacks=new ArrayList<String>();
      int intersecHostNum=0;
      int maxIntersecHostNum=0;
      for (      RackInfo rackInfo : racksInfo) {
        if (specifiedRacks.isEmpty() || specifiedRacks.size() == 0 || specifiedRacks.contains(rackInfo.getName())) {
          intersecHostNum+=rackInfo.getHosts().size();
          intersecRacks.add(rackInfo.getName());
          if (rackInfo.getHosts().size() > maxIntersecHostNum) {
            maxIntersecHostNum=rackInfo.getHosts().size();
          }
        }
      }
      if (intersecRacks.size() == 0) {
        valid=false;
        throw ClusterConfigException.NO_VALID_RACK(ngc.getName());
      }
      if (ngc.calculateHostNum() != null) {
        if (rackType.equals(GroupRacksType.ROUNDROBIN) && ngc.calculateHostNum() > intersecHostNum) {
          valid=false;
          throw ClusterConfigException.LACK_PHYSICAL_HOSTS(ngc.getName(),ngc.calculateHostNum(),intersecHostNum);
        }
 else         if (rackType.equals(GroupRacksType.SAMERACK) && ngc.calculateHostNum() > maxIntersecHostNum) {
          valid=false;
          throw ClusterConfigException.LACK_PHYSICAL_HOSTS(ngc.getName(),ngc.calculateHostNum(),maxIntersecHostNum);
        }
      }
      if (specifiedRacks.isEmpty()) {
        r.setRacks(new String[0]);
      }
 else {
        r.setRacks(intersecRacks.toArray(new String[intersecRacks.size()]));
      }
    }
  }
  return valid;
}"
49082,"public void limitCluster(String clusterName,String nodeGroupName,int activeComputeNodeNum){
  final String path=Constants.REST_PATH_CLUSTER + ""String_Node_Str"" + clusterName+ ""String_Node_Str""+ ""String_Node_Str"";
  final HttpMethod httpverb=HttpMethod.PUT;
  PrettyOutput outputCallBack=getClusterPrettyOutputCallBack(this,clusterName);
  VHMRequestBody requestBody=new VHMRequestBody();
  requestBody.setActiveComputeNodeNum(activeComputeNodeNum);
  requestBody.setNodeGroupName(nodeGroupName);
  restClient.update(requestBody,path,httpverb,outputCallBack);
}","public void limitCluster(String clusterName,String nodeGroupName,int activeComputeNodeNum){
  final String path=Constants.REST_PATH_CLUSTER + ""String_Node_Str"" + clusterName+ ""String_Node_Str""+ ""String_Node_Str"";
  final HttpMethod httpverb=HttpMethod.PUT;
  VHMRequestBody requestBody=new VHMRequestBody();
  requestBody.setActiveComputeNodeNum(activeComputeNodeNum);
  requestBody.setNodeGroupName(nodeGroupName);
  restClient.update(requestBody,path,httpverb);
}"
49083,"private void processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    Status taskStatus=null;
    int progress=0;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      progress=(int)(taskRead.getProgress() * 100);
      taskStatus=taskRead.getStatus();
      if ((prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(false)) || oldTaskStatus != taskStatus || oldProgress != progress) {
        oldTaskStatus=taskStatus;
        oldProgress=progress;
        clearScreen();
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskRead.getStatus() != TaskRead.Status.SUCCESS && taskRead.getStatus() != TaskRead.Status.FAILED);
    String logdir=taskRead.getWorkDir();
    String errorMsg=taskRead.getErrorMessage();
    if (taskRead.getStatus().equals(TaskRead.Status.FAILED)) {
      if (!CommandsUtils.isBlank(logdir)) {
        String outputErrorInfo=Constants.OUTPUT_LOG_INFO + logdir;
        if (errorMsg != null) {
          outputErrorInfo=errorMsg + ""String_Node_Str"" + outputErrorInfo;
        }
        throw new CliRestException(outputErrorInfo);
      }
 else       if (errorMsg != null && !errorMsg.isEmpty()) {
        throw new CliRestException(errorMsg);
      }
 else {
        throw new CliRestException(""String_Node_Str"");
      }
    }
 else     if (taskRead.getStatus().equals(TaskRead.Status.SUCCESS)) {
      if (taskRead.getType().equals(Type.VHM)) {
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(true)) {
          clearScreen();
          System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
          if (prettyOutput != null && prettyOutput.length > 0) {
            prettyOutput[0].prettyOutput();
          }
        }
      }
    }
  }
}","private void processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    Status taskStatus=null;
    int progress=0;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      progress=(int)(taskRead.getProgress() * 100);
      taskStatus=taskRead.getStatus();
      if (oldTaskStatus != taskStatus || oldProgress != progress) {
        oldTaskStatus=taskStatus;
        oldProgress=progress;
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(false)) {
          clearScreen();
          System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
          prettyOutput[0].prettyOutput();
        }
 else {
          String output=taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"";
          if (taskRead.getProgressMessage() != null) {
            output+=taskRead.getProgressMessage();
          }
          System.out.println(output);
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskRead.getStatus() != TaskRead.Status.SUCCESS && taskRead.getStatus() != TaskRead.Status.FAILED);
    String logdir=taskRead.getWorkDir();
    String errorMsg=taskRead.getErrorMessage();
    if (taskRead.getStatus().equals(TaskRead.Status.FAILED)) {
      if (!CommandsUtils.isBlank(logdir)) {
        String outputErrorInfo=Constants.OUTPUT_LOG_INFO + logdir;
        if (errorMsg != null) {
          outputErrorInfo=errorMsg + ""String_Node_Str"" + outputErrorInfo;
        }
        throw new CliRestException(outputErrorInfo);
      }
 else       if (errorMsg != null && !errorMsg.isEmpty()) {
        throw new CliRestException(errorMsg);
      }
 else {
        throw new CliRestException(""String_Node_Str"");
      }
    }
 else     if (taskRead.getStatus().equals(TaskRead.Status.SUCCESS)) {
      if (taskRead.getType().equals(Type.VHM)) {
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(true)) {
          clearScreen();
          System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
          if (prettyOutput != null && prettyOutput.length > 0) {
            prettyOutput[0].prettyOutput();
          }
        }
      }
    }
  }
}"
49084,"public TaskRead(Long id,Status status,Type type,Double progress,String errorMessage,String workDir){
  this.id=id;
  this.status=status;
  this.type=type;
  this.progress=progress;
  this.errorMessage=errorMessage;
  this.workDir=workDir;
}","public TaskRead(Long id,Status status,Type type,Double progress,String errorMessage,String workDir,String progressMessage){
  this.id=id;
  this.status=status;
  this.type=type;
  this.progress=progress;
  this.errorMessage=errorMessage;
  this.workDir=workDir;
  this.progressMessage=progressMessage;
}"
49085,"public Void body(){
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  AuAssert.check(cluster != null);
  cluster.setStatus(status);
  return null;
}","@Override public List<String> body(){
  List<String> clusterNames=new ArrayList<String>();
  List<ClusterEntity> clusters=DAL.findAll(ClusterEntity.class);
  for (  ClusterEntity cluster : clusters) {
    Set<String> usedDS=cluster.getUsedVcDatastores();
    if (matchDatastorePattern(patterns,usedDS)) {
      clusterNames.add(cluster.getName());
    }
  }
  return clusterNames;
}"
49086,"public ClusterEntity createClusterConfig(final ClusterCreate cluster){
  final String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  if (!cluster.validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  if (!cluster.validateNodeGroupRoles(failedMsgList)) {
    throw ClusterConfigException.INVALID_ROLES(failedMsgList);
  }
  if (cluster.getDistro() == null || distroMgr.getDistroByName(cluster.getDistro()) == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  transformHDFSUrl(cluster);
  try {
    return DAL.inTransactionDo(new Saveable<ClusterEntity>(){
      public ClusterEntity body(){
        ClusterEntity entity=ClusterEntity.findClusterEntityByName(name);
        if (entity != null) {
          logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
          throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
        }
        logger.debug(""String_Node_Str"" + name);
        Gson gson=new Gson();
        ClusterEntity clusterEntity=new ClusterEntity(name);
        clusterEntity.setDistro(cluster.getDistro());
        clusterEntity.setStartAfterDeploy(true);
        if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
          logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
          clusterEntity.setVcRpNameList(cluster.getRpNames());
        }
 else {
          logger.debug(""String_Node_Str"");
          Set<String> globalNames=rpMgr.getAllRPNames();
          if (globalNames.isEmpty()) {
            throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
          }
          List<String> rpNames=new ArrayList<String>();
          rpNames.addAll(globalNames);
          clusterEntity.setVcRpNameList(rpNames);
        }
        if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
          logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
          clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
        }
 else {
          logger.debug(""String_Node_Str"");
          Set<String> globalNames=datastoreMgr.getAllDataStoreName();
          if (globalNames.isEmpty()) {
            throw ClusterConfigException.NO_DATASTORE_ADDED();
          }
          List<String> dsNames=new ArrayList<String>();
          dsNames.addAll(globalNames);
          clusterEntity.setVcDatastoreNameList(dsNames);
        }
        String networkName=cluster.getNetworkName();
        NetworkEntity networkEntity=null;
        if (networkName == null || networkName.isEmpty()) {
          List<NetworkEntity> nets=networkMgr.getAllNetworkEntities();
          if (nets.isEmpty() || nets.size() > 1) {
            throw ClusterConfigException.NETWORK_IS_NOT_SPECIFIED(nets.size(),name);
          }
 else {
            networkEntity=nets.get(0);
          }
        }
 else {
          networkEntity=networkMgr.getNetworkEntityByName(networkName);
        }
        if (networkEntity == null) {
          throw ClusterConfigException.NETWORK_IS_NOT_FOUND(networkName,name);
        }
        clusterEntity.setNetwork(networkEntity);
        if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
          CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
          clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
        }
        NodeGroupCreate[] groups=cluster.getNodeGroups();
        if (groups != null && groups.length > 0) {
          clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,EnumSet.noneOf(HadoopRole.class),cluster.isValidateConfig()));
        }
        if (cluster.getTopologyPolicy() == null) {
          clusterEntity.setTopologyPolicy(TopologyType.NONE);
        }
 else {
          clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
        }
        if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
          boolean hveSupported=false;
          if (clusterEntity.getDistro() != null) {
            DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
            if (dr != null) {
              hveSupported=dr.isHveSupported();
            }
          }
          if (!hveSupported) {
            throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
          }
        }
        clusterEntity.insert();
        logger.debug(""String_Node_Str"" + name);
        return clusterEntity;
      }
    }
);
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","public ClusterEntity createClusterConfig(final ClusterCreate cluster){
  final String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  if (!cluster.validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  if (!cluster.validateNodeGroupRoles(failedMsgList)) {
    throw ClusterConfigException.INVALID_ROLES(failedMsgList);
  }
  if (cluster.getDistro() == null || distroMgr.getDistroByName(cluster.getDistro()) == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  transformHDFSUrl(cluster);
  try {
    return DAL.inTransactionDo(new Saveable<ClusterEntity>(){
      public ClusterEntity body(){
        ClusterEntity entity=ClusterEntity.findClusterEntityByName(name);
        if (entity != null) {
          logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
          throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
        }
        logger.debug(""String_Node_Str"" + name);
        Gson gson=new Gson();
        ClusterEntity clusterEntity=new ClusterEntity(name);
        clusterEntity.setDistro(cluster.getDistro());
        clusterEntity.setStartAfterDeploy(true);
        if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
          logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
          clusterEntity.setVcRpNameList(cluster.getRpNames());
        }
 else {
          logger.debug(""String_Node_Str"");
        }
        if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
          logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
          clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
        }
 else {
          logger.debug(""String_Node_Str"");
        }
        String networkName=cluster.getNetworkName();
        NetworkEntity networkEntity=null;
        if (networkName == null || networkName.isEmpty()) {
          List<NetworkEntity> nets=networkMgr.getAllNetworkEntities();
          if (nets.isEmpty() || nets.size() > 1) {
            throw ClusterConfigException.NETWORK_IS_NOT_SPECIFIED(nets.size(),name);
          }
 else {
            networkEntity=nets.get(0);
          }
        }
 else {
          networkEntity=networkMgr.getNetworkEntityByName(networkName);
        }
        if (networkEntity == null) {
          throw ClusterConfigException.NETWORK_IS_NOT_FOUND(networkName,name);
        }
        clusterEntity.setNetwork(networkEntity);
        if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
          CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
          clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
        }
        NodeGroupCreate[] groups=cluster.getNodeGroups();
        if (groups != null && groups.length > 0) {
          clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,EnumSet.noneOf(HadoopRole.class),cluster.isValidateConfig()));
        }
        if (cluster.getTopologyPolicy() == null) {
          clusterEntity.setTopologyPolicy(TopologyType.NONE);
        }
 else {
          clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
        }
        if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
          boolean hveSupported=false;
          if (clusterEntity.getDistro() != null) {
            DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
            if (dr != null) {
              hveSupported=dr.isHveSupported();
            }
          }
          if (!hveSupported) {
            throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
          }
        }
        clusterEntity.insert();
        logger.debug(""String_Node_Str"" + name);
        return clusterEntity;
      }
    }
);
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
49087,"public void deleteDatastore(String name){
  logger.debug(""String_Node_Str"" + name);
  final List<VcDataStoreEntity> entities=VcDataStoreEntity.findByName(name);
  if (entities.isEmpty()) {
    throw VcProviderException.DATASTORE_NOT_FOUND(name);
  }
  List<ClusterEntity> clusters=ClusterEntity.findClusterEntityByDatastore(name);
  if (!clusters.isEmpty()) {
    List<String> clusterNames=new ArrayList<String>();
    for (    ClusterEntity cluster : clusters) {
      clusterNames.add(cluster.getName());
    }
    logger.error(""String_Node_Str"" + clusterNames);
    throw VcProviderException.DATASTORE_IS_REFERENCED_BY_CLUSTER(clusterNames);
  }
  DAL.inTransactionDo(new Saveable<Void>(){
    public Void body() throws VcProviderException {
      for (      VcDataStoreEntity entity : entities) {
        entity.delete();
      }
      return null;
    }
  }
);
  logger.debug(""String_Node_Str"" + name);
}","public void deleteDatastore(String name){
  logger.debug(""String_Node_Str"" + name);
  final List<VcDataStoreEntity> entities=VcDataStoreEntity.findByName(name);
  if (entities.isEmpty()) {
    throw VcProviderException.DATASTORE_NOT_FOUND(name);
  }
  final Set<String> patterns=new HashSet<String>();
  for (  VcDataStoreEntity entity : entities) {
    patterns.add(entity.getVcDatastore());
  }
  List<String> clusterNames=ClusterEntity.findClusterNamesByUsedDatastores(patterns);
  if (!clusterNames.isEmpty()) {
    logger.error(""String_Node_Str"" + clusterNames);
    throw VcProviderException.DATASTORE_IS_REFERENCED_BY_CLUSTER(clusterNames);
  }
  DAL.inTransactionDo(new Saveable<Void>(){
    public Void body() throws VcProviderException {
      for (      VcDataStoreEntity entity : entities) {
        entity.delete();
      }
      return null;
    }
  }
);
  logger.debug(""String_Node_Str"" + name);
}"
49088,"public void deleteResourcePool(final String rpName){
  logger.debug(""String_Node_Str"" + rpName);
  VcResourcePoolEntity entity=VcResourcePoolEntity.findByName(rpName);
  if (entity == null) {
    throw VcProviderException.RESOURCE_POOL_NOT_FOUND(rpName);
  }
  List<ClusterEntity> clusters=ClusterEntity.findClusterEntityByRP(rpName);
  if (!clusters.isEmpty()) {
    List<String> clusterNames=new ArrayList<String>();
    for (    ClusterEntity cluster : clusters) {
      clusterNames.add(cluster.getName());
    }
    logger.error(""String_Node_Str"" + clusterNames);
    throw VcProviderException.RESOURCE_POOL_IS_REFERENCED_BY_CLUSTER(clusterNames);
  }
  DAL.inTransactionDelete(entity);
  logger.debug(""String_Node_Str"" + rpName);
}","public void deleteResourcePool(final String rpName){
  logger.debug(""String_Node_Str"" + rpName);
  VcResourcePoolEntity entity=VcResourcePoolEntity.findByName(rpName);
  if (entity == null) {
    throw VcProviderException.RESOURCE_POOL_NOT_FOUND(rpName);
  }
  List<String> clusterNames=ClusterEntity.findClusterNamesByUsedResourcePool(rpName);
  if (!clusterNames.isEmpty()) {
    logger.error(""String_Node_Str"" + clusterNames);
    throw VcProviderException.RESOURCE_POOL_IS_REFERENCED_BY_CLUSTER(clusterNames);
  }
  DAL.inTransactionDelete(entity);
  logger.debug(""String_Node_Str"" + rpName);
}"
49089,"public static void writeProperties(Properties properties,String propertiesFilePath){
  FileOutputStream fos=null;
  try {
    fos=new FileOutputStream(propertiesFilePath);
    properties.store(fos,""String_Node_Str"");
    fos.close();
  }
 catch (  IOException e) {
    System.out.println(e.getMessage());
    if (fos != null) {
      try {
        fos.close();
      }
 catch (      IOException e1) {
        System.out.println(e1.getMessage());
      }
    }
  }
}","public static void writeProperties(Properties properties,String propertiesFilePath){
  FileOutputStream fos=null;
  try {
    Properties prop=null;
    File file=new File(propertiesFilePath);
    if (file.exists()) {
      prop=new Properties();
      prop.load(new FileInputStream(propertiesFilePath));
      prop.putAll(properties);
    }
 else {
      prop=properties;
    }
    fos=new FileOutputStream(propertiesFilePath);
    prop.store(fos,""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(e.getMessage());
  }
 finally {
    if (fos != null) {
      try {
        fos.close();
      }
 catch (      IOException e1) {
        System.out.println(e1.getMessage());
      }
    }
  }
}"
49090,"public static Properties readProperties(String propertiesFilePath){
  Properties properties=new Properties();
  FileInputStream fis=null;
  try {
    File file=new File(propertiesFilePath);
    if (!file.exists()) {
      return null;
    }
    fis=new FileInputStream(propertiesFilePath);
    properties.load(fis);
    fis.close();
    return properties;
  }
 catch (  IOException e) {
    System.out.println(e.getMessage());
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e1) {
        System.out.println(e1.getMessage());
      }
    }
    return null;
  }
}","public static Properties readProperties(String propertiesFilePath){
  Properties properties=new Properties();
  FileInputStream fis=null;
  try {
    File file=new File(propertiesFilePath);
    if (!file.exists()) {
      return null;
    }
    fis=new FileInputStream(propertiesFilePath);
    properties.load(fis);
    return properties;
  }
 catch (  IOException e) {
    System.out.println(e.getMessage());
    return null;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
        System.out.println(e.getMessage());
      }
    }
  }
}"
49091,"private <T>ResponseEntity<T> login(final String path,final Class<T> respEntityType,final String username,final String password){
  StringBuilder uriBuff=new StringBuilder();
  uriBuff.append(hostUri).append(path);
  if (!CommandsUtils.isBlank(username) && !CommandsUtils.isBlank(password)) {
    uriBuff.append(""String_Node_Str"").append(""String_Node_Str"").append(username).append(""String_Node_Str"").append(password);
  }
  return restPostByUri(uriBuff.toString(),respEntityType);
}","private <T>ResponseEntity<T> login(final String path,final Class<T> respEntityType,final String username,final String password){
  StringBuilder uriBuff=new StringBuilder();
  uriBuff.append(hostUri).append(path);
  if (!CommandsUtils.isBlank(username) && !CommandsUtils.isBlank(password)) {
    uriBuff.append(""String_Node_Str"").append(""String_Node_Str"").append(username).append(""String_Node_Str"").append(password);
  }
  return restPostByUri(uriBuff.toString(),respEntityType,false);
}"
49092,"private <T>ResponseEntity<T> restPostByUri(String uri,Class<T> respEntityType){
  HttpHeaders headers=buildHeaders();
  HttpEntity<String> entity=new HttpEntity<String>(headers);
  return client.exchange(uri,HttpMethod.POST,entity,respEntityType);
}","private <T>ResponseEntity<T> restPostByUri(String uri,Class<T> respEntityType,boolean withCookie){
  HttpHeaders headers=buildHeaders(withCookie);
  HttpEntity<String> entity=new HttpEntity<String>(headers);
  return client.exchange(uri,HttpMethod.POST,entity,respEntityType);
}"
49093,"private String readCookieInfo(){
  String cookieValue=""String_Node_Str"";
  cookieValue=CookieCache.get(""String_Node_Str"");
  if (CommandsUtils.isBlank(cookieValue)) {
    String propertiesFile=""String_Node_Str"";
    Properties properties=null;
    properties=CommandsUtils.readProperties(propertiesFile);
    if (properties != null) {
      return properties.getProperty(""String_Node_Str"");
    }
 else {
      return null;
    }
  }
  return cookieValue;
}","private String readCookieInfo(){
  String cookieValue=""String_Node_Str"";
  cookieValue=CookieCache.get(""String_Node_Str"");
  if (CommandsUtils.isBlank(cookieValue)) {
    Properties properties=null;
    properties=CommandsUtils.readProperties(Constants.PROPERTY_FILE);
    if (properties != null) {
      return properties.getProperty(""String_Node_Str"");
    }
 else {
      return null;
    }
  }
  return cookieValue;
}"
49094,"private HttpHeaders buildHeaders(){
  HttpHeaders headers=new HttpHeaders();
  headers.setContentType(MediaType.APPLICATION_JSON);
  List<MediaType> acceptedTypes=new ArrayList<MediaType>();
  acceptedTypes.add(MediaType.APPLICATION_JSON);
  acceptedTypes.add(MediaType.TEXT_HTML);
  headers.setAccept(acceptedTypes);
  String cookieInfo=readCookieInfo();
  headers.add(""String_Node_Str"",cookieInfo == null ? ""String_Node_Str"" : cookieInfo);
  return headers;
}","private HttpHeaders buildHeaders(){
  return buildHeaders(true);
}"
49095,"private void writeCookieInfo(String cookie){
  CookieCache.put(""String_Node_Str"",cookie);
  String propertiesFile=""String_Node_Str"";
  Properties properties=new Properties();
  properties.put(""String_Node_Str"",cookie);
  CommandsUtils.writeProperties(properties,propertiesFile);
}","private void writeCookieInfo(String cookie){
  CookieCache.put(""String_Node_Str"",cookie);
  Properties properties=new Properties();
  properties.put(""String_Node_Str"",cookie);
  CommandsUtils.writeProperties(properties,Constants.PROPERTY_FILE);
}"
49096,"@Test public void testResumeCreateClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,true,false,false);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testResumeCreateClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,true,false,false);
  CookieCache.clear();
}"
49097,"@Test public void testCreateClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.BAD_REQUEST,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testCreateClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.BAD_REQUEST,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}"
49098,"@Test public void testCreateClusterBySpecFile() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  distro.setRoles(roles);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testCreateClusterBySpecFile() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  distro.setRoles(roles);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"" + Constants.DEFAULT_DISTRO,HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distro));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,""String_Node_Str"",null,null,null,null,false,false,true);
  CookieCache.clear();
}"
49099,"@Test public void testClusterStopFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.stopCluster(""String_Node_Str"");
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClusterStopFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.stopCluster(""String_Node_Str"");
  CookieCache.clear();
}"
49100,"@Test(enabled=false) public void testConfigCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_NAME_NODE);
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  cr1.setNodeGroups(nodeGroupRead1);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.configCluster(""String_Node_Str"",""String_Node_Str"",false,false);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test(enabled=false) public void testConfigCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_NAME_NODE);
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  cr1.setNodeGroups(nodeGroupRead1);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.configCluster(""String_Node_Str"",""String_Node_Str"",false,false);
  CookieCache.clear();
}"
49101,"@Test public void testClusterStop(){
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  this.buildReqRespWithoutRespBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.stopCluster(""String_Node_Str"");
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClusterStop(){
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  this.buildReqRespWithoutRespBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.stopCluster(""String_Node_Str"");
  CookieCache.clear();
}"
49102,"@Test public void testClusterStartFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.startCluster(""String_Node_Str"");
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClusterStartFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.startCluster(""String_Node_Str"");
  CookieCache.clear();
}"
49103,"@Test public void testResumeCreateCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,null,null,null,null,true,false,false);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testResumeCreateCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,null,null,null,null,true,false,false);
  CookieCache.clear();
}"
49104,"@Test public void testClusterCreateOutput() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.ACCEPTED,""String_Node_Str"",""String_Node_Str"");
  TaskRead task=new TaskRead();
  task.setId(12l);
  task.setType(Type.INNER);
  task.setProgress(0.8);
  task.setStatus(Status.RUNNING);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  ClusterRead cluster=new ClusterRead();
  List<NodeGroupRead> nodeGroups=new ArrayList<NodeGroupRead>();
  NodeGroupRead workerGroup=new NodeGroupRead();
  workerGroup.setName(""String_Node_Str"");
  workerGroup.setInstanceNum(1);
  List<NodeRead> instances=new ArrayList<NodeRead>();
  NodeRead instance1=new NodeRead();
  instance1.setName(""String_Node_Str"");
  instance1.setStatus(""String_Node_Str"");
  instance1.setAction(""String_Node_Str"");
  instances.add(instance1);
  workerGroup.setInstances(instances);
  nodeGroups.add(workerGroup);
  cluster.setNodeGroups(nodeGroups);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  task.setProgress(1.0);
  task.setStatus(Status.SUCCESS);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  instance1.setStatus(""String_Node_Str"");
  instance1.setIp(""String_Node_Str"");
  instance1.setAction(null);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClusterCreateOutput() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.ACCEPTED,""String_Node_Str"",""String_Node_Str"");
  TaskRead task=new TaskRead();
  task.setId(12l);
  task.setType(Type.INNER);
  task.setProgress(0.8);
  task.setStatus(Status.RUNNING);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  ClusterRead cluster=new ClusterRead();
  List<NodeGroupRead> nodeGroups=new ArrayList<NodeGroupRead>();
  NodeGroupRead workerGroup=new NodeGroupRead();
  workerGroup.setName(""String_Node_Str"");
  workerGroup.setInstanceNum(1);
  List<NodeRead> instances=new ArrayList<NodeRead>();
  NodeRead instance1=new NodeRead();
  instance1.setName(""String_Node_Str"");
  instance1.setStatus(""String_Node_Str"");
  instance1.setAction(""String_Node_Str"");
  instances.add(instance1);
  workerGroup.setInstances(instances);
  nodeGroups.add(workerGroup);
  cluster.setNodeGroups(nodeGroups);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  task.setProgress(1.0);
  task.setStatus(Status.SUCCESS);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  instance1.setStatus(""String_Node_Str"");
  instance1.setIp(""String_Node_Str"");
  instance1.setAction(null);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}"
49105,"@Test public void testGetCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  StorageRead sr2=new StorageRead();
  sr2.setType(""String_Node_Str"");
  sr2.setSizeGB(200);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  nr1.setRack(""String_Node_Str"");
  NodeRead nr2=new NodeRead();
  nr2.setHostName(""String_Node_Str"");
  nr2.setIp(""String_Node_Str"");
  nr2.setName(""String_Node_Str"");
  nr2.setStatus(""String_Node_Str"");
  nr2.setRack(""String_Node_Str"");
  NodeRead nr3=new NodeRead();
  nr3.setHostName(""String_Node_Str"");
  nr3.setIp(""String_Node_Str"");
  nr3.setName(""String_Node_Str"");
  nr3.setStatus(""String_Node_Str"");
  nr3.setRack(""String_Node_Str"");
  NodeRead nr4=new NodeRead();
  nr4.setHostName(""String_Node_Str"");
  nr4.setIp(""String_Node_Str"");
  nr4.setName(""String_Node_Str"");
  nr4.setStatus(""String_Node_Str"");
  nr4.setRack(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  instances1.add(nr2);
  List<NodeRead> instances2=new LinkedList<NodeRead>();
  instances2.add(nr3);
  instances2.add(nr4);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_NAME_NODE);
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  List<String> roles2=new LinkedList<String>();
  roles2.add(Constants.ROLE_HADOOP_DATANODE);
  roles2.add(Constants.ROLE_HADOOP_TASKTRACKER);
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  NodeGroupRead ngr2=new NodeGroupRead();
  ngr2.setName(""String_Node_Str"");
  ngr2.setCpuNum(12);
  ngr2.setMemCapacityMB(2048);
  ngr2.setStorage(sr2);
  ngr2.setInstanceNum(20);
  ngr2.setInstances(instances2);
  ngr2.setRoles(roles2);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  ClusterRead cr2=new ClusterRead();
  cr2.setName(""String_Node_Str"");
  cr2.setDistro(""String_Node_Str"");
  cr2.setInstanceNum(20);
  cr2.setStatus(ClusterRead.ClusterStatus.STOPPED);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  nodeGroupRead1.add(ngr2);
  cr1.setNodeGroups(nodeGroupRead1);
  cr2.setNodeGroups(nodeGroupRead1);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(new ClusterRead[]{cr1,cr2}));
  clusterCommands.getCluster(null,true);
  cr1.setTopologyPolicy(TopologyType.HVE);
  cr2.setTopologyPolicy(TopologyType.RACK_AS_RACK);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(new ClusterRead[]{cr1,cr2}));
  clusterCommands.getCluster(null,true);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testGetCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  StorageRead sr2=new StorageRead();
  sr2.setType(""String_Node_Str"");
  sr2.setSizeGB(200);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  nr1.setRack(""String_Node_Str"");
  NodeRead nr2=new NodeRead();
  nr2.setHostName(""String_Node_Str"");
  nr2.setIp(""String_Node_Str"");
  nr2.setName(""String_Node_Str"");
  nr2.setStatus(""String_Node_Str"");
  nr2.setRack(""String_Node_Str"");
  NodeRead nr3=new NodeRead();
  nr3.setHostName(""String_Node_Str"");
  nr3.setIp(""String_Node_Str"");
  nr3.setName(""String_Node_Str"");
  nr3.setStatus(""String_Node_Str"");
  nr3.setRack(""String_Node_Str"");
  NodeRead nr4=new NodeRead();
  nr4.setHostName(""String_Node_Str"");
  nr4.setIp(""String_Node_Str"");
  nr4.setName(""String_Node_Str"");
  nr4.setStatus(""String_Node_Str"");
  nr4.setRack(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  instances1.add(nr2);
  List<NodeRead> instances2=new LinkedList<NodeRead>();
  instances2.add(nr3);
  instances2.add(nr4);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_NAME_NODE);
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  List<String> roles2=new LinkedList<String>();
  roles2.add(Constants.ROLE_HADOOP_DATANODE);
  roles2.add(Constants.ROLE_HADOOP_TASKTRACKER);
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  NodeGroupRead ngr2=new NodeGroupRead();
  ngr2.setName(""String_Node_Str"");
  ngr2.setCpuNum(12);
  ngr2.setMemCapacityMB(2048);
  ngr2.setStorage(sr2);
  ngr2.setInstanceNum(20);
  ngr2.setInstances(instances2);
  ngr2.setRoles(roles2);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  ClusterRead cr2=new ClusterRead();
  cr2.setName(""String_Node_Str"");
  cr2.setDistro(""String_Node_Str"");
  cr2.setInstanceNum(20);
  cr2.setStatus(ClusterRead.ClusterStatus.STOPPED);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  nodeGroupRead1.add(ngr2);
  cr1.setNodeGroups(nodeGroupRead1);
  cr2.setNodeGroups(nodeGroupRead1);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(new ClusterRead[]{cr1,cr2}));
  clusterCommands.getCluster(null,true);
  cr1.setTopologyPolicy(TopologyType.HVE);
  cr2.setTopologyPolicy(TopologyType.RACK_AS_RACK);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(new ClusterRead[]{cr1,cr2}));
  clusterCommands.getCluster(null,true);
  CookieCache.clear();
}"
49106,"@Test public void testClusterResizeFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  StorageRead sr2=new StorageRead();
  sr2.setType(""String_Node_Str"");
  sr2.setSizeGB(200);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  NodeRead nr2=new NodeRead();
  nr2.setHostName(""String_Node_Str"");
  nr2.setIp(""String_Node_Str"");
  nr2.setName(""String_Node_Str"");
  nr2.setStatus(""String_Node_Str"");
  NodeRead nr3=new NodeRead();
  nr3.setHostName(""String_Node_Str"");
  nr3.setIp(""String_Node_Str"");
  nr3.setName(""String_Node_Str"");
  nr3.setStatus(""String_Node_Str"");
  NodeRead nr4=new NodeRead();
  nr4.setHostName(""String_Node_Str"");
  nr4.setIp(""String_Node_Str"");
  nr4.setName(""String_Node_Str"");
  nr4.setStatus(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  instances1.add(nr2);
  List<NodeRead> instances2=new LinkedList<NodeRead>();
  instances2.add(nr3);
  instances2.add(nr4);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  List<String> roles2=new LinkedList<String>();
  roles2.add(Constants.ROLE_HADOOP_TASKTRACKER);
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  NodeGroupRead ngr2=new NodeGroupRead();
  ngr2.setName(""String_Node_Str"");
  ngr2.setCpuNum(12);
  ngr2.setMemCapacityMB(2048);
  ngr2.setStorage(sr2);
  ngr2.setInstanceNum(20);
  ngr2.setInstances(instances2);
  ngr2.setRoles(roles2);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  nodeGroupRead1.add(ngr2);
  cr1.setNodeGroups(nodeGroupRead1);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.resizeCluster(""String_Node_Str"",""String_Node_Str"",5);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClusterResizeFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  StorageRead sr2=new StorageRead();
  sr2.setType(""String_Node_Str"");
  sr2.setSizeGB(200);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  NodeRead nr2=new NodeRead();
  nr2.setHostName(""String_Node_Str"");
  nr2.setIp(""String_Node_Str"");
  nr2.setName(""String_Node_Str"");
  nr2.setStatus(""String_Node_Str"");
  NodeRead nr3=new NodeRead();
  nr3.setHostName(""String_Node_Str"");
  nr3.setIp(""String_Node_Str"");
  nr3.setName(""String_Node_Str"");
  nr3.setStatus(""String_Node_Str"");
  NodeRead nr4=new NodeRead();
  nr4.setHostName(""String_Node_Str"");
  nr4.setIp(""String_Node_Str"");
  nr4.setName(""String_Node_Str"");
  nr4.setStatus(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  instances1.add(nr2);
  List<NodeRead> instances2=new LinkedList<NodeRead>();
  instances2.add(nr3);
  instances2.add(nr4);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  List<String> roles2=new LinkedList<String>();
  roles2.add(Constants.ROLE_HADOOP_TASKTRACKER);
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  NodeGroupRead ngr2=new NodeGroupRead();
  ngr2.setName(""String_Node_Str"");
  ngr2.setCpuNum(12);
  ngr2.setMemCapacityMB(2048);
  ngr2.setStorage(sr2);
  ngr2.setInstanceNum(20);
  ngr2.setInstances(instances2);
  ngr2.setRoles(roles2);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  nodeGroupRead1.add(ngr2);
  cr1.setNodeGroups(nodeGroupRead1);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.resizeCluster(""String_Node_Str"",""String_Node_Str"",5);
  CookieCache.clear();
}"
49107,"@Test public void testLimitCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  StorageRead sr2=new StorageRead();
  sr2.setType(""String_Node_Str"");
  sr2.setSizeGB(200);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  NodeRead nr2=new NodeRead();
  nr2.setHostName(""String_Node_Str"");
  nr2.setIp(""String_Node_Str"");
  nr2.setName(""String_Node_Str"");
  nr2.setStatus(""String_Node_Str"");
  NodeRead nr3=new NodeRead();
  nr3.setHostName(""String_Node_Str"");
  nr3.setIp(""String_Node_Str"");
  nr3.setName(""String_Node_Str"");
  nr3.setStatus(""String_Node_Str"");
  NodeRead nr4=new NodeRead();
  nr4.setHostName(""String_Node_Str"");
  nr4.setIp(""String_Node_Str"");
  nr4.setName(""String_Node_Str"");
  nr4.setStatus(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  instances1.add(nr2);
  List<NodeRead> instances2=new LinkedList<NodeRead>();
  instances2.add(nr3);
  instances2.add(nr4);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  List<String> roles2=new LinkedList<String>();
  roles2.add(Constants.ROLE_HADOOP_TASKTRACKER);
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  NodeGroupRead ngr2=new NodeGroupRead();
  ngr2.setName(""String_Node_Str"");
  ngr2.setCpuNum(12);
  ngr2.setMemCapacityMB(2048);
  ngr2.setStorage(sr2);
  ngr2.setInstanceNum(20);
  ngr2.setInstances(instances2);
  ngr2.setRoles(roles2);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  nodeGroupRead1.add(ngr2);
  cr1.setNodeGroups(nodeGroupRead1);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.limitCluster(""String_Node_Str"",""String_Node_Str"",1);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testLimitCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  StorageRead sr2=new StorageRead();
  sr2.setType(""String_Node_Str"");
  sr2.setSizeGB(200);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  NodeRead nr2=new NodeRead();
  nr2.setHostName(""String_Node_Str"");
  nr2.setIp(""String_Node_Str"");
  nr2.setName(""String_Node_Str"");
  nr2.setStatus(""String_Node_Str"");
  NodeRead nr3=new NodeRead();
  nr3.setHostName(""String_Node_Str"");
  nr3.setIp(""String_Node_Str"");
  nr3.setName(""String_Node_Str"");
  nr3.setStatus(""String_Node_Str"");
  NodeRead nr4=new NodeRead();
  nr4.setHostName(""String_Node_Str"");
  nr4.setIp(""String_Node_Str"");
  nr4.setName(""String_Node_Str"");
  nr4.setStatus(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  instances1.add(nr2);
  List<NodeRead> instances2=new LinkedList<NodeRead>();
  instances2.add(nr3);
  instances2.add(nr4);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  List<String> roles2=new LinkedList<String>();
  roles2.add(Constants.ROLE_HADOOP_TASKTRACKER);
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  NodeGroupRead ngr2=new NodeGroupRead();
  ngr2.setName(""String_Node_Str"");
  ngr2.setCpuNum(12);
  ngr2.setMemCapacityMB(2048);
  ngr2.setStorage(sr2);
  ngr2.setInstanceNum(20);
  ngr2.setInstances(instances2);
  ngr2.setRoles(roles2);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  nodeGroupRead1.add(ngr2);
  cr1.setNodeGroups(nodeGroupRead1);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.limitCluster(""String_Node_Str"",""String_Node_Str"",1);
  CookieCache.clear();
}"
49108,"@Test public void testGetClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.getCluster(null,true);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testGetClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.getCluster(null,true);
  CookieCache.clear();
}"
49109,"@Test public void testClusterStart(){
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  this.buildReqRespWithoutRespBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.startCluster(""String_Node_Str"");
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClusterStart(){
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  this.buildReqRespWithoutRespBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.startCluster(""String_Node_Str"");
  CookieCache.clear();
}"
49110,"@Test public void testCreateCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testCreateCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.clear();
}"
49111,"@Test public void testExportClusterSpec() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(this.getClass().getResource(""String_Node_Str"").getPath()));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(clusterSpec));
  clusterCommands.exportClusterSpec(""String_Node_Str"",null);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testExportClusterSpec() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(this.getClass().getResource(""String_Node_Str"").getPath()));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(clusterSpec));
  clusterCommands.exportClusterSpec(""String_Node_Str"",null);
  CookieCache.clear();
}"
49112,"@Test public void testClusterResize() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  StorageRead sr2=new StorageRead();
  sr2.setType(""String_Node_Str"");
  sr2.setSizeGB(200);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  NodeRead nr2=new NodeRead();
  nr2.setHostName(""String_Node_Str"");
  nr2.setIp(""String_Node_Str"");
  nr2.setName(""String_Node_Str"");
  nr2.setStatus(""String_Node_Str"");
  NodeRead nr3=new NodeRead();
  nr3.setHostName(""String_Node_Str"");
  nr3.setIp(""String_Node_Str"");
  nr3.setName(""String_Node_Str"");
  nr3.setStatus(""String_Node_Str"");
  NodeRead nr4=new NodeRead();
  nr4.setHostName(""String_Node_Str"");
  nr4.setIp(""String_Node_Str"");
  nr4.setName(""String_Node_Str"");
  nr4.setStatus(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  instances1.add(nr2);
  List<NodeRead> instances2=new LinkedList<NodeRead>();
  instances2.add(nr3);
  instances2.add(nr4);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  List<String> roles2=new LinkedList<String>();
  roles2.add(HadoopRole.ZOOKEEPER_ROLE.toString());
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  NodeGroupRead ngr2=new NodeGroupRead();
  ngr2.setName(""String_Node_Str"");
  ngr2.setCpuNum(12);
  ngr2.setMemCapacityMB(2048);
  ngr2.setStorage(sr2);
  ngr2.setInstanceNum(20);
  ngr2.setInstances(instances2);
  ngr2.setRoles(roles2);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  nodeGroupRead1.add(ngr2);
  cr1.setNodeGroups(nodeGroupRead1);
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  this.buildReqRespWithoutRespBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.resizeCluster(""String_Node_Str"",""String_Node_Str"",0);
  clusterCommands.resizeCluster(""String_Node_Str"",""String_Node_Str"",5);
  setup();
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  this.buildReqRespWithoutRespBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.resizeCluster(""String_Node_Str"",""String_Node_Str"",5);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClusterResize() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  StorageRead sr1=new StorageRead();
  sr1.setType(""String_Node_Str"");
  sr1.setSizeGB(100);
  StorageRead sr2=new StorageRead();
  sr2.setType(""String_Node_Str"");
  sr2.setSizeGB(200);
  NodeRead nr1=new NodeRead();
  nr1.setHostName(""String_Node_Str"");
  nr1.setIp(""String_Node_Str"");
  nr1.setName(""String_Node_Str"");
  nr1.setStatus(""String_Node_Str"");
  NodeRead nr2=new NodeRead();
  nr2.setHostName(""String_Node_Str"");
  nr2.setIp(""String_Node_Str"");
  nr2.setName(""String_Node_Str"");
  nr2.setStatus(""String_Node_Str"");
  NodeRead nr3=new NodeRead();
  nr3.setHostName(""String_Node_Str"");
  nr3.setIp(""String_Node_Str"");
  nr3.setName(""String_Node_Str"");
  nr3.setStatus(""String_Node_Str"");
  NodeRead nr4=new NodeRead();
  nr4.setHostName(""String_Node_Str"");
  nr4.setIp(""String_Node_Str"");
  nr4.setName(""String_Node_Str"");
  nr4.setStatus(""String_Node_Str"");
  List<NodeRead> instances1=new LinkedList<NodeRead>();
  instances1.add(nr1);
  instances1.add(nr2);
  List<NodeRead> instances2=new LinkedList<NodeRead>();
  instances2.add(nr3);
  instances2.add(nr4);
  List<String> roles1=new LinkedList<String>();
  roles1.add(Constants.ROLE_HADOOP_JOB_TRACKER);
  List<String> roles2=new LinkedList<String>();
  roles2.add(HadoopRole.ZOOKEEPER_ROLE.toString());
  NodeGroupRead ngr1=new NodeGroupRead();
  ngr1.setName(""String_Node_Str"");
  ngr1.setCpuNum(6);
  ngr1.setMemCapacityMB(2048);
  ngr1.setStorage(sr1);
  ngr1.setInstanceNum(1);
  ngr1.setInstances(instances1);
  ngr1.setRoles(roles1);
  NodeGroupRead ngr2=new NodeGroupRead();
  ngr2.setName(""String_Node_Str"");
  ngr2.setCpuNum(12);
  ngr2.setMemCapacityMB(2048);
  ngr2.setStorage(sr2);
  ngr2.setInstanceNum(20);
  ngr2.setInstances(instances2);
  ngr2.setRoles(roles2);
  ClusterRead cr1=new ClusterRead();
  cr1.setName(""String_Node_Str"");
  cr1.setDistro(""String_Node_Str"");
  cr1.setInstanceNum(10);
  cr1.setStatus(ClusterRead.ClusterStatus.RUNNING);
  List<NodeGroupRead> nodeGroupRead1=new LinkedList<NodeGroupRead>();
  nodeGroupRead1.add(ngr1);
  nodeGroupRead1.add(ngr2);
  cr1.setNodeGroups(nodeGroupRead1);
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  this.buildReqRespWithoutRespBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.resizeCluster(""String_Node_Str"",""String_Node_Str"",0);
  clusterCommands.resizeCluster(""String_Node_Str"",""String_Node_Str"",5);
  setup();
  this.buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cr1));
  this.buildReqRespWithoutRespBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.resizeCluster(""String_Node_Str"",""String_Node_Str"",5);
  CookieCache.clear();
}"
49113,"public boolean validatePlacementPolicies(ClusterCreate cluster,Map<String,NodeGroupCreate> groups,List<String> failedMsgList,List<String> warningMsgList){
  boolean valid=true;
  PlacementPolicy policies=getPlacementPolicies();
  if (policies != null) {
    if (policies.getInstancePerHost() != null) {
      if (policies.getInstancePerHost() <= 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).toString());
      }
 else       if (calculateHostNum() < 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupRacks() != null) {
      if (cluster.getTopologyPolicy() == null) {
        warningMsgList.add(""String_Node_Str"" + Constants.PRACK_NO_TOPOLOGY_TYPE_SPECIFIED);
        cluster.setTopologyPolicy(TopologyType.NONE);
      }
      GroupRacks r=policies.getGroupRacks();
      if (r.getType() == null) {
        r.setType(GroupRacksType.ROUNDROBIN);
      }
 else       if (r.getType() == GroupRacksType.SAMERACK && r.getRacks().length != 1) {
        valid=false;
        failedMsgList.add(Constants.PRACK_SAME_RACK_WITH_WRONG_VALUES);
      }
      if (getStorage() == null || getStorage().getType() == null || getStorage().getType().equals(DatastoreType.SHARED.toString())) {
        warningMsgList.add(""String_Node_Str"" + Constants.PRACK_WITH_SHARED_STORAGE);
      }
    }
    if (policies.getGroupAssociations() != null) {
      if (policies.getGroupAssociations().size() != 1) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
      }
 else {
        GroupAssociation a=policies.getGroupAssociations().get(0);
        if (a.getType() == null) {
          a.setType(GroupAssociationType.WEAK);
        }
        if (a.getReference() == null) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (a.getReference().equals(getName())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (!groups.containsKey(a.getReference())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).toString());
        }
 else {
          if (a.getType() == GroupAssociationType.STRICT) {
            if (policies.getGroupRacks() != null) {
              warningMsgList.add(""String_Node_Str"" + Constants.PRACK_WITH_STRICT_ASSOCIATION);
            }
            int hostNum=1;
            int refHostNum=groups.get(a.getReference()).getInstanceNum();
            if (calculateHostNum() != null) {
              hostNum=calculateHostNum();
            }
            if (groups.get(a.getReference()).calculateHostNum() != null) {
              refHostNum=groups.get(a.getReference()).calculateHostNum();
            }
            if (hostNum > refHostNum) {
              valid=false;
              failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"" + ""String_Node_Str"").append(a.getReference()).toString());
            }
          }
          PlacementPolicy refPolicies=groups.get(a.getReference()).getPlacementPolicies();
          if (refPolicies != null && refPolicies.getGroupAssociations() != null && !refPolicies.getGroupAssociations().isEmpty()) {
            valid=false;
            failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
          }
        }
      }
    }
  }
  return valid;
}","@SuppressWarnings(""String_Node_Str"") public boolean validatePlacementPolicies(ClusterCreate cluster,Map<String,NodeGroupCreate> groups,List<String> failedMsgList,List<String> warningMsgList){
  boolean valid=true;
  if (cluster.getTopologyPolicy() == TopologyType.HVE || cluster.getTopologyPolicy() == TopologyType.HOST_AS_RACK || cluster.getTopologyPolicy() == TopologyType.RACK_AS_RACK) {
    if (getPlacementPolicies() == null) {
      setPlacementPolicies(new PlacementPolicy());
    }
    if (getPlacementPolicies().getGroupRacks() == null) {
      GroupRacks groupRacks=new GroupRacks();
      groupRacks.setType(GroupRacksType.ROUNDROBIN);
      groupRacks.setRacks(new String[0]);
      getPlacementPolicies().setGroupRacks(groupRacks);
    }
  }
  PlacementPolicy policies=getPlacementPolicies();
  if (policies != null) {
    if (policies.getInstancePerHost() != null) {
      if (policies.getInstancePerHost() <= 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).toString());
      }
 else       if (calculateHostNum() < 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupRacks() != null) {
      if (cluster.getTopologyPolicy() == null) {
        warningMsgList.add(""String_Node_Str"" + Constants.PRACK_NO_TOPOLOGY_TYPE_SPECIFIED);
        cluster.setTopologyPolicy(TopologyType.NONE);
      }
      GroupRacks r=policies.getGroupRacks();
      if (r.getType() == null) {
        r.setType(GroupRacksType.ROUNDROBIN);
      }
 else       if (r.getType() == GroupRacksType.SAMERACK && r.getRacks().length != 1) {
        valid=false;
        failedMsgList.add(Constants.PRACK_SAME_RACK_WITH_WRONG_VALUES);
      }
      if (r.getRacks() == null) {
        r.setRacks(new String[0]);
      }
      if (getStorage() == null || getStorage().getType() == null || getStorage().getType().equals(DatastoreType.SHARED.toString())) {
        warningMsgList.add(""String_Node_Str"" + Constants.PRACK_WITH_SHARED_STORAGE);
      }
    }
    if (policies.getGroupAssociations() != null) {
      if (policies.getGroupAssociations().size() != 1) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
      }
 else {
        GroupAssociation a=policies.getGroupAssociations().get(0);
        if (a.getType() == null) {
          a.setType(GroupAssociationType.WEAK);
        }
        if (a.getReference() == null) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (a.getReference().equals(getName())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (!groups.containsKey(a.getReference())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).toString());
        }
 else {
          if (a.getType() == GroupAssociationType.STRICT) {
            if (policies.getGroupRacks() != null) {
              warningMsgList.add(""String_Node_Str"" + Constants.PRACK_WITH_STRICT_ASSOCIATION);
            }
            int hostNum=1;
            int refHostNum=groups.get(a.getReference()).getInstanceNum();
            if (calculateHostNum() != null) {
              hostNum=calculateHostNum();
            }
            if (groups.get(a.getReference()).calculateHostNum() != null) {
              refHostNum=groups.get(a.getReference()).calculateHostNum();
            }
            if (hostNum > refHostNum) {
              valid=false;
              failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"" + ""String_Node_Str"").append(a.getReference()).toString());
            }
          }
          PlacementPolicy refPolicies=groups.get(a.getReference()).getPlacementPolicies();
          if (refPolicies != null && refPolicies.getGroupAssociations() != null && !refPolicies.getGroupAssociations().isEmpty()) {
            valid=false;
            failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
          }
        }
      }
    }
  }
  return valid;
}"
49114,"public void validateIfHostCanSatisfied(int instanceNum){
  if (getInstancePerHost() != null) {
    int requiredHostNum=instanceNum / getInstancePerHost();
    if (requiredHostNum > 0 && getGroupRacks() != null) {
      GroupRacks groupRacks=(GroupRacks)new Gson().fromJson(getGroupRacks(),GroupRacks.class);
      Integer totalHostNum=0;
      List<RackInfo> racksInfo=new RackInfoManager().exportRackInfo();
      Set<String> totalRacks=new HashSet<String>(Arrays.asList(groupRacks.getRacks()));
      for (      RackInfo rackInfo : racksInfo) {
        if (totalRacks.isEmpty()) {
          totalHostNum+=rackInfo.getHosts().size();
        }
 else         if (totalRacks.contains(rackInfo.getName())) {
          totalHostNum+=rackInfo.getHosts().size();
        }
      }
      if (totalHostNum < requiredHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS();
      }
    }
  }
}","public void validateIfHostCanSatisfied(int instanceNum){
  if (getInstancePerHost() != null) {
    int requiredHostNum=instanceNum / getInstancePerHost();
    if (requiredHostNum > 0 && getGroupRacks() != null) {
      GroupRacks groupRacks=(GroupRacks)new Gson().fromJson(getGroupRacks(),GroupRacks.class);
      Integer totalHostNum=0;
      List<RackInfo> racksInfo=new RackInfoManager().exportRackInfo();
      Set<String> totalRacks=new HashSet<String>(Arrays.asList(groupRacks.getRacks()));
      for (      RackInfo rackInfo : racksInfo) {
        if (totalRacks.isEmpty()) {
          totalHostNum+=rackInfo.getHosts().size();
        }
 else         if (totalRacks.contains(rackInfo.getName())) {
          totalHostNum+=rackInfo.getHosts().size();
        }
      }
      if (totalHostNum < requiredHostNum) {
        throw ClusterConfigException.LACK_PHYSICAL_HOSTS(this.name,requiredHostNum,totalHostNum);
      }
    }
  }
}"
49115,"public static ClusterConfigException LACK_PHYSICAL_HOSTS(){
  return new ClusterConfigException(null,""String_Node_Str"");
}","public static ClusterConfigException LACK_PHYSICAL_HOSTS(String groupName,int requiredHostNum,int provideHostNum){
  return new ClusterConfigException(null,""String_Node_Str"",groupName,requiredHostNum,provideHostNum);
}"
49116,"private boolean validateRacksInfo(ClusterCreate cluster,List<String> failedMsgList){
  boolean valid=true;
  Map<String,NodeGroupCreate> allGroups=new TreeMap<String,NodeGroupCreate>();
  if (cluster.getNodeGroups() == null) {
    return valid;
  }
  for (  NodeGroupCreate nodeGroupCreate : cluster.getNodeGroups()) {
    allGroups.put(nodeGroupCreate.getName(),nodeGroupCreate);
  }
  for (  NodeGroupCreate ngc : cluster.getNodeGroups()) {
    PlacementPolicy policies=ngc.getPlacementPolicies();
    if (policies != null && policies.getGroupRacks() != null && ngc.calculateHostNum() != null) {
      Integer requiredHostNum=ngc.calculateHostNum();
      if (requiredHostNum > 0) {
        GroupRacks r=policies.getGroupRacks();
        Integer totalHostNum=0;
        List<RackInfo> racksInfo=rackInfoMgr.exportRackInfo();
        Set<String> totalRacks=new HashSet<String>(Arrays.asList(r.getRacks()));
        for (        RackInfo rackInfo : racksInfo) {
          if (totalRacks.isEmpty()) {
            totalHostNum+=rackInfo.getHosts().size();
          }
 else           if (totalRacks.contains(rackInfo.getName())) {
            totalHostNum+=rackInfo.getHosts().size();
          }
        }
        if (totalHostNum < requiredHostNum) {
          valid=false;
          throw ClusterConfigException.LACK_PHYSICAL_HOSTS();
        }
      }
    }
  }
  return valid;
}","private boolean validateRacksInfo(ClusterCreate cluster,List<String> failedMsgList){
  boolean valid=true;
  Map<String,NodeGroupCreate> allGroups=new TreeMap<String,NodeGroupCreate>();
  if (cluster.getNodeGroups() == null) {
    return valid;
  }
  for (  NodeGroupCreate nodeGroupCreate : cluster.getNodeGroups()) {
    allGroups.put(nodeGroupCreate.getName(),nodeGroupCreate);
  }
  for (  NodeGroupCreate ngc : cluster.getNodeGroups()) {
    PlacementPolicy policies=ngc.getPlacementPolicies();
    if (policies != null && policies.getGroupAssociations() != null && policies.getGroupAssociations().get(0).getType() == GroupAssociationType.STRICT) {
      continue;
    }
    if (ngc.getStorage() != null && ngc.getStorage().getType() != null && ngc.getStorage().getType().equals(DatastoreType.SHARED.toString())) {
      continue;
    }
    if (policies != null && policies.getGroupRacks() != null && ngc.calculateHostNum() != null) {
      Integer requiredHostNum=ngc.calculateHostNum();
      if (requiredHostNum > 0) {
        GroupRacks r=policies.getGroupRacks();
        Integer totalHostNum=0;
        List<RackInfo> racksInfo=rackInfoMgr.exportRackInfo();
        Set<String> totalRacks=new HashSet<String>(Arrays.asList(r.getRacks()));
        for (        RackInfo rackInfo : racksInfo) {
          if (totalRacks.isEmpty()) {
            totalHostNum+=rackInfo.getHosts().size();
          }
 else           if (totalRacks.contains(rackInfo.getName())) {
            totalHostNum+=rackInfo.getHosts().size();
          }
        }
        if (totalHostNum < requiredHostNum) {
          valid=false;
          throw ClusterConfigException.LACK_PHYSICAL_HOSTS(ngc.getName(),requiredHostNum,totalHostNum);
        }
      }
    }
  }
  return valid;
}"
49117,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void unlimitCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName){
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void unlimitCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName){
  try {
    int activeComputeNodeNum=-1;
    ClusterRead cluster=restClient.get(clusterName,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return;
    }
    if (!cluster.validateLimit(nodeGroupName)) {
      return;
    }
    restClient.limitCluster(clusterName,nodeGroupName,activeComputeNodeNum);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OP_ADJUSTMENT,null,Constants.OUTPUT_OP_ADJUSTMENT_SUCCEEDED);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,e.getMessage());
  }
}"
49118,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void limitCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final int activeComputeNodeNum){
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void limitCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final int activeComputeNodeNum){
  try {
    if (activeComputeNodeNum < 0) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,""String_Node_Str"" + activeComputeNodeNum + ""String_Node_Str"");
      return;
    }
    ClusterRead cluster=restClient.get(clusterName,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return;
    }
    if (!cluster.validateLimit(nodeGroupName)) {
      return;
    }
    restClient.limitCluster(clusterName,nodeGroupName,activeComputeNodeNum);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OP_ADJUSTMENT,null,Constants.OUTPUT_OP_ADJUSTMENT_SUCCEEDED);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,e.getMessage());
  }
}"
49119,"public boolean isRefresh() throws Exception {
  try {
    cluster=clusterRestClient.get(id,false);
    if (cluster != null) {
      List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
      if (nodeGroups != null) {
        return checkOutputUpdate(nodeGroups);
      }
    }
    return false;
  }
 catch (  CliRestException expectedException) {
    cluster=null;
    return false;
  }
catch (  Exception e) {
    throw e;
  }
}","public boolean isRefresh(boolean realTime) throws Exception {
  try {
    cluster=clusterRestClient.get(id,realTime);
    if (cluster != null) {
      List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
      if (nodeGroups != null) {
        return checkOutputUpdate(nodeGroups);
      }
    }
    return false;
  }
 catch (  CliRestException expectedException) {
    cluster=null;
    return false;
  }
catch (  Exception e) {
    throw e;
  }
}"
49120,"private PrettyOutput getClusterPrettyOutputCallBack(final ClusterRestClient clusterRestClient,final String id){
  return new PrettyOutput(){
    private String ngSnapshotInJson=null;
    private boolean needUpdate=true;
    private ClusterRead cluster=null;
    public void prettyOutput() throws Exception {
      try {
        if (cluster != null) {
          List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
          if (nodeGroups != null) {
            for (            NodeGroupRead nodeGroup : nodeGroups) {
              System.out.printf(""String_Node_Str"",nodeGroup.getName(),nodeGroup.getInstanceNum());
              System.out.printf(""String_Node_Str"",nodeGroup.getRoles());
              printNodesInfo(nodeGroup.getInstances());
            }
          }
        }
      }
 catch (      Exception e) {
        throw e;
      }
    }
    public boolean isRefresh() throws Exception {
      try {
        cluster=clusterRestClient.get(id,false);
        if (cluster != null) {
          List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
          if (nodeGroups != null) {
            return checkOutputUpdate(nodeGroups);
          }
        }
        return false;
      }
 catch (      CliRestException expectedException) {
        cluster=null;
        return false;
      }
catch (      Exception e) {
        throw e;
      }
    }
    private void printNodesInfo(    List<NodeRead> nodes) throws Exception {
      if (nodes != null && nodes.size() > 0) {
        LinkedHashMap<String,List<String>> columnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NAME,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_IP,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_STATUS,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_TASK,Arrays.asList(""String_Node_Str""));
        CommandsUtils.printInTableFormat(columnNamesWithGetMethodNames,nodes.toArray(),Constants.OUTPUT_INDENT);
      }
 else {
        System.out.println();
      }
    }
    private boolean checkOutputUpdate(    List<NodeGroupRead> nodeGroups) throws JsonGenerationException, IOException {
      ObjectMapper mapper=new ObjectMapper();
      String ngCurrentInJson=mapper.writeValueAsString(nodeGroups);
      if (ngSnapshotInJson != null && ngSnapshotInJson.equals(ngCurrentInJson)) {
        needUpdate=false;
      }
 else {
        ngSnapshotInJson=ngCurrentInJson;
        needUpdate=true;
      }
      return needUpdate;
    }
  }
;
}","private PrettyOutput getClusterPrettyOutputCallBack(final ClusterRestClient clusterRestClient,final String id){
  return new PrettyOutput(){
    private String ngSnapshotInJson=null;
    private boolean needUpdate=true;
    private ClusterRead cluster=null;
    public void prettyOutput() throws Exception {
      try {
        if (cluster != null) {
          List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
          if (nodeGroups != null) {
            for (            NodeGroupRead nodeGroup : nodeGroups) {
              System.out.printf(""String_Node_Str"",nodeGroup.getName(),nodeGroup.getInstanceNum());
              System.out.printf(""String_Node_Str"",nodeGroup.getRoles());
              printNodesInfo(nodeGroup.getInstances());
            }
          }
        }
      }
 catch (      Exception e) {
        throw e;
      }
    }
    public boolean isRefresh(    boolean realTime) throws Exception {
      try {
        cluster=clusterRestClient.get(id,realTime);
        if (cluster != null) {
          List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
          if (nodeGroups != null) {
            return checkOutputUpdate(nodeGroups);
          }
        }
        return false;
      }
 catch (      CliRestException expectedException) {
        cluster=null;
        return false;
      }
catch (      Exception e) {
        throw e;
      }
    }
    private void printNodesInfo(    List<NodeRead> nodes) throws Exception {
      if (nodes != null && nodes.size() > 0) {
        LinkedHashMap<String,List<String>> columnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NAME,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_IP,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_STATUS,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_TASK,Arrays.asList(""String_Node_Str""));
        CommandsUtils.printInTableFormat(columnNamesWithGetMethodNames,nodes.toArray(),Constants.OUTPUT_INDENT);
      }
 else {
        System.out.println();
      }
    }
    private boolean checkOutputUpdate(    List<NodeGroupRead> nodeGroups) throws JsonGenerationException, IOException {
      ObjectMapper mapper=new ObjectMapper();
      String ngCurrentInJson=mapper.writeValueAsString(nodeGroups);
      if (ngSnapshotInJson != null && ngSnapshotInJson.equals(ngCurrentInJson)) {
        needUpdate=false;
      }
 else {
        ngSnapshotInJson=ngCurrentInJson;
        needUpdate=true;
      }
      return needUpdate;
    }
  }
;
}"
49121,"/** 
 * Check if the screen needs refresh or same as before
 */
boolean isRefresh() throws Exception ;","/** 
 * Check if the screen needs refresh or same as before
 */
boolean isRefresh(boolean realTime) throws Exception ;"
49122,"private void processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      int progress=(int)(taskRead.getProgress() * 100);
      Status taskStatus=taskRead.getStatus();
      if ((prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh()) || oldTaskStatus != taskStatus || oldProgress != progress) {
        oldTaskStatus=taskStatus;
        oldProgress=progress;
        AnsiConsole.systemInstall();
        String separator=""String_Node_Str"";
        char ESC=27;
        String clearScreen=""String_Node_Str"";
        System.out.print(ESC + separator + clearScreen);
        AnsiConsole.systemUninstall();
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskRead.getStatus() != TaskRead.Status.SUCCESS && taskRead.getStatus() != TaskRead.Status.FAILED);
    String logdir=taskRead.getWorkDir();
    String errorMsg=taskRead.getErrorMessage();
    if (taskRead.getStatus().equals(TaskRead.Status.FAILED)) {
      if (!CommandsUtils.isBlank(logdir)) {
        String outputErrorInfo=Constants.OUTPUT_LOG_INFO + logdir;
        if (errorMsg != null) {
          outputErrorInfo=errorMsg + ""String_Node_Str"" + outputErrorInfo;
        }
        throw new CliRestException(outputErrorInfo);
      }
 else       if (errorMsg != null && !errorMsg.isEmpty()) {
        throw new CliRestException(errorMsg);
      }
 else {
        throw new CliRestException(""String_Node_Str"");
      }
    }
 else     if (taskRead.getStatus().equals(TaskRead.Status.SUCCESS)) {
      if (taskRead.getType().equals(Type.VHM)) {
        if (!CommandsUtils.isBlank(logdir)) {
          System.out.println(Constants.OUTPUT_WARNING_LOG_INFO + logdir);
        }
      }
    }
  }
}","private void processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    Status taskStatus=null;
    int progress=0;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      progress=(int)(taskRead.getProgress() * 100);
      taskStatus=taskRead.getStatus();
      if ((prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(false)) || oldTaskStatus != taskStatus || oldProgress != progress) {
        oldTaskStatus=taskStatus;
        oldProgress=progress;
        clearScreen();
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskRead.getStatus() != TaskRead.Status.SUCCESS && taskRead.getStatus() != TaskRead.Status.FAILED);
    String logdir=taskRead.getWorkDir();
    String errorMsg=taskRead.getErrorMessage();
    if (taskRead.getStatus().equals(TaskRead.Status.FAILED)) {
      if (!CommandsUtils.isBlank(logdir)) {
        String outputErrorInfo=Constants.OUTPUT_LOG_INFO + logdir;
        if (errorMsg != null) {
          outputErrorInfo=errorMsg + ""String_Node_Str"" + outputErrorInfo;
        }
        throw new CliRestException(outputErrorInfo);
      }
 else       if (errorMsg != null && !errorMsg.isEmpty()) {
        throw new CliRestException(errorMsg);
      }
 else {
        throw new CliRestException(""String_Node_Str"");
      }
    }
 else     if (taskRead.getStatus().equals(TaskRead.Status.SUCCESS)) {
      if (taskRead.getType().equals(Type.VHM)) {
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(true)) {
          clearScreen();
          System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
          if (prettyOutput != null && prettyOutput.length > 0) {
            prettyOutput[0].prettyOutput();
          }
        }
        if (!CommandsUtils.isBlank(logdir)) {
          System.out.println(Constants.OUTPUT_WARNING_LOG_INFO + logdir);
        }
      }
    }
  }
}"
49123,"@SuppressWarnings(""String_Node_Str"") public File getWorkDir(){
  File path=null;
  Type type=getType();
  if (type.equals(type.INNER)) {
    if (getId() == null) {
      return null;
    }
    path=new File(taskRootDir,getId().toString());
    if (!path.exists()) {
      path.mkdirs();
    }
  }
 else   if (type.equals(type.VHM)) {
    path=new File(taskRootDir,serengetiLog);
    AuAssert.check(path.exists(),""String_Node_Str"" + serengetiLog + ""String_Node_Str"");
  }
  return path;
}","@SuppressWarnings(""String_Node_Str"") public File getWorkDir(){
  File path=null;
  Type type=getType();
  if (type.equals(type.INNER)) {
    if (getId() == null) {
      return null;
    }
    path=new File(taskRootDir,getId().toString());
    if (!path.exists()) {
      path.mkdirs();
    }
  }
 else   if (type.equals(type.VHM)) {
    String serengetiLogPath=""String_Node_Str"";
    if (!CommonUtil.isBlank(taskRootDirStr)) {
      serengetiLogPath=taskRootDirStr + ""String_Node_Str"" + serengetiLog;
    }
 else {
      serengetiLogPath=System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + serengetiLog;
    }
    logger.info(""String_Node_Str"" + serengetiLogPath);
    path=new File(serengetiLogPath);
    AuAssert.check(path.exists(),""String_Node_Str"" + serengetiLog + ""String_Node_Str"");
  }
  return path;
}"
49124,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void limitCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final int activeComputeNodeNum){
  try {
    ClusterRead cluster=restClient.get(clusterName,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return;
    }
    if (!cluster.validateLimit(nodeGroupName)) {
      return;
    }
    restClient.limitCluster(clusterName,nodeGroupName,activeComputeNodeNum);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OP_ADJUSTMENT,null,Constants.OUTPUT_OP_ADJUSTMENT_SUCCEEDED);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void limitCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final int activeComputeNodeNum){
}"
49125,"private void processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      int progress=(int)(taskRead.getProgress() * 100);
      Status taskStatus=taskRead.getStatus();
      if ((prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh()) || oldTaskStatus != taskStatus || oldProgress != progress) {
        oldTaskStatus=taskStatus;
        oldProgress=progress;
        AnsiConsole.systemInstall();
        String separator=""String_Node_Str"";
        char ESC=27;
        String clearScreen=""String_Node_Str"";
        System.out.print(ESC + separator + clearScreen);
        AnsiConsole.systemUninstall();
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskRead.getStatus() != TaskRead.Status.SUCCESS && taskRead.getStatus() != TaskRead.Status.FAILED);
    if (taskRead.getStatus().equals(TaskRead.Status.FAILED)) {
      String logdir=taskRead.getWorkDir();
      String errorMsg=taskRead.getErrorMessage();
      if (logdir != null && !logdir.isEmpty()) {
        String outputErrorInfo=Constants.OUTPUT_LOG_INFO + logdir;
        if (errorMsg != null) {
          outputErrorInfo=errorMsg + ""String_Node_Str"" + outputErrorInfo;
        }
        throw new CliRestException(outputErrorInfo);
      }
 else       if (errorMsg != null && !errorMsg.isEmpty()) {
        throw new CliRestException(errorMsg);
      }
 else {
        throw new CliRestException(""String_Node_Str"");
      }
    }
  }
}","private void processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      int progress=(int)(taskRead.getProgress() * 100);
      Status taskStatus=taskRead.getStatus();
      if ((prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh()) || oldTaskStatus != taskStatus || oldProgress != progress) {
        oldTaskStatus=taskStatus;
        oldProgress=progress;
        AnsiConsole.systemInstall();
        String separator=""String_Node_Str"";
        char ESC=27;
        String clearScreen=""String_Node_Str"";
        System.out.print(ESC + separator + clearScreen);
        AnsiConsole.systemUninstall();
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskRead.getStatus() != TaskRead.Status.SUCCESS && taskRead.getStatus() != TaskRead.Status.FAILED);
    String logdir=taskRead.getWorkDir();
    String errorMsg=taskRead.getErrorMessage();
    if (taskRead.getStatus().equals(TaskRead.Status.FAILED)) {
      if (!CommandsUtils.isBlank(logdir)) {
        String outputErrorInfo=Constants.OUTPUT_LOG_INFO + logdir;
        if (errorMsg != null) {
          outputErrorInfo=errorMsg + ""String_Node_Str"" + outputErrorInfo;
        }
        throw new CliRestException(outputErrorInfo);
      }
 else       if (errorMsg != null && !errorMsg.isEmpty()) {
        throw new CliRestException(errorMsg);
      }
 else {
        throw new CliRestException(""String_Node_Str"");
      }
    }
 else     if (taskRead.getStatus().equals(TaskRead.Status.SUCCESS)) {
      if (taskRead.getType().equals(Type.VHM)) {
        if (!CommandsUtils.isBlank(logdir)) {
          System.out.println(Constants.OUTPUT_WARNING_LOG_INFO + logdir);
        }
      }
    }
  }
}"
49126,"@Test public void testClusterCreateOutput() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.ACCEPTED,""String_Node_Str"",""String_Node_Str"");
  TaskRead task=new TaskRead();
  task.setId(12l);
  task.setProgress(0.8);
  task.setStatus(Status.RUNNING);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  ClusterRead cluster=new ClusterRead();
  List<NodeGroupRead> nodeGroups=new ArrayList<NodeGroupRead>();
  NodeGroupRead workerGroup=new NodeGroupRead();
  workerGroup.setName(""String_Node_Str"");
  workerGroup.setInstanceNum(1);
  List<NodeRead> instances=new ArrayList<NodeRead>();
  NodeRead instance1=new NodeRead();
  instance1.setName(""String_Node_Str"");
  instance1.setStatus(""String_Node_Str"");
  instance1.setAction(""String_Node_Str"");
  instances.add(instance1);
  workerGroup.setInstances(instances);
  nodeGroups.add(workerGroup);
  cluster.setNodeGroups(nodeGroups);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  task.setProgress(1.0);
  task.setStatus(Status.SUCCESS);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  instance1.setStatus(""String_Node_Str"");
  instance1.setIp(""String_Node_Str"");
  instance1.setAction(null);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testClusterCreateOutput() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.ACCEPTED,""String_Node_Str"",""String_Node_Str"");
  TaskRead task=new TaskRead();
  task.setId(12l);
  task.setType(Type.INNER);
  task.setProgress(0.8);
  task.setStatus(Status.RUNNING);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  ClusterRead cluster=new ClusterRead();
  List<NodeGroupRead> nodeGroups=new ArrayList<NodeGroupRead>();
  NodeGroupRead workerGroup=new NodeGroupRead();
  workerGroup.setName(""String_Node_Str"");
  workerGroup.setInstanceNum(1);
  List<NodeRead> instances=new ArrayList<NodeRead>();
  NodeRead instance1=new NodeRead();
  instance1.setName(""String_Node_Str"");
  instance1.setStatus(""String_Node_Str"");
  instance1.setAction(""String_Node_Str"");
  instances.add(instance1);
  workerGroup.setInstances(instances);
  nodeGroups.add(workerGroup);
  cluster.setNodeGroups(nodeGroups);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  task.setProgress(1.0);
  task.setStatus(Status.SUCCESS);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  instance1.setStatus(""String_Node_Str"");
  instance1.setIp(""String_Node_Str"");
  instance1.setAction(null);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,null,null,false,false,false);
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
}"
49127,"public TaskRead(Long id,Status status,Double progress,String errorMessage,String workDir){
  this.id=id;
  this.status=status;
  this.progress=progress;
  this.errorMessage=errorMessage;
  this.workDir=workDir;
}","public TaskRead(Long id,Status status,Type type,Double progress,String errorMessage,String workDir){
  this.id=id;
  this.status=status;
  this.type=type;
  this.progress=progress;
  this.errorMessage=errorMessage;
  this.workDir=workDir;
}"
49128,"public File getWorkDir(){
  if (getId() == null) {
    return null;
  }
  File path=new File(taskRootDir,getId().toString());
  if (!path.exists()) {
    path.mkdirs();
  }
  return path;
}","@SuppressWarnings(""String_Node_Str"") public File getWorkDir(){
  File path=null;
  Type type=getType();
  if (type.equals(type.INNER)) {
    if (getId() == null) {
      return null;
    }
    path=new File(taskRootDir,getId().toString());
    if (!path.exists()) {
      path.mkdirs();
    }
  }
 else   if (type.equals(type.VHM)) {
    path=new File(taskRootDir,serengetiLog);
    AuAssert.check(path.exists(),""String_Node_Str"" + serengetiLog + ""String_Node_Str"");
  }
  return path;
}"
49129,"public TaskRead getTaskById(final Long taskId){
  TaskEntity entity=DAL.inRoTransactionDo(new Saveable<TaskEntity>(){
    @Override public TaskEntity body() throws Exception {
      return DAL.findById(TaskEntity.class,taskId);
    }
  }
);
  if (entity != null) {
    return new TaskRead(entity.getId(),entity.getStatus(),entity.getProgress(),entity.getErrorMessage(),entity.getWorkDir().getAbsolutePath());
  }
  return null;
}","public TaskRead getTaskById(final Long taskId){
  TaskEntity entity=DAL.inRoTransactionDo(new Saveable<TaskEntity>(){
    @Override public TaskEntity body() throws Exception {
      return DAL.findById(TaskEntity.class,taskId);
    }
  }
);
  if (entity != null) {
    return new TaskRead(entity.getId(),entity.getStatus(),entity.getType(),entity.getProgress(),entity.getErrorMessage(),entity.getWorkDir().getAbsolutePath());
  }
  return null;
}"
49130,"public List<TaskRead> getTasks(){
  List<TaskEntity> taskEntities=DAL.inRoTransactionDo(new Saveable<List<TaskEntity>>(){
    @Override public List<TaskEntity> body() throws Exception {
      return DAL.findAll(TaskEntity.class);
    }
  }
);
  List<TaskRead> tasks=new ArrayList<TaskRead>();
  for (  TaskEntity entity : taskEntities) {
    tasks.add(new TaskRead(entity.getId(),entity.getStatus(),entity.getProgress(),entity.getErrorMessage(),entity.getWorkDir().getAbsolutePath()));
  }
  return tasks;
}","public List<TaskRead> getTasks(){
  List<TaskEntity> taskEntities=DAL.inRoTransactionDo(new Saveable<List<TaskEntity>>(){
    @Override public List<TaskEntity> body() throws Exception {
      return DAL.findAll(TaskEntity.class);
    }
  }
);
  List<TaskRead> tasks=new ArrayList<TaskRead>();
  for (  TaskEntity entity : taskEntities) {
    tasks.add(new TaskRead(entity.getId(),entity.getStatus(),entity.getType(),entity.getProgress(),entity.getErrorMessage(),entity.getWorkDir().getAbsolutePath()));
  }
  return tasks;
}"
49131,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT) @ResponseStatus(HttpStatus.ACCEPTED) public void limitCluster(@PathVariable(""String_Node_Str"") String clusterName,@RequestBody VHMRequestBody requestBody,HttpServletRequest request,HttpServletResponse response) throws Exception {
  int activeComputeNodeNum=requestBody.getActiveComputeNodeNum();
  String groupName=requestBody.getNodeGroupName();
  Long taskId=clusterMgr.limitCluster(clusterName,groupName,activeComputeNodeNum);
  redirectRequest(taskId,request,response);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT) @ResponseStatus(HttpStatus.ACCEPTED) public void limitCluster(@PathVariable(""String_Node_Str"") String clusterName,@RequestBody VHMRequestBody requestBody,HttpServletRequest request,HttpServletResponse response) throws Exception {
  int activeComputeNodeNum=requestBody.getActiveComputeNodeNum();
  String groupName=requestBody.getNodeGroupName();
  if (activeComputeNodeNum < -1) {
    logger.error(""String_Node_Str"" + activeComputeNodeNum + ""String_Node_Str"");
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",String.valueOf(activeComputeNodeNum));
  }
  Long taskId=clusterMgr.limitCluster(clusterName,groupName,activeComputeNodeNum);
  redirectRequest(taskId,request,response);
}"
49132,"public ResourcePoolRead toRest(){
  ResourcePoolRead read=new ResourcePoolRead();
  read.setRpName(this.getName());
  read.setRpVsphereName(this.getVcResourcePool());
  read.setVcCluster(this.getVcCluster());
  Set<HadoopNodeEntity> nodes=this.getHadoopNodes();
  if (nodes == null || nodes.isEmpty()) {
    return read;
  }
  List<NodeRead> nodeReads=new ArrayList<NodeRead>();
  for (  HadoopNodeEntity node : nodes) {
    NodeRead nodeRead=node.toNodeRead();
    nodeReads.add(nodeRead);
  }
  Collections.sort(nodeReads,new Comparator<NodeRead>(){
    public int compare(    NodeRead arg0,    NodeRead arg1){
      return arg0.getName().compareTo(arg1.getName());
    }
  }
);
  read.setNodes(nodeReads.toArray(new NodeRead[]{}));
  return read;
}","public ResourcePoolRead toRest(){
  ResourcePoolRead read=new ResourcePoolRead();
  read.setRpName(this.getName());
  read.setRpVsphereName(this.getVcResourcePool());
  read.setVcCluster(this.getVcCluster());
  Set<HadoopNodeEntity> nodes=this.getHadoopNodes();
  if (nodes == null || nodes.isEmpty()) {
    return read;
  }
  List<NodeRead> nodeReads=new ArrayList<NodeRead>();
  for (  HadoopNodeEntity node : nodes) {
    NodeRead nodeRead=node.toNodeRead();
    nodeReads.add(nodeRead);
  }
  Collections.sort(nodeReads,new Comparator<NodeRead>(){
    public int compare(    NodeRead arg0,    NodeRead arg1){
      return arg0.getName().compareTo(arg1.getName());
    }
  }
);
  read.setNodes(nodeReads.toArray(new NodeRead[nodeReads.size()]));
  return read;
}"
49133,"private void convertClusterConfig(ClusterEntity clusterEntity,ClusterCreate clusterConfig){
  logger.debug(""String_Node_Str"" + clusterEntity.getName());
  CommonClusterExpandPolicy.expandDistro(clusterEntity,clusterConfig,distroMgr);
  clusterConfig.setTopologyPolicy(clusterEntity.getTopologyPolicy());
  Map<String,String> hostToRackMap=rackInfoMgr.exportHostRackMap();
  if ((clusterConfig.getTopologyPolicy() == TopologyType.RACK_AS_RACK || clusterConfig.getTopologyPolicy() == TopologyType.HVE) && hostToRackMap.isEmpty()) {
    logger.error(""String_Node_Str"");
    throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterConfig.getTopologyPolicy(),""String_Node_Str"");
  }
  clusterConfig.setHostToRackMap(hostToRackMap);
  clusterConfig.setTemplateId(templateId);
  if (clusterEntity.getVcRpNames() != null) {
    logger.debug(""String_Node_Str"");
    String[] rpNames=clusterEntity.getVcRpNameList().toArray(new String[]{});
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    clusterConfig.setVcClusters(vcClusters);
    clusterConfig.setRpNames(clusterEntity.getVcRpNameList());
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  if (clusterEntity.getVcDatastoreNameList() != null) {
    logger.debug(""String_Node_Str"");
    Set<String> sharedPattern=datastoreMgr.getSharedDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setSharedPattern(sharedPattern);
    Set<String> localPattern=datastoreMgr.getLocalDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setLocalPattern(localPattern);
    clusterConfig.setDsNames(clusterEntity.getVcDatastoreNameList());
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  List<NodeGroupCreate> nodeGroups=new ArrayList<NodeGroupCreate>();
  Set<NodeGroupEntity> nodeGroupEntities=clusterEntity.getNodeGroups();
  long instanceNum=0;
  for (  NodeGroupEntity ngEntity : nodeGroupEntities) {
    NodeGroupCreate group=convertNodeGroups(clusterEntity.getDistro(),ngEntity,clusterEntity.getName());
    nodeGroups.add(group);
    instanceNum+=group.getInstanceNum();
  }
  sortGroups(nodeGroups);
  clusterConfig.setNodeGroups(nodeGroups.toArray(new NodeGroupCreate[]{}));
  NetworkEntity networkEntity=clusterEntity.getNetwork();
  List<NetworkAdd> networking=new ArrayList<NetworkAdd>();
  NetworkAdd network=new NetworkAdd();
  network.setPortGroup(networkEntity.getPortGroup());
  network.setDhcp(networkEntity.getAllocType() == NetworkEntity.AllocType.DHCP);
  if (!network.isDhcp()) {
    logger.debug(""String_Node_Str"");
    List<IpBlockEntity> ipBlockEntities=networkMgr.getAllocatedIpBlocks(networkEntity,clusterEntity.getId());
    long allocatedIpNum=IpBlockEntity.count(ipBlockEntities);
    if (allocatedIpNum < instanceNum) {
      long newNum=instanceNum - allocatedIpNum;
      List<IpBlockEntity> newIpBlockEntities=networkMgr.alloc(networkEntity,clusterEntity.getId(),newNum);
      ipBlockEntities.addAll(newIpBlockEntities);
    }
    network.setDns1(networkEntity.getDns1());
    network.setDns2(networkEntity.getDns2());
    network.setGateway(networkEntity.getGateway());
    network.setNetmask(networkEntity.getNetmask());
    List<IpBlock> ips=new ArrayList<IpBlock>();
    for (    IpBlockEntity ipBlockEntity : ipBlockEntities) {
      IpBlock ip=new IpBlock();
      ip.setBeginIp(ipBlockEntity.getBeginAddress());
      ip.setEndIp(ipBlockEntity.getEndAddress());
      ips.add(ip);
    }
    network.setIp(ips);
  }
  networking.add(network);
  clusterConfig.setNetworking(networking);
  clusterConfig.setNetworkName(networkEntity.getName());
  if (clusterEntity.getHadoopConfig() != null) {
    Map hadoopConfig=(new Gson()).fromJson(clusterEntity.getHadoopConfig(),Map.class);
    clusterConfig.setConfiguration((Map<String,Object>)hadoopConfig);
  }
}","private void convertClusterConfig(ClusterEntity clusterEntity,ClusterCreate clusterConfig){
  logger.debug(""String_Node_Str"" + clusterEntity.getName());
  CommonClusterExpandPolicy.expandDistro(clusterEntity,clusterConfig,distroMgr);
  clusterConfig.setTopologyPolicy(clusterEntity.getTopologyPolicy());
  Map<String,String> hostToRackMap=rackInfoMgr.exportHostRackMap();
  if ((clusterConfig.getTopologyPolicy() == TopologyType.RACK_AS_RACK || clusterConfig.getTopologyPolicy() == TopologyType.HVE) && hostToRackMap.isEmpty()) {
    logger.error(""String_Node_Str"");
    throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterConfig.getTopologyPolicy(),""String_Node_Str"");
  }
  clusterConfig.setHostToRackMap(hostToRackMap);
  clusterConfig.setTemplateId(templateId);
  if (clusterEntity.getVcRpNames() != null) {
    logger.debug(""String_Node_Str"");
    String[] rpNames=clusterEntity.getVcRpNameList().toArray(new String[clusterEntity.getVcRpNameList().size()]);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    clusterConfig.setVcClusters(vcClusters);
    clusterConfig.setRpNames(clusterEntity.getVcRpNameList());
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  if (clusterEntity.getVcDatastoreNameList() != null) {
    logger.debug(""String_Node_Str"");
    Set<String> sharedPattern=datastoreMgr.getSharedDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setSharedPattern(sharedPattern);
    Set<String> localPattern=datastoreMgr.getLocalDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setLocalPattern(localPattern);
    clusterConfig.setDsNames(clusterEntity.getVcDatastoreNameList());
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  List<NodeGroupCreate> nodeGroups=new ArrayList<NodeGroupCreate>();
  Set<NodeGroupEntity> nodeGroupEntities=clusterEntity.getNodeGroups();
  long instanceNum=0;
  for (  NodeGroupEntity ngEntity : nodeGroupEntities) {
    NodeGroupCreate group=convertNodeGroups(clusterEntity.getDistro(),ngEntity,clusterEntity.getName());
    nodeGroups.add(group);
    instanceNum+=group.getInstanceNum();
  }
  sortGroups(nodeGroups);
  clusterConfig.setNodeGroups(nodeGroups.toArray(new NodeGroupCreate[nodeGroups.size()]));
  NetworkEntity networkEntity=clusterEntity.getNetwork();
  List<NetworkAdd> networking=new ArrayList<NetworkAdd>();
  NetworkAdd network=new NetworkAdd();
  network.setPortGroup(networkEntity.getPortGroup());
  network.setDhcp(networkEntity.getAllocType() == NetworkEntity.AllocType.DHCP);
  if (!network.isDhcp()) {
    logger.debug(""String_Node_Str"");
    List<IpBlockEntity> ipBlockEntities=networkMgr.getAllocatedIpBlocks(networkEntity,clusterEntity.getId());
    long allocatedIpNum=IpBlockEntity.count(ipBlockEntities);
    if (allocatedIpNum < instanceNum) {
      long newNum=instanceNum - allocatedIpNum;
      List<IpBlockEntity> newIpBlockEntities=networkMgr.alloc(networkEntity,clusterEntity.getId(),newNum);
      ipBlockEntities.addAll(newIpBlockEntities);
    }
    network.setDns1(networkEntity.getDns1());
    network.setDns2(networkEntity.getDns2());
    network.setGateway(networkEntity.getGateway());
    network.setNetmask(networkEntity.getNetmask());
    List<IpBlock> ips=new ArrayList<IpBlock>();
    for (    IpBlockEntity ipBlockEntity : ipBlockEntities) {
      IpBlock ip=new IpBlock();
      ip.setBeginIp(ipBlockEntity.getBeginAddress());
      ip.setEndIp(ipBlockEntity.getEndAddress());
      ips.add(ip);
    }
    network.setIp(ips);
  }
  networking.add(network);
  clusterConfig.setNetworking(networking);
  clusterConfig.setNetworkName(networkEntity.getName());
  if (clusterEntity.getHadoopConfig() != null) {
    Map hadoopConfig=(new Gson()).fromJson(clusterEntity.getHadoopConfig(),Map.class);
    clusterConfig.setConfiguration((Map<String,Object>)hadoopConfig);
  }
}"
49134,"private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,EnumSet<HadoopRole> allRoles,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups;
  nodeGroups=new HashSet<NodeGroupEntity>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,allRoles,group,distro,validateWhiteList);
    groupEntity.setVmFolderPath(clusterEntity);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
    }
  }
  return nodeGroups;
}","private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,EnumSet<HadoopRole> allRoles,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups;
  nodeGroups=new HashSet<NodeGroupEntity>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,allRoles,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
    }
  }
  return nodeGroups;
}"
49135,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  roles.addAll(group.getRoles());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(roles));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  boolean removeIt=validateGroupInstanceNum(clusterEntity.getName(),groupType,group,allRoles);
  if (removeIt) {
    return null;
  }
  allRoles.addAll(enumRoles);
  groupEntity.setCluster(clusterEntity);
  groupEntity.setCpuNum(group.getCpuNum());
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new TreeSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  if (group.getStorage() != null) {
    groupEntity.setStorageSize(group.getStorage().getSizeGB());
    if (group.getStorage().getType() != null) {
      if (group.getStorage().getType().equals(DatastoreType.LOCAL.name())) {
        groupEntity.setStorageType(DatastoreType.LOCAL);
      }
 else {
        groupEntity.setStorageType(DatastoreType.SHARED);
      }
    }
    groupEntity.setVcDatastoreNameList(group.getStorage().getDsNames());
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
  Set<String> localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  roles.addAll(group.getRoles());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(roles));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  boolean removeIt=validateGroupInstanceNum(clusterEntity.getName(),groupType,group,allRoles);
  if (removeIt) {
    return null;
  }
  allRoles.addAll(enumRoles);
  groupEntity.setCluster(clusterEntity);
  groupEntity.setCpuNum(group.getCpuNum());
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new TreeSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  if (group.getStorage() != null) {
    groupEntity.setStorageSize(group.getStorage().getSizeGB());
    if (group.getStorage().getType() != null) {
      if (group.getStorage().getType().equals(DatastoreType.LOCAL.name())) {
        groupEntity.setStorageType(DatastoreType.LOCAL);
      }
 else {
        groupEntity.setStorageType(DatastoreType.SHARED);
      }
    }
    groupEntity.setVcDatastoreNameList(group.getStorage().getDsNames());
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
  Set<String> localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
49136,"private String readDistroManifest() throws IOException {
  URL manifestUrl=new URL(distrosManifestUrl);
  BufferedReader in=new BufferedReader(new InputStreamReader(manifestUrl.openStream()));
  StringBuffer sb=new StringBuffer();
  String line;
  while ((line=in.readLine()) != null) {
    sb.append(line);
  }
  in.close();
  return sb.toString();
}","private String readDistroManifest() throws IOException {
  URL manifestUrl=new URL(distrosManifestUrl);
  BufferedReader in=null;
  try {
    in=new BufferedReader(new InputStreamReader(manifestUrl.openStream()));
    StringBuffer sb=new StringBuffer();
    String line;
    while ((line=in.readLine()) != null) {
      sb.append(line);
    }
    return sb.toString();
  }
  finally {
    if (in != null) {
      in.close();
    }
  }
}"
49137,"/** 
 * Generate a weak (non-standard) UUID string based on current time, parameters and pseudo random number.
 * @param params list of parameters
 * @return UUID string
 */
private static String generateCookie(Object... params){
  long timestamp=System.currentTimeMillis();
  long rand=new Random().nextInt();
  long hash=0;
  for (  Object p : params) {
    if (p != null) {
      hash^=p.hashCode();
    }
  }
  return new UUID((hash << 32) | (rand & 0xFFFFFFFFL),timestamp).toString();
}","/** 
 * Generate a weak (non-standard) UUID string based on current time, parameters and pseudo random number.
 * @param params list of parameters
 * @return UUID string
 */
private static String generateCookie(Object... params){
  long timestamp=System.currentTimeMillis();
  long rand=random.nextInt();
  long hash=0;
  for (  Object p : params) {
    if (p != null) {
      hash^=p.hashCode();
    }
  }
  return new UUID((hash << 32) | (rand & 0xFFFFFFFFL),timestamp).toString();
}"
49138,"public Set<String> getDatastoresByName(String name){
  List<VcDataStoreEntity> datastores=VcDataStoreEntity.findByName(name);
  if (datastores == null) {
    logger.warn(""String_Node_Str"" + name);
  }
  return getDatastorePattern(datastores);
}","public Set<String> getDatastoresByName(String name){
  List<VcDataStoreEntity> datastores=VcDataStoreEntity.findByName(name);
  return getDatastorePattern(datastores);
}"
49139,"private Set<String> getAllDatastoresByTypeAndName(DatastoreType type,String name){
  List<VcDataStoreEntity> datastores=VcDataStoreEntity.findByNameAndType(type,name);
  if (datastores == null) {
    logger.warn(""String_Node_Str"" + name + ""String_Node_Str""+ type);
  }
  Set<String> result=getDatastorePattern(datastores);
  logger.debug(""String_Node_Str"" + type + ""String_Node_Str""+ name+ result);
  return result;
}","private Set<String> getAllDatastoresByTypeAndName(DatastoreType type,String name){
  List<VcDataStoreEntity> datastores=VcDataStoreEntity.findByNameAndType(type,name);
  Set<String> result=getDatastorePattern(datastores);
  logger.debug(""String_Node_Str"" + type + ""String_Node_Str""+ name+ result);
  return result;
}"
49140,"public List<VcCluster> getVcResourcePoolByNameList(String[] names){
  logger.debug(""String_Node_Str"" + names);
  if (names == null || names.length == 0) {
    return null;
  }
  Map<String,VcCluster> clusterMap=new HashMap<String,VcCluster>();
  for (  String name : names) {
    VcResourcePoolEntity rpForName=VcResourcePoolEntity.findByName(name);
    if (rpForName == null) {
      logger.warn(""String_Node_Str"" + name + ""String_Node_Str"");
      continue;
    }
    combineCluster(clusterMap,rpForName);
  }
  if (clusterMap.values().isEmpty()) {
    throw VcProviderException.NO_RESOURCE_POOL_FOUND(names);
  }
  List<VcCluster> result=new ArrayList<VcCluster>();
  result.addAll(clusterMap.values());
  logger.debug(""String_Node_Str"" + result);
  return result;
}","public List<VcCluster> getVcResourcePoolByNameList(String[] names){
  logger.debug(""String_Node_Str"" + Arrays.toString(names));
  if (names == null || names.length == 0) {
    return null;
  }
  Map<String,VcCluster> clusterMap=new HashMap<String,VcCluster>();
  for (  String name : names) {
    VcResourcePoolEntity rpForName=VcResourcePoolEntity.findByName(name);
    if (rpForName == null) {
      logger.warn(""String_Node_Str"" + name + ""String_Node_Str"");
      continue;
    }
    combineCluster(clusterMap,rpForName);
  }
  if (clusterMap.values().isEmpty()) {
    throw VcProviderException.NO_RESOURCE_POOL_FOUND(names);
  }
  List<VcCluster> result=new ArrayList<VcCluster>();
  result.addAll(clusterMap.values());
  logger.debug(""String_Node_Str"" + result);
  return result;
}"
49141,"@Override public Map<String,Object> work(boolean mqEnabled,TaskEntity taskEntity,boolean successed,String errorMessage,Logger logger) throws IOException {
  Map<String,Object> result=new HashMap<String,Object>();
  String[] cmdArray;
  if (logger.isInfoEnabled()) {
    cmdArray=new String[taskEntity.getCmdArray().length + 1];
    int i;
    for (i=0; i < taskEntity.getCmdArray().length; ++i) {
      cmdArray[i]=taskEntity.getCmdArray()[i];
    }
    cmdArray[i]=logger.isDebugEnabled() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else {
    cmdArray=taskEntity.getCmdArray();
  }
  Process proc=Runtime.getRuntime().exec(cmdArray,null,taskEntity.getWorkDir());
  Thread stdoutReaperThread=new Thread(new StreamReaper(proc.getInputStream(),new File(taskEntity.getWorkDir(),TaskManager.STDOUT_FILENAME)));
  Thread stderrReaperThread=new Thread(new StreamReaper(proc.getErrorStream(),new File(taskEntity.getWorkDir(),TaskManager.STDERR_FILENAME)));
  MessageProcessor messageProcessor=null;
  Thread messageProcessorThread=null;
  if (mqEnabled) {
    String routeKey=taskEntity.getMessageRouteKey();
    messageProcessor=new MessageProcessor(taskEntity.getId(),ConfigInfo.getMqServerHost(),ConfigInfo.getMqServerPort(),ConfigInfo.getMqServerUsername(),ConfigInfo.getMqServerPassword(),ConfigInfo.getMqExchangeName(),routeKey,routeKey,false);
    messageProcessorThread=new Thread(messageProcessor);
    messageProcessorThread.setDaemon(true);
    messageProcessorThread.start();
  }
  stdoutReaperThread.setDaemon(true);
  stderrReaperThread.setDaemon(true);
  stdoutReaperThread.start();
  stderrReaperThread.start();
  boolean exitSuccess=true;
  while (true) {
    try {
      int exitValue=proc.waitFor();
      if (exitValue == 0) {
        successed=true;
        logger.info(""String_Node_Str"" + taskEntity.getId() + ""String_Node_Str"");
      }
 else {
        logger.error(""String_Node_Str"" + taskEntity.getId() + ""String_Node_Str""+ exitValue);
      }
      break;
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"",e);
      exitSuccess=kill(proc,logger);
      if (mqEnabled) {
        logger.warn(""String_Node_Str"",e);
        messageProcessor.forceStopNow();
      }
      break;
    }
  }
  try {
    logger.info(""String_Node_Str"" + taskEntity.getId());
    if (mqEnabled) {
      messageProcessor.forceStop();
      try {
        messageProcessorThread.join();
      }
 catch (      InterruptedException e) {
        logger.warn(""String_Node_Str"",e);
        if (mqEnabled) {
          messageProcessor.forceStopNow();
          messageProcessorThread.join();
        }
      }
    }
    if (exitSuccess) {
      stdoutReaperThread.join();
      stderrReaperThread.join();
    }
 else {
      logger.error(""String_Node_Str"" + taskEntity.getCmdArray());
    }
    logger.info(""String_Node_Str"" + taskEntity.getId());
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
  }
  if (mqEnabled) {
    successed=messageProcessor.isSuccess();
    if (!successed) {
      errorMessage=messageProcessor.getErrorMessage();
    }
  }
  result.put(""String_Node_Str"",successed);
  result.put(""String_Node_Str"",errorMessage);
  return result;
}","@Override public Map<String,Object> work(boolean mqEnabled,TaskEntity taskEntity,boolean successed,String errorMessage,Logger logger) throws IOException {
  Map<String,Object> result=new HashMap<String,Object>();
  String[] cmdArray;
  if (logger.isInfoEnabled()) {
    cmdArray=new String[taskEntity.getCmdArray().length + 1];
    int i;
    for (i=0; i < taskEntity.getCmdArray().length; ++i) {
      cmdArray[i]=taskEntity.getCmdArray()[i];
    }
    cmdArray[i]=logger.isDebugEnabled() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else {
    cmdArray=taskEntity.getCmdArray();
  }
  Process proc=Runtime.getRuntime().exec(cmdArray,null,taskEntity.getWorkDir());
  Thread stdoutReaperThread=new Thread(new StreamReaper(proc.getInputStream(),new File(taskEntity.getWorkDir(),TaskManager.STDOUT_FILENAME)));
  Thread stderrReaperThread=new Thread(new StreamReaper(proc.getErrorStream(),new File(taskEntity.getWorkDir(),TaskManager.STDERR_FILENAME)));
  MessageProcessor messageProcessor=null;
  Thread messageProcessorThread=null;
  if (mqEnabled) {
    String routeKey=taskEntity.getMessageRouteKey();
    messageProcessor=new MessageProcessor(taskEntity.getId(),ConfigInfo.getMqServerHost(),ConfigInfo.getMqServerPort(),ConfigInfo.getMqServerUsername(),ConfigInfo.getMqServerPassword(),ConfigInfo.getMqExchangeName(),routeKey,routeKey,false);
    messageProcessorThread=new Thread(messageProcessor);
    messageProcessorThread.setDaemon(true);
    messageProcessorThread.start();
  }
  stdoutReaperThread.setDaemon(true);
  stderrReaperThread.setDaemon(true);
  stdoutReaperThread.start();
  stderrReaperThread.start();
  boolean exitSuccess=true;
  while (true) {
    try {
      int exitValue=proc.waitFor();
      if (exitValue == 0) {
        successed=true;
        logger.info(""String_Node_Str"" + taskEntity.getId() + ""String_Node_Str"");
      }
 else {
        logger.error(""String_Node_Str"" + taskEntity.getId() + ""String_Node_Str""+ exitValue);
      }
      break;
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"",e);
      exitSuccess=kill(proc,logger);
      if (mqEnabled) {
        logger.warn(""String_Node_Str"",e);
        messageProcessor.forceStopNow();
      }
      break;
    }
  }
  try {
    logger.info(""String_Node_Str"" + taskEntity.getId());
    if (mqEnabled) {
      messageProcessor.forceStop();
      try {
        messageProcessorThread.join();
      }
 catch (      InterruptedException e) {
        logger.warn(""String_Node_Str"",e);
        if (mqEnabled) {
          messageProcessor.forceStopNow();
          messageProcessorThread.join();
        }
      }
    }
    if (exitSuccess) {
      stdoutReaperThread.join();
      stderrReaperThread.join();
    }
 else {
      logger.error(""String_Node_Str"" + Arrays.toString(taskEntity.getCmdArray()));
    }
    logger.info(""String_Node_Str"" + taskEntity.getId());
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
  }
  if (mqEnabled) {
    successed=messageProcessor.isSuccess();
    if (!successed) {
      errorMessage=messageProcessor.getErrorMessage();
    }
  }
  result.put(""String_Node_Str"",successed);
  result.put(""String_Node_Str"",errorMessage);
  return result;
}"
49142,"/** 
 * Kill a Linux process, not portable
 * @param pid
 */
private boolean kill(Process proc,Logger logger){
  try {
    if (isUnix()) {
      Field field=proc.getClass().getDeclaredField(""String_Node_Str"");
      field.setAccessible(true);
      Integer pid=(Integer)field.get(proc);
      String killCmd=Configuration.getString(""String_Node_Str"");
      String[] cmdArrayKill={killCmd,pid.toString()};
      Process procKill=Runtime.getRuntime().exec(cmdArrayKill);
      if (ConfigInfo.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + killCmd + ""String_Node_Str""+ pid);
        BufferedReader bufInStream=new BufferedReader(new InputStreamReader(procKill.getInputStream()));
        String line;
        while ((line=bufInStream.readLine()) != null) {
          logger.debug(line);
        }
        bufInStream.close();
        logger.debug(""String_Node_Str"" + killCmd + ""String_Node_Str""+ pid);
        bufInStream=new BufferedReader(new InputStreamReader(procKill.getErrorStream()));
        while ((line=bufInStream.readLine()) != null) {
          logger.debug(line);
        }
        bufInStream.close();
      }
      int exit=procKill.waitFor();
      logger.info(""String_Node_Str"" + exit);
      if (exit == 0) {
        return true;
      }
    }
 else {
      logger.warn(""String_Node_Str"");
      ;
    }
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"" + proc,t);
  }
  return false;
}","/** 
 * Kill a Linux process, not portable
 * @param pid
 */
private boolean kill(Process proc,Logger logger){
  BufferedReader bufInStream=null;
  BufferedReader bufErrStream=null;
  try {
    if (isUnix()) {
      Field field=proc.getClass().getDeclaredField(""String_Node_Str"");
      field.setAccessible(true);
      Integer pid=(Integer)field.get(proc);
      String killCmd=Configuration.getString(""String_Node_Str"");
      String[] cmdArrayKill={killCmd,pid.toString()};
      Process procKill=Runtime.getRuntime().exec(cmdArrayKill);
      if (ConfigInfo.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + killCmd + ""String_Node_Str""+ pid);
        bufInStream=new BufferedReader(new InputStreamReader(procKill.getInputStream()));
        String line;
        while ((line=bufInStream.readLine()) != null) {
          logger.debug(line);
        }
        logger.debug(""String_Node_Str"" + killCmd + ""String_Node_Str""+ pid);
        bufErrStream=new BufferedReader(new InputStreamReader(procKill.getErrorStream()));
        while ((line=bufErrStream.readLine()) != null) {
          logger.debug(line);
        }
      }
      int exit=procKill.waitFor();
      logger.info(""String_Node_Str"" + exit);
      if (exit == 0) {
        return true;
      }
    }
 else {
      logger.warn(""String_Node_Str"");
      ;
    }
  }
 catch (  Throwable t) {
    logger.error(""String_Node_Str"" + proc,t);
  }
 finally {
    if (bufInStream != null) {
      try {
        bufInStream.close();
      }
 catch (      Exception e) {
      }
    }
    if (bufErrStream != null) {
      try {
        bufErrStream.close();
      }
 catch (      Exception e) {
      }
    }
  }
  return false;
}"
49143,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  this.alwaysAnswerYes=alwaysAnswerYes;
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
    clusterCreate.setType(clusterType);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(null);
  }
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  if (topology == null) {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
 else {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_TOPOLOGY_INVALID_VALUE);
      System.out.println(""String_Node_Str"");
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  this.alwaysAnswerYes=alwaysAnswerYes;
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(null);
  }
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  if (topology == null) {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
 else {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_TOPOLOGY_INVALID_VALUE);
      System.out.println(""String_Node_Str"");
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49144,"public Long startCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STARTED_ERROR(clusterName);
  }
  if (!ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.START_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  StartClusterListener listener=new StartClusterListener(clusterName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.STARTING);
}","public Long startCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STARTED_ERROR(clusterName);
  }
  if (!ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.START_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  StartClusterListener listener=new StartClusterListener(clusterName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.STARTING);
}"
49145,"public Long resizeCluster(final String clusterName,final String nodeGroupName,final int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  final ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  final NodeGroupEntity group=DAL.inRoTransactionDo(new Saveable<NodeGroupEntity>(){
    @Override public NodeGroupEntity body() throws Exception {
      NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
      if (group == null) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
        throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
      }
      List<String> roles=group.getRoleNameList();
      List<String> unsupportedRoles=new ArrayList<String>();
      AuAssert.check(!roles.isEmpty(),""String_Node_Str"");
      if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
      }
      if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
      }
      if (!unsupportedRoles.isEmpty()) {
        logger.info(""String_Node_Str"" + unsupportedRoles);
        throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
      }
      if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
        throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
      }
      if (instanceNum <= group.getDefineInstanceNum()) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
        throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
      }
      Integer instancePerHost=group.getInstancePerHost();
      if (instancePerHost != null && instanceNum % instancePerHost != 0) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
      }
      group.validateHostNumber(instanceNum);
      group.validateIfHostCanSatisfied(instanceNum);
      return group;
    }
  }
);
  final int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  DAL.inTransactionUpdate(group);
  UpdateClusterListener listener=new UpdateClusterListener(clusterName,nodeGroupName,oldInstanceNum);
  try {
    return createClusterMgmtTask(cluster,listener,ClusterStatus.UPDATING);
  }
 catch (  Exception ex) {
    DAL.inTransactionDo(new Saveable<Void>(){
      @Override public Void body(){
        DAL.refresh(group);
        group.setDefineInstanceNum(oldInstanceNum);
        Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
        if (group.getHadoopNodes() != null) {
          for (          HadoopNodeEntity node : group.getHadoopNodes()) {
            if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
              logger.info(""String_Node_Str"" + node.getVmName());
              toRemove.add(node);
              DAL.delete(node);
            }
          }
          group.getHadoopNodes().removeAll(toRemove);
        }
        return null;
      }
    }
);
    throw ex;
  }
}","public Long resizeCluster(final String clusterName,final String nodeGroupName,final int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  final ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  final NodeGroupEntity group=DAL.inRoTransactionDo(new Saveable<NodeGroupEntity>(){
    @Override public NodeGroupEntity body() throws Exception {
      NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
      if (group == null) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
        throw ClusterManagerException.NOGEGROUP_NOT_FOUND_ERROR(nodeGroupName);
      }
      List<String> roles=group.getRoleNameList();
      List<String> unsupportedRoles=new ArrayList<String>();
      AuAssert.check(!roles.isEmpty(),""String_Node_Str"");
      if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
      }
      if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
        unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
      }
      if (!unsupportedRoles.isEmpty()) {
        logger.info(""String_Node_Str"" + unsupportedRoles);
        throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
      }
      if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
        throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
      }
      if (instanceNum <= group.getDefineInstanceNum()) {
        logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
        throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
      }
      Integer instancePerHost=group.getInstancePerHost();
      if (instancePerHost != null && instanceNum % instancePerHost != 0) {
        throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
      }
      group.validateHostNumber(instanceNum);
      group.validateIfHostCanSatisfied(instanceNum);
      return group;
    }
  }
);
  final int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  DAL.inTransactionUpdate(group);
  UpdateClusterListener listener=new UpdateClusterListener(clusterName);
  try {
    return createClusterMgmtTask(cluster,listener,ClusterStatus.UPDATING);
  }
 catch (  Exception ex) {
    DAL.inTransactionDo(new Saveable<Void>(){
      @Override public Void body(){
        DAL.refresh(group);
        group.setDefineInstanceNum(oldInstanceNum);
        Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
        if (group.getHadoopNodes() != null) {
          for (          HadoopNodeEntity node : group.getHadoopNodes()) {
            if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
              logger.info(""String_Node_Str"" + node.getVmName());
              toRemove.add(node);
              DAL.delete(node);
            }
          }
          group.getHadoopNodes().removeAll(toRemove);
        }
        return null;
      }
    }
);
    throw ex;
  }
}"
49146,"public Long stopCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STOPPED_ERROR(clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.STOP_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  StopClusterListener listener=new StopClusterListener(clusterName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.STOPPING);
}","public Long stopCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STOPPED_ERROR(clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.STOP_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  StopClusterListener listener=new StopClusterListener(clusterName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.STOPPING);
}"
49147,"@Override public void onFailure(){
  logger.debug(""String_Node_Str"");
  DAL.inRwTransactionDo(new Saveable<Void>(){
    @Override public Void body() throws Exception {
      ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
      AuAssert.check(cluster != null);
      NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
      AuAssert.check(group != null);
      cluster.setStatus(ClusterStatus.RUNNING);
      group.setDefineInstanceNum(oldInstanceNum);
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
      if (group.getHadoopNodes() != null) {
        for (        HadoopNodeEntity node : group.getHadoopNodes()) {
          if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
            logger.info(""String_Node_Str"" + node.getVmName());
            toRemove.add(node);
            DAL.delete(node);
          }
        }
        group.getHadoopNodes().removeAll(toRemove);
      }
      return null;
    }
  }
);
}","@Override public void onFailure(){
  logger.debug(""String_Node_Str"");
  DAL.inRwTransactionDo(new Saveable<Void>(){
    @Override public Void body() throws Exception {
      ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
      AuAssert.check(cluster != null);
      cluster.setStatus(ClusterStatus.RUNNING);
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return null;
    }
  }
);
}"
49148,"public UpdateClusterListener(String clusterName,String nodeGroupName,int oldInstanceNum){
  super();
  this.clusterName=clusterName;
  this.nodeGroupName=nodeGroupName;
  this.oldInstanceNum=oldInstanceNum;
}","public UpdateClusterListener(String clusterName){
  super();
  this.clusterName=clusterName;
}"
49149,"@Override public Void body() throws Exception {
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  AuAssert.check(cluster != null);
  NodeGroupEntity group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName);
  AuAssert.check(group != null);
  cluster.setStatus(ClusterStatus.RUNNING);
  group.setDefineInstanceNum(oldInstanceNum);
  logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  Set<HadoopNodeEntity> toRemove=new HashSet<HadoopNodeEntity>();
  if (group.getHadoopNodes() != null) {
    for (    HadoopNodeEntity node : group.getHadoopNodes()) {
      if (ClusterCmdUtil.getIndexFromNodeName(node.getVmName()) >= oldInstanceNum) {
        logger.info(""String_Node_Str"" + node.getVmName());
        toRemove.add(node);
        DAL.delete(node);
      }
    }
    group.getHadoopNodes().removeAll(toRemove);
  }
  return null;
}","@Override public Void body() throws Exception {
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  AuAssert.check(cluster != null);
  cluster.setStatus(ClusterStatus.RUNNING);
  logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  return null;
}"
49150,"private List<RackInfo> readRackInfoFromFile(String filePath) throws IOException, FileNotFoundException, CliException {
  FileReader fileReader=null;
  BufferedReader reader=null;
  List<RackInfo> racksInfo=new ArrayList<RackInfo>();
  try {
    File f=new File(filePath);
    fileReader=new FileReader(f);
    reader=new BufferedReader(fileReader);
    String line=""String_Node_Str"";
    int lineNum=1;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if (line.isEmpty()) {
        lineNum++;
        continue;
      }
 else {
        String[] rackHosts=line.split(""String_Node_Str"");
        if (rackHosts.length != 2) {
          throw new CliException(""String_Node_Str"" + lineNum + ""String_Node_Str""+ Constants.TOPLOGY_FORMAT);
        }
 else {
          String[] hosts=rackHosts[1].split(""String_Node_Str"");
          for (int i=0; i < hosts.length; i++) {
            hosts[i]=hosts[i].trim();
          }
          RackInfo rackInfo=new RackInfo();
          rackInfo.setName(rackHosts[0].trim());
          rackInfo.setHosts(Arrays.asList(hosts));
          racksInfo.add(rackInfo);
        }
      }
    }
  }
  finally {
    if (reader != null) {
      reader.close();
    }
    if (fileReader != null) {
      fileReader.close();
    }
  }
  return racksInfo;
}","private List<RackInfo> readRackInfoFromFile(String filePath) throws IOException, FileNotFoundException, CliException {
  FileReader fileReader=null;
  BufferedReader reader=null;
  List<RackInfo> racksInfo=new ArrayList<RackInfo>();
  try {
    File f=new File(filePath);
    fileReader=new FileReader(f);
    reader=new BufferedReader(fileReader);
    String line=""String_Node_Str"";
    int lineNum=1;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if (line.isEmpty()) {
        lineNum++;
        continue;
      }
 else {
        String[] rackHosts=line.split(""String_Node_Str"");
        if (rackHosts.length != 2 || rackHosts[0].trim().isEmpty() || rackHosts[1].trim().isEmpty()) {
          throw new CliException(""String_Node_Str"" + lineNum + ""String_Node_Str""+ Constants.TOPLOGY_FORMAT);
        }
 else {
          String[] hosts=rackHosts[1].split(""String_Node_Str"");
          int numOfNonEmptyHosts=0;
          for (int i=0; i < hosts.length; i++) {
            hosts[i]=hosts[i].trim();
            if (!hosts[i].isEmpty()) {
              hosts[numOfNonEmptyHosts++]=hosts[i];
            }
          }
          if (numOfNonEmptyHosts == 0) {
            throw new CliException(""String_Node_Str"" + lineNum + ""String_Node_Str""+ Constants.TOPLOGY_FORMAT);
          }
          RackInfo rackInfo=new RackInfo();
          rackInfo.setName(rackHosts[0].trim());
          rackInfo.setHosts(Arrays.asList(hosts).subList(0,numOfNonEmptyHosts));
          racksInfo.add(rackInfo);
        }
      }
    }
  }
  finally {
    if (reader != null) {
      reader.close();
    }
    if (fileReader != null) {
      fileReader.close();
    }
  }
  return racksInfo;
}"
49151,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void upload(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String fileName){
  try {
    List<RackInfo> racks=readRackInfoFromFile(fileName);
    topologyRestClient.upload(racks);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_TOPOLOGY,null,Constants.OUTPUT_OP_RESULT_UPLOAD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_TOPOLOGY,null,Constants.OUTPUT_OP_UPLOAD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void upload(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String fileName){
  try {
    List<RackInfo> racks=readRackInfoFromFile(fileName);
    if (!duplicatedNameCheck(racks)) {
      topologyRestClient.upload(racks);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_TOPOLOGY,null,Constants.OUTPUT_OP_RESULT_UPLOAD);
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_TOPOLOGY,null,Constants.OUTPUT_OP_UPLOAD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
}"
49152,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  this.alwaysAnswerYes=alwaysAnswerYes;
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(null);
  }
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,""String_Node_Str""));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  if (topology == null) {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
 else {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_TOPOLOGY_INVALID_VALUE);
      System.out.println(""String_Node_Str"");
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  this.alwaysAnswerYes=alwaysAnswerYes;
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(null);
  }
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,""String_Node_Str""));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  if (topology == null) {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
 else {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_TOPOLOGY_INVALID_VALUE);
      System.out.println(""String_Node_Str"");
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49153,"public NodeGroupRead toNodeGroupRead(){
  NodeGroupRead nodeGroupRead=new NodeGroupRead();
  nodeGroupRead.setName(this.name);
  nodeGroupRead.setCpuNum(this.cpuNum);
  nodeGroupRead.setMemCapacityMB(this.memorySize);
  nodeGroupRead.setInstanceNum(this.getRealInstanceNum());
  nodeGroupRead.setRoles(this.getRoleNameList());
  StorageRead storage=new StorageRead();
  storage.setType(this.storageType.toString());
  storage.setSizeGB(this.storageSize);
  storage.setDsNames(getVcDatastoreNameList());
  nodeGroupRead.setStorage(storage);
  List<NodeRead> nodeList=new ArrayList<NodeRead>();
  for (  HadoopNodeEntity node : this.hadoopNodes) {
    nodeList.add(node.toNodeRead());
  }
  nodeGroupRead.setInstances(nodeList);
  List<GroupAssociation> associations=new ArrayList<GroupAssociation>();
  for (  NodeGroupAssociation relation : groupAssociations) {
    GroupAssociation association=new GroupAssociation();
    association.setReference(relation.getReferencedGroup());
    association.setType(relation.getAssociationType());
    associations.add(association);
  }
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(instancePerHost);
  policy.setGroupAssociations(associations);
  nodeGroupRead.setPlacementPolicies(policy);
  return nodeGroupRead;
}","public NodeGroupRead toNodeGroupRead(){
  NodeGroupRead nodeGroupRead=new NodeGroupRead();
  nodeGroupRead.setName(this.name);
  nodeGroupRead.setCpuNum(this.cpuNum);
  nodeGroupRead.setMemCapacityMB(this.memorySize);
  nodeGroupRead.setInstanceNum(this.getRealInstanceNum());
  nodeGroupRead.setRoles(this.getRoleNameList());
  StorageRead storage=new StorageRead();
  storage.setType(this.storageType.toString());
  storage.setSizeGB(this.storageSize);
  storage.setDsNames(getVcDatastoreNameList());
  nodeGroupRead.setStorage(storage);
  List<NodeRead> nodeList=new ArrayList<NodeRead>();
  for (  HadoopNodeEntity node : this.hadoopNodes) {
    nodeList.add(node.toNodeRead());
  }
  nodeGroupRead.setInstances(nodeList);
  List<GroupAssociation> associations=new ArrayList<GroupAssociation>();
  for (  NodeGroupAssociation relation : groupAssociations) {
    GroupAssociation association=new GroupAssociation();
    association.setReference(relation.getReferencedGroup());
    association.setType(relation.getAssociationType());
    associations.add(association);
  }
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(instancePerHost);
  policy.setGroupAssociations(associations);
  policy.setGroupRacks((GroupRacks)new Gson().fromJson(groupRacks,GroupRacks.class));
  nodeGroupRead.setPlacementPolicies(policy);
  return nodeGroupRead;
}"
49154,"public Long deleteClusterByName(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())&& !ClusterStatus.PROVISION_ERROR.equals(cluster.getStatus())&& !ClusterStatus.CONFIGURE_ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.DELETION_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  DeleteClusterListener listener=new DeleteClusterListener(clusterName,networkManager);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.DELETING);
}","public Long deleteClusterByName(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())&& !ClusterStatus.PROVISION_ERROR.equals(cluster.getStatus())&& !ClusterStatus.CONFIGURE_ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.DELETION_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!checkClusterInstance(clusterName)) {
    return null;
  }
  DeleteClusterListener listener=new DeleteClusterListener(clusterName,networkManager);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.DELETING);
}"
49155,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseStatus(HttpStatus.ACCEPTED) public void deleteCluster(@PathVariable(""String_Node_Str"") String clusterName,HttpServletRequest request,HttpServletResponse response) throws Exception {
  Long taskId=clusterMgr.deleteClusterByName(clusterName);
  redirectRequest(taskId,request,response);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseStatus(HttpStatus.ACCEPTED) public void deleteCluster(@PathVariable(""String_Node_Str"") String clusterName,HttpServletRequest request,HttpServletResponse response) throws Exception {
  Long taskId=clusterMgr.deleteClusterByName(clusterName);
  if (taskId == null) {
    return;
  }
  redirectRequest(taskId,request,response);
}"
49156,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void limitCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final int activeComputeNodeNum){
  try {
    if (!validateLimit(clusterName,nodeGroupName,activeComputeNodeNum)) {
      return;
    }
    restClient.limitCluster(clusterName,nodeGroupName,activeComputeNodeNum);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OP_ADJUSTMENT,null,Constants.OUTPUT_OP_ADJUSTMENT_SUCCEEDED);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void limitCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final int activeComputeNodeNum){
  try {
    if (activeComputeNodeNum < 0) {
      System.out.println(""String_Node_Str"" + activeComputeNodeNum);
      return;
    }
    ClusterRead cluster=restClient.get(clusterName);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return;
    }
    if (!cluster.validateLimit(nodeGroupName,activeComputeNodeNum)) {
      return;
    }
    restClient.limitCluster(clusterName,nodeGroupName,activeComputeNodeNum);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OP_ADJUSTMENT,null,Constants.OUTPUT_OP_ADJUSTMENT_SUCCEEDED);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OP_ADJUSTMENT,null,null,Constants.OUTPUT_OP_ADJUSTMENT_FAILED,e.getMessage());
  }
}"
49157,"/** 
 * Check whether the given String has actual text. More specifically, returns <code>false</code> if the string not <code>null</code>, its length is greater than 0, and it contains at least one non-whitespace character. <p> <pre> CommandsUtils.isBlank(null) = true CommandsUtils.isBlank("""") = true CommandsUtils.isBlank("" "") = true CommandsUtils.isBlank(""12345"") = false CommandsUtils.isBlank("" 12345 "") = false </pre>
 * @param str the String to check(may be null).
 * @return the opposite of
 */
public static boolean isBlank(final String str){
  return str == null || str.trim().isEmpty();
}","/** 
 * Check whether the given String has actual text. More specifically, returns <code>false</code> if the string not <code>null</code>, its length is greater than 0, and it contains at least one non-whitespace character. <p> <pre> CommandsUtils.isBlank(null) = true CommandsUtils.isBlank("""") = true CommandsUtils.isBlank("" "") = true CommandsUtils.isBlank(""12345"") = false CommandsUtils.isBlank("" 12345 "") = false </pre>
 * @param str the String to check(may be null).
 * @return the opposite of
 */
public static boolean isBlank(final String str){
  return CommonUtil.isBlank(str);
}"
49158,"public void limitCluster(String clusterName,String nodeGroupName,int activeComputeNodeNum){
  final String path=Constants.REST_PATH_CLUSTER + ""String_Node_Str"" + clusterName+ ""String_Node_Str""+ ""String_Node_Str"";
  final HttpMethod httpverb=HttpMethod.PUT;
  PrettyOutput outputCallBack=getClusterPrettyOutputCallBack(this,clusterName);
  NodeGroupRead nodeGroup=new NodeGroupRead();
  nodeGroup.setInstanceNum(activeComputeNodeNum);
  nodeGroup.setName(nodeGroupName);
  restClient.update(nodeGroup,path,httpverb,outputCallBack);
}","public void limitCluster(String clusterName,String nodeGroupName,int activeComputeNodeNum){
  final String path=Constants.REST_PATH_CLUSTER + ""String_Node_Str"" + clusterName+ ""String_Node_Str""+ ""String_Node_Str"";
  final HttpMethod httpverb=HttpMethod.PUT;
  PrettyOutput outputCallBack=getClusterPrettyOutputCallBack(this,clusterName);
  VHMRequestBody requestBody=new VHMRequestBody();
  requestBody.setActiveComputeNodeNum(activeComputeNodeNum);
  requestBody.setNodeGroupName(nodeGroupName);
  restClient.update(requestBody,path,httpverb,outputCallBack);
}"
49159,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void stopCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeName){
  Map<String,String> queryStrings=new HashMap<String,String>();
  queryStrings.put(Constants.QUERY_ACTION_KEY,Constants.QUERY_ACTION_STOP);
  try {
    if (!validateNodeGroupName(nodeGroupName)) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
    if (!validateNodeName(clusterName,nodeGroupName,nodeName)) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
    String groupName=nodeGroupName;
    String fullNodeName=nodeName;
    if (nodeName != null) {
      if (nodeGroupName == null) {
        groupName=extractNodeGroupName(nodeName);
        if (groupName == null) {
          CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
          return;
        }
      }
 else {
        fullNodeName=autoCompleteNodeName(clusterName,nodeGroupName,nodeName);
      }
    }
    String resource=getClusterResourceName(clusterName,nodeGroupName,fullNodeName);
    if (resource != null) {
      restClient.actionOps(resource,clusterName,queryStrings);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_STOP);
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void stopCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeName){
  Map<String,String> queryStrings=new HashMap<String,String>();
  queryStrings.put(Constants.QUERY_ACTION_KEY,Constants.QUERY_ACTION_STOP);
  try {
    if (!validateNodeGroupName(nodeGroupName)) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
    if (!validateNodeName(clusterName,nodeGroupName,nodeName)) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
    String groupName=nodeGroupName;
    String fullNodeName=nodeName;
    if (nodeName != null) {
      if (nodeGroupName == null) {
        groupName=extractNodeGroupName(nodeName);
        if (groupName == null) {
          CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
          return;
        }
      }
 else {
        fullNodeName=autoCompleteNodeName(clusterName,nodeGroupName,nodeName);
      }
    }
    String resource=getClusterResourceName(clusterName,groupName,fullNodeName);
    if (resource != null) {
      restClient.actionOps(resource,clusterName,queryStrings);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_STOP);
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49160,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  this.alwaysAnswerYes=alwaysAnswerYes;
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,""String_Node_Str""));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  this.alwaysAnswerYes=alwaysAnswerYes;
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,""String_Node_Str""));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49161,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
private boolean validateClusterCreate(ClusterCreate clusterCreate){
  boolean validated=true;
  boolean warning=false;
  int masterCount=0, workerCount=0, clientCount=0;
  NodeGroupCreate[] nodeGroupCreates=clusterCreate.getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.MULTI_INPUTS_CHECK);
    return !validated;
  }
 else {
    List<String> failedMsgList=new LinkedList<String>();
    List<String> distroRoles=findDistroRoles(clusterCreate);
    if (distroRoles == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NO_DISTRO_AVAILABLE);
      return !validated;
    }
    if (nodeGroupCreates.length < 2 || nodeGroupCreates.length > 4) {
      warning=true;
    }
    if (clusterCreate.hasHDFSUrlConfigured() && !clusterCreate.validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(clusterCreate.getExternalHDFS()).toString());
      validated=false;
    }
    if (!clusterCreate.validateNodeGroupPlacementPolicies(failedMsgList)) {
      validated=false;
    }
    if (!clusterCreate.validateNodeGroupRoles(failedMsgList)) {
      validated=false;
    }
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      if (!checkInstanceNum(nodeGroupCreate,failedMsgList)) {
        validated=false;
      }
      if (!checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList)) {
        validated=false;
      }
      NodeGroupRole role=getNodeGroupRole(nodeGroupCreate);
switch (role) {
case MASTER:
        masterCount++;
      if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
        validated=false;
        collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
      }
    break;
case WORKER:
  workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
  validated=false;
  collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
  warning=true;
}
break;
case CLIENT:
clientCount++;
if (nodeGroupCreate.getInstanceNum() == 0 || isHAFlag(nodeGroupCreate)) {
warning=true;
}
break;
case NONE:
warning=true;
break;
default :
}
}
if ((masterCount < 1 || masterCount > 2) || (workerCount < 1 || workerCount > 2) || clientCount > 1) {
warning=true;
}
if (!validated) {
showFailedMsg(clusterCreate.getName(),failedMsgList);
}
 else if (warning) {
showWarningMsg();
if (!isContinue(clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.PARAM_PROMPT_CONTINUE_MESSAGE)) {
validated=false;
}
}
return validated;
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
private boolean validateClusterCreate(ClusterCreate clusterCreate){
  boolean validated=true;
  boolean warning=false;
  int masterCount=0, workerCount=0, clientCount=0;
  NodeGroupCreate[] nodeGroupCreates=clusterCreate.getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.MULTI_INPUTS_CHECK);
    return !validated;
  }
 else {
    List<String> failedMsgList=new LinkedList<String>();
    List<String> distroRoles=findDistroRoles(clusterCreate);
    if (distroRoles == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NO_DISTRO_AVAILABLE);
      return !validated;
    }
    if (nodeGroupCreates.length < 2 || nodeGroupCreates.length > 5) {
      warning=true;
    }
    if (clusterCreate.hasHDFSUrlConfigured() && !clusterCreate.validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(clusterCreate.getExternalHDFS()).toString());
      validated=false;
    }
    if (!clusterCreate.validateNodeGroupPlacementPolicies(failedMsgList)) {
      validated=false;
    }
    if (!clusterCreate.validateNodeGroupRoles(failedMsgList)) {
      validated=false;
    }
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      if (!checkInstanceNum(nodeGroupCreate,failedMsgList)) {
        validated=false;
      }
      if (!checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList)) {
        validated=false;
      }
      NodeGroupRole role=getNodeGroupRole(nodeGroupCreate);
switch (role) {
case MASTER:
        masterCount++;
      if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
        validated=false;
        collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
      }
    break;
case WORKER:
  workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
  validated=false;
  collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
  warning=true;
}
break;
case CLIENT:
clientCount++;
if (isHAFlag(nodeGroupCreate)) {
warning=true;
}
break;
case NONE:
warning=true;
break;
default :
}
}
if ((masterCount < 1 || masterCount > 2) || (workerCount < 1 || workerCount > 2) || clientCount > 1) {
warning=true;
}
if (!validated) {
showFailedMsg(clusterCreate.getName(),failedMsgList);
}
 else if (warning) {
showWarningMsg();
if (!isContinue(clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,Constants.PARAM_PROMPT_CONTINUE_MESSAGE)) {
validated=false;
}
}
return validated;
}
}"
49162,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void conn(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String hostName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String username,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String password){
  Map<String,String> loginInfo=new HashMap<String,String>();
  loginInfo.put(""String_Node_Str"",username);
  loginInfo.put(""String_Node_Str"",password);
  try {
    if (CommandsUtils.isBlank(username)) {
      if (!prompt(Constants.CONNECT_ENTER_USER_NAME,PromptType.USER_NAME,loginInfo)) {
        return;
      }
    }
    if (CommandsUtils.isBlank(password)) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return;
      }
    }
    connect(hostName,loginInfo,3);
  }
 catch (  CliRestException e) {
    System.out.println();
    printConnectionFailure(e.getMessage());
  }
catch (  Exception e) {
    printConnectionFailure(e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void conn(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String hostName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String username,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String password){
  Map<String,String> loginInfo=new HashMap<String,String>();
  loginInfo.put(""String_Node_Str"",username);
  loginInfo.put(""String_Node_Str"",password);
  try {
    if (CommandsUtils.isBlank(username)) {
      if (!prompt(Constants.CONNECT_ENTER_USER_NAME,PromptType.USER_NAME,loginInfo)) {
        return;
      }
    }
    if (CommandsUtils.isBlank(password)) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return;
      }
    }
    connect(hostName,loginInfo,3);
  }
 catch (  Exception e) {
    System.out.println();
    printConnectionFailure(e.getMessage());
  }
}"
49163,"private String readEnter(String msg,PromptType promptType){
  String enter=""String_Node_Str"";
  BufferedReader br=null;
  try {
    br=new BufferedReader(new InputStreamReader(System.in));
    ConsoleReader reader=new ConsoleReader(System.in,new PrintWriter(System.out));
    int times=0;
    while (!br.ready() && times < Constants.MAX_WAITING_LOOP) {
      Thread.currentThread().sleep(Constants.READER_SLEEP_TIME_MILLISECONDS);
      times++;
    }
    if (!br.ready()) {
      throw new CliRestException(Constants.READ_TIME_OUT);
    }
    if (promptType == PromptType.USER_NAME) {
      enter=reader.readLine();
    }
 else     if (promptType == PromptType.PASSWORD) {
      enter=reader.readLine(new Character('*'));
    }
  }
 catch (  CliRestException e) {
    throw e;
  }
catch (  Exception e) {
    throw new CliRestException(e.getMessage());
  }
  return enter;
}","@SuppressWarnings(""String_Node_Str"") private String readEnter(String msg,PromptType promptType) throws Exception {
  String enter=""String_Node_Str"";
  BufferedReader br=null;
  br=new BufferedReader(new InputStreamReader(System.in));
  ConsoleReader reader=new ConsoleReader(System.in,new PrintWriter(System.out));
  int times=0;
  while (!br.ready() && times < Constants.MAX_WAITING_LOOP) {
    Thread.currentThread().sleep(Constants.READER_SLEEP_TIME_MILLISECONDS);
    times++;
  }
  if (!br.ready()) {
    throw new Exception(Constants.READ_TIME_OUT);
  }
  if (promptType == PromptType.USER_NAME) {
    enter=reader.readLine();
  }
 else   if (promptType == PromptType.PASSWORD) {
    enter=reader.readLine(new Character('*'));
  }
  return enter;
}"
49164,"private boolean prompt(String msg,PromptType promptType,Map<String,String> loginInfo){
  int k=0;
  String enter=""String_Node_Str"";
  while (k < 3) {
    System.out.print(msg);
    enter=readEnter(msg,promptType);
    if (!CommandsUtils.isBlank(enter)) {
      if (promptType == PromptType.USER_NAME) {
        loginInfo.put(""String_Node_Str"",enter);
      }
 else {
        loginInfo.put(""String_Node_Str"",enter);
      }
      break;
    }
 else {
      StringBuilder warningMsg=new StringBuilder();
      if (promptType == PromptType.USER_NAME) {
        warningMsg.append(Constants.CONNECT_USER_NAME);
      }
 else {
        warningMsg.append(Constants.CONNECT_PASSWORD);
      }
      warningMsg.append(Constants.CONNECT_CAN_NOT_BE_NULL);
      System.out.println(warningMsg.toString());
    }
    k++;
  }
  return k < 3;
}","private boolean prompt(String msg,PromptType promptType,Map<String,String> loginInfo) throws Exception {
  int k=0;
  String enter=""String_Node_Str"";
  while (k < 3) {
    System.out.print(msg);
    enter=readEnter(msg,promptType);
    if (!CommandsUtils.isBlank(enter)) {
      if (promptType == PromptType.USER_NAME) {
        loginInfo.put(""String_Node_Str"",enter);
      }
 else {
        loginInfo.put(""String_Node_Str"",enter);
      }
      break;
    }
 else {
      StringBuilder warningMsg=new StringBuilder();
      if (promptType == PromptType.USER_NAME) {
        warningMsg.append(Constants.CONNECT_USER_NAME);
      }
 else {
        warningMsg.append(Constants.CONNECT_PASSWORD);
      }
      warningMsg.append(Constants.CONNECT_CAN_NOT_BE_NULL);
      System.out.println(warningMsg.toString());
    }
    k++;
  }
  return k < 3;
}"
49165,"private boolean connect(final String hostName,final Map<String,String> loginInfo,int count){
  if (count <= 0) {
    return false;
  }
 else {
    ConnectType connectType=conn.connect(hostName,loginInfo.get(""String_Node_Str""),loginInfo.get(""String_Node_Str""));
    if (connectType == ConnectType.UNAUTHORIZATION) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return false;
      }
 else {
        count--;
        connect(hostName,loginInfo,count);
      }
    }
  }
  return true;
}","private boolean connect(final String hostName,final Map<String,String> loginInfo,int count) throws Exception {
  if (count <= 0) {
    return false;
  }
 else {
    ConnectType connectType=conn.connect(hostName,loginInfo.get(""String_Node_Str""),loginInfo.get(""String_Node_Str""));
    if (connectType == ConnectType.UNAUTHORIZATION) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return false;
      }
 else {
        count--;
        connect(hostName,loginInfo,count);
      }
    }
  }
  return true;
}"
49166,"/** 
 * connect to a Serengeti server
 * @param host host url with optional port
 * @param username serengeti login user name
 * @param password serengeti password
 */
public Connect.ConnectType connect(final String host,final String username,final String password){
  String oldHostUri=hostUri;
  hostUri=Constants.HTTP_CONNECTION_PREFIX + host + Constants.HTTP_CONNECTION_LOGIN_SUFFIX;
  try {
    ResponseEntity<String> response=login(Constants.REST_PATH_LOGIN,String.class,username,password);
    if (response.getStatusCode() == HttpStatus.OK) {
      updateHostproperty(host);
      String cookieValue=response.getHeaders().getFirst(""String_Node_Str"");
      if (cookieValue.contains(""String_Node_Str"")) {
        cookieValue=cookieValue.split(""String_Node_Str"")[0];
      }
      writeCookieInfo(cookieValue);
      System.out.println(Constants.CONNECT_SUCCESS);
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE);
      hostUri=oldHostUri;
      return Connect.ConnectType.ERROR;
    }
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      System.out.println(Constants.CONNECT_UNAUTHORIZATION);
      hostUri=oldHostUri;
      return Connect.ConnectType.UNAUTHORIZATION;
    }
  }
catch (  Exception e) {
    System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + e.getCause().getMessage().toLowerCase());
    return Connect.ConnectType.ERROR;
  }
  return Connect.ConnectType.SUCCESS;
}","/** 
 * connect to a Serengeti server
 * @param host host url with optional port
 * @param username serengeti login user name
 * @param password serengeti password
 */
public Connect.ConnectType connect(final String host,final String username,final String password){
  String oldHostUri=hostUri;
  hostUri=Constants.HTTP_CONNECTION_PREFIX + host + Constants.HTTP_CONNECTION_LOGIN_SUFFIX;
  try {
    ResponseEntity<String> response=login(Constants.REST_PATH_LOGIN,String.class,username,password);
    if (response.getStatusCode() == HttpStatus.OK) {
      updateHostproperty(host);
      String cookieValue=response.getHeaders().getFirst(""String_Node_Str"");
      if (cookieValue.contains(""String_Node_Str"")) {
        cookieValue=cookieValue.split(""String_Node_Str"")[0];
      }
      writeCookieInfo(cookieValue);
      System.out.println(Constants.CONNECT_SUCCESS);
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE);
      hostUri=oldHostUri;
      return Connect.ConnectType.ERROR;
    }
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      System.out.println(Constants.CONNECT_UNAUTHORIZATION);
      hostUri=oldHostUri;
      return Connect.ConnectType.UNAUTHORIZATION;
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + cliRestException.getStatus()+ ""String_Node_Str""+ cliRestException.getMessage().toLowerCase());
      return Connect.ConnectType.ERROR;
    }
  }
catch (  Exception e) {
    System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + e.getCause().getMessage().toLowerCase());
    return Connect.ConnectType.ERROR;
  }
  return Connect.ConnectType.SUCCESS;
}"
49167,"public void handleError(ClientHttpResponse response) throws IOException {
  MediaType contentType=response.getHeaders().getContentType();
  if (contentType == MediaType.APPLICATION_JSON) {
    throw new CliRestException(delegate.extractData(response).getMessage());
  }
 else {
    HttpStatus statusCode=response.getStatusCode();
    String errorMsg=""String_Node_Str"";
    if (statusCode == HttpStatus.UNAUTHORIZED) {
      errorMsg=Constants.CONNECT_SESSION_TIME_OUT;
    }
 else {
      errorMsg=statusCode.getReasonPhrase();
    }
    throw new CliRestException(statusCode,errorMsg);
  }
}","public void handleError(ClientHttpResponse response) throws IOException {
  MediaType contentType=response.getHeaders().getContentType();
  if (contentType.equals(MediaType.APPLICATION_JSON)) {
    throw new CliRestException(delegate.extractData(response).getMessage());
  }
 else {
    HttpStatus statusCode=response.getStatusCode();
    String errorMsg=""String_Node_Str"";
    if (statusCode == HttpStatus.UNAUTHORIZED) {
      errorMsg=Constants.CONNECT_SESSION_TIME_OUT;
    }
 else {
      errorMsg=statusCode.getReasonPhrase();
    }
    throw new CliRestException(statusCode,errorMsg);
  }
}"
49168,"private void createDefalutFile(ClusterCreate cluster){
  String origFile=""String_Node_Str"";
  String destFile=System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + cluster.getName()+ ""String_Node_Str"";
  StringBuilder createDefalutFileMsgBuffer=new StringBuilder();
  try {
    CommonUtil.copyFile(origFile,destFile);
    createDefalutFileMsgBuffer.append(""String_Node_Str"").append(destFile).append(""String_Node_Str"").append(cluster.getName()).append(""String_Node_Str"");
    System.out.println(createDefalutFileMsgBuffer.toString());
  }
 catch (  IOException e) {
    CommonUtil.deleteFile(destFile);
  }
}","private void createDefalutFile(String clusterName){
  String origFile=""String_Node_Str"";
  String destFile=System.getProperty(""String_Node_Str"") + ""String_Node_Str"" + clusterName+ ""String_Node_Str"";
  StringBuilder createDefalutFileMsgBuffer=new StringBuilder();
  try {
    CommonUtil.copyFile(origFile,destFile);
    createDefalutFileMsgBuffer.append(""String_Node_Str"").append(destFile).append(""String_Node_Str"").append(clusterName).append(""String_Node_Str"");
    System.out.println(createDefalutFileMsgBuffer.toString());
  }
 catch (  IOException e) {
    CommonUtil.deleteFile(destFile);
  }
}"
49169,"private void resumeCreateCluster(final String name){
  Map<String,String> queryStrings=new HashMap<String,String>();
  queryStrings.put(Constants.QUERY_ACTION_KEY,Constants.QUERY_ACTION_RESUME);
  try {
    restClient.actionOps(name,queryStrings);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_RESUME);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESUME,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","private void resumeCreateCluster(final String name){
  Map<String,String> queryStrings=new HashMap<String,String>();
  queryStrings.put(Constants.QUERY_ACTION_KEY,Constants.QUERY_ACTION_RESUME);
  try {
    ClusterRead cluster=restClient.get(name);
    restClient.actionOps(name,queryStrings);
    if (cluster != null && cluster.isDefault()) {
      createDefalutFile(name);
    }
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_RESUME);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESUME,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49170,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  this.alwaysAnswerYes=alwaysAnswerYes;
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,""String_Node_Str""));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    if (specFilePath == null) {
      createDefalutFile(clusterCreate);
    }
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  this.alwaysAnswerYes=alwaysAnswerYes;
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,""String_Node_Str""));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
      clusterCreate.setDefault(false);
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    if (specFilePath == null) {
      createDefalutFile(clusterCreate.getName());
    }
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49171,"@Test public void testResumeCreateClusterFailure() throws Exception {
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,true,false,false);
}","@Test public void testResumeCreateClusterFailure() throws Exception {
  ClusterRead cluster=buildClusterRead();
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NOT_FOUND,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",""String_Node_Str"",null,null,null,null,true,false,false);
}"
49172,"@Test public void testResumeCreateCluster() throws Exception {
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,null,null,true,false,false);
}","@Test public void testResumeCreateCluster() throws Exception {
  ObjectMapper mapper=new ObjectMapper();
  ClusterRead cluster=buildClusterRead();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.PUT,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,null,null,true,false,false);
}"
49173,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (!type.trim().equalsIgnoreCase(""String_Node_Str"") && !type.trim().equalsIgnoreCase(""String_Node_Str"")) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,type.toUpperCase()));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    if (specFilePath == null) {
      createDefalutFile(clusterCreate);
    }
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (!type.trim().equalsIgnoreCase(""String_Node_Str"") && !type.trim().equalsIgnoreCase(""String_Node_Str"")) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,type.toUpperCase()));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    if (specFilePath == null) {
      createDefalutFile(clusterCreate);
    }
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49174,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void startCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeName){
  Map<String,String> queryStrings=new HashMap<String,String>();
  queryStrings.put(Constants.QUERY_ACTION_KEY,Constants.QUERY_ACTION_START);
  try {
    String fullNodeName=autoCompleteNodeName(clusterName,nodeGroupName,nodeName);
    String resource=getClusterResourceName(clusterName,nodeGroupName,fullNodeName);
    if (resource != null) {
      restClient.actionOps(resource,queryStrings);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_START);
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_START,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void startCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeName){
  Map<String,String> queryStrings=new HashMap<String,String>();
  queryStrings.put(Constants.QUERY_ACTION_KEY,Constants.QUERY_ACTION_START);
  try {
    String fullNodeName=autoCompleteNodeName(clusterName,nodeGroupName,nodeName);
    String resource=getClusterResourceName(clusterName,nodeGroupName,fullNodeName);
    if (resource != null) {
      restClient.actionOps(resource,clusterName,queryStrings);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_START);
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_START,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49175,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void stopCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeName){
  Map<String,String> queryStrings=new HashMap<String,String>();
  queryStrings.put(Constants.QUERY_ACTION_KEY,Constants.QUERY_ACTION_STOP);
  try {
    String fullNodeName=autoCompleteNodeName(clusterName,nodeGroupName,nodeName);
    String resource=getClusterResourceName(clusterName,nodeGroupName,fullNodeName);
    if (resource != null) {
      restClient.actionOps(resource,queryStrings);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_STOP);
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void stopCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String nodeName){
  Map<String,String> queryStrings=new HashMap<String,String>();
  queryStrings.put(Constants.QUERY_ACTION_KEY,Constants.QUERY_ACTION_STOP);
  try {
    String fullNodeName=autoCompleteNodeName(clusterName,nodeGroupName,nodeName);
    String resource=getClusterResourceName(clusterName,nodeGroupName,fullNodeName);
    if (resource != null) {
      restClient.actionOps(resource,clusterName,queryStrings);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_STOP);
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NODES_IN_CLUSTER,clusterName,Constants.OUTPUT_OP_STOP,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49176,"public void actionOps(String id,Map<String,?> queryStrings){
  final String path=Constants.REST_PATH_CLUSTER;
  final HttpMethod httpverb=HttpMethod.PUT;
  PrettyOutput outputCallBack=getClusterPrettyOutputCallBack(this,id);
  restClient.actionOps(id,path,httpverb,queryStrings,outputCallBack);
}","public void actionOps(String id,Map<String,?> queryStrings){
  actionOps(id,id,queryStrings);
}"
49177,"public Long startNode(String clusterName,String nodeGroupName,String nodeName) throws Exception {
  logger.info(""String_Node_Str"" + ClusterCmdUtil.getFullNodeName(clusterName,nodeGroupName,nodeName));
  ClusterEntity cluster;
  NodeGroupEntity group;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if ((group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName)) == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",nodeGroupName);
  }
  if (HadoopNodeEntity.findByName(group,nodeGroupName) == null) {
    logger.error(""String_Node_Str"" + nodeName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",nodeName);
  }
  StartClusterListener listener=new StartClusterListener(clusterName,nodeGroupName,nodeName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,null);
}","public Long startNode(String clusterName,String nodeGroupName,String nodeName) throws Exception {
  logger.info(""String_Node_Str"" + ClusterCmdUtil.getFullNodeName(clusterName,nodeGroupName,nodeName));
  ClusterEntity cluster;
  NodeGroupEntity group;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if ((group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName)) == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",nodeGroupName);
  }
  if (HadoopNodeEntity.findByName(group,nodeName) == null) {
    logger.error(""String_Node_Str"" + nodeName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",nodeName);
  }
  StartClusterListener listener=new StartClusterListener(clusterName,nodeGroupName,nodeName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,null);
}"
49178,"public Long stopNode(String clusterName,String nodeGroupName,String nodeName) throws Exception {
  logger.info(""String_Node_Str"" + ClusterCmdUtil.getFullNodeName(clusterName,nodeGroupName,nodeName));
  ClusterEntity cluster;
  NodeGroupEntity group;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if ((group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName)) == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",nodeGroupName);
  }
  if (HadoopNodeEntity.findByName(group,nodeGroupName) == null) {
    logger.error(""String_Node_Str"" + nodeName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",nodeName);
  }
  StopClusterListener listener=new StopClusterListener(clusterName,nodeGroupName,nodeName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,null);
}","public Long stopNode(String clusterName,String nodeGroupName,String nodeName) throws Exception {
  logger.info(""String_Node_Str"" + ClusterCmdUtil.getFullNodeName(clusterName,nodeGroupName,nodeName));
  ClusterEntity cluster;
  NodeGroupEntity group;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if ((group=NodeGroupEntity.findNodeGroupEntityByName(cluster,nodeGroupName)) == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",nodeGroupName);
  }
  if (HadoopNodeEntity.findByName(group,nodeName) == null) {
    logger.error(""String_Node_Str"" + nodeName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",nodeName);
  }
  StopClusterListener listener=new StopClusterListener(clusterName,nodeGroupName,nodeName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,null);
}"
49179,"public static String getFullNodeName(String cluster,String group,String node){
  AuAssert.check(cluster != null && !cluster.isEmpty());
  AuAssert.check(group == null || !group.isEmpty());
  AuAssert.check(node == null || !node.isEmpty());
  AuAssert.check(!(node != null && group == null));
  StringBuilder fullName=new StringBuilder();
  fullName.append(cluster).append(""String_Node_Str"");
  if (group != null) {
    fullName.append(group).append(""String_Node_Str"");
    if (node != null) {
      fullName.append(node);
    }
  }
  return fullName.toString();
}","public static String getFullNodeName(String cluster,String group,String node){
  AuAssert.check(cluster != null && !cluster.isEmpty());
  AuAssert.check(group == null || !group.isEmpty());
  AuAssert.check(node == null || !node.isEmpty());
  AuAssert.check(!(node != null && group == null));
  StringBuilder fullName=new StringBuilder();
  fullName.append(cluster);
  if (group != null) {
    fullName.append(""String_Node_Str"").append(group);
    if (node != null) {
      fullName.append(""String_Node_Str"").append(node);
    }
  }
  return fullName.toString();
}"
49180,"public CliRestException(String errorMsg){
  super(errorMsg);
}","public CliRestException(HttpStatus status,String errorMsg){
  super(errorMsg);
  this.status=status;
}"
49181,"public void handleError(ClientHttpResponse response) throws IOException {
  throw new CliRestException(delegate.extractData(response).getMessage());
}","public void handleError(ClientHttpResponse response) throws IOException {
  MediaType contentType=response.getHeaders().getContentType();
  if (contentType == MediaType.APPLICATION_JSON) {
    throw new CliRestException(delegate.extractData(response).getMessage());
  }
 else {
    HttpStatus statusCode=response.getStatusCode();
    throw new CliRestException(statusCode,statusCode.getReasonPhrase());
  }
}"
49182,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (!type.trim().equalsIgnoreCase(""String_Node_Str"") && !type.trim().equalsIgnoreCase(""String_Node_Str"")) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,type.toUpperCase()));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    if (specFilePath == null) {
      createDefalutFile(clusterCreate);
    }
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (!type.trim().equalsIgnoreCase(""String_Node_Str"") && !type.trim().equalsIgnoreCase(""String_Node_Str"")) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  clusterCreate.setType(Enum.valueOf(ClusterType.class,type.toUpperCase()));
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> warningMsgList=new ArrayList<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (!showWarningMsg(clusterCreate.getName(),warningMsgList)) {
      return;
    }
    restClient.create(clusterCreate);
    if (specFilePath == null) {
      createDefalutFile(clusterCreate);
    }
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49183,"private boolean showWarningMsg(String clusterName,List<String> warningMsgList){
  if (warningMsgList != null && !warningMsgList.isEmpty()) {
    for (    String message : warningMsgList) {
      System.out.println(message);
    }
    if (!isContinue(clusterName,Constants.OUTPUT_OP_CREATE,Constants.PARAM_PROMPT_CONTINUE_NEW_MESSAGE)) {
      return false;
    }
  }
  return true;
}","private boolean showWarningMsg(String clusterName,List<String> warningMsgList){
  if (warningMsgList != null && !warningMsgList.isEmpty()) {
    for (    String message : warningMsgList) {
      System.out.println(message);
    }
    if (!isContinue(clusterName,Constants.OUTPUT_OP_CREATE,Constants.PARAM_PROMPT_CONTINUE_MESSAGE)) {
      return false;
    }
  }
  return true;
}"
49184,"public Long configCluster(String clusterName,ClusterCreate createSpec) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus());
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterConfigMgr.updateAppConfig(clusterName,createSpec);
  ConfigureClusterListener listener=new ConfigureClusterListener(clusterName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.CONFIGURING);
}","public Long configCluster(String clusterName,ClusterCreate createSpec) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.CONFIGURE_ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus());
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterConfigMgr.updateAppConfig(clusterName,createSpec);
  ConfigureClusterListener listener=new ConfigureClusterListener(clusterName);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.CONFIGURING);
}"
49185,"public Long deleteClusterByName(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())&& !ClusterStatus.PROVISION_ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.DELETION_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  DeleteClusterListener listener=new DeleteClusterListener(clusterName,networkManager);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.DELETING);
}","public Long deleteClusterByName(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster;
  if ((cluster=ClusterEntity.findClusterEntityByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())&& !ClusterStatus.PROVISION_ERROR.equals(cluster.getStatus())&& !ClusterStatus.CONFIGURE_ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.DELETION_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  DeleteClusterListener listener=new DeleteClusterListener(clusterName,networkManager);
  return createClusterMgmtTaskWithErrorSetting(cluster,listener,ClusterStatus.DELETING);
}"
49186,"@Override public void onFailure(){
  logger.debug(""String_Node_Str"");
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  AuAssert.check(cluster != null);
  cluster.setStatus(ClusterStatus.ERROR);
  DAL.inTransactionUpdate(cluster);
  logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
}","@Override public void onFailure(){
  logger.debug(""String_Node_Str"");
  ClusterEntity cluster=ClusterEntity.findClusterEntityByName(clusterName);
  AuAssert.check(cluster != null);
  cluster.setStatus(ClusterStatus.CONFIGURE_ERROR);
  DAL.inTransactionUpdate(cluster);
  logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
}"
49187,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void configCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CONFIG,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  try {
    ClusterRead clusterRead=restClient.get(name);
    ClusterCreate clusterConfig=new ClusterCreate();
    clusterConfig.setName(clusterRead.getName());
    ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
    clusterConfig.setNodeGroups(clusterSpec.getNodeGroups());
    clusterConfig.setConfiguration(clusterSpec.getConfiguration());
    if (!skipConfigValidation) {
      if (!validateConfiguration(clusterConfig)) {
        return;
      }
    }
 else {
      clusterConfig.setValidateConfig(false);
    }
    restClient.configCluster(clusterConfig);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CONFIG,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void configCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CONFIG,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  try {
    ClusterRead clusterRead=restClient.get(name);
    ClusterCreate clusterConfig=new ClusterCreate();
    clusterConfig.setName(clusterRead.getName());
    ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
    clusterConfig.setNodeGroups(clusterSpec.getNodeGroups());
    clusterConfig.setConfiguration(clusterSpec.getConfiguration());
    ValidateResult blackListResult=validateBlackList(clusterConfig);
    if (!skipConfigValidation) {
      ValidateResult whiteListResult=validateWhiteList(clusterConfig);
      if (!showWhiteListWarning(clusterConfig.getName(),whiteListResult)) {
        return;
      }
    }
 else {
      clusterConfig.setValidateConfig(false);
    }
    if (blackListResult != null) {
      showBlackListWarning(blackListResult);
    }
    restClient.configCluster(clusterConfig);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CONFIG);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CONFIG,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
}"
49188,"private boolean validateConfiguration(String levelName,Map<String,Object> configuration){
  ValidateResult validateResult=null;
  for (  ValidationType validationType : ValidationType.values()) {
    validateResult=AppConfigValidationUtils.validateConfig(validationType,configuration);
    if (validateResult.getType() != ValidateResult.Type.VALID) {
      String warningMsg=""String_Node_Str"";
      if (validateResult.getType() == ValidateResult.Type.NAME_IN_BLACK_LIST) {
        warningMsg=getValidateWarningMsg(levelName,validateResult.getFailureNames(),Constants.PARAM_CLUSTER_IN_BLACK_LIST_WARNING);
        System.out.println(warningMsg);
      }
 else       if (validateResult.getType() == ValidateResult.Type.WHITE_LIST_INVALID_NAME) {
        warningMsg=getValidateWarningMsg(levelName,validateResult.getFailureNames(),Constants.PARAM_CLUSTER_NOT_IN_WHITE_LIST_WARNING + Constants.PARAM_CLUSTER_NOT_IN_WHITE_LIST_WARNING_CONTINUE);
        if (!isContinue(levelName,Constants.OUTPUT_OP_CREATE,warningMsg)) {
          return false;
        }
      }
    }
  }
  return true;
}","private ValidateResult validateConfiguration(ClusterCreate cluster,ValidationType validationType){
  ValidateResult validateResult=new ValidateResult();
  ValidateResult vr=null;
  if (cluster.getConfiguration() != null && !cluster.getConfiguration().isEmpty()) {
    vr=AppConfigValidationUtils.validateConfig(validationType,cluster.getConfiguration());
    if (vr.getType() != ValidateResult.Type.VALID) {
      validateResult.setType(vr.getType());
      validateResult.setFailureNames(vr.getFailureNames());
    }
  }
  for (  NodeGroupCreate nodeGroup : cluster.getNodeGroups()) {
    if (nodeGroup.getConfiguration() != null && !nodeGroup.getConfiguration().isEmpty()) {
      vr=AppConfigValidationUtils.validateConfig(validationType,nodeGroup.getConfiguration());
      if (vr.getType() != ValidateResult.Type.VALID) {
        validateResult.setType(vr.getType());
        List<String> failureNames=new LinkedList<String>();
        failureNames.addAll(validateResult.getFailureNames());
        for (        String name : vr.getFailureNames()) {
          if (!failureNames.contains(name)) {
            failureNames.add(name);
          }
        }
        validateResult.setFailureNames(vr.getFailureNames());
      }
    }
  }
  return validateResult;
}"
49189,"private String getValidateWarningMsg(String levelName,List<String> failureNames,String warningMsg){
  StringBuilder warningMsgBuff=new StringBuilder();
  if (failureNames != null && !failureNames.isEmpty()) {
    warningMsgBuff.append(""String_Node_Str"");
    for (    String failureName : failureNames) {
      warningMsgBuff.append(failureName).append(""String_Node_Str"");
    }
    warningMsgBuff.delete(warningMsgBuff.length() - 2,warningMsgBuff.length());
    if (failureNames.size() > 1) {
      warningMsgBuff.append(""String_Node_Str"");
    }
 else {
      warningMsgBuff.append(""String_Node_Str"");
    }
    warningMsgBuff.append(warningMsg);
  }
  return warningMsgBuff.toString();
}","private String getValidateWarningMsg(List<String> failureNames,String warningMsg){
  StringBuilder warningMsgBuff=new StringBuilder();
  if (failureNames != null && !failureNames.isEmpty()) {
    warningMsgBuff.append(""String_Node_Str"");
    for (    String failureName : failureNames) {
      warningMsgBuff.append(failureName).append(""String_Node_Str"");
    }
    warningMsgBuff.delete(warningMsgBuff.length() - 2,warningMsgBuff.length());
    if (failureNames.size() > 1) {
      warningMsgBuff.append(""String_Node_Str"");
    }
 else {
      warningMsgBuff.append(""String_Node_Str"");
    }
    warningMsgBuff.append(warningMsg);
  }
  return warningMsgBuff.toString();
}"
49190,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      if (!skipConfigValidation) {
        if (!validateConfiguration(clusterCreate)) {
          return;
        }
      }
 else {
        clusterCreate.setValidateConfig(false);
      }
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (distro != null) {
    List<String> distroNames=getDistroNames();
    if (validName(distro,distroNames)) {
      clusterCreate.setDistro(distro);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
      return;
    }
  }
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  ValidateResult blackListResult=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      blackListResult=validateBlackList(clusterCreate);
      if (!skipConfigValidation) {
        ValidateResult whiteListResult=validateWhiteList(clusterCreate);
        if (!showWhiteListWarning(clusterCreate.getName(),whiteListResult)) {
          return;
        }
      }
 else {
        clusterCreate.setValidateConfig(false);
      }
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  List<String> networkNames=getNetworkNames();
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null) {
    if (!validateClusterCreate(clusterCreate)) {
      return;
    }
  }
  try {
    if (blackListResult != null) {
      showBlackListWarning(blackListResult);
    }
    restClient.create(clusterCreate);
    if (specFilePath == null) {
      createDefalutFile(clusterCreate);
    }
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
49191,"@SuppressWarnings(""String_Node_Str"") private static <T>void validateBySameFileName(String fileName,Object configProperties,List<Map<String,T>> warnPropertyList,ValidateResult validateResult,ValidationType validationType){
  for (  Map<String,T> warnPropertyFileMap : warnPropertyList) {
    if (warnPropertyFileMap.containsKey(fileName) && configProperties instanceof Map) {
      Map<String,Object> configPropertyMap=(Map<String,Object>)configProperties;
      for (      Entry<String,Object> configProperty : configPropertyMap.entrySet()) {
        if (validationType == ValidationType.WHITE_LIST) {
          for (          Entry<String,T> warnPropertyFileEntry : warnPropertyFileMap.entrySet()) {
            if (warnPropertyFileEntry.getValue() instanceof List) {
              List<Object> propertyList=(List<Object>)warnPropertyFileEntry.getValue();
              if (!validateWhiteListPropertis(propertyList,configProperty.getKey(),String.valueOf(configProperty.getValue()),validateResult)) {
              }
            }
          }
        }
 else         if (validationType == ValidationType.BLACK_LIST) {
          for (          Entry<String,T> warnPropertyFileEntry : warnPropertyFileMap.entrySet()) {
            if (warnPropertyFileEntry.getValue() instanceof List) {
              List<String> propertyList=(List<String>)warnPropertyFileEntry.getValue();
              for (              String propertyName : propertyList) {
                if (configProperty.getKey().equals(propertyName)) {
                  validateResult.setType(ValidateResult.Type.NAME_IN_BLACK_LIST);
                  validateResult.addFailureName(configProperty.getKey());
                }
              }
            }
          }
        }
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private static <T>void validateBySameFileName(String fileName,Object configProperties,List<Map<String,T>> warnPropertyList,ValidateResult validateResult,ValidationType validationType){
  for (  Map<String,T> warnPropertyFileMap : warnPropertyList) {
    if (warnPropertyFileMap.containsKey(fileName) && configProperties instanceof Map) {
      Map<String,Object> configPropertyMap=(Map<String,Object>)configProperties;
      List<String> removeList=new ArrayList<String>();
      for (      Entry<String,Object> configProperty : configPropertyMap.entrySet()) {
        if (validationType == ValidationType.WHITE_LIST) {
          for (          Entry<String,T> warnPropertyFileEntry : warnPropertyFileMap.entrySet()) {
            if (warnPropertyFileEntry.getValue() instanceof List) {
              List<Object> propertyList=(List<Object>)warnPropertyFileEntry.getValue();
              if (!validateWhiteListPropertis(propertyList,configProperty.getKey(),String.valueOf(configProperty.getValue()),validateResult)) {
              }
            }
          }
        }
 else         if (validationType == ValidationType.BLACK_LIST) {
          for (          Entry<String,T> warnPropertyFileEntry : warnPropertyFileMap.entrySet()) {
            if (warnPropertyFileEntry.getValue() instanceof List) {
              List<String> propertyList=(List<String>)warnPropertyFileEntry.getValue();
              for (              String propertyName : propertyList) {
                if (configProperty.getKey().equals(propertyName)) {
                  validateResult.setType(ValidateResult.Type.NAME_IN_BLACK_LIST);
                  validateResult.addFailureName(configProperty.getKey());
                  validateResult.putProperty(fileName,propertyName);
                  removeList.add(propertyName);
                }
              }
            }
          }
        }
      }
      for (      String pName : removeList) {
        configPropertyMap.remove(pName);
      }
    }
  }
}"
49192,"public void contextInitialized(Injector injector){
  org.candlepin.common.config.Configuration candlepinConfig=injector.getInstance(org.candlepin.common.config.Configuration.class);
  if (activeMQServer == null) {
    Configuration config=new ConfigurationImpl();
    HashSet<TransportConfiguration> transports=new HashSet<>();
    transports.add(new TransportConfiguration(InVMAcceptorFactory.class.getName()));
    config.setAcceptorConfigurations(transports);
    config.setClusterUser(null);
    config.setClusterPassword(null);
    config.setSecurityEnabled(false);
    config.setJournalType(JournalType.NIO);
    config.setCreateBindingsDir(true);
    config.setCreateJournalDir(true);
    String baseDir=candlepinConfig.getString(ConfigProperties.ACTIVEMQ_BASE_DIR);
    config.setBindingsDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setJournalDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setLargeMessagesDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setPagingDirectory(new File(baseDir,""String_Node_Str"").toString());
    Map<String,AddressSettings> settings=new HashMap<>();
    AddressSettings pagingConfig=new AddressSettings();
    String addressPolicyString=candlepinConfig.getString(ConfigProperties.ACTIVEMQ_ADDRESS_FULL_POLICY);
    long maxQueueSizeInMb=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_MAX_QUEUE_SIZE);
    long maxPageSizeInMb=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_MAX_PAGE_SIZE);
    AddressFullMessagePolicy addressPolicy=null;
    if (addressPolicyString.equals(""String_Node_Str"")) {
      addressPolicy=AddressFullMessagePolicy.PAGE;
    }
 else     if (addressPolicyString.equals(""String_Node_Str"")) {
      addressPolicy=AddressFullMessagePolicy.BLOCK;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + addressPolicyString + ""String_Node_Str"");
    }
    pagingConfig.setMaxSizeBytes(maxQueueSizeInMb * FileUtils.ONE_MB);
    if (addressPolicy == AddressFullMessagePolicy.PAGE) {
      pagingConfig.setPageSizeBytes(maxPageSizeInMb * FileUtils.ONE_MB);
    }
    pagingConfig.setAddressFullMessagePolicy(addressPolicy);
    settings.put(""String_Node_Str"",pagingConfig);
    config.setAddressesSettings(settings);
    int maxScheduledThreads=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_MAX_SCHEDULED_THREADS);
    int maxThreads=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_MAX_THREADS);
    if (maxThreads != -1) {
      config.setThreadPoolMaxSize(maxThreads);
    }
    if (maxScheduledThreads != -1) {
      config.setScheduledThreadPoolMaxSize(maxScheduledThreads);
    }
    int largeMsgSize=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_LARGE_MSG_SIZE);
    config.setJournalBufferSize_AIO(largeMsgSize);
    config.setJournalBufferSize_NIO(largeMsgSize);
    activeMQServer=new EmbeddedActiveMQ();
    activeMQServer.setConfiguration(config);
  }
  try {
    activeMQServer.start();
    log.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
  setupAmqp(injector,candlepinConfig);
  cleanupOldQueues();
  List<String> listeners=getActiveMQListeners(candlepinConfig);
  eventSource=injector.getInstance(EventSource.class);
  for (int i=0; i < listeners.size(); i++) {
    try {
      Class<?> clazz=this.getClass().getClassLoader().loadClass(listeners.get(i));
      eventSource.registerListener((EventListener)injector.getInstance(clazz));
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"" + listeners.get(i),e);
    }
  }
  EventSink sink=injector.getInstance(EventSink.class);
  try {
    sink.initialize();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
}","public void contextInitialized(Injector injector){
  org.candlepin.common.config.Configuration candlepinConfig=injector.getInstance(org.candlepin.common.config.Configuration.class);
  if (activeMQServer == null) {
    Configuration config=new ConfigurationImpl();
    HashSet<TransportConfiguration> transports=new HashSet<>();
    transports.add(new TransportConfiguration(InVMAcceptorFactory.class.getName()));
    config.setAcceptorConfigurations(transports);
    config.setClusterUser(null);
    config.setClusterPassword(null);
    config.setSecurityEnabled(false);
    config.setJournalType(JournalType.NIO);
    config.setCreateBindingsDir(true);
    config.setCreateJournalDir(true);
    String baseDir=candlepinConfig.getString(ConfigProperties.ACTIVEMQ_BASE_DIR);
    config.setBindingsDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setJournalDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setLargeMessagesDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setPagingDirectory(new File(baseDir,""String_Node_Str"").toString());
    Map<String,AddressSettings> settings=new HashMap<>();
    AddressSettings commonAddressConfig=new AddressSettings();
    String addressPolicyString=candlepinConfig.getString(ConfigProperties.ACTIVEMQ_ADDRESS_FULL_POLICY);
    long maxQueueSizeInMb=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_MAX_QUEUE_SIZE);
    long maxPageSizeInMb=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_MAX_PAGE_SIZE);
    AddressFullMessagePolicy addressPolicy=null;
    if (addressPolicyString.equals(""String_Node_Str"")) {
      addressPolicy=AddressFullMessagePolicy.PAGE;
    }
 else     if (addressPolicyString.equals(""String_Node_Str"")) {
      addressPolicy=AddressFullMessagePolicy.BLOCK;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + addressPolicyString + ""String_Node_Str"");
    }
    commonAddressConfig.setMaxSizeBytes(maxQueueSizeInMb * FileUtils.ONE_MB);
    if (addressPolicy == AddressFullMessagePolicy.PAGE) {
      commonAddressConfig.setPageSizeBytes(maxPageSizeInMb * FileUtils.ONE_MB);
    }
    commonAddressConfig.setAddressFullMessagePolicy(addressPolicy);
    configureMessageRetry(commonAddressConfig,candlepinConfig);
    settings.put(""String_Node_Str"",commonAddressConfig);
    config.setAddressesSettings(settings);
    int maxScheduledThreads=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_MAX_SCHEDULED_THREADS);
    int maxThreads=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_MAX_THREADS);
    if (maxThreads != -1) {
      config.setThreadPoolMaxSize(maxThreads);
    }
    if (maxScheduledThreads != -1) {
      config.setScheduledThreadPoolMaxSize(maxScheduledThreads);
    }
    int largeMsgSize=candlepinConfig.getInt(ConfigProperties.ACTIVEMQ_LARGE_MSG_SIZE);
    config.setJournalBufferSize_AIO(largeMsgSize);
    config.setJournalBufferSize_NIO(largeMsgSize);
    activeMQServer=new EmbeddedActiveMQ();
    activeMQServer.setConfiguration(config);
  }
  try {
    activeMQServer.start();
    log.info(""String_Node_Str"");
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
  setupAmqp(injector,candlepinConfig);
  cleanupOldQueues();
  List<String> listeners=getActiveMQListeners(candlepinConfig);
  eventSource=injector.getInstance(EventSource.class);
  for (int i=0; i < listeners.size(); i++) {
    try {
      Class<?> clazz=this.getClass().getClassLoader().loadClass(listeners.get(i));
      eventSource.registerListener((EventListener)injector.getInstance(clazz));
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"" + listeners.get(i),e);
    }
  }
  EventSink sink=injector.getInstance(EventSink.class);
  try {
    sink.initialize();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
}"
49193,"@Inject public EventSource(ObjectMapper mapper){
  this.mapper=mapper;
  try {
    factory=createSessionFactory();
    session=factory.createSession(true,true,0);
    session.start();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Inject public EventSource(ObjectMapper mapper){
  this.mapper=mapper;
  try {
    factory=createSessionFactory();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
49194,"protected void shutDown(){
  try {
    session.stop();
    session.close();
    factory.close();
  }
 catch (  ActiveMQException e) {
    log.warn(""String_Node_Str"",e);
  }
}","protected void shutDown(){
  closeEventReceivers();
  factory.close();
}"
49195,"void registerListener(EventListener listener){
  String queueName=QUEUE_ADDRESS + ""String_Node_Str"" + listener.getClass().getCanonicalName();
  log.debug(""String_Node_Str"",queueName);
  try {
    try {
      session.createQueue(QUEUE_ADDRESS,queueName,true);
      log.debug(""String_Node_Str"" + queueName);
    }
 catch (    ActiveMQException e) {
      if (e.getType() != ActiveMQExceptionType.QUEUE_EXISTS) {
        throw e;
      }
    }
    ClientConsumer consumer=session.createConsumer(queueName);
    consumer.setMessageHandler(new ListenerWrapper(listener,mapper));
  }
 catch (  ActiveMQException e) {
    log.error(""String_Node_Str"" + listener,e);
  }
}","void registerListener(EventListener listener) throws Exception {
  this.eventReceivers.add(new EventReceiver(listener,factory,mapper));
}"
49196,"public ListenerWrapper(EventListener listener,ObjectMapper mapper){
  this.listener=listener;
  this.mapper=mapper;
}","public ListenerWrapper(EventListener listener,ObjectMapper mapper,ClientSession session){
  this.listener=listener;
  this.mapper=mapper;
  this.session=session;
}"
49197,"@Override public void onMessage(ClientMessage msg){
  String body=msg.getBodyBuffer().readString();
  log.debug(""String_Node_Str"",body);
  try {
    Event event=mapper.readValue(body,Event.class);
    listener.onEvent(event);
  }
 catch (  JsonMappingException e) {
    log.error(""String_Node_Str"" + body,e);
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  JsonParseException e) {
    log.error(""String_Node_Str"" + body,e);
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    log.error(""String_Node_Str"" + body,e);
    throw new RuntimeException(""String_Node_Str"",e);
  }
  try {
    msg.acknowledge();
    log.debug(""String_Node_Str"" + listener);
  }
 catch (  ActiveMQException e) {
    log.error(""String_Node_Str"",e);
  }
}","@Override public void onMessage(ClientMessage msg){
  String body=""String_Node_Str"";
  try {
    msg.acknowledge();
    log.debug(""String_Node_Str"",msg.getMessageID(),listener);
    body=msg.getBodyBuffer().readString();
    log.debug(""String_Node_Str"",body);
    Event event=mapper.readValue(body,Event.class);
    listener.onEvent(event);
    session.commit();
  }
 catch (  Exception e) {
    String messageId=(msg == null) ? ""String_Node_Str"" : Long.toString(msg.getMessageID());
    String reason=(e.getCause() == null) ? e.getMessage() : e.getCause().getMessage();
    log.error(""String_Node_Str"",messageId,reason);
    log.debug(""String_Node_Str"",body,e);
    try {
      session.rollback();
    }
 catch (    ActiveMQException amqe) {
      log.error(""String_Node_Str"",amqe);
    }
  }
}"
49198,"/** 
 * Returns the true value of the autobindDisabled setting.
 * @return True if autobind is disabled for this owner, False or null otherwise.A value of null means that it is unset, and considered in code as False.
 */
@JsonProperty(""String_Node_Str"") public boolean isAutobindDisabled(){
  return autobindDisabled;
}","/** 
 * Checks if autobind is disabled for consumers of this owner/organization.
 * @return true if autobind is disabled for this owner/organization; false otherwise
 */
@JsonProperty(""String_Node_Str"") public boolean isAutobindDisabled(){
  return this.autobindDisabled != null ? this.autobindDisabled.booleanValue() : false;
}"
49199,"@Override public List<Pool> createPools(List<Pool> pools){
  if (CollectionUtils.isNotEmpty(pools)) {
    poolCurator.saveOrUpdateAll(pools,false,false);
    for (    Pool pool : pools) {
      log.debug(""String_Node_Str"",pool);
      if (pool != null) {
        sink.emitPoolCreated(pool);
      }
    }
  }
  return pools;
}","@Override public List<Pool> createPools(List<Pool> pools){
  if (CollectionUtils.isNotEmpty(pools)) {
    Set<String> updatedPoolIds=new HashSet<String>();
    for (    Pool pool : pools) {
      if (pool.getId() != null) {
        updatedPoolIds.add(pool.getId());
      }
    }
    poolCurator.saveOrUpdateAll(pools,false,false);
    for (    Pool pool : pools) {
      if (pool != null && !updatedPoolIds.contains(pool.getId())) {
        log.debug(""String_Node_Str"",pool);
        sink.emitPoolCreated(pool);
      }
 else {
        log.debug(""String_Node_Str"",pool);
      }
    }
  }
  return pools;
}"
49200,"@Override public Pool createPool(Pool pool){
  Pool created=poolCurator.create(pool);
  log.debug(""String_Node_Str"",pool);
  if (created != null) {
    sink.emitPoolCreated(created);
  }
  return created;
}","@Override public Pool createPool(Pool pool){
  if (pool != null) {
    if (pool.getId() == null) {
      pool=this.poolCurator.create(pool);
      log.debug(""String_Node_Str"",pool);
      if (pool != null) {
        sink.emitPoolCreated(pool);
      }
    }
 else {
      pool=this.poolCurator.merge(pool);
      log.debug(""String_Node_Str"",pool);
    }
  }
  return pool;
}"
49201,"@Override public void updateMasterPool(Pool pool){
  if (pool == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pool.getEndDate() != null && pool.getEndDate().before(new Date())) {
    List<String> subscriptions=new ArrayList<String>();
    subscriptions.add(pool.getSubscriptionId());
    this.deletePoolsForSubscriptions(subscriptions);
  }
 else {
    this.refreshPoolsForMasterPool(pool,false,true,Collections.<String,Product>emptyMap());
  }
}","@Override public void updateMasterPool(Pool pool){
  if (pool == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pool.getEndDate() != null && pool.getEndDate().before(new Date())) {
    this.deletePoolsForSubscriptions(Collections.<String>singletonList(pool.getSubscriptionId()));
  }
 else {
    this.refreshPoolsForMasterPool(pool,false,true,Collections.<String,Product>emptyMap());
  }
}"
49202,"@Transactional void refreshPoolsForMasterPool(Pool pool,boolean updateStackDerived,boolean lazy,Map<String,Product> changedProducts){
  List<Pool> subscriptionPools=poolCurator.getPoolsBySubscriptionId(pool.getSubscriptionId()).list();
  log.debug(""String_Node_Str"",subscriptionPools.size(),pool.getSubscriptionId());
  if (log.isDebugEnabled()) {
    for (    Pool p : subscriptionPools) {
      log.debug(""String_Node_Str"",p.getOwner().getKey(),p);
    }
  }
  for (  Pool subPool : subscriptionPools) {
    Product product=subPool.getProduct();
    if (product != null) {
      Product update=changedProducts.get(product.getId());
      if (update != null) {
        subPool.setProduct(update);
      }
    }
    product=subPool.getDerivedProduct();
    if (product != null) {
      Product update=changedProducts.get(product.getId());
      if (update != null) {
        subPool.setDerivedProduct(update);
      }
    }
  }
  removeAndDeletePoolsOnOtherOwners(subscriptionPools,pool);
  Long originalQuantity=pool.getQuantity();
  createAndEnrichPools(pool,subscriptionPools);
  Set<String> updatedMasterPools=updatePoolsForMasterPool(subscriptionPools,pool,originalQuantity,updateStackDerived,changedProducts);
  regenerateCertificatesByEntIds(updatedMasterPools,lazy);
}","@Transactional void refreshPoolsForMasterPool(Pool pool,boolean updateStackDerived,boolean lazy,Map<String,Product> changedProducts){
  List<Pool> subscriptionPools;
  if (pool.getSubscriptionId() != null) {
    subscriptionPools=this.poolCurator.getPoolsBySubscriptionId(pool.getSubscriptionId()).list();
  }
 else {
    subscriptionPools=pool.getId() != null ? Collections.<Pool>singletonList(this.poolCurator.find(pool.getId())) : Collections.<Pool>singletonList(pool);
  }
  log.debug(""String_Node_Str"",subscriptionPools.size(),pool.getSubscriptionId());
  if (log.isDebugEnabled()) {
    for (    Pool p : subscriptionPools) {
      log.debug(""String_Node_Str"",p.getOwner().getKey(),p);
    }
  }
  for (  Pool subPool : subscriptionPools) {
    Product product=subPool.getProduct();
    if (product != null) {
      Product update=changedProducts.get(product.getId());
      if (update != null) {
        subPool.setProduct(update);
      }
    }
    product=subPool.getDerivedProduct();
    if (product != null) {
      Product update=changedProducts.get(product.getId());
      if (update != null) {
        subPool.setDerivedProduct(update);
      }
    }
  }
  removeAndDeletePoolsOnOtherOwners(subscriptionPools,pool);
  Long originalQuantity=pool.getQuantity();
  createAndEnrichPools(pool,subscriptionPools);
  Set<String> updatedMasterPools=updatePoolsForMasterPool(subscriptionPools,pool,originalQuantity,updateStackDerived,changedProducts);
  regenerateCertificatesByEntIds(updatedMasterPools,lazy);
}"
49203,"private void postBindShareCreate(PoolManager poolManager,Consumer c,Map<String,Entitlement> entitlementMap){
  log.debug(""String_Node_Str"");
  Owner sharingOwner=c.getOwner();
  Owner recipient=ownerCurator.lookupByKey(c.getRecipientOwnerKey());
  List<Pool> sharedPoolsToCreate=new ArrayList<Pool>();
  for (  Entitlement entitlement : entitlementMap.values()) {
    Pool sourcePool=entitlement.getPool();
    Set<Product> allProducts=new HashSet<Product>();
    allProducts.add(sourcePool.getProduct());
    if (sourcePool.getProvidedProducts() != null) {
      allProducts.addAll(sourcePool.getProvidedProducts());
    }
    if (sourcePool.getDerivedProduct() != null) {
      allProducts.add(sourcePool.getDerivedProduct());
    }
    if (sourcePool.getDerivedProvidedProducts() != null) {
      allProducts.addAll(sourcePool.getDerivedProvidedProducts());
    }
    Map<String,Product> resolvedProducts=resolveProductShares(sharingOwner,recipient,allProducts);
    Product product=resolvedProducts.get(sourcePool.getProduct().getId());
    Set<Product> providedProducts=copySetFromResolved(sourcePool.getProvidedProducts(),resolvedProducts);
    Long q=Long.valueOf(entitlement.getQuantity());
    Date endDate=(entitlement.getEndDateOverride() == null) ? sourcePool.getEndDate() : entitlement.getEndDateOverride();
    Pool sharedPool=new Pool(recipient,product,providedProducts,q,sourcePool.getStartDate(),endDate,sourcePool.getContractNumber(),sourcePool.getAccountNumber(),sourcePool.getOrderNumber());
    if (sourcePool.getDerivedProduct() != null) {
      Product derivedProduct=resolvedProducts.get(sourcePool.getDerivedProduct().getId());
      sharedPool.setDerivedProduct(derivedProduct);
    }
    Set<Product> derivedProvidedProducts=copySetFromResolved(sourcePool.getDerivedProvidedProducts(),resolvedProducts);
    sharedPool.setDerivedProvidedProducts(derivedProvidedProducts);
    if (entitlement != null && entitlement.getPool() != null) {
      sharedPool.setSourceEntitlement(entitlement);
    }
    sharedPool.setSourceSubscription(new SourceSubscription(sourcePool.getSubscriptionId(),entitlement.getId()));
    for (    Entry<String,String> entry : sourcePool.getAttributes().entrySet()) {
      sharedPool.setAttribute(entry.getKey(),entry.getValue());
    }
    sharedPool.setAttribute(Pool.Attributes.DERIVED_POOL,""String_Node_Str"");
    sharedPool.setCreatedByShare(Boolean.TRUE);
    sharedPool.setHasSharedAncestor(Boolean.TRUE);
    for (    Branding b : sourcePool.getBranding()) {
      sharedPool.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
    }
    sharedPoolsToCreate.add(sharedPool);
  }
  if (CollectionUtils.isNotEmpty(sharedPoolsToCreate)) {
    poolManager.createPools(sharedPoolsToCreate);
  }
}","private void postBindShareCreate(PoolManager poolManager,Consumer c,Map<String,Entitlement> entitlementMap){
  log.debug(""String_Node_Str"");
  Owner sharingOwner=c.getOwner();
  Owner recipient=ownerCurator.lookupByKey(c.getRecipientOwnerKey());
  List<Pool> sharedPoolsToCreate=new ArrayList<Pool>();
  for (  Entitlement entitlement : entitlementMap.values()) {
    Pool sourcePool=entitlement.getPool();
    Set<Product> allProducts=new HashSet<Product>();
    allProducts.add(sourcePool.getProduct());
    if (sourcePool.getProvidedProducts() != null) {
      allProducts.addAll(sourcePool.getProvidedProducts());
    }
    if (sourcePool.getDerivedProduct() != null) {
      allProducts.add(sourcePool.getDerivedProduct());
    }
    if (sourcePool.getDerivedProvidedProducts() != null) {
      allProducts.addAll(sourcePool.getDerivedProvidedProducts());
    }
    Map<String,Product> resolvedProducts=resolveProductShares(sharingOwner,recipient,allProducts);
    Product product=resolvedProducts.get(sourcePool.getProduct().getId());
    Set<Product> providedProducts=copySetFromResolved(sourcePool.getProvidedProducts(),resolvedProducts);
    Long q=Long.valueOf(entitlement.getQuantity());
    Date endDate=(entitlement.getEndDateOverride() == null) ? sourcePool.getEndDate() : entitlement.getEndDateOverride();
    Pool sharedPool=new Pool(recipient,product,providedProducts,q,sourcePool.getStartDate(),endDate,sourcePool.getContractNumber(),sourcePool.getAccountNumber(),sourcePool.getOrderNumber());
    if (sourcePool.getDerivedProduct() != null) {
      Product derivedProduct=resolvedProducts.get(sourcePool.getDerivedProduct().getId());
      sharedPool.setDerivedProduct(derivedProduct);
    }
    Set<Product> derivedProvidedProducts=copySetFromResolved(sourcePool.getDerivedProvidedProducts(),resolvedProducts);
    sharedPool.setDerivedProvidedProducts(derivedProvidedProducts);
    if (entitlement != null && entitlement.getPool() != null) {
      sharedPool.setSourceEntitlement(entitlement);
    }
    String subscriptionId=sourcePool.getSubscriptionId();
    if (subscriptionId != null && !subscriptionId.isEmpty()) {
      sharedPool.setSourceSubscription(new SourceSubscription(subscriptionId,entitlement.getId()));
    }
    for (    Entry<String,String> entry : sourcePool.getAttributes().entrySet()) {
      sharedPool.setAttribute(entry.getKey(),entry.getValue());
    }
    sharedPool.setAttribute(Pool.Attributes.DERIVED_POOL,""String_Node_Str"");
    sharedPool.setCreatedByShare(Boolean.TRUE);
    sharedPool.setHasSharedAncestor(Boolean.TRUE);
    for (    Branding b : sourcePool.getBranding()) {
      sharedPool.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
    }
    sharedPoolsToCreate.add(sharedPool);
  }
  if (CollectionUtils.isNotEmpty(sharedPoolsToCreate)) {
    poolManager.createPools(sharedPoolsToCreate);
  }
}"
49204,"/** 
 * Create a pool only for virt guests of a particular host consumer.
 * @param pools Pools these host restricted pools are being derived from.
 * @return pools the created pools
 */
public static List<Pool> createHostRestrictedPools(PoolManager poolManager,Consumer consumer,List<Pool> pools,Map<String,Entitlement> sourceEntitlements,Map<String,Map<String,String>> attributeMaps,ProductCurator productCurator){
  List<Pool> poolsToCreate=new ArrayList<Pool>();
  List<Pool> poolsToUpdateFromStack=new ArrayList<Pool>();
  for (  Pool pool : pools) {
    Product product=pool.getProduct();
    Pool consumerSpecificPool=null;
    Map<String,String> attributes=attributeMaps.get(pool.getId());
    String quantity=attributes.get(""String_Node_Str"");
    if (pool.getDerivedProduct() == null) {
      consumerSpecificPool=createPool(product,pool.getOwner(),quantity,pool.getStartDate(),pool.getEndDate(),pool.getContractNumber(),pool.getAccountNumber(),pool.getOrderNumber(),productCurator.getPoolProvidedProductsCached(pool),sourceEntitlements.get(pool.getId()),pool.hasSharedAncestor());
    }
 else {
      consumerSpecificPool=createPool(pool.getDerivedProduct(),pool.getOwner(),quantity,pool.getStartDate(),pool.getEndDate(),pool.getContractNumber(),pool.getAccountNumber(),pool.getOrderNumber(),productCurator.getPoolDerivedProvidedProductsCached(pool),sourceEntitlements.get(pool.getId()),pool.hasSharedAncestor());
    }
    consumerSpecificPool.setAttribute(Pool.Attributes.REQUIRES_HOST,consumer.getUuid());
    consumerSpecificPool.setAttribute(Pool.Attributes.DERIVED_POOL,""String_Node_Str"");
    consumerSpecificPool.setAttribute(Pool.Attributes.VIRT_ONLY,""String_Node_Str"");
    consumerSpecificPool.setAttribute(Pool.Attributes.PHYSICAL_ONLY,""String_Node_Str"");
    if (pool.isStacked()) {
      poolsToUpdateFromStack.add(consumerSpecificPool);
    }
 else {
      consumerSpecificPool.setAttribute(Pool.Attributes.SOURCE_POOL_ID,pool.getId());
      consumerSpecificPool.setSourceSubscription(new SourceSubscription(pool.getSubscriptionId(),sourceEntitlements.get(pool.getId()).getId()));
    }
    poolsToCreate.add(consumerSpecificPool);
  }
  if (CollectionUtils.isNotEmpty(poolsToUpdateFromStack)) {
    poolManager.updatePoolsFromStack(consumer,poolsToUpdateFromStack);
  }
  return poolManager.createPools(poolsToCreate);
}","/** 
 * Create a pool only for virt guests of a particular host consumer.
 * @param pools Pools these host restricted pools are being derived from.
 * @return pools the created pools
 */
public static List<Pool> createHostRestrictedPools(PoolManager poolManager,Consumer consumer,List<Pool> pools,Map<String,Entitlement> sourceEntitlements,Map<String,Map<String,String>> attributeMaps,ProductCurator productCurator){
  List<Pool> poolsToCreate=new ArrayList<Pool>();
  List<Pool> poolsToUpdateFromStack=new ArrayList<Pool>();
  for (  Pool pool : pools) {
    Product product=pool.getProduct();
    Pool consumerSpecificPool=null;
    Map<String,String> attributes=attributeMaps.get(pool.getId());
    String quantity=attributes.get(""String_Node_Str"");
    if (pool.getDerivedProduct() == null) {
      consumerSpecificPool=createPool(product,pool.getOwner(),quantity,pool.getStartDate(),pool.getEndDate(),pool.getContractNumber(),pool.getAccountNumber(),pool.getOrderNumber(),productCurator.getPoolProvidedProductsCached(pool),sourceEntitlements.get(pool.getId()),pool.hasSharedAncestor());
    }
 else {
      consumerSpecificPool=createPool(pool.getDerivedProduct(),pool.getOwner(),quantity,pool.getStartDate(),pool.getEndDate(),pool.getContractNumber(),pool.getAccountNumber(),pool.getOrderNumber(),productCurator.getPoolDerivedProvidedProductsCached(pool),sourceEntitlements.get(pool.getId()),pool.hasSharedAncestor());
    }
    consumerSpecificPool.setAttribute(Pool.Attributes.REQUIRES_HOST,consumer.getUuid());
    consumerSpecificPool.setAttribute(Pool.Attributes.DERIVED_POOL,""String_Node_Str"");
    consumerSpecificPool.setAttribute(Pool.Attributes.VIRT_ONLY,""String_Node_Str"");
    consumerSpecificPool.setAttribute(Pool.Attributes.PHYSICAL_ONLY,""String_Node_Str"");
    if (pool.isStacked()) {
      poolsToUpdateFromStack.add(consumerSpecificPool);
    }
 else {
      consumerSpecificPool.setAttribute(Pool.Attributes.SOURCE_POOL_ID,pool.getId());
      String subscriptionId=pool.getSubscriptionId();
      if (subscriptionId != null && !subscriptionId.isEmpty()) {
        consumerSpecificPool.setSourceSubscription(new SourceSubscription(subscriptionId,sourceEntitlements.get(pool.getId()).getId()));
      }
    }
    poolsToCreate.add(consumerSpecificPool);
  }
  if (CollectionUtils.isNotEmpty(poolsToUpdateFromStack)) {
    poolManager.updatePoolsFromStack(consumer,poolsToUpdateFromStack);
  }
  return poolManager.createPools(poolsToCreate);
}"
49205,"/** 
 * Create any pools that need to be created for the given pool. In some scenarios, due to attribute changes, pools may need to be created even though pools already exist for the subscription. A list of pre-existing pools for the given sub are provided to help this method determine if something needs to be done or not. For a genuine new pool, the existing pools list will be empty.
 * @param masterPool
 * @param existingPools
 * @return a list of pools created for the given pool
 */
public List<Pool> createAndEnrichPools(Pool masterPool,List<Pool> existingPools){
  List<Pool> pools=new LinkedList<Pool>();
  long calculated=this.calculateQuantity(masterPool.getQuantity() != null ? masterPool.getQuantity() : 1,masterPool.getProduct(),masterPool.getUpstreamPoolId());
  masterPool.setQuantity(calculated);
  String virtOnly=masterPool.getProductAttributeValue(Product.Attributes.VIRT_ONLY);
  if (virtOnly != null && !virtOnly.isEmpty()) {
    masterPool.setAttribute(Pool.Attributes.VIRT_ONLY,virtOnly);
  }
 else {
    masterPool.removeAttribute(Pool.Attributes.VIRT_ONLY);
  }
  log.info(""String_Node_Str"",masterPool);
  if (!hasMasterPool(existingPools)) {
    if (masterPool.getSourceSubscription() != null && masterPool.getSourceSubscription().getSubscriptionSubKey().contentEquals(""String_Node_Str"")) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pools.add(masterPool);
    log.info(""String_Node_Str"",masterPool);
  }
  Pool bonusPool=createBonusPool(masterPool,existingPools);
  if (bonusPool != null) {
    pools.add(bonusPool);
  }
  return pools;
}","/** 
 * Create any pools that need to be created for the given pool. In some scenarios, due to attribute changes, pools may need to be created even though pools already exist for the subscription. A list of pre-existing pools for the given sub are provided to help this method determine if something needs to be done or not. For a genuine new pool, the existing pools list will be empty.
 * @param masterPool
 * @param existingPools
 * @return a list of pools created for the given pool
 */
public List<Pool> createAndEnrichPools(Pool masterPool,List<Pool> existingPools){
  List<Pool> pools=new LinkedList<Pool>();
  long calculated=this.calculateQuantity(masterPool.getQuantity() != null ? masterPool.getQuantity() : 1,masterPool.getProduct(),masterPool.getUpstreamPoolId());
  masterPool.setQuantity(calculated);
  String virtOnly=masterPool.getProductAttributeValue(Product.Attributes.VIRT_ONLY);
  if (virtOnly != null && !virtOnly.isEmpty()) {
    masterPool.setAttribute(Pool.Attributes.VIRT_ONLY,virtOnly);
  }
 else {
    masterPool.removeAttribute(Pool.Attributes.VIRT_ONLY);
  }
  log.info(""String_Node_Str"",masterPool);
  if (masterPool.getSubscriptionId() != null) {
    if (!hasMasterPool(existingPools)) {
      if (masterPool.getSubscriptionSubKey() != null && masterPool.getSubscriptionSubKey().contentEquals(""String_Node_Str"")) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      pools.add(masterPool);
      log.info(""String_Node_Str"",masterPool);
    }
  }
 else   if (masterPool.getId() == null) {
    pools.add(masterPool);
  }
  Pool bonusPool=createBonusPool(masterPool,existingPools);
  if (bonusPool != null) {
    pools.add(bonusPool);
  }
  return pools;
}"
49206,"@Test public void refreshPoolsCreatingPoolsForExistingSubscriptions(){
  List<Subscription> subscriptions=Util.newList();
  List<Pool> pools=Util.newList();
  Owner owner=this.getOwner();
  Product product=TestUtil.createProduct();
  product.setLocked(true);
  Subscription s=TestUtil.createSubscription(owner,product);
  subscriptions.add(s);
  mockSubsList(subscriptions);
  mockPoolsList(pools);
  List<Pool> newPools=new LinkedList<Pool>();
  Pool p=TestUtil.createPool(product);
  p.setId(""String_Node_Str"");
  p.setSourceSubscription(new SourceSubscription(s.getId(),""String_Node_Str""));
  newPools.add(p);
  ArgumentCaptor<Pool> argPool=ArgumentCaptor.forClass(Pool.class);
  when(poolRulesMock.createAndEnrichPools(argPool.capture(),any(List.class))).thenReturn(newPools);
  when(mockOwnerCurator.lookupByKey(owner.getKey())).thenReturn(owner);
  this.mockProducts(owner,product);
  this.mockProductImport(owner,product);
  this.mockContentImport(owner,new Content[]{});
  CandlepinQuery<Pool> cqmock=mock(CandlepinQuery.class);
  when(cqmock.list()).thenReturn(pools);
  when(cqmock.iterator()).thenReturn(pools.iterator());
  when(mockPoolCurator.listByOwnerAndType(eq(owner),any(PoolType.class))).thenReturn(cqmock);
  cqmock=mock(CandlepinQuery.class);
  when(cqmock.list()).thenReturn(Collections.<Pool>emptyList());
  when(mockPoolCurator.getPoolsBySubscriptionIds(anyList())).thenReturn(cqmock);
  cqmock=mock(CandlepinQuery.class);
  when(cqmock.list()).thenReturn(Collections.<Pool>emptyList());
  when(mockPoolCurator.getPoolsBySubscriptionId(anyString())).thenReturn(cqmock);
  this.manager.getRefresher(mockSubAdapter,mockOwnerAdapter).add(owner).run();
  TestUtil.assertPoolsAreEqual(TestUtil.copyFromSub(s),argPool.getValue());
  verify(this.mockPoolCurator,times(1)).create(any(Pool.class));
}","@Test public void refreshPoolsCreatingPoolsForExistingSubscriptions(){
  List<Subscription> subscriptions=Util.newList();
  List<Pool> pools=Util.newList();
  Owner owner=this.getOwner();
  Product product=TestUtil.createProduct();
  product.setLocked(true);
  Subscription s=TestUtil.createSubscription(owner,product);
  subscriptions.add(s);
  mockSubsList(subscriptions);
  mockPoolsList(pools);
  List<Pool> newPools=new LinkedList<Pool>();
  Pool p=TestUtil.createPool(product);
  p.setSourceSubscription(new SourceSubscription(s.getId(),""String_Node_Str""));
  newPools.add(p);
  ArgumentCaptor<Pool> argPool=ArgumentCaptor.forClass(Pool.class);
  when(poolRulesMock.createAndEnrichPools(argPool.capture(),any(List.class))).thenReturn(newPools);
  when(mockOwnerCurator.lookupByKey(owner.getKey())).thenReturn(owner);
  this.mockProducts(owner,product);
  this.mockProductImport(owner,product);
  this.mockContentImport(owner,new Content[]{});
  CandlepinQuery<Pool> cqmock=mock(CandlepinQuery.class);
  when(cqmock.list()).thenReturn(pools);
  when(cqmock.iterator()).thenReturn(pools.iterator());
  when(mockPoolCurator.listByOwnerAndType(eq(owner),any(PoolType.class))).thenReturn(cqmock);
  cqmock=mock(CandlepinQuery.class);
  when(cqmock.list()).thenReturn(Collections.<Pool>emptyList());
  when(mockPoolCurator.getPoolsBySubscriptionIds(anyList())).thenReturn(cqmock);
  cqmock=mock(CandlepinQuery.class);
  when(cqmock.list()).thenReturn(Collections.<Pool>emptyList());
  when(mockPoolCurator.getPoolsBySubscriptionId(anyString())).thenReturn(cqmock);
  this.manager.getRefresher(mockSubAdapter,mockOwnerAdapter).add(owner).run();
  TestUtil.assertPoolsAreEqual(TestUtil.copyFromSub(s),argPool.getValue());
  verify(this.mockPoolCurator,times(1)).create(any(Pool.class));
}"
49207,"protected String readPassphrase(String passphraseProperty) throws ConfigurationException {
  if (!containsKey(passphraseProperty)) {
    log.info(""String_Node_Str"");
    return null;
  }
  String secretFile=getString(passphraseProperty);
  if (StringUtils.isEmpty(secretFile)) {
    log.warn(""String_Node_Str"",passphraseProperty);
    return null;
  }
  log.debug(""String_Node_Str"",secretFile);
  try {
    InputStream bs=new FileInputStream(secretFile);
    return IOUtils.toString(bs,Charset.defaultCharset().name());
  }
 catch (  Exception e) {
    String msg=String.format(""String_Node_Str"",secretFile);
    log.error(msg);
    throw new ConfigurationException(msg,e);
  }
}","protected String readPassphrase(String passphraseProperty) throws ConfigurationException {
  if (!containsKey(passphraseProperty)) {
    log.info(""String_Node_Str"");
    return null;
  }
  String secretFile=getString(passphraseProperty);
  if (StringUtils.isEmpty(secretFile)) {
    log.warn(""String_Node_Str"",passphraseProperty);
    return null;
  }
  log.debug(""String_Node_Str"",secretFile);
  try (InputStream bs=new FileInputStream(secretFile)){
    return IOUtils.toString(bs,Charset.defaultCharset().name());
  }
 catch (  Exception e) {
    String msg=String.format(""String_Node_Str"",secretFile);
    log.error(msg);
    throw new ConfigurationException(msg,e);
  }
}"
49208,"@Override public Map<String,String> headers(){
  HashMap<String,String> negHeaders=new HashMap<String,String>();
  negHeaders.put(""String_Node_Str"",""String_Node_Str"");
  negHeaders.put(""String_Node_Str"",""String_Node_Str"");
  return negHeaders;
}","@Override public Map<String,String> headers(){
  HashMap<String,String> negHeaders=new HashMap<String,String>();
  negHeaders.put(""String_Node_Str"",""String_Node_Str"");
  return negHeaders;
}"
49209,"@Override public String interpolate(String messageTemplate,Context context,Locale locale){
  Map<String,Object> attrs=context.getConstraintDescriptor().getAttributes();
  ValidationMessage validationMessage=MESSAGES.get(messageTemplate);
  List<Object> paramList=new ArrayList<Object>();
  for (  String param : validationMessage.getParamNames()) {
    if (attrs.containsKey(param)) {
      paramList.add(attrs.get(param));
    }
 else {
      paramList.add(param);
    }
  }
  return i18nProvider.get().tr(validationMessage.getMessage(),paramList.toArray());
}","@Override public String interpolate(String messageTemplate,Context context,Locale locale){
  Map<String,Object> attrs=context.getConstraintDescriptor().getAttributes();
  ValidationMessage validationMessage=MESSAGES.get(messageTemplate);
  List<Object> paramList=new ArrayList<Object>();
  for (  String param : validationMessage.getParamNames()) {
    paramList.add(attrs.containsKey(param) ? attrs.get(param) : param);
  }
  return i18nProvider.get().tr(validationMessage.getMessage(),paramList.toArray());
}"
49210,"void registerListener(EventListener listener){
  String queueName=QUEUE_ADDRESS + ""String_Node_Str"" + listener.getClass().getCanonicalName();
  log.debug(""String_Node_Str"" + queueName);
  try {
    try {
      session.createQueue(QUEUE_ADDRESS,queueName,true);
      log.debug(""String_Node_Str"" + queueName);
    }
 catch (    ActiveMQException e) {
      if (e.getType() != ActiveMQExceptionType.QUEUE_EXISTS) {
        throw e;
      }
    }
    ClientConsumer consumer=session.createConsumer(queueName);
    consumer.setMessageHandler(new ListenerWrapper(listener,mapper));
  }
 catch (  ActiveMQException e) {
    log.error(""String_Node_Str"" + listener,e);
  }
}","void registerListener(EventListener listener){
  String queueName=QUEUE_ADDRESS + ""String_Node_Str"" + listener.getClass().getCanonicalName();
  log.debug(""String_Node_Str"",queueName);
  try {
    try {
      session.createQueue(QUEUE_ADDRESS,queueName,true);
      log.debug(""String_Node_Str"" + queueName);
    }
 catch (    ActiveMQException e) {
      if (e.getType() != ActiveMQExceptionType.QUEUE_EXISTS) {
        throw e;
      }
    }
    ClientConsumer consumer=session.createConsumer(queueName);
    consumer.setMessageHandler(new ListenerWrapper(listener,mapper));
  }
 catch (  ActiveMQException e) {
    log.error(""String_Node_Str"" + listener,e);
  }
}"
49211,"/** 
 * Revokes the given set of entitlements.
 * @param entsToRevoke entitlements to revoke
 * @param alreadyDeletedPools pools to skip deletion as they have already been deleted
 * @param regenCertsAndStatuses if this revocation should also trigger regeneration of certificatesand recomputation of statuses. For performance reasons some callers might choose to set this to false.
 */
@Transactional @Traceable public void revokeEntitlements(List<Entitlement> entsToRevoke,Set<String> alreadyDeletedPools,boolean regenCertsAndStatuses){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",getEntIds(entsToRevoke));
  }
  if (CollectionUtils.isEmpty(entsToRevoke)) {
    return;
  }
  List<Pool> poolsToDelete=poolCurator.listBySourceEntitlements(entsToRevoke);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",getPoolIds(poolsToDelete));
  }
  List<Pool> poolsToLock=new ArrayList<Pool>();
  poolsToLock.addAll(poolsToDelete);
  for (  Entitlement ent : entsToRevoke) {
    poolsToLock.add(ent.getPool());
    if (ent.getPool() != null && ent.getPool().isDevelopmentPool()) {
      poolsToDelete.add(ent.getPool());
    }
  }
  poolCurator.lockAndLoad(poolsToLock);
  log.info(""String_Node_Str"",entsToRevoke.size());
  entsToRevoke=new ArrayList<Entitlement>(entsToRevoke);
  for (  Pool pool : poolsToDelete) {
    for (    Entitlement ent : pool.getEntitlements()) {
      ent.setDeletedFromPool(true);
      entsToRevoke.add(ent);
    }
  }
  log.debug(""String_Node_Str"");
  List<Pool> poolsToSave=new ArrayList<Pool>();
  for (  Entitlement ent : entsToRevoke) {
    Pool pool=ent.getPool();
    int entQuantity=ent.getQuantity() != null ? ent.getQuantity() : 0;
    pool.setConsumed(pool.getConsumed() - entQuantity);
    Consumer consumer=ent.getConsumer();
    if (consumer.isManifestDistributor()) {
      pool.setExported(pool.getExported() - entQuantity);
    }
 else     if (consumer.isShare()) {
      pool.setShared(pool.getShared() - entQuantity);
    }
    consumer.setEntitlementCount(consumer.getEntitlementCount() - entQuantity);
    consumerCurator.update(consumer);
    poolsToSave.add(pool);
  }
  poolCurator.updateAll(poolsToSave,false,false);
  if (regenCertsAndStatuses) {
    log.debug(""String_Node_Str"");
    int update=this.entitlementCurator.markDependentEntitlementsDirty(entsToRevoke);
    log.debug(""String_Node_Str"",update);
  }
  log.info(""String_Node_Str"");
  poolCurator.batchDelete(poolsToDelete,alreadyDeletedPools);
  log.info(""String_Node_Str"");
  entitlementCurator.batchDelete(entsToRevoke);
  log.info(""String_Node_Str"");
  entitlementCurator.flush();
  log.info(""String_Node_Str"");
  Map<Consumer,List<Entitlement>> consumerSortedEntitlements=entitlementCurator.getDistinctConsumers(entsToRevoke);
  filterAndUpdateStackingEntitlements(consumerSortedEntitlements,alreadyDeletedPools);
  for (  Entitlement ent : entsToRevoke) {
    enforcer.postUnbind(ent.getConsumer(),this,ent);
  }
  if (!regenCertsAndStatuses) {
    log.info(""String_Node_Str"");
    sendDeletedEvents(entsToRevoke);
    return;
  }
  log.info(""String_Node_Str"",consumerSortedEntitlements.size());
  int i=1;
  for (  Consumer consumer : consumerSortedEntitlements.keySet()) {
    if (i++ % 1000 == 0) {
      consumerCurator.flush();
    }
    complianceRules.getStatus(consumer);
  }
  consumerCurator.flush();
  log.info(""String_Node_Str"");
  sendDeletedEvents(entsToRevoke);
}","/** 
 * Revokes the given set of entitlements.
 * @param entsToRevoke entitlements to revoke
 * @param alreadyDeletedPools pools to skip deletion as they have already been deleted
 * @param regenCertsAndStatuses if this revocation should also trigger regeneration of certificatesand recomputation of statuses. For performance reasons some callers might choose to set this to false.
 */
@Transactional @Traceable public void revokeEntitlements(List<Entitlement> entsToRevoke,Set<String> alreadyDeletedPools,boolean regenCertsAndStatuses){
  if (CollectionUtils.isEmpty(entsToRevoke)) {
    return;
  }
  log.debug(""String_Node_Str"",entsToRevoke.size());
  if (log.isTraceEnabled()) {
    log.trace(""String_Node_Str"",getEntIds(entsToRevoke));
  }
  Set<Pool> poolsToDelete=this.poolCurator.listBySourceEntitlements(entsToRevoke);
  log.debug(""String_Node_Str"",poolsToDelete.size());
  if (log.isTraceEnabled()) {
    log.trace(""String_Node_Str"",getPoolIds(poolsToDelete));
  }
  List<Pool> poolsToLock=new ArrayList<Pool>();
  poolsToLock.addAll(poolsToDelete);
  for (  Entitlement ent : entsToRevoke) {
    poolsToLock.add(ent.getPool());
    if (ent.getPool() != null && ent.getPool().isDevelopmentPool()) {
      poolsToDelete.add(ent.getPool());
    }
  }
  poolCurator.lockAndLoad(poolsToLock);
  log.info(""String_Node_Str"",entsToRevoke.size());
  entsToRevoke=new ArrayList<Entitlement>(entsToRevoke);
  for (  Pool pool : poolsToDelete) {
    for (    Entitlement ent : pool.getEntitlements()) {
      ent.setDeletedFromPool(true);
      entsToRevoke.add(ent);
    }
  }
  log.debug(""String_Node_Str"");
  List<Pool> poolsToSave=new ArrayList<Pool>();
  for (  Entitlement ent : entsToRevoke) {
    Pool pool=ent.getPool();
    int entQuantity=ent.getQuantity() != null ? ent.getQuantity() : 0;
    pool.setConsumed(pool.getConsumed() - entQuantity);
    Consumer consumer=ent.getConsumer();
    if (consumer.isManifestDistributor()) {
      pool.setExported(pool.getExported() - entQuantity);
    }
 else     if (consumer.isShare()) {
      pool.setShared(pool.getShared() - entQuantity);
    }
    consumer.setEntitlementCount(consumer.getEntitlementCount() - entQuantity);
    consumerCurator.update(consumer);
    poolsToSave.add(pool);
  }
  poolCurator.updateAll(poolsToSave,false,false);
  if (regenCertsAndStatuses) {
    log.debug(""String_Node_Str"");
    int update=this.entitlementCurator.markDependentEntitlementsDirty(entsToRevoke);
    log.debug(""String_Node_Str"",update);
  }
  log.info(""String_Node_Str"");
  poolCurator.batchDelete(poolsToDelete,alreadyDeletedPools);
  log.info(""String_Node_Str"");
  entitlementCurator.batchDelete(entsToRevoke);
  log.info(""String_Node_Str"");
  entitlementCurator.flush();
  log.info(""String_Node_Str"");
  Map<Consumer,List<Entitlement>> consumerSortedEntitlements=entitlementCurator.getDistinctConsumers(entsToRevoke);
  filterAndUpdateStackingEntitlements(consumerSortedEntitlements,alreadyDeletedPools);
  for (  Entitlement ent : entsToRevoke) {
    enforcer.postUnbind(ent.getConsumer(),this,ent);
  }
  if (!regenCertsAndStatuses) {
    log.info(""String_Node_Str"");
    sendDeletedEvents(entsToRevoke);
    return;
  }
  log.info(""String_Node_Str"",consumerSortedEntitlements.size());
  int i=1;
  for (  Consumer consumer : consumerSortedEntitlements.keySet()) {
    if (i++ % 1000 == 0) {
      consumerCurator.flush();
    }
    complianceRules.getStatus(consumer);
  }
  consumerCurator.flush();
  log.info(""String_Node_Str"");
  sendDeletedEvents(entsToRevoke);
}"
49212,"/** 
 * Return all pools referencing the given entitlements as their source entitlements. Works recursively. The method always takes the result and return all source entitlements of the pools. This method finds all the pools that have been created as direct consequence of creating some of ents. So for example bonus pools created as consequence of creating ents.
 * @param ents Entitlements for which we search the pools
 * @return Pools created as a result of creation of one of the ents.
 */
public List<Pool> listBySourceEntitlements(List<Entitlement> ents){
  if (ents.size() == 0) {
    return new ArrayList<Pool>();
  }
  List<Pool> results=createSecureCriteria().add(CPRestrictions.in(""String_Node_Str"",ents)).setFetchMode(""String_Node_Str"",FetchMode.JOIN).list();
  if (results == null) {
    results=new LinkedList<Pool>();
  }
  if (results.size() > 0) {
    List<Pool> pools=listBySourceEntitlements(convertPoolsToEntitlements(results));
    results.addAll(pools);
  }
  return results;
}","/** 
 * Return all pools referencing the given entitlements as their source entitlements. Works recursively. The method always takes the result and return all source entitlements of the pools. This method finds all the pools that have been created as direct consequence of creating some of ents. So for example bonus pools created as consequence of creating ents.
 * @param ents Entitlements for which we search the pools
 * @return Pools created as a result of creation of one of the ents.
 */
public Set<Pool> listBySourceEntitlements(Iterable<Entitlement> ents){
  if (ents == null || !ents.iterator().hasNext()) {
    return new HashSet<Pool>();
  }
  Set<Pool> output=new HashSet<Pool>();
  for (  List<Entitlement> block : this.partition(ents)) {
    List<Pool> pools=createSecureCriteria().add(CPRestrictions.in(""String_Node_Str"",block)).setFetchMode(""String_Node_Str"",FetchMode.JOIN).list();
    if (pools != null) {
      output.addAll(pools);
    }
  }
  if (output.size() > 0) {
    Set<Pool> pools=this.listBySourceEntitlements(convertPoolsToEntitlements(output));
    output.addAll(pools);
  }
  return output;
}"
49213,"private List<Entitlement> convertPoolsToEntitlements(List<Pool> pools){
  List<Entitlement> result=new ArrayList<Entitlement>();
  for (  Pool p : pools) {
    result.addAll(p.getEntitlements());
  }
  return result;
}","private Set<Entitlement> convertPoolsToEntitlements(Collection<Pool> pools){
  Set<Entitlement> output=new HashSet<Entitlement>();
  for (  Pool p : pools) {
    output.addAll(p.getEntitlements());
  }
  return output;
}"
49214,"@Test public void testBatchRevokeCleansUpCorrectPoolsWithSourceEnt() throws Exception {
  Consumer c=TestUtil.createConsumer(owner);
  Pool pool2=TestUtil.createPool(owner,product);
  Entitlement e=new Entitlement(pool,c,1);
  Entitlement e2=new Entitlement(pool2,c,1);
  Entitlement e3=new Entitlement(pool2,c,1);
  List<Entitlement> entsToDelete=Util.newList();
  entsToDelete.add(e);
  entsToDelete.add(e2);
  List<Pool> poolsWithSource=createPoolsWithSourceEntitlement(e,product);
  poolsWithSource.get(0).getEntitlements().add(e3);
  when(mockPoolCurator.listBySourceEntitlements(entsToDelete)).thenReturn(poolsWithSource);
  PreUnbindHelper preHelper=mock(PreUnbindHelper.class);
  ValidationResult result=new ValidationResult();
  when(preHelper.getResult()).thenReturn(result);
  when(mockConfig.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  when(mockPoolCurator.lockAndLoad(eq(pool))).thenReturn(pool);
  when(mockPoolCurator.lockAndLoad(eq(pool2))).thenReturn(pool2);
  manager.revokeEntitlements(entsToDelete);
  entsToDelete.add(e3);
  verify(entitlementCurator).batchDelete(eq(entsToDelete));
  verify(mockPoolCurator).batchDelete(eq(poolsWithSource),anySetOf(String.class));
}","@Test public void testBatchRevokeCleansUpCorrectPoolsWithSourceEnt() throws Exception {
  Consumer c=TestUtil.createConsumer(owner);
  Pool pool2=TestUtil.createPool(owner,product);
  Entitlement e=new Entitlement(pool,c,1);
  Entitlement e2=new Entitlement(pool2,c,1);
  Entitlement e3=new Entitlement(pool2,c,1);
  List<Entitlement> entsToDelete=Util.newList();
  entsToDelete.add(e);
  entsToDelete.add(e2);
  List<Pool> poolsWithSource=createPoolsWithSourceEntitlement(e,product);
  poolsWithSource.get(0).getEntitlements().add(e3);
  Set<Pool> poolsWithSourceAsSet=new HashSet<Pool>(poolsWithSource);
  when(mockPoolCurator.listBySourceEntitlements(entsToDelete)).thenReturn(poolsWithSourceAsSet);
  PreUnbindHelper preHelper=mock(PreUnbindHelper.class);
  ValidationResult result=new ValidationResult();
  when(preHelper.getResult()).thenReturn(result);
  when(mockConfig.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  when(mockPoolCurator.lockAndLoad(eq(pool))).thenReturn(pool);
  when(mockPoolCurator.lockAndLoad(eq(pool2))).thenReturn(pool2);
  manager.revokeEntitlements(entsToDelete);
  entsToDelete.add(e3);
  verify(entitlementCurator).batchDelete(eq(entsToDelete));
  verify(mockPoolCurator).batchDelete(eq(poolsWithSourceAsSet),anySetOf(String.class));
}"
49215,"@Test public void testListBySourceEntitlements(){
  Pool sourcePool=TestUtil.createPool(owner,product);
  Pool sourcePool2=TestUtil.createPool(owner,product);
  Pool sourcePool3=TestUtil.createPool(owner,product);
  poolCurator.create(sourcePool);
  poolCurator.create(sourcePool2);
  poolCurator.create(sourcePool3);
  Entitlement e=new Entitlement(sourcePool,consumer,1);
  e.setId(Util.generateDbUUID());
  Entitlement e2=new Entitlement(sourcePool2,consumer,1);
  e2.setId(Util.generateDbUUID());
  Entitlement e3=new Entitlement(sourcePool3,consumer,1);
  e3.setId(Util.generateDbUUID());
  entitlementCurator.create(e);
  entitlementCurator.create(e2);
  entitlementCurator.create(e3);
  Pool pool2=TestUtil.createPool(owner,product);
  pool2.setSourceEntitlement(e);
  Pool pool3=TestUtil.createPool(owner,product);
  pool3.setSourceEntitlement(e);
  Pool pool4=TestUtil.createPool(owner,product);
  pool4.setSourceEntitlement(e2);
  Pool pool5=TestUtil.createPool(owner,product);
  pool5.setSourceEntitlement(e3);
  poolCurator.create(pool2);
  poolCurator.create(pool3);
  poolCurator.create(pool4);
  poolCurator.create(pool5);
  List<Pool> pools=poolCurator.listBySourceEntitlements(Arrays.asList(e,e2));
  assertEquals(3,pools.size());
}","@Test public void testListBySourceEntitlements(){
  Pool sourcePool=TestUtil.createPool(owner,product);
  Pool sourcePool2=TestUtil.createPool(owner,product);
  Pool sourcePool3=TestUtil.createPool(owner,product);
  poolCurator.create(sourcePool);
  poolCurator.create(sourcePool2);
  poolCurator.create(sourcePool3);
  Entitlement e=new Entitlement(sourcePool,consumer,1);
  e.setId(Util.generateDbUUID());
  Entitlement e2=new Entitlement(sourcePool2,consumer,1);
  e2.setId(Util.generateDbUUID());
  Entitlement e3=new Entitlement(sourcePool3,consumer,1);
  e3.setId(Util.generateDbUUID());
  entitlementCurator.create(e);
  entitlementCurator.create(e2);
  entitlementCurator.create(e3);
  Pool pool2=TestUtil.createPool(owner,product);
  pool2.setSourceEntitlement(e);
  Pool pool3=TestUtil.createPool(owner,product);
  pool3.setSourceEntitlement(e);
  Pool pool4=TestUtil.createPool(owner,product);
  pool4.setSourceEntitlement(e2);
  Pool pool5=TestUtil.createPool(owner,product);
  pool5.setSourceEntitlement(e3);
  poolCurator.create(pool2);
  poolCurator.create(pool3);
  poolCurator.create(pool4);
  poolCurator.create(pool5);
  Set<Pool> pools=poolCurator.listBySourceEntitlements(Arrays.asList(e,e2));
  assertEquals(3,pools.size());
}"
49216,"/** 
 * Updates the pools using the information stored in the given pool. Because the input subscription is used to lookup pools, the ID field must be set for this method to operate properly.
 * @param pool The pool to use for updating the associated pools
 */
void updateMasterPool(Pool pool);","/** 
 * Applies changes to the given pool to itself and any of its derived pools. This may result in a deletion of the pool if it has been expired as a result of the changes.
 * @param pool The pool to update
 */
void updateMasterPool(Pool pool);"
49217,"/** 
 * Create any pools that need to be created for the given pool. In some scenarios, due to attribute changes, pools may need to be created even though pools already exist for the subscription. A list of pre-existing pools for the given sub are provided to help this method determine if something needs to be done or not. For a genuine new pool, the existing pools list will be empty.
 * @param masterPool
 * @param existingPools
 * @return a list of pools created for the given pool
 */
public List<Pool> createAndEnrichPools(Pool masterPool,List<Pool> existingPools){
  List<Pool> pools=new LinkedList<Pool>();
  masterPool.setQuantity(calculateQuantity(masterPool.getQuantity(),masterPool.getProduct(),masterPool.getUpstreamPoolId()));
  String virtOnly=masterPool.getProductAttributeValue(Product.Attributes.VIRT_ONLY);
  if (virtOnly != null && !virtOnly.isEmpty()) {
    masterPool.setAttribute(Pool.Attributes.VIRT_ONLY,virtOnly);
  }
  log.info(""String_Node_Str"",masterPool);
  if (!hasMasterPool(existingPools)) {
    if (masterPool.getSourceSubscription() != null && masterPool.getSourceSubscription().getSubscriptionSubKey().contentEquals(""String_Node_Str"")) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pools.add(masterPool);
    log.info(""String_Node_Str"",masterPool);
  }
  Pool bonusPool=createBonusPool(masterPool,existingPools);
  if (bonusPool != null) {
    pools.add(bonusPool);
  }
  return pools;
}","/** 
 * Create any pools that need to be created for the given pool. In some scenarios, due to attribute changes, pools may need to be created even though pools already exist for the subscription. A list of pre-existing pools for the given sub are provided to help this method determine if something needs to be done or not. For a genuine new pool, the existing pools list will be empty.
 * @param masterPool
 * @param existingPools
 * @return a list of pools created for the given pool
 */
public List<Pool> createAndEnrichPools(Pool masterPool,List<Pool> existingPools){
  List<Pool> pools=new LinkedList<Pool>();
  masterPool.setQuantity(calculateQuantity(masterPool.getQuantity(),masterPool.getProduct(),masterPool.getUpstreamPoolId()));
  String virtOnly=masterPool.getProductAttributeValue(Product.Attributes.VIRT_ONLY);
  if (virtOnly != null && !virtOnly.isEmpty()) {
    masterPool.setAttribute(Pool.Attributes.VIRT_ONLY,virtOnly);
  }
 else {
    masterPool.removeAttribute(Pool.Attributes.VIRT_ONLY);
  }
  log.info(""String_Node_Str"",masterPool);
  if (!hasMasterPool(existingPools)) {
    if (masterPool.getSourceSubscription() != null && masterPool.getSourceSubscription().getSubscriptionSubKey().contentEquals(""String_Node_Str"")) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    pools.add(masterPool);
    log.info(""String_Node_Str"",masterPool);
  }
  Pool bonusPool=createBonusPool(masterPool,existingPools);
  if (bonusPool != null) {
    pools.add(bonusPool);
  }
  return pools;
}"
49218,"/** 
 * Updates a pool for an Owner. assumes this is a normal pool, and errors out otherwise cause we cannot create master pools from bonus pools TODO: while this method replaces the now deprecated updateSubsciption, it still uses it underneath. We need to re-implement the wheel like we did in createPool
 * @httpcode 404
 * @httpcode 200
 */
@PUT @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") @ApiOperation(notes=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=404,message=""String_Node_Str"")}) public void updatePool(@PathParam(""String_Node_Str"") @Verify(Owner.class) String ownerKey,@ApiParam(name=""String_Node_Str"",required=true) Pool newPool){
  Pool currentPool=this.poolManager.find(newPool.getId());
  if (currentPool == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",newPool.getId()));
  }
  if (currentPool.getType() != PoolType.NORMAL || newPool.getType() != PoolType.NORMAL) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  if (currentPool.isCreatedByShare() || newPool.isCreatedByShare()) {
    throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  newPool.setProduct(currentPool.getProduct());
  newPool.setDerivedProduct(currentPool.getDerivedProduct());
  newPool=resolverUtil.resolvePool(newPool);
  this.poolManager.updateMasterPool(newPool);
}","/** 
 * Updates a pool for an Owner. assumes this is a normal pool, and errors out otherwise cause we cannot create master pools from bonus pools TODO: while this method replaces the now deprecated updateSubsciption, it still uses it underneath. We need to re-implement the wheel like we did in createPool
 * @httpcode 404
 * @httpcode 200
 */
@PUT @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") @ApiOperation(notes=""String_Node_Str"" + ""String_Node_Str"",value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=404,message=""String_Node_Str"")}) public void updatePool(@PathParam(""String_Node_Str"") @Verify(Owner.class) String ownerKey,@ApiParam(name=""String_Node_Str"",required=true) Pool newPool){
  Pool currentPool=this.poolManager.find(newPool.getId());
  if (currentPool == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",newPool.getId()));
  }
  if (currentPool.getOwner() == null || !ownerKey.equals(currentPool.getOwner().getKey())) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",newPool.getId()));
  }
  newPool.setOwner(currentPool.getOwner());
  if (currentPool.getType() != PoolType.NORMAL || newPool.getType() != PoolType.NORMAL) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  if (currentPool.isCreatedByShare() || newPool.isCreatedByShare()) {
    throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  newPool.setProduct(currentPool.getProduct());
  newPool.setDerivedProduct(currentPool.getDerivedProduct());
  newPool.setActiveSubscription(currentPool.getActiveSubscription());
  newPool.setCreatedByShare(currentPool.isCreatedByShare());
  newPool.setHasSharedAncestor(currentPool.hasSharedAncestor());
  newPool.setSourceEntitlement(currentPool.getSourceEntitlement());
  newPool.setSourceStack(currentPool.getSourceStack());
  newPool.setSourceSubscription(currentPool.getSourceSubscription());
  newPool.setEntitlements(currentPool.getEntitlements());
  newPool.setRestrictedToUsername(currentPool.getRestrictedToUsername());
  newPool.setContractNumber(currentPool.getContractNumber());
  newPool.setAccountNumber(currentPool.getAccountNumber());
  newPool.setOrderNumber(currentPool.getOrderNumber());
  newPool.setConsumed(currentPool.getConsumed());
  newPool.setExported(currentPool.getExported());
  newPool.setShared(currentPool.getShared());
  newPool.setUpstreamPoolId(currentPool.getUpstreamPoolId());
  newPool.setUpstreamEntitlementId(currentPool.getUpstreamEntitlementId());
  newPool.setUpstreamConsumerId(currentPool.getUpstreamConsumerId());
  newPool.setCertificate(currentPool.getCertificate());
  newPool.setCdn(currentPool.getCdn());
  if (newPool.getQuantity() == null) {
    newPool.setQuantity(currentPool.getQuantity());
  }
  if (newPool.getStartDate() == null) {
    newPool.setStartDate(currentPool.getStartDate());
  }
  if (newPool.getEndDate() == null) {
    newPool.setEndDate(currentPool.getEndDate());
  }
  if (newPool.getAttributes() == null) {
    newPool.setAttributes(currentPool.getAttributes());
  }
  if (newPool.getBranding() == null) {
    newPool.setBranding(currentPool.getBranding());
  }
  newPool=resolverUtil.resolvePool(newPool);
  this.poolManager.updateMasterPool(newPool);
}"
49219,"@Transactional public List<Pool> listSharedPoolsOf(Pool pool){
  return listByCriteria(currentSession().createCriteria(Pool.class).createAlias(""String_Node_Str"",""String_Node_Str"").createAlias(""String_Node_Str"",""String_Node_Str"").add(Restrictions.and(Restrictions.eq(""String_Node_Str"",Boolean.TRUE))).add(Restrictions.and(Restrictions.eq(""String_Node_Str"",pool))).addOrder(Order.desc(""String_Node_Str"")));
}","@Transactional public List<Pool> listSharedPoolsOf(Pool pool){
  return listByCriteria(currentSession().createCriteria(Pool.class).createAlias(""String_Node_Str"",""String_Node_Str"").createAlias(""String_Node_Str"",""String_Node_Str"").add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE)).add(Restrictions.eq(""String_Node_Str"",pool)).addOrder(Order.desc(""String_Node_Str"")));
}"
49220,"@Test public void testFetchSharedPoolsOf(){
  consumer=TestUtil.createConsumer(owner);
  ConsumerType share=new ConsumerType(""String_Node_Str"");
  consumer.setType(share);
  consumerTypeCurator.create(share);
  consumerCurator.create(consumer);
  Pool pool=createPool(owner,product,1L,TestUtil.createDate(2011,3,2),TestUtil.createDate(2055,3,2));
  poolCurator.create(pool);
  Pool pool2=createPool(owner,product,1L,TestUtil.createDate(2011,3,2),TestUtil.createDate(2055,3,2));
  poolCurator.create(pool2);
  Entitlement sourceEnt=new Entitlement(pool,consumer,1);
  sourceEnt.setId(Util.generateDbUUID());
  entitlementCurator.create(sourceEnt);
  pool.getEntitlements().add(sourceEnt);
  poolCurator.merge(pool);
  Pool sharedPool=createPool(owner,product,1L,TestUtil.createDate(2011,3,2),TestUtil.createDate(2055,3,2));
  sharedPool.setAttribute(Pool.Attributes.SHARE,""String_Node_Str"");
  sharedPool.setAttribute(Pool.Attributes.DERIVED_POOL,""String_Node_Str"");
  sharedPool.setSourceEntitlement(sourceEnt);
  poolCurator.create(sharedPool);
  Pool result=poolCurator.listSharedPoolsOf(pool).get(0);
  assertEquals(sharedPool,result);
}","@Test public void testFetchSharedPoolsOf(){
  consumer=TestUtil.createConsumer(owner);
  ConsumerType share=new ConsumerType(""String_Node_Str"");
  consumer.setType(share);
  consumerTypeCurator.create(share);
  consumerCurator.create(consumer);
  Pool pool=createPool(owner,product,1L,TestUtil.createDate(2011,3,2),TestUtil.createDate(2055,3,2));
  poolCurator.create(pool);
  Pool pool2=createPool(owner,product,1L,TestUtil.createDate(2011,3,2),TestUtil.createDate(2055,3,2));
  poolCurator.create(pool2);
  Entitlement sourceEnt=new Entitlement(pool,consumer,1);
  sourceEnt.setId(Util.generateDbUUID());
  entitlementCurator.create(sourceEnt);
  Set<Entitlement> entitlements=new HashSet<Entitlement>();
  entitlements.add(sourceEnt);
  pool.setEntitlements(entitlements);
  poolCurator.merge(pool);
  Pool sharedPool=createPool(owner,product,1L,TestUtil.createDate(2011,3,2),TestUtil.createDate(2055,3,2));
  sharedPool.setCreatedByShare(true);
  sharedPool.setAttribute(Pool.Attributes.DERIVED_POOL,""String_Node_Str"");
  sharedPool.setSourceEntitlement(sourceEnt);
  poolCurator.create(sharedPool);
  List<Pool> sharedPools=poolCurator.listSharedPoolsOf(pool);
  assertNotNull(sharedPools);
  assertTrue(sharedPools.size() > 0);
  Pool result=sharedPools.get(0);
  assertEquals(sharedPool,result);
}"
49221,"public long findNumRunningByClassAndTarget(String target,Class<? extends KingpinJob> jobClass){
  return (Long)this.currentSession().createCriteria(JobStatus.class).add(Restrictions.ge(""String_Node_Str"",getBlockingCutoff())).add(Restrictions.eq(""String_Node_Str"",JobState.RUNNING)).add(Restrictions.eq(""String_Node_Str"",target)).add(Restrictions.eq(""String_Node_Str"",jobClass)).setProjection(Projections.count(""String_Node_Str"")).uniqueResult();
}","public long findNumRunningByClassAndTarget(String target,Class<? extends KingpinJob> jobClass){
  if (jobClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (Long)this.currentSession().createCriteria(JobStatus.class).add(Restrictions.ge(""String_Node_Str"",getBlockingCutoff())).add(Restrictions.eq(""String_Node_Str"",JobState.RUNNING)).add(Restrictions.eq(""String_Node_Str"",target)).add(Restrictions.eq(""String_Node_Str"",jobClass.getCanonicalName())).setProjection(Projections.count(""String_Node_Str"")).uniqueResult();
}"
49222,"public JobStatus getByClassAndTarget(String target,Class<? extends KingpinJob> jobClass){
  return (JobStatus)this.currentSession().createCriteria(JobStatus.class).addOrder(Order.desc(""String_Node_Str"")).add(Restrictions.ge(""String_Node_Str"",getBlockingCutoff())).add(Restrictions.ne(""String_Node_Str"",JobState.FINISHED)).add(Restrictions.ne(""String_Node_Str"",JobState.FAILED)).add(Restrictions.ne(""String_Node_Str"",JobState.CANCELED)).add(Restrictions.eq(""String_Node_Str"",target)).add(Restrictions.eq(""String_Node_Str"",jobClass)).setMaxResults(1).uniqueResult();
}","public JobStatus getByClassAndTarget(String target,Class<? extends KingpinJob> jobClass){
  if (jobClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return (JobStatus)this.currentSession().createCriteria(JobStatus.class).addOrder(Order.desc(""String_Node_Str"")).add(Restrictions.ge(""String_Node_Str"",getBlockingCutoff())).add(Restrictions.ne(""String_Node_Str"",JobState.FINISHED)).add(Restrictions.ne(""String_Node_Str"",JobState.FAILED)).add(Restrictions.ne(""String_Node_Str"",JobState.CANCELED)).add(Restrictions.eq(""String_Node_Str"",target)).add(Restrictions.eq(""String_Node_Str"",jobClass.getCanonicalName())).setMaxResults(1).uniqueResult();
}"
49223,"@XmlTransient public Class<? extends KingpinJob> getJobClass(){
  return jobClass;
}","@XmlTransient public String getJobClass(){
  return jobClass;
}"
49224,"public String toString(){
  return String.format(""String_Node_Str"",this.id,this.jobClass != null ? this.jobClass.getSimpleName() : null,this.ownerId,this.targetId,this.targetType,this.state);
}","public String toString(){
  return String.format(""String_Node_Str"",this.id,this.jobClass != null ? this.jobClass : null,this.ownerId,this.targetId,this.targetType,this.state);
}"
49225,"public static boolean isSchedulable(JobCurator jobCurator,JobStatus status){
  long running=jobCurator.findNumRunningByClassAndTarget(status.getTargetId(),status.getJobClass());
  int throttle=conf.getInt(ConfigProperties.ENTITLER_JOB_THROTTLE);
  return running < throttle;
}","public static boolean isSchedulable(JobCurator jobCurator,JobStatus status){
  Class<? extends KingpinJob> jobClass;
  try {
    jobClass=(Class<? extends KingpinJob>)Class.forName(status.getJobClass());
  }
 catch (  ClassNotFoundException cnfe) {
    log.warn(""String_Node_Str"",status.getJobClass());
    return false;
  }
  long running=jobCurator.findNumRunningByClassAndTarget(status.getTargetId(),jobClass);
  int throttle=conf.getInt(ConfigProperties.ENTITLER_JOB_THROTTLE);
  return running < throttle;
}"
49226,"public static boolean isSchedulable(JobCurator jobCurator,JobStatus status){
  long running=jobCurator.findNumRunningByClassAndTarget(status.getTargetId(),status.getJobClass());
  return running == 0;
}","public static boolean isSchedulable(JobCurator jobCurator,JobStatus status){
  Class<? extends KingpinJob> jobClass;
  try {
    jobClass=(Class<? extends KingpinJob>)Class.forName(status.getJobClass());
  }
 catch (  ClassNotFoundException cnfe) {
    log.warn(""String_Node_Str"",status.getJobClass());
    return false;
  }
  long running=jobCurator.findNumRunningByClassAndTarget(status.getTargetId(),jobClass);
  return running == 0;
}"
49227,"@Override public void toExecute(JobExecutionContext ctx) throws JobExecutionException {
  List<JobStatus> waitingJobs;
  try {
    waitingJobs=jobCurator.findWaitingJobs().list();
  }
 catch (  HibernateException e) {
    log.error(""String_Node_Str"",e);
    throw new JobExecutionException(e);
  }
  for (  JobStatus j : waitingJobs) {
    try {
      boolean schedule=(Boolean)j.getJobClass().getMethod(""String_Node_Str"",JobCurator.class,JobStatus.class).invoke(null,jobCurator,j);
      if (schedule) {
        log.debug(""String_Node_Str"" + j.getId());
        pinsetterKernel.addTrigger(j);
        j.setState(JobState.CREATED);
        jobCurator.merge(j);
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"" + j.getId(),e);
    }
  }
}","@Override public void toExecute(JobExecutionContext ctx) throws JobExecutionException {
  List<JobStatus> waitingJobs;
  try {
    waitingJobs=jobCurator.findWaitingJobs().list();
  }
 catch (  HibernateException e) {
    log.error(""String_Node_Str"",e);
    throw new JobExecutionException(e);
  }
  for (  JobStatus j : waitingJobs) {
    try {
      Class jobClass=Class.forName(j.getJobClass());
      boolean schedule=(Boolean)jobClass.getMethod(""String_Node_Str"",JobCurator.class,JobStatus.class).invoke(null,jobCurator,j);
      if (schedule) {
        log.debug(""String_Node_Str"" + j.getId());
        pinsetterKernel.addTrigger(j);
        j.setState(JobState.CREATED);
        jobCurator.merge(j);
      }
    }
 catch (    ClassNotFoundException cnfe) {
      log.warn(""String_Node_Str"" + ""String_Node_Str"",j.getJobClass());
      j.setState(JobState.CANCELED);
      j.setResult(""String_Node_Str"");
      jobCurator.merge(j);
    }
catch (    Exception e) {
      log.error(""String_Node_Str"" + j.getId(),e);
    }
  }
}"
49228,"@Before public void init(){
  MockitoAnnotations.initMocks(this);
  unpauseJob=new UnpauseJob(j,pk);
}","@Before public void init(){
  MockitoAnnotations.initMocks(this);
  unpauseJob=new UnpauseJob(jobCurator,pk);
}"
49229,"@Test public void noUnPausesTest() throws JobExecutionException {
  when(j.findWaitingJobs()).thenReturn(new EmptyCandlepinQuery<JobStatus>());
  unpauseJob.execute(ctx);
  try {
    verify(pk,never()).addTrigger(any(JobStatus.class));
  }
 catch (  SchedulerException e) {
    fail(""String_Node_Str"");
  }
}","@Test public void noUnPausesTest() throws JobExecutionException {
  when(jobCurator.findWaitingJobs()).thenReturn(new EmptyCandlepinQuery<JobStatus>());
  unpauseJob.execute(ctx);
  try {
    verify(pk,never()).addTrigger(any(JobStatus.class));
  }
 catch (  SchedulerException e) {
    fail(""String_Node_Str"");
  }
}"
49230,"@Test public void unPauseTest() throws JobExecutionException, PinsetterException {
  JobDetail jd=newJob(KingpinJob.class).withIdentity(""String_Node_Str"",""String_Node_Str"").build();
  JobStatus js=new JobStatus(jd,true);
  List<JobStatus> jl=new ArrayList<JobStatus>();
  jl.add(js);
  CandlepinQuery query=mock(CandlepinQuery.class);
  when(query.list()).thenReturn(jl);
  when(j.findWaitingJobs()).thenReturn(query);
  unpauseJob.execute(ctx);
  try {
    verify(pk,atLeastOnce()).addTrigger(js);
  }
 catch (  SchedulerException e) {
    fail(""String_Node_Str"");
  }
}","@Test public void unPauseTest() throws JobExecutionException, PinsetterException {
  JobDetail jd=newJob(KingpinJob.class).withIdentity(""String_Node_Str"",""String_Node_Str"").build();
  JobStatus js=new JobStatus(jd,true);
  List<JobStatus> jl=new ArrayList<JobStatus>();
  jl.add(js);
  CandlepinQuery query=mock(CandlepinQuery.class);
  when(query.list()).thenReturn(jl);
  when(jobCurator.findWaitingJobs()).thenReturn(query);
  unpauseJob.execute(ctx);
  try {
    verify(pk,atLeastOnce()).addTrigger(js);
  }
 catch (  SchedulerException e) {
    fail(""String_Node_Str"");
  }
}"
49231,"@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"",response=Pool.class,responseContainer=""String_Node_Str"") @ApiResponses({@ApiResponse(code=400,message=""String_Node_Str"")}) @GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Iterator<Pool> getActivationKeyPools(@PathParam(""String_Node_Str"") String activationKeyId){
  ActivationKey key=activationKeyCurator.verifyAndLookupKey(activationKeyId);
  return new TransformedIterator<ActivationKeyPool,Pool>(key.getPools().iterator(),new ElementTransformer<ActivationKeyPool,Pool>(){
    @Override public Pool transform(    ActivationKeyPool akp){
      return akp.getPool();
    }
  }
);
}","@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"",response=Pool.class,responseContainer=""String_Node_Str"") @ApiResponses({@ApiResponse(code=400,message=""String_Node_Str"")}) @GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Iterator<Pool> getActivationKeyPools(@PathParam(""String_Node_Str"") @Verify(ActivationKey.class) String activationKeyId){
  ActivationKey key=activationKeyCurator.verifyAndLookupKey(activationKeyId);
  return new TransformedIterator<ActivationKeyPool,Pool>(key.getPools().iterator(),new ElementTransformer<ActivationKeyPool,Pool>(){
    @Override public Pool transform(    ActivationKeyPool akp){
      return akp.getPool();
    }
  }
);
}"
49232,"/** 
 * Cache for fully hydrated Product entities
 * @return Cache for Status entity
 */
public Cache<String,Product> getProductCache(){
  return cacheManager.getCache(CacheContextListener.CACHE_PRODUCT_FULL);
}","/** 
 * Cache for fully hydrated Product entities
 * @return Cache for Status entity
 */
public Cache<String,Product> getProductCache(){
  return cacheManager.getCache(CACHE_PRODUCT_FULL);
}"
49233,"@Inject public CandlepinCache(CacheManager cacheManager){
  this.cacheManager=cacheManager;
}","@Inject public CandlepinCache(CacheManager cacheManager){
  this.cacheManager=cacheManager;
  this.statusCache=new StatusCache();
}"
49234,"/** 
 * Retrieves Candlepin Status cache. This cache will be used only to cache status resource responses using single key STATUS_KEY
 * @return Cache for Status entity
 */
public Cache<String,Status> getStatusCache(){
  return cacheManager.getCache(CacheContextListener.CACHE_STATUS,String.class,Status.class);
}","/** 
 * Retrieves Candlepin Status cache. This cache will be used only to cache status resource responses.
 * @return StatusCache for Status entity
 */
public StatusCache getStatusCache(){
  return this.statusCache;
}"
49235,"@Override public void withInjector(Injector injector){
  insertValidationEventListeners(injector);
  ResourceLocatorMap map=injector.getInstance(ResourceLocatorMap.class);
  map.init();
  if (config.getBoolean(ConfigProperties.AMQP_INTEGRATION_ENABLED) && !config.getBoolean(ConfigProperties.SUSPEND_MODE_ENABLED)) {
    QpidQmf qmf=injector.getInstance(QpidQmf.class);
    QpidStatus status=qmf.getStatus();
    if (status != QpidStatus.CONNECTED) {
      log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",status);
      throw new RuntimeException(""String_Node_Str"" + status);
    }
  }
  cacheListener=injector.getInstance(CacheContextListener.class);
  cacheListener.contextInitialized(injector);
  if (config.getBoolean(ConfigProperties.AMQP_INTEGRATION_ENABLED) && config.getBoolean(ConfigProperties.SUSPEND_MODE_ENABLED)) {
    SuspendModeTransitioner mw=injector.getInstance(SuspendModeTransitioner.class);
    mw.transitionAppropriately();
    mw.startPeriodicExecutions();
  }
  if (config.getBoolean(HORNETQ_ENABLED)) {
    try {
      hornetqListener=injector.getInstance(HornetqContextListener.class);
      hornetqListener.contextInitialized(injector);
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
  if (config.getBoolean(ConfigProperties.CACHE_JMX_STATS)) {
    MBeanServer mBeanServer=ManagementFactory.getPlatformMBeanServer();
    ManagementService.registerMBeans(CacheManager.getInstance(),mBeanServer,true,true,true,true);
  }
  pinsetterListener=injector.getInstance(PinsetterContextListener.class);
  pinsetterListener.contextInitialized();
  loggerListener=injector.getInstance(LoggerContextListener.class);
  ModelConverters.getInstance().addConverter(injector.getInstance(CandlepinSwaggerModelConverter.class));
  this.injector=injector;
}","@Override public void withInjector(Injector injector){
  insertValidationEventListeners(injector);
  ResourceLocatorMap map=injector.getInstance(ResourceLocatorMap.class);
  map.init();
  if (config.getBoolean(ConfigProperties.AMQP_INTEGRATION_ENABLED) && !config.getBoolean(ConfigProperties.SUSPEND_MODE_ENABLED)) {
    QpidQmf qmf=injector.getInstance(QpidQmf.class);
    QpidStatus status=qmf.getStatus();
    if (status != QpidStatus.CONNECTED) {
      log.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",status);
      throw new RuntimeException(""String_Node_Str"" + status);
    }
  }
  if (config.getBoolean(ConfigProperties.AMQP_INTEGRATION_ENABLED) && config.getBoolean(ConfigProperties.SUSPEND_MODE_ENABLED)) {
    SuspendModeTransitioner mw=injector.getInstance(SuspendModeTransitioner.class);
    mw.transitionAppropriately();
    mw.startPeriodicExecutions();
  }
  if (config.getBoolean(HORNETQ_ENABLED)) {
    try {
      hornetqListener=injector.getInstance(HornetqContextListener.class);
      hornetqListener.contextInitialized(injector);
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
  if (config.getBoolean(ConfigProperties.CACHE_JMX_STATS)) {
    MBeanServer mBeanServer=ManagementFactory.getPlatformMBeanServer();
    ManagementService.registerMBeans(CacheManager.getInstance(),mBeanServer,true,true,true,true);
  }
  pinsetterListener=injector.getInstance(PinsetterContextListener.class);
  pinsetterListener.contextInitialized();
  loggerListener=injector.getInstance(LoggerContextListener.class);
  ModelConverters.getInstance().addConverter(injector.getInstance(CandlepinSwaggerModelConverter.class));
  this.injector=injector;
}"
49236,"/** 
 * Retrieves the Status of the System <p> <pre> { ""result"" : true, ""version"" : ""0.9.10"", ""rulesVersion"" : ""5.8"", ""release"" : ""1"", ""standalone"" : true, ""timeUTC"" : [date], ""managerCapabilities"" : [ ""cores"", ""ram"", ""instance_multiplier"" ], ""rulesSource"" : ""DEFAULT"" } </pre> <p> Status to see if a server is up and running
 * @return a Status object
 * @httpcode 200
 */
@GET @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",authorizations={}) @Produces({MediaType.APPLICATION_JSON}) @SecurityHole(noAuth=true,anon=true) public Status status(){
  Cache<String,Status> statusCache=candlepinCache.getStatusCache();
  Status cached=statusCache.get(CandlepinCache.STATUS_KEY);
  if (cached != null) {
    return cached;
  }
  boolean good=true;
  try {
    rulesCurator.getUpdatedFromDB();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    good=false;
  }
  CandlepinModeChange modeChange=modeManager.getLastCandlepinModeChange();
  if (modeChange.getMode() != Mode.NORMAL) {
    good=false;
  }
  Status status=new Status(good,version,release,standalone,jsProvider.getRulesVersion(),jsProvider.getRulesSource(),modeChange.getMode(),modeChange.getReason(),modeChange.getChangeTime());
  statusCache.put(CandlepinCache.STATUS_KEY,status);
  return status;
}","/** 
 * Retrieves the Status of the System <p> <pre> { ""result"" : true, ""version"" : ""0.9.10"", ""rulesVersion"" : ""5.8"", ""release"" : ""1"", ""standalone"" : true, ""timeUTC"" : [date], ""managerCapabilities"" : [ ""cores"", ""ram"", ""instance_multiplier"" ], ""rulesSource"" : ""DEFAULT"" } </pre> <p> Status to see if a server is up and running
 * @return a Status object
 * @httpcode 200
 */
@GET @ApiOperation(value=""String_Node_Str"",notes=""String_Node_Str"",authorizations={}) @Produces({MediaType.APPLICATION_JSON}) @SecurityHole(noAuth=true,anon=true) public Status status(){
  StatusCache statusCache=candlepinCache.getStatusCache();
  Status cached=statusCache.getStatus();
  if (cached != null) {
    return cached;
  }
  boolean good=true;
  try {
    rulesCurator.getUpdatedFromDB();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    good=false;
  }
  CandlepinModeChange modeChange=modeManager.getLastCandlepinModeChange();
  if (modeChange.getMode() != Mode.NORMAL) {
    good=false;
  }
  Status status=new Status(good,version,release,standalone,jsProvider.getRulesVersion(),jsProvider.getRulesSource(),modeChange.getMode(),modeChange.getReason(),modeChange.getChangeTime());
  statusCache.setStatus(status);
  return status;
}"
49237,"@Override public void configure(){
  bindScope(TestSingleton.class,TestScope.SINGLETON);
  CandlepinCache mockedCandlepinCache=mock(CandlepinCache.class);
  when(mockedCandlepinCache.getProductCache()).thenReturn(mock(Cache.class));
  when(mockedCandlepinCache.getStatusCache()).thenReturn(mock(Cache.class));
  bind(Configuration.class).toInstance(config);
  bind(CandlepinCache.class).toInstance(mockedCandlepinCache);
  CandlepinRequestScope requestScope=new CandlepinRequestScope();
  bindScope(CandlepinRequestScoped.class,requestScope);
  bindScope(RequestScoped.class,new TestingRequestScope());
  bind(CandlepinRequestScope.class).toInstance(requestScope);
  bind(X509ExtensionUtil.class);
  bind(ConsumerResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(EnvironmentResource.class);
  bind(SubscriptionResource.class);
  bind(ActivationKeyResource.class);
  bind(ProductServiceAdapter.class).to(DefaultProductServiceAdapter.class);
  bind(ProductResource.class);
  bind(DateSource.class).to(DateSourceForTesting.class).asEagerSingleton();
  bind(Enforcer.class).to(EnforcerForTesting.class);
  bind(SubjectKeyIdentifierWriter.class).to(DefaultSubjectKeyIdentifierWriter.class);
  bind(PKIUtility.class).to(BouncyCastlePKIUtility.class);
  bind(PKIReader.class).to(PKIReaderForTesting.class).asEagerSingleton();
  bind(SubscriptionServiceAdapter.class).to(ImportSubscriptionServiceAdapter.class);
  bind(OwnerServiceAdapter.class).to(DefaultOwnerServiceAdapter.class);
  bind(EntitlementCertServiceAdapter.class).to(StubEntitlementCertServiceAdapter.class);
  bind(ManifestFileService.class).to(DBManifestService.class);
  bind(ContentAccessCertServiceAdapter.class).to(DefaultContentAccessCertServiceAdapter.class);
  bind(ScriptEngineProvider.class);
  bind(JobFactory.class).to(GuiceJobFactory.class);
  bind(JobListener.class).to(PinsetterJobListener.class);
  bind(UserServiceAdapter.class).to(DefaultUserServiceAdapter.class);
  bind(JsRunnerProvider.class).asEagerSingleton();
  bind(JsRunner.class).toProvider(JsRunnerProvider.class);
  bind(PrincipalProvider.class).to(TestPrincipalProvider.class);
  bind(Principal.class).toProvider(TestPrincipalProvider.class);
  bind(EventSink.class).to(NoopEventSinkImpl.class);
  bind(ExportExtensionAdapter.class).to(DefaultExportExtensionAdapter.class);
  bind(ResourceLocatorMap.class);
  bind(StoreFactory.class);
  VerifyAuthorizationFilterFactory amf=new VerifyAuthorizationFilterFactory();
  requestInjection(amf);
  authMethodInterceptor=new TestingInterceptor(amf);
  bind(TestingInterceptor.class).toInstance(authMethodInterceptor);
  bindInterceptor(Matchers.inPackage(Package.getPackage(""String_Node_Str"")),new HttpMethodMatcher(),authMethodInterceptor);
  bind(CertificateRevocationListTask.class);
  bind(IdentityCertServiceAdapter.class).to(DefaultIdentityCertServiceAdapter.class);
  bind(PoolRules.class);
  bind(CriteriaRules.class);
  bind(PoolManager.class).to(CandlepinPoolManager.class);
  bind(UniqueIdGenerator.class).to(DefaultUniqueIdGenerator.class);
  bind(Function.class).annotatedWith(Names.named(""String_Node_Str"")).to(ExpiryDateFunction.class).in(Singleton.class);
  bind(ModeManager.class).to(ModeManagerImpl.class).asEagerSingleton();
  bind(TriggerListener.class).to(PinsetterTriggerListener.class);
}","@Override public void configure(){
  bindScope(TestSingleton.class,TestScope.SINGLETON);
  CandlepinCache mockedCandlepinCache=mock(CandlepinCache.class);
  when(mockedCandlepinCache.getProductCache()).thenReturn(mock(Cache.class));
  when(mockedCandlepinCache.getStatusCache()).thenReturn(mock(StatusCache.class));
  bind(Configuration.class).toInstance(config);
  bind(CandlepinCache.class).toInstance(mockedCandlepinCache);
  CandlepinRequestScope requestScope=new CandlepinRequestScope();
  bindScope(CandlepinRequestScoped.class,requestScope);
  bindScope(RequestScoped.class,new TestingRequestScope());
  bind(CandlepinRequestScope.class).toInstance(requestScope);
  bind(X509ExtensionUtil.class);
  bind(ConsumerResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(EnvironmentResource.class);
  bind(SubscriptionResource.class);
  bind(ActivationKeyResource.class);
  bind(ProductServiceAdapter.class).to(DefaultProductServiceAdapter.class);
  bind(ProductResource.class);
  bind(DateSource.class).to(DateSourceForTesting.class).asEagerSingleton();
  bind(Enforcer.class).to(EnforcerForTesting.class);
  bind(SubjectKeyIdentifierWriter.class).to(DefaultSubjectKeyIdentifierWriter.class);
  bind(PKIUtility.class).to(BouncyCastlePKIUtility.class);
  bind(PKIReader.class).to(PKIReaderForTesting.class).asEagerSingleton();
  bind(SubscriptionServiceAdapter.class).to(ImportSubscriptionServiceAdapter.class);
  bind(OwnerServiceAdapter.class).to(DefaultOwnerServiceAdapter.class);
  bind(EntitlementCertServiceAdapter.class).to(StubEntitlementCertServiceAdapter.class);
  bind(ManifestFileService.class).to(DBManifestService.class);
  bind(ContentAccessCertServiceAdapter.class).to(DefaultContentAccessCertServiceAdapter.class);
  bind(ScriptEngineProvider.class);
  bind(JobFactory.class).to(GuiceJobFactory.class);
  bind(JobListener.class).to(PinsetterJobListener.class);
  bind(UserServiceAdapter.class).to(DefaultUserServiceAdapter.class);
  bind(JsRunnerProvider.class).asEagerSingleton();
  bind(JsRunner.class).toProvider(JsRunnerProvider.class);
  bind(PrincipalProvider.class).to(TestPrincipalProvider.class);
  bind(Principal.class).toProvider(TestPrincipalProvider.class);
  bind(EventSink.class).to(NoopEventSinkImpl.class);
  bind(ExportExtensionAdapter.class).to(DefaultExportExtensionAdapter.class);
  bind(ResourceLocatorMap.class);
  bind(StoreFactory.class);
  VerifyAuthorizationFilterFactory amf=new VerifyAuthorizationFilterFactory();
  requestInjection(amf);
  authMethodInterceptor=new TestingInterceptor(amf);
  bind(TestingInterceptor.class).toInstance(authMethodInterceptor);
  bindInterceptor(Matchers.inPackage(Package.getPackage(""String_Node_Str"")),new HttpMethodMatcher(),authMethodInterceptor);
  bind(CertificateRevocationListTask.class);
  bind(IdentityCertServiceAdapter.class).to(DefaultIdentityCertServiceAdapter.class);
  bind(PoolRules.class);
  bind(CriteriaRules.class);
  bind(PoolManager.class).to(CandlepinPoolManager.class);
  bind(UniqueIdGenerator.class).to(DefaultUniqueIdGenerator.class);
  bind(Function.class).annotatedWith(Names.named(""String_Node_Str"")).to(ExpiryDateFunction.class).in(Singleton.class);
  bind(ModeManager.class).to(ModeManagerImpl.class).asEagerSingleton();
  bind(TriggerListener.class).to(PinsetterTriggerListener.class);
}"
49238,"@Inject public CdnManager(CdnCurator cdnCurator,CertificateSerialCurator certSerialCurator){
  this.cdnCurator=cdnCurator;
  this.certSerialCurator=certSerialCurator;
}","@Inject public CdnManager(CdnCurator cdnCurator,PoolCurator poolCurator,CertificateSerialCurator certSerialCurator){
  this.cdnCurator=cdnCurator;
  this.certSerialCurator=certSerialCurator;
  this.poolCurator=poolCurator;
}"
49239,"/** 
 * Deletes the specified   {@link Cdn}.
 * @param cdn the cdn to delete.
 */
@Transactional public void deleteCdn(Cdn cdn){
  cdnCurator.delete(cdn);
}","/** 
 * Deletes the specified   {@link Cdn}.
 * @param cdn the cdn to delete.
 */
@Transactional public void deleteCdn(Cdn cdn){
  poolCurator.removeCdn(cdn);
  cdnCurator.delete(cdn);
}"
49240,"/** 
 * Fetches a collection of content used by the given products
 * @param products The products for which to fetch content
 * @return A collection of content used by the specified products
 */
@SuppressWarnings(""String_Node_Str"") public CandlepinQuery<Content> getContentByProducts(Collection<Product> products){
  if (products != null && !products.isEmpty()) {
    Session session=this.currentSession();
    List<String> uuids=session.createCriteria(ProductContent.class).add(CPRestrictions.in(""String_Node_Str"",products)).setProjection(Projections.distinct(Projections.property(""String_Node_Str""))).list();
    if (uuids != null && !uuids.isEmpty()) {
      DetachedCriteria criteria=this.createSecureDetachedCriteria().add(CPRestrictions.in(""String_Node_Str"",uuids));
      return this.cpQueryFactory.<Content>buildQuery(session,criteria);
    }
  }
  return this.cpQueryFactory.<Content>buildQuery();
}","/** 
 * Fetches a collection of content used by the given products
 * @param products The products for which to fetch content
 * @return A collection of content used by the specified products
 */
@SuppressWarnings(""String_Node_Str"") public CandlepinQuery<Content> getContentByProducts(Collection<Product> products){
  Collection<String> uuids=new HashSet<String>();
  for (  Product product : products) {
    uuids.add(product.getUuid());
  }
  return this.getContentByProductUuids(uuids);
}"
49241,"/** 
 * Migrates content data.
 */
@SuppressWarnings(""String_Node_Str"") protected void migrateContentData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"");
  List<Object[]> contentRows=new LinkedList<Object[]>();
  Set<String> uuidCache=new HashSet<String>();
  ResultSet contentInfo=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid);
  while (contentInfo.next()) {
    String contentId=contentInfo.getString(1);
    String contentUuid=this.migratedContent.get(contentId);
    if (contentUuid == null) {
      this.logger.info(""String_Node_Str"",contentId);
      contentUuid=this.generateUUID();
      contentRows.add(new Object[]{contentUuid,contentInfo.getObject(1),contentInfo.getObject(2),contentInfo.getObject(3),contentInfo.getObject(4),contentInfo.getObject(5),contentInfo.getObject(6),contentInfo.getObject(7),contentInfo.getObject(8),contentInfo.getObject(9),contentInfo.getObject(10),contentInfo.getObject(11),contentInfo.getObject(12),contentInfo.getObject(13),0});
      this.migratedContent.put(contentId,contentUuid);
    }
    uuidCache.add(contentUuid);
  }
  contentInfo.close();
  if (contentRows.size() > 0) {
    PreparedStatement statement=this.generateBulkInsertStatement(""String_Node_Str"",contentRows.size(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    int index=0;
    for (    Object[] row : contentRows) {
      for (      Object col : row) {
        this.setParameter(statement,++index,col);
      }
    }
    int count=statement.executeUpdate();
    if (count != contentRows.size()) {
      String errmsg=String.format(""String_Node_Str"",contentRows.size(),count);
      this.logger.error(errmsg);
      throw new DatabaseException(errmsg);
    }
    this.logger.info(""String_Node_Str"",count);
    statement.close();
  }
  if (uuidCache.size() > 0) {
    PreparedStatement statement=this.generateBulkInsertStatement(""String_Node_Str"",uuidCache.size(),""String_Node_Str"",""String_Node_Str"");
    int index=0;
    for (    String cid : uuidCache) {
      this.setParameter(statement,++index,orgid);
      this.setParameter(statement,++index,cid);
    }
    int count=statement.executeUpdate();
    if (count != uuidCache.size()) {
      String errmsg=String.format(""String_Node_Str"",orgid,uuidCache.size(),count);
      this.logger.error(errmsg);
      throw new DatabaseException(errmsg);
    }
    this.logger.info(""String_Node_Str"",count);
    statement.close();
  }
}","/** 
 * Migrates content data.
 */
@SuppressWarnings(""String_Node_Str"") protected void migrateContentData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"");
  List<Object[]> contentRows=new LinkedList<Object[]>();
  Set<String> uuidCache=new HashSet<String>();
  ResultSet contentInfo=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid);
  int maxrows=MAX_PARAMETERS_PER_STATEMENT / 15;
  while (contentInfo.next()) {
    String contentId=contentInfo.getString(1);
    String contentUuid=this.migratedContent.get(contentId);
    if (contentUuid == null) {
      this.logger.info(""String_Node_Str"",contentId);
      contentUuid=this.generateUUID();
      contentRows.add(new Object[]{contentUuid,contentInfo.getObject(1),contentInfo.getObject(2),contentInfo.getObject(3),contentInfo.getObject(4),contentInfo.getObject(5),contentInfo.getObject(6),contentInfo.getObject(7),contentInfo.getObject(8),contentInfo.getObject(9),contentInfo.getObject(10),contentInfo.getObject(11),contentInfo.getObject(12),contentInfo.getObject(13),0});
      if (contentRows.size() > maxrows) {
        this.bulkInsertContentData(contentRows);
        contentRows.clear();
      }
      this.migratedContent.put(contentId,contentUuid);
    }
    uuidCache.add(contentUuid);
  }
  contentInfo.close();
  this.bulkInsertContentData(contentRows);
  contentRows.clear();
  if (uuidCache.size() > 0) {
    maxrows=MAX_PARAMETERS_PER_STATEMENT / 2;
    int lastBlock=0;
    int blockSize=maxrows / 2;
    Iterator<String> uuidIterator=uuidCache.iterator();
    PreparedStatement statement=null;
    for (int offset=0; offset < uuidCache.size(); offset+=blockSize) {
      int remaining=Math.min(uuidCache.size() - offset,blockSize);
      if (remaining != lastBlock) {
        if (statement != null) {
          statement.close();
        }
        statement=this.generateBulkInsertStatement(""String_Node_Str"",remaining,""String_Node_Str"",""String_Node_Str"");
        lastBlock=remaining;
      }
      int index=0;
      while (remaining-- > 0) {
        this.setParameter(statement,++index,orgid);
        this.setParameter(statement,++index,uuidIterator.next());
      }
      int count=statement.executeUpdate();
      if (count != uuidCache.size()) {
        String errmsg=String.format(""String_Node_Str"",orgid,uuidCache.size(),count);
        this.logger.error(errmsg);
        throw new DatabaseException(errmsg);
      }
    }
    this.logger.info(""String_Node_Str"",uuidCache.size());
    statement.close();
  }
}"
49242,"/** 
 * Migrates product data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate product data
 */
@SuppressWarnings(""String_Node_Str"") protected void migrateProductData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"");
  this.checkForMalformedPoolsAndSubscriptions(orgid);
  List<Object[]> productRows=new LinkedList<Object[]>();
  Set<String> uuidCache=new HashSet<String>();
  ResultSet productInfo=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,orgid,orgid,orgid,orgid,orgid,orgid);
  while (productInfo.next()) {
    String productId=productInfo.getString(1);
    String productUuid=this.migratedProducts.get(productId);
    if (productUuid == null) {
      this.logger.info(""String_Node_Str"",productId);
      productUuid=this.generateUUID();
      productRows.add(new Object[]{productUuid,productInfo.getObject(2),productInfo.getObject(3),productInfo.getObject(4),productId,productInfo.getObject(5),0});
      this.migratedProducts.put(productId,productUuid);
    }
    uuidCache.add(productUuid);
  }
  productInfo.close();
  if (productRows.size() > 0) {
    PreparedStatement statement=this.generateBulkInsertStatement(""String_Node_Str"",productRows.size(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    int index=0;
    for (    Object[] row : productRows) {
      for (      Object col : row) {
        this.setParameter(statement,++index,col);
      }
    }
    int count=statement.executeUpdate();
    if (count != productRows.size()) {
      String errmsg=String.format(""String_Node_Str"",productRows.size(),count);
      this.logger.error(errmsg);
      throw new DatabaseException(errmsg);
    }
    this.logger.info(""String_Node_Str"",count);
    statement.close();
  }
  if (uuidCache.size() > 0) {
    PreparedStatement statement=this.generateBulkInsertStatement(""String_Node_Str"",uuidCache.size(),""String_Node_Str"",""String_Node_Str"");
    int index=0;
    for (    String uuid : uuidCache) {
      this.setParameter(statement,++index,orgid);
      this.setParameter(statement,++index,uuid);
    }
    int count=statement.executeUpdate();
    if (count != uuidCache.size()) {
      String errmsg=String.format(""String_Node_Str"",orgid,uuidCache.size(),count);
      this.logger.error(errmsg);
      throw new DatabaseException(errmsg);
    }
    this.logger.info(""String_Node_Str"",count);
    statement.close();
  }
}","/** 
 * Migrates product data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate product data
 */
@SuppressWarnings(""String_Node_Str"") protected void migrateProductData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"");
  this.checkForMalformedPoolsAndSubscriptions(orgid);
  List<Object[]> productRows=new LinkedList<Object[]>();
  Set<String> uuidCache=new HashSet<String>();
  ResultSet productInfo=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,orgid,orgid,orgid,orgid,orgid,orgid);
  int maxrows=MAX_PARAMETERS_PER_STATEMENT / 7;
  while (productInfo.next()) {
    String productId=productInfo.getString(1);
    String productUuid=this.migratedProducts.get(productId);
    if (productUuid == null) {
      this.logger.info(""String_Node_Str"",productId);
      productUuid=this.generateUUID();
      productRows.add(new Object[]{productUuid,productInfo.getObject(2),productInfo.getObject(3),productInfo.getObject(4),productId,productInfo.getObject(5),0});
      if (productRows.size() > maxrows) {
        this.bulkInsertProductData(productRows);
        productRows.clear();
      }
      this.migratedProducts.put(productId,productUuid);
    }
    uuidCache.add(productUuid);
  }
  productInfo.close();
  bulkInsertProductData(productRows);
  productRows.clear();
  if (uuidCache.size() > 0) {
    maxrows=MAX_PARAMETERS_PER_STATEMENT / 2;
    int lastBlock=0;
    int blockSize=maxrows / 2;
    Iterator<String> uuidIterator=uuidCache.iterator();
    PreparedStatement statement=null;
    for (int offset=0; offset < uuidCache.size(); offset+=blockSize) {
      int remaining=Math.min(uuidCache.size() - offset,blockSize);
      if (remaining != lastBlock) {
        if (statement != null) {
          statement.close();
        }
        statement=this.generateBulkInsertStatement(""String_Node_Str"",remaining,""String_Node_Str"",""String_Node_Str"");
        lastBlock=remaining;
      }
      int index=0;
      while (remaining-- > 0) {
        this.setParameter(statement,++index,orgid);
        this.setParameter(statement,++index,uuidIterator.next());
      }
      int count=statement.executeUpdate();
      if (count != uuidCache.size()) {
        String errmsg=String.format(""String_Node_Str"",orgid,uuidCache.size(),count);
        this.logger.error(errmsg);
        throw new DatabaseException(errmsg);
      }
    }
    this.logger.info(""String_Node_Str"",uuidCache.size());
    statement.close();
  }
}"
49243,"/** 
 * @param consumer
 * @param principal
 * @param userName
 * @return a String object
 */
private void checkConsumerName(Consumer consumer){
  if (consumer.getName() != null) {
    if (consumer.getName().indexOf('#') == 0) {
      throw new BadRequestException(i18n.tr(""String_Node_Str""));
    }
    int max=Consumer.MAX_LENGTH_OF_CONSUMER_NAME;
    if (consumer.getName().length() > max) {
      String m=""String_Node_Str"";
      throw new BadRequestException(i18n.tr(m,Integer.toString(max)));
    }
  }
}","/** 
 * @param consumer
 * @param principal
 * @param userName
 * @return a String object
 */
private void checkConsumerName(Consumer consumer){
  if (consumer.getName() != null) {
    if (consumer.getName().indexOf('#') == 0) {
      throw new BadRequestException(i18n.tr(""String_Node_Str""));
    }
    int max=Consumer.MAX_LENGTH_OF_CONSUMER_NAME;
    if (consumer.getName().length() > max) {
      String m=""String_Node_Str"";
      throw new BadRequestException(i18n.tr(m,Integer.toString(max + 1)));
    }
  }
}"
49244,"@Test public void testCreateConsumerShouldFailOnMaxLengthOfName(){
  thrown.expect(BadRequestException.class);
  int max=Consumer.MAX_LENGTH_OF_CONSUMER_NAME;
  String m=String.format(""String_Node_Str"" + ""String_Node_Str"",max);
  thrown.expectMessage(m);
  Consumer c=mock(Consumer.class);
  Owner o=mock(Owner.class);
  UserPrincipal up=mock(UserPrincipal.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerType cType=new ConsumerType(ConsumerTypeEnum.SYSTEM);
  ConsumerResource consumerResource=createConsumerResource(oc);
  String ownerKey=""String_Node_Str"";
  when(oc.lookupByKey(eq(ownerKey))).thenReturn(o);
  when(o.getKey()).thenReturn(ownerKey);
  when(c.getType()).thenReturn(cType);
  String s=RandomStringUtils.randomAlphanumeric(max + 1);
  when(c.getName()).thenReturn(s);
  when(up.canAccess(eq(o),eq(SubResource.CONSUMERS),eq(Access.CREATE))).thenReturn(true);
  consumerResource.create(c,up,null,ownerKey,null,false);
}","@Test public void testCreateConsumerShouldFailOnMaxLengthOfName(){
  thrown.expect(BadRequestException.class);
  thrown.expectMessage(String.format(""String_Node_Str"" + ""String_Node_Str"",Consumer.MAX_LENGTH_OF_CONSUMER_NAME + 1));
  Consumer c=mock(Consumer.class);
  Owner o=mock(Owner.class);
  UserPrincipal up=mock(UserPrincipal.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerType cType=new ConsumerType(ConsumerTypeEnum.SYSTEM);
  ConsumerResource consumerResource=createConsumerResource(oc);
  String ownerKey=""String_Node_Str"";
  when(oc.lookupByKey(eq(ownerKey))).thenReturn(o);
  when(o.getKey()).thenReturn(ownerKey);
  when(c.getType()).thenReturn(cType);
  String s=RandomStringUtils.randomAlphanumeric(Consumer.MAX_LENGTH_OF_CONSUMER_NAME + 1);
  when(c.getName()).thenReturn(s);
  when(up.canAccess(eq(o),eq(SubResource.CONSUMERS),eq(Access.CREATE))).thenReturn(true);
  consumerResource.create(c,up,null,ownerKey,null,false);
}"
49245,"/** 
 * Removes all content with the provided UUIDs from the given owner.
 * @param owner The owner from which to remove content
 * @param contentUuids A collection of UUIDs representing the content to remove
 * @param regenerateEntitlementCerts Whether or not changes made to the content should trigger the regeneration of entitlement certificates for affected consumers
 * @throws IllegalArgumentException if owner is null
 */
public void removeContentByUuids(Owner owner,Collection<String> contentUuids,boolean regenerateEntitlementCerts){
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (contentUuids != null && !contentUuids.isEmpty()) {
    log.debug(""String_Node_Str"",contentUuids);
    List<Product> affectedProducts=this.productCurator.getProductsByContentUuids(owner,contentUuids).list();
    if (!affectedProducts.isEmpty()) {
      log.debug(""String_Node_Str"",affectedProducts.size());
      if (!(contentUuids instanceof Set)) {
        contentUuids=new HashSet<String>(contentUuids);
      }
      Map<String,Content> affectedProductsContent=new HashMap<String,Content>();
      for (      Content content : this.contentCurator.getContentByProducts(affectedProducts)) {
        if (!contentUuids.contains(content.getUuid())) {
          affectedProductsContent.put(content.getId(),content);
        }
      }
      Map<String,ProductData> affectedProductData=new HashMap<String,ProductData>();
      for (      Product product : affectedProducts) {
        ProductData pdata=product.toDTO();
        Iterator<ProductContentData> pcd=pdata.getProductContent().iterator();
        while (pcd.hasNext()) {
          ContentData cdata=pcd.next().getContent();
          if (!affectedProductsContent.containsKey(cdata.getId())) {
            pcd.remove();
          }
        }
      }
      log.debug(""String_Node_Str"",affectedProductData);
      this.productManager.importProducts(owner,affectedProductData,affectedProductsContent);
      if (regenerateEntitlementCerts) {
        this.entitlementCertGenerator.regenerateCertificatesOf(Arrays.asList(owner),affectedProducts,true);
      }
    }
    log.debug(""String_Node_Str"");
    this.ownerContentCurator.removeOwnerContentReferences(owner,contentUuids);
  }
}","/** 
 * Removes all content with the provided UUIDs from the given owner.
 * @param owner The owner from which to remove content
 * @param contentUuids A collection of UUIDs representing the content to remove
 * @param regenerateEntitlementCerts Whether or not changes made to the content should trigger the regeneration of entitlement certificates for affected consumers
 * @throws IllegalArgumentException if owner is null
 */
public void removeContentByUuids(Owner owner,Collection<String> contentUuids,boolean regenerateEntitlementCerts){
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (contentUuids != null && !contentUuids.isEmpty()) {
    log.debug(""String_Node_Str"",contentUuids);
    List<Product> affectedProducts=this.productCurator.getProductsByContentUuids(owner,contentUuids).list();
    if (!affectedProducts.isEmpty()) {
      log.debug(""String_Node_Str"",affectedProducts.size());
      if (!(contentUuids instanceof Set)) {
        contentUuids=new HashSet<String>(contentUuids);
      }
      Map<String,Content> affectedProductsContent=new HashMap<String,Content>();
      for (      Content content : this.contentCurator.getContentByProducts(affectedProducts)) {
        if (!contentUuids.contains(content.getUuid())) {
          affectedProductsContent.put(content.getId(),content);
        }
      }
      Map<String,ProductData> affectedProductData=new HashMap<String,ProductData>();
      for (      Product product : affectedProducts) {
        ProductData pdata=product.toDTO();
        Iterator<ProductContentData> pcd=pdata.getProductContent().iterator();
        while (pcd.hasNext()) {
          ContentData cdata=pcd.next().getContent();
          if (!affectedProductsContent.containsKey(cdata.getId())) {
            pcd.remove();
          }
        }
        affectedProductData.put(pdata.getId(),pdata);
      }
      log.debug(""String_Node_Str"",affectedProductData);
      this.productManager.importProducts(owner,affectedProductData,affectedProductsContent);
      if (regenerateEntitlementCerts) {
        this.entitlementCertGenerator.regenerateCertificatesOf(Arrays.asList(owner),affectedProducts,true);
      }
    }
    this.ownerContentCurator.removeOwnerContentReferences(owner,contentUuids);
  }
}"
49246,"@Transactional public void cleanupAndDelete(Owner owner,boolean revokeCerts){
  log.info(""String_Node_Str"",owner);
  List<String> ids=ownerCurator.getConsumerUuids(owner.getKey()).list();
  List<Consumer> consumers=consumerCurator.lockAndLoadBatch(ids);
  for (  Consumer c : consumers) {
    log.info(""String_Node_Str"",c);
    poolManager.revokeAllEntitlements(c,revokeCerts);
  }
  for (  Consumer consumer : consumers) {
    log.info(""String_Node_Str"",consumer);
    Consumer next=consumerCurator.find(consumer.getId());
    if (next != null) {
      consumerCurator.delete(next);
    }
  }
  for (  ActivationKey key : activationKeyCurator.listByOwner(owner)) {
    log.info(""String_Node_Str"",key);
    activationKeyCurator.delete(key);
  }
  for (  Environment e : owner.getEnvironments()) {
    log.info(""String_Node_Str"",e.getId());
    envCurator.delete(e);
  }
  for (  Pool p : poolManager.listPoolsByOwner(owner)) {
    log.info(""String_Node_Str"",p);
    poolManager.deletePool(p);
  }
  Pool ueberPool=poolManager.findUeberPool(owner);
  if (ueberPool != null) {
    poolManager.deletePool(ueberPool);
  }
  ExporterMetadata m=exportCurator.lookupByTypeAndOwner(ExporterMetadata.TYPE_PER_USER,owner);
  if (m != null) {
    log.info(""String_Node_Str"",m);
    exportCurator.delete(m);
  }
  for (  ImportRecord record : importRecordCurator.findRecords(owner)) {
    log.info(""String_Node_Str"",record);
    importRecordCurator.delete(record);
  }
  for (  PermissionBlueprint perm : permissionCurator.findByOwner(owner)) {
    log.info(""String_Node_Str"",perm.getAccess());
    perm.getRole().getPermissions().remove(perm);
    permissionCurator.delete(perm);
  }
  log.info(""String_Node_Str"");
  this.productManager.removeAllProducts(owner);
  log.info(""String_Node_Str"");
  this.contentManager.removeAllContent(owner,false);
  log.info(""String_Node_Str"",owner);
  ownerCurator.delete(owner);
}","@Transactional public void cleanupAndDelete(Owner owner,boolean revokeCerts){
  log.info(""String_Node_Str"",owner);
  List<String> ids=ownerCurator.getConsumerUuids(owner.getKey()).list();
  List<Consumer> consumers=consumerCurator.lockAndLoadBatch(ids);
  for (  Consumer c : consumers) {
    log.info(""String_Node_Str"",c);
    poolManager.revokeAllEntitlements(c,revokeCerts);
  }
  for (  Consumer consumer : consumers) {
    log.info(""String_Node_Str"",consumer);
    Consumer next=consumerCurator.find(consumer.getId());
    if (next != null) {
      consumerCurator.delete(next);
    }
  }
  for (  ActivationKey key : activationKeyCurator.listByOwner(owner)) {
    log.info(""String_Node_Str"",key);
    activationKeyCurator.delete(key);
  }
  log.debug(""String_Node_Str"",owner);
  envCurator.deleteEnvironmentsForOwner(owner);
  for (  Pool p : poolManager.listPoolsByOwner(owner)) {
    log.info(""String_Node_Str"",p);
    poolManager.deletePool(p);
  }
  Pool ueberPool=poolManager.findUeberPool(owner);
  if (ueberPool != null) {
    poolManager.deletePool(ueberPool);
  }
  ExporterMetadata m=exportCurator.lookupByTypeAndOwner(ExporterMetadata.TYPE_PER_USER,owner);
  if (m != null) {
    log.info(""String_Node_Str"",m);
    exportCurator.delete(m);
  }
  for (  ImportRecord record : importRecordCurator.findRecords(owner)) {
    log.info(""String_Node_Str"",record);
    importRecordCurator.delete(record);
  }
  for (  PermissionBlueprint perm : permissionCurator.findByOwner(owner)) {
    log.info(""String_Node_Str"",perm.getAccess());
    perm.getRole().getPermissions().remove(perm);
    permissionCurator.delete(perm);
  }
  log.info(""String_Node_Str"");
  this.productManager.removeAllProducts(owner);
  log.info(""String_Node_Str"");
  this.contentManager.removeAllContent(owner,false);
  log.info(""String_Node_Str"",owner);
  ownerCurator.delete(owner);
}"
49247,"/** 
 * Removes the specified products from the given owner. Products which are shared will have any references to the owner removed, while unshared products will be deleted entirely.
 * @param owner The owner from which to remove products
 * @param productUuids A collection of product UUIDs representing the products to remove from the owner
 * @throws IllegalArgumentException if owner is null
 * @throws IllegalStateException if any of the given products are still associated with one or more subscriptions
 */
public void removeProductsByUuids(Owner owner,Collection<String> productUuids){
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (productUuids != null && !productUuids.isEmpty()) {
    log.debug(""String_Node_Str"",owner,productUuids);
    this.ownerProductCurator.removeOwnerProductReferences(owner,productUuids);
  }
}","/** 
 * Removes the specified products from the given owner. Products which are shared will have any references to the owner removed, while unshared products will be deleted entirely.
 * @param owner The owner from which to remove products
 * @param productUuids A collection of product UUIDs representing the products to remove from the owner
 * @throws IllegalArgumentException if owner is null
 * @throws IllegalStateException if any of the given products are still associated with one or more subscriptions
 */
public void removeProductsByUuids(Owner owner,Collection<String> productUuids){
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (productUuids != null && !productUuids.isEmpty()) {
    this.ownerProductCurator.removeOwnerProductReferences(owner,productUuids);
  }
}"
49248,"/** 
 * Removes the content references currently pointing to the specified content for the given owners. <p/></p> <strong>Note:</strong> product-content mappings are not modified by this method. <p/></p> <strong>Warning:</strong> Hibernate does not gracefully handle situations where the data backing an entity changes via direct SQL or other outside influence. While, logically, a refresh on the entity should resolve any divergence, in many cases it does not or causes errors. As such, whenever this method is called, any active Environment entities should be manually evicted from the session and re-queried to ensure they will not clobber the changes made by this method on persist, nor trigger any errors on refresh.
 * @param owner The owner for which to apply the reference changes
 * @param contentUuids A collection of content UUIDs representing the content entities to orphan
 */
@Transactional public void removeOwnerContentReferences(Owner owner,Collection<String> contentUuids){
  Session session=this.currentSession();
  Map<String,Object> criteria=new HashMap<String,Object>();
  criteria.put(""String_Node_Str"",owner.getId());
  criteria.put(""String_Node_Str"",contentUuids);
  int count=this.bulkSQLDelete(OwnerContent.DB_TABLE,criteria);
  log.info(""String_Node_Str"",count);
  String sql=""String_Node_Str"" + Environment.DB_TABLE + ""String_Node_Str"";
  List<String> ids=session.createSQLQuery(sql).setParameter(""String_Node_Str"",owner.getId()).list();
  if (ids != null && !ids.isEmpty()) {
    criteria.clear();
    criteria.put(""String_Node_Str"",ids);
    criteria.put(""String_Node_Str"",contentUuids);
    count=this.bulkSQLDelete(EnvironmentContent.DB_TABLE,criteria);
    log.info(""String_Node_Str"",count);
  }
 else {
    log.info(""String_Node_Str"");
  }
}","/** 
 * Removes the content references currently pointing to the specified content for the given owners. <p/></p> <strong>Note:</strong> product-content mappings are not modified by this method. <p/></p> <strong>Warning:</strong> Hibernate does not gracefully handle situations where the data backing an entity changes via direct SQL or other outside influence. While, logically, a refresh on the entity should resolve any divergence, in many cases it does not or causes errors. As such, whenever this method is called, any active Environment entities should be manually evicted from the session and re-queried to ensure they will not clobber the changes made by this method on persist, nor trigger any errors on refresh.
 * @param owner The owner for which to apply the reference changes
 * @param contentUuids A collection of content UUIDs representing the content entities to orphan
 */
@Transactional public void removeOwnerContentReferences(Owner owner,Collection<String> contentUuids){
  if (contentUuids != null && !contentUuids.isEmpty()) {
    log.info(""String_Node_Str"",owner,contentUuids);
    Session session=this.currentSession();
    Map<String,Object> criteria=new HashMap<String,Object>();
    criteria.put(""String_Node_Str"",owner.getId());
    criteria.put(""String_Node_Str"",contentUuids);
    int count=this.bulkSQLDelete(OwnerContent.DB_TABLE,criteria);
    log.info(""String_Node_Str"",count);
    String sql=""String_Node_Str"" + Environment.DB_TABLE + ""String_Node_Str"";
    List<String> ids=session.createSQLQuery(sql).setParameter(""String_Node_Str"",owner.getId()).list();
    if (ids != null && !ids.isEmpty()) {
      criteria.clear();
      criteria.put(""String_Node_Str"",ids);
      criteria.put(""String_Node_Str"",contentUuids);
      count=this.bulkSQLDelete(EnvironmentContent.DB_TABLE,criteria);
      log.info(""String_Node_Str"",count);
    }
 else {
      log.info(""String_Node_Str"");
    }
  }
}"
49249,"@SuppressWarnings(""String_Node_Str"") public CandlepinQuery<Product> getProductsByContentUuids(Owner owner,Collection<String> contentUuids){
  if (contentUuids != null && !contentUuids.isEmpty()) {
    Criteria idCriteria=this.createSecureCriteria().createAlias(""String_Node_Str"",""String_Node_Str"").createAlias(""String_Node_Str"",""String_Node_Str"").add(CPRestrictions.in(""String_Node_Str"",contentUuids)).setProjection(Projections.distinct(Projections.id()));
    List<String> productUuids=idCriteria.list();
    if (productUuids != null && !productUuids.isEmpty()) {
      DetachedCriteria criteria=this.createSecureDetachedCriteria().add(CPRestrictions.in(""String_Node_Str"",productUuids));
      return this.cpQueryFactory.<Product>buildQuery(this.currentSession(),criteria);
    }
  }
  return this.cpQueryFactory.<Product>buildQuery();
}","@SuppressWarnings(""String_Node_Str"") public CandlepinQuery<Product> getProductsByContentUuids(Owner owner,Collection<String> contentUuids){
  if (contentUuids != null && !contentUuids.isEmpty()) {
    Criteria idCriteria=this.createSecureCriteria(OwnerProduct.class,null).createAlias(""String_Node_Str"",""String_Node_Str"").createAlias(""String_Node_Str"",""String_Node_Str"").createAlias(""String_Node_Str"",""String_Node_Str"").createAlias(""String_Node_Str"",""String_Node_Str"").add(Restrictions.eq(""String_Node_Str"",owner.getId())).add(CPRestrictions.in(""String_Node_Str"",contentUuids)).setProjection(Projections.distinct(Projections.property(""String_Node_Str"")));
    List<String> productUuids=idCriteria.list();
    if (productUuids != null && !productUuids.isEmpty()) {
      DetachedCriteria criteria=this.createSecureDetachedCriteria().add(CPRestrictions.in(""String_Node_Str"",productUuids));
      return this.cpQueryFactory.<Product>buildQuery(this.currentSession(),criteria);
    }
  }
  return this.cpQueryFactory.<Product>buildQuery();
}"
49250,"@Test @Parameters({""String_Node_Str"",""String_Node_Str""}) public void testRemoveContentDivergeFromExisting(boolean regenCerts){
  Owner owner1=this.createOwner(""String_Node_Str"",""String_Node_Str"");
  Owner owner2=this.createOwner(""String_Node_Str"",""String_Node_Str"");
  Product product=this.createProduct(""String_Node_Str"",""String_Node_Str"",owner1,owner2);
  Content content=this.createContent(""String_Node_Str"",""String_Node_Str"",owner1,owner2);
  product.addContent(content,true);
  product=this.productCurator.merge(product);
  assertTrue(this.ownerContentCurator.isContentMappedToOwner(content,owner1));
  assertTrue(this.ownerContentCurator.isContentMappedToOwner(content,owner2));
  this.contentManager.removeContent(owner1,content,regenCerts);
  assertFalse(this.ownerContentCurator.isContentMappedToOwner(content,owner1));
  assertTrue(this.ownerContentCurator.isContentMappedToOwner(content,owner2));
  assertNotNull(this.contentCurator.find(content.getUuid()));
  if (regenCerts) {
    verify(this.mockEntCertGenerator,times(1)).regenerateCertificatesOf(eq(Arrays.asList(owner1)),anyCollectionOf(Product.class),anyBoolean());
  }
 else {
    verifyZeroInteractions(this.mockEntCertGenerator);
  }
}","@Test @Parameters({""String_Node_Str"",""String_Node_Str""}) public void testRemoveContentDivergeFromExisting(boolean regenCerts){
  Owner owner1=this.createOwner(""String_Node_Str"",""String_Node_Str"");
  Owner owner2=this.createOwner(""String_Node_Str"",""String_Node_Str"");
  Product product=this.createProduct(""String_Node_Str"",""String_Node_Str"",owner1,owner2);
  Content content=this.createContent(""String_Node_Str"",""String_Node_Str"",owner1,owner2);
  product.addContent(content,true);
  product=this.productCurator.merge(product);
  assertTrue(this.ownerContentCurator.isContentMappedToOwner(content,owner1));
  assertTrue(this.ownerContentCurator.isContentMappedToOwner(content,owner2));
  try {
    this.beginTransaction();
    this.contentManager.removeContent(owner1,content,regenCerts);
    this.commitTransaction();
  }
 catch (  RuntimeException e) {
    this.rollbackTransaction();
  }
  assertFalse(this.ownerContentCurator.isContentMappedToOwner(content,owner1));
  assertTrue(this.ownerContentCurator.isContentMappedToOwner(content,owner2));
  assertNotNull(this.contentCurator.find(content.getUuid()));
  if (regenCerts) {
    verify(this.mockEntCertGenerator,times(1)).regenerateCertificatesOf(eq(Arrays.asList(owner1)),anyCollectionOf(Product.class),anyBoolean());
  }
 else {
    verifyZeroInteractions(this.mockEntCertGenerator);
  }
}"
49251,"@Test @Parameters({""String_Node_Str"",""String_Node_Str""}) public void testRemoveContent(boolean regenCerts){
  Owner owner=this.createOwner(""String_Node_Str"",""String_Node_Str"");
  Product product=this.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  Content content=this.createContent(""String_Node_Str"",""String_Node_Str"",owner);
  product.addContent(content,true);
  product=this.productCurator.merge(product);
  assertTrue(this.ownerContentCurator.isContentMappedToOwner(content,owner));
  this.contentManager.removeContent(owner,content,regenCerts);
  assertFalse(this.ownerContentCurator.isContentMappedToOwner(content,owner));
  assertNotNull(this.contentCurator.find(content.getUuid()));
  assertEquals(0,this.ownerContentCurator.getOwnerCount(content));
  if (regenCerts) {
    verify(this.mockEntCertGenerator,times(1)).regenerateCertificatesOf(eq(Arrays.asList(owner)),anyCollectionOf(Product.class),anyBoolean());
  }
 else {
    verifyZeroInteractions(this.mockEntCertGenerator);
  }
}","@Test @Parameters({""String_Node_Str"",""String_Node_Str""}) public void testRemoveContent(boolean regenCerts){
  Owner owner=this.createOwner(""String_Node_Str"",""String_Node_Str"");
  Product product=this.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  Content content=this.createContent(""String_Node_Str"",""String_Node_Str"",owner);
  product.addContent(content,true);
  product=this.productCurator.merge(product);
  assertTrue(this.ownerContentCurator.isContentMappedToOwner(content,owner));
  try {
    this.beginTransaction();
    this.contentManager.removeContent(owner,content,regenCerts);
    this.commitTransaction();
  }
 catch (  RuntimeException e) {
    this.rollbackTransaction();
  }
  assertFalse(this.ownerContentCurator.isContentMappedToOwner(content,owner));
  assertNotNull(this.contentCurator.find(content.getUuid()));
  assertEquals(0,this.ownerContentCurator.getOwnerCount(content));
  if (regenCerts) {
    verify(this.mockEntCertGenerator,times(1)).regenerateCertificatesOf(eq(Arrays.asList(owner)),anyCollectionOf(Product.class),anyBoolean());
  }
 else {
    verifyZeroInteractions(this.mockEntCertGenerator);
  }
}"
49252,"@Transactional @SuppressWarnings(""String_Node_Str"") void refreshPoolsWithRegeneration(SubscriptionServiceAdapter subAdapter,Owner owner,boolean lazy){
  long start=System.currentTimeMillis();
  owner=this.refreshOwner(owner);
  log.info(""String_Node_Str"",owner);
  Map<String,Subscription> subscriptionMap=new HashMap<String,Subscription>();
  Map<String,ProductData> productMap=new HashMap<String,ProductData>();
  Map<String,ContentData> contentMap=new HashMap<String,ContentData>();
  SubscriptionReconciler reconciler=new SubscriptionReconciler();
  for (  Subscription subscription : reconciler.reconcile(owner,subAdapter.getSubscriptions(owner),poolCurator)) {
    if (subscription == null) {
      continue;
    }
    Subscription existingSub=subscriptionMap.get(subscription.getId());
    if (existingSub != null && !existingSub.equals(subscription)) {
      log.warn(""String_Node_Str"" + ""String_Node_Str"",subscription.getId(),existingSub,subscription);
      continue;
    }
    subscriptionMap.put(subscription.getId(),subscription);
    List<ProductData> products=new LinkedList<ProductData>();
    products.add(subscription.getProduct());
    products.add(subscription.getDerivedProduct());
    products.addAll(subscription.getProvidedProducts());
    products.addAll(subscription.getDerivedProvidedProducts());
    for (    ProductData product : products) {
      if (product == null) {
        continue;
      }
      if (product.getId() == null) {
        log.error(""String_Node_Str"",product);
        throw new IllegalStateException(""String_Node_Str"" + product);
      }
      product.setLocked(true);
      ProductData existingProduct=productMap.get(product.getId());
      if (existingProduct != null && !existingProduct.equals(product)) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"",product.getId(),existingProduct,product);
      }
 else {
        productMap.put(product.getId(),product);
        Collection<ProductContentData> pcdCollection=product.getProductContent();
        if (pcdCollection != null) {
          for (          ProductContentData pcd : pcdCollection) {
            if (pcd == null) {
              log.error(""String_Node_Str"",product);
              throw new IllegalStateException(""String_Node_Str"" + product);
            }
            ContentData content=pcd.getContent();
            if (content == null || content.getId() == null) {
              log.error(""String_Node_Str"" + ""String_Node_Str"",product);
              throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + product);
            }
            ContentData existingContent=contentMap.get(content.getId());
            if (existingContent != null && !existingContent.equals(content)) {
              log.warn(""String_Node_Str"" + ""String_Node_Str"",content.getId(),existingContent,content);
            }
 else {
              contentMap.put(content.getId(),content);
            }
          }
        }
      }
    }
  }
  log.debug(""String_Node_Str"",contentMap.size());
  for (  ContentData cdata : contentMap.values()) {
    cdata.setLocked(true);
  }
  Map<String,Content> importedContent=this.contentManager.importContent(owner,contentMap,productMap.keySet());
  Set<Product> changedProducts=new HashSet<Product>();
  Set<String> existingProductIds=this.ownerProductCurator.filterUnknownProductIds(owner,productMap.keySet());
  log.debug(""String_Node_Str"",productMap.size());
  Map<String,Product> importedProducts=this.productManager.importProducts(owner,productMap,importedContent);
  for (  String pid : existingProductIds) {
    changedProducts.add(importedProducts.get(pid));
  }
  log.debug(""String_Node_Str"",subscriptionMap.size());
  Iterator<Map.Entry<String,Subscription>> subsIterator=subscriptionMap.entrySet().iterator();
  while (subsIterator.hasNext()) {
    Map.Entry<String,Subscription> entry=subsIterator.next();
    Subscription sub=entry.getValue();
    if (this.isExpired(sub)) {
      log.info(""String_Node_Str"",sub);
      subsIterator.remove();
      continue;
    }
    log.debug(""String_Node_Str"",sub);
    Pool pool=this.convertToMasterPoolImpl(sub,owner,importedProducts);
    this.refreshPoolsForMasterPool(pool,false,lazy,changedProducts);
  }
  Pool ueberPool=this.findUeberPool(owner);
  String ueberPoolId=ueberPool != null ? ueberPool.getId() : null;
  log.debug(""String_Node_Str"");
  List<Pool> poolsToDelete=new ArrayList<Pool>();
  for (  Pool pool : poolCurator.getPoolsFromBadSubs(owner,subscriptionMap.keySet())) {
    if (pool.getSourceSubscription() != null && !pool.getType().isDerivedType() && (ueberPoolId == null || !ueberPoolId.equals(pool.getId()))) {
      poolsToDelete.add(pool);
    }
  }
  deletePools(poolsToDelete);
  log.debug(""String_Node_Str"");
  List<Pool> floatingPools=poolCurator.getOwnersFloatingPools(owner);
  updateFloatingPools(floatingPools,lazy,changedProducts);
  log.info(""String_Node_Str"",owner.getKey(),System.currentTimeMillis() - start);
}","@Transactional @SuppressWarnings(""String_Node_Str"") void refreshPoolsWithRegeneration(SubscriptionServiceAdapter subAdapter,Owner owner,boolean lazy){
  long start=System.currentTimeMillis();
  owner=this.refreshOwner(owner);
  log.info(""String_Node_Str"",owner);
  Map<String,Subscription> subscriptionMap=new HashMap<String,Subscription>();
  Map<String,ProductData> productMap=new HashMap<String,ProductData>();
  Map<String,ContentData> contentMap=new HashMap<String,ContentData>();
  SubscriptionReconciler reconciler=new SubscriptionReconciler();
  for (  Subscription subscription : reconciler.reconcile(owner,subAdapter.getSubscriptions(owner),poolCurator)) {
    if (subscription == null) {
      continue;
    }
    Subscription existingSub=subscriptionMap.get(subscription.getId());
    if (existingSub != null && !existingSub.equals(subscription)) {
      log.warn(""String_Node_Str"" + ""String_Node_Str"",subscription.getId(),existingSub,subscription);
      continue;
    }
    subscriptionMap.put(subscription.getId(),subscription);
    List<ProductData> products=new LinkedList<ProductData>();
    products.add(subscription.getProduct());
    products.add(subscription.getDerivedProduct());
    products.addAll(subscription.getProvidedProducts());
    products.addAll(subscription.getDerivedProvidedProducts());
    for (    ProductData product : products) {
      if (product == null) {
        continue;
      }
      if (product.getId() == null) {
        log.error(""String_Node_Str"",product);
        throw new IllegalStateException(""String_Node_Str"" + product);
      }
      product.setLocked(true);
      ProductData existingProduct=productMap.get(product.getId());
      if (existingProduct != null && !existingProduct.equals(product)) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"",product.getId(),existingProduct,product);
      }
 else {
        productMap.put(product.getId(),product);
        Collection<ProductContentData> pcdCollection=product.getProductContent();
        if (pcdCollection != null) {
          for (          ProductContentData pcd : pcdCollection) {
            if (pcd == null) {
              log.error(""String_Node_Str"",product);
              throw new IllegalStateException(""String_Node_Str"" + product);
            }
            ContentData content=pcd.getContent();
            if (content == null || content.getId() == null) {
              log.error(""String_Node_Str"" + ""String_Node_Str"",product);
              throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + product);
            }
            ContentData existingContent=contentMap.get(content.getId());
            if (existingContent != null && !existingContent.equals(content)) {
              log.warn(""String_Node_Str"" + ""String_Node_Str"",content.getId(),existingContent,content);
            }
 else {
              contentMap.put(content.getId(),content);
            }
          }
        }
      }
    }
  }
  log.debug(""String_Node_Str"",contentMap.size());
  for (  ContentData cdata : contentMap.values()) {
    cdata.setLocked(true);
  }
  Map<String,Content> importedContent=this.contentManager.importContent(owner,contentMap,productMap.keySet()).getImportedEntities();
  log.debug(""String_Node_Str"",productMap.size());
  ImportResult<Product> importResult=this.productManager.importProducts(owner,productMap,importedContent);
  Map<String,Product> importedProducts=importResult.getImportedEntities();
  Set<Product> changedProducts=new HashSet<Product>();
  changedProducts.addAll(importResult.getUpdatedEntities().values());
  log.debug(""String_Node_Str"",subscriptionMap.size());
  Iterator<Map.Entry<String,Subscription>> subsIterator=subscriptionMap.entrySet().iterator();
  while (subsIterator.hasNext()) {
    Map.Entry<String,Subscription> entry=subsIterator.next();
    Subscription sub=entry.getValue();
    if (this.isExpired(sub)) {
      log.info(""String_Node_Str"",sub);
      subsIterator.remove();
      continue;
    }
    log.debug(""String_Node_Str"",sub);
    Pool pool=this.convertToMasterPoolImpl(sub,owner,importedProducts);
    this.refreshPoolsForMasterPool(pool,false,lazy,changedProducts);
  }
  Pool ueberPool=this.findUeberPool(owner);
  String ueberPoolId=ueberPool != null ? ueberPool.getId() : null;
  log.debug(""String_Node_Str"");
  List<Pool> poolsToDelete=new ArrayList<Pool>();
  for (  Pool pool : poolCurator.getPoolsFromBadSubs(owner,subscriptionMap.keySet())) {
    if (pool.getSourceSubscription() != null && !pool.getType().isDerivedType() && (ueberPoolId == null || !ueberPoolId.equals(pool.getId()))) {
      poolsToDelete.add(pool);
    }
  }
  deletePools(poolsToDelete);
  log.debug(""String_Node_Str"");
  List<Pool> floatingPools=poolCurator.getOwnersFloatingPools(owner);
  updateFloatingPools(floatingPools,lazy,changedProducts);
  log.info(""String_Node_Str"",owner.getKey(),System.currentTimeMillis() - start);
}"
49253,"/** 
 * Creates or updates content from the given content DTOs, omitting product updates for the provided Red Hat product IDs. <p></p> The content DTOs provided in the given map should be mapped by the content's Red Hat ID. If the mappings are incorrect or inconsistent, the result of this method is undefined.
 * @param owner The owner for which to import the given content
 * @param contentData A mapping of Red Hat content ID to content DTOs to import
 * @param importedProductIds A set of Red Hat product IDs specifying products which are being imported and should not be updated as part of this import operation
 * @return A mapping of Red Hat content ID to content entities representing the imported content
 */
@SuppressWarnings(""String_Node_Str"") public Map<String,Content> importContent(Owner owner,Map<String,ContentData> contentData,Set<String> importedProductIds){
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (contentData == null || contentData.isEmpty()) {
    return new HashMap<String,Content>();
  }
  Map<String,Content> importedContent=new HashMap<String,Content>();
  Map<String,Content> createdContent=new HashMap<String,Content>();
  Map<String,Content> updatedContent=new HashMap<String,Content>();
  Map<String,Integer> contentVersions=new HashMap<String,Integer>();
  Map<String,Content> sourceContent=new HashMap<String,Content>();
  Map<String,List<Content>> existingVersions=new HashMap<String,List<Content>>();
  List<OwnerContent> ownerContentBuffer=new LinkedList<OwnerContent>();
  for (  Content content : this.ownerContentCurator.getContentByIds(owner,contentData.keySet())) {
    ContentData update=contentData.get(content.getId());
    if (!content.isChangedBy(update)) {
      importedContent.put(content.getId(),content);
      continue;
    }
    sourceContent.put(content.getId(),content);
    content=this.applyContentChanges((Content)content.clone(),update);
    updatedContent.put(content.getId(),content);
    contentVersions.put(content.getId(),content.getEntityVersion());
  }
  for (  ContentData update : contentData.values()) {
    if (!updatedContent.containsKey(update.getId()) && !importedContent.containsKey(update.getId())) {
      if (update.getId() == null || update.getType() == null || update.getLabel() == null || update.getName() == null || update.getVendor() == null) {
        throw new IllegalStateException(""String_Node_Str"" + update);
      }
      Content content=this.applyContentChanges(new Content(update.getId()),update);
      createdContent.put(content.getId(),content);
      contentVersions.put(content.getId(),content.getEntityVersion());
    }
  }
  for (  Content alt : this.contentCurator.getContentByVersions(contentVersions)) {
    List<Content> alternates=existingVersions.get(alt.getId());
    if (alternates == null) {
      alternates=new LinkedList<Content>();
      existingVersions.put(alt.getId(),alternates);
    }
    alternates.add(alt);
  }
  contentVersions.clear();
  contentVersions=null;
  Iterator<Content> iterator=createdContent.values().iterator();
  createdContentLoop:   while (iterator.hasNext()) {
    Content created=iterator.next();
    List<Content> alternates=existingVersions.get(created.getId());
    if (alternates != null) {
      for (      Content alt : alternates) {
        if (created.equals(alt)) {
          ownerContentBuffer.add(new OwnerContent(owner,alt));
          importedContent.put(alt.getId(),alt);
          iterator.remove();
          continue createdContentLoop;
        }
      }
    }
    ownerContentBuffer.add(new OwnerContent(owner,created));
  }
  updatedContentLoop:   for (  Map.Entry<String,Content> entry : updatedContent.entrySet()) {
    Content updated=entry.getValue();
    List<Content> alternates=existingVersions.get(updated.getId());
    if (alternates != null) {
      for (      Content alt : alternates) {
        if (updated.equals(alt)) {
          updated=alt;
          entry.setValue(alt);
          continue updatedContentLoop;
        }
      }
    }
    updated.setUuid(null);
    createdContent.put(updated.getId(),updated);
  }
  this.contentCurator.saveAll(createdContent.values(),true,false);
  this.ownerContentCurator.saveAll(ownerContentBuffer,true,true);
  List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,sourceContent.keySet(),importedProductIds).list();
  if (affectedProducts != null && !affectedProducts.isEmpty()) {
    Map<String,Content> affectedProductsContent=new HashMap<String,Content>();
    for (    Content content : this.contentCurator.getContentByProducts(affectedProducts)) {
      affectedProductsContent.put(content.getId(),content);
    }
    affectedProductsContent.putAll(updatedContent);
    Map<String,ProductData> affectedProductData=new HashMap<String,ProductData>();
    for (    Product product : affectedProducts) {
      ProductData productData=product.toDTO();
      for (      ProductContentData pcd : productData.getProductContent()) {
        ContentData cdata=pcd.getContent();
        Content content=updatedContent.get(cdata.getId());
        if (content != null) {
          pcd.setContent(content.toDTO());
        }
      }
      affectedProductData.put(productData.getId(),productData);
    }
    this.productManager.importProducts(owner,affectedProductData,affectedProductsContent);
  }
  Map<String,String> contentUuidMap=new HashMap<String,String>();
  for (  Content update : updatedContent.values()) {
    Content source=sourceContent.get(update.getId());
    contentUuidMap.put(source.getUuid(),update.getUuid());
  }
  this.ownerContentCurator.updateOwnerContentReferences(owner,contentUuidMap);
  importedContent.putAll(createdContent);
  importedContent.putAll(updatedContent);
  return importedContent;
}","/** 
 * Creates or updates content from the given content DTOs, omitting product updates for the provided Red Hat product IDs. <p></p> The content DTOs provided in the given map should be mapped by the content's Red Hat ID. If the mappings are incorrect or inconsistent, the result of this method is undefined.
 * @param owner The owner for which to import the given content
 * @param contentData A mapping of Red Hat content ID to content DTOs to import
 * @param importedProductIds A set of Red Hat product IDs specifying products which are being imported and should not be updated as part of this import operation
 * @return A mapping of Red Hat content ID to content entities representing the imported content
 */
@SuppressWarnings(""String_Node_Str"") public ImportResult<Content> importContent(Owner owner,Map<String,ContentData> contentData,Set<String> importedProductIds){
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ImportResult<Content> importResult=new ImportResult<Content>();
  if (contentData == null || contentData.isEmpty()) {
    return importResult;
  }
  Map<String,Content> skippedContent=importResult.getSkippedEntities();
  Map<String,Content> createdContent=importResult.getCreatedEntities();
  Map<String,Content> updatedContent=importResult.getUpdatedEntities();
  Map<String,Integer> contentVersions=new HashMap<String,Integer>();
  Map<String,Content> sourceContent=new HashMap<String,Content>();
  Map<String,List<Content>> existingVersions=new HashMap<String,List<Content>>();
  List<OwnerContent> ownerContentBuffer=new LinkedList<OwnerContent>();
  for (  Content content : this.ownerContentCurator.getContentByIds(owner,contentData.keySet())) {
    ContentData update=contentData.get(content.getId());
    if (!content.isChangedBy(update)) {
      skippedContent.put(content.getId(),content);
      continue;
    }
    sourceContent.put(content.getId(),content);
    content=this.applyContentChanges((Content)content.clone(),update);
    updatedContent.put(content.getId(),content);
    contentVersions.put(content.getId(),content.getEntityVersion());
  }
  for (  ContentData update : contentData.values()) {
    if (!skippedContent.containsKey(update.getId()) && !updatedContent.containsKey(update.getId())) {
      if (update.getId() == null || update.getType() == null || update.getLabel() == null || update.getName() == null || update.getVendor() == null) {
        throw new IllegalStateException(""String_Node_Str"" + update);
      }
      Content content=this.applyContentChanges(new Content(update.getId()),update);
      createdContent.put(content.getId(),content);
      contentVersions.put(content.getId(),content.getEntityVersion());
    }
  }
  for (  Content alt : this.contentCurator.getContentByVersions(contentVersions)) {
    List<Content> alternates=existingVersions.get(alt.getId());
    if (alternates == null) {
      alternates=new LinkedList<Content>();
      existingVersions.put(alt.getId(),alternates);
    }
    alternates.add(alt);
  }
  contentVersions.clear();
  contentVersions=null;
  Map<String,Content> stagedEntities=new HashMap<String,Content>(createdContent);
  Iterator<Content> iterator=stagedEntities.values().iterator();
  createdContentLoop:   while (iterator.hasNext()) {
    Content created=iterator.next();
    List<Content> alternates=existingVersions.get(created.getId());
    if (alternates != null) {
      for (      Content alt : alternates) {
        if (created.equals(alt)) {
          ownerContentBuffer.add(new OwnerContent(owner,alt));
          createdContent.put(alt.getId(),alt);
          iterator.remove();
          continue createdContentLoop;
        }
      }
    }
    ownerContentBuffer.add(new OwnerContent(owner,created));
  }
  updatedContentLoop:   for (  Map.Entry<String,Content> entry : updatedContent.entrySet()) {
    Content updated=entry.getValue();
    List<Content> alternates=existingVersions.get(updated.getId());
    if (alternates != null) {
      for (      Content alt : alternates) {
        if (updated.equals(alt)) {
          updated=alt;
          entry.setValue(alt);
          continue updatedContentLoop;
        }
      }
    }
    updated.setUuid(null);
    stagedEntities.put(updated.getId(),updated);
  }
  this.contentCurator.saveAll(stagedEntities.values(),true,false);
  this.ownerContentCurator.saveAll(ownerContentBuffer,true,true);
  List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,sourceContent.keySet(),importedProductIds).list();
  if (affectedProducts != null && !affectedProducts.isEmpty()) {
    Map<String,Content> affectedProductsContent=new HashMap<String,Content>();
    for (    Content content : this.contentCurator.getContentByProducts(affectedProducts)) {
      affectedProductsContent.put(content.getId(),content);
    }
    affectedProductsContent.putAll(updatedContent);
    Map<String,ProductData> affectedProductData=new HashMap<String,ProductData>();
    for (    Product product : affectedProducts) {
      ProductData productData=product.toDTO();
      for (      ProductContentData pcd : productData.getProductContent()) {
        ContentData cdata=pcd.getContent();
        Content content=updatedContent.get(cdata.getId());
        if (content != null) {
          pcd.setContent(content.toDTO());
        }
      }
      affectedProductData.put(productData.getId(),productData);
    }
    this.productManager.importProducts(owner,affectedProductData,affectedProductsContent);
  }
  Map<String,String> contentUuidMap=new HashMap<String,String>();
  for (  Content update : updatedContent.values()) {
    Content source=sourceContent.get(update.getId());
    contentUuidMap.put(source.getUuid(),update.getUuid());
  }
  this.ownerContentCurator.updateOwnerContentReferences(owner,contentUuidMap);
  return importResult;
}"
49254,"/** 
 * Looks up all Products matching the specified SKU and the consumer's installed products.
 * @param consumer the consumer to pull the installed product id list from.
 * @param sku the product id of the SKU.
 * @return a {@link DeveloperProducts} object that contains the Product objectsfrom the adapter.
 */
private DeveloperProducts getDevProductMap(Consumer consumer,String sku){
  List<String> devProductIds=new ArrayList<String>();
  devProductIds.add(sku);
  for (  ConsumerInstalledProduct ip : consumer.getInstalledProducts()) {
    devProductIds.add(ip.getProductId());
  }
  Owner owner=consumer.getOwner();
  Map<String,ProductData> productMap=new HashMap<String,ProductData>();
  Map<String,ContentData> contentMap=new HashMap<String,ContentData>();
  log.debug(""String_Node_Str"");
  for (  ProductData product : this.productAdapter.getProductsByIds(owner,devProductIds)) {
    if (product == null) {
      continue;
    }
    if (sku.equals(product.getId()) && StringUtils.isEmpty(product.getAttributeValue(Product.Attributes.SUPPORT_LEVEL))) {
      product.setAttribute(Product.Attributes.SUPPORT_LEVEL,this.DEFAULT_DEV_SLA);
    }
    product.setLocked(true);
    ProductData existingProduct=productMap.get(product.getId());
    if (existingProduct != null && !existingProduct.equals(product)) {
      log.warn(""String_Node_Str"" + ""String_Node_Str"",product.getId(),existingProduct,product);
    }
 else {
      productMap.put(product.getId(),product);
      Collection<ProductContentData> pcdCollection=product.getProductContent();
      if (pcdCollection != null) {
        for (        ProductContentData pcd : pcdCollection) {
          if (pcd == null) {
            log.error(""String_Node_Str"",product);
            throw new IllegalStateException(""String_Node_Str"" + product);
          }
          ContentData content=pcd.getContent();
          if (content == null || content.getId() == null) {
            log.error(""String_Node_Str"" + ""String_Node_Str"",product);
            throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + product);
          }
          ContentData existingContent=contentMap.get(content.getId());
          if (existingContent != null && !existingContent.equals(content)) {
            log.warn(""String_Node_Str"" + ""String_Node_Str"",content.getId(),existingContent,content);
          }
 else {
            contentMap.put(content.getId(),content);
          }
        }
      }
    }
  }
  log.debug(""String_Node_Str"",contentMap.size());
  for (  ContentData cdata : contentMap.values()) {
    cdata.setLocked(true);
  }
  Map<String,Content> importedContent=this.contentManager.importContent(owner,contentMap,productMap.keySet());
  log.debug(""String_Node_Str"",productMap.size());
  Map<String,Product> importedProducts=this.productManager.importProducts(owner,productMap,importedContent);
  log.debug(""String_Node_Str"",productMap.size(),sku);
  return new DeveloperProducts(sku,importedProducts);
}","/** 
 * Looks up all Products matching the specified SKU and the consumer's installed products.
 * @param consumer the consumer to pull the installed product id list from.
 * @param sku the product id of the SKU.
 * @return a {@link DeveloperProducts} object that contains the Product objectsfrom the adapter.
 */
private DeveloperProducts getDevProductMap(Consumer consumer,String sku){
  List<String> devProductIds=new ArrayList<String>();
  devProductIds.add(sku);
  for (  ConsumerInstalledProduct ip : consumer.getInstalledProducts()) {
    devProductIds.add(ip.getProductId());
  }
  Owner owner=consumer.getOwner();
  Map<String,ProductData> productMap=new HashMap<String,ProductData>();
  Map<String,ContentData> contentMap=new HashMap<String,ContentData>();
  log.debug(""String_Node_Str"");
  for (  ProductData product : this.productAdapter.getProductsByIds(owner,devProductIds)) {
    if (product == null) {
      continue;
    }
    if (sku.equals(product.getId()) && StringUtils.isEmpty(product.getAttributeValue(Product.Attributes.SUPPORT_LEVEL))) {
      product.setAttribute(Product.Attributes.SUPPORT_LEVEL,this.DEFAULT_DEV_SLA);
    }
    product.setLocked(true);
    ProductData existingProduct=productMap.get(product.getId());
    if (existingProduct != null && !existingProduct.equals(product)) {
      log.warn(""String_Node_Str"" + ""String_Node_Str"",product.getId(),existingProduct,product);
    }
 else {
      productMap.put(product.getId(),product);
      Collection<ProductContentData> pcdCollection=product.getProductContent();
      if (pcdCollection != null) {
        for (        ProductContentData pcd : pcdCollection) {
          if (pcd == null) {
            log.error(""String_Node_Str"",product);
            throw new IllegalStateException(""String_Node_Str"" + product);
          }
          ContentData content=pcd.getContent();
          if (content == null || content.getId() == null) {
            log.error(""String_Node_Str"" + ""String_Node_Str"",product);
            throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + product);
          }
          ContentData existingContent=contentMap.get(content.getId());
          if (existingContent != null && !existingContent.equals(content)) {
            log.warn(""String_Node_Str"" + ""String_Node_Str"",content.getId(),existingContent,content);
          }
 else {
            contentMap.put(content.getId(),content);
          }
        }
      }
    }
  }
  log.debug(""String_Node_Str"",contentMap.size());
  for (  ContentData cdata : contentMap.values()) {
    cdata.setLocked(true);
  }
  Map<String,Content> importedContent=this.contentManager.importContent(owner,contentMap,productMap.keySet()).getImportedEntities();
  log.debug(""String_Node_Str"",productMap.size());
  Map<String,Product> importedProducts=this.productManager.importProducts(owner,productMap,importedContent).getImportedEntities();
  log.debug(""String_Node_Str"",productMap.size(),sku);
  return new DeveloperProducts(sku,importedProducts);
}"
49255,"/** 
 * Creates or updates products from the given products DTOs, using the provided content for content lookup and resolution. <p></p> The product DTOs provided in the given map should be mapped by the product's Red Hat ID. If the mappings are incorrect or inconsistent, the result of this method is undefined.
 * @param owner The owner for which to import the given product
 * @param productData A mapping of Red Hat product ID to product DTOs to import
 * @param importedContent A mapping of Red Hat content ID to content instances to use to lookup and resolve content references on the provided product DTOs.
 * @return A mapping of Red Hat content ID to content entities representing the imported content
 */
public Map<String,Product> importProducts(Owner owner,Map<String,ProductData> productData,Map<String,Content> importedContent){
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (productData == null || productData.isEmpty()) {
    return new HashMap<String,Product>();
  }
  Map<String,Product> importedProducts=new HashMap<String,Product>();
  Map<String,Product> createdProducts=new HashMap<String,Product>();
  Map<String,Product> updatedProducts=new HashMap<String,Product>();
  Map<String,Integer> productVersions=new HashMap<String,Integer>();
  Map<String,Product> sourceProducts=new HashMap<String,Product>();
  Map<String,List<Product>> existingVersions=new HashMap<String,List<Product>>();
  List<OwnerProduct> ownerProductBuffer=new LinkedList<OwnerProduct>();
  for (  Product product : this.ownerProductCurator.getProductsByIds(owner,productData.keySet())) {
    ProductData update=productData.get(product.getId());
    if (!product.isChangedBy(update)) {
      importedProducts.put(product.getId(),product);
      continue;
    }
    sourceProducts.put(product.getId(),product);
    product=this.applyProductChanges((Product)product.clone(),update,importedContent);
    updatedProducts.put(product.getId(),product);
    productVersions.put(product.getId(),product.getEntityVersion());
  }
  for (  ProductData update : productData.values()) {
    if (!updatedProducts.containsKey(update.getId()) && !importedProducts.containsKey(update.getId())) {
      if (update.getId() == null || update.getName() == null) {
        throw new IllegalStateException(""String_Node_Str"" + update);
      }
      Product product=new Product(update.getId(),update.getName());
      product=this.applyProductChanges(product,update,importedContent);
      createdProducts.put(product.getId(),product);
      productVersions.put(product.getId(),product.getEntityVersion());
    }
  }
  for (  Product alt : this.productCurator.getProductByVersions(productVersions)) {
    List<Product> alternates=existingVersions.get(alt.getId());
    if (alternates == null) {
      alternates=new LinkedList<Product>();
      existingVersions.put(alt.getId(),alternates);
    }
    alternates.add(alt);
  }
  productVersions.clear();
  productVersions=null;
  Iterator<Product> iterator=createdProducts.values().iterator();
  createdProductLoop:   while (iterator.hasNext()) {
    Product created=iterator.next();
    List<Product> alternates=existingVersions.get(created.getId());
    if (alternates != null) {
      for (      Product alt : alternates) {
        if (created.equals(alt)) {
          ownerProductBuffer.add(new OwnerProduct(owner,alt));
          importedProducts.put(alt.getId(),alt);
          iterator.remove();
          continue createdProductLoop;
        }
      }
    }
    ownerProductBuffer.add(new OwnerProduct(owner,created));
  }
  updatedProductLoop:   for (  Map.Entry<String,Product> entry : updatedProducts.entrySet()) {
    Product updated=entry.getValue();
    List<Product> alternates=existingVersions.get(updated.getId());
    if (alternates != null) {
      for (      Product alt : alternates) {
        if (updated.equals(alt)) {
          updated=alt;
          entry.setValue(alt);
          continue updatedProductLoop;
        }
      }
    }
    updated.setUuid(null);
    createdProducts.put(updated.getId(),updated);
  }
  this.productCurator.saveAll(createdProducts.values(),true,false);
  this.ownerProductCurator.saveAll(ownerProductBuffer,true,true);
  Map<String,String> productUuidMap=new HashMap<String,String>();
  for (  Product update : updatedProducts.values()) {
    Product source=sourceProducts.get(update.getId());
    productUuidMap.put(source.getUuid(),update.getUuid());
  }
  this.ownerProductCurator.updateOwnerProductReferences(owner,productUuidMap);
  importedProducts.putAll(createdProducts);
  importedProducts.putAll(updatedProducts);
  return importedProducts;
}","/** 
 * Creates or updates products from the given products DTOs, using the provided content for content lookup and resolution. <p></p> The product DTOs provided in the given map should be mapped by the product's Red Hat ID. If the mappings are incorrect or inconsistent, the result of this method is undefined.
 * @param owner The owner for which to import the given product
 * @param productData A mapping of Red Hat product ID to product DTOs to import
 * @param importedContent A mapping of Red Hat content ID to content instances to use to lookup and resolve content references on the provided product DTOs.
 * @return A mapping of Red Hat content ID to content entities representing the imported content
 */
public ImportResult<Product> importProducts(Owner owner,Map<String,ProductData> productData,Map<String,Content> importedContent){
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ImportResult<Product> importResult=new ImportResult<Product>();
  if (productData == null || productData.isEmpty()) {
    return importResult;
  }
  Map<String,Product> skippedProducts=importResult.getSkippedEntities();
  Map<String,Product> createdProducts=importResult.getCreatedEntities();
  Map<String,Product> updatedProducts=importResult.getUpdatedEntities();
  Map<String,Integer> productVersions=new HashMap<String,Integer>();
  Map<String,Product> sourceProducts=new HashMap<String,Product>();
  Map<String,List<Product>> existingVersions=new HashMap<String,List<Product>>();
  List<OwnerProduct> ownerProductBuffer=new LinkedList<OwnerProduct>();
  for (  Product product : this.ownerProductCurator.getProductsByIds(owner,productData.keySet())) {
    ProductData update=productData.get(product.getId());
    if (!product.isChangedBy(update)) {
      skippedProducts.put(product.getId(),product);
      continue;
    }
    sourceProducts.put(product.getId(),product);
    product=this.applyProductChanges((Product)product.clone(),update,importedContent);
    updatedProducts.put(product.getId(),product);
    productVersions.put(product.getId(),product.getEntityVersion());
  }
  for (  ProductData update : productData.values()) {
    if (!skippedProducts.containsKey(update.getId()) && !updatedProducts.containsKey(update.getId())) {
      if (update.getId() == null || update.getName() == null) {
        throw new IllegalStateException(""String_Node_Str"" + update);
      }
      Product product=new Product(update.getId(),update.getName());
      product=this.applyProductChanges(product,update,importedContent);
      createdProducts.put(product.getId(),product);
      productVersions.put(product.getId(),product.getEntityVersion());
    }
  }
  for (  Product alt : this.productCurator.getProductByVersions(productVersions)) {
    List<Product> alternates=existingVersions.get(alt.getId());
    if (alternates == null) {
      alternates=new LinkedList<Product>();
      existingVersions.put(alt.getId(),alternates);
    }
    alternates.add(alt);
  }
  productVersions.clear();
  productVersions=null;
  Map<String,Product> stagedEntities=new HashMap<String,Product>(createdProducts);
  Iterator<Product> iterator=stagedEntities.values().iterator();
  createdProductLoop:   while (iterator.hasNext()) {
    Product created=iterator.next();
    List<Product> alternates=existingVersions.get(created.getId());
    if (alternates != null) {
      for (      Product alt : alternates) {
        if (created.equals(alt)) {
          ownerProductBuffer.add(new OwnerProduct(owner,alt));
          createdProducts.put(alt.getId(),alt);
          iterator.remove();
          continue createdProductLoop;
        }
      }
    }
    ownerProductBuffer.add(new OwnerProduct(owner,created));
  }
  updatedProductLoop:   for (  Map.Entry<String,Product> entry : updatedProducts.entrySet()) {
    Product updated=entry.getValue();
    List<Product> alternates=existingVersions.get(updated.getId());
    if (alternates != null) {
      for (      Product alt : alternates) {
        if (updated.equals(alt)) {
          updated=alt;
          entry.setValue(alt);
          continue updatedProductLoop;
        }
      }
    }
    updated.setUuid(null);
    stagedEntities.put(updated.getId(),updated);
  }
  this.productCurator.saveAll(stagedEntities.values(),true,false);
  this.ownerProductCurator.saveAll(ownerProductBuffer,true,true);
  Map<String,String> productUuidMap=new HashMap<String,String>();
  for (  Product update : updatedProducts.values()) {
    Product source=sourceProducts.get(update.getId());
    productUuidMap.put(source.getUuid(),update.getUuid());
  }
  this.ownerProductCurator.updateOwnerProductReferences(owner,productUuidMap);
  return importResult;
}"
49256,"/** 
 * Find an owner by ownerKey and lock it.
 * @param ownerKey the target Owner's key
 * @return the Owner with the specified key, or null if not found.
 */
@Transactional public Owner findAndLock(String ownerKey){
  List<Owner> result=getEntityManager().createQuery(""String_Node_Str"",Owner.class).setParameter(""String_Node_Str"",ownerKey).setMaxResults(1).setLockMode(LockModeType.PESSIMISTIC_WRITE).getResultList();
  if (result == null || result.isEmpty()) {
    return null;
  }
  return result.get(0);
}","/** 
 * Find an owner by ownerKey and lock it.
 * @param ownerKey the target Owner's key
 * @return the Owner with the specified key, or null if not found.
 */
@Transactional public Owner findAndLock(String ownerKey){
  List<Owner> result=getEntityManager().createQuery(""String_Node_Str"",Owner.class).setParameter(""String_Node_Str"",ownerKey).setMaxResults(1).setLockMode(LockModeType.PESSIMISTIC_WRITE).getResultList();
  if (result == null || result.isEmpty()) {
    return null;
  }
  Owner owner=result.get(0);
  getEntityManager().refresh(owner,LockModeType.PESSIMISTIC_WRITE);
  return owner;
}"
49257,"@Inject public ContentManager(ContentCurator contentCurator,OwnerContentCurator ownerContentCurator,ProductCurator productCurator,ProductManager productManager,EntitlementCertificateGenerator entitlementCertGenerator,Configuration config){
  this.contentCurator=contentCurator;
  this.ownerContentCurator=ownerContentCurator;
  this.productCurator=productCurator;
  this.productManager=productManager;
  this.entitlementCertGenerator=entitlementCertGenerator;
}","@Inject public ContentManager(ContentCurator contentCurator,EntitlementCertificateGenerator entitlementCertGenerator,OwnerContentCurator ownerContentCurator,ProductCurator productCurator,ProductManager productManager){
  this.contentCurator=contentCurator;
  this.entitlementCertGenerator=entitlementCertGenerator;
  this.ownerContentCurator=ownerContentCurator;
  this.productCurator=productCurator;
  this.productManager=productManager;
}"
49258,"/** 
 * Applies the changes from the given DTO to the specified entity
 * @param entity The entity to modify
 * @param update The DTO containing the modifications to apply
 * @param owner An owner to use for resolving entity references
 * @throws IllegalArgumentException if entity, update or owner is null
 * @return The updated product entity
 */
private Content applyContentChanges(Content entity,ContentData update,Owner owner){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update.getType() != null) {
    entity.setType(update.getType());
  }
  if (update.getLabel() != null) {
    entity.setLabel(update.getLabel());
  }
  if (update.getName() != null) {
    entity.setName(update.getName());
  }
  if (update.getVendor() != null) {
    entity.setVendor(update.getVendor());
  }
  if (update.getContentUrl() != null) {
    entity.setContentUrl(update.getContentUrl());
  }
  if (update.getRequiredTags() != null) {
    entity.setRequiredTags(update.getRequiredTags());
  }
  if (update.getReleaseVersion() != null) {
    entity.setReleaseVer(update.getReleaseVersion());
  }
  if (update.getGpgUrl() != null) {
    entity.setGpgUrl(update.getGpgUrl());
  }
  if (update.getMetadataExpire() != null) {
    entity.setMetadataExpire(update.getMetadataExpire());
  }
  if (update.getModifiedProductIds() != null) {
    entity.setModifiedProductIds(update.getModifiedProductIds());
  }
  if (update.getArches() != null) {
    entity.setArches(update.getArches());
  }
  if (update.isLocked() != null) {
    entity.setLocked(update.isLocked());
  }
  return entity;
}","/** 
 * Applies the changes from the given DTO to the specified entity
 * @param entity The entity to modify
 * @param update The DTO containing the modifications to apply
 * @param owner An owner to use for resolving entity references
 * @throws IllegalArgumentException if entity, update or owner is null
 * @return The updated product entity
 */
private Content applyContentChanges(Content entity,ContentData update,Owner owner){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update.getType() != null) {
    entity.setType(update.getType());
  }
  if (update.getLabel() != null) {
    entity.setLabel(update.getLabel());
  }
  if (update.getName() != null) {
    entity.setName(update.getName());
  }
  if (update.getVendor() != null) {
    entity.setVendor(update.getVendor());
  }
  if (update.getContentUrl() != null) {
    entity.setContentUrl(update.getContentUrl());
  }
  if (update.getRequiredTags() != null) {
    entity.setRequiredTags(update.getRequiredTags());
  }
  if (update.getReleaseVersion() != null) {
    entity.setReleaseVersion(update.getReleaseVersion());
  }
  if (update.getGpgUrl() != null) {
    entity.setGpgUrl(update.getGpgUrl());
  }
  if (update.getMetadataExpire() != null) {
    entity.setMetadataExpire(update.getMetadataExpire());
  }
  if (update.getModifiedProductIds() != null) {
    entity.setModifiedProductIds(update.getModifiedProductIds());
  }
  if (update.getArches() != null) {
    entity.setArches(update.getArches());
  }
  if (update.isLocked() != null) {
    entity.setLocked(update.isLocked());
  }
  return entity;
}"
49259,"/** 
 * Updates the specified content instance, creating a new version of the content as necessary. The content instance returned by this method is not guaranteed to be the same instance passed in. As such, once this method has been called, callers should only use the instance output by this method.
 * @param entity The content entity to update
 * @param owner The owner for which to update the content
 * @param regenerateEntitlementCerts Whether or not changes made to the content should trigger the regeneration of entitlement certificates for affected consumers
 * @throws IllegalStateException if this method is called with an entity does not exist in the backing database for the given owner
 * @throws IllegalArgumentException if either the provided content entity or owner are null
 * @return the updated content entity, or a new content entity
 */
@Transactional public Content updateContent(Content entity,ContentData update,Owner owner,boolean regenerateEntitlementCerts){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"",entity,owner);
  entity=this.contentCurator.lookupById(owner,entity.getId());
  if (entity == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Content updated=this.applyContentChanges((Content)entity.clone(),update,owner);
  List<Content> alternateVersions=this.contentCurator.getContentByVersion(update.getId(),updated.hashCode()).list();
  log.debug(""String_Node_Str"",alternateVersions.size());
  for (  Content alt : alternateVersions) {
    if (alt.equals(updated)) {
      log.debug(""String_Node_Str"",updated,alt);
      List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,Arrays.asList(updated.getId()));
      List<Owner> owners=Arrays.asList(owner);
      updated=this.ownerContentCurator.updateOwnerContentReferences(updated,alt,owners);
      ContentData cdata=updated.toDTO();
      for (      Product product : affectedProducts) {
        ProductData pdata=product.toDTO();
        ProductContentData pcd=pdata.getProductContent(updated.getId());
        if (pcd != null) {
          pcd.setContent(cdata);
          this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
        }
      }
      return updated;
    }
  }
  if (this.ownerContentCurator.getOwnerCount(updated) == 1) {
    log.debug(""String_Node_Str"",updated);
    updated=this.contentCurator.merge(updated);
    if (regenerateEntitlementCerts) {
      this.entitlementCertGenerator.regenerateCertificatesOf(this.productCurator.getProductsWithContent(Arrays.asList(updated.getUuid())),true);
    }
    return updated;
  }
  log.debug(""String_Node_Str"",updated);
  List<Owner> owners=Arrays.asList(owner);
  updated.setUuid(null);
  List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,Arrays.asList(updated.getId()));
  updated=this.contentCurator.create(updated);
  ContentData cdata=updated.toDTO();
  for (  Product product : affectedProducts) {
    ProductData pdata=product.toDTO();
    ProductContentData pcd=pdata.getProductContent(updated.getId());
    if (pcd != null) {
      pcd.setContent(cdata);
      this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
    }
    this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
  }
  return this.ownerContentCurator.updateOwnerContentReferences(entity,updated,owners);
}","/** 
 * Updates the specified content instance, creating a new version of the content as necessary. The content instance returned by this method is not guaranteed to be the same instance passed in. As such, once this method has been called, callers should only use the instance output by this method.
 * @param entity The content entity to update
 * @param owner The owner for which to update the content
 * @param regenerateEntitlementCerts Whether or not changes made to the content should trigger the regeneration of entitlement certificates for affected consumers
 * @throws IllegalStateException if this method is called with an entity does not exist in the backing database for the given owner
 * @throws IllegalArgumentException if either the provided content entity or owner are null
 * @return the updated content entity, or a new content entity
 */
@Transactional public Content updateContent(Content entity,ContentData update,Owner owner,boolean regenerateEntitlementCerts){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"",entity,owner);
  entity=this.contentCurator.lookupById(owner,entity.getId());
  if (entity == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!entity.isChangedBy(update)) {
    return entity;
  }
  Content updated=this.applyContentChanges((Content)entity.clone(),update,owner);
  List<Content> alternateVersions=this.contentCurator.getContentByVersion(update.getId(),updated.hashCode()).list();
  log.debug(""String_Node_Str"",alternateVersions.size());
  for (  Content alt : alternateVersions) {
    if (alt.equals(updated)) {
      log.debug(""String_Node_Str"",updated,alt);
      List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,Arrays.asList(updated.getId()));
      List<Owner> owners=Arrays.asList(owner);
      updated=this.ownerContentCurator.updateOwnerContentReferences(updated,alt,owners);
      ContentData cdata=updated.toDTO();
      for (      Product product : affectedProducts) {
        ProductData pdata=product.toDTO();
        ProductContentData pcd=pdata.getProductContent(updated.getId());
        if (pcd != null) {
          pcd.setContent(cdata);
          this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
        }
      }
      return updated;
    }
  }
  if (this.ownerContentCurator.getOwnerCount(updated) == 1) {
    log.debug(""String_Node_Str"",updated);
    updated=this.contentCurator.merge(updated);
    if (regenerateEntitlementCerts) {
      this.entitlementCertGenerator.regenerateCertificatesOf(this.productCurator.getProductsWithContent(Arrays.asList(updated.getUuid())),true);
    }
    return updated;
  }
  log.debug(""String_Node_Str"",updated);
  List<Owner> owners=Arrays.asList(owner);
  updated.setUuid(null);
  List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,Arrays.asList(updated.getId()));
  updated=this.contentCurator.create(updated);
  ContentData cdata=updated.toDTO();
  for (  Product product : affectedProducts) {
    ProductData pdata=product.toDTO();
    ProductContentData pcd=pdata.getProductContent(updated.getId());
    if (pcd != null) {
      pcd.setContent(cdata);
      this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
    }
    this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
  }
  return this.ownerContentCurator.updateOwnerContentReferences(entity,updated,owners);
}"
49260,"/** 
 * Updates the specified product instance, creating a new version of the product as necessary. The product instance returned by this method is not guaranteed to be the same instance passed in. As such, once this method has been called, callers should only use the instance output by this method.
 * @param entity The product entity to update
 * @param update The product updates to apply
 * @param owner The owner for which to update the product
 * @param regenerateEntitlementCerts Whether or not changes made to the product should trigger the regeneration of entitlement certificates for affected consumers
 * @throws IllegalStateException if this method is called with an entity does not exist in the backing database for the given owner
 * @throws IllegalArgumentException if entity, update or owner is null
 * @return the updated product entity, or a new product entity
 */
@Transactional public Product updateProduct(Product entity,ProductData update,Owner owner,boolean regenerateEntitlementCerts){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"",update,entity,owner);
  entity=this.ownerProductCurator.getProductById(owner,entity.getId());
  if (entity == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Product updated=this.applyProductChanges((Product)entity.clone(),update,owner);
  List<Product> alternateVersions=this.productCurator.getProductsByVersion(update.getId(),updated.hashCode()).list();
  log.debug(""String_Node_Str"",alternateVersions.size());
  for (  Product alt : alternateVersions) {
    if (alt.equals(updated)) {
      log.debug(""String_Node_Str"",updated,alt);
      List<Owner> owners=Arrays.asList(owner);
      updated=this.ownerProductCurator.updateOwnerProductReferences(updated,alt,owners);
      if (regenerateEntitlementCerts) {
        this.entitlementCertGenerator.regenerateCertificatesOf(owners,Arrays.asList(updated),true);
      }
      return updated;
    }
  }
  if (this.ownerProductCurator.getOwnerCount(updated) == 1) {
    log.debug(""String_Node_Str"",updated);
    updated=this.productCurator.merge(updated);
    if (regenerateEntitlementCerts) {
      this.entitlementCertGenerator.regenerateCertificatesOf(Arrays.asList(updated),true);
    }
    return updated;
  }
  log.debug(""String_Node_Str"",updated);
  List<Owner> owners=Arrays.asList(owner);
  updated.setUuid(null);
  updated=this.productCurator.create(updated);
  updated=this.ownerProductCurator.updateOwnerProductReferences(entity,updated,owners);
  if (regenerateEntitlementCerts) {
    this.entitlementCertGenerator.regenerateCertificatesOf(owners,Arrays.asList(updated),true);
  }
  return updated;
}","/** 
 * Updates the specified product instance, creating a new version of the product as necessary. The product instance returned by this method is not guaranteed to be the same instance passed in. As such, once this method has been called, callers should only use the instance output by this method.
 * @param entity The product entity to update
 * @param update The product updates to apply
 * @param owner The owner for which to update the product
 * @param regenerateEntitlementCerts Whether or not changes made to the product should trigger the regeneration of entitlement certificates for affected consumers
 * @throws IllegalStateException if this method is called with an entity does not exist in the backing database for the given owner
 * @throws IllegalArgumentException if entity, update or owner is null
 * @return the updated product entity, or a new product entity
 */
@Transactional public Product updateProduct(Product entity,ProductData update,Owner owner,boolean regenerateEntitlementCerts){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"",update,entity,owner);
  entity=this.ownerProductCurator.getProductById(owner,entity.getId());
  if (entity == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!entity.isChangedBy(update)) {
    return entity;
  }
  Product updated=this.applyProductChanges((Product)entity.clone(),update,owner);
  List<Product> alternateVersions=this.productCurator.getProductsByVersion(update.getId(),updated.hashCode()).list();
  log.debug(""String_Node_Str"",alternateVersions.size());
  for (  Product alt : alternateVersions) {
    if (alt.equals(updated)) {
      log.debug(""String_Node_Str"",updated,alt);
      List<Owner> owners=Arrays.asList(owner);
      updated=this.ownerProductCurator.updateOwnerProductReferences(updated,alt,owners);
      if (regenerateEntitlementCerts) {
        this.entitlementCertGenerator.regenerateCertificatesOf(owners,Arrays.asList(updated),true);
      }
      return updated;
    }
  }
  if (this.ownerProductCurator.getOwnerCount(updated) == 1) {
    log.debug(""String_Node_Str"",updated);
    updated=this.productCurator.merge(updated);
    if (regenerateEntitlementCerts) {
      this.entitlementCertGenerator.regenerateCertificatesOf(Arrays.asList(updated),true);
    }
    return updated;
  }
  log.debug(""String_Node_Str"",updated);
  List<Owner> owners=Arrays.asList(owner);
  updated.setUuid(null);
  updated=this.productCurator.create(updated);
  updated=this.ownerProductCurator.updateOwnerProductReferences(entity,updated,owners);
  if (regenerateEntitlementCerts) {
    this.entitlementCertGenerator.regenerateCertificatesOf(owners,Arrays.asList(updated),true);
  }
  return updated;
}"
49261,"@Inject public ProductManager(ContentCurator contentCurator,EntitlementCertificateGenerator entitlementCertGenerator,ProductCurator productCurator,OwnerProductCurator ownerProductCurator,Configuration config){
  this.contentCurator=contentCurator;
  this.entitlementCertGenerator=entitlementCertGenerator;
  this.ownerProductCurator=ownerProductCurator;
  this.productCurator=productCurator;
}","@Inject public ProductManager(ContentCurator contentCurator,EntitlementCertificateGenerator entitlementCertGenerator,OwnerProductCurator ownerProductCurator,ProductCurator productCurator){
  this.contentCurator=contentCurator;
  this.entitlementCertGenerator=entitlementCertGenerator;
  this.ownerProductCurator=ownerProductCurator;
  this.productCurator=productCurator;
}"
49262,"/** 
 * Copies several properties from the given content on to this content instance. Properties that are not copied over include any identifiying fields (UUID, ID), the creation date and locking states. Values on the source content which are null will be ignored.
 * @param source The source content instance from which to pull content information
 * @return this content instance
 */
public Content merge(Content source){
  this.setUpdated(source.getUpdated() != null ? (Date)source.getUpdated().clone() : null);
  this.setType(source.getType());
  this.setLabel(source.getLabel());
  this.setName(source.getName());
  this.setVendor(source.getVendor());
  this.setContentUrl(source.getContentUrl());
  this.setRequiredTags(source.getRequiredTags());
  this.setReleaseVer(source.getReleaseVer());
  this.setGpgUrl(source.getGpgUrl());
  this.setMetadataExpire(source.getMetadataExpire());
  this.setArches(source.getArches());
  this.setModifiedProductIds(source.getModifiedProductIds());
  return this;
}","/** 
 * Copies several properties from the given content on to this content instance. Properties that are not copied over include any identifiying fields (UUID, ID), the creation date and locking states. Values on the source content which are null will be ignored.
 * @param source The source content instance from which to pull content information
 * @return this content instance
 */
public Content merge(Content source){
  this.setUpdated(source.getUpdated() != null ? (Date)source.getUpdated().clone() : null);
  this.setType(source.getType());
  this.setLabel(source.getLabel());
  this.setName(source.getName());
  this.setVendor(source.getVendor());
  this.setContentUrl(source.getContentUrl());
  this.setRequiredTags(source.getRequiredTags());
  this.setReleaseVersion(source.getReleaseVersion());
  this.setGpgUrl(source.getGpgUrl());
  this.setMetadataExpire(source.getMetadataExpire());
  this.setArches(source.getArches());
  this.setModifiedProductIds(source.getModifiedProductIds());
  return this;
}"
49263,"/** 
 * Populates this DTO with data from the given source entity.
 * @param source The source entity from which to copy data
 * @throws IllegalArgumentException if source is null
 * @return a reference to this DTO
 */
public ContentData populate(Content source){
  if (source == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  super.populate(source);
  this.uuid=source.getUuid();
  this.id=source.getId();
  this.type=source.getType();
  this.label=source.getLabel();
  this.name=source.getName();
  this.vendor=source.getVendor();
  this.contentUrl=source.getContentUrl();
  this.requiredTags=source.getRequiredTags();
  this.releaseVer=source.getReleaseVer();
  this.gpgUrl=source.getGpgUrl();
  this.metadataExpire=source.getMetadataExpire();
  this.setModifiedProductIds(source.getModifiedProductIds());
  return this;
}","/** 
 * Populates this DTO with data from the given source entity.
 * @param source The source entity from which to copy data
 * @throws IllegalArgumentException if source is null
 * @return a reference to this DTO
 */
public ContentData populate(Content source){
  if (source == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  super.populate(source);
  this.uuid=source.getUuid();
  this.id=source.getId();
  this.type=source.getType();
  this.label=source.getLabel();
  this.name=source.getName();
  this.vendor=source.getVendor();
  this.contentUrl=source.getContentUrl();
  this.requiredTags=source.getRequiredTags();
  this.releaseVer=source.getReleaseVersion();
  this.gpgUrl=source.getGpgUrl();
  this.metadataExpire=source.getMetadataExpire();
  this.setModifiedProductIds(source.getModifiedProductIds());
  return this;
}"
49264,"/** 
 * Adds the given content to this product DTO. If a matching content has already been added to this product, it will be overwritten by the specified content.
 * @param content The product content DTO to add to this product
 * @throws IllegalArgumentException if content is null
 * @return true if adding the content resulted in a change to this product; false otherwise
 */
public boolean addProductContent(ProductContent content){
  if (content == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this.addProductContent(new ProductContentData(content));
}","/** 
 * Adds the given content to this product DTO. If a matching content has already been added to this product, it will be overwritten by the specified content.
 * @param productContent The product content DTO to add to this product
 * @throws IllegalArgumentException if productContent is null
 * @return true if adding the content resulted in a change to this product; false otherwise
 */
public boolean addProductContent(ProductContent productContent){
  if (productContent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this.addProductContent(productContent.toDTO());
}"
49265,"/** 
 * Adds the given content to this product DTO. If a matching content has already been added to this product, it will be overwritten by the specified content.
 * @param content The product content DTO to add to this product
 * @throws IllegalArgumentException if content is null
 * @return true if adding the content resulted in a change to this product; false otherwise
 */
public boolean addContent(Content content,boolean enabled){
  if (content == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this.addProductContent(new ProductContentData(new ContentData(content),enabled));
}","/** 
 * Adds the given content to this product DTO. If a matching content has already been added to this product, it will be overwritten by the specified content.
 * @param content The product content DTO to add to this product
 * @throws IllegalArgumentException if content is null
 * @return true if adding the content resulted in a change to this product; false otherwise
 */
public boolean addContent(Content content,boolean enabled){
  if (content == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this.addProductContent(new ProductContentData(content.toDTO(),enabled));
}"
49266,"@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=400,message=""String_Node_Str"")}) @GET @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public Content getContent(@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey,@PathParam(""String_Node_Str"") String contentId){
  Owner owner=this.getOwnerByKey(ownerKey);
  Content content=this.contentCurator.lookupById(owner,contentId);
  if (content == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",contentId));
  }
  return content;
}","@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"") @ApiResponses({@ApiResponse(code=400,message=""String_Node_Str"")}) @GET @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public ContentData getContent(@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey,@PathParam(""String_Node_Str"") String contentId){
  Owner owner=this.getOwnerByKey(ownerKey);
  Content content=this.fetchContent(owner,contentId);
  return content.toDTO();
}"
49267,"/** 
 * Creates or merges the given Content object.
 * @param owner The owner for which to create the new content
 * @param content The content to create or merge
 * @return the newly created and/or merged Content object.
 */
private Content createContentImpl(Owner owner,ContentData content){
  Content entity=null;
  if (content.getId() == null || content.getId().trim().length() == 0) {
    content.setId(this.idGenerator.generateId());
    entity=this.contentManager.createContent(content,owner);
  }
 else {
    Content existing=this.ownerContentCurator.getContentById(owner,content.getId());
    if (existing != null) {
      entity=this.contentManager.updateContent(existing,content,owner,true);
    }
 else {
      entity=this.contentManager.createContent(content,owner);
    }
  }
  return entity;
}","/** 
 * Creates or merges the given Content object.
 * @param owner The owner for which to create the new content
 * @param content The content to create or merge
 * @return the newly created and/or merged Content object.
 */
private Content createContentImpl(Owner owner,ContentData content){
  Content entity=null;
  if (content.getId() == null || content.getId().trim().length() == 0) {
    content.setId(this.idGenerator.generateId());
    entity=this.contentManager.createContent(content,owner);
  }
 else {
    Content existing=this.ownerContentCurator.getContentById(owner,content.getId());
    if (existing != null) {
      if (existing.isLocked()) {
        throw new ForbiddenException(i18n.tr(""String_Node_Str"",existing.getId()));
      }
      entity=this.contentManager.updateContent(existing,content,owner,true);
    }
 else {
      entity=this.contentManager.createContent(content,owner);
    }
  }
  return entity;
}"
49268,"@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"") @GET @Produces(MediaType.APPLICATION_JSON) public List<Content> list(@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey){
  Owner owner=this.getOwnerByKey(ownerKey);
  return contentCurator.listByOwner(owner);
}","@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"") @GET @Produces(MediaType.APPLICATION_JSON) public Response list(@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey){
  final Owner owner=this.getOwnerByKey(ownerKey);
  final Collection<Content> contents=this.ownerContentCurator.getContentByOwner(owner);
  final ObjectMapper mapper=new JsonProvider(true).locateMapper(Object.class,MediaType.APPLICATION_JSON_TYPE);
  StreamingOutput output=new StreamingOutput(){
    @Override public void write(    OutputStream stream) throws IOException, WebApplicationException {
      JsonGenerator generator=mapper.getJsonFactory().createGenerator(stream);
      generator.writeStartArray();
      for (      Content content : contents) {
        mapper.writeValue(generator,content.toDTO());
      }
      generator.writeEndArray();
      generator.flush();
    }
  }
;
  return Response.ok(output).build();
}"
49269,"@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"") @PUT @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public ContentData updateContent(@PathParam(""String_Node_Str"") String ownerKey,@PathParam(""String_Node_Str"") String contentId,ContentData content){
  Owner owner=this.getOwnerByKey(ownerKey);
  Content existing=this.getContent(ownerKey,contentId);
  if (existing.isLocked()) {
    throw new ForbiddenException(i18n.tr(""String_Node_Str"",content.getId()));
  }
  existing=this.contentManager.updateContent(existing,content,owner,true);
  return existing.toDTO();
}","@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"") @PUT @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public ContentData updateContent(@PathParam(""String_Node_Str"") String ownerKey,@PathParam(""String_Node_Str"") String contentId,ContentData content){
  Owner owner=this.getOwnerByKey(ownerKey);
  Content existing=this.fetchContent(owner,contentId);
  if (existing.isLocked()) {
    throw new ForbiddenException(i18n.tr(""String_Node_Str"",existing.getId()));
  }
  existing=this.contentManager.updateContent(existing,content,owner,true);
  return existing.toDTO();
}"
49270,"@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"") @DELETE @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public void remove(@PathParam(""String_Node_Str"") String ownerKey,@PathParam(""String_Node_Str"") String contentId){
  Owner owner=this.getOwnerByKey(ownerKey);
  Content content=this.getContent(ownerKey,contentId);
  if (content.isLocked()) {
    throw new ForbiddenException(i18n.tr(""String_Node_Str"",content.getId()));
  }
  this.contentManager.removeContent(content,owner,true);
}","@ApiOperation(notes=""String_Node_Str"",value=""String_Node_Str"") @DELETE @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public void remove(@PathParam(""String_Node_Str"") String ownerKey,@PathParam(""String_Node_Str"") String contentId){
  Owner owner=this.getOwnerByKey(ownerKey);
  Content content=this.fetchContent(owner,contentId);
  if (content.isLocked()) {
    throw new ForbiddenException(i18n.tr(""String_Node_Str"",content.getId()));
  }
  this.contentManager.removeContent(content,owner,true);
}"
49271,"public Set<Content> getChangedContent(Owner owner,Map<String,ContentData> contentCache){
  Set<Content> changed=Util.newSet();
  log.debug(""String_Node_Str"",contentCache.size());
  for (  String cid : contentCache.keySet()) {
    ContentData incoming=contentCache.get(cid);
    Content existing=this.contentCurator.lookupById(owner,cid);
    incoming.setLocked(true);
    if (existing == null) {
      log.info(""String_Node_Str"",owner.getKey(),cid);
      existing=this.contentManager.createContent(incoming,owner);
    }
 else     if (!existing.isChangedBy(incoming)) {
      log.info(""String_Node_Str"",owner.getKey(),cid);
      existing=this.contentManager.updateContent(existing,incoming,owner,false);
      changed.add(existing);
    }
  }
  return changed;
}","public Set<Content> getChangedContent(Owner owner,Map<String,ContentData> contentCache){
  Set<Content> changed=Util.newSet();
  log.debug(""String_Node_Str"",contentCache.size());
  for (  String cid : contentCache.keySet()) {
    ContentData incoming=contentCache.get(cid);
    Content existing=this.ownerContentCurator.getContentById(owner,cid);
    if (existing == null) {
      log.info(""String_Node_Str"",owner.getKey(),cid);
      existing=this.contentManager.createContent(incoming,owner);
    }
 else     if (existing.isChangedBy(incoming)) {
      log.info(""String_Node_Str"",owner.getKey(),cid);
      existing=this.contentManager.updateContent(existing,incoming,owner,false);
      changed.add(existing);
    }
 else {
      log.info(""String_Node_Str"");
    }
  }
  return changed;
}"
49272,"/** 
 * Creates a Subscription object using information derived from the specified pool. Used to support deprecated API calls that still require a subscription.
 * @param pool The pool from which to build a subscription
 * @return a new subscription object derived from the specified pool.
 */
@Override public Subscription fabricateSubscriptionFromPool(Pool pool){
  if (pool == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Long poolQuantity=pool.getQuantity();
  Long multiplier=1L;
  if (pool.getProduct() != null) {
    multiplier=pool.getProduct().getMultiplier();
  }
 else {
    log.error(""String_Node_Str"",pool.getId());
  }
  if (poolQuantity != null && multiplier != null && multiplier != 0 && pool.getProduct() != null) {
    if (poolQuantity % multiplier != 0) {
      log.error(""String_Node_Str"" + ""String_Node_Str"",pool.getId(),poolQuantity,multiplier);
    }
 else {
      poolQuantity/=multiplier;
    }
    if (pool.getProduct().hasAttribute(""String_Node_Str"") && pool.getUpstreamPoolId() == null) {
      Integer instMult=null;
      String stringInstmult=pool.getProduct().getAttributeValue(""String_Node_Str"");
      try {
        instMult=Integer.parseInt(stringInstmult);
      }
 catch (      NumberFormatException nfe) {
        log.error(""String_Node_Str"",stringInstmult);
      }
      if (instMult != null && instMult != 0 && poolQuantity % instMult == 0) {
        poolQuantity/=instMult;
      }
 else {
        log.error(""String_Node_Str"" + ""String_Node_Str"",poolQuantity,instMult,poolQuantity);
      }
    }
  }
 else {
    log.warn(""String_Node_Str"",poolQuantity,multiplier,pool.getProduct());
  }
  return new Subscription(pool);
}","/** 
 * Creates a Subscription object using information derived from the specified pool. Used to support deprecated API calls that still require a subscription.
 * @param pool The pool from which to build a subscription
 * @return a new subscription object derived from the specified pool.
 */
@Override public Subscription fabricateSubscriptionFromPool(Pool pool){
  if (pool == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Long poolQuantity=pool.getQuantity();
  Long multiplier=1L;
  if (pool.getProduct() != null) {
    multiplier=pool.getProduct().getMultiplier();
  }
 else {
    log.error(""String_Node_Str"",pool.getId());
  }
  if (poolQuantity != null && multiplier != null && multiplier != 0 && pool.getProduct() != null) {
    if (poolQuantity % multiplier != 0) {
      log.error(""String_Node_Str"" + ""String_Node_Str"",pool.getId(),poolQuantity,multiplier);
    }
 else {
      poolQuantity/=multiplier;
    }
    if (pool.getProduct().hasAttribute(""String_Node_Str"") && pool.getUpstreamPoolId() == null) {
      Integer instMult=null;
      String stringInstmult=pool.getProduct().getAttributeValue(""String_Node_Str"");
      try {
        instMult=Integer.parseInt(stringInstmult);
      }
 catch (      NumberFormatException nfe) {
        log.error(""String_Node_Str"",stringInstmult);
      }
      if (instMult != null && instMult != 0 && poolQuantity % instMult == 0) {
        poolQuantity/=instMult;
      }
 else {
        log.error(""String_Node_Str"" + ""String_Node_Str"",poolQuantity,instMult,poolQuantity);
      }
    }
  }
 else {
    log.warn(""String_Node_Str"",poolQuantity,multiplier,pool.getProduct());
  }
  Subscription subscription=new Subscription(pool);
  subscription.setQuantity(poolQuantity);
  return subscription;
}"
49273,"public Set<Product> getChangedProducts(Owner owner,Map<String,ProductData> productCache){
  log.debug(""String_Node_Str"",productCache.size());
  Set<Product> changedProducts=Util.newSet();
  for (  String pid : productCache.keySet()) {
    ProductData incoming=productCache.get(pid);
    Product existing=this.ownerProductCurator.getProductById(owner,pid);
    incoming.setLocked(true);
    if (existing == null) {
      log.info(""String_Node_Str"",owner.getKey(),pid);
      existing=this.productManager.createProduct(incoming,owner);
    }
 else     if (!existing.isChangedBy(incoming)) {
      log.info(""String_Node_Str"",owner.getKey(),pid);
      existing=this.productManager.updateProduct(existing,incoming,owner,false);
      changedProducts.add(existing);
    }
  }
  return changedProducts;
}","public Set<Product> getChangedProducts(Owner owner,Map<String,ProductData> productCache){
  log.debug(""String_Node_Str"",productCache.size());
  Set<Product> changedProducts=Util.newSet();
  for (  String pid : productCache.keySet()) {
    ProductData incoming=productCache.get(pid);
    Product existing=this.ownerProductCurator.getProductById(owner,pid);
    incoming.setLocked(true);
    if (existing == null) {
      log.info(""String_Node_Str"",owner.getKey(),pid);
      existing=this.productManager.createProduct(incoming,owner);
    }
 else     if (existing.isChangedBy(incoming)) {
      log.info(""String_Node_Str"",owner.getKey(),pid);
      existing=this.productManager.updateProduct(existing,incoming,owner,false);
      changedProducts.add(existing);
    }
  }
  return changedProducts;
}"
49274,"private void updateContentRefs(Map<String,Content> contentCache,Owner owner,Product product){
  if (product == null) {
    return;
  }
  for (  ProductContent pc : product.getProductContent()) {
    Content content=pc.getContent();
    Content existing=this.contentCurator.lookupById(owner,content.getId());
    if (existing == null) {
      throw new RuntimeException(String.format(""String_Node_Str"",content));
    }
    pc.setContent(existing);
  }
}","private void updateContentRefs(Map<String,Content> contentCache,Owner owner,Product product){
  if (product == null) {
    return;
  }
  for (  ProductContent pc : product.getProductContent()) {
    Content content=pc.getContent();
    Content existing=this.ownerContentCurator.getContentById(owner,content.getId());
    if (existing == null) {
      throw new RuntimeException(String.format(""String_Node_Str"",content));
    }
    pc.setContent(existing);
  }
}"
49275,"/** 
 * Refreshes the specified content under the given owner/org.
 * @param owner The owner for which to refresh content
 * @param subs The subscriptions from which to pull content
 * @return the set of existing content which was updated/changed as a result of this operation
 */
protected Set<Content> refreshContent(Owner owner,Collection<Subscription> subs){
  Map<String,ContentData> content=new HashMap<String,ContentData>();
  log.info(""String_Node_Str"",subs.size());
  for (  Subscription sub : subs) {
    this.addProductContentToMap(content,sub.getProduct());
    this.addProductContentToMap(content,sub.getDerivedProduct());
    for (    ProductData product : sub.getProvidedProducts()) {
      this.addProductContentToMap(content,product);
    }
    for (    ProductData product : sub.getDerivedProvidedProducts()) {
      this.addProductContentToMap(content,product);
    }
  }
  Set<Content> changed=this.getChangedContent(owner,content);
  this.contentCurator.flush();
  return changed;
}","/** 
 * Refreshes the specified content under the given owner/org.
 * @param owner The owner for which to refresh content
 * @param subs The subscriptions from which to pull content
 * @return the set of existing content which was updated/changed as a result of this operation
 */
protected Set<Content> refreshContent(Owner owner,Collection<Subscription> subs){
  Map<String,ContentData> content=new HashMap<String,ContentData>();
  log.info(""String_Node_Str"",subs.size());
  if (subs != null) {
    for (    Subscription sub : subs) {
      this.addProductContentToMap(content,sub.getProduct());
      this.addProductContentToMap(content,sub.getDerivedProduct());
      for (      ProductData product : sub.getProvidedProducts()) {
        this.addProductContentToMap(content,product);
      }
      for (      ProductData product : sub.getDerivedProvidedProducts()) {
        this.addProductContentToMap(content,product);
      }
    }
  }
  Set<Content> changed=this.getChangedContent(owner,content);
  this.ownerContentCurator.flush();
  return changed;
}"
49276,"/** 
 * @param poolCurator
 * @param subAdapter
 * @param sink
 * @param eventFactory
 * @param config
 */
@Inject public CandlepinPoolManager(PoolCurator poolCurator,EventSink sink,EventFactory eventFactory,Configuration config,Enforcer enforcer,PoolRules poolRules,EntitlementCurator entitlementCurator,ConsumerCurator consumerCurator,EntitlementCertificateCurator entitlementCertCurator,EntitlementCertificateGenerator ecGenerator,ComplianceRules complianceRules,AutobindRules autobindRules,ActivationKeyRules activationKeyRules,ProductCurator productCurator,ProductManager productManager,ContentCurator contentCurator,ContentManager contentManager,OwnerCurator ownerCurator,OwnerProductCurator ownerProductCurator,PinsetterKernel pinsetterKernel,I18n i18n){
  this.poolCurator=poolCurator;
  this.sink=sink;
  this.eventFactory=eventFactory;
  this.config=config;
  this.entitlementCurator=entitlementCurator;
  this.consumerCurator=consumerCurator;
  this.enforcer=enforcer;
  this.poolRules=poolRules;
  this.entitlementCertificateCurator=entitlementCertCurator;
  this.ecGenerator=ecGenerator;
  this.complianceRules=complianceRules;
  this.productCurator=productCurator;
  this.autobindRules=autobindRules;
  this.activationKeyRules=activationKeyRules;
  this.productCurator=productCurator;
  this.productManager=productManager;
  this.contentCurator=contentCurator;
  this.contentManager=contentManager;
  this.ownerCurator=ownerCurator;
  this.ownerProductCurator=ownerProductCurator;
  this.pinsetterKernel=pinsetterKernel;
  this.i18n=i18n;
}","/** 
 * @param poolCurator
 * @param subAdapter
 * @param sink
 * @param eventFactory
 * @param config
 */
@Inject public CandlepinPoolManager(PoolCurator poolCurator,EventSink sink,EventFactory eventFactory,Configuration config,Enforcer enforcer,PoolRules poolRules,EntitlementCurator entitlementCurator,ConsumerCurator consumerCurator,EntitlementCertificateCurator entitlementCertCurator,EntitlementCertificateGenerator ecGenerator,ComplianceRules complianceRules,AutobindRules autobindRules,ActivationKeyRules activationKeyRules,ProductCurator productCurator,ProductManager productManager,ContentManager contentManager,OwnerContentCurator ownerContentCurator,OwnerCurator ownerCurator,OwnerProductCurator ownerProductCurator,PinsetterKernel pinsetterKernel,I18n i18n){
  this.poolCurator=poolCurator;
  this.sink=sink;
  this.eventFactory=eventFactory;
  this.config=config;
  this.entitlementCurator=entitlementCurator;
  this.consumerCurator=consumerCurator;
  this.enforcer=enforcer;
  this.poolRules=poolRules;
  this.entitlementCertificateCurator=entitlementCertCurator;
  this.ecGenerator=ecGenerator;
  this.complianceRules=complianceRules;
  this.productCurator=productCurator;
  this.autobindRules=autobindRules;
  this.activationKeyRules=activationKeyRules;
  this.productCurator=productCurator;
  this.productManager=productManager;
  this.contentManager=contentManager;
  this.ownerContentCurator=ownerContentCurator;
  this.ownerCurator=ownerCurator;
  this.ownerProductCurator=ownerProductCurator;
  this.pinsetterKernel=pinsetterKernel;
  this.i18n=i18n;
}"
49277,"private void addProductContentToMap(Map<String,ContentData> contentMap,ProductData product){
  if (product == null) {
    return;
  }
  Map<String,ContentData> mapped=new HashMap<String,ContentData>();
  List<ProductContentData> duplicates=new LinkedList<ProductContentData>();
  for (  ProductContentData pcd : product.getProductContent()) {
    ContentData content=pcd.getContent();
    if (mapped.containsKey(content.getId())) {
      log.warn(""String_Node_Str"" + ""String_Node_Str"",product,content,mapped.get(content.getId()));
      duplicates.add(pcd);
      continue;
    }
    mapped.put(content.getId(),content);
    ContentData existing=contentMap.get(content.getId());
    if (existing != null && !content.equals(existing)) {
      log.warn(""String_Node_Str"" + ""String_Node_Str"",content.getId(),existing,content);
    }
    contentMap.put(content.getId(),content);
  }
  if (duplicates.size() > 0) {
    log.debug(""String_Node_Str"");
  }
}","private void addProductContentToMap(Map<String,ContentData> contentMap,ProductData product){
  if (product == null) {
    return;
  }
  Map<String,ContentData> mapped=new HashMap<String,ContentData>();
  List<ProductContentData> duplicates=new LinkedList<ProductContentData>();
  if (product.getProductContent() != null) {
    for (    ProductContentData pcd : product.getProductContent()) {
      ContentData content=pcd.getContent();
      if (mapped.containsKey(content.getId())) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"",product,content,mapped.get(content.getId()));
        duplicates.add(pcd);
        continue;
      }
      mapped.put(content.getId(),content);
      ContentData existing=contentMap.get(content.getId());
      if (existing != null && !content.equals(existing)) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"",content.getId(),existing,content);
      }
      contentMap.put(content.getId(),content);
    }
  }
  if (duplicates.size() > 0) {
    log.debug(""String_Node_Str"");
  }
}"
49278,"/** 
 * Creates a new Content for the given owner, potentially using a different version than the entity provided if a matching entity has already been registered for another owner.
 * @param entity A Content instance representing the content to create
 * @param owner The owner for which to create the content
 * @throws IllegalStateException if this method is called with an entity that already exists in the backing database for the given owner
 * @throws NullPointerException if entity or owner is null
 * @return a new Content instance representing the specified content for the given owner
 */
@Transactional public Content createContent(Content entity,Owner owner){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"",entity,owner);
  Content existing=this.contentCurator.lookupById(owner,entity.getId());
  if (existing != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  List<Content> alternateVersions=this.contentCurator.getContentByVersion(entity.getId(),entity.hashCode()).list();
  for (  Content alt : alternateVersions) {
    if (alt.equals(entity)) {
      this.ownerContentCurator.mapContentToOwner(alt,owner);
      return alt;
    }
  }
  entity=this.contentCurator.create(entity);
  this.ownerContentCurator.mapContentToOwner(entity,owner);
  return entity;
}","/** 
 * Creates a new Content for the given owner, potentially using a different version than the entity provided if a matching entity has already been registered for another owner.
 * @param entity A Content instance representing the content to create
 * @param owner The owner for which to create the content
 * @throws IllegalStateException if this method is called with an entity that already exists in the backing database for the given owner
 * @throws NullPointerException if entity or owner is null
 * @return a new Content instance representing the specified content for the given owner
 */
@Transactional public Content createContent(Content entity,Owner owner){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"",entity,owner);
  Content existing=this.ownerContentCurator.getContentById(owner,entity.getId());
  if (existing != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  List<Content> alternateVersions=this.contentCurator.getContentByVersion(entity.getId(),entity.hashCode()).list();
  log.debug(""String_Node_Str"",alternateVersions.size());
  for (  Content alt : alternateVersions) {
    if (alt.equals(entity)) {
      this.ownerContentCurator.mapContentToOwner(alt,owner);
      return alt;
    }
  }
  entity=this.contentCurator.create(entity);
  this.ownerContentCurator.mapContentToOwner(entity,owner);
  return entity;
}"
49279,"/** 
 * Updates the specified content instance, creating a new version of the content as necessary. The content instance returned by this method is not guaranteed to be the same instance passed in. As such, once this method has been called, callers should only use the instance output by this method.
 * @param entity The content entity to update
 * @param owner The owner for which to update the content
 * @param regenerateEntitlementCerts Whether or not changes made to the content should trigger the regeneration of entitlement certificates for affected consumers
 * @throws IllegalStateException if this method is called with an entity does not exist in the backing database for the given owner
 * @throws IllegalArgumentException if either the provided content entity or owner are null
 * @return the updated content entity, or a new content entity
 */
@Transactional public Content updateContent(Content entity,ContentData update,Owner owner,boolean regenerateEntitlementCerts){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"",entity,owner);
  entity=this.contentCurator.lookupById(owner,entity.getId());
  if (entity == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!entity.isChangedBy(update)) {
    return entity;
  }
  Content updated=this.applyContentChanges((Content)entity.clone(),update,owner);
  List<Content> alternateVersions=this.contentCurator.getContentByVersion(update.getId(),updated.hashCode()).list();
  log.debug(""String_Node_Str"",alternateVersions.size());
  for (  Content alt : alternateVersions) {
    if (alt.equals(updated)) {
      log.debug(""String_Node_Str"",updated,alt);
      List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,Arrays.asList(updated.getId()));
      List<Owner> owners=Arrays.asList(owner);
      updated=this.ownerContentCurator.updateOwnerContentReferences(updated,alt,owners);
      ContentData cdata=updated.toDTO();
      for (      Product product : affectedProducts) {
        ProductData pdata=product.toDTO();
        ProductContentData pcd=pdata.getProductContent(updated.getId());
        if (pcd != null) {
          pcd.setContent(cdata);
          this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
        }
      }
      return updated;
    }
  }
  if (this.ownerContentCurator.getOwnerCount(updated) == 1) {
    log.debug(""String_Node_Str"",updated);
    updated=this.contentCurator.merge(updated);
    if (regenerateEntitlementCerts) {
      this.entitlementCertGenerator.regenerateCertificatesOf(this.productCurator.getProductsWithContent(Arrays.asList(updated.getUuid())),true);
    }
    return updated;
  }
  log.debug(""String_Node_Str"",updated);
  List<Owner> owners=Arrays.asList(owner);
  updated.setUuid(null);
  List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,Arrays.asList(updated.getId()));
  updated=this.contentCurator.create(updated);
  ContentData cdata=updated.toDTO();
  for (  Product product : affectedProducts) {
    ProductData pdata=product.toDTO();
    ProductContentData pcd=pdata.getProductContent(updated.getId());
    if (pcd != null) {
      pcd.setContent(cdata);
      this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
    }
    this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
  }
  return this.ownerContentCurator.updateOwnerContentReferences(entity,updated,owners);
}","/** 
 * Updates the specified content instance, creating a new version of the content as necessary. The content instance returned by this method is not guaranteed to be the same instance passed in. As such, once this method has been called, callers should only use the instance output by this method.
 * @param entity The content entity to update
 * @param owner The owner for which to update the content
 * @param regenerateEntitlementCerts Whether or not changes made to the content should trigger the regeneration of entitlement certificates for affected consumers
 * @throws IllegalStateException if this method is called with an entity does not exist in the backing database for the given owner
 * @throws IllegalArgumentException if either the provided content entity or owner are null
 * @return the updated content entity, or a new content entity
 */
@Transactional public Content updateContent(Content entity,ContentData update,Owner owner,boolean regenerateEntitlementCerts){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (update == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (owner == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"",entity,owner);
  entity=this.ownerContentCurator.getContentById(owner,entity.getId());
  if (entity == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!entity.isChangedBy(update)) {
    return entity;
  }
  Content updated=this.applyContentChanges((Content)entity.clone(),update,owner);
  List<Content> alternateVersions=this.contentCurator.getContentByVersion(update.getId(),updated.hashCode()).list();
  log.debug(""String_Node_Str"",alternateVersions.size());
  for (  Content alt : alternateVersions) {
    if (alt.equals(updated)) {
      log.debug(""String_Node_Str"",updated,alt);
      List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,Arrays.asList(updated.getId()));
      List<Owner> owners=Arrays.asList(owner);
      updated=this.ownerContentCurator.updateOwnerContentReferences(updated,alt,owners);
      ContentData cdata=updated.toDTO();
      for (      Product product : affectedProducts) {
        ProductData pdata=product.toDTO();
        ProductContentData pcd=pdata.getProductContent(updated.getId());
        if (pcd != null) {
          pcd.setContent(cdata);
          this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
        }
      }
      return updated;
    }
  }
  if (this.ownerContentCurator.getOwnerCount(updated) == 1) {
    log.debug(""String_Node_Str"",updated);
    updated=this.contentCurator.merge(updated);
    if (regenerateEntitlementCerts) {
      List<Product> affectedProducts=this.productCurator.getProductsWithContent(Arrays.asList(updated.getUuid()));
      this.entitlementCertGenerator.regenerateCertificatesOf(Arrays.asList(owner),affectedProducts,true);
    }
    return updated;
  }
  log.debug(""String_Node_Str"",updated);
  updated.setUuid(null);
  List<Product> affectedProducts=this.productCurator.getProductsWithContent(owner,Arrays.asList(updated.getId()));
  updated=this.contentCurator.create(updated);
  ContentData cdata=updated.toDTO();
  for (  Product product : affectedProducts) {
    ProductData pdata=product.toDTO();
    ProductContentData pcd=pdata.getProductContent(updated.getId());
    if (pcd != null) {
      pcd.setContent(cdata);
      this.productManager.updateProduct(product,pdata,owner,regenerateEntitlementCerts);
    }
  }
  return this.ownerContentCurator.updateOwnerContentReferences(entity,updated,Arrays.asList(owner));
}"
49280,"/** 
 * Regenerates the entitlement certificates for all pools using any of the the specified product(s), effective for the all owners using them.
 * @param products A collection of products for which to regenerate affected certificates
 * @param lazy Whether or not to generate the certificate immediately, or mark it dirty and allow it to be regenerated on-demand
 */
@Transactional public void regenerateCertificatesOf(Collection<Product> products,boolean lazy){
  Set<Owner> owners=new HashSet<Owner>();
  for (  Product product : products) {
    throw new RuntimeException(""String_Node_Str"");
  }
  this.regenerateCertificatesOf(owners,products,lazy);
}","/** 
 * Regenerates the entitlement certificates for all pools using any of the the specified product(s), effective for the given owners.
 * @param owners A collection of owners for which the certificates should be generated. Pools using the given products but not owned by an owner within this collection will not have their certificates regenerated.
 * @param products A collection of products for which to regenerate affected certificates
 * @param lazy Whether or not to generate the certificate immediately, or mark it dirty and allow it to be regenerated on-demand
 */
@Transactional public void regenerateCertificatesOf(Collection<Owner> owners,Collection<Product> products,boolean lazy){
  List<Pool> pools=new LinkedList<Pool>();
  Set<String> productIds=new HashSet<String>();
  Date now=new Date();
  for (  Product product : products) {
    productIds.add(product.getId());
  }
  for (  Owner owner : owners) {
    pools.addAll(this.poolCurator.listAvailableEntitlementPools(null,owner,productIds,now,false));
  }
  for (  Pool pool : pools) {
    this.regenerateCertificatesOf(pool.getEntitlements(),lazy);
  }
}"
49281,"@Transactional public void cleanupAndDelete(Owner owner,boolean revokeCerts){
  log.info(""String_Node_Str"" + owner);
  List<String> ids=ownerCurator.getConsumerUuids(owner.getKey());
  List<Consumer> consumers=consumerCurator.lockAndLoadBatch(ids);
  for (  Consumer c : consumers) {
    log.info(""String_Node_Str"",c);
    poolManager.revokeAllEntitlements(c,revokeCerts);
  }
  for (  Consumer consumer : consumers) {
    log.info(""String_Node_Str"",consumer);
    Consumer next=consumerCurator.find(consumer.getId());
    if (next != null) {
      consumerCurator.delete(next);
    }
  }
  for (  ActivationKey key : activationKeyCurator.listByOwner(owner)) {
    log.info(""String_Node_Str"",key);
    activationKeyCurator.delete(key);
  }
  for (  Environment e : owner.getEnvironments()) {
    log.info(""String_Node_Str"",e.getId());
    envCurator.delete(e);
  }
  for (  Pool p : poolManager.listPoolsByOwner(owner)) {
    log.info(""String_Node_Str"",p);
    poolManager.deletePool(p);
  }
  Pool ueberPool=poolManager.findUeberPool(owner);
  if (ueberPool != null) {
    poolManager.deletePool(ueberPool);
  }
  ExporterMetadata m=exportCurator.lookupByTypeAndOwner(ExporterMetadata.TYPE_PER_USER,owner);
  if (m != null) {
    log.info(""String_Node_Str"",m);
    exportCurator.delete(m);
  }
  for (  ImportRecord record : importRecordCurator.findRecords(owner)) {
    log.info(""String_Node_Str"",record);
    importRecordCurator.delete(record);
  }
  for (  PermissionBlueprint perm : permissionCurator.findByOwner(owner)) {
    log.info(""String_Node_Str"",perm.getAccess());
    perm.getRole().getPermissions().remove(perm);
    permissionCurator.delete(perm);
  }
  for (  Product p : this.ownerProductCurator.getProductsByOwner(owner)) {
    log.info(""String_Node_Str"",p);
    this.prodManager.removeProduct(p,owner);
  }
  contentCurator.flush();
  for (  Content c : contentCurator.listByOwner(owner)) {
    log.info(""String_Node_Str"",c);
    this.contentManager.removeContent(c,owner,false);
  }
  log.info(""String_Node_Str"",owner);
  ownerCurator.delete(owner);
}","@Transactional public void cleanupAndDelete(Owner owner,boolean revokeCerts){
  log.info(""String_Node_Str"" + owner);
  List<String> ids=ownerCurator.getConsumerUuids(owner.getKey());
  List<Consumer> consumers=consumerCurator.lockAndLoadBatch(ids);
  for (  Consumer c : consumers) {
    log.info(""String_Node_Str"",c);
    poolManager.revokeAllEntitlements(c,revokeCerts);
  }
  for (  Consumer consumer : consumers) {
    log.info(""String_Node_Str"",consumer);
    Consumer next=consumerCurator.find(consumer.getId());
    if (next != null) {
      consumerCurator.delete(next);
    }
  }
  for (  ActivationKey key : activationKeyCurator.listByOwner(owner)) {
    log.info(""String_Node_Str"",key);
    activationKeyCurator.delete(key);
  }
  for (  Environment e : owner.getEnvironments()) {
    log.info(""String_Node_Str"",e.getId());
    envCurator.delete(e);
  }
  for (  Pool p : poolManager.listPoolsByOwner(owner)) {
    log.info(""String_Node_Str"",p);
    poolManager.deletePool(p);
  }
  Pool ueberPool=poolManager.findUeberPool(owner);
  if (ueberPool != null) {
    poolManager.deletePool(ueberPool);
  }
  ExporterMetadata m=exportCurator.lookupByTypeAndOwner(ExporterMetadata.TYPE_PER_USER,owner);
  if (m != null) {
    log.info(""String_Node_Str"",m);
    exportCurator.delete(m);
  }
  for (  ImportRecord record : importRecordCurator.findRecords(owner)) {
    log.info(""String_Node_Str"",record);
    importRecordCurator.delete(record);
  }
  for (  PermissionBlueprint perm : permissionCurator.findByOwner(owner)) {
    log.info(""String_Node_Str"",perm.getAccess());
    perm.getRole().getPermissions().remove(perm);
    permissionCurator.delete(perm);
  }
  for (  Product p : this.ownerProductCurator.getProductsByOwner(owner)) {
    log.info(""String_Node_Str"",p);
    this.prodManager.removeProduct(p,owner);
  }
  ownerContentCurator.flush();
  for (  Content c : ownerContentCurator.getContentByOwner(owner)) {
    log.info(""String_Node_Str"",c);
    this.contentManager.removeContent(c,owner,false);
  }
  log.info(""String_Node_Str"",owner);
  ownerCurator.delete(owner);
}"
49282,"@Override @Transactional public void toExecute(JobExecutionContext ctx) throws JobExecutionException {
  try {
    JobDataMap map=ctx.getMergedJobDataMap();
    String uuid=(String)map.get(JobStatus.TARGET_ID);
    Date onDate=(Date)map.get(""String_Node_Str"");
    Boolean calculateComplianceUntill=(Boolean)map.get(""String_Node_Str"");
    Boolean forceUpdate=(Boolean)map.get(""String_Node_Str"");
    Boolean update=(Boolean)map.get(""String_Node_Str"");
    Consumer consumer=consumerCurator.verifyAndLookupConsumer(uuid);
    consumerCurator.lockAndLoad(consumer);
    complianceRules.getStatus(consumer,onDate,calculateComplianceUntill,update);
    if (forceUpdate) {
      consumerCurator.update(consumer);
    }
    ctx.setResult(""String_Node_Str"" + consumer.getUuid());
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    ctx.setResult(e.getMessage());
    throw new JobExecutionException(e.getMessage(),e,false);
  }
}","@Override @Transactional public void toExecute(JobExecutionContext ctx) throws JobExecutionException {
  JobDataMap map=ctx.getMergedJobDataMap();
  String uuid=(String)map.get(JobStatus.TARGET_ID);
  Date onDate=(Date)map.get(""String_Node_Str"");
  Boolean calculateComplianceUntill=(Boolean)map.get(""String_Node_Str"");
  Boolean forceUpdate=(Boolean)map.get(""String_Node_Str"");
  Boolean update=(Boolean)map.get(""String_Node_Str"");
  try {
    Consumer consumer=consumerCurator.lockAndLoadByUuid(uuid);
    if (consumer == null) {
      String message=""String_Node_Str"";
      log.info(message,uuid);
      ctx.setResult(String.format(message,uuid));
      return;
    }
    complianceRules.getStatus(consumer,onDate,calculateComplianceUntill,update);
    if (forceUpdate) {
      consumerCurator.update(consumer);
    }
    ctx.setResult(String.format(""String_Node_Str"",consumer.getUuid()));
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    ctx.setResult(e.getMessage());
    throw new JobExecutionException(e.getMessage(),e,false);
  }
}"
49283,"@Test @SuppressWarnings(""String_Node_Str"") public void normalCreate(){
  Consumer consumer=new Consumer(""String_Node_Str"",""String_Node_Str"",owner,ct);
  consumerCurator.create(consumer);
  List<Product> results=entityManager().createQuery(""String_Node_Str"").getResultList();
  assertEquals(1,results.size());
}","@Test public void normalCreate(){
  Consumer consumer=new Consumer(""String_Node_Str"",""String_Node_Str"",owner,ct);
  consumerCurator.create(consumer);
  List<Consumer> results=entityManager().createQuery(""String_Node_Str"",Consumer.class).getResultList();
  assertEquals(1,results.size());
}"
49284,"@Test public void scheduleSimpleStatusCheck() throws JobExecutionException {
  JobDetail detail=job.scheduleStatusCheck(consumer,new Date(),true,false);
  assertNotNull(detail);
  when(ctx.getMergedJobDataMap()).thenReturn(detail.getJobDataMap());
  when(curator.verifyAndLookupConsumer(consumerUuid)).thenReturn(consumer);
  job.execute(ctx);
  verify(curator).lockAndLoad(eq(consumer));
  verify(rules).getStatus(eq(consumer),any(Date.class),eq(true),eq(false));
}","@Test public void scheduleSimpleStatusCheck() throws JobExecutionException {
  JobDetail detail=job.scheduleStatusCheck(consumer,new Date(),true,false);
  assertNotNull(detail);
  when(ctx.getMergedJobDataMap()).thenReturn(detail.getJobDataMap());
  when(curator.lockAndLoadByUuid(consumerUuid)).thenReturn(consumer);
  job.execute(ctx);
  verify(curator).lockAndLoadByUuid(eq(consumerUuid));
  verify(rules).getStatus(eq(consumer),any(Date.class),eq(true),eq(false));
}"
49285,"@Test(expected=JobExecutionException.class) public void exceptionOnSchedule() throws JobExecutionException {
  JobDetail detail=job.scheduleWithForceUpdate(consumer);
  assertNotNull(detail);
  when(ctx.getMergedJobDataMap()).thenReturn(detail.getJobDataMap());
  when(curator.verifyAndLookupConsumer(consumerUuid)).thenReturn(consumer);
  when(rules.getStatus(eq(consumer),any(Date.class),eq(false),eq(false))).thenThrow(new RuleExecutionException(""String_Node_Str""));
  job.execute(ctx);
}","@Test(expected=JobExecutionException.class) public void exceptionOnSchedule() throws JobExecutionException {
  JobDetail detail=job.scheduleWithForceUpdate(consumer);
  assertNotNull(detail);
  when(ctx.getMergedJobDataMap()).thenReturn(detail.getJobDataMap());
  when(curator.lockAndLoadByUuid(consumerUuid)).thenReturn(consumer);
  when(rules.getStatus(eq(consumer),any(Date.class),eq(false),eq(false))).thenThrow(new RuleExecutionException(""String_Node_Str""));
  job.execute(ctx);
}"
49286,"@Test public void scheduleWithForceUpdateCheck() throws JobExecutionException {
  JobDetail detail=job.scheduleWithForceUpdate(consumer);
  assertNotNull(detail);
  when(ctx.getMergedJobDataMap()).thenReturn(detail.getJobDataMap());
  when(curator.verifyAndLookupConsumer(consumerUuid)).thenReturn(consumer);
  job.execute(ctx);
  verify(curator).lockAndLoad(eq(consumer));
  verify(rules).getStatus(eq(consumer),any(Date.class),eq(false),eq(false));
  verify(curator).update(consumer);
}","@Test public void scheduleWithForceUpdateCheck() throws JobExecutionException {
  JobDetail detail=job.scheduleWithForceUpdate(consumer);
  assertNotNull(detail);
  when(ctx.getMergedJobDataMap()).thenReturn(detail.getJobDataMap());
  when(curator.lockAndLoadByUuid(consumerUuid)).thenReturn(consumer);
  job.execute(ctx);
  verify(curator).lockAndLoadByUuid(eq(consumerUuid));
  verify(rules).getStatus(eq(consumer),any(Date.class),eq(false),eq(false));
  verify(curator).update(consumer);
}"
49287,"@Override public List<Pool> createPools(List<Pool> pools){
  if (pools != null && !pools.isEmpty()) {
    poolCurator.saveOrUpdateAll(pools);
    for (    Pool pool : pools) {
      log.debug(""String_Node_Str"",pool);
      if (pool != null) {
        sink.emitPoolCreated(pool);
      }
    }
  }
  return pools;
}","@Override public List<Pool> createPools(List<Pool> pools){
  if (pools != null && !pools.isEmpty()) {
    poolCurator.saveOrUpdateAll(pools,false);
    for (    Pool pool : pools) {
      log.debug(""String_Node_Str"",pool);
      if (pool != null) {
        sink.emitPoolCreated(pool);
      }
    }
  }
  return pools;
}"
49288,"/** 
 * Some History, hopefully irrelavant henceforth: This transaction used to update consumer's status hash and got dead locked because: T1 and T2 are entitlement jobs 1. T1 grabs a shared lock on cp_consumer.id due to the FK in cp_entitlement when inserting into cp_entitlement 2. T2 grabs a shared lock on cp_consumer.id due to the FK in cp_entitlement when inserting into cp_entitlement 3. T1 attempts to grab an exclusive lock on cp_consumer.id for an update to cp_consumer's compliance hash.  T1 blocks waiting for the T2's shared lock to be released. 4. T2 attempts to grab an exclusive lock on cp_consumer.id for an update to cp_consumer's compliance hash. 5. Deadlock.  T2 is waiting for T1's shared lock to be released but T1 is waiting for T2's shared lock to be released. The solution was to create a longer transaction and grab an exclusive lock on the cp_consumer row (using a select for update) at the start of the transaction. The other thread will then wait for the exclusive lock to be released instead of deadlocking. Another effort on the solution removed compliance status evaluation from this thread and created a separate asynchronous job to accomplish that, thus removing the need to hold that exclusive lock on cp_consumer See BZ #1274074 and git history for details
 */
@Transactional protected List<Entitlement> addOrUpdateEntitlements(Consumer consumer,Map<String,Integer> poolQuantityMap,Map<String,Entitlement> entitlements,boolean generateUeberCert,CallerType caller) throws EntitlementRefusedException {
  log.debug(""String_Node_Str"",poolQuantityMap.keySet());
  List<Pool> pools=poolCurator.lockAndLoad(poolQuantityMap.keySet());
  for (  Pool pool : pools) {
    log.debug(""String_Node_Str"",pool,pool.getConsumed());
  }
  Map<String,PoolQuantity> poolQuantities=new HashMap<String,PoolQuantity>();
  boolean quantityFound=false;
  for (  Pool pool : pools) {
    Integer quantity=poolQuantityMap.get(pool.getId());
    if (quantity > 0) {
      quantityFound=true;
    }
    poolQuantities.put(pool.getId(),new PoolQuantity(pool,quantity));
    poolQuantityMap.remove(pool.getId());
  }
  if (!poolQuantityMap.isEmpty()) {
    throw new IllegalArgumentException(i18n.tr(""String_Node_Str"",poolQuantityMap.keySet()));
  }
  if (quantityFound) {
    log.info(""String_Node_Str"");
    Map<String,ValidationResult> results=enforcer.preEntitlement(consumer,poolQuantities.values(),caller);
    for (    Entry<String,ValidationResult> entry : results.entrySet()) {
      ValidationResult result=entry.getValue();
      if (!result.isSuccessful()) {
        log.warn(""String_Node_Str"",result.getErrors().toString(),entry.getKey());
        throw new EntitlementRefusedException(results);
      }
    }
  }
  EntitlementHandler handler=null;
  if (entitlements == null) {
    handler=new NewHandler();
  }
 else   if (entitlements.keySet().size() != poolQuantities.keySet().size() || !entitlements.keySet().containsAll(poolQuantities.keySet()) || !poolQuantities.keySet().containsAll(entitlements.keySet())) {
    throw new IllegalArgumentException(i18n.tr(""String_Node_Str"" + ""String_Node_Str"",entitlements.keySet().size(),poolQuantityMap.keySet().size()));
  }
 else {
    handler=new UpdateHandler();
  }
  log.info(""String_Node_Str"");
  entitlements=handler.handleEntitlement(consumer,poolQuantities,entitlements);
  log.info(""String_Node_Str"");
  handler.handleEntitlementPersist(entitlements);
  for (  Entry<String,PoolQuantity> entry : poolQuantities.entrySet()) {
    Pool pool=entry.getValue().getPool();
    Integer quantity=entry.getValue().getQuantity();
    pool.setConsumed(pool.getConsumed() + quantity);
    if (consumer.getType().isManifest()) {
      pool.setExported(pool.getExported() + quantity);
    }
  }
  handler.handlePostEntitlement(this,consumer,entitlements);
  handler.handleSelfCertificates(consumer,poolQuantities,entitlements,generateUeberCert);
  for (  Entitlement regenEnt : entitlementCurator.listModifying(entitlements.values())) {
    this.regenerateCertificatesOf(regenEnt,generateUeberCert,true);
  }
  handler.handleBonusPools(poolQuantities,entitlements);
  JobDetail detail=ConsumerComplianceJob.scheduleStatusCheck(consumer,null,false,false);
  log.info(""String_Node_Str"",detail.getKey(),consumer.getUuid());
  return new ArrayList<Entitlement>(entitlements.values());
}","/** 
 * Some History, hopefully irrelavant henceforth: This transaction used to update consumer's status hash and got dead locked because: T1 and T2 are entitlement jobs 1. T1 grabs a shared lock on cp_consumer.id due to the FK in cp_entitlement when inserting into cp_entitlement 2. T2 grabs a shared lock on cp_consumer.id due to the FK in cp_entitlement when inserting into cp_entitlement 3. T1 attempts to grab an exclusive lock on cp_consumer.id for an update to cp_consumer's compliance hash.  T1 blocks waiting for the T2's shared lock to be released. 4. T2 attempts to grab an exclusive lock on cp_consumer.id for an update to cp_consumer's compliance hash. 5. Deadlock.  T2 is waiting for T1's shared lock to be released but T1 is waiting for T2's shared lock to be released. The solution was to create a longer transaction and grab an exclusive lock on the cp_consumer row (using a select for update) at the start of the transaction. The other thread will then wait for the exclusive lock to be released instead of deadlocking. Another effort on the solution removed compliance status evaluation from this thread and created a separate asynchronous job to accomplish that, thus removing the need to hold that exclusive lock on cp_consumer See BZ #1274074 and git history for details
 */
@Transactional protected List<Entitlement> addOrUpdateEntitlements(Consumer consumer,Map<String,Integer> poolQuantityMap,Map<String,Entitlement> entitlements,boolean generateUeberCert,CallerType caller) throws EntitlementRefusedException {
  log.debug(""String_Node_Str"",poolQuantityMap.keySet());
  List<Pool> pools=poolCurator.lockAndLoad(poolQuantityMap.keySet());
  for (  Pool pool : pools) {
    log.debug(""String_Node_Str"",pool,pool.getConsumed());
  }
  Map<String,PoolQuantity> poolQuantities=new HashMap<String,PoolQuantity>();
  boolean quantityFound=false;
  for (  Pool pool : pools) {
    Integer quantity=poolQuantityMap.get(pool.getId());
    if (quantity > 0) {
      quantityFound=true;
    }
    poolQuantities.put(pool.getId(),new PoolQuantity(pool,quantity));
    poolQuantityMap.remove(pool.getId());
  }
  if (!poolQuantityMap.isEmpty()) {
    throw new IllegalArgumentException(i18n.tr(""String_Node_Str"",poolQuantityMap.keySet()));
  }
  if (quantityFound) {
    log.info(""String_Node_Str"");
    Map<String,ValidationResult> results=enforcer.preEntitlement(consumer,poolQuantities.values(),caller);
    for (    Entry<String,ValidationResult> entry : results.entrySet()) {
      ValidationResult result=entry.getValue();
      if (!result.isSuccessful()) {
        log.warn(""String_Node_Str"",result.getErrors().toString(),entry.getKey());
        throw new EntitlementRefusedException(results);
      }
    }
  }
  EntitlementHandler handler=null;
  if (entitlements == null) {
    handler=new NewHandler();
  }
 else   if (entitlements.keySet().size() != poolQuantities.keySet().size() || !entitlements.keySet().containsAll(poolQuantities.keySet()) || !poolQuantities.keySet().containsAll(entitlements.keySet())) {
    throw new IllegalArgumentException(i18n.tr(""String_Node_Str"" + ""String_Node_Str"",entitlements.keySet().size(),poolQuantityMap.keySet().size()));
  }
 else {
    handler=new UpdateHandler();
  }
  log.info(""String_Node_Str"");
  entitlements=handler.handleEntitlement(consumer,poolQuantities,entitlements);
  log.info(""String_Node_Str"");
  handler.handleEntitlementPersist(entitlements);
  for (  Entry<String,PoolQuantity> entry : poolQuantities.entrySet()) {
    Pool pool=entry.getValue().getPool();
    Integer quantity=entry.getValue().getQuantity();
    pool.setConsumed(pool.getConsumed() + quantity);
    if (consumer.getType().isManifest()) {
      pool.setExported(pool.getExported() + quantity);
    }
  }
  handler.handlePostEntitlement(this,consumer,entitlements);
  handler.handleSelfCertificates(consumer,poolQuantities,entitlements,generateUeberCert);
  for (  Entitlement regenEnt : entitlementCurator.listModifying(entitlements.values())) {
    this.regenerateCertificatesOf(regenEnt,generateUeberCert,true);
  }
  handler.handleBonusPools(poolQuantities,entitlements);
  JobDetail detail=ConsumerComplianceJob.scheduleStatusCheck(consumer,null,false,false);
  detail.getJobDataMap().put(PinsetterJobListener.PRINCIPAL_KEY,new SystemPrincipal());
  log.info(""String_Node_Str"",detail.getKey(),consumer.getUuid());
  try {
    pinsetterKernel.scheduleSingleJob(detail);
  }
 catch (  PinsetterException e) {
    log.error(""String_Node_Str"",e.getMessage());
  }
  poolCurator.flush();
  return new ArrayList<Entitlement>(entitlements.values());
}"
49289,"/** 
 * Request an entitlement by product for a host system in a host-guest relationship.  Allows getBestPoolsForHost to choose products to bind.
 * @param guest consumer requesting to have host entitled
 * @param host host consumer to entitle
 * @param entitleDate specific date to entitle by.
 * @return Entitlement
 * @throws EntitlementRefusedException if entitlement is refused
 */
@Override @Transactional public List<Entitlement> entitleByProductsForHost(Consumer guest,Consumer host,Date entitleDate,Collection<String> possiblePools) throws EntitlementRefusedException {
  List<Entitlement> entitlements=new LinkedList<Entitlement>();
  if (!host.getOwner().equals(guest.getOwner())) {
    log.debug(""String_Node_Str"",host.getUuid(),guest.getUuid());
    return entitlements;
  }
  Owner owner=host.getOwner();
  if (entitleDate == null) {
    entitleDate=new Date();
  }
  List<PoolQuantity> bestPools=getBestPoolsForHost(guest,host,entitleDate,owner,null,possiblePools);
  if (bestPools == null) {
    log.info(""String_Node_Str"",host.getUuid());
    return null;
  }
  return entitleByPools(guest,convertToMap(bestPools));
}","/** 
 * Request an entitlement by product for a host system in a host-guest relationship.  Allows getBestPoolsForHost to choose products to bind.
 * @param guest consumer requesting to have host entitled
 * @param host host consumer to entitle
 * @param entitleDate specific date to entitle by.
 * @return Entitlement
 * @throws EntitlementRefusedException if entitlement is refused
 */
@Override @Transactional public List<Entitlement> entitleByProductsForHost(Consumer guest,Consumer host,Date entitleDate,Collection<String> possiblePools) throws EntitlementRefusedException {
  List<Entitlement> entitlements=new LinkedList<Entitlement>();
  if (!host.getOwner().equals(guest.getOwner())) {
    log.debug(""String_Node_Str"",host.getUuid(),guest.getUuid());
    return entitlements;
  }
  Owner owner=host.getOwner();
  if (entitleDate == null) {
    entitleDate=new Date();
  }
  List<PoolQuantity> bestPools=getBestPoolsForHost(guest,host,entitleDate,owner,null,possiblePools);
  if (bestPools == null) {
    log.info(""String_Node_Str"",host.getUuid());
    return null;
  }
  return entitleByPools(host,convertToMap(bestPools));
}"
49290,"@Override public void handleEntitlementPersist(Map<String,Entitlement> entitlements){
  List<Entitlement> entitlementsList=new ArrayList<Entitlement>(entitlements.values());
  entitlementCurator.mergeAll(entitlementsList);
}","@Override public void handleEntitlementPersist(Map<String,Entitlement> entitlements){
  List<Entitlement> entitlementsList=new ArrayList<Entitlement>(entitlements.values());
  entitlementCurator.mergeAll(entitlementsList,false);
}"
49291,"public Collection<E> mergeAll(Collection<E> entries){
  if (entries != null && !entries.isEmpty()) {
    try {
      Session session=currentSession();
      int i=0;
      Iterator<E> iter=entries.iterator();
      while (iter.hasNext()) {
        session.merge(iter.next());
        if (i % batchSize == 0) {
          session.flush();
          session.clear();
        }
        i++;
      }
      session.flush();
      session.clear();
    }
 catch (    OptimisticLockException e) {
      throw new ConcurrentModificationException(getConcurrentModificationMessage(),e);
    }
  }
  return entries;
}","public Collection<E> mergeAll(Collection<E> entries,boolean flush){
  if (entries != null && !entries.isEmpty()) {
    try {
      Session session=currentSession();
      int i=0;
      Iterator<E> iter=entries.iterator();
      while (iter.hasNext()) {
        session.merge(iter.next());
        if (i % batchSize == 0 && flush) {
          session.flush();
          session.clear();
        }
        i++;
      }
      if (flush) {
        session.flush();
        session.clear();
      }
    }
 catch (    OptimisticLockException e) {
      throw new ConcurrentModificationException(getConcurrentModificationMessage(),e);
    }
  }
  return entries;
}"
49292,"public final void flush(){
  try {
    getEntityManager().flush();
  }
 catch (  OptimisticLockException e) {
    throw new ConcurrentModificationException(getConcurrentModificationMessage(),e);
  }
}","public void flush(){
  try {
    getEntityManager().flush();
  }
 catch (  OptimisticLockException e) {
    throw new ConcurrentModificationException(getConcurrentModificationMessage(),e);
  }
}"
49293,"public Collection<E> saveOrUpdateAll(Collection<E> entries){
  if (entries != null && !entries.isEmpty()) {
    try {
      Session session=currentSession();
      int i=0;
      Iterator<E> iter=entries.iterator();
      while (iter.hasNext()) {
        session.saveOrUpdate(iter.next());
        if (i % batchSize == 0) {
          session.flush();
          session.clear();
        }
        i++;
      }
      session.flush();
      session.clear();
    }
 catch (    OptimisticLockException e) {
      throw new ConcurrentModificationException(getConcurrentModificationMessage(),e);
    }
  }
  return entries;
}","public Collection<E> saveOrUpdateAll(Collection<E> entries,boolean flush){
  if (entries != null && !entries.isEmpty()) {
    try {
      Session session=currentSession();
      int i=0;
      Iterator<E> iter=entries.iterator();
      while (iter.hasNext()) {
        session.saveOrUpdate(iter.next());
        if (i % batchSize == 0 && flush) {
          session.flush();
          session.clear();
        }
        i++;
      }
      if (flush) {
        session.flush();
        session.clear();
      }
    }
 catch (    OptimisticLockException e) {
      throw new ConcurrentModificationException(getConcurrentModificationMessage(),e);
    }
  }
  return entries;
}"
49294,"public Collection<CertificateSerial> saveOrUpdateAll(Map<String,CertificateSerial> serialMap){
  return this.saveOrUpdateAll(serialMap.values());
}","public Collection<CertificateSerial> saveOrUpdateAll(Map<String,CertificateSerial> serialMap){
  return this.saveOrUpdateAll(serialMap.values(),false);
}"
49295,"private void postBindVirtLimit(PoolManager poolManager,Consumer c,Map<String,Entitlement> entitlementMap,Map<String,Map<String,String>> attributeMaps,List<Pool> subPoolsForStackIds){
  Set<String> stackIdsThathaveSubPools=new HashSet<String>();
  if (subPoolsForStackIds != null && !subPoolsForStackIds.isEmpty()) {
    for (    Pool pool : subPoolsForStackIds) {
      stackIdsThathaveSubPools.add(pool.getSourceStackId());
    }
  }
  log.debug(""String_Node_Str"");
  boolean consumerFactExpression=!c.getType().isManifest() && !""String_Node_Str"".equalsIgnoreCase(c.getFact(""String_Node_Str""));
  boolean isStandalone=config.getBoolean(ConfigProperties.STANDALONE);
  List<Pool> createHostRestrictedPoolFor=new ArrayList<Pool>();
  List<Entitlement> decrementHostedBonusPoolQuantityFor=new ArrayList<Entitlement>();
  for (  Entitlement entitlement : entitlementMap.values()) {
    Pool pool=entitlement.getPool();
    Map<String,String> attributes=attributeMaps.get(pool.getId());
    boolean hostLimited=attributes.containsKey(""String_Node_Str"") && attributes.get(""String_Node_Str"").equals(""String_Node_Str"");
    if (consumerFactExpression && (isStandalone || hostLimited)) {
      String virtLimit=attributes.get(""String_Node_Str"");
      String stackId=attributes.get(""String_Node_Str"");
      boolean createSubPool=stackId == null || stackIdsThathaveSubPools.contains(stackId);
      if (createSubPool) {
        log.debug(""String_Node_Str"",pool);
        try {
          int virtQuantity=Integer.parseInt(virtLimit);
          if (virtQuantity <= 0) {
            continue;
          }
        }
 catch (        NumberFormatException nfe) {
          if (!""String_Node_Str"".equals(virtLimit)) {
            continue;
          }
        }
        createHostRestrictedPoolFor.add(pool);
      }
 else {
        log.debug(""String_Node_Str"",pool);
      }
    }
 else {
      decrementHostedBonusPoolQuantityFor.add(entitlement);
    }
  }
  if (createHostRestrictedPoolFor != null && !createHostRestrictedPoolFor.isEmpty()) {
    log.debug(""String_Node_Str"",createHostRestrictedPoolFor);
    PoolHelper.createHostRestrictedPools(poolManager,c,createHostRestrictedPoolFor,entitlementMap,attributeMaps);
  }
  if (decrementHostedBonusPoolQuantityFor != null && !decrementHostedBonusPoolQuantityFor.isEmpty()) {
    log.debug(""String_Node_Str"",decrementHostedBonusPoolQuantityFor);
    decrementHostedBonusPoolQuantity(poolManager,c,decrementHostedBonusPoolQuantityFor,attributeMaps);
  }
}","private void postBindVirtLimit(PoolManager poolManager,Consumer c,Map<String,Entitlement> entitlementMap,Map<String,Map<String,String>> attributeMaps,List<Pool> subPoolsForStackIds){
  Set<String> stackIdsThathaveSubPools=new HashSet<String>();
  if (subPoolsForStackIds != null && !subPoolsForStackIds.isEmpty()) {
    for (    Pool pool : subPoolsForStackIds) {
      stackIdsThathaveSubPools.add(pool.getSourceStackId());
    }
  }
  log.debug(""String_Node_Str"");
  boolean consumerFactExpression=!c.getType().isManifest() && !""String_Node_Str"".equalsIgnoreCase(c.getFact(""String_Node_Str""));
  boolean isStandalone=config.getBoolean(ConfigProperties.STANDALONE);
  List<Pool> createHostRestrictedPoolFor=new ArrayList<Pool>();
  List<Entitlement> decrementHostedBonusPoolQuantityFor=new ArrayList<Entitlement>();
  for (  Entitlement entitlement : entitlementMap.values()) {
    Pool pool=entitlement.getPool();
    Map<String,String> attributes=attributeMaps.get(pool.getId());
    boolean hostLimited=attributes.containsKey(""String_Node_Str"") && attributes.get(""String_Node_Str"").equals(""String_Node_Str"");
    if (consumerFactExpression && (isStandalone || hostLimited)) {
      String virtLimit=attributes.get(""String_Node_Str"");
      String stackId=attributes.get(""String_Node_Str"");
      boolean createSubPool=stackId == null || !stackIdsThathaveSubPools.contains(stackId);
      if (createSubPool) {
        log.debug(""String_Node_Str"",pool);
        try {
          int virtQuantity=Integer.parseInt(virtLimit);
          if (virtQuantity <= 0) {
            continue;
          }
        }
 catch (        NumberFormatException nfe) {
          if (!""String_Node_Str"".equals(virtLimit)) {
            continue;
          }
        }
        createHostRestrictedPoolFor.add(pool);
      }
 else {
        log.debug(""String_Node_Str"",pool);
      }
    }
 else {
      decrementHostedBonusPoolQuantityFor.add(entitlement);
    }
  }
  if (createHostRestrictedPoolFor != null && !createHostRestrictedPoolFor.isEmpty()) {
    log.debug(""String_Node_Str"",createHostRestrictedPoolFor);
    PoolHelper.createHostRestrictedPools(poolManager,c,createHostRestrictedPoolFor,entitlementMap,attributeMaps);
  }
  if (decrementHostedBonusPoolQuantityFor != null && !decrementHostedBonusPoolQuantityFor.isEmpty()) {
    log.debug(""String_Node_Str"",decrementHostedBonusPoolQuantityFor);
    decrementHostedBonusPoolQuantity(poolManager,c,decrementHostedBonusPoolQuantityFor,attributeMaps);
  }
}"
49296,"/** 
 * Updates the pool based on the entitlements in the specified stack.
 * @param pools
 * @param consumer
 */
public void updatePoolsFromStack(Consumer consumer,List<Pool> pools){
  Map<String,List<Entitlement>> entitlementMap=new HashMap<String,List<Entitlement>>();
  Map<String,Pool> poolMap=new HashMap<String,Pool>();
  Set<String> sourceStackIds=new HashSet<String>();
  for (  Pool pool : pools) {
    sourceStackIds.add(pool.getSourceStackId());
    poolMap.put(pool.getId(),pool);
  }
  List<Entitlement> stackedEnts=this.entCurator.findByStackIds(consumer,sourceStackIds);
  for (  Entitlement entitlement : stackedEnts) {
    if (!entitlementMap.containsKey(entitlement.getPool().getId())) {
      entitlementMap.put(entitlement.getPool().getId(),new ArrayList<Entitlement>());
    }
    entitlementMap.get(entitlement.getPool().getId()).add(entitlement);
  }
  for (  Entry<String,Pool> entry : poolMap.entrySet()) {
    this.updatePoolFromStackedEntitlements(entry.getValue(),entitlementMap.get(entry.getKey()),new HashSet<Product>());
  }
}","/** 
 * Updates the pool based on the entitlements in the specified stack.
 * @param pools
 * @param consumer
 */
public void updatePoolsFromStack(Consumer consumer,List<Pool> pools){
  Map<String,List<Entitlement>> entitlementMap=new HashMap<String,List<Entitlement>>();
  Map<String,Pool> poolMap=new HashMap<String,Pool>();
  Set<String> sourceStackIds=new HashSet<String>();
  for (  Pool pool : pools) {
    sourceStackIds.add(pool.getSourceStackId());
    poolMap.put(pool.getId(),pool);
  }
  List<Entitlement> stackedEnts=this.entCurator.findByStackIds(consumer,sourceStackIds);
  for (  Entitlement entitlement : stackedEnts) {
    if (!entitlementMap.containsKey(entitlement.getPool().getStackId())) {
      entitlementMap.put(entitlement.getPool().getStackId(),new ArrayList<Entitlement>());
    }
    entitlementMap.get(entitlement.getPool().getStackId()).add(entitlement);
  }
  for (  Pool pool : poolMap.values()) {
    List<Entitlement> entitlements=entitlementMap.get(pool.getSourceStackId());
    if (entitlements != null && !entitlements.isEmpty()) {
      this.updatePoolFromStackedEntitlements(pool,entitlements,new HashSet<Product>());
    }
  }
}"
49297,"public PoolUpdate updatePoolFromStackedEntitlements(Pool pool,List<Entitlement> stackedEnts,Set<Product> changedProducts){
  PoolUpdate update=new PoolUpdate(pool);
  if (stackedEnts.isEmpty()) {
    return update;
  }
  pool.setSourceEntitlement(null);
  pool.setSourceSubscription(null);
  StackedSubPoolValueAccumulator acc=new StackedSubPoolValueAccumulator(pool,stackedEnts);
  Entitlement eldestWithVirtLimit=acc.getEldestWithVirtLimit();
  if (eldestWithVirtLimit != null) {
    String virtLimit=eldestWithVirtLimit.getPool().getProductAttributeValue(""String_Node_Str"");
    Long quantity=virtLimit.equalsIgnoreCase(""String_Node_Str"") ? -1L : Long.parseLong(virtLimit);
    if (!quantity.equals(pool.getQuantity())) {
      pool.setQuantity(quantity);
      update.setQuantityChanged(true);
    }
  }
  update.setDatesChanged(checkForDateChange(acc.getStartDate(),acc.getEndDate(),pool));
  Entitlement eldest=acc.getEldest();
  Pool eldestEntPool=eldest.getPool();
  boolean useDerived=eldestEntPool.getDerivedProduct() != null;
  Product product=useDerived ? eldestEntPool.getDerivedProduct() : eldestEntPool.getProduct();
  update.setProductAttributesChanged(!pool.getProductAttributes().equals(product.getAttributes()));
  update.setProductsChanged(checkForChangedProducts(product,acc.getExpectedProvidedProds(),pool,changedProducts));
  if (!StringUtils.equals(eldestEntPool.getContractNumber(),pool.getContractNumber()) || !StringUtils.equals(eldestEntPool.getOrderNumber(),pool.getOrderNumber()) || !StringUtils.equals(eldestEntPool.getAccountNumber(),pool.getAccountNumber())) {
    pool.setContractNumber(eldestEntPool.getContractNumber());
    pool.setAccountNumber(eldestEntPool.getAccountNumber());
    pool.setOrderNumber(eldestEntPool.getOrderNumber());
    update.setOrderChanged(true);
  }
  if (update.changed()) {
    for (    Entitlement ent : pool.getEntitlements()) {
      ent.setDirty(true);
    }
  }
  return update;
}","public PoolUpdate updatePoolFromStackedEntitlements(Pool pool,List<Entitlement> stackedEnts,Set<Product> changedProducts){
  PoolUpdate update=new PoolUpdate(pool);
  if (stackedEnts == null || stackedEnts.isEmpty()) {
    return update;
  }
  pool.setSourceEntitlement(null);
  pool.setSourceSubscription(null);
  StackedSubPoolValueAccumulator acc=new StackedSubPoolValueAccumulator(pool,stackedEnts);
  Entitlement eldestWithVirtLimit=acc.getEldestWithVirtLimit();
  if (eldestWithVirtLimit != null) {
    String virtLimit=eldestWithVirtLimit.getPool().getProductAttributeValue(""String_Node_Str"");
    Long quantity=virtLimit.equalsIgnoreCase(""String_Node_Str"") ? -1L : Long.parseLong(virtLimit);
    if (!quantity.equals(pool.getQuantity())) {
      pool.setQuantity(quantity);
      update.setQuantityChanged(true);
    }
  }
  update.setDatesChanged(checkForDateChange(acc.getStartDate(),acc.getEndDate(),pool));
  Entitlement eldest=acc.getEldest();
  Pool eldestEntPool=eldest.getPool();
  boolean useDerived=eldestEntPool.getDerivedProduct() != null;
  Product product=useDerived ? eldestEntPool.getDerivedProduct() : eldestEntPool.getProduct();
  update.setProductAttributesChanged(!pool.getProductAttributes().equals(product.getAttributes()));
  update.setProductsChanged(checkForChangedProducts(product,acc.getExpectedProvidedProds(),pool,changedProducts));
  if (!StringUtils.equals(eldestEntPool.getContractNumber(),pool.getContractNumber()) || !StringUtils.equals(eldestEntPool.getOrderNumber(),pool.getOrderNumber()) || !StringUtils.equals(eldestEntPool.getAccountNumber(),pool.getAccountNumber())) {
    pool.setContractNumber(eldestEntPool.getContractNumber());
    pool.setAccountNumber(eldestEntPool.getAccountNumber());
    pool.setOrderNumber(eldestEntPool.getOrderNumber());
    update.setOrderChanged(true);
  }
  if (update.changed()) {
    for (    Entitlement ent : pool.getEntitlements()) {
      ent.setDirty(true);
    }
  }
  return update;
}"
49298,"/** 
 * @param entitlements a map of entitlements indexed by pool ids to generatethe certs of
 * @param productMap a map of respective products indexed by pool id
 * @throws IOException
 * @throws GeneralSecurityException
 * @return entitlementCerts the respective entitlement certs indexed by poolid
 */
private Map<String,EntitlementCertificate> generateEntitlementCerts(Consumer consumer,Map<String,Entitlement> entitlements,Map<String,Product> productMap,boolean thisIsUeberCert) throws GeneralSecurityException, IOException {
  log.info(""String_Node_Str"");
  KeyPair keyPair=keyPairCurator.getConsumerKeyPair(consumer);
  byte[] pemEncodedKeyPair=pki.getPemEncoded(keyPair.getPrivate());
  Map<String,CertificateSerial> serialMap=new HashMap<String,CertificateSerial>();
  for (  Entry<String,Entitlement> entry : entitlements.entrySet()) {
    serialMap.put(entry.getKey(),new CertificateSerial(entry.getValue().getEndDate()));
  }
  serialCurator.saveOrUpdateAll(serialMap);
  Map<String,EntitlementCertificate> entitlementCerts=new HashMap<String,EntitlementCertificate>();
  for (  Entry<String,Entitlement> entry : entitlements.entrySet()) {
    Entitlement entitlement=entry.getValue();
    CertificateSerial serial=serialMap.get(entry.getKey());
    Product product=productMap.get(entry.getKey());
    log.info(""String_Node_Str"",entitlement);
    Set<Product> products=new HashSet<Product>(entitlement.getPool().getProvidedProducts());
    products.addAll(getDerivedProductsForDistributor(entitlement));
    products.add(product);
    Map<String,EnvironmentContent> promotedContent=getPromotedContent(entitlement);
    String contentPrefix=getContentPrefix(entitlement,!thisIsUeberCert);
    log.info(""String_Node_Str"",product);
    log.debug(""String_Node_Str"",products);
    List<org.candlepin.model.dto.Product> productModels=v3extensionUtil.createProducts(product,products,contentPrefix,promotedContent,entitlement.getConsumer(),entitlement);
    X509Certificate x509Cert=createX509Certificate(entitlement,product,products,productModels,BigInteger.valueOf(serial.getId()),keyPair,!thisIsUeberCert);
    EntitlementCertificate cert=new EntitlementCertificate();
    cert.setSerial(serial);
    cert.setKeyAsBytes(pemEncodedKeyPair);
    log.info(""String_Node_Str"");
    String pem=new String(this.pki.getPemEncoded(x509Cert));
    if (shouldGenerateV3(entitlement)) {
      log.debug(""String_Node_Str"");
      byte[] payloadBytes=v3extensionUtil.createEntitlementDataPayload(product,productModels,entitlement,contentPrefix,promotedContent);
      String payload=""String_Node_Str"";
      payload+=Util.toBase64(payloadBytes);
      payload+=""String_Node_Str"";
      byte[] bytes=pki.getSHA256WithRSAHash(new ByteArrayInputStream(payloadBytes));
      String signature=""String_Node_Str"";
      signature+=Util.toBase64(bytes);
      signature+=""String_Node_Str"";
      pem+=payload + signature;
    }
    cert.setCert(pem);
    cert.setEntitlement(entitlement);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + serial.getId());
      log.debug(""String_Node_Str"" + cert.getKey());
      log.debug(""String_Node_Str"" + cert.getCert());
    }
    entitlement.getCertificates().add(cert);
    entitlementCerts.put(entry.getKey(),cert);
  }
  log.info(""String_Node_Str"");
  entCertCurator.saveOrUpdateAll(entitlementCerts.values());
  return entitlementCerts;
}","/** 
 * @param entitlements a map of entitlements indexed by pool ids to generatethe certs of
 * @param productMap a map of respective products indexed by pool id
 * @throws IOException
 * @throws GeneralSecurityException
 * @return entitlementCerts the respective entitlement certs indexed by poolid
 */
private Map<String,EntitlementCertificate> generateEntitlementCerts(Consumer consumer,Map<String,Entitlement> entitlements,Map<String,Product> productMap,boolean thisIsUeberCert) throws GeneralSecurityException, IOException {
  log.info(""String_Node_Str"");
  KeyPair keyPair=keyPairCurator.getConsumerKeyPair(consumer);
  byte[] pemEncodedKeyPair=pki.getPemEncoded(keyPair.getPrivate());
  Map<String,CertificateSerial> serialMap=new HashMap<String,CertificateSerial>();
  for (  Entry<String,Entitlement> entry : entitlements.entrySet()) {
    serialMap.put(entry.getKey(),new CertificateSerial(entry.getValue().getEndDate()));
  }
  serialCurator.saveOrUpdateAll(serialMap);
  Map<String,EntitlementCertificate> entitlementCerts=new HashMap<String,EntitlementCertificate>();
  for (  Entry<String,Entitlement> entry : entitlements.entrySet()) {
    Entitlement entitlement=entry.getValue();
    CertificateSerial serial=serialMap.get(entry.getKey());
    Product product=productMap.get(entry.getKey());
    log.info(""String_Node_Str"",entitlement);
    Set<Product> products=new HashSet<Product>(entitlement.getPool().getProvidedProducts());
    products.addAll(getDerivedProductsForDistributor(entitlement));
    products.add(product);
    Map<String,EnvironmentContent> promotedContent=getPromotedContent(entitlement);
    String contentPrefix=getContentPrefix(entitlement,!thisIsUeberCert);
    log.info(""String_Node_Str"",product);
    log.debug(""String_Node_Str"",products);
    List<org.candlepin.model.dto.Product> productModels=v3extensionUtil.createProducts(product,products,contentPrefix,promotedContent,entitlement.getConsumer(),entitlement);
    X509Certificate x509Cert=createX509Certificate(entitlement,product,products,productModels,BigInteger.valueOf(serial.getId()),keyPair,!thisIsUeberCert);
    EntitlementCertificate cert=new EntitlementCertificate();
    cert.setSerial(serial);
    cert.setKeyAsBytes(pemEncodedKeyPair);
    log.info(""String_Node_Str"");
    String pem=new String(this.pki.getPemEncoded(x509Cert));
    if (shouldGenerateV3(entitlement)) {
      log.debug(""String_Node_Str"");
      byte[] payloadBytes=v3extensionUtil.createEntitlementDataPayload(product,productModels,entitlement,contentPrefix,promotedContent);
      String payload=""String_Node_Str"";
      payload+=Util.toBase64(payloadBytes);
      payload+=""String_Node_Str"";
      byte[] bytes=pki.getSHA256WithRSAHash(new ByteArrayInputStream(payloadBytes));
      String signature=""String_Node_Str"";
      signature+=Util.toBase64(bytes);
      signature+=""String_Node_Str"";
      pem+=payload + signature;
    }
    cert.setCert(pem);
    cert.setEntitlement(entitlement);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + serial.getId());
      log.debug(""String_Node_Str"" + cert.getKey());
      log.debug(""String_Node_Str"" + cert.getCert());
    }
    entitlement.getCertificates().add(cert);
    entitlementCerts.put(entry.getKey(),cert);
  }
  log.info(""String_Node_Str"");
  entCertCurator.saveOrUpdateAll(entitlementCerts.values(),false);
  return entitlementCerts;
}"
49299,"public boolean syncCRLWithDB(File file) throws IOException {
  List<BigInteger> revoke=new LinkedList<BigInteger>();
  List<CertificateSerial> serials=this.certificateSerialCurator.retrieveTobeCollectedSerials();
  for (  CertificateSerial serial : serials) {
    revoke.add(serial.getSerial());
    serial.setCollected(true);
  }
  List<BigInteger> unrevoke=new LinkedList<BigInteger>();
  for (  CertificateSerial serial : this.certificateSerialCurator.getExpiredSerials()) {
    unrevoke.add(serial.getSerial());
  }
  if (revoke.size() > 0 || unrevoke.size() > 0) {
    this.updateCRLFile(file,revoke,unrevoke);
    this.certificateSerialCurator.saveOrUpdateAll(serials);
  }
  return true;
}","public boolean syncCRLWithDB(File file) throws IOException {
  List<BigInteger> revoke=new LinkedList<BigInteger>();
  List<CertificateSerial> serials=this.certificateSerialCurator.retrieveTobeCollectedSerials();
  for (  CertificateSerial serial : serials) {
    revoke.add(serial.getSerial());
    serial.setCollected(true);
  }
  List<BigInteger> unrevoke=new LinkedList<BigInteger>();
  for (  CertificateSerial serial : this.certificateSerialCurator.getExpiredSerials()) {
    unrevoke.add(serial.getSerial());
  }
  if (revoke.size() > 0 || unrevoke.size() > 0) {
    this.updateCRLFile(file,revoke,unrevoke);
    this.certificateSerialCurator.saveOrUpdateAll(serials,true);
  }
  return true;
}"
49300,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testEntitleWithADate() throws Exception {
  Product product=TestUtil.createProduct(o);
  List<Pool> pools=Util.newList();
  Pool pool1=TestUtil.createPool(product);
  pools.add(pool1);
  Pool pool2=TestUtil.createPool(product);
  pools.add(pool2);
  Date now=new Date();
  ValidationResult result=mock(ValidationResult.class);
  Page page=mock(Page.class);
  when(page.getPageData()).thenReturn(pools);
  when(mockPoolCurator.listAvailableEntitlementPools(any(Consumer.class),any(Owner.class),any(String.class),any(String.class),eq(now),anyBoolean(),any(PoolFilterBuilder.class),any(PageRequest.class),anyBoolean())).thenReturn(page);
  when(mockPoolCurator.lockAndLoad(any(List.class))).thenReturn(Arrays.asList(pool1));
  when(enforcerMock.preEntitlement(any(Consumer.class),any(Pool.class),anyInt(),any(CallerType.class))).thenReturn(result);
  when(result.isSuccessful()).thenReturn(true);
  List<PoolQuantity> bestPools=new ArrayList<PoolQuantity>();
  bestPools.add(new PoolQuantity(pool1,1));
  when(autobindRules.selectBestPools(any(Consumer.class),any(String[].class),any(List.class),any(ComplianceStatus.class),any(String.class),any(Set.class),eq(false))).thenReturn(bestPools);
  AutobindData data=AutobindData.create(TestUtil.createConsumer(o)).forProducts(new String[]{product.getUuid()}).on(now);
  List<Entitlement> e=manager.entitleByProducts(data);
  assertNotNull(e);
  assertEquals(e.size(),1);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testEntitleWithADate() throws Exception {
  Product product=TestUtil.createProduct(o);
  List<Pool> pools=Util.newList();
  Pool pool1=TestUtil.createPool(product);
  pools.add(pool1);
  Pool pool2=TestUtil.createPool(product);
  pools.add(pool2);
  Date now=new Date();
  ValidationResult result=mock(ValidationResult.class);
  Page page=mock(Page.class);
  when(page.getPageData()).thenReturn(pools);
  when(mockPoolCurator.listAvailableEntitlementPools(any(Consumer.class),any(Owner.class),any(String.class),any(String.class),eq(now),anyBoolean(),any(PoolFilterBuilder.class),any(PageRequest.class),anyBoolean())).thenReturn(page);
  when(mockPoolCurator.lockAndLoad(any(List.class))).thenReturn(Arrays.asList(pool1));
  when(enforcerMock.preEntitlement(any(Consumer.class),any(Pool.class),anyInt(),any(CallerType.class))).thenReturn(result);
  when(result.isSuccessful()).thenReturn(true);
  List<PoolQuantity> bestPools=new ArrayList<PoolQuantity>();
  bestPools.add(new PoolQuantity(pool1,1));
  when(autobindRules.selectBestPools(any(Consumer.class),any(String[].class),any(List.class),any(ComplianceStatus.class),any(String.class),any(Set.class),eq(false))).thenReturn(bestPools);
  AutobindData data=AutobindData.create(TestUtil.createConsumer(o)).forProducts(new String[]{product.getUuid()}).on(now);
  doNothing().when(mockPoolCurator).flush();
  doNothing().when(mockPoolCurator).clear();
  List<Entitlement> e=manager.entitleByProducts(data);
  assertNotNull(e);
  assertEquals(e.size(),1);
}"
49301,"/** 
 * Update pool for master pool.
 * @param existingPools the existing pools
 * @param pool the master pool
 * @param originalQuantity the pool's original quantity before multiplier was applied
 * @param updateStackDerived whether or not to attempt to update stackderived pools
 */
Set<String> updatePoolsForMasterPool(List<Pool> existingPools,Pool pool,Long originalQuantity,boolean updateStackDerived,Set<Product> changedProducts){
  if (existingPools == null || existingPools.isEmpty()) {
    return new HashSet<String>(0);
  }
  log.debug(""String_Node_Str"",existingPools.size(),pool);
  Map<String,EventBuilder> poolEvents=new HashMap<String,EventBuilder>();
  for (  Pool existing : existingPools) {
    EventBuilder eventBuilder=eventFactory.getEventBuilder(Target.POOL,Type.MODIFIED).setOldEntity(existing);
    poolEvents.put(existing.getId(),eventBuilder);
  }
  List<PoolUpdate> updatedPools=poolRules.updatePools(pool,existingPools,originalQuantity,changedProducts);
  String virtLimit=pool.getProduct().getAttributeValue(""String_Node_Str"");
  boolean createsSubPools=!StringUtils.isBlank(virtLimit) && !""String_Node_Str"".equals(virtLimit);
  if (updateStackDerived && !updatedPools.isEmpty() && createsSubPools&& pool.isStacked()) {
    List<Pool> subPools=getOwnerSubPoolsForStackId(pool.getOwner(),pool.getStackId());
    for (    Pool subPool : subPools) {
      PoolUpdate update=updatePoolFromStack(subPool,changedProducts);
      if (update.changed()) {
        updatedPools.add(update);
      }
    }
  }
  Set<String> entsToRegen=processPoolUpdates(poolEvents,updatedPools);
  return entsToRegen;
}","/** 
 * Update pool for master pool.
 * @param existingPools the existing pools
 * @param pool the master pool
 * @param originalQuantity the pool's original quantity before multiplier was applied
 * @param updateStackDerived whether or not to attempt to update stackderived pools
 */
Set<String> updatePoolsForMasterPool(List<Pool> existingPools,Pool pool,Long originalQuantity,boolean updateStackDerived,Set<Product> changedProducts){
  if (existingPools == null || existingPools.isEmpty()) {
    return new HashSet<String>(0);
  }
  log.debug(""String_Node_Str"",existingPools.size(),pool);
  Map<String,EventBuilder> poolEvents=new HashMap<String,EventBuilder>();
  for (  Pool existing : existingPools) {
    EventBuilder eventBuilder=eventFactory.getEventBuilder(Target.POOL,Type.MODIFIED).setOldEntity(existing);
    poolEvents.put(existing.getId(),eventBuilder);
  }
  List<PoolUpdate> updatedPools=poolRules.updatePools(pool,existingPools,originalQuantity,changedProducts);
  String virtLimit=pool.getProduct().getAttributeValue(""String_Node_Str"");
  boolean createsSubPools=!StringUtils.isBlank(virtLimit) && !""String_Node_Str"".equals(virtLimit);
  if (updateStackDerived && !updatedPools.isEmpty() && createsSubPools&& pool.isStacked()) {
    List<Pool> subPools=getOwnerSubPoolsForStackId(pool.getOwner(),pool.getStackId());
    for (    Pool subPool : subPools) {
      PoolUpdate update=updatePoolFromStack(subPool,changedProducts);
      if (update.changed()) {
        updatedPools.add(update);
        EventBuilder eventBuilder=eventFactory.getEventBuilder(Target.POOL,Type.MODIFIED).setOldEntity(subPool);
        poolEvents.put(subPool.getId(),eventBuilder);
      }
    }
  }
  Set<String> entsToRegen=processPoolUpdates(poolEvents,updatedPools);
  return entsToRegen;
}"
49302,"private Set<String> processPoolUpdates(Map<String,EventBuilder> poolEvents,List<PoolUpdate> updatedPools){
  Set<String> entitlementsToRegen=Util.newSet();
  for (  PoolUpdate updatedPool : updatedPools) {
    Pool existingPool=updatedPool.getPool();
    log.info(""String_Node_Str"",updatedPool.toString());
    if (existingPool.isMarkedForDelete()) {
      log.warn(""String_Node_Str"",existingPool.getId());
      deletePool(existingPool);
      continue;
    }
    this.poolCurator.merge(existingPool);
    this.poolCurator.flush();
    if (updatedPool.getQuantityChanged()) {
      this.deleteExcessEntitlements(existingPool);
    }
    if (updatedPool.getDatesChanged() || updatedPool.getProductsChanged() || updatedPool.getBrandingChanged()) {
      List<String> entitlements=poolCurator.retrieveFreeEntitlementIdsOfPool(existingPool,true);
      entitlementsToRegen.addAll(entitlements);
    }
    Event event=poolEvents.get(existingPool.getId()).setNewEntity(existingPool).buildEvent();
    sink.queueEvent(event);
  }
  return entitlementsToRegen;
}","private Set<String> processPoolUpdates(Map<String,EventBuilder> poolEvents,List<PoolUpdate> updatedPools){
  Set<String> entitlementsToRegen=Util.newSet();
  for (  PoolUpdate updatedPool : updatedPools) {
    Pool existingPool=updatedPool.getPool();
    log.info(""String_Node_Str"",updatedPool.toString());
    if (existingPool.isMarkedForDelete()) {
      log.warn(""String_Node_Str"",existingPool.getId());
      deletePool(existingPool);
      continue;
    }
    this.poolCurator.merge(existingPool);
    this.poolCurator.flush();
    if (updatedPool.getQuantityChanged()) {
      this.deleteExcessEntitlements(existingPool);
    }
    if (updatedPool.getDatesChanged() || updatedPool.getProductsChanged() || updatedPool.getBrandingChanged()) {
      List<String> entitlements=poolCurator.retrieveFreeEntitlementIdsOfPool(existingPool,true);
      entitlementsToRegen.addAll(entitlements);
    }
    EventBuilder builder=poolEvents.get(existingPool.getId());
    if (builder != null) {
      Event event=builder.setNewEntity(existingPool).buildEvent();
      sink.queueEvent(event);
    }
 else {
      log.warn(""String_Node_Str"",existingPool);
    }
  }
  return entitlementsToRegen;
}"
49303,"public Pool findDevPool(Consumer consumer){
  PoolFilterBuilder filters=new PoolFilterBuilder();
  filters.addAttributeFilter(Pool.DEVELOPMENT_POOL_ATTRIBUTE,""String_Node_Str"");
  filters.addAttributeFilter(Pool.REQUIRES_CONSUMER_ATTRIBUTE,consumer.getUuid());
  Criteria criteria=currentSession().createCriteria(Pool.class);
  filters.applyTo(criteria);
  criteria.setMaxResults(1).uniqueResult();
  return (Pool)criteria.uniqueResult();
}","public Pool findDevPool(Consumer consumer){
  PoolFilterBuilder filters=new PoolFilterBuilder();
  filters.addAttributeFilter(Pool.DEVELOPMENT_POOL_ATTRIBUTE,""String_Node_Str"");
  filters.addAttributeFilter(Pool.REQUIRES_CONSUMER_ATTRIBUTE,consumer.getUuid());
  Criteria criteria=currentSession().createCriteria(Pool.class);
  criteria.add(Restrictions.eq(""String_Node_Str"",consumer.getOwner()));
  filters.applyTo(criteria);
  criteria.setMaxResults(1).uniqueResult();
  return (Pool)criteria.uniqueResult();
}"
49304,"@Test public void testDevPoolForConsumerNotFoundReturnsNullWhenNoMatchOnConsumer() throws Exception {
  Pool pool=createPool(owner,product,-1L,TestUtil.createDate(2010,3,2),TestUtil.createDate(Calendar.getInstance().get(Calendar.YEAR) + 1,3,2));
  pool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  poolCurator.create(pool);
  Pool found=poolCurator.findDevPool(consumer);
  assertNull(found);
}","@Test public void testDevPoolForConsumerNotFoundReturnsNullWhenNoMatchOnConsumer() throws Exception {
  createPool(owner,product,-1L,TestUtil.createDate(2010,3,2),TestUtil.createDate(Calendar.getInstance().get(Calendar.YEAR) + 1,3,2));
  Pool pool=createPool(owner,product,-1L,TestUtil.createDate(2010,3,2),TestUtil.createDate(Calendar.getInstance().get(Calendar.YEAR) + 1,3,2));
  pool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  poolCurator.create(pool);
  Pool found=poolCurator.findDevPool(consumer);
  assertNull(found);
}"
49305,"@Test public void testLookupDevPoolForConsumer() throws Exception {
  Pool pool=createPool(owner,product,-1L,TestUtil.createDate(2010,3,2),TestUtil.createDate(Calendar.getInstance().get(Calendar.YEAR) + 1,3,2));
  pool.setAttribute(""String_Node_Str"",consumer.getUuid());
  pool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  poolCurator.create(pool);
  Pool found=poolCurator.findDevPool(consumer);
  assertNotNull(found);
  assertEquals(pool.getId(),found.getId());
}","@Test public void testLookupDevPoolForConsumer() throws Exception {
  createPool(owner,product,-1L,TestUtil.createDate(2010,3,2),TestUtil.createDate(Calendar.getInstance().get(Calendar.YEAR) + 1,3,2));
  Pool pool=createPool(owner,product,-1L,TestUtil.createDate(2010,3,2),TestUtil.createDate(Calendar.getInstance().get(Calendar.YEAR) + 1,3,2));
  pool.setAttribute(""String_Node_Str"",consumer.getUuid());
  pool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  poolCurator.create(pool);
  Pool found=poolCurator.findDevPool(consumer);
  assertNotNull(found);
  assertEquals(pool.getId(),found.getId());
}"
49306,"/** 
 * Update pool for master pool.
 * @param existingPools the existing pools
 * @param pool the master pool
 * @param updateStackDerived whether or not to attempt to update stackderived pools
 */
Set<String> updatePoolsForMasterPool(List<Pool> existingPools,Pool pool,boolean updateStackDerived,Set<Product> changedProducts){
  if (existingPools == null || existingPools.isEmpty()) {
    return new HashSet<String>(0);
  }
  log.debug(""String_Node_Str"",existingPools.size(),pool);
  Map<String,EventBuilder> poolEvents=new HashMap<String,EventBuilder>();
  for (  Pool existing : existingPools) {
    EventBuilder eventBuilder=eventFactory.getEventBuilder(Target.POOL,Type.MODIFIED).setOldEntity(existing);
    poolEvents.put(existing.getId(),eventBuilder);
  }
  List<PoolUpdate> updatedPools=poolRules.updatePools(pool,existingPools,changedProducts);
  String virtLimit=pool.getProduct().getAttributeValue(""String_Node_Str"");
  boolean createsSubPools=!StringUtils.isBlank(virtLimit) && !""String_Node_Str"".equals(virtLimit);
  if (updateStackDerived && !updatedPools.isEmpty() && createsSubPools&& pool.isStacked()) {
    List<Pool> subPools=getOwnerSubPoolsForStackId(pool.getOwner(),pool.getStackId());
    for (    Pool subPool : subPools) {
      PoolUpdate update=updatePoolFromStack(subPool,changedProducts);
      if (update.changed()) {
        updatedPools.add(update);
      }
    }
  }
  Set<String> entsToRegen=processPoolUpdates(poolEvents,updatedPools);
  return entsToRegen;
}","/** 
 * Update pool for master pool.
 * @param existingPools the existing pools
 * @param pool the master pool
 * @param originalQuantity the pool's original quantity before multiplier was applied
 * @param updateStackDerived whether or not to attempt to update stackderived pools
 */
Set<String> updatePoolsForMasterPool(List<Pool> existingPools,Pool pool,Long originalQuantity,boolean updateStackDerived,Set<Product> changedProducts){
  if (existingPools == null || existingPools.isEmpty()) {
    return new HashSet<String>(0);
  }
  log.debug(""String_Node_Str"",existingPools.size(),pool);
  Map<String,EventBuilder> poolEvents=new HashMap<String,EventBuilder>();
  for (  Pool existing : existingPools) {
    EventBuilder eventBuilder=eventFactory.getEventBuilder(Target.POOL,Type.MODIFIED).setOldEntity(existing);
    poolEvents.put(existing.getId(),eventBuilder);
  }
  List<PoolUpdate> updatedPools=poolRules.updatePools(pool,existingPools,originalQuantity,changedProducts);
  String virtLimit=pool.getProduct().getAttributeValue(""String_Node_Str"");
  boolean createsSubPools=!StringUtils.isBlank(virtLimit) && !""String_Node_Str"".equals(virtLimit);
  if (updateStackDerived && !updatedPools.isEmpty() && createsSubPools&& pool.isStacked()) {
    List<Pool> subPools=getOwnerSubPoolsForStackId(pool.getOwner(),pool.getStackId());
    for (    Pool subPool : subPools) {
      PoolUpdate update=updatePoolFromStack(subPool,changedProducts);
      if (update.changed()) {
        updatedPools.add(update);
      }
    }
  }
  Set<String> entsToRegen=processPoolUpdates(poolEvents,updatedPools);
  return entsToRegen;
}"
49307,"@Transactional void refreshPoolsForMasterPool(Pool pool,boolean updateStackDerived,boolean lazy,Set<Product> changedProducts){
  List<Pool> subscriptionPools=poolCurator.getPoolsBySubscriptionId(pool.getSubscriptionId());
  log.debug(""String_Node_Str"",subscriptionPools.size(),pool.getSubscriptionId());
  if (log.isDebugEnabled()) {
    for (    Pool p : subscriptionPools) {
      log.debug(""String_Node_Str"",p.getOwner().getKey(),p);
    }
  }
  removeAndDeletePoolsOnOtherOwners(subscriptionPools,pool);
  createAndEnrichPools(pool,subscriptionPools);
  regenerateCertificatesByEntIds(updatePoolsForMasterPool(subscriptionPools,pool,updateStackDerived,changedProducts),lazy);
}","@Transactional void refreshPoolsForMasterPool(Pool pool,boolean updateStackDerived,boolean lazy,Set<Product> changedProducts){
  List<Pool> subscriptionPools=poolCurator.getPoolsBySubscriptionId(pool.getSubscriptionId());
  log.debug(""String_Node_Str"",subscriptionPools.size(),pool.getSubscriptionId());
  if (log.isDebugEnabled()) {
    for (    Pool p : subscriptionPools) {
      log.debug(""String_Node_Str"",p.getOwner().getKey(),p);
    }
  }
  removeAndDeletePoolsOnOtherOwners(subscriptionPools,pool);
  Long originalQuantity=pool.getQuantity();
  createAndEnrichPools(pool,subscriptionPools);
  regenerateCertificatesByEntIds(updatePoolsForMasterPool(subscriptionPools,pool,originalQuantity,updateStackDerived,changedProducts),lazy);
}"
49308,"public List<PoolUpdate> updatePools(Pool masterPool,List<Pool> existingPools,Set<Product> changedProducts){
  log.debug(""String_Node_Str"" + masterPool);
  log.debug(""String_Node_Str"" + existingPools.size());
  PoolHelper helper=new PoolHelper(this.poolManager,null);
  List<PoolUpdate> poolsUpdated=new LinkedList<PoolUpdate>();
  Map<String,String> attributes=helper.getFlattenedAttributes(masterPool.getProduct());
  for (  Pool existingPool : existingPools) {
    log.debug(""String_Node_Str"" + existingPool.getId());
    if (""String_Node_Str"".equalsIgnoreCase(existingPool.getSubscriptionSubKey())) {
      existingPool.setUpstreamPoolId(masterPool.getUpstreamPoolId());
      existingPool.setUpstreamEntitlementId(masterPool.getUpstreamEntitlementId());
      existingPool.setUpstreamConsumerId(masterPool.getUpstreamConsumerId());
      existingPool.setCdn(masterPool.getCdn());
      existingPool.setCertificate(masterPool.getCertificate());
    }
    PoolUpdate update=new PoolUpdate(existingPool);
    update.setDatesChanged(checkForDateChange(masterPool.getStartDate(),masterPool.getEndDate(),existingPool));
    update.setQuantityChanged(checkForQuantityChange(masterPool,existingPool,existingPools,attributes));
    if (!existingPool.isMarkedForDelete()) {
      boolean useDerived=BooleanUtils.toBoolean(existingPool.getAttributeValue(""String_Node_Str"")) && masterPool.getDerivedProduct() != null;
      update.setProductsChanged(checkForChangedProducts(useDerived ? masterPool.getDerivedProduct() : masterPool.getProduct(),getExpectedProvidedProducts(masterPool,useDerived),existingPool,changedProducts));
      if (!useDerived) {
        update.setDerivedProductsChanged(checkForChangedDerivedProducts(masterPool,existingPool,changedProducts));
      }
      update.setOrderChanged(checkForOrderDataChanges(masterPool,helper,existingPool));
      update.setBrandingChanged(checkForBrandingChanges(masterPool,existingPool));
    }
    if (update.changed()) {
      poolsUpdated.add(update);
    }
 else {
      log.debug(""String_Node_Str"");
    }
  }
  return poolsUpdated;
}","public List<PoolUpdate> updatePools(Pool masterPool,List<Pool> existingPools,Long originalQuantity,Set<Product> changedProducts){
  log.debug(""String_Node_Str"" + masterPool);
  log.debug(""String_Node_Str"" + existingPools.size());
  PoolHelper helper=new PoolHelper(this.poolManager,null);
  List<PoolUpdate> poolsUpdated=new LinkedList<PoolUpdate>();
  Map<String,String> attributes=helper.getFlattenedAttributes(masterPool.getProduct());
  for (  Pool existingPool : existingPools) {
    log.debug(""String_Node_Str"" + existingPool.getId());
    if (""String_Node_Str"".equalsIgnoreCase(existingPool.getSubscriptionSubKey())) {
      existingPool.setUpstreamPoolId(masterPool.getUpstreamPoolId());
      existingPool.setUpstreamEntitlementId(masterPool.getUpstreamEntitlementId());
      existingPool.setUpstreamConsumerId(masterPool.getUpstreamConsumerId());
      existingPool.setCdn(masterPool.getCdn());
      existingPool.setCertificate(masterPool.getCertificate());
    }
    PoolUpdate update=new PoolUpdate(existingPool);
    update.setDatesChanged(checkForDateChange(masterPool.getStartDate(),masterPool.getEndDate(),existingPool));
    update.setQuantityChanged(checkForQuantityChange(masterPool,existingPool,originalQuantity,existingPools,attributes));
    if (!existingPool.isMarkedForDelete()) {
      boolean useDerived=BooleanUtils.toBoolean(existingPool.getAttributeValue(""String_Node_Str"")) && masterPool.getDerivedProduct() != null;
      update.setProductsChanged(checkForChangedProducts(useDerived ? masterPool.getDerivedProduct() : masterPool.getProduct(),getExpectedProvidedProducts(masterPool,useDerived),existingPool,changedProducts));
      if (!useDerived) {
        update.setDerivedProductsChanged(checkForChangedDerivedProducts(masterPool,existingPool,changedProducts));
      }
      update.setOrderChanged(checkForOrderDataChanges(masterPool,helper,existingPool));
      update.setBrandingChanged(checkForBrandingChanges(masterPool,existingPool));
    }
    if (update.changed()) {
      poolsUpdated.add(update);
    }
 else {
      log.debug(""String_Node_Str"");
    }
  }
  return poolsUpdated;
}"
49309,"private boolean checkForQuantityChange(Pool pool,Pool existingPool,List<Pool> existingPools,Map<String,String> attributes){
  long expectedQuantity=calculateQuantity(pool.getQuantity(),pool.getProduct(),pool.getUpstreamPoolId());
  expectedQuantity=processVirtLimitPools(existingPools,attributes,existingPool,expectedQuantity);
  boolean quantityChanged=!(expectedQuantity == existingPool.getQuantity());
  if (quantityChanged) {
    existingPool.setQuantity(expectedQuantity);
  }
  return quantityChanged;
}","private boolean checkForQuantityChange(Pool pool,Pool existingPool,Long originalQuantity,List<Pool> existingPools,Map<String,String> attributes){
  long expectedQuantity=calculateQuantity(originalQuantity,pool.getProduct(),pool.getUpstreamPoolId());
  expectedQuantity=processVirtLimitPools(existingPools,attributes,existingPool,expectedQuantity);
  boolean quantityChanged=!(expectedQuantity == existingPool.getQuantity());
  if (quantityChanged) {
    existingPool.setQuantity(expectedQuantity);
  }
  return quantityChanged;
}"
49310,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void refreshPoolsCleanupPoolThatLostVirtLimit(){
  List<Subscription> subscriptions=Util.newList();
  List<Pool> pools=Util.newList();
  Subscription s=TestUtil.createSubscription(getOwner(),TestUtil.createProduct(o));
  s.setId(""String_Node_Str"");
  subscriptions.add(s);
  Pool p=TestUtil.createPool(s.getProduct());
  p.setSourceSubscription(new SourceSubscription(s.getId(),""String_Node_Str""));
  p.setMarkedForDelete(true);
  p.setOwner(s.getOwner());
  pools.add(p);
  mockSubsList(subscriptions);
  mockPoolsList(pools);
  List<PoolUpdate> updates=new LinkedList();
  PoolUpdate u=new PoolUpdate(p);
  u.setQuantityChanged(true);
  u.setOrderChanged(true);
  updates.add(u);
  ArgumentCaptor<Pool> argPool=ArgumentCaptor.forClass(Pool.class);
  when(poolRulesMock.updatePools(argPool.capture(),eq(pools),any(Set.class))).thenReturn(updates);
  when(ownerCuratorMock.lookupByKey(s.getOwner().getKey())).thenReturn(s.getOwner());
  this.manager.getRefresher(mockSubAdapter).add(getOwner()).run();
  verify(poolRulesMock).createAndEnrichPools(argPool.capture(),any(List.class));
  TestUtil.assertPoolsAreEqual(TestUtil.copyFromSub(s),argPool.getValue());
  verify(this.mockPoolCurator,times(1)).delete(any(Pool.class));
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void refreshPoolsCleanupPoolThatLostVirtLimit(){
  List<Subscription> subscriptions=Util.newList();
  List<Pool> pools=Util.newList();
  Subscription s=TestUtil.createSubscription(getOwner(),TestUtil.createProduct(o));
  s.setId(""String_Node_Str"");
  subscriptions.add(s);
  Pool p=TestUtil.createPool(s.getProduct());
  p.setSourceSubscription(new SourceSubscription(s.getId(),""String_Node_Str""));
  p.setMarkedForDelete(true);
  p.setOwner(s.getOwner());
  pools.add(p);
  mockSubsList(subscriptions);
  mockPoolsList(pools);
  List<PoolUpdate> updates=new LinkedList();
  PoolUpdate u=new PoolUpdate(p);
  u.setQuantityChanged(true);
  u.setOrderChanged(true);
  updates.add(u);
  ArgumentCaptor<Pool> argPool=ArgumentCaptor.forClass(Pool.class);
  when(poolRulesMock.updatePools(argPool.capture(),eq(pools),eq(s.getQuantity()),any(Set.class))).thenReturn(updates);
  when(ownerCuratorMock.lookupByKey(s.getOwner().getKey())).thenReturn(s.getOwner());
  this.manager.getRefresher(mockSubAdapter).add(getOwner()).run();
  verify(poolRulesMock).createAndEnrichPools(argPool.capture(),any(List.class));
  TestUtil.assertPoolsAreEqual(TestUtil.copyFromSub(s),argPool.getValue());
  verify(this.mockPoolCurator,times(1)).delete(any(Pool.class));
}"
49311,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testRefreshPoolsOnlyRegeneratesWhenNecessary(){
  List<Subscription> subscriptions=Util.newList();
  Product product=TestUtil.createProduct(o);
  Subscription sub=TestUtil.createSubscription(getOwner(),product);
  sub.setId(""String_Node_Str"");
  subscriptions.add(sub);
  List<Pool> pools=Util.newList();
  Pool p=TestUtil.createPool(product);
  p.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
  p.setOwner(sub.getOwner());
  pools.add(p);
  mockSubsList(subscriptions);
  mockPoolsList(pools);
  when(ownerCuratorMock.lookupByKey(sub.getOwner().getKey())).thenReturn(sub.getOwner());
  this.manager.getRefresher(mockSubAdapter).add(getOwner()).run();
  List<Pool> expectedModified=new LinkedList();
  expectedModified.add(p);
  verify(this.manager).updateFloatingPools(eq(new LinkedList()),eq(true),any(Set.class));
  ArgumentCaptor<Pool> argPool=ArgumentCaptor.forClass(Pool.class);
  verify(this.manager).updatePoolsForMasterPool(eq(expectedModified),argPool.capture(),eq(false),any(Set.class));
  TestUtil.assertPoolsAreEqual(TestUtil.copyFromSub(sub),argPool.getValue());
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testRefreshPoolsOnlyRegeneratesWhenNecessary(){
  List<Subscription> subscriptions=Util.newList();
  Product product=TestUtil.createProduct(o);
  Subscription sub=TestUtil.createSubscription(getOwner(),product);
  sub.setId(""String_Node_Str"");
  subscriptions.add(sub);
  List<Pool> pools=Util.newList();
  Pool p=TestUtil.createPool(product);
  p.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
  p.setOwner(sub.getOwner());
  pools.add(p);
  mockSubsList(subscriptions);
  mockPoolsList(pools);
  when(ownerCuratorMock.lookupByKey(sub.getOwner().getKey())).thenReturn(sub.getOwner());
  this.manager.getRefresher(mockSubAdapter).add(getOwner()).run();
  List<Pool> expectedModified=new LinkedList();
  expectedModified.add(p);
  verify(this.manager).updateFloatingPools(eq(new LinkedList()),eq(true),any(Set.class));
  ArgumentCaptor<Pool> argPool=ArgumentCaptor.forClass(Pool.class);
  verify(this.manager).updatePoolsForMasterPool(eq(expectedModified),argPool.capture(),eq(sub.getQuantity()),eq(false),any(Set.class));
  TestUtil.assertPoolsAreEqual(TestUtil.copyFromSub(sub),argPool.getValue());
}"
49312,"@Test public void testPoolOnlyExaminedOnceProductAndOwner(){
  Owner owner=TestUtil.createOwner();
  Product product=mock(Product.class);
  when(product.getUuid()).thenReturn(""String_Node_Str"");
  Pool pool=new Pool();
  pool.setSourceSubscription(new SourceSubscription(""String_Node_Str"",""String_Node_Str""));
  pool.setOwner(owner);
  Subscription subscription=new Subscription();
  subscription.setId(""String_Node_Str"");
  subscription.setOwner(owner);
  List<Pool> pools=Util.newList();
  pools.add(pool);
  List<Subscription> subscriptions=Util.newList();
  subscriptions.add(subscription);
  when(subAdapter.getSubscriptions(product)).thenReturn(subscriptions);
  when(subAdapter.getSubscriptions(owner)).thenReturn(subscriptions);
  when(subAdapter.getSubscription(""String_Node_Str"")).thenReturn(subscription);
  when(poolManager.lookupBySubscriptionId(""String_Node_Str"")).thenReturn(pools);
  refresher.add(owner);
  refresher.add(product);
  refresher.run();
  verify(poolManager,times(1)).refreshPoolsWithRegeneration(eq(subAdapter),eq(owner),eq(false));
  verify(poolManager,times(0)).updatePoolsForMasterPool(any(List.class),any(Pool.class),eq(false),any(Set.class));
}","@Test public void testPoolOnlyExaminedOnceProductAndOwner(){
  Owner owner=TestUtil.createOwner();
  Product product=mock(Product.class);
  when(product.getUuid()).thenReturn(""String_Node_Str"");
  Pool pool=new Pool();
  pool.setSourceSubscription(new SourceSubscription(""String_Node_Str"",""String_Node_Str""));
  pool.setOwner(owner);
  Subscription subscription=new Subscription();
  subscription.setId(""String_Node_Str"");
  subscription.setOwner(owner);
  List<Pool> pools=Util.newList();
  pools.add(pool);
  List<Subscription> subscriptions=Util.newList();
  subscriptions.add(subscription);
  when(subAdapter.getSubscriptions(product)).thenReturn(subscriptions);
  when(subAdapter.getSubscriptions(owner)).thenReturn(subscriptions);
  when(subAdapter.getSubscription(""String_Node_Str"")).thenReturn(subscription);
  when(poolManager.lookupBySubscriptionId(""String_Node_Str"")).thenReturn(pools);
  refresher.add(owner);
  refresher.add(product);
  refresher.run();
  verify(poolManager,times(1)).refreshPoolsWithRegeneration(eq(subAdapter),eq(owner),eq(false));
  verify(poolManager,times(0)).updatePoolsForMasterPool(any(List.class),any(Pool.class),eq(pool.getQuantity()),eq(false),any(Set.class));
}"
49313,"@Test public void hostedInstanceBasedRemoved(){
  Subscription s=createInstanceBasedSub(""String_Node_Str"",100,2,false);
  Pool masterPool=TestUtil.copyFromSub(s);
  List<Pool> pools=poolRules.createAndEnrichPools(masterPool,new LinkedList<Pool>());
  assertEquals(1,pools.size());
  Pool pool=pools.get(0);
  masterPool=TestUtil.copyFromSub(s);
  ProductAttribute pa=masterPool.getProduct().getAttribute(""String_Node_Str"");
  masterPool.getProduct().getAttributes().remove(pa);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(pool);
  List<PoolUpdate> updates=poolRules.updatePools(masterPool,existingPools,TestUtil.stubChangedProducts(masterPool.getProduct()));
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getQuantityChanged());
  assertEquals(new Long(100),update.getPool().getQuantity());
  assertFalse(update.getPool().getProduct().hasAttribute(""String_Node_Str""));
}","@Test public void hostedInstanceBasedRemoved(){
  Subscription s=createInstanceBasedSub(""String_Node_Str"",100,2,false);
  Pool masterPool=TestUtil.copyFromSub(s);
  List<Pool> pools=poolRules.createAndEnrichPools(masterPool,new LinkedList<Pool>());
  assertEquals(1,pools.size());
  Pool pool=pools.get(0);
  masterPool=TestUtil.copyFromSub(s);
  ProductAttribute pa=masterPool.getProduct().getAttribute(""String_Node_Str"");
  masterPool.getProduct().getAttributes().remove(pa);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(pool);
  List<PoolUpdate> updates=poolRules.updatePools(masterPool,existingPools,s.getQuantity(),TestUtil.stubChangedProducts(masterPool.getProduct()));
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getQuantityChanged());
  assertEquals(new Long(100),update.getPool().getQuantity());
  assertFalse(update.getPool().getProduct().hasAttribute(""String_Node_Str""));
}"
49314,"@Test public void hostedInstanceBasedUpdatePool(){
  Subscription s=createInstanceBasedSub(""String_Node_Str"",100,2,false);
  Pool p=TestUtil.copyFromSub(s);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(1,pools.size());
  Pool pool=pools.get(0);
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  p.setQuantity(new Long(200));
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(pool);
  List<PoolUpdate> updates=poolRules.updatePools(p,existingPools,TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getQuantityChanged());
  assertEquals(new Long(800),update.getPool().getQuantity());
}","@Test public void hostedInstanceBasedUpdatePool(){
  Subscription s=createInstanceBasedSub(""String_Node_Str"",100,2,false);
  Pool p=TestUtil.copyFromSub(s);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(1,pools.size());
  Pool pool=pools.get(0);
  p=TestUtil.copyFromSub(s);
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  p.setQuantity(new Long(200));
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(pool);
  List<PoolUpdate> updates=poolRules.updatePools(p,existingPools,p.getQuantity(),TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getQuantityChanged());
  assertEquals(new Long(800),update.getPool().getQuantity());
}"
49315,"@Test public void standaloneInstanceBasedUpdatePool(){
  Subscription s=createInstanceBasedSub(""String_Node_Str"",100,2,true);
  Pool masterPool=TestUtil.copyFromSub(s);
  List<Pool> pools=poolRules.createAndEnrichPools(masterPool,new LinkedList<Pool>());
  assertEquals(1,pools.size());
  Pool pool=pools.get(0);
  masterPool=TestUtil.copyFromSub(s);
  masterPool.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  masterPool.setQuantity(new Long(200));
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(pool);
  List<PoolUpdate> updates=poolRules.updatePools(masterPool,existingPools,TestUtil.stubChangedProducts(masterPool.getProduct()));
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getQuantityChanged());
  assertEquals(new Long(200),update.getPool().getQuantity());
}","@Test public void standaloneInstanceBasedUpdatePool(){
  Subscription s=createInstanceBasedSub(""String_Node_Str"",100,2,true);
  Pool masterPool=TestUtil.copyFromSub(s);
  List<Pool> pools=poolRules.createAndEnrichPools(masterPool,new LinkedList<Pool>());
  assertEquals(1,pools.size());
  Pool pool=pools.get(0);
  masterPool=TestUtil.copyFromSub(s);
  masterPool.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  masterPool.setQuantity(new Long(200));
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(pool);
  List<PoolUpdate> updates=poolRules.updatePools(masterPool,existingPools,masterPool.getQuantity(),TestUtil.stubChangedProducts(masterPool.getProduct()));
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getQuantityChanged());
  assertEquals(new Long(200),update.getPool().getQuantity());
}"
49316,"@Test public void brandingDidntChange(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Branding b1=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Branding b2=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  p.getBranding().add(b1);
  p.getBranding().add(b2);
  when(productAdapterMock.getProductById(p.getProduct().getOwner(),p.getProduct().getId())).thenReturn(p.getProduct());
  Pool p1=TestUtil.clone(p);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(0,updates.size());
}","@Test public void brandingDidntChange(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Branding b1=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Branding b2=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  p.getBranding().add(b1);
  p.getBranding().add(b2);
  when(productAdapterMock.getProductById(p.getProduct().getOwner(),p.getProduct().getId())).thenReturn(p.getProduct());
  Pool p1=TestUtil.clone(p);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(0,updates.size());
}"
49317,"@Test public void hostedVirtLimitSubUpdatesUnlimitedBonusVirtOnlyPool(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  Pool virtBonusPool=pools.get(1);
  assertEquals(new Long(-1),virtBonusPool.getQuantity());
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(2,updates.size());
  PoolUpdate virtUpdate=updates.get(1);
  assertEquals(new Long(100),virtUpdate.getPool().getQuantity());
}","@Test public void hostedVirtLimitSubUpdatesUnlimitedBonusVirtOnlyPool(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  Pool virtBonusPool=pools.get(1);
  assertEquals(new Long(-1),virtBonusPool.getQuantity());
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,p.getQuantity(),TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(2,updates.size());
  PoolUpdate virtUpdate=updates.get(1);
  assertEquals(new Long(100),virtUpdate.getPool().getQuantity());
}"
49318,"@Test public void updateVirtOnlyNoVirtLimit(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setQuantity(10L);
  Pool p1=TestUtil.clone(p);
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.setQuantity(20L);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertTrue(update.getQuantityChanged());
  assertEquals(Long.valueOf(10),update.getPool().getQuantity());
}","@Test public void updateVirtOnlyNoVirtLimit(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setQuantity(10L);
  Pool p1=TestUtil.clone(p);
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.setQuantity(20L);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertTrue(update.getQuantityChanged());
  assertEquals(Long.valueOf(10),update.getPool().getQuantity());
}"
49319,"@Test public void standaloneVirtLimitSubUpdate(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  assertEquals(0,physicalPool.getAttributes().size());
  p=createVirtLimitPool(""String_Node_Str"",10,10);
  p.setQuantity(50L);
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,new HashSet<Product>());
  assertEquals(2,updates.size());
  physicalPool=updates.get(0).getPool();
  Pool unmappedPool=updates.get(1).getPool();
  assertEquals(new Long(50),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
}","@Test public void standaloneVirtLimitSubUpdate(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  assertEquals(0,physicalPool.getAttributes().size());
  p=createVirtLimitPool(""String_Node_Str"",10,10);
  p.setQuantity(50L);
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,p.getQuantity(),new HashSet<Product>());
  assertEquals(2,updates.size());
  physicalPool=updates.get(0).getPool();
  Pool unmappedPool=updates.get(1).getPool();
  assertEquals(new Long(50),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
}"
49320,"@Test public void productNameChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Pool p1=TestUtil.clone(p);
  p1.getProduct().setName(""String_Node_Str"");
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getQuantityChanged());
  assertEquals(p.getProduct().getName(),update.getPool().getProductName());
}","@Test public void productNameChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Pool p1=TestUtil.clone(p);
  p1.getProduct().setName(""String_Node_Str"");
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getQuantityChanged());
  assertEquals(p.getProduct().getName(),update.getPool().getProductName());
}"
49321,"@Test public void quantityChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Pool p1=TestUtil.clone(p);
  p1.setQuantity(2000L);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertTrue(update.getQuantityChanged());
  assertEquals(p.getQuantity(),update.getPool().getQuantity());
}","@Test public void quantityChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Pool p1=TestUtil.clone(p);
  p1.setQuantity(2000L);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertTrue(update.getQuantityChanged());
  assertEquals(p.getQuantity(),update.getPool().getQuantity());
}"
49322,"@Test public void brandingChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Pool p1=TestUtil.clone(p);
  Branding b1=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Branding b2=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  p.getBranding().add(b1);
  p.getBranding().add(b2);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getQuantityChanged());
  assertTrue(update.getBrandingChanged());
  assertTrue(update.changed());
  assertEquals(2,update.getPool().getBranding().size());
  assertTrue(update.getPool().getBranding().contains(b1));
  assertTrue(update.getPool().getBranding().contains(b2));
}","@Test public void brandingChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Pool p1=TestUtil.clone(p);
  Branding b1=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Branding b2=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  p.getBranding().add(b1);
  p.getBranding().add(b2);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getQuantityChanged());
  assertTrue(update.getBrandingChanged());
  assertTrue(update.changed());
  assertEquals(2,update.getPool().getBranding().size());
  assertTrue(update.getPool().getBranding().contains(b1));
  assertTrue(update.getPool().getBranding().contains(b2));
}"
49323,"@Test public void updatePoolSubProvidedProductsChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Product subProd=TestUtil.createProduct(owner);
  p.setDerivedProduct(subProd);
  Product product1=TestUtil.createProduct(owner);
  Product product2=TestUtil.createProduct(owner);
  Product product3=TestUtil.createProduct(owner);
  p.getDerivedProvidedProducts().add(product1);
  p.getDerivedProvidedProducts().add(product2);
  Pool p1=TestUtil.clone(p);
  p1.getProvidedProducts().clear();
  p1.getProvidedProducts().add(product3);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  assertEquals(2,updates.get(0).getPool().getDerivedProvidedProducts().size());
}","@Test public void updatePoolSubProvidedProductsChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Product subProd=TestUtil.createProduct(owner);
  p.setDerivedProduct(subProd);
  Product product1=TestUtil.createProduct(owner);
  Product product2=TestUtil.createProduct(owner);
  Product product3=TestUtil.createProduct(owner);
  p.getDerivedProvidedProducts().add(product1);
  p.getDerivedProvidedProducts().add(product2);
  Pool p1=TestUtil.clone(p);
  p1.getProvidedProducts().clear();
  p1.getProvidedProducts().add(product3);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  assertEquals(2,updates.get(0).getPool().getDerivedProvidedProducts().size());
}"
49324,"@Test public void standaloneVirtSubPoolUpdateNoChanges(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  Entitlement ent=mock(Entitlement.class);
  when(ent.getQuantity()).thenReturn(1);
  Pool consumerSpecificPool=TestUtil.clone(p);
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setQuantity(10L);
  consumerSpecificPool.setSourceEntitlement(ent);
  pools.add(consumerSpecificPool);
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,new HashSet<Product>());
  assertEquals(0,updates.size());
}","@Test public void standaloneVirtSubPoolUpdateNoChanges(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  Entitlement ent=mock(Entitlement.class);
  when(ent.getQuantity()).thenReturn(1);
  Pool consumerSpecificPool=TestUtil.clone(p);
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setQuantity(10L);
  consumerSpecificPool.setSourceEntitlement(ent);
  pools.add(consumerSpecificPool);
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,p.getQuantity(),new HashSet<Product>());
  assertEquals(0,updates.size());
}"
49325,"@Test public void providedProductsChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Product product1=TestUtil.createProduct(owner);
  Product product2=TestUtil.createProduct(owner);
  Product product3=TestUtil.createProduct(owner);
  p.getProvidedProducts().add(product1);
  p.getProvidedProducts().add(product2);
  Pool p1=TestUtil.clone(p);
  p1.getProvidedProducts().clear();
  p1.getProvidedProducts().add(product3);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getQuantityChanged());
}","@Test public void providedProductsChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Product product1=TestUtil.createProduct(owner);
  Product product2=TestUtil.createProduct(owner);
  Product product3=TestUtil.createProduct(owner);
  p.getProvidedProducts().add(product1);
  p.getProvidedProducts().add(product2);
  Pool p1=TestUtil.clone(p);
  p1.getProvidedProducts().clear();
  p1.getProvidedProducts().add(product3);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getQuantityChanged());
}"
49326,"@Test public void accountNumberChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setAccountNumber(""String_Node_Str"");
  Pool p1=TestUtil.clone(p);
  p1.setQuantity(2000L);
  p1.setAccountNumber(""String_Node_Str"");
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getOrderChanged());
  assertEquals(""String_Node_Str"",update.getPool().getAccountNumber());
}","@Test public void accountNumberChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setAccountNumber(""String_Node_Str"");
  Pool p1=TestUtil.clone(p);
  p1.setQuantity(2000L);
  p1.setAccountNumber(""String_Node_Str"");
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getOrderChanged());
  assertEquals(""String_Node_Str"",update.getPool().getAccountNumber());
}"
49327,"@Test public void orderNumberChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setOrderNumber(""String_Node_Str"");
  Pool p1=TestUtil.clone(p);
  p1.setQuantity(2000L);
  p1.setOrderNumber(""String_Node_Str"");
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getOrderChanged());
  assertEquals(""String_Node_Str"",update.getPool().getOrderNumber());
}","@Test public void orderNumberChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setOrderNumber(""String_Node_Str"");
  Pool p1=TestUtil.clone(p);
  p1.setQuantity(2000L);
  p1.setOrderNumber(""String_Node_Str"");
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getOrderChanged());
  assertEquals(""String_Node_Str"",update.getPool().getOrderNumber());
}"
49328,"@Test public void standaloneVirtSubPoolUpdateVirtLimitChanged(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  p.setQuantity(new Long(20));
  Entitlement ent=mock(Entitlement.class);
  when(ent.getQuantity()).thenReturn(4);
  Pool consumerSpecificPool=TestUtil.clone(p);
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setQuantity(10L);
  consumerSpecificPool.setSourceEntitlement(ent);
  pools.add(consumerSpecificPool);
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(3,updates.size());
  Pool regular=updates.get(0).getPool();
  Pool unmappedSubPool=updates.get(1).getPool();
  Pool subPool=updates.get(2).getPool();
  assertEquals(""String_Node_Str"",regular.getProduct().getAttributeValue(""String_Node_Str""));
  assertEquals(new Long(40),subPool.getQuantity());
  assertEquals(new Long(800),unmappedSubPool.getQuantity());
}","@Test public void standaloneVirtSubPoolUpdateVirtLimitChanged(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  p.setQuantity(new Long(20));
  Entitlement ent=mock(Entitlement.class);
  when(ent.getQuantity()).thenReturn(4);
  Pool consumerSpecificPool=TestUtil.clone(p);
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setQuantity(10L);
  consumerSpecificPool.setSourceEntitlement(ent);
  pools.add(consumerSpecificPool);
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,p.getQuantity(),TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(3,updates.size());
  Pool regular=updates.get(0).getPool();
  Pool unmappedSubPool=updates.get(1).getPool();
  Pool subPool=updates.get(2).getPool();
  assertEquals(""String_Node_Str"",regular.getProduct().getAttributeValue(""String_Node_Str""));
  assertEquals(new Long(40),subPool.getQuantity());
  assertEquals(new Long(800),unmappedSubPool.getQuantity());
}"
49329,"@Test public void virtOnlyQuantityChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.getProduct().addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  p.setQuantity(10L);
  when(productAdapterMock.getProductById(p.getProduct().getOwner(),p.getProduct().getId())).thenReturn(p.getProduct());
  Pool p1=TestUtil.clone(p);
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.setQuantity(40L);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,null);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getProductAttributesChanged());
  assertTrue(update.getQuantityChanged());
  assertEquals(Long.valueOf(50),update.getPool().getQuantity());
}","@Test public void virtOnlyQuantityChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.getProduct().addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  p.setQuantity(10L);
  when(productAdapterMock.getProductById(p.getProduct().getOwner(),p.getProduct().getId())).thenReturn(p.getProduct());
  Pool p1=TestUtil.clone(p);
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.setQuantity(40L);
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),null);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getProductAttributesChanged());
  assertTrue(update.getQuantityChanged());
  assertEquals(Long.valueOf(50),update.getPool().getQuantity());
}"
49330,"@Test public void hostedVirtLimitRemoved(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  p.setProduct(TestUtil.createProduct(p.getProduct().getId(),p.getProduct().getName(),owner));
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(2,updates.size());
  PoolUpdate baseUpdate=updates.get(0);
  assertEquals(new Long(10),baseUpdate.getPool().getQuantity());
  assertFalse(baseUpdate.getPool().isMarkedForDelete());
  PoolUpdate virtUpdate=updates.get(1);
  assertEquals(new Long(0),virtUpdate.getPool().getQuantity());
  assertTrue(virtUpdate.getPool().isMarkedForDelete());
}","@Test public void hostedVirtLimitRemoved(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Pool p=createVirtLimitPool(""String_Node_Str"",10,10);
  p.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(2,pools.size());
  p.setProduct(TestUtil.createProduct(p.getProduct().getId(),p.getProduct().getName(),owner));
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,p.getQuantity(),TestUtil.stubChangedProducts(p.getProduct()));
  assertEquals(2,updates.size());
  PoolUpdate baseUpdate=updates.get(0);
  assertEquals(new Long(10),baseUpdate.getPool().getQuantity());
  assertFalse(baseUpdate.getPool().isMarkedForDelete());
  PoolUpdate virtUpdate=updates.get(1);
  assertEquals(new Long(0),virtUpdate.getPool().getQuantity());
  assertTrue(virtUpdate.getPool().isMarkedForDelete());
}"
49331,"@Test public void dontUpdateVirtOnlyNoVirtLimit(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setQuantity(10L);
  when(productAdapterMock.getProductById(p.getProduct().getOwner(),p.getProduct().getId())).thenReturn(p.getProduct());
  Pool p1=TestUtil.clone(p);
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.setQuantity(10L);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(0,updates.size());
}","@Test public void dontUpdateVirtOnlyNoVirtLimit(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setQuantity(10L);
  when(productAdapterMock.getProductById(p.getProduct().getOwner(),p.getProduct().getId())).thenReturn(p.getProduct());
  Pool p1=TestUtil.clone(p);
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p1.setQuantity(10L);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(0,updates.size());
}"
49332,"@Test public void hostedVirtOnlySubUpdate(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool p=createVirtOnlyPool(""String_Node_Str"",10);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(1,pools.size());
  p=createVirtOnlyPool(""String_Node_Str"",20);
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,new HashSet<Product>());
  assertEquals(1,updates.size());
  Pool updated=updates.get(0).getPool();
  assertEquals(new Long(20),updated.getQuantity());
}","@Test public void hostedVirtOnlySubUpdate(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool p=createVirtOnlyPool(""String_Node_Str"",10);
  List<Pool> pools=poolRules.createAndEnrichPools(p,new LinkedList<Pool>());
  assertEquals(1,pools.size());
  p=createVirtOnlyPool(""String_Node_Str"",20);
  List<PoolUpdate> updates=poolRules.updatePools(p,pools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  Pool updated=updates.get(0).getPool();
  assertEquals(new Long(20),updated.getQuantity());
}"
49333,"@Test public void contractNumberChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setContractNumber(""String_Node_Str"");
  Pool p1=TestUtil.clone(p);
  p1.setQuantity(2000L);
  p1.setContractNumber(""String_Node_Str"");
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getOrderChanged());
  assertEquals(""String_Node_Str"",update.getPool().getContractNumber());
}","@Test public void contractNumberChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  p.setContractNumber(""String_Node_Str"");
  Pool p1=TestUtil.clone(p);
  p1.setQuantity(2000L);
  p1.setContractNumber(""String_Node_Str"");
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertTrue(update.getOrderChanged());
  assertEquals(""String_Node_Str"",update.getPool().getContractNumber());
}"
49334,"@Test public void datesNameChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Pool p1=TestUtil.clone(p);
  p1.setEndDate(new Date());
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertTrue(update.getDatesChanged());
  assertFalse(update.getQuantityChanged());
  assertEquals(p.getEndDate(),update.getPool().getEndDate());
}","@Test public void datesNameChanged(){
  Pool p=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Pool p1=TestUtil.clone(p);
  p1.setEndDate(new Date());
  List<Pool> existingPools=Arrays.asList(p1);
  List<PoolUpdate> updates=this.poolRules.updatePools(p,existingPools,p.getQuantity(),new HashSet<Product>());
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertTrue(update.getDatesChanged());
  assertFalse(update.getQuantityChanged());
  assertEquals(p.getEndDate(),update.getPool().getEndDate());
}"
49335,"@Override public String toString(){
  return ""String_Node_Str"" + (owner != null ? owner.getKey() : null) + ""String_Node_Str""+ id+ ""String_Node_Str""+ name+ ""String_Node_Str"";
}","@Override public String toString(){
  String ownerKey=(owner != null ? owner.getKey() : null);
  return ""String_Node_Str"" + ownerKey + ""String_Node_Str""+ id+ ""String_Node_Str""+ name+ ""String_Node_Str"";
}"
49336,"@Test public void testCreateUeberCertificateRegenerate(){
  Principal principal=setupPrincipal(owner,Access.ALL);
  Owner owner=TestUtil.createOwner();
  Consumer consumer=TestUtil.createConsumer(owner);
  Entitlement ent=mock(Entitlement.class);
  List<Entitlement> entList=Arrays.asList(ent);
  EntitlementCertificate entCert=mock(EntitlementCertificate.class);
  List<EntitlementCertificate> ecList=Arrays.asList(entCert);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerCurator cc=mock(ConsumerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  CandlepinPoolManager cpm=mock(CandlepinPoolManager.class);
  EntitlementCertificateCurator ecc=mock(EntitlementCertificateCurator.class);
  UeberCertificateGenerator ucg=mock(UeberCertificateGenerator.class);
  OwnerResource resource=new OwnerResource(oc,null,cc,null,i18n,null,null,null,null,null,cpm,null,null,null,null,null,ecc,ec,ucg,null,null,null,null,null,null,null,null);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
  when(cc.findByName(eq(owner),eq(Consumer.UEBER_CERT_CONSUMER))).thenReturn(consumer);
  when(ec.listByConsumer(eq(consumer))).thenReturn(entList);
  when(ecc.listForConsumer(eq(consumer))).thenReturn(ecList);
  EntitlementCertificate result=resource.createUeberCertificate(principal,""String_Node_Str"");
  assertEquals(entCert,result);
}","@Test public void testCreateUeberCertificateRegenerate(){
  Principal principal=setupPrincipal(owner,Access.ALL);
  Owner owner=TestUtil.createOwner();
  Consumer consumer=TestUtil.createConsumer(owner);
  Entitlement ent=mock(Entitlement.class);
  List<Entitlement> entList=Arrays.asList(ent);
  EntitlementCertificate entCert=mock(EntitlementCertificate.class);
  List<EntitlementCertificate> ecList=Arrays.asList(entCert);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerCurator cc=mock(ConsumerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  CandlepinPoolManager cpm=mock(CandlepinPoolManager.class);
  EntitlementCertificateCurator ecc=mock(EntitlementCertificateCurator.class);
  UeberCertificateGenerator ucg=mock(UeberCertificateGenerator.class);
  OwnerResource resource=new OwnerResource(oc,null,cc,null,i18n,null,null,null,null,null,cpm,null,null,null,null,null,ecc,ec,ucg,null,null,null,null,null,null,null,null,null);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
  when(cc.findByName(eq(owner),eq(Consumer.UEBER_CERT_CONSUMER))).thenReturn(consumer);
  when(ec.listByConsumer(eq(consumer))).thenReturn(entList);
  when(ecc.listForConsumer(eq(consumer))).thenReturn(ecList);
  EntitlementCertificate result=resource.createUeberCertificate(principal,""String_Node_Str"");
  assertEquals(entCert,result);
}"
49337,"@Test public void upstreamConsumers(){
  Principal p=mock(Principal.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  UpstreamConsumer upstream=mock(UpstreamConsumer.class);
  Owner owner=mock(Owner.class);
  OwnerResource ownerres=new OwnerResource(oc,null,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
  when(owner.getUpstreamConsumer()).thenReturn(upstream);
  List<UpstreamConsumer> results=ownerres.getUpstreamConsumers(p,""String_Node_Str"");
  assertNotNull(results);
  assertEquals(1,results.size());
}","@Test public void upstreamConsumers(){
  Principal p=mock(Principal.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  UpstreamConsumer upstream=mock(UpstreamConsumer.class);
  Owner owner=mock(Owner.class);
  OwnerResource ownerres=new OwnerResource(oc,null,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null,null);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
  when(owner.getUpstreamConsumer()).thenReturn(upstream);
  List<UpstreamConsumer> results=ownerres.getUpstreamConsumers(p,""String_Node_Str"");
  assertNotNull(results);
  assertEquals(1,results.size());
}"
49338,"@Test public void testImportRecordFailureWithFilename() throws IOException, ImporterException {
  Importer importer=mock(Importer.class);
  EventSink es=mock(EventSink.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,null,null,null,i18n,es,null,null,null,importer,null,null,null,importRecordCurator,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  MultipartInput input=mock(MultipartInput.class);
  InputPart part=mock(InputPart.class);
  File archive=mock(File.class);
  List<InputPart> parts=new ArrayList<InputPart>();
  parts.add(part);
  MultivaluedMap<String,String> mm=new MultivaluedMapImpl<String,String>();
  List<String> contDis=new ArrayList<String>();
  contDis.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",contDis);
  when(input.getParts()).thenReturn(parts);
  when(part.getHeaders()).thenReturn(mm);
  when(part.getBody(any(GenericType.class))).thenReturn(archive);
  when(importer.loadExport(eq(owner),any(File.class),any(ConflictOverrides.class))).thenThrow(new ImporterException(""String_Node_Str""));
  try {
    thisOwnerResource.importManifest(owner.getKey(),new String[]{},input);
  }
 catch (  IseException ise) {
  }
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  ImportRecord ir=records.get(0);
  assertEquals(""String_Node_Str"",ir.getFileName());
  assertEquals(owner,ir.getOwner());
  assertEquals(ImportRecord.Status.FAILURE,ir.getStatus());
  assertEquals(""String_Node_Str"",ir.getStatusMessage());
}","@Test public void testImportRecordFailureWithFilename() throws IOException, ImporterException {
  Importer importer=mock(Importer.class);
  EventSink es=mock(EventSink.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,null,null,null,i18n,es,null,null,null,importer,null,null,null,importRecordCurator,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null,null);
  MultipartInput input=mock(MultipartInput.class);
  InputPart part=mock(InputPart.class);
  File archive=mock(File.class);
  List<InputPart> parts=new ArrayList<InputPart>();
  parts.add(part);
  MultivaluedMap<String,String> mm=new MultivaluedMapImpl<String,String>();
  List<String> contDis=new ArrayList<String>();
  contDis.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",contDis);
  when(input.getParts()).thenReturn(parts);
  when(part.getHeaders()).thenReturn(mm);
  when(part.getBody(any(GenericType.class))).thenReturn(archive);
  when(importer.loadExport(eq(owner),any(File.class),any(ConflictOverrides.class))).thenThrow(new ImporterException(""String_Node_Str""));
  try {
    thisOwnerResource.importManifest(owner.getKey(),new String[]{},input);
  }
 catch (  IseException ise) {
  }
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  ImportRecord ir=records.get(0);
  assertEquals(""String_Node_Str"",ir.getFileName());
  assertEquals(owner,ir.getOwner());
  assertEquals(ImportRecord.Status.FAILURE,ir.getStatus());
  assertEquals(""String_Node_Str"",ir.getStatusMessage());
}"
49339,"@Test public void testCreateUeberCertificateFromScratch(){
  Principal principal=setupPrincipal(owner,Access.ALL);
  Owner owner=TestUtil.createOwner();
  Consumer consumer=TestUtil.createConsumer(owner);
  EntitlementCertificate entCert=mock(EntitlementCertificate.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerCurator cc=mock(ConsumerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  CandlepinPoolManager cpm=mock(CandlepinPoolManager.class);
  EntitlementCertificateCurator ecc=mock(EntitlementCertificateCurator.class);
  UeberCertificateGenerator ucg=mock(UeberCertificateGenerator.class);
  OwnerResource resource=new OwnerResource(oc,null,cc,null,i18n,null,null,null,null,null,cpm,null,null,null,null,null,ecc,ec,ucg,null,null,null,null,null,null,null,null);
  try {
    when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
    when(cc.findByName(eq(owner),eq(Consumer.UEBER_CERT_CONSUMER))).thenReturn(null);
    when(ucg.generate(eq(owner),eq(principal))).thenReturn(entCert);
  }
 catch (  EntitlementRefusedException ere) {
  }
  EntitlementCertificate result=resource.createUeberCertificate(principal,""String_Node_Str"");
  assertEquals(entCert,result);
}","@Test public void testCreateUeberCertificateFromScratch(){
  Principal principal=setupPrincipal(owner,Access.ALL);
  Owner owner=TestUtil.createOwner();
  Consumer consumer=TestUtil.createConsumer(owner);
  EntitlementCertificate entCert=mock(EntitlementCertificate.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerCurator cc=mock(ConsumerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  CandlepinPoolManager cpm=mock(CandlepinPoolManager.class);
  EntitlementCertificateCurator ecc=mock(EntitlementCertificateCurator.class);
  UeberCertificateGenerator ucg=mock(UeberCertificateGenerator.class);
  OwnerResource resource=new OwnerResource(oc,null,cc,null,i18n,null,null,null,null,null,cpm,null,null,null,null,null,ecc,ec,ucg,null,null,null,null,null,null,null,null,null);
  try {
    when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
    when(cc.findByName(eq(owner),eq(Consumer.UEBER_CERT_CONSUMER))).thenReturn(null);
    when(ucg.generate(eq(owner),eq(principal))).thenReturn(entCert);
  }
 catch (  EntitlementRefusedException ere) {
  }
  EntitlementCertificate result=resource.createUeberCertificate(principal,""String_Node_Str"");
  assertEquals(entCert,result);
}"
49340,"@Test public void getAllEntitlementsForOwner(){
  PageRequest req=new PageRequest();
  req.setPage(1);
  req.setPerPage(10);
  Owner owner=TestUtil.createOwner();
  Consumer consumer=TestUtil.createConsumer(owner);
  Pool pool=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Entitlement e=TestUtil.createEntitlement(owner,consumer,pool,null);
  e.setId(""String_Node_Str"");
  List<Entitlement> entitlements=new ArrayList<Entitlement>();
  entitlements.add(e);
  Page<List<Entitlement>> page=new Page<List<Entitlement>>();
  page.setPageData(entitlements);
  OwnerCurator oc=mock(OwnerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  OwnerResource ownerres=new OwnerResource(oc,null,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,ec,null,null,null,null,null,null,null,null,null);
  when(oc.lookupByKey(owner.getKey())).thenReturn(owner);
  when(ec.listByOwner(isA(Owner.class),anyString(),isA(EntitlementFilterBuilder.class),isA(PageRequest.class))).thenReturn(page);
  List<Entitlement> result=ownerres.ownerEntitlements(owner.getKey(),null,null,null,req);
  assertEquals(1,result.size());
  assertEquals(""String_Node_Str"",result.get(0).getId());
}","@Test public void getAllEntitlementsForOwner(){
  PageRequest req=new PageRequest();
  req.setPage(1);
  req.setPerPage(10);
  Owner owner=TestUtil.createOwner();
  Consumer consumer=TestUtil.createConsumer(owner);
  Pool pool=TestUtil.createPool(owner,TestUtil.createProduct(owner));
  Entitlement e=TestUtil.createEntitlement(owner,consumer,pool,null);
  e.setId(""String_Node_Str"");
  List<Entitlement> entitlements=new ArrayList<Entitlement>();
  entitlements.add(e);
  Page<List<Entitlement>> page=new Page<List<Entitlement>>();
  page.setPageData(entitlements);
  OwnerCurator oc=mock(OwnerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  OwnerResource ownerres=new OwnerResource(oc,null,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,ec,null,null,null,null,null,null,null,null,null,null);
  when(oc.lookupByKey(owner.getKey())).thenReturn(owner);
  when(ec.listByOwner(isA(Owner.class),anyString(),isA(EntitlementFilterBuilder.class),isA(PageRequest.class))).thenReturn(page);
  List<Entitlement> result=ownerres.ownerEntitlements(owner.getKey(),null,null,null,req);
  assertEquals(1,result.size());
  assertEquals(""String_Node_Str"",result.get(0).getId());
}"
49341,"@Test(expected=BadRequestException.class) public void testActivationKeyNameUnique(){
  ActivationKey ak=mock(ActivationKey.class);
  ActivationKey akOld=mock(ActivationKey.class);
  ActivationKeyCurator akc=mock(ActivationKeyCurator.class);
  Owner o=mock(Owner.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  when(ak.getName()).thenReturn(""String_Node_Str"");
  when(akc.lookupForOwner(eq(""String_Node_Str""),eq(o))).thenReturn(akOld);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(o);
  OwnerResource or=new OwnerResource(oc,akc,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  or.createActivationKey(""String_Node_Str"",ak);
}","@Test(expected=BadRequestException.class) public void testActivationKeyNameUnique(){
  ActivationKey ak=mock(ActivationKey.class);
  ActivationKey akOld=mock(ActivationKey.class);
  ActivationKeyCurator akc=mock(ActivationKeyCurator.class);
  Owner o=mock(Owner.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  when(ak.getName()).thenReturn(""String_Node_Str"");
  when(akc.lookupForOwner(eq(""String_Node_Str""),eq(o))).thenReturn(akOld);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(o);
  OwnerResource or=new OwnerResource(oc,akc,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null,null);
  or.createActivationKey(""String_Node_Str"",ak);
}"
49342,"@Test public void testImportRecordSuccessWithFilename() throws IOException, ImporterException {
  Importer importer=mock(Importer.class);
  EventSink es=mock(EventSink.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,null,null,null,i18n,es,null,null,null,importer,null,null,null,importRecordCurator,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  MultipartInput input=mock(MultipartInput.class);
  InputPart part=mock(InputPart.class);
  File archive=mock(File.class);
  List<InputPart> parts=new ArrayList<InputPart>();
  parts.add(part);
  MultivaluedMap<String,String> mm=new MultivaluedMapImpl<String,String>();
  List<String> contDis=new ArrayList<String>();
  contDis.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",contDis);
  when(input.getParts()).thenReturn(parts);
  when(part.getHeaders()).thenReturn(mm);
  when(part.getBody(any(GenericType.class))).thenReturn(archive);
  when(importer.loadExport(eq(owner),any(File.class),any(ConflictOverrides.class))).thenReturn(new HashMap<String,Object>());
  thisOwnerResource.importManifest(owner.getKey(),new String[]{},input);
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  ImportRecord ir=records.get(0);
  assertEquals(""String_Node_Str"",ir.getFileName());
  assertEquals(owner,ir.getOwner());
  assertEquals(ImportRecord.Status.SUCCESS,ir.getStatus());
}","@Test public void testImportRecordSuccessWithFilename() throws IOException, ImporterException {
  Importer importer=mock(Importer.class);
  EventSink es=mock(EventSink.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,null,null,null,i18n,es,null,null,null,importer,null,null,null,importRecordCurator,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null,null);
  MultipartInput input=mock(MultipartInput.class);
  InputPart part=mock(InputPart.class);
  File archive=mock(File.class);
  List<InputPart> parts=new ArrayList<InputPart>();
  parts.add(part);
  MultivaluedMap<String,String> mm=new MultivaluedMapImpl<String,String>();
  List<String> contDis=new ArrayList<String>();
  contDis.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",contDis);
  when(input.getParts()).thenReturn(parts);
  when(part.getHeaders()).thenReturn(mm);
  when(part.getBody(any(GenericType.class))).thenReturn(archive);
  when(importer.loadExport(eq(owner),any(File.class),any(ConflictOverrides.class))).thenReturn(new HashMap<String,Object>());
  thisOwnerResource.importManifest(owner.getKey(),new String[]{},input);
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  ImportRecord ir=records.get(0);
  assertEquals(""String_Node_Str"",ir.getFileName());
  assertEquals(owner,ir.getOwner());
  assertEquals(ImportRecord.Status.SUCCESS,ir.getStatus());
}"
49343,"@Test public void testCreateUeberCertificateRegenerateWithNoEntitlement(){
  Principal principal=setupPrincipal(owner,Access.ALL);
  Owner owner=TestUtil.createOwner();
  Consumer consumer=TestUtil.createConsumer(owner);
  Entitlement ent=mock(Entitlement.class);
  List<Entitlement> entList=new LinkedList<Entitlement>();
  EntitlementCertificate entCert=mock(EntitlementCertificate.class);
  List<EntitlementCertificate> ecList=Arrays.asList(entCert);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerCurator cc=mock(ConsumerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  CandlepinPoolManager cpm=mock(CandlepinPoolManager.class);
  EntitlementCertificateCurator ecc=mock(EntitlementCertificateCurator.class);
  UeberCertificateGenerator ucg=mock(UeberCertificateGenerator.class);
  OwnerResource resource=new OwnerResource(oc,null,cc,null,i18n,null,null,null,null,null,cpm,null,null,null,null,null,ecc,ec,ucg,null,null,null,null,null,null,null,null);
  try {
    when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
    when(cc.findByName(eq(owner),eq(Consumer.UEBER_CERT_CONSUMER))).thenReturn(consumer);
    when(ec.listByConsumer(eq(consumer))).thenReturn(entList);
    when(ucg.generate(eq(owner),eq(principal))).thenReturn(entCert);
  }
 catch (  EntitlementRefusedException ere) {
  }
  EntitlementCertificate result=resource.createUeberCertificate(principal,""String_Node_Str"");
  assertEquals(entCert,result);
}","@Test public void testCreateUeberCertificateRegenerateWithNoEntitlement(){
  Principal principal=setupPrincipal(owner,Access.ALL);
  Owner owner=TestUtil.createOwner();
  Consumer consumer=TestUtil.createConsumer(owner);
  Entitlement ent=mock(Entitlement.class);
  List<Entitlement> entList=new LinkedList<Entitlement>();
  EntitlementCertificate entCert=mock(EntitlementCertificate.class);
  List<EntitlementCertificate> ecList=Arrays.asList(entCert);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerCurator cc=mock(ConsumerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  CandlepinPoolManager cpm=mock(CandlepinPoolManager.class);
  EntitlementCertificateCurator ecc=mock(EntitlementCertificateCurator.class);
  UeberCertificateGenerator ucg=mock(UeberCertificateGenerator.class);
  OwnerResource resource=new OwnerResource(oc,null,cc,null,i18n,null,null,null,null,null,cpm,null,null,null,null,null,ecc,ec,ucg,null,null,null,null,null,null,null,null,null);
  try {
    when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
    when(cc.findByName(eq(owner),eq(Consumer.UEBER_CERT_CONSUMER))).thenReturn(consumer);
    when(ec.listByConsumer(eq(consumer))).thenReturn(entList);
    when(ucg.generate(eq(owner),eq(principal))).thenReturn(entCert);
  }
 catch (  EntitlementRefusedException ere) {
  }
  EntitlementCertificate result=resource.createUeberCertificate(principal,""String_Node_Str"");
  assertEquals(entCert,result);
}"
49344,"@Test(expected=NotFoundException.class) public void testCreateUeberCertificateInvalidOwner(){
  Principal principal=setupPrincipal(owner,Access.ALL);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerCurator cc=mock(ConsumerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  CandlepinPoolManager cpm=mock(CandlepinPoolManager.class);
  EntitlementCertificateCurator ecc=mock(EntitlementCertificateCurator.class);
  UeberCertificateGenerator ucg=mock(UeberCertificateGenerator.class);
  OwnerResource resource=new OwnerResource(oc,null,cc,null,i18n,null,null,null,null,null,cpm,null,null,null,null,null,ecc,ec,ucg,null,null,null,null,null,null,null,null);
  EntitlementCertificate result=resource.createUeberCertificate(principal,""String_Node_Str"");
}","@Test(expected=NotFoundException.class) public void testCreateUeberCertificateInvalidOwner(){
  Principal principal=setupPrincipal(owner,Access.ALL);
  OwnerCurator oc=mock(OwnerCurator.class);
  ConsumerCurator cc=mock(ConsumerCurator.class);
  EntitlementCurator ec=mock(EntitlementCurator.class);
  CandlepinPoolManager cpm=mock(CandlepinPoolManager.class);
  EntitlementCertificateCurator ecc=mock(EntitlementCertificateCurator.class);
  UeberCertificateGenerator ucg=mock(UeberCertificateGenerator.class);
  OwnerResource resource=new OwnerResource(oc,null,cc,null,i18n,null,null,null,null,null,cpm,null,null,null,null,null,ecc,ec,ucg,null,null,null,null,null,null,null,null,null);
  EntitlementCertificate result=resource.createUeberCertificate(principal,""String_Node_Str"");
}"
49345,"@Test(expected=NotFoundException.class) public void getEntitlementsForNonExistantOwner(){
  PageRequest req=new PageRequest();
  req.setPage(1);
  req.setPerPage(10);
  OwnerCurator oc=mock(OwnerCurator.class);
  OwnerResource ownerres=new OwnerResource(oc,null,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null);
  ownerres.ownerEntitlements(""String_Node_Str"",null,null,null,req);
}","@Test(expected=NotFoundException.class) public void getEntitlementsForNonExistantOwner(){
  PageRequest req=new PageRequest();
  req.setPage(1);
  req.setPerPage(10);
  OwnerCurator oc=mock(OwnerCurator.class);
  OwnerResource ownerres=new OwnerResource(oc,null,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null);
  ownerres.ownerEntitlements(""String_Node_Str"",null,null,null,req);
}"
49346,"@Before public void setUp(){
  owner=ownerCurator.create(new Owner(OWNER_NAME));
  Role ownerAdminRole=createAdminRole(owner);
  roleCurator.create(ownerAdminRole);
  User user=new User(""String_Node_Str"",""String_Node_Str"");
  principal=new UserPrincipal(""String_Node_Str"",new ArrayList<Permission>(permFactory.createPermissions(user,ownerAdminRole.getPermissions())),false);
  setupPrincipal(principal);
  ConsumerType ueberCertType=new ConsumerType(ConsumerTypeEnum.UEBER_CERT);
  consumerTypeCurator.create(ueberCertType);
  or=new OwnerResource(ownerCurator,null,consumerCurator,null,i18n,null,null,null,null,null,poolManager,null,null,null,null,consumerTypeCurator,entCertCurator,entitlementCurator,ueberCertGenerator,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
}","@Before public void setUp(){
  owner=ownerCurator.create(new Owner(OWNER_NAME));
  Role ownerAdminRole=createAdminRole(owner);
  roleCurator.create(ownerAdminRole);
  User user=new User(""String_Node_Str"",""String_Node_Str"");
  principal=new UserPrincipal(""String_Node_Str"",new ArrayList<Permission>(permFactory.createPermissions(user,ownerAdminRole.getPermissions())),false);
  setupPrincipal(principal);
  ConsumerType ueberCertType=new ConsumerType(ConsumerTypeEnum.UEBER_CERT);
  consumerTypeCurator.create(ueberCertType);
  or=new OwnerResource(ownerCurator,null,consumerCurator,null,i18n,null,null,null,null,null,poolManager,null,null,null,null,consumerTypeCurator,entCertCurator,entitlementCurator,ueberCertGenerator,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null,null);
}"
49347,"public List<PoolUpdate> updatePools(Subscription sub,List<Pool> existingPools,Set<Product> changedProducts){
  log.debug(""String_Node_Str"" + sub);
  log.debug(""String_Node_Str"" + existingPools.size());
  PoolHelper helper=new PoolHelper(this.poolManager,null);
  List<PoolUpdate> poolsUpdated=new LinkedList<PoolUpdate>();
  Map<String,String> attributes=helper.getFlattenedAttributes(sub.getProduct());
  for (  Pool existingPool : existingPools) {
    log.debug(""String_Node_Str"" + existingPool.getId());
    if (""String_Node_Str"".equalsIgnoreCase(existingPool.getSubscriptionSubKey())) {
      existingPool.setUpstreamPoolId(sub.getUpstreamPoolId());
      existingPool.setUpstreamEntitlementId(sub.getUpstreamEntitlementId());
      existingPool.setUpstreamConsumerId(sub.getUpstreamConsumerId());
      existingPool.setCdn(sub.getCdn());
      existingPool.setCertificate(sub.getCertificate());
    }
    PoolUpdate update=new PoolUpdate(existingPool);
    update.setDatesChanged(checkForDateChange(sub.getStartDate(),sub.getEndDate(),existingPool));
    update.setQuantityChanged(checkForQuantityChange(sub,existingPool,existingPools,attributes));
    if (!existingPool.isMarkedForDelete()) {
      boolean useDerived=BooleanUtils.toBoolean(existingPool.getAttributeValue(""String_Node_Str"")) && sub.getDerivedProduct() != null;
      update.setProductsChanged(checkForChangedProducts(sub.getProduct(),getExpectedProvidedProducts(sub,existingPool,useDerived),existingPool,changedProducts));
      if (!useDerived) {
        update.setDerivedProductsChanged(checkForChangedDerivedProducts(sub,existingPool,changedProducts));
      }
      update.setOrderChanged(checkForOrderDataChanges(sub,helper,existingPool));
      update.setBrandingChanged(checkForBrandingChanges(sub,existingPool));
    }
    if (update.changed()) {
      poolsUpdated.add(update);
    }
 else {
      log.debug(""String_Node_Str"");
    }
  }
  return poolsUpdated;
}","public List<PoolUpdate> updatePools(Subscription sub,List<Pool> existingPools,Set<Product> changedProducts){
  log.debug(""String_Node_Str"" + sub);
  log.debug(""String_Node_Str"" + existingPools.size());
  PoolHelper helper=new PoolHelper(this.poolManager,null);
  List<PoolUpdate> poolsUpdated=new LinkedList<PoolUpdate>();
  Map<String,String> attributes=helper.getFlattenedAttributes(sub.getProduct());
  for (  Pool existingPool : existingPools) {
    log.debug(""String_Node_Str"" + existingPool.getId());
    if (""String_Node_Str"".equalsIgnoreCase(existingPool.getSubscriptionSubKey())) {
      existingPool.setUpstreamPoolId(sub.getUpstreamPoolId());
      existingPool.setUpstreamEntitlementId(sub.getUpstreamEntitlementId());
      existingPool.setUpstreamConsumerId(sub.getUpstreamConsumerId());
      existingPool.setCdn(sub.getCdn());
      existingPool.setCertificate(sub.getCertificate());
    }
    PoolUpdate update=new PoolUpdate(existingPool);
    update.setDatesChanged(checkForDateChange(sub.getStartDate(),sub.getEndDate(),existingPool));
    update.setQuantityChanged(checkForQuantityChange(sub,existingPool,existingPools,attributes));
    if (!existingPool.isMarkedForDelete()) {
      boolean useDerived=BooleanUtils.toBoolean(existingPool.getAttributeValue(""String_Node_Str"")) && sub.getDerivedProduct() != null;
      update.setProductsChanged(checkForChangedProducts(useDerived ? sub.getDerivedProduct() : sub.getProduct(),getExpectedProvidedProducts(sub,existingPool,useDerived),existingPool,changedProducts));
      if (!useDerived) {
        update.setDerivedProductsChanged(checkForChangedDerivedProducts(sub,existingPool,changedProducts));
      }
      update.setOrderChanged(checkForOrderDataChanges(sub,helper,existingPool));
      update.setBrandingChanged(checkForBrandingChanges(sub,existingPool));
    }
    if (update.changed()) {
      poolsUpdated.add(update);
    }
 else {
      log.debug(""String_Node_Str"");
    }
  }
  return poolsUpdated;
}"
49348,"void refreshPoolsWithRegeneration(SubscriptionServiceAdapter subAdapter,Owner owner,boolean lazy){
  long start=System.currentTimeMillis();
  log.info(""String_Node_Str"",owner);
  List<Subscription> subs=subAdapter.getSubscriptions(owner);
  log.debug(""String_Node_Str"",subs.size());
  SubscriptionReconciler reconciler=new SubscriptionReconciler();
  reconciler.reconcile(owner,subs,poolCurator);
  Set<String> subIds=Util.newSet();
  Set<Content> changedContent=refreshContent(owner,subs);
  Set<Product> changedProducts=refreshProducts(owner,subs);
  List<String> deletedSubs=new LinkedList<String>();
  for (  Subscription sub : subs) {
    String subId=sub.getId();
    subIds.add(subId);
    log.debug(""String_Node_Str"",sub);
    if (isExpired(sub)) {
      deletedSubs.add(subId);
      log.info(""String_Node_Str"",sub);
      continue;
    }
    refreshPoolsForSubscription(sub,lazy,changedProducts);
  }
  subIds.removeAll(deletedSubs);
  for (  Pool pool : poolCurator.getPoolsFromBadSubs(owner,subIds)) {
    if (pool.getSourceSubscription() != null && !pool.getType().isDerivedType()) {
      deletePool(pool);
    }
  }
  List<Pool> floatingPools=poolCurator.getOwnersFloatingPools(owner);
  updateFloatingPools(floatingPools,lazy,changedProducts);
  log.info(""String_Node_Str"",owner.getKey(),System.currentTimeMillis() - start);
}","void refreshPoolsWithRegeneration(SubscriptionServiceAdapter subAdapter,Owner owner,boolean lazy){
  long start=System.currentTimeMillis();
  log.info(""String_Node_Str"",owner);
  List<Subscription> subs=subAdapter.getSubscriptions(owner);
  log.debug(""String_Node_Str"",subs.size());
  SubscriptionReconciler reconciler=new SubscriptionReconciler();
  reconciler.reconcile(owner,subs,poolCurator);
  Set<String> subIds=Util.newSet();
  Set<Content> changedContent=refreshContent(owner,subs);
  Set<Product> changedProducts=refreshProducts(owner,subs);
  List<String> deletedSubs=new LinkedList<String>();
  for (  Subscription sub : subs) {
    String subId=sub.getId();
    subIds.add(subId);
    log.debug(""String_Node_Str"",sub);
    if (isExpired(sub)) {
      deletedSubs.add(subId);
      log.info(""String_Node_Str"",sub);
      continue;
    }
    refreshPoolsForSubscription(sub,lazy,changedProducts);
  }
  Pool ueberPool=this.findUeberPool(owner);
  String ueberPoolId=ueberPool != null ? ueberPool.getId() : null;
  subIds.removeAll(deletedSubs);
  for (  Pool pool : poolCurator.getPoolsFromBadSubs(owner,subIds)) {
    if (pool.getSourceSubscription() != null && !pool.getType().isDerivedType() && (ueberPoolId == null || !ueberPoolId.equals(pool.getId()))) {
      deletePool(pool);
    }
  }
  List<Pool> floatingPools=poolCurator.getOwnersFloatingPools(owner);
  updateFloatingPools(floatingPools,lazy,changedProducts);
  log.info(""String_Node_Str"",owner.getKey(),System.currentTimeMillis() - start);
}"
49349,"/** 
 * Creates an Ueber Entitlement Certificate
 * @return an EntitlementCertificate object
 * @httpcode 400
 * @httpcode 404
 * @httpcode 200
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public EntitlementCertificate createUeberCertificate(@Context Principal principal,@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey){
  Owner o=findOwner(ownerKey);
  if (o == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",ownerKey));
  }
  Consumer ueberConsumer=consumerCurator.findByName(o,Consumer.UEBER_CERT_CONSUMER);
  if (ueberConsumer != null) {
    List<Entitlement> ueberEntitlement=entitlementCurator.listByConsumer(ueberConsumer);
    poolManager.regenerateCertificatesOf(ueberEntitlement.get(0),true,false);
    return entitlementCertCurator.listForConsumer(ueberConsumer).get(0);
  }
  try {
    return ueberCertGenerator.generate(o,principal);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + o.getKey(),e);
    throw new BadRequestException(i18n.tr(""String_Node_Str"",e));
  }
}","/** 
 * Creates an Ueber Entitlement Certificate
 * @return an EntitlementCertificate object
 * @httpcode 400
 * @httpcode 404
 * @httpcode 200
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public EntitlementCertificate createUeberCertificate(@Context Principal principal,@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey){
  Owner o=findOwner(ownerKey);
  if (o == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",ownerKey));
  }
  try {
    Consumer ueberConsumer=consumerCurator.findByName(o,Consumer.UEBER_CERT_CONSUMER);
    if (ueberConsumer != null) {
      List<Entitlement> ueberEntitlements=entitlementCurator.listByConsumer(ueberConsumer);
      if (ueberEntitlements.size() > 0) {
        poolManager.regenerateCertificatesOf(ueberEntitlements.get(0),true,false);
        return entitlementCertCurator.listForConsumer(ueberConsumer).get(0);
      }
    }
    return ueberCertGenerator.generate(o,principal);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + o.getKey(),e);
    throw new BadRequestException(i18n.tr(""String_Node_Str"",e));
  }
}"
49350,"/** 
 * Creates a   {@link JobDetail} that runs this job for the given {@link Owner}.
 * @param owner the owner to refresh
 * @return a {@link JobDetail} that describes the job run
 */
public static JobDetail forOwner(Owner owner,String data,Boolean create,Principal principal){
  JobDataMap map=new JobDataMap();
  map.put(JobStatus.TARGET_TYPE,JobStatus.TargetType.OWNER);
  map.put(JobStatus.TARGET_ID,owner.getKey());
  map.put(CREATE,create);
  map.put(DATA,compress(data));
  map.put(PRINCIPAL,principal);
  JobDetail detail=newJob(HypervisorUpdateJob.class).withIdentity(prefix + Util.generateUUID()).requestRecovery(true).usingJobData(map).storeDurably(true).build();
  return detail;
}","/** 
 * Creates a   {@link JobDetail} that runs this job for the given {@link Owner}.
 * @param owner the owner to refresh
 * @return a {@link JobDetail} that describes the job run
 */
public static JobDetail forOwner(Owner owner,String data,Boolean create,Principal principal){
  JobDataMap map=new JobDataMap();
  map.put(JobStatus.TARGET_TYPE,JobStatus.TargetType.OWNER);
  map.put(JobStatus.TARGET_ID,owner.getKey());
  map.put(JobStatus.OWNER_ID,owner.getKey());
  map.put(CREATE,create);
  map.put(DATA,compress(data));
  map.put(PRINCIPAL,principal);
  JobDetail detail=newJob(HypervisorUpdateJob.class).withIdentity(prefix + Util.generateUUID()).requestRecovery(true).usingJobData(map).storeDurably(true).build();
  return detail;
}"
49351,"/** 
 * Migrates pool data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate pool data
 */
private void migratePoolData(String orgid) throws DatabaseException, SQLException {
}","/** 
 * Migrates pool data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate pool data
 */
private void migratePoolData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet pools=this.executeQuery(""String_Node_Str"",orgid);
  while (pools.next()) {
    String poolid=pools.getString(1);
    ResultSet sourcesub=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",poolid);
    while (sourcesub.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),sourcesub.getString(2),sourcesub.getString(3),poolid,sourcesub.getTimestamp(5),sourcesub.getTimestamp(6));
    }
    sourcesub.close();
  }
  pools.close();
}"
49352,"/** 
 * Migrates subscription data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate subscription data
 */
@SuppressWarnings(""String_Node_Str"") private void migrateSubscriptionData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet subscriptiondata=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",orgid);
  while (subscriptiondata.next()) {
    String subid=subscriptiondata.getString(1);
    String upstreamEntitlementId=subscriptiondata.getString(4);
    String upstreamConsumerId=subscriptiondata.getString(5);
    String upstreamPoolId=subscriptiondata.getString(6);
    if (upstreamEntitlementId == null || upstreamConsumerId == null || upstreamPoolId == null) {
      int count=this.executeUpdate(""String_Node_Str"",subid);
      if (count == 0) {
        this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",this.generateUUID(),true,subid);
      }
    }
 else {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subscriptiondata.getString(2),subscriptiondata.getString(3),upstreamEntitlementId,upstreamConsumerId,upstreamPoolId,subid);
    }
    ResultSet sourcesub=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",subid);
    while (sourcesub.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),subid,sourcesub.getString(3),sourcesub.getString(4),sourcesub.getTimestamp(5),sourcesub.getTimestamp(6));
    }
    sourcesub.close();
  }
  subscriptiondata.close();
}","/** 
 * Migrates subscription data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate subscription data
 */
@SuppressWarnings(""String_Node_Str"") private void migrateSubscriptionData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet subscriptiondata=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",orgid);
  while (subscriptiondata.next()) {
    String subid=subscriptiondata.getString(1);
    String upstreamEntitlementId=subscriptiondata.getString(4);
    String upstreamConsumerId=subscriptiondata.getString(5);
    String upstreamPoolId=subscriptiondata.getString(6);
    if (upstreamEntitlementId == null || upstreamConsumerId == null || upstreamPoolId == null) {
      int count=this.executeUpdate(""String_Node_Str"",subid);
      if (count == 0) {
        this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",this.generateUUID(),true,subid);
      }
    }
 else {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subscriptiondata.getString(2),subscriptiondata.getString(3),upstreamEntitlementId,upstreamConsumerId,upstreamPoolId,subid);
    }
  }
  subscriptiondata.close();
}"
49353,"/** 
 * Return a list of subscriptions for the given product. We do essentially 2 queries here, so there is room for optimization both in speed and memory usage.
 * @param product product to search for.
 * @return a list of subscriptions
 */
@SuppressWarnings(""String_Node_Str"") public List<Subscription> listByProduct(Product product){
  Criteria subscriptionCriteria=currentSession().createCriteria(Subscription.class).createAlias(""String_Node_Str"",""String_Node_Str"",CriteriaSpecification.LEFT_JOIN).add(Restrictions.or(Restrictions.eq(""String_Node_Str"",product),Restrictions.eq(""String_Node_Str"",product.getId())));
  List<Subscription> subs=subscriptionCriteria.list();
  if (subs == null) {
    return new LinkedList<Subscription>();
  }
  return subs;
}","/** 
 * Return a list of subscriptions for the given product. We do essentially 2 queries here, so there is room for optimization both in speed and memory usage.
 * @param product product to search for.
 * @return a list of subscriptions
 */
@SuppressWarnings(""String_Node_Str"") public List<Subscription> listByProduct(Product product){
  String hql=""String_Node_Str"" + ""String_Node_Str"";
  Query query=currentSession().createQuery(hql);
  query.setParameter(""String_Node_Str"",product.getId());
  List<Subscription> subs=query.list();
  if (subs == null) {
    return new LinkedList<Subscription>();
  }
  return subs;
}"
49354,"@Test public void testLookupSubscriptionByProductMixedMainAndProvidedProduct(){
  Owner owner=createOwner();
  Product product=TestUtil.createProduct();
  Product product2=TestUtil.createProduct();
  Product product3=TestUtil.createProduct();
  productCurator.create(product);
  productCurator.create(product2);
  productCurator.create(product3);
  Set<Product> providedProducts=new HashSet<Product>();
  providedProducts.add(product);
  Subscription sub=TestUtil.createSubscription(owner,product2,providedProducts);
  adapter.createSubscription(sub);
  Set<Product> providedProducts2=new HashSet<Product>();
  providedProducts2.add(product3);
  Subscription sub2=TestUtil.createSubscription(owner,product,providedProducts2);
  adapter.createSubscription(sub2);
  List<Subscription> results=adapter.getSubscriptions(product);
  assertEquals(2,results.size());
  assertTrue(results.contains(sub));
  assertTrue(results.contains(sub2));
}","@Test public void testLookupSubscriptionByProductMixedMainAndProvidedProduct(){
  Owner owner=createOwner();
  Product product=TestUtil.createProduct();
  Product product2=TestUtil.createProduct();
  Product product3=TestUtil.createProduct();
  Product product4=TestUtil.createProduct();
  Product product5=TestUtil.createProduct();
  productCurator.create(product);
  productCurator.create(product2);
  productCurator.create(product3);
  productCurator.create(product4);
  productCurator.create(product5);
  Set<Product> providedProducts=new HashSet<Product>();
  providedProducts.add(product);
  providedProducts.add(product4);
  providedProducts.add(product5);
  Subscription sub=TestUtil.createSubscription(owner,product2,providedProducts);
  adapter.createSubscription(sub);
  Set<Product> providedProducts2=new HashSet<Product>();
  providedProducts2.add(product3);
  providedProducts2.add(product5);
  Subscription sub2=TestUtil.createSubscription(owner,product,providedProducts2);
  adapter.createSubscription(sub2);
  subCurator.evict(sub);
  subCurator.evict(sub2);
  List<Subscription> results=adapter.getSubscriptions(product);
  assertEquals(2,results.size());
  assertTrue(results.get(0).getId().equals(sub.getId()) || results.get(0).getId().equals(sub2.getId()));
  assertTrue(results.get(1).getId().equals(sub.getId()) || results.get(1).getId().equals(sub2.getId()));
  if (results.get(0).getId().equals(sub.getId())) {
    sub=results.get(0);
    sub2=results.get(1);
  }
 else {
    sub2=results.get(0);
    sub=results.get(1);
  }
  assertEquals(3,sub.getProvidedProducts().size());
  assertEquals(2,sub2.getProvidedProducts().size());
}"
49355,"/** 
 * Migrates subscription data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate subscription data
 */
private void migrateSubscriptionData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet subscriptiondata=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",orgid);
  while (subscriptiondata.next()) {
    String subid=subscriptiondata.getString(1);
    String subuuid=this.generateUUID();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subscriptiondata.getString(2),subscriptiondata.getString(3),subscriptiondata.getString(4),subscriptiondata.getString(5),subscriptiondata.getString(6),subid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,orgid,orgid,subid);
    ResultSet sourcesub=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",subid);
    while (sourcesub.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),subuuid,sourcesub.getString(3),sourcesub.getString(4),sourcesub.getDate(5),sourcesub.getDate(6));
    }
    sourcesub.close();
    ResultSet branding=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,subid);
    while (branding.next()) {
      String brandingid=branding.getString(1);
      String brandinguuid=this.generateUUID();
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",brandinguuid,branding.getDate(2),branding.getDate(3),branding.getString(4),branding.getString(5),branding.getString(6));
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",subuuid,brandinguuid);
    }
    branding.close();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
  }
  subscriptiondata.close();
}","/** 
 * Migrates subscription data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate subscription data
 */
private void migrateSubscriptionData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet subscriptiondata=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",orgid);
  while (subscriptiondata.next()) {
    String subid=subscriptiondata.getString(1);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subscriptiondata.getString(2),subscriptiondata.getString(3),subscriptiondata.getString(4),subscriptiondata.getString(5),subscriptiondata.getString(6),subid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subid,orgid,orgid,orgid,subid);
    ResultSet sourcesub=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",subid);
    while (sourcesub.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),subid,sourcesub.getString(3),sourcesub.getString(4),sourcesub.getDate(5),sourcesub.getDate(6));
    }
    sourcesub.close();
    ResultSet branding=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,subid);
    while (branding.next()) {
      String brandingid=branding.getString(1);
      String brandinguuid=this.generateUUID();
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",brandinguuid,branding.getDate(2),branding.getDate(3),branding.getString(4),branding.getString(5),branding.getString(6));
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",subid,brandinguuid);
    }
    branding.close();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subid,orgid,subid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subid,orgid,subid);
  }
  subscriptiondata.close();
}"
49356,"public Set<Product> getChangedProducts(Owner o,Set<Product> allProducts){
  Set<Product> changedProducts=Util.newSet();
  log.debug(""String_Node_Str"",allProducts.size());
  for (  Product incoming : allProducts) {
    Product existing=prodCurator.lookupById(o,incoming.getId());
    if (existing == null) {
      log.info(""String_Node_Str"",o.getKey(),incoming.getId());
      incoming.setOwner(o);
      prodCurator.create(incoming);
    }
 else {
      if (hasProductChanged(existing,incoming)) {
        log.info(""String_Node_Str"",o.getKey(),incoming.getId());
        prodCurator.createOrUpdate(incoming);
        changedProducts.add(incoming);
      }
    }
  }
  return changedProducts;
}","public Set<Product> getChangedProducts(Owner o,Set<Product> allProducts){
  Set<Product> changedProducts=Util.newSet();
  log.debug(""String_Node_Str"",allProducts.size());
  for (  Product incoming : allProducts) {
    log.debug(""String_Node_Str"",incoming.getOwner(),o);
    Product existing=prodCurator.lookupById(o,incoming.getId());
    if (existing == null) {
      log.info(""String_Node_Str"",o.getKey(),incoming.getId());
      incoming.setOwner(o);
      prodCurator.create(incoming);
    }
 else {
      if (hasProductChanged(existing,incoming)) {
        log.info(""String_Node_Str"",o.getKey(),incoming.getId());
        prodCurator.createOrUpdate(incoming);
        changedProducts.add(incoming);
      }
    }
  }
  return changedProducts;
}"
49357,"Set<Product> refreshProducts(Owner o,List<Subscription> subs){
  Set<Product> allProducts=Util.newSet();
  for (  Subscription sub : subs) {
    allProducts.add(sub.getProduct());
    allProducts.addAll(sub.getProvidedProducts());
  }
  return getChangedProducts(o,allProducts);
}","Set<Product> refreshProducts(Owner o,List<Subscription> subs){
  Set<Product> allProducts=Util.newSet();
  for (  Subscription sub : subs) {
    log.debug(""String_Node_Str"",sub.getOwner());
    allProducts.add(sub.getProduct());
    allProducts.addAll(sub.getProvidedProducts());
    allProducts.add(sub.getDerivedProduct());
    allProducts.addAll(sub.getDerivedProvidedProducts());
  }
  return getChangedProducts(o,allProducts);
}"
49358,"void refreshPoolsWithRegeneration(SubscriptionServiceAdapter subAdapter,Owner owner,boolean lazy){
  log.info(""String_Node_Str"" + owner.getKey());
  List<Subscription> subs=subAdapter.getSubscriptions(owner);
  log.debug(""String_Node_Str"" + subs.size() + ""String_Node_Str"");
  SubscriptionReconciler reconciler=new SubscriptionReconciler();
  reconciler.reconcile(owner,subs,poolCurator);
  Set<String> subIds=Util.newSet();
  Set<Product> changedProducts=refreshProducts(owner,subs);
  List<String> deletedSubs=new LinkedList<String>();
  for (  Subscription sub : subs) {
    String subId=sub.getId();
    subIds.add(subId);
    if (isExpired(sub)) {
      deletedSubs.add(subId);
      log.info(""String_Node_Str"" + sub);
      continue;
    }
    refreshPoolsForSubscription(sub,lazy,changedProducts);
  }
  subIds.removeAll(deletedSubs);
  for (  Pool p : poolCurator.getPoolsFromBadSubs(owner,subIds)) {
    if (p.getType() == PoolType.NORMAL || p.getType() == PoolType.BONUS) {
      deletePool(p);
    }
  }
  List<Pool> floatingPools=poolCurator.getOwnersFloatingPools(owner);
  updateFloatingPools(subAdapter,floatingPools,lazy,changedProducts);
}","void refreshPoolsWithRegeneration(SubscriptionServiceAdapter subAdapter,Owner owner,boolean lazy){
  log.info(""String_Node_Str"",owner);
  List<Subscription> subs=subAdapter.getSubscriptions(owner);
  log.debug(""String_Node_Str"" + subs.size() + ""String_Node_Str"");
  SubscriptionReconciler reconciler=new SubscriptionReconciler();
  reconciler.reconcile(owner,subs,poolCurator);
  Set<String> subIds=Util.newSet();
  Set<Product> changedProducts=refreshProducts(owner,subs);
  List<String> deletedSubs=new LinkedList<String>();
  for (  Subscription sub : subs) {
    String subId=sub.getId();
    subIds.add(subId);
    if (isExpired(sub)) {
      deletedSubs.add(subId);
      log.info(""String_Node_Str"" + sub);
      continue;
    }
    refreshPoolsForSubscription(sub,lazy,changedProducts);
  }
  subIds.removeAll(deletedSubs);
  for (  Pool p : poolCurator.getPoolsFromBadSubs(owner,subIds)) {
    if (p.getType() == PoolType.NORMAL || p.getType() == PoolType.BONUS) {
      deletePool(p);
    }
  }
  List<Pool> floatingPools=poolCurator.getOwnersFloatingPools(owner);
  updateFloatingPools(subAdapter,floatingPools,lazy,changedProducts);
}"
49359,"public Subscription importObject(ObjectMapper mapper,Reader reader,Owner owner,Map<String,Product> productsById,ConsumerDto consumer,Meta meta) throws IOException, SyncDataFormatException {
  Entitlement entitlement=mapper.readValue(reader,Entitlement.class);
  Subscription subscription=new Subscription();
  subscription.setId(Util.generateDbUUID());
  subscription.setUpstreamPoolId(entitlement.getPool().getId());
  subscription.setUpstreamEntitlementId(entitlement.getId());
  subscription.setUpstreamConsumerId(consumer.getUuid());
  subscription.setOwner(owner);
  subscription.setStartDate(entitlement.getStartDate());
  subscription.setEndDate(entitlement.getEndDate());
  subscription.setAccountNumber(entitlement.getPool().getAccountNumber());
  subscription.setContractNumber(entitlement.getPool().getContractNumber());
  subscription.setOrderNumber(entitlement.getPool().getOrderNumber());
  subscription.setQuantity(entitlement.getQuantity().longValue());
  for (  Branding b : entitlement.getPool().getBranding()) {
    subscription.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
  }
  subscription.setProduct(findProduct(productsById,entitlement.getProductId()));
  String cdnLabel=meta.getCdnLabel();
  if (!StringUtils.isBlank(cdnLabel)) {
    Cdn cdn=cdnCurator.lookupByLabel(cdnLabel);
    if (cdn != null) {
      subscription.setCdn(cdn);
    }
  }
  Set<Product> products=new HashSet<Product>();
  for (  Product providedProduct : entitlement.getPool().getProvidedProducts()) {
    products.add(findProduct(productsById,providedProduct.getId()));
  }
  subscription.setProvidedProducts(products);
  if (entitlement.getPool().getDerivedProduct() != null) {
    subscription.setDerivedProduct(findProduct(productsById,entitlement.getPool().getDerivedProduct().getId()));
  }
  Set<Product> subProvProds=new HashSet<Product>();
  for (  Product subProvProd : entitlement.getPool().getDerivedProvidedProducts()) {
    subProvProds.add(findProduct(productsById,subProvProd.getId()));
  }
  subscription.setDerivedProvidedProducts(subProvProds);
  Set<EntitlementCertificate> certs=entitlement.getCertificates();
  int entcnt=0;
  for (  EntitlementCertificate cert : certs) {
    entcnt++;
    CertificateSerial cs=new CertificateSerial();
    cs.setCollected(cert.getSerial().isCollected());
    cs.setExpiration(cert.getSerial().getExpiration());
    cs.setUpdated(cert.getSerial().getUpdated());
    cs.setCreated(cert.getSerial().getCreated());
    csCurator.create(cs);
    SubscriptionsCertificate sc=new SubscriptionsCertificate();
    sc.setKey(cert.getKey());
    sc.setCertAsBytes(cert.getCertAsBytes());
    sc.setSerial(cs);
    subscription.setCertificate(sc);
  }
  if (entcnt > 1) {
    log.error(""String_Node_Str"");
  }
  return subscription;
}","public Subscription importObject(ObjectMapper mapper,Reader reader,Owner owner,Map<String,Product> productsById,ConsumerDto consumer,Meta meta) throws IOException, SyncDataFormatException {
  Entitlement entitlement=mapper.readValue(reader,Entitlement.class);
  Subscription subscription=new Subscription();
  log.debug(""String_Node_Str"",owner);
  log.debug(""String_Node_Str"",entitlement.getPool());
  log.debug(""String_Node_Str"",entitlement.getPool().getDerivedProduct());
  subscription.setId(Util.generateDbUUID());
  subscription.setUpstreamPoolId(entitlement.getPool().getId());
  subscription.setUpstreamEntitlementId(entitlement.getId());
  subscription.setUpstreamConsumerId(consumer.getUuid());
  subscription.setOwner(owner);
  subscription.setStartDate(entitlement.getStartDate());
  subscription.setEndDate(entitlement.getEndDate());
  subscription.setAccountNumber(entitlement.getPool().getAccountNumber());
  subscription.setContractNumber(entitlement.getPool().getContractNumber());
  subscription.setOrderNumber(entitlement.getPool().getOrderNumber());
  subscription.setQuantity(entitlement.getQuantity().longValue());
  for (  Branding b : entitlement.getPool().getBranding()) {
    subscription.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
  }
  subscription.setProduct(findProduct(productsById,entitlement.getProductId()));
  String cdnLabel=meta.getCdnLabel();
  if (!StringUtils.isBlank(cdnLabel)) {
    Cdn cdn=cdnCurator.lookupByLabel(cdnLabel);
    if (cdn != null) {
      subscription.setCdn(cdn);
    }
  }
  Set<Product> products=new HashSet<Product>();
  for (  Product providedProduct : entitlement.getPool().getProvidedProducts()) {
    products.add(findProduct(productsById,providedProduct.getId()));
  }
  subscription.setProvidedProducts(products);
  if (entitlement.getPool().getDerivedProduct() != null) {
    subscription.setDerivedProduct(findProduct(productsById,entitlement.getPool().getDerivedProduct().getId()));
  }
  Set<Product> subProvProds=new HashSet<Product>();
  for (  Product subProvProd : entitlement.getPool().getDerivedProvidedProducts()) {
    subProvProds.add(findProduct(productsById,subProvProd.getId()));
  }
  subscription.setDerivedProvidedProducts(subProvProds);
  Set<EntitlementCertificate> certs=entitlement.getCertificates();
  int entcnt=0;
  for (  EntitlementCertificate cert : certs) {
    entcnt++;
    CertificateSerial cs=new CertificateSerial();
    cs.setCollected(cert.getSerial().isCollected());
    cs.setExpiration(cert.getSerial().getExpiration());
    cs.setUpdated(cert.getSerial().getUpdated());
    cs.setCreated(cert.getSerial().getCreated());
    csCurator.create(cs);
    SubscriptionsCertificate sc=new SubscriptionsCertificate();
    sc.setKey(cert.getKey());
    sc.setCertAsBytes(cert.getCertAsBytes());
    sc.setSerial(cs);
    subscription.setCertificate(sc);
  }
  if (entcnt > 1) {
    log.error(""String_Node_Str"");
  }
  return subscription;
}"
49360,"@Transactional(rollbackOn={IOException.class,ImporterException.class,RuntimeException.class,ImportConflictException.class}) ConsumerDto importObjects(Owner owner,Map<String,File> importFiles,ConflictOverrides overrides) throws IOException, ImporterException {
  File metadata=importFiles.get(ImportFile.META.fileName());
  if (metadata == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerTypes=importFiles.get(ImportFile.CONSUMER_TYPE.fileName());
  if (consumerTypes == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerFile=importFiles.get(ImportFile.CONSUMER.fileName());
  if (consumerFile == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File products=importFiles.get(ImportFile.PRODUCTS.fileName());
  File entitlements=importFiles.get(ImportFile.ENTITLEMENTS.fileName());
  if (products != null && entitlements == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  List<ImportConflictException> conflictExceptions=new LinkedList<ImportConflictException>();
  File rules=importFiles.get(ImportFile.RULES_FILE.fileName());
  importRules(rules,metadata);
  importConsumerTypes(consumerTypes.listFiles());
  File distributorVersions=importFiles.get(ImportFile.DISTRIBUTOR_VERSIONS.fileName());
  if (distributorVersions != null) {
    importDistributorVersions(distributorVersions.listFiles());
  }
  File cdns=importFiles.get(ImportFile.CONTENT_DELIVERY_NETWORKS.fileName());
  if (cdns != null) {
    importContentDeliveryNetworks(cdns.listFiles());
  }
  try {
    validateMetadata(ExporterMetadata.TYPE_PER_USER,owner,metadata,overrides);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  ConsumerDto consumer=null;
  try {
    Meta m=mapper.readValue(metadata,Meta.class);
    File upstreamFile=importFiles.get(ImportFile.UPSTREAM_CONSUMER.fileName());
    File[] dafiles=new File[0];
    if (upstreamFile != null) {
      dafiles=upstreamFile.listFiles();
    }
    consumer=importConsumer(owner,consumerFile,dafiles,overrides,m);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  if (!conflictExceptions.isEmpty()) {
    log.error(""String_Node_Str"");
    for (    ImportConflictException e : conflictExceptions) {
      log.error(""String_Node_Str"",e.message().getConflicts());
    }
    throw new ImportConflictException(conflictExceptions);
  }
  Meta meta=mapper.readValue(metadata,Meta.class);
  List<Subscription> importSubs=new ArrayList<Subscription>();
  if (importFiles.get(ImportFile.PRODUCTS.fileName()) != null) {
    ProductImporter importer=new ProductImporter(productCurator,contentCurator);
    Set<Product> productsToImport=importProducts(importFiles.get(ImportFile.PRODUCTS.fileName()).listFiles(),importer);
    importer.store(productsToImport,owner);
    meta=mapper.readValue(metadata,Meta.class);
    importSubs=importEntitlements(owner,productsToImport,entitlements.listFiles(),consumer,meta);
  }
 else {
    log.warn(""String_Node_Str"");
    log.warn(""String_Node_Str"");
    importEntitlements(owner,new HashSet<Product>(),new File[]{},consumer,meta);
  }
  SubscriptionServiceAdapter adapter=new ImportSubscriptionServiceAdapter(importSubs);
  Refresher refresher=poolManager.getRefresher(adapter);
  refresher.add(owner);
  refresher.run();
  return consumer;
}","@Transactional(rollbackOn={IOException.class,ImporterException.class,RuntimeException.class,ImportConflictException.class}) ConsumerDto importObjects(Owner owner,Map<String,File> importFiles,ConflictOverrides overrides) throws IOException, ImporterException {
  log.debug(""String_Node_Str"",owner);
  File metadata=importFiles.get(ImportFile.META.fileName());
  if (metadata == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerTypes=importFiles.get(ImportFile.CONSUMER_TYPE.fileName());
  if (consumerTypes == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerFile=importFiles.get(ImportFile.CONSUMER.fileName());
  if (consumerFile == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File products=importFiles.get(ImportFile.PRODUCTS.fileName());
  File entitlements=importFiles.get(ImportFile.ENTITLEMENTS.fileName());
  if (products != null && entitlements == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  List<ImportConflictException> conflictExceptions=new LinkedList<ImportConflictException>();
  File rules=importFiles.get(ImportFile.RULES_FILE.fileName());
  importRules(rules,metadata);
  importConsumerTypes(consumerTypes.listFiles());
  File distributorVersions=importFiles.get(ImportFile.DISTRIBUTOR_VERSIONS.fileName());
  if (distributorVersions != null) {
    importDistributorVersions(distributorVersions.listFiles());
  }
  File cdns=importFiles.get(ImportFile.CONTENT_DELIVERY_NETWORKS.fileName());
  if (cdns != null) {
    importContentDeliveryNetworks(cdns.listFiles());
  }
  try {
    validateMetadata(ExporterMetadata.TYPE_PER_USER,owner,metadata,overrides);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  ConsumerDto consumer=null;
  try {
    Meta m=mapper.readValue(metadata,Meta.class);
    File upstreamFile=importFiles.get(ImportFile.UPSTREAM_CONSUMER.fileName());
    File[] dafiles=new File[0];
    if (upstreamFile != null) {
      dafiles=upstreamFile.listFiles();
    }
    consumer=importConsumer(owner,consumerFile,dafiles,overrides,m);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  if (!conflictExceptions.isEmpty()) {
    log.error(""String_Node_Str"");
    for (    ImportConflictException e : conflictExceptions) {
      log.error(""String_Node_Str"",e.message().getConflicts());
    }
    throw new ImportConflictException(conflictExceptions);
  }
  Meta meta=mapper.readValue(metadata,Meta.class);
  List<Subscription> importSubs=new ArrayList<Subscription>();
  if (importFiles.get(ImportFile.PRODUCTS.fileName()) != null) {
    ProductImporter importer=new ProductImporter(productCurator,contentCurator);
    Set<Product> productsToImport=importProducts(importFiles.get(ImportFile.PRODUCTS.fileName()).listFiles(),importer);
    importer.store(productsToImport,owner);
    meta=mapper.readValue(metadata,Meta.class);
    importSubs=importEntitlements(owner,productsToImport,entitlements.listFiles(),consumer,meta);
  }
 else {
    log.warn(""String_Node_Str"");
    log.warn(""String_Node_Str"");
    importEntitlements(owner,new HashSet<Product>(),new File[]{},consumer,meta);
  }
  SubscriptionServiceAdapter adapter=new ImportSubscriptionServiceAdapter(importSubs);
  Refresher refresher=poolManager.getRefresher(adapter);
  refresher.add(owner);
  refresher.run();
  return consumer;
}"
49361,"public List<Subscription> importEntitlements(Owner owner,Set<Product> products,File[] entitlements,ConsumerDto consumer,Meta meta) throws IOException, SyncDataFormatException {
  EntitlementImporter importer=new EntitlementImporter(csCurator,cdnCurator,i18n);
  Map<String,Product> productsById=new HashMap<String,Product>();
  for (  Product product : products) {
    productsById.put(product.getId(),product);
  }
  List<Subscription> subscriptionsToImport=new ArrayList<Subscription>();
  for (  File entitlement : entitlements) {
    Reader reader=null;
    try {
      log.debug(""String_Node_Str"" + entitlement.getName());
      reader=new FileReader(entitlement);
      subscriptionsToImport.add(importer.importObject(mapper,reader,owner,productsById,consumer,meta));
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
  return subscriptionsToImport;
}","public List<Subscription> importEntitlements(Owner owner,Set<Product> products,File[] entitlements,ConsumerDto consumer,Meta meta) throws IOException, SyncDataFormatException {
  log.debug(""String_Node_Str"",owner);
  EntitlementImporter importer=new EntitlementImporter(csCurator,cdnCurator,i18n);
  Map<String,Product> productsById=new HashMap<String,Product>();
  for (  Product product : products) {
    log.debug(""String_Node_Str"",owner.getKey());
    productsById.put(product.getId(),product);
  }
  List<Subscription> subscriptionsToImport=new ArrayList<Subscription>();
  for (  File entitlement : entitlements) {
    Reader reader=null;
    try {
      log.debug(""String_Node_Str"" + entitlement.getName());
      reader=new FileReader(entitlement);
      subscriptionsToImport.add(importer.importObject(mapper,reader,owner,productsById,consumer,meta));
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
  return subscriptionsToImport;
}"
49362,"public Product createObject(ObjectMapper mapper,Reader reader) throws IOException {
  final Product importedProduct=mapper.readValue(reader,Product.class);
  for (  ProductAttribute a : importedProduct.getAttributes()) {
    a.setId(null);
  }
  importedProduct.setMultiplier(1L);
  return importedProduct;
}","public Product createObject(ObjectMapper mapper,Reader reader) throws IOException {
  final Product importedProduct=mapper.readValue(reader,Product.class);
  importedProduct.setUuid(null);
  for (  ProductAttribute a : importedProduct.getAttributes()) {
    a.setId(null);
  }
  importedProduct.setOwner(null);
  importedProduct.setMultiplier(1L);
  return importedProduct;
}"
49363,"/** 
 * Migrates pool data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate pool data
 */
private void migratePoolData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet pools=this.executeQuery(""String_Node_Str"",orgid);
  while (pools.next()) {
    String poolid=pools.getString(1);
    ResultSet branding=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,poolid);
    while (branding.next()) {
      String brandingid=branding.getString(1);
      String brandinguuid=this.generateUUID();
      this.logger.info(String.format(""String_Node_Str"" + ""String_Node_Str"",brandingid,brandinguuid,orgid,branding.getString(7)));
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",brandinguuid,branding.getDate(2),branding.getDate(3),branding.getString(4),branding.getString(5),branding.getString(6));
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",poolid,brandinguuid);
    }
    branding.close();
  }
  pools.close();
}","/** 
 * Migrates pool data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate pool data
 */
private void migratePoolData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet pools=this.executeQuery(""String_Node_Str"",orgid);
  while (pools.next()) {
    String poolid=pools.getString(1);
    ResultSet branding=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,poolid);
    while (branding.next()) {
      String brandingid=branding.getString(1);
      String brandinguuid=Util.generateDbUUID();
      this.logger.info(String.format(""String_Node_Str"" + ""String_Node_Str"",brandingid,brandinguuid,orgid,branding.getString(7)));
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",brandinguuid,branding.getDate(2),branding.getDate(3),branding.getString(4),branding.getString(5),branding.getString(6));
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",poolid,brandinguuid);
    }
    branding.close();
  }
  pools.close();
}"
49364,"/** 
 * Migrates subscription data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate subscription data
 */
private void migrateSubscriptionData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet subscriptionids=this.executeQuery(""String_Node_Str"",orgid);
  while (subscriptionids.next()) {
    String subid=subscriptionids.getString(1);
    String subuuid=this.generateUUID();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,orgid,orgid,subid);
    ResultSet sourcesub=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",subid);
    while (sourcesub.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),subuuid,sourcesub.getString(3),sourcesub.getString(4),sourcesub.getDate(5),sourcesub.getDate(6));
    }
    sourcesub.close();
    ResultSet branding=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,subid);
    while (branding.next()) {
      String brandingid=branding.getString(1);
      String brandinguuid=this.generateUUID();
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",brandinguuid,branding.getDate(2),branding.getDate(3),branding.getString(4),branding.getString(5),branding.getString(6));
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",subuuid,brandinguuid);
    }
    branding.close();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
  }
  subscriptionids.close();
}","/** 
 * Migrates subscription data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate subscription data
 */
private void migrateSubscriptionData(String orgid) throws DatabaseException, SQLException {
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet subscriptionids=this.executeQuery(""String_Node_Str"",orgid);
  while (subscriptionids.next()) {
    String subid=subscriptionids.getString(1);
    String subuuid=Util.generateDbUUID();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,orgid,orgid,subid);
    ResultSet sourcesub=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",subid);
    while (sourcesub.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",Util.generateDbUUID(),subuuid,sourcesub.getString(3),sourcesub.getString(4),sourcesub.getDate(5),sourcesub.getDate(6));
    }
    sourcesub.close();
    ResultSet branding=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,subid);
    while (branding.next()) {
      String brandingid=branding.getString(1);
      String brandinguuid=Util.generateDbUUID();
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",brandinguuid,branding.getDate(2),branding.getDate(3),branding.getString(4),branding.getString(5),branding.getString(6));
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"",subuuid,brandinguuid);
    }
    branding.close();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
  }
  subscriptionids.close();
}"
49365,"/** 
 * Migrates product data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate product data
 */
@SuppressWarnings(""String_Node_Str"") private void migrateProductData(String orgid) throws DatabaseException, SQLException {
  Map<String,String> contentCache=new HashMap<String,String>();
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet productids=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,orgid,orgid);
  while (productids.next()) {
    String productid=productids.getString(1);
    String productuuid=this.generateUUID();
    this.logger.info(String.format(""String_Node_Str"",orgid,productid,productuuid));
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,orgid,productid,productid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
    ResultSet attributes=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",productid);
    while (attributes.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),attributes.getDate(2),attributes.getDate(3),attributes.getString(4),attributes.getString(5),productuuid);
    }
    attributes.close();
    ResultSet certificates=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",productid);
    while (certificates.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),certificates.getDate(2),certificates.getDate(3),certificates.getBytes(4),certificates.getBytes(5),productuuid);
    }
    certificates.close();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid,orgid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid,orgid);
    ResultSet contentids=this.executeQuery(""String_Node_Str"",productid);
    while (contentids.next()) {
      String contentid=contentids.getString(1);
      String contentuuid=contentCache.get(contentid);
      if (contentuuid == null) {
        contentuuid=this.generateUUID();
        contentCache.put(contentid,contentuuid);
        this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",contentuuid,orgid,contentid);
        this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",contentuuid,contentid);
        ResultSet content=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",contentid);
        while (content.next()) {
          this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),content.getDate(2),content.getDate(3),contentuuid,content.getBoolean(5),content.getString(6));
        }
        content.close();
      }
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,contentuuid,productid,contentid);
    }
    contentids.close();
  }
  productids.close();
}","/** 
 * Migrates product data. Must be called per-org.
 * @param orgid The id of the owner/organization for which to migrate product data
 */
@SuppressWarnings(""String_Node_Str"") private void migrateProductData(String orgid) throws DatabaseException, SQLException {
  Map<String,String> contentCache=new HashMap<String,String>();
  this.logger.info(""String_Node_Str"" + orgid);
  ResultSet productids=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",orgid,orgid,orgid);
  while (productids.next()) {
    String productid=productids.getString(1);
    String productuuid=Util.generateDbUUID();
    this.logger.info(String.format(""String_Node_Str"",orgid,productid,productuuid));
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,orgid,productid,productid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
    ResultSet attributes=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",productid);
    while (attributes.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",Util.generateDbUUID(),attributes.getDate(2),attributes.getDate(3),attributes.getString(4),attributes.getString(5),productuuid);
    }
    attributes.close();
    ResultSet certificates=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",productid);
    while (certificates.next()) {
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",Util.generateDbUUID(),certificates.getDate(2),certificates.getDate(3),certificates.getBytes(4),certificates.getBytes(5),productuuid);
    }
    certificates.close();
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid,orgid);
    this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid,orgid);
    ResultSet contentids=this.executeQuery(""String_Node_Str"",productid);
    while (contentids.next()) {
      String contentid=contentids.getString(1);
      String contentuuid=contentCache.get(contentid);
      if (contentuuid == null) {
        contentuuid=Util.generateDbUUID();
        contentCache.put(contentid,contentuuid);
        this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",contentuuid,orgid,contentid);
        this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",contentuuid,contentid);
        ResultSet content=this.executeQuery(""String_Node_Str"" + ""String_Node_Str"",contentid);
        while (content.next()) {
          this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",Util.generateDbUUID(),content.getDate(2),content.getDate(3),contentuuid,content.getBoolean(5),content.getString(6));
        }
        content.close();
      }
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,contentuuid,productid,contentid);
    }
    contentids.close();
  }
  productids.close();
}"
49366,"public Subscription importObject(ObjectMapper mapper,Reader reader,Owner owner,Map<String,Product> productsById,ConsumerDto consumer,Meta meta) throws IOException, SyncDataFormatException {
  Entitlement entitlement=mapper.readValue(reader,Entitlement.class);
  Subscription subscription=new Subscription();
  subscription.setUpstreamPoolId(entitlement.getPool().getId());
  subscription.setUpstreamEntitlementId(entitlement.getId());
  subscription.setUpstreamConsumerId(consumer.getUuid());
  subscription.setOwner(owner);
  subscription.setStartDate(entitlement.getStartDate());
  subscription.setEndDate(entitlement.getEndDate());
  subscription.setAccountNumber(entitlement.getPool().getAccountNumber());
  subscription.setContractNumber(entitlement.getPool().getContractNumber());
  subscription.setOrderNumber(entitlement.getPool().getOrderNumber());
  subscription.setQuantity(entitlement.getQuantity().longValue());
  for (  Branding b : entitlement.getPool().getBranding()) {
    subscription.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
  }
  subscription.setProduct(findProduct(productsById,entitlement.getProductId()));
  String cdnLabel=meta.getCdnLabel();
  if (!StringUtils.isBlank(cdnLabel)) {
    Cdn cdn=cdnCurator.lookupByLabel(cdnLabel);
    if (cdn != null) {
      subscription.setCdn(cdn);
    }
  }
  Set<Product> products=new HashSet<Product>();
  for (  Product providedProduct : entitlement.getPool().getProvidedProducts()) {
    products.add(findProduct(productsById,providedProduct.getId()));
  }
  subscription.setProvidedProducts(products);
  if (entitlement.getPool().getDerivedProduct() != null) {
    subscription.setDerivedProduct(findProduct(productsById,entitlement.getPool().getDerivedProduct().getId()));
  }
  Set<Product> subProvProds=new HashSet<Product>();
  for (  Product subProvProd : entitlement.getPool().getDerivedProvidedProducts()) {
    subProvProds.add(findProduct(productsById,subProvProd.getId()));
  }
  subscription.setDerivedProvidedProducts(subProvProds);
  Set<EntitlementCertificate> certs=entitlement.getCertificates();
  int entcnt=0;
  for (  EntitlementCertificate cert : certs) {
    entcnt++;
    CertificateSerial cs=new CertificateSerial();
    cs.setCollected(cert.getSerial().isCollected());
    cs.setExpiration(cert.getSerial().getExpiration());
    cs.setUpdated(cert.getSerial().getUpdated());
    cs.setCreated(cert.getSerial().getCreated());
    csCurator.create(cs);
    SubscriptionsCertificate sc=new SubscriptionsCertificate();
    sc.setKey(cert.getKey());
    sc.setCertAsBytes(cert.getCertAsBytes());
    sc.setSerial(cs);
    subscription.setCertificate(sc);
  }
  if (entcnt > 1) {
    log.error(""String_Node_Str"");
  }
  return subscription;
}","public Subscription importObject(ObjectMapper mapper,Reader reader,Owner owner,Map<String,Product> productsById,ConsumerDto consumer,Meta meta) throws IOException, SyncDataFormatException {
  Entitlement entitlement=mapper.readValue(reader,Entitlement.class);
  Subscription subscription=new Subscription();
  subscription.setId(Util.generateDbUUID());
  subscription.setUpstreamPoolId(entitlement.getPool().getId());
  subscription.setUpstreamEntitlementId(entitlement.getId());
  subscription.setUpstreamConsumerId(consumer.getUuid());
  subscription.setOwner(owner);
  subscription.setStartDate(entitlement.getStartDate());
  subscription.setEndDate(entitlement.getEndDate());
  subscription.setAccountNumber(entitlement.getPool().getAccountNumber());
  subscription.setContractNumber(entitlement.getPool().getContractNumber());
  subscription.setOrderNumber(entitlement.getPool().getOrderNumber());
  subscription.setQuantity(entitlement.getQuantity().longValue());
  for (  Branding b : entitlement.getPool().getBranding()) {
    subscription.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
  }
  subscription.setProduct(findProduct(productsById,entitlement.getProductId()));
  String cdnLabel=meta.getCdnLabel();
  if (!StringUtils.isBlank(cdnLabel)) {
    Cdn cdn=cdnCurator.lookupByLabel(cdnLabel);
    if (cdn != null) {
      subscription.setCdn(cdn);
    }
  }
  Set<Product> products=new HashSet<Product>();
  for (  Product providedProduct : entitlement.getPool().getProvidedProducts()) {
    products.add(findProduct(productsById,providedProduct.getId()));
  }
  subscription.setProvidedProducts(products);
  if (entitlement.getPool().getDerivedProduct() != null) {
    subscription.setDerivedProduct(findProduct(productsById,entitlement.getPool().getDerivedProduct().getId()));
  }
  Set<Product> subProvProds=new HashSet<Product>();
  for (  Product subProvProd : entitlement.getPool().getDerivedProvidedProducts()) {
    subProvProds.add(findProduct(productsById,subProvProd.getId()));
  }
  subscription.setDerivedProvidedProducts(subProvProds);
  Set<EntitlementCertificate> certs=entitlement.getCertificates();
  int entcnt=0;
  for (  EntitlementCertificate cert : certs) {
    entcnt++;
    CertificateSerial cs=new CertificateSerial();
    cs.setCollected(cert.getSerial().isCollected());
    cs.setExpiration(cert.getSerial().getExpiration());
    cs.setUpdated(cert.getSerial().getUpdated());
    cs.setCreated(cert.getSerial().getCreated());
    csCurator.create(cs);
    SubscriptionsCertificate sc=new SubscriptionsCertificate();
    sc.setKey(cert.getKey());
    sc.setCertAsBytes(cert.getCertAsBytes());
    sc.setSerial(cs);
    subscription.setCertificate(sc);
  }
  if (entcnt > 1) {
    log.error(""String_Node_Str"");
  }
  return subscription;
}"
49367,"@Before public void init() throws Exception {
  o=new Owner(""String_Node_Str"",""String_Node_Str"");
  product=TestUtil.createProduct(o);
  pool=TestUtil.createPool(o,product);
  when(mockConfig.getInt(eq(ConfigProperties.PRODUCT_CACHE_MAX))).thenReturn(100);
  when(eventFactory.getEventBuilder(any(Target.class),any(Type.class))).thenReturn(eventBuilder);
  when(eventBuilder.setNewEntity(any(AbstractHibernateObject.class))).thenReturn(eventBuilder);
  when(eventBuilder.setOldEntity(any(AbstractHibernateObject.class))).thenReturn(eventBuilder);
  this.principal=TestUtil.createOwnerPrincipal();
  this.manager=spy(new CandlepinPoolManager(mockPoolCurator,mockSubAdapter,mockProductCurator,entCertAdapterMock,mockEventSink,eventFactory,mockConfig,enforcerMock,poolRulesMock,entitlementCurator,consumerCuratorMock,certCuratorMock,complianceRules,autobindRules,activationKeyRules,productCuratorMock));
  when(entCertAdapterMock.generateEntitlementCert(any(Entitlement.class),any(Product.class))).thenReturn(new EntitlementCertificate());
  dummyComplianceStatus=new ComplianceStatus(new Date());
  when(complianceRules.getStatus(any(Consumer.class),any(Date.class))).thenReturn(dummyComplianceStatus);
}","@Before public void init() throws Exception {
  o=new Owner(""String_Node_Str"",""String_Node_Str"");
  product=TestUtil.createProduct(o);
  pool=TestUtil.createPool(o,product);
  when(mockConfig.getInt(eq(ConfigProperties.PRODUCT_CACHE_MAX))).thenReturn(100);
  when(eventFactory.getEventBuilder(any(Target.class),any(Type.class))).thenReturn(eventBuilder);
  when(eventBuilder.setNewEntity(any(AbstractHibernateObject.class))).thenReturn(eventBuilder);
  when(eventBuilder.setOldEntity(any(AbstractHibernateObject.class))).thenReturn(eventBuilder);
  this.principal=TestUtil.createOwnerPrincipal();
  this.manager=spy(new CandlepinPoolManager(mockPoolCurator,mockSubAdapter,mockProductCurator,entCertAdapterMock,mockEventSink,eventFactory,mockConfig,enforcerMock,poolRulesMock,entitlementCurator,consumerCuratorMock,certCuratorMock,complianceRules,autobindRules,activationKeyRules,productCuratorMock,contentCuratorMock));
  when(entCertAdapterMock.generateEntitlementCert(any(Entitlement.class),any(Product.class))).thenReturn(new EntitlementCertificate());
  dummyComplianceStatus=new ComplianceStatus(new Date());
  when(complianceRules.getStatus(any(Consumer.class),any(Date.class))).thenReturn(dummyComplianceStatus);
}"
49368,"@Test(expected=RuntimeException.class) public void testExceptionFromCertGen() throws Exception {
  Consumer consumer=createConsumer();
  Entitlement e=Mockito.mock(Entitlement.class);
  Pool p=Mockito.mock(Pool.class);
  Subscription s=Mockito.mock(Subscription.class);
  when(e.getPool()).thenReturn(p);
  when(p.getSubscriptionId()).thenReturn(""String_Node_Str"");
  when(mockedConsumerCurator.verifyAndLookupConsumer(consumer.getUuid())).thenReturn(consumer);
  when(mockedEntitlementCurator.find(eq(""String_Node_Str""))).thenReturn(e);
  when(mockedSubscriptionServiceAdapter.getSubscription(eq(""String_Node_Str""))).thenReturn(s);
  when(mockedEntitlementCertServiceAdapter.generateEntitlementCert(any(Entitlement.class),any(Product.class))).thenThrow(new IOException());
  CandlepinPoolManager poolManager=new CandlepinPoolManager(null,mockedSubscriptionServiceAdapter,null,mockedEntitlementCertServiceAdapter,null,null,new CandlepinCommonTestConfig(),null,null,mockedEntitlementCurator,mockedConsumerCurator,null,null,null,mockedActivationKeyRules,null);
  ConsumerResource consumerResource=new ConsumerResource(mockedConsumerCurator,null,null,null,mockedEntitlementCurator,null,mockedEntitlementCertServiceAdapter,null,null,null,null,null,null,null,poolManager,null,null,null,null,null,null,null,null,new CandlepinCommonTestConfig(),null,null,null,consumerBindUtil);
  consumerResource.regenerateEntitlementCertificates(consumer.getUuid(),""String_Node_Str"",false);
}","@Test(expected=RuntimeException.class) public void testExceptionFromCertGen() throws Exception {
  Consumer consumer=createConsumer();
  Entitlement e=Mockito.mock(Entitlement.class);
  Pool p=Mockito.mock(Pool.class);
  Subscription s=Mockito.mock(Subscription.class);
  when(e.getPool()).thenReturn(p);
  when(p.getSubscriptionId()).thenReturn(""String_Node_Str"");
  when(mockedConsumerCurator.verifyAndLookupConsumer(consumer.getUuid())).thenReturn(consumer);
  when(mockedEntitlementCurator.find(eq(""String_Node_Str""))).thenReturn(e);
  when(mockedSubscriptionServiceAdapter.getSubscription(eq(""String_Node_Str""))).thenReturn(s);
  when(mockedEntitlementCertServiceAdapter.generateEntitlementCert(any(Entitlement.class),any(Product.class))).thenThrow(new IOException());
  CandlepinPoolManager poolManager=new CandlepinPoolManager(null,mockedSubscriptionServiceAdapter,null,mockedEntitlementCertServiceAdapter,null,null,new CandlepinCommonTestConfig(),null,null,mockedEntitlementCurator,mockedConsumerCurator,null,null,null,mockedActivationKeyRules,null,null);
  ConsumerResource consumerResource=new ConsumerResource(mockedConsumerCurator,null,null,null,mockedEntitlementCurator,null,mockedEntitlementCertServiceAdapter,null,null,null,null,null,null,null,poolManager,null,null,null,null,null,null,null,null,new CandlepinCommonTestConfig(),null,null,null,consumerBindUtil);
  consumerResource.regenerateEntitlementCertificates(consumer.getUuid(),""String_Node_Str"",false);
}"
49369,"@Test public void testNewProductCreated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  when(productCuratorMock.lookupById(product.getOwner(),product.getId())).thenReturn(null);
  importer.store(storeThese,owner);
}","@Test public void testNewProductCreated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader,owner);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
}"
49370,"@Test public void testVendorSetToUnknown() throws Exception {
  Product product=TestUtil.createProduct(owner);
  addNoVendorContentTo(product);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Content c=created.getProductContent().iterator().next().getContent();
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  importer.store(storeThese,owner);
  verify(contentCuratorMock).createOrUpdate(c);
  assertEquals(""String_Node_Str"",c.getVendor());
}","@Test public void testVendorSetToUnknown() throws Exception {
  Product product=TestUtil.createProduct(owner);
  addNoVendorContentTo(product);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader,owner);
  Content c=created.getProductContent().iterator().next().getContent();
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  assertEquals(""String_Node_Str"",c.getVendor());
}"
49371,"@Test public void testExistingProductUpdated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  String newProductName=""String_Node_Str"";
  created.setName(newProductName);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  when(productCuratorMock.lookupById(product.getOwner(),product.getId())).thenReturn(product);
  importer.store(storeThese,owner);
}","@Test public void testExistingProductUpdated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader,owner);
  String newProductName=""String_Node_Str"";
  created.setName(newProductName);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  when(productCuratorMock.lookupById(product.getOwner(),product.getId())).thenReturn(product);
}"
49372,"@Test public void testContentCreated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  addContentTo(product);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Content c=created.getProductContent().iterator().next().getContent();
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  importer.store(storeThese,owner);
  verify(contentCuratorMock).createOrUpdate(c);
  assertEquals(new Long(1),c.getMetadataExpire());
}","@Test public void testContentCreated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  addContentTo(product);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader,owner);
  Content c=created.getProductContent().iterator().next().getContent();
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  assertEquals(new Long(1),c.getMetadataExpire());
}"
49373,"@Test public void testExistingProductContentAdded() throws Exception {
  Owner owner=new Owner(""String_Node_Str"");
  Product oldProduct=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  Product newProduct=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  addContentTo(newProduct);
  Content c=newProduct.getProductContent().iterator().next().getContent();
  when(productCuratorMock.find(oldProduct.getUuid())).thenReturn(oldProduct);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(newProduct);
  importer.store(storeThese,owner);
}","@Test public void testExistingProductContentAdded() throws Exception {
  Owner owner=new Owner(""String_Node_Str"");
  Product oldProduct=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  Product newProduct=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  addContentTo(newProduct);
  Content c=newProduct.getProductContent().iterator().next().getContent();
  when(productCuratorMock.find(oldProduct.getUuid())).thenReturn(oldProduct);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(newProduct);
}"
49374,"@Test public void testCreateObject() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  assertEquals(product.getUuid(),created.getUuid());
  assertEquals(product.getName(),created.getName());
  assertEquals(product.getAttributes(),created.getAttributes());
}","@Test public void testCreateObject() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader,owner);
  assertEquals(product.getUuid(),created.getUuid());
  assertEquals(product.getName(),created.getName());
  assertEquals(product.getAttributes(),created.getAttributes());
}"
49375,"@JsonIgnore public Set<ProvidedProduct> getDerivedProvidedProductDtos(){
  return this.providedProductDtos;
}","@JsonProperty(""String_Node_Str"") public Set<ProvidedProduct> getDerivedProvidedProductDtos(){
  Set<ProvidedProduct> prods=new HashSet<ProvidedProduct>();
  if (this.derivedProvidedProductDtos != null) {
    prods.addAll(this.derivedProvidedProductDtos);
  }
  for (  Product p : getDerivedProvidedProducts()) {
    prods.add(new ProvidedProduct(p));
  }
  return prods;
}"
49376,"@JsonProperty(""String_Node_Str"") public Set<ProvidedProduct> getProvidedProductDtos(){
  Set<ProvidedProduct> prods=new HashSet<ProvidedProduct>();
  for (  Product p : getProvidedProducts()) {
    prods.add(new ProvidedProduct(p));
  }
  return prods;
}","@JsonProperty(""String_Node_Str"") public Set<ProvidedProduct> getProvidedProductDtos(){
  Set<ProvidedProduct> prods=new HashSet<ProvidedProduct>();
  if (this.providedProductDtos != null) {
    prods.addAll(this.providedProductDtos);
  }
  for (  Product p : getProvidedProducts()) {
    prods.add(new ProvidedProduct(p));
  }
  return prods;
}"
49377,"public Subscription importObject(ObjectMapper mapper,Reader reader,Owner owner,Map<String,Product> productsById,ConsumerDto consumer,Meta meta) throws IOException, SyncDataFormatException {
  Entitlement entitlement=mapper.readValue(reader,Entitlement.class);
  Subscription subscription=new Subscription();
  log.debug(""String_Node_Str"",owner);
  log.debug(""String_Node_Str"",entitlement.getPool());
  log.debug(""String_Node_Str"",entitlement.getPool().getDerivedProduct());
  subscription.setId(Util.generateDbUUID());
  subscription.setUpstreamPoolId(entitlement.getPool().getId());
  subscription.setUpstreamEntitlementId(entitlement.getId());
  subscription.setUpstreamConsumerId(consumer.getUuid());
  subscription.setOwner(owner);
  subscription.setStartDate(entitlement.getStartDate());
  subscription.setEndDate(entitlement.getEndDate());
  subscription.setAccountNumber(entitlement.getPool().getAccountNumber());
  subscription.setContractNumber(entitlement.getPool().getContractNumber());
  subscription.setOrderNumber(entitlement.getPool().getOrderNumber());
  subscription.setQuantity(entitlement.getQuantity().longValue());
  for (  Branding b : entitlement.getPool().getBranding()) {
    subscription.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
  }
  subscription.setProduct(findProduct(productsById,entitlement.getProductId()));
  String cdnLabel=meta.getCdnLabel();
  if (!StringUtils.isBlank(cdnLabel)) {
    Cdn cdn=cdnCurator.lookupByLabel(cdnLabel);
    if (cdn != null) {
      subscription.setCdn(cdn);
    }
  }
  Set<Product> products=new HashSet<Product>();
  for (  Product providedProduct : entitlement.getPool().getProvidedProducts()) {
    products.add(findProduct(productsById,providedProduct.getId()));
  }
  subscription.setProvidedProducts(products);
  if (entitlement.getPool().getDerivedProduct() != null) {
    subscription.setDerivedProduct(findProduct(productsById,entitlement.getPool().getDerivedProduct().getId()));
  }
  Set<Product> subProvProds=new HashSet<Product>();
  for (  Product subProvProd : entitlement.getPool().getDerivedProvidedProducts()) {
    subProvProds.add(findProduct(productsById,subProvProd.getId()));
  }
  for (  ProvidedProduct pp : entitlement.getPool().getDerivedProvidedProductDtos()) {
    subProvProds.add(this.findProduct(productsById,pp.getProductId()));
  }
  log.debug(""String_Node_Str"",entitlement.getPool().getDerivedProvidedProducts().size());
  log.debug(""String_Node_Str"",entitlement.getPool().getDerivedProvidedProductDtos().size());
  log.debug(""String_Node_Str"",subProvProds.size());
  subscription.setDerivedProvidedProducts(subProvProds);
  Set<EntitlementCertificate> certs=entitlement.getCertificates();
  int entcnt=0;
  for (  EntitlementCertificate cert : certs) {
    entcnt++;
    CertificateSerial cs=new CertificateSerial();
    cs.setCollected(cert.getSerial().isCollected());
    cs.setExpiration(cert.getSerial().getExpiration());
    cs.setUpdated(cert.getSerial().getUpdated());
    cs.setCreated(cert.getSerial().getCreated());
    csCurator.create(cs);
    SubscriptionsCertificate sc=new SubscriptionsCertificate();
    sc.setKey(cert.getKey());
    sc.setCertAsBytes(cert.getCertAsBytes());
    sc.setSerial(cs);
    subscription.setCertificate(sc);
  }
  if (entcnt > 1) {
    log.error(""String_Node_Str"");
  }
  return subscription;
}","public Subscription importObject(ObjectMapper mapper,Reader reader,Owner owner,Map<String,Product> productsById,ConsumerDto consumer,Meta meta) throws IOException, SyncDataFormatException {
  Entitlement entitlement=mapper.readValue(reader,Entitlement.class);
  Subscription subscription=new Subscription();
  log.debug(""String_Node_Str"",owner);
  log.debug(""String_Node_Str"",entitlement.getPool());
  log.debug(""String_Node_Str"",entitlement.getPool().getDerivedProduct());
  subscription.setId(Util.generateDbUUID());
  subscription.setUpstreamPoolId(entitlement.getPool().getId());
  subscription.setUpstreamEntitlementId(entitlement.getId());
  subscription.setUpstreamConsumerId(consumer.getUuid());
  subscription.setOwner(owner);
  subscription.setStartDate(entitlement.getStartDate());
  subscription.setEndDate(entitlement.getEndDate());
  subscription.setAccountNumber(entitlement.getPool().getAccountNumber());
  subscription.setContractNumber(entitlement.getPool().getContractNumber());
  subscription.setOrderNumber(entitlement.getPool().getOrderNumber());
  subscription.setQuantity(entitlement.getQuantity().longValue());
  for (  Branding b : entitlement.getPool().getBranding()) {
    subscription.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
  }
  subscription.setProduct(findProduct(productsById,entitlement.getProductId()));
  String cdnLabel=meta.getCdnLabel();
  if (!StringUtils.isBlank(cdnLabel)) {
    Cdn cdn=cdnCurator.lookupByLabel(cdnLabel);
    if (cdn != null) {
      subscription.setCdn(cdn);
    }
  }
  Set<Product> products=new HashSet<Product>();
  for (  Product providedProduct : entitlement.getPool().getProvidedProducts()) {
    products.add(findProduct(productsById,providedProduct.getId()));
  }
  subscription.setProvidedProducts(products);
  if (entitlement.getPool().getDerivedProduct() != null) {
    subscription.setDerivedProduct(findProduct(productsById,entitlement.getPool().getDerivedProduct().getId()));
  }
  Set<Product> subProvProds=new HashSet<Product>();
  for (  Product subProvProd : entitlement.getPool().getDerivedProvidedProducts()) {
    subProvProds.add(findProduct(productsById,subProvProd.getId()));
  }
  entitlement.getPool().setDerivedProvidedProducts(null);
  for (  ProvidedProduct pp : entitlement.getPool().getDerivedProvidedProductDtos()) {
    subProvProds.add(this.findProduct(productsById,pp.getProductId()));
  }
  entitlement.getPool().setDerivedProvidedProductDtos(null);
  log.debug(""String_Node_Str"",entitlement.getPool().getDerivedProvidedProducts().size());
  log.debug(""String_Node_Str"",entitlement.getPool().getDerivedProvidedProductDtos().size());
  log.debug(""String_Node_Str"",subProvProds.size());
  subscription.setDerivedProvidedProducts(subProvProds);
  Set<EntitlementCertificate> certs=entitlement.getCertificates();
  int entcnt=0;
  for (  EntitlementCertificate cert : certs) {
    entcnt++;
    CertificateSerial cs=new CertificateSerial();
    cs.setCollected(cert.getSerial().isCollected());
    cs.setExpiration(cert.getSerial().getExpiration());
    cs.setUpdated(cert.getSerial().getUpdated());
    cs.setCreated(cert.getSerial().getCreated());
    csCurator.create(cs);
    SubscriptionsCertificate sc=new SubscriptionsCertificate();
    sc.setKey(cert.getKey());
    sc.setCertAsBytes(cert.getCertAsBytes());
    sc.setSerial(cs);
    subscription.setCertificate(sc);
  }
  if (entcnt > 1) {
    log.error(""String_Node_Str"");
  }
  return subscription;
}"
49378,"@Test public void getUpstreamCertSimple(){
  Entitlement e=TestUtil.createEntitlement();
  e.setId(""String_Node_Str"");
  when(entitlementCurator.find(eq(e.getId()))).thenReturn(e);
  String expected=""String_Node_Str"";
  when(subResource.getSubCertAsPem(eq(e.getPool().getSubscriptionId()))).thenReturn(expected);
  String result=entResource.getUpstreamCert(e.getId());
  assertEquals(expected,result);
}","@Test public void getUpstreamCertSimple(){
  Entitlement e=TestUtil.createEntitlement();
  e.setId(""String_Node_Str"");
  EntitlementCertificate entitlementCert=new EntitlementCertificate();
  entitlementCert.setCert(""String_Node_Str"");
  entitlementCert.setKey(""String_Node_Str"");
  Set<EntitlementCertificate> certs=new HashSet<EntitlementCertificate>();
  certs.add(entitlementCert);
  e.setCertificates(certs);
  when(entitlementCurator.find(eq(e.getId()))).thenReturn(e);
  String expected=""String_Node_Str"";
  String result=entResource.getUpstreamCert(e.getId());
  assertEquals(expected,result);
}"
49379,"@Test public void getUpstreamCertStackSubPool(){
  Entitlement parentEnt=TestUtil.createEntitlement();
  parentEnt.setId(""String_Node_Str"");
  when(entitlementCurator.findUpstreamEntitlementForStack(consumer,""String_Node_Str"")).thenReturn(parentEnt);
  String expected=""String_Node_Str"";
  when(subResource.getSubCertAsPem(eq(parentEnt.getPool().getSubscriptionId()))).thenReturn(expected);
  Entitlement e=TestUtil.createEntitlement();
  e.setId(""String_Node_Str"");
  e.getPool().setSourceStack(new SourceStack(consumer,""String_Node_Str""));
  when(entitlementCurator.find(eq(e.getId()))).thenReturn(e);
  String result=entResource.getUpstreamCert(e.getId());
  assertEquals(expected,result);
}","@Test public void getUpstreamCertStackSubPool(){
  Entitlement parentEnt=TestUtil.createEntitlement();
  parentEnt.setId(""String_Node_Str"");
  EntitlementCertificate entitlementCert=new EntitlementCertificate();
  entitlementCert.setCert(""String_Node_Str"");
  entitlementCert.setKey(""String_Node_Str"");
  Set<EntitlementCertificate> certs=new HashSet<EntitlementCertificate>();
  certs.add(entitlementCert);
  parentEnt.setCertificates(certs);
  when(entitlementCurator.findUpstreamEntitlementForStack(consumer,""String_Node_Str"")).thenReturn(parentEnt);
  String expected=""String_Node_Str"";
  Entitlement e=TestUtil.createEntitlement();
  e.setId(""String_Node_Str"");
  e.getPool().setSourceStack(new SourceStack(consumer,""String_Node_Str""));
  when(entitlementCurator.find(eq(e.getId()))).thenReturn(e);
  String result=entResource.getUpstreamCert(e.getId());
  assertEquals(expected,result);
}"
49380,"@Test public void testImportRecordDeleteWithLogging() throws IOException, ImporterException {
  EventSink es=mock(EventSink.class);
  ExporterMetadataCurator ec=mock(ExporterMetadataCurator.class);
  SubscriptionCurator sc=mock(SubscriptionCurator.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,sc,null,null,null,i18n,es,null,null,null,null,null,ec,null,importRecordCurator,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  ExporterMetadata metadata=new ExporterMetadata();
  when(ec.lookupByTypeAndOwner(ExporterMetadata.TYPE_PER_USER,owner)).thenReturn(metadata);
  when(sc.listByOwner(owner)).thenReturn(new ArrayList<Subscription>());
  thisOwnerResource.undoImports(owner.getKey(),new UserPrincipal(""String_Node_Str"",null,true));
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  assertTrue(records.size() == 1);
  ImportRecord ir=records.get(0);
  assertTrue(ir.getStatus() == ImportRecord.Status.DELETE);
}","@Test public void testImportRecordDeleteWithLogging() throws IOException, ImporterException {
  EventSink es=mock(EventSink.class);
  ExporterMetadataCurator ec=mock(ExporterMetadataCurator.class);
  SubscriptionCurator sc=mock(SubscriptionCurator.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,sc,null,null,null,i18n,es,null,null,null,null,this.poolManager,ec,null,importRecordCurator,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  ExporterMetadata metadata=new ExporterMetadata();
  when(ec.lookupByTypeAndOwner(ExporterMetadata.TYPE_PER_USER,owner)).thenReturn(metadata);
  when(sc.listByOwner(owner)).thenReturn(new ArrayList<Subscription>());
  thisOwnerResource.undoImports(owner.getKey(),new UserPrincipal(""String_Node_Str"",null,true));
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  assertTrue(records.size() == 1);
  ImportRecord ir=records.get(0);
  assertTrue(ir.getStatus() == ImportRecord.Status.DELETE);
}"
49381,"@Transactional public Content createOrUpdate(Content c){
  Content existing=this.lookupById(c.getOwner(),c.getId());
  if (existing == null) {
    create(c);
    return c;
  }
  return merge(c);
}","@Transactional public Content createOrUpdate(Content c){
  Content existing=this.lookupById(c.getOwner(),c.getId());
  if (existing == null) {
    create(c);
    return c;
  }
  copy(c,existing);
  return merge(existing);
}"
49382,"public Set<ProductAttribute> getProductAttributes(){
  if (this.isStacked()) {
    return this.getStackedProductAttributes();
  }
  return this.getProduct() != null ? this.getProduct().getAttributes() : new HashSet<ProductAttribute>();
}","public Set<ProductAttribute> getProductAttributes(){
  return this.getProduct() != null ? this.getProduct().getAttributes() : new HashSet<ProductAttribute>();
}"
49383,"public PoolUpdate updatePoolFromStackedEntitlements(Pool pool,List<Entitlement> stackedEnts,Set<Product> changedProducts){
  PoolUpdate update=new PoolUpdate(pool);
  if (stackedEnts.isEmpty()) {
    return update;
  }
  pool.setSourceEntitlement(null);
  pool.setSourceSubscription(null);
  StackedSubPoolValueAccumulator acc=new StackedSubPoolValueAccumulator(pool,stackedEnts);
  Entitlement eldestWithVirtLimit=acc.getEldestWithVirtLimit();
  if (eldestWithVirtLimit != null) {
    String virtLimit=eldestWithVirtLimit.getPool().getProduct().getAttributeValue(""String_Node_Str"");
    Long quantity=virtLimit.equalsIgnoreCase(""String_Node_Str"") ? -1L : Long.parseLong(virtLimit);
    if (!quantity.equals(pool.getQuantity())) {
      pool.setQuantity(quantity);
      update.setQuantityChanged(true);
    }
  }
  update.setDatesChanged(checkForDateChange(acc.getStartDate(),acc.getEndDate(),pool));
  Entitlement eldest=acc.getEldest();
  Pool eldestEntPool=eldest.getPool();
  boolean useDerived=eldestEntPool.getDerivedProduct() != null;
  Product product=useDerived ? eldestEntPool.getDerivedProduct() : eldestEntPool.getProduct();
  update.setProductsChanged(checkForChangedProducts(product,acc.getExpectedProvidedProds(),pool,changedProducts));
  Set<ProductAttribute> expectedAttrs=acc.getExpectedAttributes();
  if (!pool.getProductAttributes().equals(expectedAttrs)) {
    pool.setStackedProductAttributes(expectedAttrs);
    update.setProductAttributesChanged(true);
  }
  if (!StringUtils.equals(eldestEntPool.getContractNumber(),pool.getContractNumber()) || !StringUtils.equals(eldestEntPool.getOrderNumber(),pool.getOrderNumber()) || !StringUtils.equals(eldestEntPool.getAccountNumber(),pool.getAccountNumber())) {
    pool.setContractNumber(eldestEntPool.getContractNumber());
    pool.setAccountNumber(eldestEntPool.getAccountNumber());
    pool.setOrderNumber(eldestEntPool.getOrderNumber());
    update.setOrderChanged(true);
  }
  if (update.changed()) {
    for (    Entitlement ent : pool.getEntitlements()) {
      ent.setDirty(true);
    }
  }
  return update;
}","public PoolUpdate updatePoolFromStackedEntitlements(Pool pool,List<Entitlement> stackedEnts,Set<Product> changedProducts){
  PoolUpdate update=new PoolUpdate(pool);
  if (stackedEnts.isEmpty()) {
    return update;
  }
  pool.setSourceEntitlement(null);
  pool.setSourceSubscription(null);
  StackedSubPoolValueAccumulator acc=new StackedSubPoolValueAccumulator(pool,stackedEnts);
  Entitlement eldestWithVirtLimit=acc.getEldestWithVirtLimit();
  if (eldestWithVirtLimit != null) {
    String virtLimit=eldestWithVirtLimit.getPool().getProductAttributeValue(""String_Node_Str"");
    Long quantity=virtLimit.equalsIgnoreCase(""String_Node_Str"") ? -1L : Long.parseLong(virtLimit);
    if (!quantity.equals(pool.getQuantity())) {
      pool.setQuantity(quantity);
      update.setQuantityChanged(true);
    }
  }
  update.setDatesChanged(checkForDateChange(acc.getStartDate(),acc.getEndDate(),pool));
  Entitlement eldest=acc.getEldest();
  Pool eldestEntPool=eldest.getPool();
  boolean useDerived=eldestEntPool.getDerivedProduct() != null;
  Product product=useDerived ? eldestEntPool.getDerivedProduct() : eldestEntPool.getProduct();
  update.setProductAttributesChanged(!pool.getProductAttributes().equals(product.getAttributes()));
  update.setProductsChanged(checkForChangedProducts(product,acc.getExpectedProvidedProds(),pool,changedProducts));
  if (!StringUtils.equals(eldestEntPool.getContractNumber(),pool.getContractNumber()) || !StringUtils.equals(eldestEntPool.getOrderNumber(),pool.getOrderNumber()) || !StringUtils.equals(eldestEntPool.getAccountNumber(),pool.getAccountNumber())) {
    pool.setContractNumber(eldestEntPool.getContractNumber());
    pool.setAccountNumber(eldestEntPool.getAccountNumber());
    pool.setOrderNumber(eldestEntPool.getOrderNumber());
    update.setOrderChanged(true);
  }
  if (update.changed()) {
    for (    Entitlement ent : pool.getEntitlements()) {
      ent.setDirty(true);
    }
  }
  return update;
}"
49384,"public StackedSubPoolValueAccumulator(Pool stackedSubPool,List<Entitlement> stackedEnts){
  for (  Entitlement nextStacked : stackedEnts) {
    Pool nextStackedPool=nextStacked.getPool();
    updateEldest(nextStacked);
    accumulateDateRange(nextStacked);
    updateEldestWithVirtLimit(nextStacked);
    accumulateProvidedProducts(stackedSubPool,nextStackedPool);
    accumulateProductAttributes(stackedSubPool,nextStackedPool);
  }
}","public StackedSubPoolValueAccumulator(Pool stackedSubPool,List<Entitlement> stackedEnts){
  for (  Entitlement nextStacked : stackedEnts) {
    Pool nextStackedPool=nextStacked.getPool();
    updateEldest(nextStacked);
    accumulateDateRange(nextStacked);
    updateEldestWithVirtLimit(nextStacked);
    accumulateProvidedProducts(stackedSubPool,nextStackedPool);
  }
}"
49385,"@Test public void mergedProductAttributes(){
  stackedEnts.add(createEntFromPool(pool1));
  stackedEnts.add(createEntFromPool(pool3));
  PoolUpdate update=poolRules.updatePoolFromStack(stackDerivedPool,null);
  assertTrue(update.changed());
  assertTrue(update.getProductAttributesChanged());
  assertEquals(6,stackDerivedPool.getProductAttributes().size());
  assertEquals(""String_Node_Str"",stackDerivedPool.getProductAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",stackDerivedPool.getProductAttributeValue(""String_Node_Str""));
}","@Test public void mergedProductAttributes(){
  Entitlement ent1=createEntFromPool(pool1);
  ent1.setCreated(new Date(System.currentTimeMillis() - 86400000));
  stackedEnts.add(ent1);
  stackedEnts.add(createEntFromPool(pool3));
  PoolUpdate update=poolRules.updatePoolFromStack(stackDerivedPool,null);
  assertTrue(update.changed());
  assertTrue(update.getProductAttributesChanged());
  assertEquals(pool1.getProductAttributes(),stackDerivedPool.getProductAttributes());
}"
49386,"@Before public void setUp(){
  InputStream is=this.getClass().getResourceAsStream(RulesCurator.DEFAULT_RULES_FILE);
  Rules rules=new Rules(Util.readFile(is));
  when(rulesCuratorMock.getUpdated()).thenReturn(new Date());
  when(rulesCuratorMock.getRules()).thenReturn(rules);
  when(configMock.getInt(eq(ConfigProperties.PRODUCT_CACHE_MAX))).thenReturn(100);
  poolRules=new PoolRules(poolManagerMock,configMock,entCurMock,productCuratorMock);
  principal=TestUtil.createOwnerPrincipal();
  owner=principal.getOwners().get(0);
  consumer=new Consumer(""String_Node_Str"",""String_Node_Str"",owner,new ConsumerType(ConsumerTypeEnum.SYSTEM));
  prod1=TestUtil.createProduct(owner);
  prod1.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  prod1.addAttribute(new ProductAttribute(""String_Node_Str"",STACK));
  prod1.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  when(productCuratorMock.find(prod1.getUuid())).thenReturn(prod1);
  prod2=TestUtil.createProduct(owner);
  prod2.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  prod2.addAttribute(new ProductAttribute(""String_Node_Str"",STACK));
  prod2.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  when(productCuratorMock.find(prod2.getUuid())).thenReturn(prod2);
  provided1=TestUtil.createProduct(owner);
  provided2=TestUtil.createProduct(owner);
  provided3=TestUtil.createProduct(owner);
  sub1=createStackedVirtSub(owner,prod1,TestUtil.createDate(2010,1,1),TestUtil.createDate(2015,1,1));
  sub1.getProvidedProducts().add(provided1);
  pool1=TestUtil.copyFromSub(sub1);
  sub2=createStackedVirtSub(owner,prod2,TestUtil.createDate(2011,1,1),TestUtil.createDate(2017,1,1));
  sub2.getProvidedProducts().add(provided2);
  pool2=TestUtil.copyFromSub(sub2);
  sub3=createStackedVirtSub(owner,prod2,TestUtil.createDate(2012,1,1),TestUtil.createDate(2020,1,1));
  sub3.getProvidedProducts().add(provided3);
  pool3=TestUtil.copyFromSub(sub3);
  stackedEnts.add(createEntFromPool(pool2));
  when(entCurMock.findByStackId(consumer,STACK)).thenReturn(stackedEnts);
  PoolHelper helper=new PoolHelper(poolManagerMock,stackedEnts.get(0));
  stackDerivedPool=helper.createHostRestrictedPool(prod2,pool2,""String_Node_Str"");
}","@Before public void setUp(){
  InputStream is=this.getClass().getResourceAsStream(RulesCurator.DEFAULT_RULES_FILE);
  Rules rules=new Rules(Util.readFile(is));
  when(rulesCuratorMock.getUpdated()).thenReturn(new Date());
  when(rulesCuratorMock.getRules()).thenReturn(rules);
  when(configMock.getInt(eq(ConfigProperties.PRODUCT_CACHE_MAX))).thenReturn(100);
  poolRules=new PoolRules(poolManagerMock,configMock,entCurMock,productCuratorMock);
  principal=TestUtil.createOwnerPrincipal();
  owner=principal.getOwners().get(0);
  consumer=new Consumer(""String_Node_Str"",""String_Node_Str"",owner,new ConsumerType(ConsumerTypeEnum.SYSTEM));
  prod1=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  prod1.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  prod1.addAttribute(new ProductAttribute(""String_Node_Str"",STACK));
  prod1.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  when(productCuratorMock.find(prod1.getUuid())).thenReturn(prod1);
  prod2=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  prod2.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  prod2.addAttribute(new ProductAttribute(""String_Node_Str"",STACK));
  prod2.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  when(productCuratorMock.find(prod2.getUuid())).thenReturn(prod2);
  provided1=TestUtil.createProduct(owner);
  provided2=TestUtil.createProduct(owner);
  provided3=TestUtil.createProduct(owner);
  sub1=createStackedVirtSub(owner,prod1,TestUtil.createDate(2010,1,1),TestUtil.createDate(2015,1,1));
  sub1.getProvidedProducts().add(provided1);
  pool1=TestUtil.copyFromSub(sub1);
  sub2=createStackedVirtSub(owner,prod2,TestUtil.createDate(2011,1,1),TestUtil.createDate(2017,1,1));
  sub2.getProvidedProducts().add(provided2);
  pool2=TestUtil.copyFromSub(sub2);
  sub3=createStackedVirtSub(owner,prod2,TestUtil.createDate(2012,1,1),TestUtil.createDate(2020,1,1));
  sub3.getProvidedProducts().add(provided3);
  pool3=TestUtil.copyFromSub(sub3);
  stackedEnts.add(createEntFromPool(pool2));
  when(entCurMock.findByStackId(consumer,STACK)).thenReturn(stackedEnts);
  PoolHelper helper=new PoolHelper(poolManagerMock,stackedEnts.get(0));
  stackDerivedPool=helper.createHostRestrictedPool(prod2,pool2,""String_Node_Str"");
}"
49387,"@Transactional(rollbackOn={IOException.class,ImporterException.class,RuntimeException.class,ImportConflictException.class}) ConsumerDto importObjects(Owner owner,Map<String,File> importFiles,ConflictOverrides overrides) throws IOException, ImporterException {
  File metadata=importFiles.get(ImportFile.META.fileName());
  if (metadata == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerTypes=importFiles.get(ImportFile.CONSUMER_TYPE.fileName());
  if (consumerTypes == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerFile=importFiles.get(ImportFile.CONSUMER.fileName());
  if (consumerFile == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File products=importFiles.get(ImportFile.PRODUCTS.fileName());
  File entitlements=importFiles.get(ImportFile.ENTITLEMENTS.fileName());
  if (products != null && entitlements == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  List<ImportConflictException> conflictExceptions=new LinkedList<ImportConflictException>();
  File rules=importFiles.get(ImportFile.RULES_FILE.fileName());
  importRules(rules,metadata);
  importConsumerTypes(consumerTypes.listFiles());
  File distributorVersions=importFiles.get(ImportFile.DISTRIBUTOR_VERSIONS.fileName());
  if (distributorVersions != null) {
    importDistributorVersions(distributorVersions.listFiles());
  }
  File cdns=importFiles.get(ImportFile.CONTENT_DELIVERY_NETWORKS.fileName());
  if (cdns != null) {
    importContentDeliveryNetworks(cdns.listFiles());
  }
  try {
    validateMetadata(ExporterMetadata.TYPE_PER_USER,owner,metadata,overrides);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  ConsumerDto consumer=null;
  try {
    Meta m=mapper.readValue(metadata,Meta.class);
    File upstreamFile=importFiles.get(ImportFile.UPSTREAM_CONSUMER.fileName());
    File[] dafiles=new File[0];
    if (upstreamFile != null) {
      dafiles=upstreamFile.listFiles();
    }
    consumer=importConsumer(owner,consumerFile,dafiles,overrides,m);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  if (!conflictExceptions.isEmpty()) {
    log.error(""String_Node_Str"");
    for (    ImportConflictException e : conflictExceptions) {
      log.error(""String_Node_Str"",e.message().getConflicts());
    }
    throw new ImportConflictException(conflictExceptions);
  }
  SubscriptionServiceAdapter adapter=new ImportSubscriptionServiceAdapter(new ArrayList<Subscription>());
  Refresher refresher=poolManager.getRefresher(adapter);
  Meta meta=mapper.readValue(metadata,Meta.class);
  if (importFiles.get(ImportFile.PRODUCTS.fileName()) != null) {
    ProductImporter importer=new ProductImporter(productCurator,contentCurator);
    Set<Product> productsToImport=importProducts(importFiles.get(ImportFile.PRODUCTS.fileName()).listFiles(),importer);
    importer.store(productsToImport);
    meta=mapper.readValue(metadata,Meta.class);
    importEntitlements(owner,productsToImport,entitlements.listFiles(),consumer,meta);
    refresher.add(owner);
    refresher.run();
  }
 else {
    log.warn(""String_Node_Str"");
    log.warn(""String_Node_Str"");
    importEntitlements(owner,new HashSet<Product>(),new File[]{},consumer,meta);
    refresher.add(owner);
    refresher.run();
  }
  return consumer;
}","@Transactional(rollbackOn={IOException.class,ImporterException.class,RuntimeException.class,ImportConflictException.class}) ConsumerDto importObjects(Owner owner,Map<String,File> importFiles,ConflictOverrides overrides) throws IOException, ImporterException {
  File metadata=importFiles.get(ImportFile.META.fileName());
  if (metadata == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerTypes=importFiles.get(ImportFile.CONSUMER_TYPE.fileName());
  if (consumerTypes == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerFile=importFiles.get(ImportFile.CONSUMER.fileName());
  if (consumerFile == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File products=importFiles.get(ImportFile.PRODUCTS.fileName());
  File entitlements=importFiles.get(ImportFile.ENTITLEMENTS.fileName());
  if (products != null && entitlements == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  List<ImportConflictException> conflictExceptions=new LinkedList<ImportConflictException>();
  File rules=importFiles.get(ImportFile.RULES_FILE.fileName());
  importRules(rules,metadata);
  importConsumerTypes(consumerTypes.listFiles());
  File distributorVersions=importFiles.get(ImportFile.DISTRIBUTOR_VERSIONS.fileName());
  if (distributorVersions != null) {
    importDistributorVersions(distributorVersions.listFiles());
  }
  File cdns=importFiles.get(ImportFile.CONTENT_DELIVERY_NETWORKS.fileName());
  if (cdns != null) {
    importContentDeliveryNetworks(cdns.listFiles());
  }
  try {
    validateMetadata(ExporterMetadata.TYPE_PER_USER,owner,metadata,overrides);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  ConsumerDto consumer=null;
  try {
    Meta m=mapper.readValue(metadata,Meta.class);
    File upstreamFile=importFiles.get(ImportFile.UPSTREAM_CONSUMER.fileName());
    File[] dafiles=new File[0];
    if (upstreamFile != null) {
      dafiles=upstreamFile.listFiles();
    }
    consumer=importConsumer(owner,consumerFile,dafiles,overrides,m);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  if (!conflictExceptions.isEmpty()) {
    log.error(""String_Node_Str"");
    for (    ImportConflictException e : conflictExceptions) {
      log.error(""String_Node_Str"",e.message().getConflicts());
    }
    throw new ImportConflictException(conflictExceptions);
  }
  SubscriptionServiceAdapter adapter=new ImportSubscriptionServiceAdapter(new ArrayList<Subscription>());
  Refresher refresher=poolManager.getRefresher(adapter);
  Meta meta=mapper.readValue(metadata,Meta.class);
  if (importFiles.get(ImportFile.PRODUCTS.fileName()) != null) {
    ProductImporter importer=new ProductImporter(productCurator,contentCurator);
    Set<Product> productsToImport=importProducts(importFiles.get(ImportFile.PRODUCTS.fileName()).listFiles(),importer);
    importer.store(productsToImport,owner);
    meta=mapper.readValue(metadata,Meta.class);
    importEntitlements(owner,productsToImport,entitlements.listFiles(),consumer,meta);
    refresher.add(owner);
    refresher.run();
  }
 else {
    log.warn(""String_Node_Str"");
    log.warn(""String_Node_Str"");
    importEntitlements(owner,new HashSet<Product>(),new File[]{},consumer,meta);
    refresher.add(owner);
    refresher.run();
  }
  return consumer;
}"
49388,"public void store(Set<Product> products){
  for (  Product importedProduct : products) {
    for (    ProductContent content : importedProduct.getProductContent()) {
      Content c=content.getContent();
      if (StringUtils.isBlank(c.getVendor())) {
        c.setVendor(""String_Node_Str"");
      }
      contentCurator.createOrUpdate(c);
    }
    curator.createOrUpdate(importedProduct);
  }
}","public void store(Set<Product> products,Owner o){
  for (  Product importedProduct : products) {
    for (    ProductContent content : importedProduct.getProductContent()) {
      Content c=content.getContent();
      if (StringUtils.isBlank(c.getVendor())) {
        c.setVendor(""String_Node_Str"");
      }
      c.setOwner(o);
      contentCurator.createOrUpdate(c);
    }
  }
}"
49389,"@Test public void testNewProductCreated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  when(productCuratorMock.lookupById(product.getOwner(),product.getId())).thenReturn(null);
  importer.store(storeThese);
  verify(productCuratorMock).createOrUpdate(created);
}","@Test public void testNewProductCreated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  when(productCuratorMock.lookupById(product.getOwner(),product.getId())).thenReturn(null);
  importer.store(storeThese,owner);
  verify(productCuratorMock).createOrUpdate(created);
}"
49390,"@Test public void testVendorSetToUnknown() throws Exception {
  Product product=TestUtil.createProduct(owner);
  addNoVendorContentTo(product);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Content c=created.getProductContent().iterator().next().getContent();
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  importer.store(storeThese);
  verify(contentCuratorMock).createOrUpdate(c);
  assertEquals(""String_Node_Str"",c.getVendor());
}","@Test public void testVendorSetToUnknown() throws Exception {
  Product product=TestUtil.createProduct(owner);
  addNoVendorContentTo(product);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Content c=created.getProductContent().iterator().next().getContent();
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  importer.store(storeThese,owner);
  verify(contentCuratorMock).createOrUpdate(c);
  assertEquals(""String_Node_Str"",c.getVendor());
}"
49391,"@Test public void testExistingProductUpdated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  String newProductName=""String_Node_Str"";
  created.setName(newProductName);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  when(productCuratorMock.lookupById(product.getOwner(),product.getId())).thenReturn(product);
  importer.store(storeThese);
  verify(productCuratorMock).createOrUpdate(created);
}","@Test public void testExistingProductUpdated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  String newProductName=""String_Node_Str"";
  created.setName(newProductName);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  when(productCuratorMock.lookupById(product.getOwner(),product.getId())).thenReturn(product);
  importer.store(storeThese,owner);
  verify(productCuratorMock).createOrUpdate(created);
}"
49392,"@Test public void testContentCreated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  addContentTo(product);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Content c=created.getProductContent().iterator().next().getContent();
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  importer.store(storeThese);
  verify(contentCuratorMock).createOrUpdate(c);
  assertEquals(new Long(1000),c.getMetadataExpire());
}","@Test public void testContentCreated() throws Exception {
  Product product=TestUtil.createProduct(owner);
  addContentTo(product);
  String json=getJsonForProduct(product);
  Reader reader=new StringReader(json);
  Product created=importer.createObject(mapper,reader);
  Content c=created.getProductContent().iterator().next().getContent();
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(created);
  importer.store(storeThese,owner);
  verify(contentCuratorMock).createOrUpdate(c);
  assertEquals(new Long(1000),c.getMetadataExpire());
}"
49393,"@Test public void testExistingProductContentAdded() throws Exception {
  Owner owner=new Owner(""String_Node_Str"");
  Product oldProduct=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  Product newProduct=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  addContentTo(newProduct);
  Content c=newProduct.getProductContent().iterator().next().getContent();
  when(productCuratorMock.find(oldProduct.getUuid())).thenReturn(oldProduct);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(newProduct);
  importer.store(storeThese);
  verify(productCuratorMock).createOrUpdate(newProduct);
  verify(contentCuratorMock).createOrUpdate(c);
}","@Test public void testExistingProductContentAdded() throws Exception {
  Owner owner=new Owner(""String_Node_Str"");
  Product oldProduct=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  Product newProduct=TestUtil.createProduct(""String_Node_Str"",""String_Node_Str"",owner);
  addContentTo(newProduct);
  Content c=newProduct.getProductContent().iterator().next().getContent();
  when(productCuratorMock.find(oldProduct.getUuid())).thenReturn(oldProduct);
  Set<Product> storeThese=new HashSet<Product>();
  storeThese.add(newProduct);
  importer.store(storeThese,owner);
  verify(productCuratorMock).createOrUpdate(newProduct);
  verify(contentCuratorMock).createOrUpdate(c);
}"
49394,"public void copy(Content src,Content dest){
  if (src.getId() == null ? dest.getId() != null : !src.getId().equals(dest.getId())) {
    throw new RuntimeException(i18n.tr(""String_Node_Str"",src.getId(),dest.getId()));
  }
  dest.setName(src.getName());
  dest.setArches(src.getArches());
  dest.setContentUrl(src.getContentUrl());
  dest.setGpgUrl(src.getGpgUrl());
  dest.setLabel(src.getLabel());
  dest.setMetadataExpire(src.getMetadataExpire());
  dest.setModifiedProductIds(src.getModifiedProductIds());
}","public void copy(Content src,Content dest){
  if (src.getId() == null ? dest.getId() != null : !src.getId().equals(dest.getId())) {
    throw new RuntimeException(i18n.tr(""String_Node_Str"",src.getId(),dest.getId()));
  }
  dest.setName(src.getName());
  dest.setArches(src.getArches());
  dest.setContentUrl(src.getContentUrl());
  dest.setGpgUrl(src.getGpgUrl());
  dest.setLabel(src.getLabel());
  dest.setMetadataExpire(src.getMetadataExpire());
  dest.setModifiedProductIds(src.getModifiedProductIds());
  dest.setType(src.getType());
}"
49395,"public void copy(Content src,Content dest){
  if (src.getId() == null ? dest.getId() != null : !src.getId().equals(dest.getId())) {
    throw new RuntimeException(i18n.tr(""String_Node_Str"",src.getId(),dest.getId()));
  }
  dest.setName(src.getName());
  dest.setArches(src.getArches());
  dest.setContentUrl(src.getContentUrl());
  dest.setGpgUrl(src.getGpgUrl());
  dest.setLabel(src.getLabel());
  dest.setMetadataExpire(src.getMetadataExpire());
  dest.setModifiedProductIds(src.getModifiedProductIds());
  dest.setType(src.getType());
}","public void copy(Content src,Content dest){
  if (src.getId() == null ? dest.getId() != null : !src.getId().equals(dest.getId())) {
    throw new RuntimeException(i18n.tr(""String_Node_Str"",src.getId(),dest.getId()));
  }
  dest.setName(src.getName());
  dest.setArches(src.getArches());
  dest.setContentUrl(src.getContentUrl());
  dest.setGpgUrl(src.getGpgUrl());
  dest.setLabel(src.getLabel());
  dest.setMetadataExpire(src.getMetadataExpire());
  dest.setModifiedProductIds(src.getModifiedProductIds());
  dest.setType(src.getType());
  dest.setVendor(src.getVendor());
  dest.setRequiredTags(src.getRequiredTags());
  dest.setReleaseVer(src.getReleaseVer());
}"
49396,"@Test public void upstreamConsumers(){
  Principal p=mock(Principal.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  UpstreamConsumer upstream=mock(UpstreamConsumer.class);
  Owner owner=mock(Owner.class);
  OwnerResource ownerres=new OwnerResource(oc,null,null,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
  when(owner.getUpstreamConsumer()).thenReturn(upstream);
  List<UpstreamConsumer> results=ownerres.getUpstreamConsumers(p,""String_Node_Str"");
  assertNotNull(results);
  assertEquals(1,results.size());
}","@Test public void upstreamConsumers(){
  Principal p=mock(Principal.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  UpstreamConsumer upstream=mock(UpstreamConsumer.class);
  Owner owner=mock(Owner.class);
  OwnerResource ownerres=new OwnerResource(oc,null,null,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(owner);
  when(owner.getUpstreamConsumer()).thenReturn(upstream);
  List<UpstreamConsumer> results=ownerres.getUpstreamConsumers(p,""String_Node_Str"");
  assertNotNull(results);
  assertEquals(1,results.size());
}"
49397,"private Pool doTestEntitlementsRevocationCommon(long subQ,int e1,int e2,boolean fifo) throws ParseException {
  Product prod=TestUtil.createProduct(owner);
  productCurator.create(prod);
  Pool pool=createPoolAndSub(createOwner(),prod,1000L,TestUtil.createDate(2009,11,30),TestUtil.createDate(2015,11,30));
  Owner owner=pool.getOwner();
  Consumer consumer=createConsumer(owner);
  Consumer consumer1=createConsumer(owner);
  Subscription sub=this.subCurator.find(pool.getSubscriptionId());
  sub.setQuantity(subQ);
  this.subCurator.merge(sub);
  pool=this.poolCurator.find(pool.getId());
  createEntitlementWithQ(pool,owner,consumer,e1,""String_Node_Str"");
  createEntitlementWithQ(pool,owner,consumer1,e2,""String_Node_Str"");
  assertEquals(pool.getConsumed(),Long.valueOf(e1 + e2));
  this.config.setProperty(ConfigProperties.REVOKE_ENTITLEMENT_IN_FIFO_ORDER,fifo ? ""String_Node_Str"" : ""String_Node_Str"");
  poolManager.getRefresher(subAdapter).add(owner).run();
  pool=poolCurator.find(pool.getId());
  return pool;
}","private Pool doTestEntitlementsRevocationCommon(long subQ,int e1,int e2,boolean fifo) throws ParseException {
  Product prod=TestUtil.createProduct(owner);
  productCurator.create(prod);
  Pool pool=createPoolAndSub(owner,prod,1000L,TestUtil.createDate(2009,11,30),TestUtil.createDate(2015,11,30));
  Owner owner=pool.getOwner();
  Consumer consumer=createConsumer(owner);
  Consumer consumer1=createConsumer(owner);
  Subscription sub=this.subCurator.find(pool.getSubscriptionId());
  sub.setQuantity(subQ);
  this.subCurator.merge(sub);
  pool=this.poolCurator.find(pool.getId());
  createEntitlementWithQ(pool,owner,consumer,e1,""String_Node_Str"");
  createEntitlementWithQ(pool,owner,consumer1,e2,""String_Node_Str"");
  assertEquals(pool.getConsumed(),Long.valueOf(e1 + e2));
  this.config.setProperty(ConfigProperties.REVOKE_ENTITLEMENT_IN_FIFO_ORDER,fifo ? ""String_Node_Str"" : ""String_Node_Str"");
  poolManager.getRefresher(subAdapter).add(owner).run();
  pool=poolCurator.find(pool.getId());
  return pool;
}"
49398,"@Test public void testImportRecordDeleteWithLogging() throws IOException, ImporterException {
  EventSink es=mock(EventSink.class);
  ExporterMetadataCurator ec=mock(ExporterMetadataCurator.class);
  SubscriptionCurator sc=mock(SubscriptionCurator.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,sc,null,null,null,i18n,es,null,null,null,null,null,ec,null,importRecordCurator,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null);
  ExporterMetadata metadata=new ExporterMetadata();
  when(ec.lookupByTypeAndOwner(ExporterMetadata.TYPE_PER_USER,owner)).thenReturn(metadata);
  when(sc.listByOwner(owner)).thenReturn(new ArrayList<Subscription>());
  thisOwnerResource.undoImports(owner.getKey(),new UserPrincipal(""String_Node_Str"",null,true));
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  assertTrue(records.size() == 1);
  ImportRecord ir=records.get(0);
  assertTrue(ir.getStatus() == ImportRecord.Status.DELETE);
}","@Test public void testImportRecordDeleteWithLogging() throws IOException, ImporterException {
  EventSink es=mock(EventSink.class);
  ExporterMetadataCurator ec=mock(ExporterMetadataCurator.class);
  SubscriptionCurator sc=mock(SubscriptionCurator.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,sc,null,null,null,i18n,es,null,null,null,null,null,ec,null,importRecordCurator,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  ExporterMetadata metadata=new ExporterMetadata();
  when(ec.lookupByTypeAndOwner(ExporterMetadata.TYPE_PER_USER,owner)).thenReturn(metadata);
  when(sc.listByOwner(owner)).thenReturn(new ArrayList<Subscription>());
  thisOwnerResource.undoImports(owner.getKey(),new UserPrincipal(""String_Node_Str"",null,true));
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  assertTrue(records.size() == 1);
  ImportRecord ir=records.get(0);
  assertTrue(ir.getStatus() == ImportRecord.Status.DELETE);
}"
49399,"@Test public void testImportRecordFailureWithFilename() throws IOException, ImporterException {
  Importer importer=mock(Importer.class);
  EventSink es=mock(EventSink.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,null,null,null,null,i18n,es,null,null,null,importer,null,null,null,importRecordCurator,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null);
  MultipartInput input=mock(MultipartInput.class);
  InputPart part=mock(InputPart.class);
  File archive=mock(File.class);
  List<InputPart> parts=new ArrayList<InputPart>();
  parts.add(part);
  MultivaluedMap<String,String> mm=new MultivaluedMapImpl<String,String>();
  List<String> contDis=new ArrayList<String>();
  contDis.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",contDis);
  when(input.getParts()).thenReturn(parts);
  when(part.getHeaders()).thenReturn(mm);
  when(part.getBody(any(GenericType.class))).thenReturn(archive);
  when(importer.loadExport(eq(owner),any(File.class),any(ConflictOverrides.class))).thenThrow(new ImporterException(""String_Node_Str""));
  try {
    thisOwnerResource.importManifest(owner.getKey(),new String[]{},input);
  }
 catch (  IseException ise) {
  }
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  ImportRecord ir=records.get(0);
  assertEquals(""String_Node_Str"",ir.getFileName());
  assertEquals(owner,ir.getOwner());
  assertEquals(ImportRecord.Status.FAILURE,ir.getStatus());
  assertEquals(""String_Node_Str"",ir.getStatusMessage());
}","@Test public void testImportRecordFailureWithFilename() throws IOException, ImporterException {
  Importer importer=mock(Importer.class);
  EventSink es=mock(EventSink.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,null,null,null,null,i18n,es,null,null,null,importer,null,null,null,importRecordCurator,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  MultipartInput input=mock(MultipartInput.class);
  InputPart part=mock(InputPart.class);
  File archive=mock(File.class);
  List<InputPart> parts=new ArrayList<InputPart>();
  parts.add(part);
  MultivaluedMap<String,String> mm=new MultivaluedMapImpl<String,String>();
  List<String> contDis=new ArrayList<String>();
  contDis.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",contDis);
  when(input.getParts()).thenReturn(parts);
  when(part.getHeaders()).thenReturn(mm);
  when(part.getBody(any(GenericType.class))).thenReturn(archive);
  when(importer.loadExport(eq(owner),any(File.class),any(ConflictOverrides.class))).thenThrow(new ImporterException(""String_Node_Str""));
  try {
    thisOwnerResource.importManifest(owner.getKey(),new String[]{},input);
  }
 catch (  IseException ise) {
  }
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  ImportRecord ir=records.get(0);
  assertEquals(""String_Node_Str"",ir.getFileName());
  assertEquals(owner,ir.getOwner());
  assertEquals(ImportRecord.Status.FAILURE,ir.getStatus());
  assertEquals(""String_Node_Str"",ir.getStatusMessage());
}"
49400,"@Test(expected=BadRequestException.class) public void testActivationKeyNameUnique(){
  ActivationKey ak=mock(ActivationKey.class);
  ActivationKey akOld=mock(ActivationKey.class);
  ActivationKeyCurator akc=mock(ActivationKeyCurator.class);
  Owner o=mock(Owner.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  when(ak.getName()).thenReturn(""String_Node_Str"");
  when(akc.lookupForOwner(eq(""String_Node_Str""),eq(o))).thenReturn(akOld);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(o);
  OwnerResource or=new OwnerResource(oc,null,akc,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null);
  or.createActivationKey(""String_Node_Str"",ak);
}","@Test(expected=BadRequestException.class) public void testActivationKeyNameUnique(){
  ActivationKey ak=mock(ActivationKey.class);
  ActivationKey akOld=mock(ActivationKey.class);
  ActivationKeyCurator akc=mock(ActivationKeyCurator.class);
  Owner o=mock(Owner.class);
  OwnerCurator oc=mock(OwnerCurator.class);
  when(ak.getName()).thenReturn(""String_Node_Str"");
  when(akc.lookupForOwner(eq(""String_Node_Str""),eq(o))).thenReturn(akOld);
  when(oc.lookupByKey(eq(""String_Node_Str""))).thenReturn(o);
  OwnerResource or=new OwnerResource(oc,null,akc,null,null,i18n,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  or.createActivationKey(""String_Node_Str"",ak);
}"
49401,"@Test public void testImportRecordSuccessWithFilename() throws IOException, ImporterException {
  Importer importer=mock(Importer.class);
  EventSink es=mock(EventSink.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,null,null,null,null,i18n,es,null,null,null,importer,null,null,null,importRecordCurator,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null);
  MultipartInput input=mock(MultipartInput.class);
  InputPart part=mock(InputPart.class);
  File archive=mock(File.class);
  List<InputPart> parts=new ArrayList<InputPart>();
  parts.add(part);
  MultivaluedMap<String,String> mm=new MultivaluedMapImpl<String,String>();
  List<String> contDis=new ArrayList<String>();
  contDis.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",contDis);
  when(input.getParts()).thenReturn(parts);
  when(part.getHeaders()).thenReturn(mm);
  when(part.getBody(any(GenericType.class))).thenReturn(archive);
  when(importer.loadExport(eq(owner),any(File.class),any(ConflictOverrides.class))).thenReturn(new HashMap<String,Object>());
  thisOwnerResource.importManifest(owner.getKey(),new String[]{},input);
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  ImportRecord ir=records.get(0);
  assertEquals(""String_Node_Str"",ir.getFileName());
  assertEquals(owner,ir.getOwner());
  assertEquals(ImportRecord.Status.SUCCESS,ir.getStatus());
}","@Test public void testImportRecordSuccessWithFilename() throws IOException, ImporterException {
  Importer importer=mock(Importer.class);
  EventSink es=mock(EventSink.class);
  OwnerResource thisOwnerResource=new OwnerResource(ownerCurator,null,null,null,null,i18n,es,null,null,null,importer,null,null,null,importRecordCurator,null,null,null,null,null,null,null,null,contentOverrideValidator,serviceLevelValidator,null,null,null,null);
  MultipartInput input=mock(MultipartInput.class);
  InputPart part=mock(InputPart.class);
  File archive=mock(File.class);
  List<InputPart> parts=new ArrayList<InputPart>();
  parts.add(part);
  MultivaluedMap<String,String> mm=new MultivaluedMapImpl<String,String>();
  List<String> contDis=new ArrayList<String>();
  contDis.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",contDis);
  when(input.getParts()).thenReturn(parts);
  when(part.getHeaders()).thenReturn(mm);
  when(part.getBody(any(GenericType.class))).thenReturn(archive);
  when(importer.loadExport(eq(owner),any(File.class),any(ConflictOverrides.class))).thenReturn(new HashMap<String,Object>());
  thisOwnerResource.importManifest(owner.getKey(),new String[]{},input);
  List<ImportRecord> records=importRecordCurator.findRecords(owner);
  ImportRecord ir=records.get(0);
  assertEquals(""String_Node_Str"",ir.getFileName());
  assertEquals(owner,ir.getOwner());
  assertEquals(ImportRecord.Status.SUCCESS,ir.getStatus());
}"
49402,"@Override public String getHref(){
  return ""String_Node_Str"" + getOwner().getKey() + ""String_Node_Str""+ getId();
}","@Override public String getHref(){
  if (getOwner() == null) {
    return ""String_Node_Str"";
  }
  return ""String_Node_Str"" + getOwner().getKey() + ""String_Node_Str""+ getId();
}"
49403,"/** 
 * Create any pools that need to be created for the given subscription. In some scenarios, due to attribute changes, pools may need to be created even though pools already exist for the subscription. A list of pre-existing pools for the given sub are provided to help this method determine if something needs to be done or not. For a genuine new subscription, the existing pools list will be empty.
 * @param sub
 * @param existingPools
 * @return
 */
public List<Pool> createPools(Subscription sub,List<Pool> existingPools){
  log.info(""String_Node_Str"" + sub);
  PoolHelper helper=new PoolHelper(this.poolManager,null);
  Product sku=prodCurator.lookupById(sub.getOwner(),sub.getProduct().getId());
  sub.setProduct(sku);
  List<Pool> pools=new LinkedList<Pool>();
  Map<String,String> attributes=helper.getFlattenedAttributes(sku);
  long quantity=calculateQuantity(sub);
  if (!hasMasterPool(existingPools)) {
    Pool newPool=new Pool(sub.getOwner(),sku,new HashSet<Product>(),quantity,sub.getStartDate(),sub.getEndDate(),sub.getContractNumber(),sub.getAccountNumber(),sub.getOrderNumber());
    for (    Product pp : sub.getProvidedProducts()) {
      newPool.addProvidedProduct(prodCurator.lookupById(sub.getOwner(),pp.getId()));
    }
    if (sub.getDerivedProvidedProducts() != null) {
      newPool.getDerivedProvidedProducts().addAll(sub.getDerivedProvidedProducts());
    }
    if (sub.getDerivedProduct() != null) {
      newPool.setDerivedProduct(sub.getDerivedProduct());
    }
    for (    Branding b : sub.getBranding()) {
      newPool.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
    }
    newPool.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
    ProductAttribute virtAtt=sku.getAttribute(""String_Node_Str"");
    if (virtAtt != null && virtAtt.getValue() != null && !virtAtt.getValue().equals(""String_Node_Str"")) {
      newPool.addAttribute(new org.candlepin.model.PoolAttribute(""String_Node_Str"",virtAtt.getValue()));
    }
    pools.add(newPool);
  }
  boolean hostLimited=attributes.containsKey(""String_Node_Str"") && attributes.get(""String_Node_Str"").equals(""String_Node_Str"");
  if (attributes.containsKey(""String_Node_Str"") && !hasBonusPool(existingPools)) {
    HashMap<String,String> virtAttributes=new HashMap<String,String>();
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    if (hostLimited || config.getBoolean(ConfigProperties.STANDALONE)) {
      virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    }
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    String virtQuantity=getVirtQuantity(attributes.get(""String_Node_Str""),quantity);
    if (virtQuantity != null) {
      if (sub.getDerivedProduct() != null) {
        sku=sub.getDerivedProduct();
      }
      Pool derivedPool=helper.createPool(sub,sku,virtQuantity,virtAttributes,prodCurator);
      derivedPool.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
      pools.add(derivedPool);
    }
  }
  return pools;
}","/** 
 * Create any pools that need to be created for the given subscription. In some scenarios, due to attribute changes, pools may need to be created even though pools already exist for the subscription. A list of pre-existing pools for the given sub are provided to help this method determine if something needs to be done or not. For a genuine new subscription, the existing pools list will be empty.
 * @param sub
 * @param existingPools
 * @return
 */
public List<Pool> createPools(Subscription sub,List<Pool> existingPools){
  log.info(""String_Node_Str"" + sub);
  PoolHelper helper=new PoolHelper(this.poolManager,null);
  Product sku=prodCurator.lookupById(sub.getOwner(),sub.getProduct().getId());
  sub.setProduct(sku);
  List<Pool> pools=new LinkedList<Pool>();
  Map<String,String> attributes=helper.getFlattenedAttributes(sku);
  long quantity=calculateQuantity(sub);
  if (!hasMasterPool(existingPools)) {
    Pool newPool=new Pool(sub.getOwner(),sku,new HashSet<Product>(),quantity,sub.getStartDate(),sub.getEndDate(),sub.getContractNumber(),sub.getAccountNumber(),sub.getOrderNumber());
    for (    Product pp : sub.getProvidedProducts()) {
      newPool.addProvidedProduct(prodCurator.lookupById(sub.getOwner(),pp.getId()));
    }
    if (sub.getDerivedProvidedProducts() != null) {
      for (      Product pp : sub.getDerivedProvidedProducts()) {
        newPool.addDerivedProvidedProduct(prodCurator.lookupById(sub.getOwner(),pp.getId()));
      }
    }
    if (sub.getDerivedProduct() != null) {
      newPool.setDerivedProduct(prodCurator.lookupById(sub.getOwner(),sub.getDerivedProduct().getId()));
    }
    for (    Branding b : sub.getBranding()) {
      newPool.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
    }
    newPool.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
    ProductAttribute virtAtt=sku.getAttribute(""String_Node_Str"");
    if (virtAtt != null && virtAtt.getValue() != null && !virtAtt.getValue().equals(""String_Node_Str"")) {
      newPool.addAttribute(new org.candlepin.model.PoolAttribute(""String_Node_Str"",virtAtt.getValue()));
    }
    pools.add(newPool);
  }
  boolean hostLimited=attributes.containsKey(""String_Node_Str"") && attributes.get(""String_Node_Str"").equals(""String_Node_Str"");
  if (attributes.containsKey(""String_Node_Str"") && !hasBonusPool(existingPools)) {
    HashMap<String,String> virtAttributes=new HashMap<String,String>();
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    if (hostLimited || config.getBoolean(ConfigProperties.STANDALONE)) {
      virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    }
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    String virtQuantity=getVirtQuantity(attributes.get(""String_Node_Str""),quantity);
    if (virtQuantity != null) {
      if (sub.getDerivedProduct() != null) {
        sku=prodCurator.lookupById(sub.getOwner(),sub.getDerivedProduct().getId());
      }
      Pool derivedPool=helper.createPool(sub,sku,virtQuantity,virtAttributes,prodCurator);
      derivedPool.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
      pools.add(derivedPool);
    }
  }
  return pools;
}"
49404,"/** 
 * Add a product that has been changed to be refreshed globally. Will be used to lookup any subscription using the product, either as a SKU or a provided product, and trigger a refresh for that specific subscription. WARNING: Should only be used in upstream production environments, downstream should always be driven by manifest import, which should never trigger a global refresh for other orgs.
 * @param product
 * @return
 */
public Refresher add(Product product){
  products.add(product);
  return this;
}","/** 
 * Add a product that has been changed to be refreshed globally. Will be used to lookup any subscription using the product, either as a SKU or a provided product, and trigger a refresh for that specific subscription. WARNING: Should only be used in upstream production environments, downstream should always be driven by manifest import, which should never trigger a global refresh for other orgs.
 * @param product
 * @return this Refresher instance
 */
public Refresher add(Product product){
  products.add(product);
  return this;
}"
49405,"/** 
 * Executes the multi-org upgrade task.
 * @throws DatabaseException if an error occurs while performing a database operation.
 */
public void execute() throws DatabaseException, SQLException {
  boolean autocommit=this.connection.getAutoCommit();
  this.connection.setAutoCommit(true);
  Map<String,String> orgContent=new HashMap<String,String>();
  ResultSet orgids=this.getOrgIDs();
  while (orgids.next()) {
    String orgid=orgids.getString(1);
    orgContent.clear();
    ResultSet productids=this.getProductIDs(orgid);
    while (productids.next()) {
      String productid=productids.getString(1);
      this.connection.setAutoCommit(false);
      String productuuid=this.generateUUID();
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid,orgid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid,orgid);
      this.connection.commit();
      this.connection.setAutoCommit(true);
      ResultSet contentids=this.getContentIDs(productid);
      while (contentids.next()) {
        String contentid=contentids.getString(1);
        String contentuuid=orgContent.get(contentid);
        this.connection.setAutoCommit(false);
        if (contentuuid == null) {
          contentuuid=this.generateUUID();
          orgContent.put(contentid,contentuuid);
          this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",contentuuid,orgid,contentid);
          this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",contentuuid,contentid);
          this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",this.generateUUID(),contentuuid,contentid);
        }
        this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,contentuuid,productid,contentid);
        this.connection.commit();
        this.connection.setAutoCommit(true);
      }
      contentids.close();
    }
    productids.close();
    ResultSet subscriptionids=this.getProductIDs(orgid);
    while (subscriptionids.next()) {
      String subid=subscriptionids.getString(1);
      String subuuid=this.generateUUID();
      this.connection.setAutoCommit(false);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,orgid,orgid,subid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),subuuid,subid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",subuuid,subid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
      this.connection.commit();
      this.connection.setAutoCommit(true);
    }
    subscriptionids.close();
  }
  orgids.close();
  this.connection.setAutoCommit(autocommit);
}","/** 
 * Executes the multi-org upgrade task.
 * @throws DatabaseException if an error occurs while performing a database operation
 * @throws SQLException if an error occurs while executing an SQL statement
 */
@SuppressWarnings(""String_Node_Str"") public void execute() throws DatabaseException, SQLException {
  boolean autocommit=this.connection.getAutoCommit();
  this.connection.setAutoCommit(true);
  Map<String,String> orgContent=new HashMap<String,String>();
  ResultSet orgids=this.getOrgIDs();
  while (orgids.next()) {
    String orgid=orgids.getString(1);
    orgContent.clear();
    ResultSet productids=this.getProductIDs(orgid);
    while (productids.next()) {
      String productid=productids.getString(1);
      this.connection.setAutoCommit(false);
      String productuuid=this.generateUUID();
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid,orgid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,productid,orgid);
      this.connection.commit();
      this.connection.setAutoCommit(true);
      ResultSet contentids=this.getContentIDs(productid);
      while (contentids.next()) {
        String contentid=contentids.getString(1);
        String contentuuid=orgContent.get(contentid);
        this.connection.setAutoCommit(false);
        if (contentuuid == null) {
          contentuuid=this.generateUUID();
          orgContent.put(contentid,contentuuid);
          this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",contentuuid,orgid,contentid);
          this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",contentuuid,contentid);
          this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",this.generateUUID(),contentuuid,contentid);
        }
        this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",productuuid,contentuuid,productid,contentid);
        this.connection.commit();
        this.connection.setAutoCommit(true);
      }
      contentids.close();
    }
    productids.close();
    ResultSet subscriptionids=this.getProductIDs(orgid);
    while (subscriptionids.next()) {
      String subid=subscriptionids.getString(1);
      String subuuid=this.generateUUID();
      this.connection.setAutoCommit(false);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,orgid,orgid,subid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",this.generateUUID(),subuuid,subid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",subuuid,subid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
      this.executeUpdate(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",subuuid,orgid,subid);
      this.connection.commit();
      this.connection.setAutoCommit(true);
    }
    subscriptionids.close();
  }
  orgids.close();
  this.connection.setAutoCommit(autocommit);
}"
49406,"/** 
 * Lookup all pools for subscriptions which are not in the given list of subscription IDs. Used for pool cleanup during refresh.
 * @param owner
 * @param expectedSubIds Full list of all expected subscription IDs.
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public List<Pool> getPoolsFromBadSubs(Owner owner,Collection<String> expectedSubIds){
  Criteria crit=currentSession().createCriteria(Pool.class).add(Restrictions.eq(""String_Node_Str"",owner));
  if (!expectedSubIds.isEmpty()) {
    crit.createAlias(""String_Node_Str"",""String_Node_Str"");
    crit.add(Restrictions.and(Restrictions.not(Restrictions.in(""String_Node_Str"",expectedSubIds)),Restrictions.isNotNull(""String_Node_Str"")));
  }
  crit.addOrder(Order.asc(""String_Node_Str""));
  return crit.list();
}","/** 
 * Lookup all pools for subscriptions which are not in the given list of subscription IDs. Used for pool cleanup during refresh.
 * @param owner
 * @param expectedSubIds Full list of all expected subscription IDs.
 * @return a list of pools for subscriptions not matching the specified subscription list
 */
@SuppressWarnings(""String_Node_Str"") public List<Pool> getPoolsFromBadSubs(Owner owner,Collection<String> expectedSubIds){
  Criteria crit=currentSession().createCriteria(Pool.class).add(Restrictions.eq(""String_Node_Str"",owner));
  if (!expectedSubIds.isEmpty()) {
    crit.createAlias(""String_Node_Str"",""String_Node_Str"");
    crit.add(Restrictions.and(Restrictions.not(Restrictions.in(""String_Node_Str"",expectedSubIds)),Restrictions.isNotNull(""String_Node_Str"")));
  }
  crit.addOrder(Order.asc(""String_Node_Str""));
  return crit.list();
}"
49407,"/** 
 * @param owner owner to lookup product for
 * @param id Product ID to lookup. (note: not the database ID)
 * @return the Product which matches the given id.
 */
@Transactional public Product lookupById(String ownerId,String productId){
  return (Product)currentSession().createCriteria(Product.class).add(Restrictions.eq(""String_Node_Str"",ownerId)).add(Restrictions.eq(""String_Node_Str"",productId)).uniqueResult();
}","/** 
 * @param ownerId The ID of the owner for which to lookup a product
 * @param productId The ID of the product to lookup. (note: not the database ID)
 * @return the Product which matches the given id.
 */
@Transactional public Product lookupById(String ownerId,String productId){
  return (Product)currentSession().createCriteria(Product.class).add(Restrictions.eq(""String_Node_Str"",ownerId)).add(Restrictions.eq(""String_Node_Str"",productId)).uniqueResult();
}"
49408,"/** 
 * Create any pools that need to be created for the given subscription. In some scenarios, due to attribute changes, pools may need to be created even though pools already exist for the subscription. A list of pre-existing pools for the given sub are provided to help this method determine if something needs to be done or not. For a genuine new subscription, the existing pools list will be empty.
 * @param sub
 * @param existingPools
 * @return
 */
public List<Pool> createPools(Subscription sub,List<Pool> existingPools){
  log.info(""String_Node_Str"" + sub);
  PoolHelper helper=new PoolHelper(this.poolManager,this.productCache,null);
  List<Pool> pools=new LinkedList<Pool>();
  Map<String,String> attributes=helper.getFlattenedAttributes(sub.getProduct());
  long quantity=calculateQuantity(sub);
  if (!hasMasterPool(existingPools)) {
    Pool newPool=new Pool(sub.getOwner(),sub.getProduct(),sub.getProvidedProducts(),quantity,sub.getStartDate(),sub.getEndDate(),sub.getContractNumber(),sub.getAccountNumber(),sub.getOrderNumber());
    if (sub.getDerivedProvidedProducts() != null) {
      newPool.getDerivedProvidedProducts().addAll(sub.getDerivedProvidedProducts());
    }
    if (sub.getDerivedProduct() != null) {
      newPool.setDerivedProduct(sub.getDerivedProduct());
    }
    for (    Branding b : sub.getBranding()) {
      newPool.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
    }
    newPool.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
    ProductAttribute virtAtt=sub.getProduct().getAttribute(""String_Node_Str"");
    if (virtAtt != null && virtAtt.getValue() != null && !virtAtt.getValue().equals(""String_Node_Str"")) {
      newPool.addAttribute(new org.candlepin.model.PoolAttribute(""String_Node_Str"",virtAtt.getValue()));
    }
    pools.add(newPool);
  }
  boolean hostLimited=attributes.containsKey(""String_Node_Str"") && attributes.get(""String_Node_Str"").equals(""String_Node_Str"");
  if (attributes.containsKey(""String_Node_Str"") && !hasBonusPool(existingPools)) {
    HashMap<String,String> virtAttributes=new HashMap<String,String>();
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    if (hostLimited || config.getBoolean(ConfigProperties.STANDALONE)) {
      virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    }
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    String virtQuantity=getVirtQuantity(attributes.get(""String_Node_Str""),quantity);
    if (virtQuantity != null) {
      Product poolProduct=sub.getProduct();
      if (sub.getDerivedProduct() != null) {
        poolProduct=sub.getDerivedProduct();
      }
      Pool derivedPool=helper.createPool(sub,poolProduct,virtQuantity,virtAttributes);
      derivedPool.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
      pools.add(derivedPool);
    }
  }
  return pools;
}","/** 
 * Create any pools that need to be created for the given subscription. In some scenarios, due to attribute changes, pools may need to be created even though pools already exist for the subscription. A list of pre-existing pools for the given sub are provided to help this method determine if something needs to be done or not. For a genuine new subscription, the existing pools list will be empty.
 * @param sub
 * @param existingPools
 * @return
 */
public List<Pool> createPools(Subscription sub,List<Pool> existingPools){
  log.info(""String_Node_Str"" + sub);
  PoolHelper helper=new PoolHelper(this.poolManager,this.productCache,null);
  List<Pool> pools=new LinkedList<Pool>();
  Map<String,String> attributes=helper.getFlattenedAttributes(sub.getProduct());
  long quantity=calculateQuantity(sub);
  if (!hasMasterPool(existingPools)) {
    Pool newPool=new Pool(sub.getOwner(),sub.getProduct(),new HashSet<Product>(sub.getProvidedProducts()),quantity,sub.getStartDate(),sub.getEndDate(),sub.getContractNumber(),sub.getAccountNumber(),sub.getOrderNumber());
    if (sub.getDerivedProvidedProducts() != null) {
      newPool.getDerivedProvidedProducts().addAll(sub.getDerivedProvidedProducts());
    }
    if (sub.getDerivedProduct() != null) {
      newPool.setDerivedProduct(sub.getDerivedProduct());
    }
    for (    Branding b : sub.getBranding()) {
      newPool.getBranding().add(new Branding(b.getProductId(),b.getType(),b.getName()));
    }
    newPool.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
    ProductAttribute virtAtt=sub.getProduct().getAttribute(""String_Node_Str"");
    if (virtAtt != null && virtAtt.getValue() != null && !virtAtt.getValue().equals(""String_Node_Str"")) {
      newPool.addAttribute(new org.candlepin.model.PoolAttribute(""String_Node_Str"",virtAtt.getValue()));
    }
    pools.add(newPool);
  }
  boolean hostLimited=attributes.containsKey(""String_Node_Str"") && attributes.get(""String_Node_Str"").equals(""String_Node_Str"");
  if (attributes.containsKey(""String_Node_Str"") && !hasBonusPool(existingPools)) {
    HashMap<String,String> virtAttributes=new HashMap<String,String>();
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    if (hostLimited || config.getBoolean(ConfigProperties.STANDALONE)) {
      virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    }
    virtAttributes.put(""String_Node_Str"",""String_Node_Str"");
    String virtQuantity=getVirtQuantity(attributes.get(""String_Node_Str""),quantity);
    if (virtQuantity != null) {
      Product poolProduct=sub.getProduct();
      if (sub.getDerivedProduct() != null) {
        poolProduct=sub.getDerivedProduct();
      }
      Pool derivedPool=helper.createPool(sub,poolProduct,virtQuantity,virtAttributes);
      derivedPool.setSourceSubscription(new SourceSubscription(sub.getId(),""String_Node_Str""));
      pools.add(derivedPool);
    }
  }
  return pools;
}"
49409,"@Override @Transactional public void regenerateCertificatesOf(String productUuid,boolean lazy){
  Product product=this.productCurator.find(productUuid);
  if (product != null) {
    this.regenerateCertificatesOf(product.getOwner(),product.getId(),lazy);
  }
}","@Override @Transactional public void regenerateCertificatesOf(Owner owner,String productId,boolean lazy){
  List<Pool> poolsForProduct=this.listAvailableEntitlementPools(null,null,owner,productId,new Date(),false,false,new PoolFilterBuilder(),null).getPageData();
  for (  Pool pool : poolsForProduct) {
    regenerateCertificatesOf(pool.getEntitlements(),lazy);
  }
}"
49410,"void regenerateCertificatesOf(String productUuid,boolean lazy);","void regenerateCertificatesOf(Owner owner,String productId,boolean lazy);"
49411,"@Override public void toExecute(JobExecutionContext arg0) throws JobExecutionException {
  String productUuid=arg0.getJobDetail().getJobDataMap().getString(PROD_UUID);
  boolean lazy=arg0.getJobDetail().getJobDataMap().getBoolean(LAZY_REGEN);
  this.poolManager.regenerateCertificatesOf(productUuid,lazy);
}","@Override public void toExecute(JobExecutionContext arg0) throws JobExecutionException {
  String productId=arg0.getJobDetail().getJobDataMap().getString(PROD_ID);
  boolean lazy=arg0.getJobDetail().getJobDataMap().getBoolean(LAZY_REGEN);
}"
49412,"/** 
 * Regenerates the Entitlement Certificates for a Product
 * @return a JobDetail object
 * @httpcode 202
 */
@PUT @Path(""String_Node_Str"") public JobDetail regenerateEntitlementCertificatesForProduct(@PathParam(""String_Node_Str"") String productId,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") boolean lazyRegen){
  prodAdapter.purgeCache(Arrays.asList(productId));
  JobDataMap map=new JobDataMap();
  map.put(RegenProductEntitlementCertsJob.PROD_UUID,productId);
  map.put(RegenProductEntitlementCertsJob.LAZY_REGEN,lazyRegen);
  JobDetail detail=newJob(RegenProductEntitlementCertsJob.class).withIdentity(""String_Node_Str"" + Util.generateUUID()).usingJobData(map).build();
  return detail;
}","/** 
 * Regenerates the Entitlement Certificates for a Product
 * @return a JobDetail object
 * @httpcode 202
 */
@PUT @Path(""String_Node_Str"") public JobDetail regenerateEntitlementCertificatesForProduct(@PathParam(""String_Node_Str"") String productId,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") boolean lazyRegen){
  prodAdapter.purgeCache(Arrays.asList(productId));
  JobDataMap map=new JobDataMap();
  map.put(RegenProductEntitlementCertsJob.PROD_ID,productId);
  map.put(RegenProductEntitlementCertsJob.LAZY_REGEN,lazyRegen);
  JobDetail detail=newJob(RegenProductEntitlementCertsJob.class).withIdentity(""String_Node_Str"" + Util.generateUUID()).usingJobData(map).build();
  return detail;
}"
49413,"@Test public void create(){
  envContent=envContentCurator.lookupByEnvironmentAndContent(e,c.getId());
  assertNotNull(envContent);
  e=envCurator.find(e.getId());
  assertEquals(1,e.getEnvironmentContent().size());
  assertEquals(1,envContentCurator.lookupByContent(c.getId()).size());
}","@Test public void create(){
  envContent=envContentCurator.lookupByEnvironmentAndContent(e,c.getId());
  assertNotNull(envContent);
  e=envCurator.find(e.getId());
  assertEquals(1,e.getEnvironmentContent().size());
  assertEquals(1,envContentCurator.lookupByContent(owner,c.getId()).size());
}"
49414,"@Test public void testGetProductIdFromContentId(){
  Product p=createTestProduct();
  Content content=new Content(this.owner,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  p.addContent(content);
  contentCurator.create(content);
  productCurator.create(p);
  List<String> contentUuids=new LinkedList<String>();
  contentUuids.add(content.getUuid());
  List<String> productIds=productCurator.getProductsWithContentUuids(contentUuids);
  assertEquals(1,productIds.size());
  assertEquals(p.getUuid(),productIds.get(0));
}","@Test public void testGetProductIdFromContentId(){
  Product p=createTestProduct();
  Content content=new Content(this.owner,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  p.addContent(content);
  contentCurator.create(content);
  productCurator.create(p);
  List<String> contentUuids=new LinkedList<String>();
  contentUuids.add(content.getUuid());
  List<Product> products=productCurator.getProductsWithContent(contentUuids);
  assertEquals(1,products.size());
  assertEquals(p,products.get(0));
}"
49415,"@Test public void execute() throws Exception {
  CandlepinPoolManager pm=mock(CandlepinPoolManager.class);
  JobExecutionContext jec=mock(JobExecutionContext.class);
  JobDetail detail=mock(JobDetail.class);
  JobDataMap jdm=mock(JobDataMap.class);
  when(jdm.getString(eq(""String_Node_Str""))).thenReturn(""String_Node_Str"");
  when(jdm.getBoolean(eq(""String_Node_Str""))).thenReturn(true);
  when(detail.getJobDataMap()).thenReturn(jdm);
  when(jec.getJobDetail()).thenReturn(detail);
  RegenProductEntitlementCertsJob recj=new RegenProductEntitlementCertsJob(pm);
  recj.execute(jec);
  verify(pm).regenerateCertificatesOf(eq(""String_Node_Str""),eq(true));
}","@Test public void execute() throws Exception {
  CandlepinPoolManager pm=mock(CandlepinPoolManager.class);
  JobExecutionContext jec=mock(JobExecutionContext.class);
  JobDetail detail=mock(JobDetail.class);
  JobDataMap jdm=mock(JobDataMap.class);
  when(jdm.getString(eq(""String_Node_Str""))).thenReturn(""String_Node_Str"");
  when(jdm.getBoolean(eq(""String_Node_Str""))).thenReturn(true);
  when(detail.getJobDataMap()).thenReturn(jdm);
  when(jec.getJobDetail()).thenReturn(detail);
  RegenProductEntitlementCertsJob recj=new RegenProductEntitlementCertsJob(pm);
  recj.execute(jec);
}"
49416,"@Test public void brandingDidntChange(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  Branding b1=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Branding b2=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  s.getBranding().add(b1);
  s.getBranding().add(b2);
  when(productAdapterMock.getProductById(s.getProduct().getUuid())).thenReturn(s.getProduct());
  Pool p=TestUtil.copyFromSub(s);
  List<Pool> existingPools=Arrays.asList(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(0,updates.size());
}","@Test public void brandingDidntChange(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  Branding b1=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Branding b2=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  s.getBranding().add(b1);
  s.getBranding().add(b2);
  when(productAdapterMock.getProductById(s.getProduct().getOwner(),s.getProduct().getId())).thenReturn(s.getProduct());
  Pool p=TestUtil.copyFromSub(s);
  List<Pool> existingPools=Arrays.asList(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(0,updates.size());
}"
49417,"@Test public void productIdChangeOnProductPoolAttributeTriggersUpdate(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  String testAttributeKey=""String_Node_Str"";
  s.getProduct().setAttribute(testAttributeKey,""String_Node_Str"");
  Pool p=TestUtil.copyFromSub(s);
  p.getProduct().setAttribute(testAttributeKey,""String_Node_Str"");
  String expectedProductId=""String_Node_Str"";
  s.getProduct().setId(expectedProductId);
  when(productAdapterMock.getProductById(s.getProduct().getUuid())).thenReturn(s.getProduct());
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  Pool updatedPool=update.getPool();
  assertEquals(s.getProduct(),updatedPool.getProduct());
  assertTrue(updatedPool.getProduct().hasAttribute(testAttributeKey));
}","@Test public void productIdChangeOnProductPoolAttributeTriggersUpdate(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  String testAttributeKey=""String_Node_Str"";
  s.getProduct().setAttribute(testAttributeKey,""String_Node_Str"");
  Pool p=TestUtil.copyFromSub(s);
  p.getProduct().setAttribute(testAttributeKey,""String_Node_Str"");
  String expectedProductId=""String_Node_Str"";
  s.getProduct().setId(expectedProductId);
  when(productAdapterMock.getProductById(s.getProduct().getOwner(),s.getProduct().getId())).thenReturn(s.getProduct());
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  Pool updatedPool=update.getPool();
  assertEquals(s.getProduct(),updatedPool.getProduct());
  assertTrue(updatedPool.getProduct().hasAttribute(testAttributeKey));
}"
49418,"private Subscription createVirtLimitSub(String productId,int quantity,int virtLimit){
  Product product=new Product(productId,productId,owner);
  product.setAttribute(""String_Node_Str"",Integer.toString(virtLimit));
  when(productAdapterMock.getProductById(productId)).thenReturn(product);
  Subscription s=TestUtil.createSubscription(product);
  s.setQuantity(new Long(quantity));
  return s;
}","private Subscription createVirtLimitSub(String productId,int quantity,int virtLimit){
  Product product=new Product(productId,productId,owner);
  product.setAttribute(""String_Node_Str"",Integer.toString(virtLimit));
  when(productAdapterMock.getProductById(product.getOwner(),product.getId())).thenReturn(product);
  Subscription s=TestUtil.createSubscription(product);
  s.setQuantity(new Long(quantity));
  return s;
}"
49419,"@Test public void brandingCopiedWhenCreatingPools(){
  Product product=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  Branding b1=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Branding b2=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  sub.getBranding().add(b1);
  sub.getBranding().add(b2);
  when(this.productAdapterMock.getProductById(anyString())).thenReturn(product);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertEquals(2,resultPool.getBranding().size());
  assertTrue(resultPool.getBranding().contains(b1));
  assertTrue(resultPool.getBranding().contains(b2));
}","@Test public void brandingCopiedWhenCreatingPools(){
  Product product=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  Branding b1=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Branding b2=new Branding(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  sub.getBranding().add(b1);
  sub.getBranding().add(b2);
  when(this.productAdapterMock.getProductById(product.getOwner(),product.getId())).thenReturn(product);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertEquals(2,resultPool.getBranding().size());
  assertTrue(resultPool.getBranding().contains(b1));
  assertTrue(resultPool.getBranding().contains(b2));
}"
49420,"@Test public void subProvidedProductsCopiedOntoPoolWhenCreatingNewPool(){
  Product product=TestUtil.createProduct(owner);
  Product subProduct=TestUtil.createProduct(owner);
  Product subProvidedProduct=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  sub.setDerivedProduct(subProduct);
  Set<Product> subProvided=new HashSet<Product>();
  subProvided.add(subProvidedProduct);
  sub.setDerivedProvidedProducts(subProvided);
  when(this.productAdapterMock.getProductById(anyString())).thenReturn(product);
  when(this.productAdapterMock.getProductById(anyString())).thenReturn(subProduct);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertEquals(1,resultPool.getDerivedProvidedProducts().size());
}","@Test public void subProvidedProductsCopiedOntoPoolWhenCreatingNewPool(){
  Product product=TestUtil.createProduct(owner);
  Product subProduct=TestUtil.createProduct(owner);
  Product subProvidedProduct=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  sub.setDerivedProduct(subProduct);
  Set<Product> subProvided=new HashSet<Product>();
  subProvided.add(subProvidedProduct);
  sub.setDerivedProvidedProducts(subProvided);
  when(this.productAdapterMock.getProductById(product.getOwner(),product.getId())).thenReturn(product);
  when(this.productAdapterMock.getProductById(subProduct.getOwner(),subProduct.getId())).thenReturn(subProduct);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertEquals(1,resultPool.getDerivedProvidedProducts().size());
}"
49421,"@Test public void productAttributesCopiedOntoPoolWhenCreatingNewPool(){
  Product product=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  String testAttributeKey=""String_Node_Str"";
  String expectedAttributeValue=""String_Node_Str"";
  sub.getProduct().setAttribute(testAttributeKey,expectedAttributeValue);
  when(this.productAdapterMock.getProductById(anyString())).thenReturn(product);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertNotNull(resultPool.getProduct());
  assertTrue(resultPool.getProduct().hasAttribute(testAttributeKey));
  assertEquals(expectedAttributeValue,resultPool.getProduct().getAttributeValue(testAttributeKey));
}","@Test public void productAttributesCopiedOntoPoolWhenCreatingNewPool(){
  Product product=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  String testAttributeKey=""String_Node_Str"";
  String expectedAttributeValue=""String_Node_Str"";
  sub.getProduct().setAttribute(testAttributeKey,expectedAttributeValue);
  when(this.productAdapterMock.getProductById(product.getOwner(),product.getId())).thenReturn(product);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertNotNull(resultPool.getProduct());
  assertTrue(resultPool.getProduct().hasAttribute(testAttributeKey));
  assertEquals(expectedAttributeValue,resultPool.getProduct().getAttributeValue(testAttributeKey));
}"
49422,"@Test public void virtOnlyQuantityChanged(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  s.getProduct().addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  s.setQuantity(10L);
  when(productAdapterMock.getProductById(s.getProduct().getUuid())).thenReturn(s.getProduct());
  Pool p=TestUtil.copyFromSub(s);
  p.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p.setQuantity(40L);
  List<Pool> existingPools=Arrays.asList(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getProductAttributesChanged());
  assertTrue(update.getQuantityChanged());
  assertEquals(Long.valueOf(50),update.getPool().getQuantity());
}","@Test public void virtOnlyQuantityChanged(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  s.getProduct().addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  s.setQuantity(10L);
  when(productAdapterMock.getProductById(s.getProduct().getOwner(),s.getProduct().getId())).thenReturn(s.getProduct());
  Pool p=TestUtil.copyFromSub(s);
  p.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p.setQuantity(40L);
  List<Pool> existingPools=Arrays.asList(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  assertFalse(update.getProductsChanged());
  assertFalse(update.getDatesChanged());
  assertFalse(update.getProductAttributesChanged());
  assertTrue(update.getQuantityChanged());
  assertEquals(Long.valueOf(50),update.getPool().getQuantity());
}"
49423,"@Test public void updatePoolWithModifiedProductAttributes(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  Pool p=TestUtil.copyFromSub(s);
  String testAttributeKey=""String_Node_Str"";
  String expectedAttributeValue=""String_Node_Str"";
  p.getProduct().setAttribute(testAttributeKey,""String_Node_Str"");
  s.getProduct().setAttribute(testAttributeKey,expectedAttributeValue);
  when(productAdapterMock.getProductById(s.getProduct().getUuid())).thenReturn(s.getProduct());
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  Pool updatedPool=update.getPool();
  assertNotNull(updatedPool.getProduct());
  assertTrue(updatedPool.getProduct().hasAttribute(testAttributeKey));
  assertEquals(expectedAttributeValue,updatedPool.getProduct().getAttributeValue(testAttributeKey));
}","@Test public void updatePoolWithModifiedProductAttributes(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  Pool p=TestUtil.copyFromSub(s);
  String testAttributeKey=""String_Node_Str"";
  String expectedAttributeValue=""String_Node_Str"";
  p.getProduct().setAttribute(testAttributeKey,""String_Node_Str"");
  s.getProduct().setAttribute(testAttributeKey,expectedAttributeValue);
  when(productAdapterMock.getProductById(s.getProduct().getOwner(),s.getProduct().getId())).thenReturn(s.getProduct());
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  Pool updatedPool=update.getPool();
  assertNotNull(updatedPool.getProduct());
  assertTrue(updatedPool.getProduct().hasAttribute(testAttributeKey));
  assertEquals(expectedAttributeValue,updatedPool.getProduct().getAttributeValue(testAttributeKey));
}"
49424,"@Test public void subProductIdCopiedOntoPoolWhenCreatingNewPool(){
  Product product=TestUtil.createProduct(owner);
  Product subProduct=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  sub.setDerivedProduct(subProduct);
  when(this.productAdapterMock.getProductById(anyString())).thenReturn(product);
  when(this.productAdapterMock.getProductById(anyString())).thenReturn(subProduct);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertEquals(subProduct,resultPool.getDerivedProduct());
}","@Test public void subProductIdCopiedOntoPoolWhenCreatingNewPool(){
  Product product=TestUtil.createProduct(owner);
  Product subProduct=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  sub.setDerivedProduct(subProduct);
  when(this.productAdapterMock.getProductById(product.getOwner(),product.getId())).thenReturn(product);
  when(this.productAdapterMock.getProductById(subProduct.getOwner(),subProduct.getId())).thenReturn(subProduct);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertEquals(subProduct,resultPool.getDerivedProduct());
}"
49425,"@Test public void subProductAttributesCopiedOntoPoolWhenCreatingNewPool(){
  Product product=TestUtil.createProduct(owner);
  Product subProduct=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  sub.setDerivedProduct(subProduct);
  String testAttributeKey=""String_Node_Str"";
  String expectedAttributeValue=""String_Node_Str"";
  subProduct.setAttribute(testAttributeKey,expectedAttributeValue);
  when(this.productAdapterMock.getProductById(anyString())).thenReturn(product);
  when(this.productAdapterMock.getProductById(anyString())).thenReturn(subProduct);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertNotNull(resultPool.getDerivedProduct());
  assertTrue(resultPool.getDerivedProduct().hasAttribute(testAttributeKey));
  assertEquals(expectedAttributeValue,resultPool.getDerivedProduct().getAttributeValue(testAttributeKey));
}","@Test public void subProductAttributesCopiedOntoPoolWhenCreatingNewPool(){
  Product product=TestUtil.createProduct(owner);
  Product subProduct=TestUtil.createProduct(owner);
  Subscription sub=TestUtil.createSubscription(owner,product);
  sub.setDerivedProduct(subProduct);
  String testAttributeKey=""String_Node_Str"";
  String expectedAttributeValue=""String_Node_Str"";
  subProduct.setAttribute(testAttributeKey,expectedAttributeValue);
  when(this.productAdapterMock.getProductById(product.getOwner(),product.getId())).thenReturn(product);
  when(this.productAdapterMock.getProductById(subProduct.getOwner(),subProduct.getId())).thenReturn(subProduct);
  List<Pool> pools=this.poolRules.createPools(sub);
  assertEquals(1,pools.size());
  Pool resultPool=pools.get(0);
  assertNotNull(resultPool.getDerivedProduct());
  assertTrue(resultPool.getDerivedProduct().hasAttribute(testAttributeKey));
  assertEquals(expectedAttributeValue,resultPool.getDerivedProduct().getAttributeValue(testAttributeKey));
}"
49426,"@Test public void dontUpdateVirtOnlyNoVirtLimit(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  s.setQuantity(10L);
  when(productAdapterMock.getProductById(s.getProduct().getUuid())).thenReturn(s.getProduct());
  Pool p=TestUtil.copyFromSub(s);
  p.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p.setQuantity(10L);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(0,updates.size());
}","@Test public void dontUpdateVirtOnlyNoVirtLimit(){
  when(configMock.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  s.setQuantity(10L);
  when(productAdapterMock.getProductById(s.getProduct().getOwner(),s.getProduct().getId())).thenReturn(s.getProduct());
  Pool p=TestUtil.copyFromSub(s);
  p.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p.setQuantity(10L);
  List<Pool> existingPools=new LinkedList<Pool>();
  existingPools.add(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(0,updates.size());
}"
49427,"@Test public void updatePoolWithNewProductAttributes(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  Pool p=TestUtil.copyFromSub(s);
  String testAttributeKey=""String_Node_Str"";
  s.getProduct().setAttribute(testAttributeKey,""String_Node_Str"");
  when(productAdapterMock.getProductById(s.getProduct().getUuid())).thenReturn(s.getProduct());
  List<Pool> existingPools=Arrays.asList(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  Pool updatedPool=update.getPool();
  assertNotNull(updatedPool.getProduct());
  assertTrue(updatedPool.getProduct().hasAttribute(testAttributeKey));
}","@Test public void updatePoolWithNewProductAttributes(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  Pool p=TestUtil.copyFromSub(s);
  String testAttributeKey=""String_Node_Str"";
  s.getProduct().setAttribute(testAttributeKey,""String_Node_Str"");
  when(productAdapterMock.getProductById(s.getProduct().getOwner(),s.getProduct().getId())).thenReturn(s.getProduct());
  List<Pool> existingPools=Arrays.asList(p);
  List<PoolUpdate> updates=this.poolRules.updatePools(s,existingPools);
  assertEquals(1,updates.size());
  PoolUpdate update=updates.get(0);
  Pool updatedPool=update.getPool();
  assertNotNull(updatedPool.getProduct());
  assertTrue(updatedPool.getProduct().hasAttribute(testAttributeKey));
}"
49428,"private Subscription createVirtOnlySub(String productId,int quantity){
  Product product=new Product(productId,productId,owner);
  product.setAttribute(""String_Node_Str"",""String_Node_Str"");
  when(productAdapterMock.getProductById(productId)).thenReturn(product);
  Subscription s=TestUtil.createSubscription(product);
  s.setQuantity(new Long(quantity));
  return s;
}","private Subscription createVirtOnlySub(String productId,int quantity){
  Product product=new Product(productId,productId,owner);
  product.setAttribute(""String_Node_Str"",""String_Node_Str"");
  when(productAdapterMock.getProductById(product.getOwner(),product.getId())).thenReturn(product);
  Subscription s=TestUtil.createSubscription(product);
  s.setQuantity(new Long(quantity));
  return s;
}"
49429,"private Subscription createSubscriptionWithSubProduct(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  Product subProd=TestUtil.createProduct(owner);
  s.setDerivedProduct(subProd);
  when(productAdapterMock.getProductById(s.getProduct().getUuid())).thenReturn(s.getProduct());
  when(productAdapterMock.getProductById(s.getDerivedProduct().getUuid())).thenReturn(s.getDerivedProduct());
  return s;
}","private Subscription createSubscriptionWithSubProduct(){
  Subscription s=TestUtil.createSubscription(owner,TestUtil.createProduct(owner));
  Product subProd=TestUtil.createProduct(owner);
  s.setDerivedProduct(subProd);
  when(productAdapterMock.getProductById(s.getProduct().getOwner(),s.getProduct().getId())).thenReturn(s.getProduct());
  when(productAdapterMock.getProductById(s.getDerivedProduct().getOwner(),s.getDerivedProduct().getId())).thenReturn(s.getDerivedProduct());
  return s;
}"
49430,"protected Subscription createVirtLimitSub(String productId,int quantity,String virtLimit){
  Product product=new Product(productId,productId,owner);
  product.setAttribute(""String_Node_Str"",virtLimit);
  when(prodAdapter.getProductById(productId)).thenReturn(product);
  Subscription s=TestUtil.createSubscription(product);
  s.setQuantity(new Long(quantity));
  s.setId(""String_Node_Str"");
  return s;
}","protected Subscription createVirtLimitSub(String productId,int quantity,String virtLimit){
  Product product=new Product(productId,productId,owner);
  product.setAttribute(""String_Node_Str"",virtLimit);
  when(prodAdapter.getProductById(owner,productId)).thenReturn(product);
  Subscription s=TestUtil.createSubscription(product);
  s.setQuantity(new Long(quantity));
  s.setId(""String_Node_Str"");
  return s;
}"
49431,"protected Pool setupVirtLimitPool(){
  Product product=new Product(productId,""String_Node_Str"",owner);
  Pool pool=TestUtil.createPool(owner,product);
  pool.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  pool.setId(""String_Node_Str"" + TestUtil.randomInt());
  when(this.prodAdapter.getProductById(productId)).thenReturn(product);
  return pool;
}","protected Pool setupVirtLimitPool(){
  Product product=new Product(productId,""String_Node_Str"",owner);
  Pool pool=TestUtil.createPool(owner,product);
  pool.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  pool.setId(""String_Node_Str"" + TestUtil.randomInt());
  when(this.prodAdapter.getProductById(owner,productId)).thenReturn(product);
  return pool;
}"
49432,"@Test public void hostedVirtLimitWithHostLimitedCreatesBonusPoolsOnBind(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  s.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  Entitlement e=new Entitlement(physicalPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,productCache,e);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock).createPool(any(Pool.class));
}","@Test public void hostedVirtLimitWithHostLimitedCreatesBonusPoolsOnBind(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  s.getProduct().setAttribute(""String_Node_Str"",""String_Node_Str"");
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  Entitlement e=new Entitlement(physicalPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,e);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock).createPool(any(Pool.class));
}"
49433,"@Test public void hostedVirtLimitUnlimitedBonusPoolQuantity(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  Pool virtBonusPool=pools.get(1);
  virtBonusPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  assertEquals(new Long(-1),virtBonusPool.getQuantity());
  assertEquals(""String_Node_Str"",virtBonusPool.getAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",virtBonusPool.getProduct().getAttributeValue(""String_Node_Str""));
  Entitlement e=new Entitlement(physicalPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,productCache,e);
  List<Pool> poolList=new ArrayList<Pool>();
  poolList.add(virtBonusPool);
  when(poolManagerMock.lookupBySubscriptionId(eq(physicalPool.getSubscriptionId()))).thenReturn(poolList);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
}","@Test public void hostedVirtLimitUnlimitedBonusPoolQuantity(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  Pool virtBonusPool=pools.get(1);
  virtBonusPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  assertEquals(new Long(-1),virtBonusPool.getQuantity());
  assertEquals(""String_Node_Str"",virtBonusPool.getAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",virtBonusPool.getProduct().getAttributeValue(""String_Node_Str""));
  Entitlement e=new Entitlement(physicalPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,e);
  List<Pool> poolList=new ArrayList<Pool>();
  poolList.add(virtBonusPool);
  when(poolManagerMock.lookupBySubscriptionId(eq(physicalPool.getSubscriptionId()))).thenReturn(poolList);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
}"
49434,"@Test public void hostedVirtLimitDoesNotAlterQuantitiesForHostLimited(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  consumer.setType(new ConsumerType(ConsumerTypeEnum.CANDLEPIN));
  Pool virtBonusPool=setupVirtLimitPool();
  virtBonusPool.setQuantity(100L);
  virtBonusPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  virtBonusPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  virtBonusPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  virtBonusPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Entitlement e=new Entitlement(virtBonusPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,productCache,e);
  List<Pool> poolList=new ArrayList<Pool>();
  poolList.add(virtBonusPool);
  when(poolManagerMock.lookupBySubscriptionId(eq(virtBonusPool.getSubscriptionId()))).thenReturn(poolList);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(eq(virtBonusPool),eq(-10L));
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(eq(virtBonusPool),eq(10L));
}","@Test public void hostedVirtLimitDoesNotAlterQuantitiesForHostLimited(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  consumer.setType(new ConsumerType(ConsumerTypeEnum.CANDLEPIN));
  Pool virtBonusPool=setupVirtLimitPool();
  virtBonusPool.setQuantity(100L);
  virtBonusPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  virtBonusPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  virtBonusPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  virtBonusPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Entitlement e=new Entitlement(virtBonusPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,e);
  List<Pool> poolList=new ArrayList<Pool>();
  poolList.add(virtBonusPool);
  when(poolManagerMock.lookupBySubscriptionId(eq(virtBonusPool.getSubscriptionId()))).thenReturn(poolList);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(eq(virtBonusPool),eq(-10L));
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(eq(virtBonusPool),eq(10L));
}"
49435,"@Test public void exportAllPhysicalZeroBonusPoolQuantity(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  consumer.setType(new ConsumerType(ConsumerTypeEnum.CANDLEPIN));
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  Pool virtBonusPool=pools.get(1);
  virtBonusPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  assertEquals(new Long(-1),virtBonusPool.getQuantity());
  assertEquals(""String_Node_Str"",virtBonusPool.getAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",virtBonusPool.getProduct().getAttributeValue(""String_Node_Str""));
  Entitlement e=new Entitlement(physicalPool,consumer,10);
  physicalPool.setConsumed(10L);
  physicalPool.setExported(10L);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,productCache,e);
  List<Pool> poolList=new ArrayList<Pool>();
  poolList.add(virtBonusPool);
  when(poolManagerMock.lookupBySubscriptionId(eq(physicalPool.getSubscriptionId()))).thenReturn(poolList);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock).setPoolQuantity(eq(virtBonusPool),eq(0L));
  virtBonusPool.setQuantity(0L);
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock).setPoolQuantity(eq(virtBonusPool),eq(-1L));
}","@Test public void exportAllPhysicalZeroBonusPoolQuantity(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  consumer.setType(new ConsumerType(ConsumerTypeEnum.CANDLEPIN));
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  Pool virtBonusPool=pools.get(1);
  virtBonusPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  assertEquals(new Long(-1),virtBonusPool.getQuantity());
  assertEquals(""String_Node_Str"",virtBonusPool.getAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",virtBonusPool.getProduct().getAttributeValue(""String_Node_Str""));
  Entitlement e=new Entitlement(physicalPool,consumer,10);
  physicalPool.setConsumed(10L);
  physicalPool.setExported(10L);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,e);
  List<Pool> poolList=new ArrayList<Pool>();
  poolList.add(virtBonusPool);
  when(poolManagerMock.lookupBySubscriptionId(eq(physicalPool.getSubscriptionId()))).thenReturn(poolList);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock).setPoolQuantity(eq(virtBonusPool),eq(0L));
  virtBonusPool.setQuantity(0L);
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock).setPoolQuantity(eq(virtBonusPool),eq(-1L));
}"
49436,"@Test public void noBonusPoolsForHostedNonDistributorBinds(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  Pool virtBonusPool=pools.get(1);
  virtBonusPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  assertEquals(new Long(-1),virtBonusPool.getQuantity());
  assertEquals(""String_Node_Str"",virtBonusPool.getAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",virtBonusPool.getProduct().getAttributeValue(""String_Node_Str""));
  Entitlement e=new Entitlement(physicalPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,productCache,e);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).createPool(any(Pool.class));
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  verify(poolManagerMock,never()).setPoolQuantity(any(Pool.class),anyLong());
}","@Test public void noBonusPoolsForHostedNonDistributorBinds(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  Pool virtBonusPool=pools.get(1);
  virtBonusPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  assertEquals(new Long(-1),virtBonusPool.getQuantity());
  assertEquals(""String_Node_Str"",virtBonusPool.getAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",virtBonusPool.getProduct().getAttributeValue(""String_Node_Str""));
  Entitlement e=new Entitlement(physicalPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,e);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).createPool(any(Pool.class));
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  verify(poolManagerMock,never()).setPoolQuantity(any(Pool.class),anyLong());
}"
49437,"@Test public void hostedVirtLimitAltersBonusPoolQuantity(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  consumer.setType(new ConsumerType(ConsumerTypeEnum.CANDLEPIN));
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  Pool virtBonusPool=pools.get(1);
  virtBonusPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  assertEquals(new Long(100),virtBonusPool.getQuantity());
  assertEquals(""String_Node_Str"",virtBonusPool.getAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",virtBonusPool.getProduct().getAttributeValue(""String_Node_Str""));
  Entitlement e=new Entitlement(physicalPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,productCache,e);
  List<Pool> poolList=new ArrayList<Pool>();
  poolList.add(virtBonusPool);
  when(poolManagerMock.lookupBySubscriptionId(eq(physicalPool.getSubscriptionId()))).thenReturn(poolList);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock).updatePoolQuantity(eq(virtBonusPool),eq(-10L));
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock).updatePoolQuantity(eq(virtBonusPool),eq(10L));
}","@Test public void hostedVirtLimitAltersBonusPoolQuantity(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(false);
  Subscription s=createVirtLimitSub(""String_Node_Str"",10,""String_Node_Str"");
  consumer.setType(new ConsumerType(ConsumerTypeEnum.CANDLEPIN));
  List<Pool> pools=poolRules.createPools(s);
  assertEquals(2,pools.size());
  Pool physicalPool=pools.get(0);
  physicalPool.setId(""String_Node_Str"");
  Pool virtBonusPool=pools.get(1);
  virtBonusPool.setId(""String_Node_Str"");
  assertEquals(new Long(10),physicalPool.getQuantity());
  assertEquals(0,physicalPool.getAttributes().size());
  assertEquals(new Long(100),virtBonusPool.getQuantity());
  assertEquals(""String_Node_Str"",virtBonusPool.getAttributeValue(""String_Node_Str""));
  assertEquals(""String_Node_Str"",virtBonusPool.getProduct().getAttributeValue(""String_Node_Str""));
  Entitlement e=new Entitlement(physicalPool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,e);
  List<Pool> poolList=new ArrayList<Pool>();
  poolList.add(virtBonusPool);
  when(poolManagerMock.lookupBySubscriptionId(eq(physicalPool.getSubscriptionId()))).thenReturn(poolList);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock).updatePoolQuantity(eq(virtBonusPool),eq(-10L));
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock).updatePoolQuantity(eq(virtBonusPool),eq(10L));
}"
49438,"@Test public void postEntitlement(){
  Consumer c=mock(Consumer.class);
  PoolHelper ph=mock(PoolHelper.class);
  Entitlement e=mock(Entitlement.class);
  ConsumerType type=mock(ConsumerType.class);
  Pool pool=mock(Pool.class);
  Product product=mock(Product.class);
  when(e.getPool()).thenReturn(pool);
  when(e.getConsumer()).thenReturn(c);
  when(c.getType()).thenReturn(type);
  when(type.isManifest()).thenReturn(true);
  when(pool.getProductId()).thenReturn(""String_Node_Str"");
  when(prodAdapter.getProductById(eq(""String_Node_Str""))).thenReturn(product);
  when(product.getAttributes()).thenReturn(new HashSet<ProductAttribute>());
  when(pool.getAttributes()).thenReturn(new HashSet<PoolAttribute>());
  assertEquals(ph,enforcer.postEntitlement(c,ph,e));
}","@Test public void postEntitlement(){
  Consumer c=mock(Consumer.class);
  PoolHelper ph=mock(PoolHelper.class);
  Entitlement e=mock(Entitlement.class);
  ConsumerType type=mock(ConsumerType.class);
  Pool pool=mock(Pool.class);
  Product product=mock(Product.class);
  Owner owner=mock(Owner.class);
  when(e.getPool()).thenReturn(pool);
  when(e.getConsumer()).thenReturn(c);
  when(c.getType()).thenReturn(type);
  when(type.isManifest()).thenReturn(true);
  when(pool.getProductId()).thenReturn(""String_Node_Str"");
  when(prodAdapter.getProductById(eq(owner),eq(""String_Node_Str""))).thenReturn(product);
  when(product.getAttributes()).thenReturn(new HashSet<ProductAttribute>());
  when(pool.getAttributes()).thenReturn(new HashSet<PoolAttribute>());
  assertEquals(ph,enforcer.postEntitlement(c,ph,e));
}"
49439,"@Test public void noSubPoolsForDistributorBinds(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  consumer.setType(new ConsumerType(ConsumerTypeEnum.CANDLEPIN));
  Pool pool=setupVirtLimitPool();
  Entitlement e=new Entitlement(pool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,productCache,e);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).createPool(any(Pool.class));
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  verify(poolManagerMock,never()).setPoolQuantity(any(Pool.class),anyLong());
}","@Test public void noSubPoolsForDistributorBinds(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  consumer.setType(new ConsumerType(ConsumerTypeEnum.CANDLEPIN));
  Pool pool=setupVirtLimitPool();
  Entitlement e=new Entitlement(pool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,e);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).createPool(any(Pool.class));
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  verify(poolManagerMock,never()).setPoolQuantity(any(Pool.class),anyLong());
}"
49440,"@Test public void noSubPoolsForGuestBinds(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool pool=setupVirtLimitPool();
  consumer.setFact(""String_Node_Str"",""String_Node_Str"");
  Entitlement e=new Entitlement(pool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,productCache,e);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).createPool(any(Pool.class));
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  verify(poolManagerMock,never()).setPoolQuantity(any(Pool.class),anyLong());
}","@Test public void noSubPoolsForGuestBinds(){
  when(config.getBoolean(ConfigProperties.STANDALONE)).thenReturn(true);
  Pool pool=setupVirtLimitPool();
  consumer.setFact(""String_Node_Str"",""String_Node_Str"");
  Entitlement e=new Entitlement(pool,consumer,1);
  PoolHelper postHelper=new PoolHelper(poolManagerMock,e);
  enforcer.postEntitlement(consumer,postHelper,e);
  verify(poolManagerMock,never()).createPool(any(Pool.class));
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  enforcer.postUnbind(consumer,postHelper,e);
  verify(poolManagerMock,never()).updatePoolQuantity(any(Pool.class),anyInt());
  verify(poolManagerMock,never()).setPoolQuantity(any(Pool.class),anyLong());
}"
49441,"@Override public int hashCode(){
  return productId.hashCode() * 31;
}","@Override public int hashCode(){
  if (productId != null) {
    return productId.hashCode() * 31;
  }
  return 31;
}"
49442,"@Override public String getHref(){
  return ""String_Node_Str"" + getId();
}","@Override public String getHref(){
  return ""String_Node_Str"" + getOwner().getKey() + ""String_Node_Str""+ getProductId();
}"
49443,"@Override public boolean equals(Object anObject){
  if (this == anObject) {
    return true;
  }
  if (!(anObject instanceof Product)) {
    return false;
  }
  Product another=(Product)anObject;
  return id.equals(another.getProductId()) && name.equals(another.getName());
}","@Override public boolean equals(Object anObject){
  if (this == anObject) {
    return true;
  }
  if (!(anObject instanceof Product)) {
    return false;
  }
  Product another=(Product)anObject;
  return getProductId().equals(another.getProductId()) && name.equals(another.getName());
}"
49444,"@Override public String toString(){
  return ""String_Node_Str"" + id + ""String_Node_Str""+ name+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + productId + ""String_Node_Str""+ name+ ""String_Node_Str"";
}"
49445,"/** 
 * Create the given product if it does not already exist, otherwise update existing product.
 * @param p Product to create or update.
 */
public void createOrUpdate(Product p){
  Product existing=lookupById(p.getId());
  if (existing == null) {
    create(p);
  }
 else {
    merge(p);
  }
}","/** 
 * Create the given product if it does not already exist, otherwise update existing product.
 * @param p Product to create or update.
 */
public void createOrUpdate(Product p){
  Product existing=lookupById(p.getOwner(),p.getProductId());
  if (existing == null) {
    create(p);
  }
 else {
    copy(p,existing);
    merge(existing);
  }
}"
49446,"@Inject public UnmappedGuestEntitlementCleanerJob(EntitlementCurator entitlementCurator,PoolManager manager){
  this.entitlementCurator=entitlementCurator;
  this.poolManager=manager;
}","@Inject public UnmappedGuestEntitlementCleanerJob(EntitlementCurator entitlementCurator,PoolManager manager,SubscriptionServiceAdapter subAdapter){
  this.entitlementCurator=entitlementCurator;
  this.poolManager=manager;
  this.subAdapter=subAdapter;
}"
49447,"@Override public void toExecute(JobExecutionContext context) throws JobExecutionException {
  Date now=new Date();
  List<Entitlement> unmappedGuestEntitlements=entitlementCurator.findByPoolAttribute(""String_Node_Str"",""String_Node_Str"");
  int total=0;
  for (  Entitlement e : unmappedGuestEntitlements) {
    if (isLapsed(e,now)) {
      poolManager.revokeEntitlement(e);
      total++;
    }
  }
  if (total > 0) {
    log.info(""String_Node_Str"",total);
  }
 else {
    log.debug(""String_Node_Str"");
  }
}","@Override public void toExecute(JobExecutionContext context) throws JobExecutionException {
  Date now=new Date();
  List<Entitlement> unmappedGuestEntitlements=entitlementCurator.findByPoolAttribute(""String_Node_Str"",""String_Node_Str"");
  int total=0;
  for (  Entitlement e : unmappedGuestEntitlements) {
    if (isLapsed(e,now)) {
      poolManager.revokeEntitlement(subAdapter,e);
      total++;
    }
  }
  if (total > 0) {
    log.info(""String_Node_Str"",total);
  }
 else {
    log.debug(""String_Node_Str"");
  }
}"
49448,"@Test public void testToExecute() throws Exception {
  Owner owner1=new Owner(""String_Node_Str"");
  Owner owner2=new Owner(""String_Node_Str"");
  Product product1=TestUtil.createProduct(owner1);
  Product product2=TestUtil.createProduct(owner2);
  Pool p1=TestUtil.createPool(owner1,product1);
  Pool p2=TestUtil.createPool(owner2,product2);
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p2.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  Date thirtySixHoursAgo=new Date(new Date().getTime() - 36L * 60L * 60L* 1000L);
  Date twelveHoursAgo=new Date(new Date().getTime() - 12L * 60L * 60L* 1000L);
  Consumer c;
  c=TestUtil.createConsumer(owner1);
  c.setCreated(thirtySixHoursAgo);
  Entitlement e1=TestUtil.createEntitlement(owner1,c,p1,null);
  Set<Entitlement> entitlementSet1=new HashSet<Entitlement>();
  entitlementSet1.add(e1);
  p1.setEntitlements(entitlementSet1);
  c=TestUtil.createConsumer(owner2);
  c.setCreated(twelveHoursAgo);
  Entitlement e2=TestUtil.createEntitlement(owner2,c,p2,null);
  Set<Entitlement> entitlementSet2=new HashSet<Entitlement>();
  entitlementSet2.add(e2);
  p2.setEntitlements(entitlementSet2);
  when(entitlementCurator.findByPoolAttribute(eq(""String_Node_Str""),eq(""String_Node_Str""))).thenReturn(Arrays.asList(new Entitlement[]{e1,e2}));
  new UnmappedGuestEntitlementCleanerJob(entitlementCurator,poolManager).execute(null);
  verify(poolManager).revokeEntitlement(e1);
}","@Test public void testToExecute() throws Exception {
  Owner owner1=new Owner(""String_Node_Str"");
  Owner owner2=new Owner(""String_Node_Str"");
  Product product1=TestUtil.createProduct(owner1);
  Product product2=TestUtil.createProduct(owner2);
  Pool p1=TestUtil.createPool(owner1,product1);
  Pool p2=TestUtil.createPool(owner2,product2);
  p1.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  p2.addAttribute(new PoolAttribute(""String_Node_Str"",""String_Node_Str""));
  Date thirtySixHoursAgo=new Date(new Date().getTime() - 36L * 60L * 60L* 1000L);
  Date twelveHoursAgo=new Date(new Date().getTime() - 12L * 60L * 60L* 1000L);
  Consumer c;
  c=TestUtil.createConsumer(owner1);
  c.setCreated(thirtySixHoursAgo);
  Entitlement e1=TestUtil.createEntitlement(owner1,c,p1,null);
  Set<Entitlement> entitlementSet1=new HashSet<Entitlement>();
  entitlementSet1.add(e1);
  p1.setEntitlements(entitlementSet1);
  c=TestUtil.createConsumer(owner2);
  c.setCreated(twelveHoursAgo);
  Entitlement e2=TestUtil.createEntitlement(owner2,c,p2,null);
  Set<Entitlement> entitlementSet2=new HashSet<Entitlement>();
  entitlementSet2.add(e2);
  p2.setEntitlements(entitlementSet2);
  when(entitlementCurator.findByPoolAttribute(eq(""String_Node_Str""),eq(""String_Node_Str""))).thenReturn(Arrays.asList(new Entitlement[]{e1,e2}));
  new UnmappedGuestEntitlementCleanerJob(entitlementCurator,poolManager,subAdapter).execute(null);
  verify(poolManager).revokeEntitlement(subAdapter,e1);
}"
49449,"/** 
 * List entitlement pools. Pools will be refreshed from the underlying subscription service.
 * @param c Consumer being entitled.
 * @param o Owner whose subscriptions should be inspected.
 * @param productId only entitlements which provide this product are included.
 * @param activeOn Indicates to return only pools valid on this date.Set to null for no date filtering.
 * @param activeOnly if true, only active entitlements are included.
 * @param filters filter builder with set filters to apply to the criteria.
 * @param pageRequest used to specify paging criteria.
 * @param postFilter if you plan on filtering the list in java
 * @return List of entitlement pools.
 */
@SuppressWarnings(""String_Node_Str"") @Transactional public Page<List<Pool>> listAvailableEntitlementPools(Consumer c,Owner o,String productId,Date activeOn,boolean activeOnly,PoolFilterBuilder filters,PageRequest pageRequest,boolean postFilter){
  if (o == null && c != null) {
    o=c.getOwner();
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
    log.debug(""String_Node_Str"" + c);
    log.debug(""String_Node_Str"" + o);
    log.debug(""String_Node_Str"" + productId);
  }
  Criteria crit=createSecureCriteria();
  crit.createAlias(""String_Node_Str"",""String_Node_Str"");
  crit.createAlias(""String_Node_Str"",""String_Node_Str"");
  crit.createAlias(""String_Node_Str"",""String_Node_Str"");
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
    List<Criterion> filterCriteria=poolCriteria.availableEntitlementCriteria(c);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + filterCriteria.size() + ""String_Node_Str"");
    }
    for (    Criterion rulesCriteria : filterCriteria) {
      crit.add(rulesCriteria);
    }
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
    crit.add(Restrictions.ne(""String_Node_Str"",Product.ueberProductNameForOwner(o)));
  }
  if (activeOn != null) {
    crit.add(Restrictions.le(""String_Node_Str"",activeOn));
    crit.add(Restrictions.ge(""String_Node_Str"",activeOn));
  }
  if (productId != null) {
    crit.add(Restrictions.or(Restrictions.eq(""String_Node_Str"",productId),Restrictions.eq(""String_Node_Str"",productId)));
  }
  if (filters != null) {
    filters.applyTo(crit);
  }
  return listByCriteria(crit,pageRequest,postFilter);
}","/** 
 * List entitlement pools. Pools will be refreshed from the underlying subscription service.
 * @param c Consumer being entitled.
 * @param o Owner whose subscriptions should be inspected.
 * @param productId only entitlements which provide this product are included.
 * @param activeOn Indicates to return only pools valid on this date.Set to null for no date filtering.
 * @param activeOnly if true, only active entitlements are included.
 * @param filters filter builder with set filters to apply to the criteria.
 * @param pageRequest used to specify paging criteria.
 * @param postFilter if you plan on filtering the list in java
 * @return List of entitlement pools.
 */
@SuppressWarnings(""String_Node_Str"") @Transactional public Page<List<Pool>> listAvailableEntitlementPools(Consumer c,Owner o,String productId,Date activeOn,boolean activeOnly,PoolFilterBuilder filters,PageRequest pageRequest,boolean postFilter){
  if (o == null && c != null) {
    o=c.getOwner();
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
    log.debug(""String_Node_Str"" + c);
    log.debug(""String_Node_Str"" + o);
    log.debug(""String_Node_Str"" + productId);
  }
  Criteria crit=createSecureCriteria();
  crit.createAlias(""String_Node_Str"",""String_Node_Str"");
  crit.createAlias(""String_Node_Str"",""String_Node_Str"");
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
    List<Criterion> filterCriteria=poolCriteria.availableEntitlementCriteria(c);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + filterCriteria.size() + ""String_Node_Str"");
    }
    for (    Criterion rulesCriteria : filterCriteria) {
      crit.add(rulesCriteria);
    }
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
    crit.add(Restrictions.ne(""String_Node_Str"",Product.ueberProductNameForOwner(o)));
  }
  if (activeOn != null) {
    crit.add(Restrictions.le(""String_Node_Str"",activeOn));
    crit.add(Restrictions.ge(""String_Node_Str"",activeOn));
  }
  if (productId != null) {
    crit.add(Restrictions.or(Restrictions.eq(""String_Node_Str"",productId),Restrictions.eq(""String_Node_Str"",productId)));
  }
  if (filters != null) {
    filters.applyTo(crit);
  }
  return listByCriteria(crit,pageRequest,postFilter);
}"
49450,"protected Boolean annotationPresent(Object obj,String propertyName,Class<? extends Annotation> clazz){
  try {
    String postFix=propertyName.substring(0,1).toUpperCase() + propertyName.substring(1);
    String methodName=""String_Node_Str"" + postFix;
    Method getter=null;
    try {
      getter=obj.getClass().getMethod(methodName);
    }
 catch (    NoSuchMethodException e) {
      methodName=""String_Node_Str"" + postFix;
      getter=obj.getClass().getMethod(methodName);
    }
    Annotation a=getter.getAnnotation(clazz);
    if (a != null) {
      return true;
    }
  }
 catch (  NoSuchMethodException e) {
    log.warn(""String_Node_Str"" + propertyName + ""String_Node_Str"");
    return false;
  }
  return false;
}","/** 
 * Checks if the specified annotation has been applied to the given object's class, property or accessor (in that order).
 * @param obj The object to check for the annotation
 * @param property The name of the property to check
 * @param annotation The annotation for which to check
 * @return True if the annotation is present either on the class, the property or the property's accessor; false otherwise.
 */
protected boolean annotationPresent(Object obj,String property,Class<? extends Annotation> annotation){
  if (obj.getClass().getAnnotation(annotation) != null) {
    return true;
  }
  try {
    Field field=obj.getClass().getField(property);
    if (field.getAnnotation(annotation) != null) {
      return true;
    }
  }
 catch (  NoSuchFieldException e) {
  }
  String[] prefixes={""String_Node_Str"",""String_Node_Str""};
  property=property.substring(0,1).toUpperCase() + property.substring(1);
  for (  String prefix : prefixes) {
    try {
      Method method=obj.getClass().getMethod(prefix + property);
      if (method.getAnnotation(annotation) != null) {
        return true;
      }
    }
 catch (    NoSuchMethodException e) {
    }
  }
  return false;
}"
49451,"private void configureHateoasObjectMapper(ObjectMapper mapper,boolean indentJson){
  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);
  if (indentJson) {
    mapper.configure(SerializationFeature.INDENT_OUTPUT,true);
  }
  SimpleFilterProvider filterProvider=new SimpleFilterProvider();
  String[] filters={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String filterName : filters) {
    filterProvider=filterProvider.addFilter(filterName,new MultiFilter(new HateoasBeanPropertyFilter(),new DynamicPropertyFilter()));
  }
  filterProvider.setDefaultFilter(new DynamicPropertyFilter());
  filterProvider.setFailOnUnknownId(false);
  mapper.setFilters(filterProvider);
  AnnotationIntrospector primary=new JacksonAnnotationIntrospector();
  AnnotationIntrospector secondary=new JaxbAnnotationIntrospector(mapper.getTypeFactory());
  AnnotationIntrospector pair=new AnnotationIntrospectorPair(primary,secondary);
  mapper.setAnnotationIntrospector(pair);
}","private void configureHateoasObjectMapper(ObjectMapper mapper,boolean indentJson){
  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);
  if (indentJson) {
    mapper.configure(SerializationFeature.INDENT_OUTPUT,true);
  }
  SimpleFilterProvider filterProvider=new SimpleFilterProvider();
  String[] filters={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String filterName : filters) {
    filterProvider=filterProvider.addFilter(filterName,new MultiFilter(new HateoasBeanPropertyFilter(),new DynamicPropertyFilter()));
  }
  filterProvider.setDefaultFilter(new DynamicPropertyFilter());
  filterProvider.setFailOnUnknownId(false);
  mapper.setFilters(filterProvider);
  AnnotationIntrospector primary=new JacksonAnnotationIntrospector();
  AnnotationIntrospector secondary=new JaxbAnnotationIntrospector(mapper.getTypeFactory());
  AnnotationIntrospector pair=new AnnotationIntrospectorPair(primary,secondary);
  mapper.setAnnotationIntrospector(pair);
}"
49452,"@Inject public EventManager(Map<String,EventHandler> targetHandlers,EventCurator eventCurator){
  this.eventCurator=eventCurator;
  this.targetHandlers=targetHandlers;
}","@Inject public EventManager(Map<String,EventHandler> targetHandlers){
  this.targetHandlers=targetHandlers;
}"
49453,"/** 
 * Properly stores events by routing them to event handlers
 * @param event to store
 */
public void handle(Event event){
  EventHandler handler=targetHandlers.get(event.getTarget());
  if (handler != null) {
    log.info(""String_Node_Str"" + event + ""String_Node_Str""+ handler.getClass().getSimpleName());
    String eventType=event.getType();
    if (MODIFIED_EVENT_TYPE.equals(eventType)) {
      event.setStatus(handler.handleUpdated(event));
    }
 else     if (CREATED_EVENT_TYPE.equals(eventType)) {
      event.setStatus(handler.handleCreated(event));
    }
 else     if (DELETED_EVENT_TYPE.equals(eventType)) {
      event.setStatus(handler.handleDeleted(event));
    }
 else {
      log.warn(""String_Node_Str"" + eventType);
      event.setStatus(Event.Status.SKIPPED);
    }
  }
 else {
    event.setStatus(Event.Status.SKIPPED);
  }
  eventCurator.merge(event);
}","/** 
 * Properly stores events by routing them to event handlers
 * @param event to store
 */
public void handle(Event event){
  EventHandler handler=targetHandlers.get(event.getTarget());
  if (handler != null) {
    log.info(""String_Node_Str"" + event + ""String_Node_Str""+ handler.getClass().getSimpleName());
    String eventType=event.getType();
    if (MODIFIED_EVENT_TYPE.equals(eventType)) {
      event.setStatus(handler.handleUpdated(event));
    }
 else     if (CREATED_EVENT_TYPE.equals(eventType)) {
      event.setStatus(handler.handleCreated(event));
    }
 else     if (DELETED_EVENT_TYPE.equals(eventType)) {
      event.setStatus(handler.handleDeleted(event));
    }
 else {
      log.warn(""String_Node_Str"" + eventType);
      event.setStatus(Event.Status.SKIPPED);
    }
  }
 else {
    event.setStatus(Event.Status.SKIPPED);
  }
}"
49454,"/** 
 * Process the event received. (second phase) In this phase we do any more complex processing of the event in a separate transaction from the one where we first stored the event. Exceptions here should always be caught and never bubble up. The transaction will never be committed and the event will be left in the database with an initial state that indicates there was some kind of failure in processing. This allows us to identify problem events and eventually re-try processing them.
 * @param event Event to be processed.
 */
private void processEvent(Event event){
  try {
    unitOfWork.begin();
    eventManager.handle(event);
    eventCurator.merge(event);
    unitOfWork.end();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + event,e);
  }
}","/** 
 * Process the event received. (second phase) In this phase we do any more complex processing of the event in a separate transaction from the one where we first stored the event. Exceptions here should always be caught and never bubble up. The transaction will never be committed and the event will be left in the database with an initial state that indicates there was some kind of failure in processing. This allows us to identify problem events and eventually re-try processing them.
 * @param event Event to be processed.
 */
private void processEvent(Event event){
  try {
    unitOfWork.begin();
    eventManager.handle(event);
    eventCurator.merge(event);
    unitOfWork.end();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + event,e);
  }
 finally {
    unitOfWork.end();
  }
}"
49455,"@Test public void testEventManagerNullTarget(){
  Event toHandle=new Event();
  eventManager.handle(toHandle);
  verify(eventCurator).create(eq(toHandle));
  verify(handler,never()).handleCreated(any(Event.class));
  verify(handler,never()).handleUpdated(any(Event.class));
  verify(handler,never()).handleDeleted(any(Event.class));
}","@Test public void testEventManagerNullTarget(){
  Event toHandle=new Event();
  eventManager.handle(toHandle);
  verify(handler,never()).handleCreated(any(Event.class));
  verify(handler,never()).handleUpdated(any(Event.class));
  verify(handler,never()).handleDeleted(any(Event.class));
}"
49456,"public TestingEventManager(Map<String,EventHandler> handlers,EventCurator curator){
  super(handlers,curator);
}","public TestingEventManager(Map<String,EventHandler> handlers){
  super(handlers);
}"
49457,"@Before public void before(){
  ObjectMapper mapper=new ObjectMapper();
  mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  Map<String,EventHandler> handlers=new HashMap<String,EventHandler>();
  handlers.put(TEST_HANDLER_TARGET,handler);
  eventManager=new TestingEventManager(handlers,eventCurator);
}","@Before public void before(){
  ObjectMapper mapper=new ObjectMapper();
  mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  Map<String,EventHandler> handlers=new HashMap<String,EventHandler>();
  handlers.put(TEST_HANDLER_TARGET,handler);
  eventManager=new TestingEventManager(handlers);
}"
49458,"@Test public void verifyHandleCreated(){
  Event toHandle=new Event();
  toHandle.setTarget(TEST_HANDLER_TARGET);
  toHandle.setType(EventManager.CREATED_EVENT_TYPE);
  eventManager.handle(toHandle);
  verify(eventCurator).create(eq(toHandle));
  verify(handler).handleCreated(eq(toHandle));
  verify(handler,never()).handleUpdated(any(Event.class));
  verify(handler,never()).handleDeleted(any(Event.class));
}","@Test public void verifyHandleCreated(){
  Event toHandle=new Event();
  toHandle.setTarget(TEST_HANDLER_TARGET);
  toHandle.setType(EventManager.CREATED_EVENT_TYPE);
  eventManager.handle(toHandle);
  verify(handler).handleCreated(eq(toHandle));
  verify(handler,never()).handleUpdated(any(Event.class));
  verify(handler,never()).handleDeleted(any(Event.class));
}"
49459,"@Test public void testEventManagerUnknown(){
  Event toHandle=new Event();
  toHandle.setTarget(""String_Node_Str"");
  eventManager.handle(toHandle);
  verify(eventCurator).create(eq(toHandle));
  verify(handler,never()).handleCreated(any(Event.class));
  verify(handler,never()).handleUpdated(any(Event.class));
  verify(handler,never()).handleDeleted(any(Event.class));
}","@Test public void testEventManagerUnknown(){
  Event toHandle=new Event();
  toHandle.setTarget(""String_Node_Str"");
  eventManager.handle(toHandle);
  verify(handler,never()).handleCreated(any(Event.class));
  verify(handler,never()).handleUpdated(any(Event.class));
  verify(handler,never()).handleDeleted(any(Event.class));
}"
49460,"@Test public void verifyHandleUpdated(){
  Event toHandle=new Event();
  toHandle.setTarget(TEST_HANDLER_TARGET);
  toHandle.setType(EventManager.MODIFIED_EVENT_TYPE);
  eventManager.handle(toHandle);
  verify(eventCurator).create(eq(toHandle));
  verify(handler).handleUpdated(eq(toHandle));
  verify(handler,never()).handleCreated(any(Event.class));
  verify(handler,never()).handleDeleted(any(Event.class));
}","@Test public void verifyHandleUpdated(){
  Event toHandle=new Event();
  toHandle.setTarget(TEST_HANDLER_TARGET);
  toHandle.setType(EventManager.MODIFIED_EVENT_TYPE);
  eventManager.handle(toHandle);
  verify(handler).handleUpdated(eq(toHandle));
  verify(handler,never()).handleCreated(any(Event.class));
  verify(handler,never()).handleDeleted(any(Event.class));
}"
49461,"@Test public void verifyHandleDeleted(){
  Event toHandle=new Event();
  toHandle.setTarget(TEST_HANDLER_TARGET);
  toHandle.setType(EventManager.DELETED_EVENT_TYPE);
  eventManager.handle(toHandle);
  verify(eventCurator).create(eq(toHandle));
  verify(handler).handleDeleted(eq(toHandle));
  verify(handler,never()).handleCreated(any(Event.class));
  verify(handler,never()).handleUpdated(any(Event.class));
}","@Test public void verifyHandleDeleted(){
  Event toHandle=new Event();
  toHandle.setTarget(TEST_HANDLER_TARGET);
  toHandle.setType(EventManager.DELETED_EVENT_TYPE);
  eventManager.handle(toHandle);
  verify(handler).handleDeleted(eq(toHandle));
  verify(handler,never()).handleCreated(any(Event.class));
  verify(handler,never()).handleUpdated(any(Event.class));
}"
49462,"/** 
 * Check whether   {@link #consumed} is greater than {@link #quantity}
 * @return true if consumed>quantity else false.
 */
@XmlTransient public boolean isOverflowing(){
  return getConsumed() > this.quantity;
}","/** 
 * Check whether   {@link #consumed} is greater than {@link #quantity}
 * @return true if consumed>quantity else false.
 */
@XmlTransient public boolean isOverflowing(){
  if (this.quantity == -1) {
    return false;
  }
  return getConsumed() > this.quantity;
}"
49463,"public void testMultiplePoolsForOwnerProductAllowed(){
  Pool duplicatePool=createPoolAndSub(owner,prod1,-1L,TestUtil.createDate(2009,11,30),TestUtil.createDate(2050,11,30));
  poolCurator.create(duplicatePool);
}","@Test public void testMultiplePoolsForOwnerProductAllowed(){
  Pool duplicatePool=createPoolAndSub(owner,prod1,-1L,TestUtil.createDate(2009,11,30),TestUtil.createDate(2050,11,30));
  poolCurator.create(duplicatePool);
}"
49464,"/** 
 * @return the passphrase
 */
public String getPassphrase(){
  log.info(""String_Node_Str"" + passphrase);
  return passphrase;
}","/** 
 * @return the passphrase
 */
public String getPassphrase(){
  log.info(""String_Node_Str"",passphrase);
  return passphrase;
}"
49465,"public String decryptValue(String toDecrypt,String passphrase){
  log.info(""String_Node_Str"");
  if (!toDecrypt.startsWith(""String_Node_Str"")) {
    log.debug(""String_Node_Str"");
    return toDecrypt;
  }
  toDecrypt=toDecrypt.substring(3);
  try {
    Cipher cipher=Cipher.getInstance(""String_Node_Str"");
    String ivString=passphrase + passphrase;
    String iv=DigestUtils.sha256Hex(ivString);
    String passphraseDigest=DigestUtils.sha256Hex(passphrase);
    SecretKeySpec spec=new SecretKeySpec(Arrays.copyOfRange(passphraseDigest.getBytes(),0,32),""String_Node_Str"");
    cipher.init(Cipher.DECRYPT_MODE,spec,new IvParameterSpec(iv.getBytes(),0,16));
    byte[] b64bytes=Base64.decodeBase64(toDecrypt);
    return new String(cipher.doFinal(b64bytes));
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"" + toDecrypt,e);
    throw new RuntimeException(e);
  }
}","public String decryptValue(String toDecrypt,String passphrase){
  log.info(""String_Node_Str"");
  if (!toDecrypt.startsWith(""String_Node_Str"")) {
    log.debug(""String_Node_Str"");
    return toDecrypt;
  }
  toDecrypt=toDecrypt.substring(3);
  try {
    Cipher cipher=Cipher.getInstance(""String_Node_Str"");
    String ivString=passphrase + passphrase;
    String iv=DigestUtils.sha256Hex(ivString);
    String passphraseDigest=DigestUtils.sha256Hex(passphrase);
    SecretKeySpec spec=new SecretKeySpec(Arrays.copyOfRange(passphraseDigest.getBytes(),0,32),""String_Node_Str"");
    cipher.init(Cipher.DECRYPT_MODE,spec,new IvParameterSpec(iv.getBytes(),0,16));
    byte[] b64bytes=Base64.decodeBase64(toDecrypt);
    return new String(cipher.doFinal(b64bytes));
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + toDecrypt,e);
    throw new RuntimeException(e);
  }
}"
49466,"public Properties parseConfig(Map<String,String> inputConfiguration){
  readSecretFile((String)inputConfiguration.get(""String_Node_Str""));
  Properties toReturn=new Properties();
  Properties toDecrypt=super.parseConfig(inputConfiguration);
  if (getEncryptedConfigKeys() != null) {
    for (    String encConfigKey : getEncryptedConfigKeys()) {
      String passwordString=toDecrypt.getProperty(encConfigKey);
      if (passwordString != null) {
        toReturn.setProperty(encConfigKey,decryptValue(passwordString,getPassphrase()));
      }
    }
  }
  return toReturn;
}","@Override public Properties parseConfig(Map<String,String> inputConfiguration){
  readSecretFile((String)inputConfiguration.get(PASSPHRASE_PROPERTY));
  Properties properties=super.parseConfig(inputConfiguration);
  Set<String> encryptedProperties=getEncryptedConfigKeys();
  if (encryptedProperties != null) {
    for (    String key : encryptedProperties) {
      String encryptedValue=properties.getProperty(key);
      properties.setProperty(key,decryptValue(encryptedValue,getPassphrase()));
    }
  }
  return properties;
}"
49467,"@SuppressWarnings(""String_Node_Str"") @Test public void getStringMethods(){
  Configuration localconf=new MapConfiguration(new HashMap<String,String>(){
{
      put(""String_Node_Str"",plainPassword);
    }
  }
);
  assertEquals(plainPassword,localconf.getString(""String_Node_Str""));
  assertNull(localconf.getString(""String_Node_Str"",null));
}","@Test public void getStringMethods(){
  Configuration localconf=new MapConfiguration(new HashMap<String,String>(){
{
      put(""String_Node_Str"",plainPassword);
    }
  }
);
  assertEquals(plainPassword,localconf.getString(""String_Node_Str""));
  assertNull(localconf.getString(""String_Node_Str"",null));
}"
49468,"public GutterballObjectMapper(){
  super();
  configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  SimpleModule module=new SimpleModule();
  module.addDeserializer(Entitlement.class,new EntitlementDeserializer(this));
  this.registerModule(module);
}","public GutterballObjectMapper(){
  super();
  configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  SimpleModule module=new SimpleModule();
  module.addDeserializer(Entitlement.class,new EntitlementDeserializer());
  this.registerModule(module);
}"
49469,"public void setGuestIds(List<GuestId> guestIds){
  this.guestIds=guestIds;
  for (  GuestId gid : this.guestIds) {
    gid.setConsumer(this);
  }
}","public void setGuestIds(List<GuestId> ids){
  if (ids == null) {
    ids=new LinkedList<GuestId>();
  }
  this.guestIds=ids;
  for (  GuestId gid : this.guestIds) {
    gid.setConsumer(this);
  }
}"
49470,"public void setInstalledProducts(Set<ConsumerInstalledProduct> installedProducts){
  this.installedProducts=installedProducts;
  for (  ConsumerInstalledProduct p : this.installedProducts) {
    p.setConsumer(this);
  }
}","public void setInstalledProducts(Set<ConsumerInstalledProduct> installed){
  if (installed == null) {
    installed=new HashSet<ConsumerInstalledProduct>();
  }
  this.installedProducts=installed;
  for (  ConsumerInstalledProduct p : this.installedProducts) {
    p.setConsumer(this);
  }
}"
49471,"public Consumer getConsumer(){
  return consumer;
}","@XmlTransient public Consumer getConsumer(){
  return consumer;
}"
49472,"public Consumer getConsumer(){
  return consumer;
}","@XmlTransient public Consumer getConsumer(){
  return consumer;
}"
49473,"/** 
 * @param i18nProvider
 * @param key
 * @param description
 */
@Inject public ConsumerTrendReport(I18nProvider i18nProvider,ComplianceSnapshotCurator complianceSnapshotCurator){
  super(i18nProvider,""String_Node_Str"",i18nProvider.get().tr(""String_Node_Str""));
  this.complianceSnapshotCurator=complianceSnapshotCurator;
}","/** 
 * @param i18nProvider
 * @param key
 * @param description
 */
@Inject public ConsumerTrendReport(I18nProvider i18nProvider,ComplianceSnapshotCurator snapshotCurator){
  super(i18nProvider,""String_Node_Str"",i18nProvider.get().tr(""String_Node_Str""));
  this.snapshotCurator=snapshotCurator;
}"
49474,"@Override protected ConsumerTrendReportResult execute(MultivaluedMap<String,String> queryParams){
  List<String> consumerIds=queryParams.get(""String_Node_Str"");
  List<String> ownerFilters=queryParams.get(""String_Node_Str"");
  Date startDate=null;
  Date endDate=null;
  if (queryParams.containsKey(""String_Node_Str"")) {
    Calendar cal=Calendar.getInstance();
    endDate=cal.getTime();
    int hours=Integer.parseInt(queryParams.getFirst(""String_Node_Str""));
    cal.add(Calendar.HOUR,hours * -1);
    startDate=cal.getTime();
  }
 else   if (queryParams.containsKey(""String_Node_Str"") && queryParams.containsKey(""String_Node_Str"")) {
    startDate=parseDate(queryParams.getFirst(""String_Node_Str""));
    endDate=parseDate(queryParams.getFirst(""String_Node_Str""));
  }
  ConsumerTrendReportResult result=new ConsumerTrendReportResult();
  Set<ComplianceSnapshot> forTimeSpan=complianceSnapshotCurator.getComplianceForTimespan(startDate,endDate,consumerIds,ownerFilters);
  for (  ComplianceSnapshot cs : forTimeSpan) {
    result.add(cs.getConsumer().getUuid(),cs);
  }
  return result;
}","@Override protected ConsumerTrendReportResult execute(MultivaluedMap<String,String> queryParams){
  List<String> consumerIds=queryParams.get(""String_Node_Str"");
  List<String> ownerFilters=queryParams.get(""String_Node_Str"");
  Date startDate=null;
  Date endDate=null;
  if (queryParams.containsKey(""String_Node_Str"")) {
    Calendar cal=Calendar.getInstance();
    endDate=cal.getTime();
    int hours=Integer.parseInt(queryParams.getFirst(""String_Node_Str""));
    cal.add(Calendar.HOUR,hours * -1);
    startDate=cal.getTime();
  }
 else   if (queryParams.containsKey(""String_Node_Str"") && queryParams.containsKey(""String_Node_Str"")) {
    startDate=parseDate(queryParams.getFirst(""String_Node_Str""));
    endDate=parseDate(queryParams.getFirst(""String_Node_Str""));
  }
  ConsumerTrendReportResult result=new ConsumerTrendReportResult();
  Set<ComplianceSnapshot> forTimeSpan=snapshotCurator.getComplianceForTimespan(startDate,endDate,consumerIds,ownerFilters);
  for (  ComplianceSnapshot cs : forTimeSpan) {
    result.add(cs.getConsumer().getUuid(),cs);
  }
  return result;
}"
49475,"/** 
 * Adds an event to the queue. Event will not be sent until sendEvents is called, typically after a successful request or job execution.
 */
@Override public void queueEvent(Event event){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + event);
  }
  getEventQueue().add(event);
}","/** 
 * Adds an event to the queue. Event will not be sent until sendEvents is called, typically after a successful request or job execution.
 */
@Override public void queueEvent(Event event){
  log.debug(""String_Node_Str"" + event);
  getEventQueue().add(event);
}"
49476,"@Inject public HornetqEventDispatcher(ObjectMapper mapper,Config config){
  this.mapper=mapper;
  try {
    largeMsgSize=config.getInt(ConfigProperties.HORNETQ_LARGE_MSG_SIZE);
    factory=createClientSessionFactory();
  }
 catch (  HornetQException e) {
    throw new RuntimeException(e);
  }
catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Inject public HornetqEventDispatcher(ObjectMapper mapper,Config config){
  this.mapper=mapper;
  try {
    largeMsgSize=config.getInt(ConfigProperties.HORNETQ_LARGE_MSG_SIZE);
    factory=createClientSessionFactory();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
49477,"public void sendEvent(Event event){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + event);
  }
  try {
    ClientMessage message=getClientSession().createMessage(true);
    String eventString=mapper.writeValueAsString(event);
    message.getBodyBuffer().writeString(eventString);
    getClientProducer().send(message);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + event,e);
  }
}","public void sendEvent(Event event){
  log.debug(""String_Node_Str"" + event);
  try {
    ClientMessage message=getClientSession().createMessage(true);
    String eventString=mapper.writeValueAsString(event);
    message.getBodyBuffer().writeString(eventString);
    getClientProducer().send(message);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + event,e);
  }
}"
49478,"@Override public void execute(JobExecutionContext context) throws JobExecutionException {
  pinsetterJobScope.enter();
  candlepinSingletonScope.enter();
  boolean startedUow=startUnitOfWork();
  try {
    decorated=injector.getInstance(decoratedJobClass);
    decorated.execute(context);
  }
  finally {
    candlepinSingletonScope.exit();
    pinsetterJobScope.exit();
    if (startedUow) {
      endUnitOfWork();
    }
  }
}","@Override public void execute(JobExecutionContext context) throws JobExecutionException {
  pinsetterJobScope.enter();
  candlepinSingletonScope.enter();
  boolean startedUow=startUnitOfWork();
  try {
    decorated=injector.getInstance(decoratedJobClass);
  }
  finally {
    candlepinSingletonScope.exit();
    if (startedUow) {
      endUnitOfWork();
    }
  }
  try {
    decorated.execute(context);
  }
  finally {
    pinsetterJobScope.exit();
  }
}"
49479,"@Override public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws IOException, ServletException {
  chain.doFilter(request,response);
  TeeHttpServletResponse resp=new TeeHttpServletResponse((HttpServletResponse)response);
  if (resp.getStatus() >= 200 && resp.getStatus() < 300) {
    eventSinkProvider.get().sendEvents();
  }
 else {
    log.debug(""String_Node_Str"");
  }
}","@Override public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws IOException, ServletException {
  TeeHttpServletResponse resp=new TeeHttpServletResponse((HttpServletResponse)response);
  chain.doFilter(request,resp);
  if (resp.getStatus() >= 200 && resp.getStatus() < 300) {
    eventSinkProvider.get().sendEvents();
  }
 else {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + resp.getStatus());
    }
  }
}"
49480,"public Iterable<DBObject> getComplianceForTimespan(Date startDate,Date endDate,List<String> consumerIds,List<String> owners){
  BasicDBObjectBuilder queryBuilder=BasicDBObjectBuilder.start();
  if (owners != null && !owners.isEmpty()) {
    queryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",owners));
  }
  BasicDBObjectBuilder dateQueryBuilder=BasicDBObjectBuilder.start();
  if (startDate != null) {
    dateQueryBuilder.add(""String_Node_Str"",startDate);
  }
  if (endDate != null) {
    dateQueryBuilder.add(""String_Node_Str"",endDate);
  }
  if (startDate != null || endDate != null) {
    queryBuilder.add(""String_Node_Str"",dateQueryBuilder.get());
  }
  BasicDBObject projections=new BasicDBObject(""String_Node_Str"",1);
  BasicDBObject project=new BasicDBObject(""String_Node_Str"",projections);
  DBObject query=new BasicDBObject(""String_Node_Str"",queryBuilder.get());
  DBObject sort=new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",1));
  AggregationOutput output=collection.aggregate(Arrays.asList(query,project,sort));
  List<ObjectId> resultIds=new LinkedList<ObjectId>();
  for (  DBObject dbo : output.results()) {
    resultIds.add((ObjectId)dbo.get(""String_Node_Str""));
  }
  projections=new BasicDBObject(""String_Node_Str"",0).append(""String_Node_Str"",1).append(""String_Node_Str"",1);
  return collection.find(new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",resultIds)),projections);
}","public DBCursor getComplianceForTimespan(Date startDate,Date endDate,List<String> consumerIds,List<String> owners){
  BasicDBObjectBuilder queryBuilder=BasicDBObjectBuilder.start();
  if (owners != null && !owners.isEmpty()) {
    queryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",owners));
  }
  BasicDBObjectBuilder dateQueryBuilder=BasicDBObjectBuilder.start();
  if (startDate != null) {
    dateQueryBuilder.add(""String_Node_Str"",startDate);
  }
  if (endDate != null) {
    dateQueryBuilder.add(""String_Node_Str"",endDate);
  }
  if (startDate != null || endDate != null) {
    queryBuilder.add(""String_Node_Str"",dateQueryBuilder.get());
  }
  BasicDBObject projections=new BasicDBObject(""String_Node_Str"",1);
  BasicDBObject project=new BasicDBObject(""String_Node_Str"",projections);
  DBObject query=new BasicDBObject(""String_Node_Str"",queryBuilder.get());
  DBObject sort=new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",1));
  AggregationOutput output=collection.aggregate(Arrays.asList(query,project,sort));
  List<ObjectId> resultIds=getObjectIds(output.results());
  return collection.find(new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",resultIds)));
}"
49481,"@Inject public ComplianceDataCurator(MongoConnection mongo,ConsumerCurator consumerCurator){
  super(BasicDBObject.class,mongo);
  this.consumerCurator=consumerCurator;
}","@Inject public ComplianceDataCurator(MongoConnection mongo,ConsumerCurator consumerCurator){
  super(BasicDBObject.class,mongo);
  this.consumerCurator=consumerCurator;
  this.collection.createIndex(new BasicDBObject(""String_Node_Str"",1));
  this.collection.createIndex(new BasicDBObject(""String_Node_Str"",1));
  this.collection.createIndex(new BasicDBObject(""String_Node_Str"",-1));
  this.collection.createIndex(new BasicDBObject(""String_Node_Str"",1));
}"
49482,"public Iterable<DBObject> getComplianceOnDate(Date targetDate,List<String> consumerIds,List<String> owners,List<String> statusFilers){
  BasicDBObjectBuilder queryBuilder=BasicDBObjectBuilder.start();
  queryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",consumerCurator.getUuidsOnDate(targetDate,owners,consumerIds)));
  if (owners != null && !owners.isEmpty()) {
    queryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",owners));
  }
  queryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",targetDate));
  BasicDBObjectBuilder filterBuilder=BasicDBObjectBuilder.start();
  if (statusFilers != null && !statusFilers.isEmpty()) {
    filterBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",statusFilers));
  }
  BasicDBObject projections=new BasicDBObject();
  projections.put(""String_Node_Str"",1);
  projections.put(""String_Node_Str"",1);
  projections.put(""String_Node_Str"",0);
  BasicDBObject project=new BasicDBObject(""String_Node_Str"",projections);
  BasicDBObject groups=new BasicDBObject(""String_Node_Str"",""String_Node_Str"");
  groups.put(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",""String_Node_Str""));
  groups.put(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",""String_Node_Str""));
  DBObject query=new BasicDBObject(""String_Node_Str"",queryBuilder.get());
  DBObject postResultFilter=new BasicDBObject(""String_Node_Str"",filterBuilder.get());
  DBObject group=new BasicDBObject(""String_Node_Str"",groups);
  DBObject sort=new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",-1));
  AggregationOutput output=collection.aggregate(Arrays.asList(query,project,sort,group,postResultFilter));
  return output.results();
}","public DBCursor getComplianceOnDate(Date targetDate,List<String> consumerIds,List<String> owners,List<String> statusFilers){
  BasicDBObjectBuilder queryBuilder=BasicDBObjectBuilder.start();
  queryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",consumerCurator.getUuidsOnDate(targetDate,owners,consumerIds)));
  if (owners != null && !owners.isEmpty()) {
    queryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",owners));
  }
  queryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",targetDate));
  StringBuffer m=new StringBuffer();
  m.append(""String_Node_Str"");
  m.append(""String_Node_Str"");
  m.append(""String_Node_Str"");
  StringBuffer r=new StringBuffer();
  r.append(""String_Node_Str"");
  r.append(""String_Node_Str"");
  r.append(""String_Node_Str"");
  r.append(""String_Node_Str"");
  MapReduceCommand command=new MapReduceCommand(collection,m.toString(),r.toString(),null,MapReduceCommand.OutputType.INLINE,queryBuilder.get());
  List<ObjectId> ids=new LinkedList<ObjectId>();
  MapReduceOutput output=collection.mapReduce(command);
  for (  DBObject row : output.results()) {
    DBObject value=(DBObject)row.get(""String_Node_Str"");
    ids.add((ObjectId)value.get(""String_Node_Str""));
  }
  BasicDBObjectBuilder filterQueryBuilder=BasicDBObjectBuilder.start();
  filterQueryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",ids));
  if (statusFilers != null && !statusFilers.isEmpty()) {
    filterQueryBuilder.add(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",statusFilers));
  }
  DBCursor all=collection.find(filterQueryBuilder.get());
  return all;
}"
49483,"@Inject public ConsumerCurator(MongoConnection mongo){
  super(Consumer.class,mongo);
}","@Inject public ConsumerCurator(MongoConnection mongo){
  super(Consumer.class,mongo);
  this.collection.createIndex(new BasicDBObject(""String_Node_Str"",-1));
  this.collection.createIndex(new BasicDBObject(""String_Node_Str"",-1));
  this.collection.createIndex(new BasicDBObject(""String_Node_Str"",1));
  this.collection.createIndex(new BasicDBObject(""String_Node_Str"",1));
}"
49484,"@Override protected MultiRowResult<DBObject> execute(MultivaluedMap<String,String> queryParams){
  MultiRowResult<DBObject> result=new MultiRowResult<DBObject>();
  List<String> consumerIds=queryParams.get(""String_Node_Str"");
  List<String> statusFilters=queryParams.get(""String_Node_Str"");
  List<String> ownerFilters=queryParams.get(""String_Node_Str"");
  Date targetDate=queryParams.containsKey(""String_Node_Str"") ? parseDate(queryParams.getFirst(""String_Node_Str"")) : new Date();
  Iterable<DBObject> complianceSnapshots=complianceDataCurator.getComplianceOnDate(targetDate,consumerIds,ownerFilters,statusFilters);
  for (  DBObject snapshot : complianceSnapshots) {
    result.add(snapshot);
  }
  return result;
}","@Override protected MultiRowResult<DBObject> execute(MultivaluedMap<String,String> queryParams){
  MultiRowResult<DBObject> result=new MultiRowResult<DBObject>();
  List<String> consumerIds=queryParams.get(""String_Node_Str"");
  List<String> statusFilters=queryParams.get(""String_Node_Str"");
  List<String> ownerFilters=queryParams.get(""String_Node_Str"");
  Date targetDate=queryParams.containsKey(""String_Node_Str"") ? parseDate(queryParams.getFirst(""String_Node_Str"")) : new Date();
  DBCursor complianceSnapshots=complianceDataCurator.getComplianceOnDate(targetDate,consumerIds,ownerFilters,statusFilters);
  while (complianceSnapshots.hasNext()) {
    result.add(complianceSnapshots.next());
  }
  return result;
}"
49485,"@Test public void testGetByConsumerUuid(){
  MultivaluedMap<String,String> params=mock(MultivaluedMap.class);
  when(params.containsKey(""String_Node_Str"")).thenReturn(true);
  when(params.get(""String_Node_Str"")).thenReturn(Arrays.asList(""String_Node_Str"",""String_Node_Str""));
  MultiRowResult<DBObject> results=report.run(params);
  assertEquals(1,results.size());
  DBObject row=results.get(0);
  DBObject consumer=(DBObject)row.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",consumer.get(""String_Node_Str""));
}","@Test public void testGetByConsumerUuid(){
  MultivaluedMap<String,String> params=mock(MultivaluedMap.class);
  when(params.containsKey(""String_Node_Str"")).thenReturn(true);
  when(params.get(""String_Node_Str"")).thenReturn(Arrays.asList(""String_Node_Str"",""String_Node_Str""));
  MultiRowResult<DBObject> results=report.run(params);
  assertEquals(1,results.size());
  DBObject snap=results.get(0);
  DBObject consumer=(DBObject)snap.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",consumer.get(""String_Node_Str""));
}"
49486,"@Test public void testGetByOwner(){
  MultivaluedMap<String,String> params=mock(MultivaluedMap.class);
  when(params.containsKey(""String_Node_Str"")).thenReturn(true);
  when(params.get(""String_Node_Str"")).thenReturn(Arrays.asList(""String_Node_Str""));
  MultiRowResult<DBObject> results=report.run(params);
  assertEquals(1,results.size());
  DBObject r=results.get(0);
  DBObject consumer=(DBObject)r.get(""String_Node_Str"");
  DBObject owner=(DBObject)consumer.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",owner.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",consumer.get(""String_Node_Str""));
}","@Test public void testGetByOwner(){
  MultivaluedMap<String,String> params=mock(MultivaluedMap.class);
  when(params.containsKey(""String_Node_Str"")).thenReturn(true);
  when(params.get(""String_Node_Str"")).thenReturn(Arrays.asList(""String_Node_Str""));
  MultiRowResult<DBObject> results=report.run(params);
  assertEquals(1,results.size());
  DBObject snap=results.get(0);
  DBObject consumer=(DBObject)snap.get(""String_Node_Str"");
  DBObject owner=(DBObject)consumer.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",owner.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",consumer.get(""String_Node_Str""));
}"
49487,"@Test public void test() throws AMQException, JMSException, URISyntaxException {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  String connstr=""String_Node_Str"";
  Connection conn=new AMQConnection(connstr);
  conn.start();
  Session sess=conn.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Destination dest=new AMQAnyDestination(""String_Node_Str"");
  MessageConsumer consumer=sess.createConsumer(dest);
  Message msg;
  while ((msg=consumer.receive(-1)) != null) {
    System.out.println(""String_Node_Str"");
    System.out.println(msg);
    System.out.println(""String_Node_Str"");
  }
  consumer.close();
  sess.close();
  conn.close();
  System.out.println(""String_Node_Str"");
}","@Test public void test() throws AMQException, JMSException, URISyntaxException {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  String connstr=""String_Node_Str"" + ""String_Node_Str"";
  Connection conn=new AMQConnection(connstr);
  conn.start();
  Session sess=conn.createSession(false,Session.AUTO_ACKNOWLEDGE);
  Destination dest=new AMQAnyDestination(""String_Node_Str"");
  MessageConsumer consumer=sess.createConsumer(dest);
  Message msg;
  while ((msg=consumer.receive(-1)) != null) {
    System.out.println(""String_Node_Str"");
    System.out.println(msg);
    System.out.println(""String_Node_Str"");
  }
  consumer.close();
  sess.close();
  conn.close();
  System.out.println(""String_Node_Str"");
}"
49488,"@Inject public EventSinkImpl(EventFactory eventFactory,ObjectMapper mapper,Config config){
  this.eventFactory=eventFactory;
  this.mapper=mapper;
  try {
    largeMsgSize=config.getInt(ConfigProperties.HORNETQ_LARGE_MSG_SIZE);
    factory=createClientSessionFactory();
    clientSession=factory.createSession();
    clientProducer=clientSession.createProducer(EventSource.QUEUE_ADDRESS);
  }
 catch (  HornetQException e) {
    throw new RuntimeException(e);
  }
catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Inject public EventSinkImpl(EventFactory eventFactory,ObjectMapper mapper,Config config){
  this.eventFactory=eventFactory;
  this.mapper=mapper;
  try {
    largeMsgSize=config.getInt(ConfigProperties.HORNETQ_LARGE_MSG_SIZE);
    factory=createClientSessionFactory();
  }
 catch (  HornetQException e) {
    throw new RuntimeException(e);
  }
catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
49489,"@Override public void sendEvent(Event event){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + event);
  }
  try {
    ClientMessage message=clientSession.createMessage(true);
    String eventString=mapper.writeValueAsString(event);
    message.getBodyBuffer().writeString(eventString);
    clientProducer.send(message);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + event,e);
  }
}","@Override public void sendEvent(Event event){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + event);
  }
  try {
    ClientMessage message=getClientSession().createMessage(true);
    String eventString=mapper.writeValueAsString(event);
    message.getBodyBuffer().writeString(eventString);
    getClientProducer().send(message);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + event,e);
  }
}"
49490,"public void contextInitialized(Injector injector){
  Config candlepinConfig=new Config();
  if (hornetqServer == null) {
    Configuration config=new ConfigurationImpl();
    HashSet<TransportConfiguration> transports=new HashSet<TransportConfiguration>();
    transports.add(new TransportConfiguration(InVMAcceptorFactory.class.getName()));
    config.setAcceptorConfigurations(transports);
    config.setClustered(false);
    config.setClusterPassword(null);
    config.setSecurityEnabled(false);
    int largeMsgSize=candlepinConfig.getInt(ConfigProperties.HORNETQ_LARGE_MSG_SIZE);
    config.setJournalBufferSize_NIO(largeMsgSize);
    config.setJournalType(JournalType.NIO);
    config.setCreateBindingsDir(true);
    config.setCreateJournalDir(true);
    String baseDir=candlepinConfig.getString(ConfigProperties.HORNETQ_BASE_DIR);
    config.setBindingsDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setJournalDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setLargeMessagesDirectory(new File(baseDir,""String_Node_Str"").toString());
    hornetqServer=new HornetQServerImpl(config);
  }
  try {
    hornetqServer.start();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
  cleanupOldQueues();
  List<String> listeners=Lists.newArrayList(candlepinConfig.getStringArray(ConfigProperties.AUDIT_LISTENERS));
  eventSource=injector.getInstance(EventSource.class);
  for (int i=0; i < listeners.size(); i++) {
    try {
      Class<?> clazz=this.getClass().getClassLoader().loadClass(listeners.get(i));
      eventSource.registerListener((EventListener)injector.getInstance(clazz));
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"" + listeners.get(i),e);
    }
  }
}","public void contextInitialized(Injector injector){
  Config candlepinConfig=new Config();
  if (hornetqServer == null) {
    Configuration config=new ConfigurationImpl();
    HashSet<TransportConfiguration> transports=new HashSet<TransportConfiguration>();
    transports.add(new TransportConfiguration(InVMAcceptorFactory.class.getName()));
    config.setAcceptorConfigurations(transports);
    config.setClustered(false);
    config.setClusterPassword(null);
    config.setSecurityEnabled(false);
    config.setJournalType(JournalType.NIO);
    config.setCreateBindingsDir(true);
    config.setCreateJournalDir(true);
    String baseDir=candlepinConfig.getString(ConfigProperties.HORNETQ_BASE_DIR);
    config.setBindingsDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setJournalDirectory(new File(baseDir,""String_Node_Str"").toString());
    config.setLargeMessagesDirectory(new File(baseDir,""String_Node_Str"").toString());
    hornetqServer=new HornetQServerImpl(config);
  }
  try {
    hornetqServer.start();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
  cleanupOldQueues();
  List<String> listeners=Lists.newArrayList(candlepinConfig.getStringArray(ConfigProperties.AUDIT_LISTENERS));
  eventSource=injector.getInstance(EventSource.class);
  for (int i=0; i < listeners.size(); i++) {
    try {
      Class<?> clazz=this.getClass().getClassLoader().loadClass(listeners.get(i));
      eventSource.registerListener((EventListener)injector.getInstance(clazz));
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"" + listeners.get(i),e);
    }
  }
}"
49491,"/** 
 * @param pool
 * @param consumer
 * @param stackId
 * @param stackedEntitlements
 */
public PoolUpdate updatePoolFromStackedEntitlements(Pool pool,Consumer consumer,String stackId,List<Entitlement> stackedEnts){
  PoolUpdate update=new PoolUpdate(pool);
  if (stackedEnts.isEmpty()) {
    return update;
  }
  pool.setSourceStackId(stackId);
  pool.setSourceEntitlement(null);
  pool.setSourceConsumer(consumer);
  pool.setSubscriptionId(null);
  Entitlement eldest=null;
  Date startDate=null;
  Date endDate=null;
  Set<ProvidedProduct> expectedProvidedProds=new HashSet<ProvidedProduct>();
  Set<ProductPoolAttribute> expectedAttrs=new HashSet<ProductPoolAttribute>();
  for (  Entitlement nextStacked : stackedEnts) {
    if (eldest == null || nextStacked.getCreated().before(eldest.getCreated())) {
      eldest=nextStacked;
    }
    if (startDate == null || nextStacked.getStartDate().before(startDate)) {
      startDate=nextStacked.getStartDate();
    }
    if (endDate == null || nextStacked.getEndDate().after(endDate)) {
      endDate=nextStacked.getEndDate();
    }
    Pool nextStackedPool=nextStacked.getPool();
    if (nextStackedPool.getDerivedProductId() == null) {
      for (      ProvidedProduct pp : nextStackedPool.getProvidedProducts()) {
        expectedProvidedProds.add(new ProvidedProduct(pp.getProductId(),pp.getProductName(),pool));
      }
    }
 else {
      for (      DerivedProvidedProduct pp : nextStackedPool.getDerivedProvidedProducts()) {
        expectedProvidedProds.add(new ProvidedProduct(pp.getProductId(),pp.getProductName(),pool));
      }
    }
    if (nextStackedPool.getDerivedProductId() == null) {
      for (      ProductPoolAttribute attr : nextStackedPool.getProductAttributes()) {
        expectedAttrs.add(new ProductPoolAttribute(attr.getName(),attr.getValue(),pool.getProductId()));
      }
    }
 else {
      for (      DerivedProductPoolAttribute attr : nextStackedPool.getDerivedProductAttributes()) {
        expectedAttrs.add(new ProductPoolAttribute(attr.getName(),attr.getValue(),pool.getProductId()));
      }
    }
  }
  update.setDatesChanged(checkForDateChange(startDate,endDate,pool));
  Pool eldestEntPool=eldest.getPool();
  boolean useDerived=eldestEntPool.getDerivedProductId() != null;
  String prodId=useDerived ? eldestEntPool.getDerivedProductId() : eldestEntPool.getProductId();
  String prodName=useDerived ? eldestEntPool.getDerivedProductName() : eldestEntPool.getProductName();
  update.setProductsChanged(checkForChangedProducts(prodId,prodName,expectedProvidedProds,pool));
  if (!pool.getProductAttributes().equals(expectedAttrs)) {
    pool.getProductAttributes().clear();
    for (    ProductPoolAttribute attr : expectedAttrs) {
      attr.setProductId(pool.getProductId());
      pool.addProductAttribute(attr);
    }
    update.setProductAttributesChanged(true);
  }
  if (!StringUtils.equals(eldestEntPool.getContractNumber(),pool.getContractNumber()) || !StringUtils.equals(eldestEntPool.getOrderNumber(),pool.getOrderNumber()) || !StringUtils.equals(eldestEntPool.getAccountNumber(),pool.getAccountNumber())) {
    pool.setContractNumber(eldestEntPool.getContractNumber());
    pool.setAccountNumber(eldestEntPool.getAccountNumber());
    pool.setOrderNumber(eldestEntPool.getOrderNumber());
    update.setOrderChanged(true);
  }
  return update;
}","/** 
 * @param pool
 * @param consumer
 * @param stackId
 * @param stackedEntitlements
 */
public PoolUpdate updatePoolFromStackedEntitlements(Pool pool,Consumer consumer,String stackId,List<Entitlement> stackedEnts){
  PoolUpdate update=new PoolUpdate(pool);
  if (stackedEnts.isEmpty()) {
    return update;
  }
  pool.setSourceStackId(stackId);
  pool.setSourceEntitlement(null);
  pool.setSourceConsumer(consumer);
  pool.setSubscriptionId(null);
  Entitlement eldest=null;
  Date startDate=null;
  Date endDate=null;
  Set<ProvidedProduct> expectedProvidedProds=new HashSet<ProvidedProduct>();
  Map<String,ProductPoolAttribute> expectedAttrs=new HashMap<String,ProductPoolAttribute>();
  for (  Entitlement nextStacked : stackedEnts) {
    if (eldest == null || nextStacked.getCreated().before(eldest.getCreated())) {
      eldest=nextStacked;
    }
    if (startDate == null || nextStacked.getStartDate().before(startDate)) {
      startDate=nextStacked.getStartDate();
    }
    if (endDate == null || nextStacked.getEndDate().after(endDate)) {
      endDate=nextStacked.getEndDate();
    }
    Pool nextStackedPool=nextStacked.getPool();
    if (nextStackedPool.getDerivedProductId() == null) {
      for (      ProvidedProduct pp : nextStackedPool.getProvidedProducts()) {
        expectedProvidedProds.add(new ProvidedProduct(pp.getProductId(),pp.getProductName(),pool));
      }
    }
 else {
      for (      DerivedProvidedProduct pp : nextStackedPool.getDerivedProvidedProducts()) {
        expectedProvidedProds.add(new ProvidedProduct(pp.getProductId(),pp.getProductName(),pool));
      }
    }
    if (nextStackedPool.getDerivedProductId() == null) {
      for (      ProductPoolAttribute attr : nextStackedPool.getProductAttributes()) {
        expectedAttrs.put(attr.getName(),new ProductPoolAttribute(attr.getName(),attr.getValue(),pool.getProductId()));
      }
    }
 else {
      for (      DerivedProductPoolAttribute attr : nextStackedPool.getDerivedProductAttributes()) {
        expectedAttrs.put(attr.getName(),new ProductPoolAttribute(attr.getName(),attr.getValue(),pool.getProductId()));
      }
    }
  }
  update.setDatesChanged(checkForDateChange(startDate,endDate,pool));
  Pool eldestEntPool=eldest.getPool();
  boolean useDerived=eldestEntPool.getDerivedProductId() != null;
  String prodId=useDerived ? eldestEntPool.getDerivedProductId() : eldestEntPool.getProductId();
  String prodName=useDerived ? eldestEntPool.getDerivedProductName() : eldestEntPool.getProductName();
  update.setProductsChanged(checkForChangedProducts(prodId,prodName,expectedProvidedProds,pool));
  if (!pool.getProductAttributes().equals(expectedAttrs.values())) {
    pool.getProductAttributes().clear();
    for (    ProductPoolAttribute attr : expectedAttrs.values()) {
      attr.setProductId(pool.getProductId());
      pool.addProductAttribute(attr);
    }
    update.setProductAttributesChanged(true);
  }
  if (!StringUtils.equals(eldestEntPool.getContractNumber(),pool.getContractNumber()) || !StringUtils.equals(eldestEntPool.getOrderNumber(),pool.getOrderNumber()) || !StringUtils.equals(eldestEntPool.getAccountNumber(),pool.getAccountNumber())) {
    pool.setContractNumber(eldestEntPool.getContractNumber());
    pool.setAccountNumber(eldestEntPool.getAccountNumber());
    pool.setOrderNumber(eldestEntPool.getOrderNumber());
    update.setOrderChanged(true);
  }
  return update;
}"
49492,"public boolean updatePoolFromStack(Pool pool,Consumer consumer,String stackId){
  return poolRules.updatePoolFromStack(pool,consumer,stackId);
}","public PoolUpdate updatePoolFromStack(Pool pool,Consumer consumer,String stackId){
  return poolRules.updatePoolFromStack(pool,consumer,stackId);
}"
49493,"/** 
 * Remove the given entitlement and clean up.
 * @param entitlement entitlement to remove
 * @param regenModified should we look for modified entitlements that are affectedand regenerated. False if we're mass deleting all the entitlements for a consumer anyhow, true otherwise. Prevents a deadlock issue on mysql (at least).
 */
@Transactional void removeEntitlement(Entitlement entitlement,boolean regenModified){
  Consumer consumer=entitlement.getConsumer();
  Pool pool=entitlement.getPool();
  pool=poolCurator.lockAndLoad(pool);
  consumer.removeEntitlement(entitlement);
  Set<Pool> deletablePools=new HashSet<Pool>();
  for (  Pool p : poolCurator.listBySourceEntitlement(entitlement)) {
    Set<Entitlement> deletableEntitlements=new HashSet<Entitlement>();
    for (    Entitlement e : p.getEntitlements()) {
      deletableEntitlements.add(e);
    }
    for (    Entitlement de : deletableEntitlements) {
      this.revokeEntitlement(de);
    }
    deletablePools.add(p);
  }
  for (  Pool dp : deletablePools) {
    deletePool(dp);
  }
  pool.getEntitlements().remove(entitlement);
  poolCurator.merge(pool);
  entitlementCurator.delete(entitlement);
  Event event=eventFactory.entitlementDeleted(entitlement);
  pool.setConsumed(pool.getConsumed() - entitlement.getQuantity());
  if (consumer.getType().isManifest()) {
    pool.setExported(pool.getExported() - entitlement.getQuantity());
  }
  if (!""String_Node_Str"".equals(pool.getAttributeValue(""String_Node_Str"")) && pool.hasProductAttribute(""String_Node_Str"")) {
    Pool stackedSubPool=poolCurator.getSubPoolForStackId(consumer,pool.getProductAttributeValue(""String_Node_Str""));
    if (stackedSubPool != null) {
      boolean updated=updatePoolFromStack(stackedSubPool,consumer,pool.getProductAttributeValue(""String_Node_Str""));
      if (updated) {
        poolCurator.merge(stackedSubPool);
      }
 else {
        deletePool(stackedSubPool);
      }
    }
  }
  PoolHelper poolHelper=new PoolHelper(this,productCache,entitlement);
  enforcer.postUnbind(consumer,poolHelper,entitlement);
  if (regenModified) {
    this.regenerateCertificatesOf(entitlementCurator.listModifying(entitlement),true);
  }
  ComplianceStatus compliance=complianceRules.getStatus(consumer,new Date());
  consumer.setEntitlementStatus(compliance.getStatus());
  consumerCurator.update(consumer);
  sink.sendEvent(event);
}","/** 
 * Remove the given entitlement and clean up.
 * @param entitlement entitlement to remove
 * @param regenModified should we look for modified entitlements that are affectedand regenerated. False if we're mass deleting all the entitlements for a consumer anyhow, true otherwise. Prevents a deadlock issue on mysql (at least).
 */
@Transactional void removeEntitlement(Entitlement entitlement,boolean regenModified){
  Consumer consumer=entitlement.getConsumer();
  Pool pool=entitlement.getPool();
  pool=poolCurator.lockAndLoad(pool);
  consumer.removeEntitlement(entitlement);
  Set<Pool> deletablePools=new HashSet<Pool>();
  for (  Pool p : poolCurator.listBySourceEntitlement(entitlement)) {
    Set<Entitlement> deletableEntitlements=new HashSet<Entitlement>();
    for (    Entitlement e : p.getEntitlements()) {
      deletableEntitlements.add(e);
    }
    for (    Entitlement de : deletableEntitlements) {
      this.revokeEntitlement(de);
    }
    deletablePools.add(p);
  }
  for (  Pool dp : deletablePools) {
    deletePool(dp);
  }
  pool.getEntitlements().remove(entitlement);
  poolCurator.merge(pool);
  entitlementCurator.delete(entitlement);
  Event event=eventFactory.entitlementDeleted(entitlement);
  pool.setConsumed(pool.getConsumed() - entitlement.getQuantity());
  if (consumer.getType().isManifest()) {
    pool.setExported(pool.getExported() - entitlement.getQuantity());
  }
  if (!""String_Node_Str"".equals(pool.getAttributeValue(""String_Node_Str"")) && pool.hasProductAttribute(""String_Node_Str"")) {
    String stackId=pool.getProductAttributeValue(""String_Node_Str"");
    Pool stackedSubPool=poolCurator.getSubPoolForStackId(consumer,stackId);
    if (stackedSubPool != null) {
      List<Entitlement> stackedEnts=this.entitlementCurator.findByStackId(consumer,stackId);
      if (stackedEnts.isEmpty()) {
        deletePool(stackedSubPool);
      }
 else {
        updatePoolFromStackedEntitlements(stackedSubPool,consumer,stackId,stackedEnts);
        poolCurator.merge(stackedSubPool);
      }
    }
  }
  PoolHelper poolHelper=new PoolHelper(this,productCache,entitlement);
  enforcer.postUnbind(consumer,poolHelper,entitlement);
  if (regenModified) {
    this.regenerateCertificatesOf(entitlementCurator.listModifying(entitlement),true);
  }
  ComplianceStatus compliance=complianceRules.getStatus(consumer,new Date());
  consumer.setEntitlementStatus(compliance.getStatus());
  consumerCurator.update(consumer);
  sink.sendEvent(event);
}"
49494,"/** 
 * Updates the pool based on the entitlements in the specified stack.
 * @param pool
 * @param consumer
 * @param stackId
 * @return true if the pool was successfully updated by another entitlementin the stack, false otherwise.
 */
boolean updatePoolFromStack(Pool pool,Consumer consumer,String stackId);","/** 
 * Updates the pool based on the entitlements in the specified stack.
 * @param pool
 * @param consumer
 * @param stackId
 * @return pool update specifics
 */
PoolUpdate updatePoolFromStack(Pool pool,Consumer consumer,String stackId);"
49495,"/** 
 * Updates the pool based on the entitlements in the specified stack.
 * @param pool
 * @param consumer
 * @param stackId
 * @return pool update specifics
 */
public PoolUpdate updatePoolFromStack(Pool pool,Consumer consumer,String stackId){
  PoolUpdate update=new PoolUpdate(pool);
  List<Entitlement> stackedEnts=this.entCurator.findByStackId(consumer,stackId);
  if (stackedEnts.isEmpty()) {
    return update;
  }
  pool.setSourceStackId(stackId);
  pool.setSourceEntitlement(null);
  pool.setSourceConsumer(consumer);
  pool.setSubscriptionId(null);
  Entitlement eldest=null;
  Date startDate=null;
  Date endDate=null;
  Set<ProvidedProduct> expectedProvidedProds=new HashSet<ProvidedProduct>();
  Set<ProductPoolAttribute> expectedAttrs=new HashSet<ProductPoolAttribute>();
  for (  Entitlement nextStacked : stackedEnts) {
    if (eldest == null || nextStacked.getCreated().before(eldest.getCreated())) {
      eldest=nextStacked;
    }
    if (startDate == null || nextStacked.getStartDate().before(startDate)) {
      startDate=nextStacked.getStartDate();
    }
    if (endDate == null || nextStacked.getEndDate().after(endDate)) {
      endDate=nextStacked.getEndDate();
    }
    Pool nextStackedPool=nextStacked.getPool();
    if (nextStackedPool.getDerivedProductId() == null) {
      for (      ProvidedProduct pp : nextStackedPool.getProvidedProducts()) {
        expectedProvidedProds.add(new ProvidedProduct(pp.getProductId(),pp.getProductName(),pool));
      }
    }
 else {
      for (      DerivedProvidedProduct pp : nextStackedPool.getDerivedProvidedProducts()) {
        expectedProvidedProds.add(new ProvidedProduct(pp.getProductId(),pp.getProductName(),pool));
      }
    }
    if (nextStackedPool.getDerivedProductId() == null) {
      for (      ProductPoolAttribute attr : nextStackedPool.getProductAttributes()) {
        expectedAttrs.add(new ProductPoolAttribute(attr.getName(),attr.getValue(),pool.getProductId()));
      }
    }
 else {
      for (      DerivedProductPoolAttribute attr : nextStackedPool.getDerivedProductAttributes()) {
        expectedAttrs.add(new ProductPoolAttribute(attr.getName(),attr.getValue(),pool.getProductId()));
      }
    }
  }
  update.setDatesChanged(checkForDateChange(startDate,endDate,pool));
  Pool eldestEntPool=eldest.getPool();
  update.setProductsChanged(checkForChangedProducts(eldestEntPool.getProductId(),eldestEntPool.getProductName(),expectedProvidedProds,pool));
  if (!pool.getProductAttributes().equals(expectedAttrs)) {
    for (    ProductPoolAttribute attr : expectedAttrs) {
      attr.setProductId(pool.getProductId());
    }
    pool.getProductAttributes().clear();
    pool.getProductAttributes().addAll(expectedAttrs);
    update.setProductAttributesChanged(true);
  }
  if (!StringUtils.equals(eldestEntPool.getContractNumber(),pool.getContractNumber()) || !StringUtils.equals(eldestEntPool.getOrderNumber(),pool.getOrderNumber()) || !StringUtils.equals(eldestEntPool.getAccountNumber(),pool.getAccountNumber())) {
    pool.setContractNumber(eldestEntPool.getContractNumber());
    pool.setAccountNumber(eldestEntPool.getAccountNumber());
    pool.setOrderNumber(eldestEntPool.getOrderNumber());
    update.setOrderChanged(true);
  }
  return update;
}","/** 
 * Updates the pool based on the entitlements in the specified stack.
 * @param pool
 * @param consumer
 * @param stackId
 * @return pool update specifics
 */
public PoolUpdate updatePoolFromStack(Pool pool,Consumer consumer,String stackId){
  List<Entitlement> stackedEnts=this.entCurator.findByStackId(consumer,stackId);
  return this.updatePoolFromStackedEntitlements(pool,consumer,stackId,stackedEnts);
}"
49496,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testRefreshPoolsSortsStackDerivedPools(){
  List<Subscription> subscriptions=Util.newList();
  List<Pool> pools=Util.newList();
  Pool p=TestUtil.createPool(TestUtil.createProduct());
  p.setLinkedStackId(""String_Node_Str"");
  pools.add(p);
  when(mockSubAdapter.getSubscriptions(any(Owner.class))).thenReturn(subscriptions);
  when(mockPoolCurator.listAvailableEntitlementPools(any(Consumer.class),any(Owner.class),anyString(),any(Date.class),anyBoolean(),anyBoolean())).thenReturn(pools);
  this.manager.getRefresher().add(getOwner()).run();
  ArgumentCaptor<List> poolCaptor=ArgumentCaptor.forClass(List.class);
  verify(this.poolRulesMock).updatePools(poolCaptor.capture());
  assertEquals(1,poolCaptor.getValue().size());
  assertEquals(p,poolCaptor.getValue().get(0));
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testRefreshPoolsSortsStackDerivedPools(){
  List<Subscription> subscriptions=Util.newList();
  List<Pool> pools=Util.newList();
  Pool p=TestUtil.createPool(TestUtil.createProduct());
  p.setLinkedStackId(""String_Node_Str"");
  pools.add(p);
  when(mockSubAdapter.getSubscriptions(any(Owner.class))).thenReturn(subscriptions);
  Page page=mock(Page.class);
  when(page.getPageData()).thenReturn(pools);
  when(mockPoolCurator.listAvailableEntitlementPools(any(Consumer.class),any(Owner.class),anyString(),any(Date.class),anyBoolean(),any(PageRequest.class))).thenReturn(page);
  this.manager.getRefresher().add(getOwner()).run();
  ArgumentCaptor<List> poolCaptor=ArgumentCaptor.forClass(List.class);
  verify(this.poolRulesMock).updatePools(poolCaptor.capture());
  assertEquals(1,poolCaptor.getValue().size());
  assertEquals(p,poolCaptor.getValue().get(0));
}"
49497,"public Set<ProductContent> filterContentByContentArch(Set<ProductContent> pcSet,Consumer consumer,Product product){
  Set<ProductContent> filtered=new HashSet<ProductContent>();
  boolean enabledContentArchFiltering=true;
  if (!enabledContentArchFiltering) {
    return pcSet;
  }
  String consumerArch=consumer.getFact(ARCH_FACT);
  log.debug(""String_Node_Str"" + consumerArch);
  if (consumerArch == null) {
    log.debug(""String_Node_Str"" + consumer.getId() + ""String_Node_Str""+ ARCH_FACT+ ""String_Node_Str"");
    log.debug(""String_Node_Str"");
    return pcSet;
  }
  for (  ProductContent pc : pcSet) {
    boolean canUse=false;
    Set<String> contentArches=Arch.parseArches(pc.getContent().getArches());
    Set<String> productArches=Arch.parseArches(product.getAttributeValue(PRODUCT_ARCH_ATTR));
    log.debug(""String_Node_Str"" + pc.getContent().getLabel());
    log.debug(""String_Node_Str"" + contentArches);
    log.debug(""String_Node_Str"" + productArches);
    if (contentArches.isEmpty()) {
      log.debug(""String_Node_Str"" + pc.getContent().getLabel() + ""String_Node_Str"");
      contentArches.addAll(productArches);
      log.debug(""String_Node_Str"" + product.toString());
      log.debug(""String_Node_Str"" + productArches.toString());
    }
    for (    String contentArch : contentArches) {
      log.debug(""String_Node_Str"" + consumerArch + ""String_Node_Str""+ contentArch);
      log.debug(""String_Node_Str"" + Arch.contentForConsumer(contentArch,consumerArch));
      if (Arch.contentForConsumer(contentArch,consumerArch)) {
        log.debug(""String_Node_Str"" + pc.getContent().getLabel() + ""String_Node_Str""+ contentArch);
        canUse=true;
      }
 else {
        log.debug(""String_Node_Str"" + pc.getContent().getLabel() + ""String_Node_Str""+ contentArch);
      }
      canUse=true;
    }
    if (canUse) {
      filtered.add(pc);
      log.debug(""String_Node_Str"" + pc.getContent().getLabel());
    }
 else {
      log.debug(""String_Node_Str"" + pc.getContent().getLabel());
    }
  }
  log.debug(""String_Node_Str"" + consumerArch + ""String_Node_Str"");
  for (  ProductContent apc : filtered) {
    log.debug(""String_Node_Str"" + apc.toString());
  }
  return filtered;
}","public Set<ProductContent> filterContentByContentArch(Set<ProductContent> pcSet,Consumer consumer,Product product){
  Set<ProductContent> filtered=new HashSet<ProductContent>();
  boolean enabledContentArchFiltering=true;
  if (!enabledContentArchFiltering) {
    return pcSet;
  }
  String consumerArch=consumer.getFact(ARCH_FACT);
  log.debug(""String_Node_Str"" + consumerArch);
  if (consumerArch == null) {
    log.debug(""String_Node_Str"" + consumer.getId() + ""String_Node_Str""+ ARCH_FACT+ ""String_Node_Str"");
    log.debug(""String_Node_Str"");
    return pcSet;
  }
  for (  ProductContent pc : pcSet) {
    boolean canUse=false;
    Set<String> contentArches=Arch.parseArches(pc.getContent().getArches());
    Set<String> productArches=Arch.parseArches(product.getAttributeValue(PRODUCT_ARCH_ATTR));
    log.debug(""String_Node_Str"" + pc.getContent().getLabel());
    log.debug(""String_Node_Str"" + contentArches);
    log.debug(""String_Node_Str"" + productArches);
    if (contentArches.isEmpty()) {
      log.debug(""String_Node_Str"" + pc.getContent().getLabel() + ""String_Node_Str"");
      contentArches.addAll(productArches);
      log.debug(""String_Node_Str"" + product.toString());
      log.debug(""String_Node_Str"" + productArches.toString());
    }
    for (    String contentArch : contentArches) {
      log.debug(""String_Node_Str"" + consumerArch + ""String_Node_Str""+ contentArch);
      log.debug(""String_Node_Str"" + Arch.contentForConsumer(contentArch,consumerArch));
      if (Arch.contentForConsumer(contentArch,consumerArch)) {
        log.debug(""String_Node_Str"" + pc.getContent().getLabel() + ""String_Node_Str""+ contentArch);
        canUse=true;
      }
 else {
        log.debug(""String_Node_Str"" + pc.getContent().getLabel() + ""String_Node_Str""+ contentArch);
      }
    }
    if (canUse) {
      filtered.add(pc);
      log.debug(""String_Node_Str"" + pc.getContent().getLabel());
    }
 else {
      log.debug(""String_Node_Str"" + pc.getContent().getLabel());
    }
  }
  log.debug(""String_Node_Str"" + consumerArch + ""String_Node_Str"");
  for (  ProductContent apc : filtered) {
    log.debug(""String_Node_Str"" + apc.toString());
  }
  return filtered;
}"
49498,"protected Integer getLastPage(Page page){
  PageRequest pageRequest=page.getPageRequest();
  return (page.getMaxRecords() / pageRequest.getPerPage()) + 1;
}","protected Integer getLastPage(Page page){
  PageRequest pageRequest=page.getPageRequest();
  int lastPage=page.getMaxRecords() / pageRequest.getPerPage();
  if (page.getMaxRecords() % pageRequest.getPerPage() != 0) {
    lastPage++;
  }
  return lastPage;
}"
49499,"public void setMessage(Consumer c,ComplianceReason reason){
  String base=KEYS.get(reason.getKey());
  if (base == null) {
    base=KEYS.get(""String_Node_Str"");
  }
  String marketingName, id;
  if (reason.isStacked()) {
    id=reason.getAttributes().get(""String_Node_Str"");
    marketingName=getStackedMarketingName(id,c);
    reason.setMessage(i18n.tr(base,marketingName,reason.getAttributes().get(""String_Node_Str""),reason.getAttributes().get(""String_Node_Str"")));
  }
 else   if (reason.isNonCovered()) {
    id=reason.getAttributes().get(""String_Node_Str"");
    marketingName=getInstalledMarketingName(id,c);
    reason.setMessage(i18n.tr(base,marketingName));
  }
 else {
    id=reason.getAttributes().get(""String_Node_Str"");
    marketingName=getMarketingName(id,c);
    reason.setMessage(i18n.tr(base,marketingName,reason.getAttributes().get(""String_Node_Str""),reason.getAttributes().get(""String_Node_Str"")));
  }
}","public void setMessage(Consumer c,ComplianceReason reason){
  String base=KEYS.get(reason.getKey());
  if (base == null) {
    base=KEYS.get(""String_Node_Str"");
  }
  String marketingName, id;
  if (reason.isStacked()) {
    id=reason.getAttributes().get(""String_Node_Str"");
    marketingName=getStackedMarketingName(id,c);
    reason.setMessage(i18n.tr(base,marketingName,reason.getAttributes().get(""String_Node_Str""),reason.getAttributes().get(""String_Node_Str""),reason.getKey()));
  }
 else   if (reason.isNonCovered()) {
    id=reason.getAttributes().get(""String_Node_Str"");
    marketingName=getInstalledMarketingName(id,c);
    reason.setMessage(i18n.tr(base,marketingName));
  }
 else {
    id=reason.getAttributes().get(""String_Node_Str"");
    marketingName=getMarketingName(id,c);
    reason.setMessage(i18n.tr(base,marketingName,reason.getAttributes().get(""String_Node_Str""),reason.getAttributes().get(""String_Node_Str""),reason.getKey()));
  }
}"
49500,"public List<PoolUpdate> updatePools(Subscription sub,List<Pool> existingPools){
  log.info(""String_Node_Str"" + sub);
  log.info(""String_Node_Str"" + existingPools.size());
  PoolHelper helper=new PoolHelper(this.poolManager,this.productCache,null);
  List<PoolUpdate> poolsUpdated=new LinkedList<PoolUpdate>();
  Map<String,String> attributes=helper.getFlattenedAttributes(sub.getProduct());
  for (  Pool existingPool : existingPools) {
    log.info(""String_Node_Str"" + existingPool.getId());
    boolean datesChanged=(!sub.getStartDate().equals(existingPool.getStartDate())) || (!sub.getEndDate().equals(existingPool.getEndDate()));
    long expectedQuantity=sub.getQuantity() * sub.getProduct().getMultiplier();
    if (existingPool.hasAttribute(""String_Node_Str"") && existingPool.attributeEquals(""String_Node_Str"",""String_Node_Str"") && existingPool.hasProductAttribute(""String_Node_Str"")) {
      if (!attributes.containsKey(""String_Node_Str"")) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + existingPool.getId());
        existingPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
        expectedQuantity=0;
      }
 else {
        String virtLimitStr=attributes.get(""String_Node_Str"");
        if (""String_Node_Str"".equals(virtLimitStr)) {
          expectedQuantity=existingPool.getQuantity() == 0 ? 0 : -1;
        }
 else {
          try {
            int virtLimit=Integer.parseInt(virtLimitStr);
            if (config.standalone()) {
              expectedQuantity=existingPool.getSourceEntitlement().getQuantity() * virtLimit;
            }
 else {
              long adjust=0L;
              for (              Pool derivedPool : existingPools) {
                String isDerived=derivedPool.getAttributeValue(""String_Node_Str"");
                if (isDerived == null) {
                  adjust=derivedPool.getExported();
                }
              }
              expectedQuantity=(expectedQuantity - adjust) * virtLimit;
            }
          }
 catch (          NumberFormatException nfe) {
            continue;
          }
        }
      }
    }
    boolean quantityChanged=!(expectedQuantity == existingPool.getQuantity());
    boolean productsChanged=helper.checkForChangedProducts(existingPool,sub);
    boolean prodAttrsChanged=helper.copyProductAttributesOntoPool(sub,existingPool);
    boolean orderDataChanged=helper.checkForOrderChanges(existingPool,sub);
    if (prodAttrsChanged) {
      log.info(""String_Node_Str"");
    }
    if (!(quantityChanged || datesChanged || productsChanged|| prodAttrsChanged|| orderDataChanged)) {
      log.info(""String_Node_Str"");
      continue;
    }
    if (quantityChanged) {
      this.updateQuantityChanged(existingPool,expectedQuantity);
    }
    if (orderDataChanged) {
      this.updateOrderChanged(existingPool,sub);
    }
    if (datesChanged) {
      this.updateDatesChanged(existingPool,sub);
    }
    if (productsChanged) {
      this.updateDatesChanged(existingPool,sub);
    }
    poolsUpdated.add(new org.candlepin.policy.js.pool.PoolUpdate(existingPool,datesChanged,quantityChanged,productsChanged,orderDataChanged));
  }
  return poolsUpdated;
}","public List<PoolUpdate> updatePools(Subscription sub,List<Pool> existingPools){
  log.info(""String_Node_Str"" + sub);
  log.info(""String_Node_Str"" + existingPools.size());
  PoolHelper helper=new PoolHelper(this.poolManager,this.productCache,null);
  List<PoolUpdate> poolsUpdated=new LinkedList<PoolUpdate>();
  Map<String,String> attributes=helper.getFlattenedAttributes(sub.getProduct());
  for (  Pool existingPool : existingPools) {
    log.info(""String_Node_Str"" + existingPool.getId());
    boolean datesChanged=(!sub.getStartDate().equals(existingPool.getStartDate())) || (!sub.getEndDate().equals(existingPool.getEndDate()));
    long expectedQuantity=sub.getQuantity() * sub.getProduct().getMultiplier();
    if (existingPool.hasAttribute(""String_Node_Str"") && existingPool.attributeEquals(""String_Node_Str"",""String_Node_Str"") && existingPool.hasProductAttribute(""String_Node_Str"")) {
      if (!attributes.containsKey(""String_Node_Str"")) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + existingPool.getId());
        existingPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
        expectedQuantity=0;
      }
 else {
        String virtLimitStr=attributes.get(""String_Node_Str"");
        if (""String_Node_Str"".equals(virtLimitStr)) {
          expectedQuantity=existingPool.getQuantity() == 0 ? 0 : -1;
        }
 else {
          try {
            int virtLimit=Integer.parseInt(virtLimitStr);
            if (config.standalone()) {
              expectedQuantity=existingPool.getSourceEntitlement().getQuantity() * virtLimit;
            }
 else {
              long adjust=0L;
              for (              Pool derivedPool : existingPools) {
                String isDerived=derivedPool.getAttributeValue(""String_Node_Str"");
                if (isDerived == null) {
                  adjust=derivedPool.getExported();
                }
              }
              expectedQuantity=(expectedQuantity - adjust) * virtLimit;
            }
          }
 catch (          NumberFormatException nfe) {
            continue;
          }
        }
      }
    }
    boolean quantityChanged=!(expectedQuantity == existingPool.getQuantity());
    boolean productsChanged=helper.checkForChangedProducts(existingPool,sub);
    boolean prodAttrsChanged=helper.copyProductAttributesOntoPool(sub,existingPool);
    boolean orderDataChanged=helper.checkForOrderChanges(existingPool,sub);
    if (prodAttrsChanged) {
      log.info(""String_Node_Str"");
    }
    if (!(quantityChanged || datesChanged || productsChanged|| prodAttrsChanged|| orderDataChanged)) {
      log.info(""String_Node_Str"");
      continue;
    }
    if (quantityChanged) {
      this.updateQuantityChanged(existingPool,expectedQuantity);
    }
    if (orderDataChanged) {
      this.updateOrderChanged(existingPool,sub);
    }
    if (datesChanged) {
      this.updateDatesChanged(existingPool,sub);
    }
    if (productsChanged) {
      this.updateProductsChagned(existingPool,sub);
    }
    poolsUpdated.add(new org.candlepin.policy.js.pool.PoolUpdate(existingPool,datesChanged,quantityChanged,productsChanged,orderDataChanged));
  }
  return poolsUpdated;
}"
49501,"private void buildSegments(Map<String,Integer> segments,Set<PathNode> nodes,PathNode parent){
  if (!nodes.contains(parent)) {
    nodes.add(parent);
    for (    NodePair np : parent.getChildren()) {
      Integer count=segments.get(np.getName());
      if (count == null) {
        count=new Integer(0);
      }
      segments.put(np.getName(),++count);
      buildSegments(segments,nodes,np.getConnection());
    }
  }
}","private void buildSegments(Map<String,Integer> segments,Set<PathNode> nodes,PathNode parent){
  if (!nodes.contains(parent)) {
    nodes.add(parent);
    for (    NodePair np : parent.getChildren()) {
      Integer count=segments.get(np.getName());
      if (count == null) {
        count=0;
      }
      segments.put(np.getName(),++count);
      buildSegments(segments,nodes,np.getConnection());
    }
  }
}"
49502,"public Subscription createSubscription(org.candlepin.model.Subscription sub,Entitlement ent){
  Subscription toReturn=new Subscription();
  toReturn.setSku(sub.getProduct().getId().toString());
  toReturn.setName(sub.getProduct().getName());
  String warningPeriod=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (warningPeriod != null && !warningPeriod.trim().equals(""String_Node_Str"")) {
    if (!warningPeriod.equals(""String_Node_Str"")) {
      toReturn.setWarning(new Integer(warningPeriod));
    }
  }
  String socketLimit=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (socketLimit != null && !socketLimit.trim().equals(""String_Node_Str"")) {
    toReturn.setSockets(new Integer(socketLimit));
  }
  String ramLimit=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (ramLimit != null && !ramLimit.trim().equals(""String_Node_Str"")) {
    toReturn.setRam(new Integer(ramLimit));
  }
  String coreLimit=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (coreLimit != null && !coreLimit.trim().equals(""String_Node_Str"")) {
    toReturn.setCores(new Integer(coreLimit));
  }
  String management=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (management != null && !management.trim().equals(""String_Node_Str"")) {
    if (management.equalsIgnoreCase(""String_Node_Str"") || management.equalsIgnoreCase(""String_Node_Str"")) {
      toReturn.setManagement(Boolean.TRUE);
    }
  }
  String stackingId=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (stackingId != null && !stackingId.trim().equals(""String_Node_Str"")) {
    toReturn.setStackingId(stackingId);
  }
  String virtOnly=ent.getPool().getAttributeValue(""String_Node_Str"");
  if (virtOnly != null && !virtOnly.trim().equals(""String_Node_Str"")) {
    Boolean vo=new Boolean(virtOnly.equalsIgnoreCase(""String_Node_Str"") || virtOnly.equalsIgnoreCase(""String_Node_Str""));
    if (vo) {
      toReturn.setVirtOnly(vo);
    }
  }
  toReturn.setService(createService(sub));
  return toReturn;
}","public Subscription createSubscription(org.candlepin.model.Subscription sub,Entitlement ent){
  Subscription toReturn=new Subscription();
  toReturn.setSku(sub.getProduct().getId().toString());
  toReturn.setName(sub.getProduct().getName());
  String warningPeriod=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (warningPeriod != null && !warningPeriod.trim().equals(""String_Node_Str"")) {
    if (!warningPeriod.equals(""String_Node_Str"")) {
      toReturn.setWarning(new Integer(warningPeriod));
    }
  }
  String socketLimit=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (socketLimit != null && !socketLimit.trim().equals(""String_Node_Str"")) {
    toReturn.setSockets(new Integer(socketLimit));
  }
  String ramLimit=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (ramLimit != null && !ramLimit.trim().equals(""String_Node_Str"")) {
    toReturn.setRam(new Integer(ramLimit));
  }
  String coreLimit=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (coreLimit != null && !coreLimit.trim().equals(""String_Node_Str"")) {
    toReturn.setCores(new Integer(coreLimit));
  }
  String management=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (management != null && !management.trim().equals(""String_Node_Str"")) {
    if (management.equalsIgnoreCase(""String_Node_Str"") || management.equalsIgnoreCase(""String_Node_Str"")) {
      toReturn.setManagement(Boolean.TRUE);
    }
  }
  String stackingId=sub.getProduct().getAttributeValue(""String_Node_Str"");
  if (stackingId != null && !stackingId.trim().equals(""String_Node_Str"")) {
    toReturn.setStackingId(stackingId);
  }
  String virtOnly=ent.getPool().getAttributeValue(""String_Node_Str"");
  if (virtOnly != null && !virtOnly.trim().equals(""String_Node_Str"")) {
    Boolean vo=Boolean.valueOf(virtOnly.equalsIgnoreCase(""String_Node_Str"") || virtOnly.equalsIgnoreCase(""String_Node_Str""));
    if (vo) {
      toReturn.setVirtOnly(vo);
    }
  }
  toReturn.setService(createService(sub));
  return toReturn;
}"
49503,"public List<String> hydrateContentPackage(byte[] payload) throws IOException, UnsupportedEncodingException {
  List<HuffNode> pathDictionary=new ArrayList<HuffNode>();
  List<HuffNode> nodeDictionary=new ArrayList<HuffNode>();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  Inflater i=new Inflater();
  InflaterOutputStream ios=new InflaterOutputStream(baos,i);
  ios.write(payload);
  ios.finish();
  long read=i.getBytesRead();
  String name=""String_Node_Str"";
  int weight=1;
  for (  byte b : baos.toByteArray()) {
    if (b == '\0') {
      pathDictionary.add(new HuffNode(name,weight++));
      name=""String_Node_Str"";
    }
 else {
      name+=(char)b;
    }
  }
  pathDictionary.add(new HuffNode(END_NODE,weight));
  List<HuffNode> triePathDictionary=new ArrayList<HuffNode>();
  triePathDictionary.addAll(pathDictionary);
  HuffNode pathTrie=makeTrie(triePathDictionary);
  StringBuffer nodeBits=new StringBuffer();
  ByteArrayInputStream bais=new ByteArrayInputStream(payload,(new Long(read)).intValue(),(new Long(payload.length - read).intValue()));
  int value=bais.read();
  int nodeCount=value;
  if (value > 127) {
    byte[] count=new byte[value - 128];
    bais.read(count);
    int total=0;
    for (int k=0; k < value - 128; k++) {
      total=(total << 8) | (count[k] & 0xFF);
    }
    nodeCount=total;
  }
  value=bais.read();
  while (value != -1) {
    String someBits=Integer.toString(value,2);
    for (int pad=0; pad < 8 - someBits.length(); pad++) {
      nodeBits.append(""String_Node_Str"");
    }
    nodeBits.append(someBits);
    value=bais.read();
  }
  for (int j=0; j < nodeCount; j++) {
    nodeDictionary.add(new HuffNode(new PathNode(),j));
  }
  List<HuffNode> trieNodeDictionary=new ArrayList<HuffNode>();
  trieNodeDictionary.addAll(nodeDictionary);
  HuffNode nodeTrie=makeTrie(trieNodeDictionary);
  Set<PathNode> pathNodes=populatePathNodes(nodeDictionary,pathTrie,nodeTrie,nodeBits);
  PathNode root=null;
  for (  PathNode pn : pathNodes) {
    if (pn.getParents().size() == 0) {
      root=pn;
      break;
    }
  }
  List<String> urls=new ArrayList<String>();
  StringBuffer aPath=new StringBuffer();
  makeURLs(root,urls,aPath);
  return urls;
}","public List<String> hydrateContentPackage(byte[] payload) throws IOException, UnsupportedEncodingException {
  List<HuffNode> pathDictionary=new ArrayList<HuffNode>();
  List<HuffNode> nodeDictionary=new ArrayList<HuffNode>();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  Inflater i=new Inflater();
  InflaterOutputStream ios=new InflaterOutputStream(baos,i);
  ios.write(payload);
  ios.finish();
  long read=i.getBytesRead();
  String name=""String_Node_Str"";
  int weight=1;
  for (  byte b : baos.toByteArray()) {
    if (b == '\0') {
      pathDictionary.add(new HuffNode(name,weight++));
      name=""String_Node_Str"";
    }
 else {
      name+=(char)b;
    }
  }
  pathDictionary.add(new HuffNode(END_NODE,weight));
  List<HuffNode> triePathDictionary=new ArrayList<HuffNode>();
  triePathDictionary.addAll(pathDictionary);
  HuffNode pathTrie=makeTrie(triePathDictionary);
  StringBuffer nodeBits=new StringBuffer();
  ByteArrayInputStream bais=new ByteArrayInputStream(payload,(int)read,(int)(payload.length - read));
  int value=bais.read();
  int nodeCount=value;
  if (value > 127) {
    byte[] count=new byte[value - 128];
    bais.read(count);
    int total=0;
    for (int k=0; k < value - 128; k++) {
      total=(total << 8) | (count[k] & 0xFF);
    }
    nodeCount=total;
  }
  value=bais.read();
  while (value != -1) {
    String someBits=Integer.toString(value,2);
    for (int pad=0; pad < 8 - someBits.length(); pad++) {
      nodeBits.append(""String_Node_Str"");
    }
    nodeBits.append(someBits);
    value=bais.read();
  }
  for (int j=0; j < nodeCount; j++) {
    nodeDictionary.add(new HuffNode(new PathNode(),j));
  }
  List<HuffNode> trieNodeDictionary=new ArrayList<HuffNode>();
  trieNodeDictionary.addAll(nodeDictionary);
  HuffNode nodeTrie=makeTrie(trieNodeDictionary);
  Set<PathNode> pathNodes=populatePathNodes(nodeDictionary,pathTrie,nodeTrie,nodeBits);
  PathNode root=null;
  for (  PathNode pn : pathNodes) {
    if (pn.getParents().size() == 0) {
      root=pn;
      break;
    }
  }
  List<String> urls=new ArrayList<String>();
  StringBuffer aPath=new StringBuffer();
  makeURLs(root,urls,aPath);
  return urls;
}"
49504,"private void verifyPersonConsumer(Consumer consumer,ConsumerType type,Owner owner,String username){
  User user=null;
  try {
    user=userService.findByLogin(username);
  }
 catch (  UnsupportedOperationException e) {
    log.warn(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!user.hasOwnerAccess(owner,Access.ALL) && !user.isSuperAdmin()) {
    throw new ForbiddenException(i18n.tr(""String_Node_Str"",user.getUsername(),owner.getKey()));
  }
  if (type.isType(ConsumerTypeEnum.PERSON)) {
    Consumer existing=consumerCurator.findByUser(user);
    if (existing != null && existing.getType().isType(ConsumerTypeEnum.PERSON)) {
      throw new BadRequestException(i18n.tr(""String_Node_Str"",user.getUsername()));
    }
    consumer.setName(user.getUsername());
  }
}","private void verifyPersonConsumer(Consumer consumer,ConsumerType type,Owner owner,String username){
  User user=null;
  try {
    user=userService.findByLogin(username);
  }
 catch (  UnsupportedOperationException e) {
    log.warn(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (user == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str""));
  }
  if (!user.hasOwnerAccess(owner,Access.ALL) && !user.isSuperAdmin()) {
    throw new ForbiddenException(i18n.tr(""String_Node_Str"",user.getUsername(),owner.getKey()));
  }
  if (type.isType(ConsumerTypeEnum.PERSON)) {
    Consumer existing=consumerCurator.findByUser(user);
    if (existing != null && existing.getType().isType(ConsumerTypeEnum.PERSON)) {
      throw new BadRequestException(i18n.tr(""String_Node_Str"",user.getUsername()));
    }
    consumer.setName(user.getUsername());
  }
}"
49505,"@Transactional(rollbackOn={IOException.class,ImporterException.class,RuntimeException.class,ImportConflictException.class}) ConsumerDto importObjects(Owner owner,Map<String,File> importFiles,ConflictOverrides overrides) throws IOException, ImporterException {
  File metadata=importFiles.get(ImportFile.META.fileName());
  if (metadata == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerTypes=importFiles.get(ImportFile.CONSUMER_TYPE.fileName());
  if (consumerTypes == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerFile=importFiles.get(ImportFile.CONSUMER.fileName());
  if (consumerFile == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File products=importFiles.get(ImportFile.PRODUCTS.fileName());
  File entitlements=importFiles.get(ImportFile.ENTITLEMENTS.fileName());
  if (products != null && entitlements == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  List<ImportConflictException> conflictExceptions=new LinkedList<ImportConflictException>();
  File rules=importFiles.get(ImportFile.RULES_FILE.fileName());
  importRules(rules,metadata);
  importConsumerTypes(consumerTypes.listFiles());
  try {
    validateMetadata(ExporterMetadata.TYPE_PER_USER,owner,metadata,overrides);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  ConsumerDto consumer=null;
  try {
    Meta m=mapper.readValue(metadata,Meta.class);
    File upstreamFile=importFiles.get(ImportFile.UPSTREAM_CONSUMER.fileName());
    File[] dafiles=new File[0];
    if (upstreamFile != null) {
      dafiles=upstreamFile.listFiles();
    }
    consumer=importConsumer(owner,consumerFile,dafiles,overrides,m);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  if (!conflictExceptions.isEmpty()) {
    log.error(""String_Node_Str"");
    for (    ImportConflictException e : conflictExceptions) {
      log.error(e.message().getConflicts());
    }
    throw new ImportConflictException(conflictExceptions);
  }
  if (importFiles.get(ImportFile.PRODUCTS.fileName()) != null) {
    Refresher refresher=poolManager.getRefresher();
    ProductImporter importer=new ProductImporter(productCurator,contentCurator,poolManager);
    Set<Product> productsToImport=importProducts(importFiles.get(ImportFile.PRODUCTS.fileName()).listFiles(),importer);
    Set<Product> modifiedProducts=importer.getChangedProducts(productsToImport);
    for (    Product product : modifiedProducts) {
      refresher.add(product);
    }
    importer.store(productsToImport);
    importEntitlements(owner,productsToImport,entitlements.listFiles(),consumer);
    refresher.add(owner);
    refresher.run();
  }
 else {
    log.warn(""String_Node_Str"");
  }
  return consumer;
}","@Transactional(rollbackOn={IOException.class,ImporterException.class,RuntimeException.class,ImportConflictException.class}) ConsumerDto importObjects(Owner owner,Map<String,File> importFiles,ConflictOverrides overrides) throws IOException, ImporterException {
  File metadata=importFiles.get(ImportFile.META.fileName());
  if (metadata == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerTypes=importFiles.get(ImportFile.CONSUMER_TYPE.fileName());
  if (consumerTypes == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File consumerFile=importFiles.get(ImportFile.CONSUMER.fileName());
  if (consumerFile == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  File products=importFiles.get(ImportFile.PRODUCTS.fileName());
  File entitlements=importFiles.get(ImportFile.ENTITLEMENTS.fileName());
  if (products != null && entitlements == null) {
    throw new ImporterException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  List<ImportConflictException> conflictExceptions=new LinkedList<ImportConflictException>();
  File rules=importFiles.get(ImportFile.RULES_FILE.fileName());
  importRules(rules,metadata);
  importConsumerTypes(consumerTypes.listFiles());
  try {
    validateMetadata(ExporterMetadata.TYPE_PER_USER,owner,metadata,overrides);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  ConsumerDto consumer=null;
  try {
    Meta m=mapper.readValue(metadata,Meta.class);
    File upstreamFile=importFiles.get(ImportFile.UPSTREAM_CONSUMER.fileName());
    File[] dafiles=new File[0];
    if (upstreamFile != null) {
      dafiles=upstreamFile.listFiles();
    }
    consumer=importConsumer(owner,consumerFile,dafiles,overrides,m);
  }
 catch (  ImportConflictException e) {
    conflictExceptions.add(e);
  }
  if (!conflictExceptions.isEmpty()) {
    log.error(""String_Node_Str"");
    for (    ImportConflictException e : conflictExceptions) {
      log.error(e.message().getConflicts());
    }
    throw new ImportConflictException(conflictExceptions);
  }
  if (importFiles.get(ImportFile.PRODUCTS.fileName()) != null) {
    Refresher refresher=poolManager.getRefresher();
    ProductImporter importer=new ProductImporter(productCurator,contentCurator);
    Set<Product> productsToImport=importProducts(importFiles.get(ImportFile.PRODUCTS.fileName()).listFiles(),importer);
    Set<Product> modifiedProducts=importer.getChangedProducts(productsToImport);
    for (    Product product : modifiedProducts) {
      refresher.add(product);
    }
    importer.store(productsToImport);
    importEntitlements(owner,productsToImport,entitlements.listFiles(),consumer);
    refresher.add(owner);
    refresher.run();
  }
 else {
    log.warn(""String_Node_Str"");
  }
  return consumer;
}"
49506,"public ProductImporter(ProductCurator curator,ContentCurator contentCurator,PoolManager poolManager){
  this.curator=curator;
  this.contentCurator=contentCurator;
  this.poolManager=poolManager;
}","public ProductImporter(ProductCurator curator,ContentCurator contentCurator){
  this.curator=curator;
  this.contentCurator=contentCurator;
}"
49507,"@Before public void setUp() throws IOException {
  mapper=SyncUtils.getObjectMapper(new Config(new HashMap<String,String>()));
  productCuratorMock=mock(ProductCurator.class);
  contentCuratorMock=mock(ContentCurator.class);
  poolManagerMock=mock(CandlepinPoolManager.class);
  importer=new ProductImporter(productCuratorMock,contentCuratorMock,poolManagerMock);
}","@Before public void setUp() throws IOException {
  mapper=SyncUtils.getObjectMapper(new Config(new HashMap<String,String>()));
  productCuratorMock=mock(ProductCurator.class);
  contentCuratorMock=mock(ContentCurator.class);
  importer=new ProductImporter(productCuratorMock,contentCuratorMock);
}"
49508,"@Override protected boolean removeEldestEntry(Entry<String,ProductReference> eldest){
  return this.size() > max;
}","@Override protected boolean removeEldestEntry(Entry<String,ProductReference> eldest){
  return super.size() > max;
}"
49509,"/** 
 * Update entitlement only works for the quantity.
 * @httpcode 404
 * @httpcode 200
 */
@PUT @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public void updateEntitlement(@PathParam(""String_Node_Str"") @Verify(Entitlement.class) String id,Entitlement update){
  if (update.getQuantity() <= 0) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  Entitlement entitlement=entitlementCurator.find(id);
  if (entitlement != null) {
    if (entitlement.getQuantity() != update.getQuantity()) {
      Consumer consumer=entitlement.getConsumer();
      entitler.adjustEntitlementQuantity(consumer,entitlement,update.getQuantity());
    }
  }
 else {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",id));
  }
}","/** 
 * Update entitlement only works for the quantity.
 * @httpcode 404
 * @httpcode 200
 */
@PUT @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public void updateEntitlement(@PathParam(""String_Node_Str"") @Verify(Entitlement.class) String id,Entitlement update){
  if (update.getQuantity() <= 0) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  Entitlement entitlement=entitlementCurator.find(id);
  if (entitlement != null) {
    if (entitlement.getQuantity().equals(update.getQuantity())) {
      Consumer consumer=entitlement.getConsumer();
      entitler.adjustEntitlementQuantity(consumer,entitlement,update.getQuantity());
    }
  }
 else {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",id));
  }
}"
49510,"/** 
 * @param subsToImport Reconciles incoming entitlements to existing subscriptions. Each set is mapped against the upstream pool id. First match attempt will use entitlement id from incoming entitlements for comparison to existing subscriptions. Next attempt will use the exact quantity for comparison. This is to cover scenarios where the intent is to re-establish the distributor from the host. The final attempt will use ordering of the remaining incoming entitlements and of remaining existing subscriptions in descending order by quantity. Either the remaining subscriptions will be deleted, or the unmatched incoming entitlements will be turned into new subscriptions.
 */
public void store(Owner owner,Set<Subscription> subsToImport){
  Map<String,Map<String,Subscription>> existingSubsByUpstreamPool=mapSubsByUpstreamPool(owner);
  Set<Subscription> subscriptionsStillToImport=new HashSet<Subscription>();
  for (  Subscription subscription : subsToImport) {
    Subscription local=null;
    Map<String,Subscription> map=existingSubsByUpstreamPool.get(subscription.getUpstreamPoolId());
    if (map == null || map.isEmpty()) {
      createSubscription(subscription);
      log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str"");
      continue;
    }
    local=map.get(subscription.getUpstreamEntitlementId());
    if (local != null) {
      mergeSubscription(subscription,local,map);
      log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ local.getUpstreamEntitlementId()+ ""String_Node_Str"");
    }
 else {
      subscriptionsStillToImport.add(subscription);
      log.warn(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ ""String_Node_Str""+ subscription.getUpstreamPoolId()+ ""String_Node_Str"");
    }
  }
  List<Subscription> subscriptionsNeedQuantityMatch=new ArrayList<Subscription>();
  for (  Subscription subscription : subscriptionsStillToImport) {
    Subscription local=null;
    Map<String,Subscription> map=existingSubsByUpstreamPool.get(subscription.getUpstreamPoolId());
    if (map == null) {
      map=new HashMap<String,Subscription>();
    }
    for (    Subscription localSub : map.values()) {
      if (localSub.getQuantity() == subscription.getQuantity()) {
        local=localSub;
        break;
      }
    }
    if (local != null) {
      mergeSubscription(subscription,local,map);
      log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ local.getUpstreamEntitlementId()+ ""String_Node_Str"");
    }
 else {
      subscriptionsNeedQuantityMatch.add(subscription);
      log.warn(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ ""String_Node_Str""+ subscription.getUpstreamPoolId()+ ""String_Node_Str"");
    }
  }
  Subscription[] inNeed=subscriptionsNeedQuantityMatch.toArray(new Subscription[0]);
  Arrays.sort(inNeed,new QuantityComparator());
  for (  Subscription subscription : inNeed) {
    Subscription local=null;
    Map<String,Subscription> map=existingSubsByUpstreamPool.get(subscription.getUpstreamPoolId());
    if (map == null || map.isEmpty()) {
      createSubscription(subscription);
      log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str"");
      continue;
    }
    Subscription[] locals=map.values().toArray(new Subscription[0]);
    Arrays.sort(locals,new QuantityComparator());
    local=locals[0];
    mergeSubscription(subscription,local,map);
    log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ local.getUpstreamEntitlementId()+ ""String_Node_Str"");
  }
  deleteRemainingLocalSubscriptions(existingSubsByUpstreamPool);
}","/** 
 * @param subsToImport Reconciles incoming entitlements to existing subscriptions. Each set is mapped against the upstream pool id. First match attempt will use entitlement id from incoming entitlements for comparison to existing subscriptions. Next attempt will use the exact quantity for comparison. This is to cover scenarios where the intent is to re-establish the distributor from the host. The final attempt will use ordering of the remaining incoming entitlements and of remaining existing subscriptions in descending order by quantity. Either the remaining subscriptions will be deleted, or the unmatched incoming entitlements will be turned into new subscriptions.
 */
public void store(Owner owner,Set<Subscription> subsToImport){
  Map<String,Map<String,Subscription>> existingSubsByUpstreamPool=mapSubsByUpstreamPool(owner);
  Set<Subscription> subscriptionsStillToImport=new HashSet<Subscription>();
  for (  Subscription subscription : subsToImport) {
    Subscription local=null;
    Map<String,Subscription> map=existingSubsByUpstreamPool.get(subscription.getUpstreamPoolId());
    if (map == null || map.isEmpty()) {
      createSubscription(subscription);
      log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str"");
      continue;
    }
    local=map.get(subscription.getUpstreamEntitlementId());
    if (local != null) {
      mergeSubscription(subscription,local,map);
      log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ local.getUpstreamEntitlementId()+ ""String_Node_Str"");
    }
 else {
      subscriptionsStillToImport.add(subscription);
      log.warn(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ ""String_Node_Str""+ subscription.getUpstreamPoolId()+ ""String_Node_Str"");
    }
  }
  List<Subscription> subscriptionsNeedQuantityMatch=new ArrayList<Subscription>();
  for (  Subscription subscription : subscriptionsStillToImport) {
    Subscription local=null;
    Map<String,Subscription> map=existingSubsByUpstreamPool.get(subscription.getUpstreamPoolId());
    if (map == null) {
      map=new HashMap<String,Subscription>();
    }
    for (    Subscription localSub : map.values()) {
      if (localSub.getQuantity().equals(subscription.getQuantity())) {
        local=localSub;
        break;
      }
    }
    if (local != null) {
      mergeSubscription(subscription,local,map);
      log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ local.getUpstreamEntitlementId()+ ""String_Node_Str"");
    }
 else {
      subscriptionsNeedQuantityMatch.add(subscription);
      log.warn(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ ""String_Node_Str""+ subscription.getUpstreamPoolId()+ ""String_Node_Str"");
    }
  }
  Subscription[] inNeed=subscriptionsNeedQuantityMatch.toArray(new Subscription[0]);
  Arrays.sort(inNeed,new QuantityComparator());
  for (  Subscription subscription : inNeed) {
    Subscription local=null;
    Map<String,Subscription> map=existingSubsByUpstreamPool.get(subscription.getUpstreamPoolId());
    if (map == null || map.isEmpty()) {
      createSubscription(subscription);
      log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str"");
      continue;
    }
    Subscription[] locals=map.values().toArray(new Subscription[0]);
    Arrays.sort(locals,new QuantityComparator());
    local=locals[0];
    mergeSubscription(subscription,local,map);
    log.info(""String_Node_Str"" + subscription.getUpstreamEntitlementId() + ""String_Node_Str""+ local.getUpstreamEntitlementId()+ ""String_Node_Str"");
  }
  deleteRemainingLocalSubscriptions(existingSubsByUpstreamPool);
}"
49511,"protected final boolean hasProductChanged(Product existingProd,Product importedProd){
  if (!existingProd.getName().equals(importedProd.getName())) {
    return true;
  }
  if (existingProd.getMultiplier() != importedProd.getMultiplier()) {
    return true;
  }
  if (existingProd.getAttributes().size() != importedProd.getAttributes().size()) {
    return true;
  }
  if (Sets.intersection(existingProd.getAttributes(),importedProd.getAttributes()).size() != existingProd.getAttributes().size()) {
    return true;
  }
  if (existingProd.getProductContent().size() != importedProd.getProductContent().size()) {
    return true;
  }
  if (Sets.intersection(existingProd.getProductContent(),importedProd.getProductContent()).size() != existingProd.getProductContent().size()) {
    return true;
  }
  return false;
}","protected final boolean hasProductChanged(Product existingProd,Product importedProd){
  if (!existingProd.getName().equals(importedProd.getName())) {
    return true;
  }
  if (!existingProd.getMultiplier().equals(importedProd.getMultiplier())) {
    return true;
  }
  if (existingProd.getAttributes().size() != importedProd.getAttributes().size()) {
    return true;
  }
  if (Sets.intersection(existingProd.getAttributes(),importedProd.getAttributes()).size() != existingProd.getAttributes().size()) {
    return true;
  }
  if (existingProd.getProductContent().size() != importedProd.getProductContent().size()) {
    return true;
  }
  if (Sets.intersection(existingProd.getProductContent(),importedProd.getProductContent()).size() != existingProd.getProductContent().size()) {
    return true;
  }
  return false;
}"
49512,"/** 
 * @param nRulesSource the rulesSource to set
 */
public void setRulesSource(Rules.RulesSource rulesSource){
  this.rulesSource=Rules.rulesSourceToString(rulesSource);
}","/** 
 * @param rulesSource the rulesSource to set
 */
public void setRulesSource(Rules.RulesSource rulesSource){
  this.rulesSource=Rules.rulesSourceToString(rulesSource);
}"
49513,"/** 
 * Check compliance status for a consumer on a specific date.
 * @param c Consumer to check.
 * @param date Date to check compliance status for.
 * @return Compliance status.
 */
public ComplianceStatus getStatus(Consumer c,Date date){
  List<Entitlement> ents=entCurator.listByConsumer(c);
  JsonJsContext args=new JsonJsContext();
  args.put(""String_Node_Str"",c);
  args.put(""String_Node_Str"",ents);
  args.put(""String_Node_Str"",date);
  args.put(""String_Node_Str"",new ComplianceRulesHelper(entCurator),false);
  args.put(""String_Node_Str"",log,false);
  String json=runJsFunction(String.class,""String_Node_Str"",args);
  log.warn(json);
  try {
    ComplianceStatus status=mapper.readValue(json,ComplianceStatus.class);
    return status;
  }
 catch (  Exception e) {
    throw new RuleExecutionException(e);
  }
}","/** 
 * Check compliance status for a consumer on a specific date.
 * @param c Consumer to check.
 * @param date Date to check compliance status for.
 * @return Compliance status.
 */
public ComplianceStatus getStatus(Consumer c,Date date){
  List<Entitlement> ents=entCurator.listByConsumer(c);
  JsonJsContext args=new JsonJsContext();
  args.put(""String_Node_Str"",c);
  args.put(""String_Node_Str"",ents);
  args.put(""String_Node_Str"",date);
  args.put(""String_Node_Str"",new ComplianceRulesHelper(entCurator),false);
  args.put(""String_Node_Str"",log,false);
  String json=runJsFunction(String.class,""String_Node_Str"",args);
  log.debug(""String_Node_Str"" + json);
  try {
    ComplianceStatus status=mapper.readValue(json,ComplianceStatus.class);
    return status;
  }
 catch (  Exception e) {
    throw new RuleExecutionException(e);
  }
}"
49514,"/** 
 * Method to compile service/support level lists. One is the available levels for consumers for this owner. The second is the level names that are exempt. Exempt means that a product pool with this level can be used with a consumer of any service level.
 * @param owner The owner that has the list of available service levels forits consumers
 * @param exempt boolean to show if the desired list is the levels that areexplicitly marked with the support_level_exempt attribute.
 * @return Set of levels based on exempt flag.
 */
public Set<String> retrieveServiceLevelsForOwner(Owner owner,boolean exempt){
  String stmt=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Query q=currentSession().createQuery(stmt);
  q.setParameter(""String_Node_Str"",owner.getId());
  List<Object[]> results=q.list();
  Set<String> slaSet=new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
  Set<String> exemptSlaSet=new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
  Set<String> exemptProductIds=new HashSet<String>();
  for (  Object[] result : results) {
    String name=(String)result[0];
    String value=(String)result[1];
    String productId=(String)result[2];
    if (""String_Node_Str"".equals(name) && ""String_Node_Str"".equalsIgnoreCase(value)) {
      exemptProductIds.add(productId);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(name) && (value != null && !value.trim().equals(""String_Node_Str""))) {
      if (exemptProductIds.contains(productId)) {
        exemptSlaSet.add(value);
      }
    }
  }
  for (  Object[] result : results) {
    String name=(String)result[0];
    String value=(String)result[1];
    if (!""String_Node_Str"".equals(name)) {
      if (!exemptSlaSet.contains(value)) {
        slaSet.add(value);
      }
    }
  }
  if (exempt) {
    return exemptSlaSet;
  }
  return slaSet;
}","/** 
 * Method to compile service/support level lists. One is the available levels for consumers for this owner. The second is the level names that are exempt. Exempt means that a product pool with this level can be used with a consumer of any service level.
 * @param owner The owner that has the list of available service levels forits consumers
 * @param exempt boolean to show if the desired list is the levels that areexplicitly marked with the support_level_exempt attribute.
 * @return Set of levels based on exempt flag.
 */
public Set<String> retrieveServiceLevelsForOwner(Owner owner,boolean exempt){
  String stmt=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Query q=currentSession().createQuery(stmt);
  q.setParameter(""String_Node_Str"",owner.getId());
  List<Object[]> results=q.list();
  Set<String> slaSet=new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
  Set<String> exemptSlaSet=new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
  Set<String> exemptProductIds=new HashSet<String>();
  for (  Object[] result : results) {
    String name=(String)result[0];
    String value=(String)result[1];
    String productId=(String)result[2];
    if (""String_Node_Str"".equals(name) && ""String_Node_Str"".equalsIgnoreCase(value)) {
      exemptProductIds.add(productId);
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(name) && (value != null && !value.trim().equals(""String_Node_Str""))) {
      if (exemptProductIds.contains(productId)) {
        exemptSlaSet.add(value);
      }
    }
  }
  for (  Object[] result : results) {
    String name=(String)result[0];
    String value=(String)result[1];
    if (!""String_Node_Str"".equals(name)) {
      if (!exemptSlaSet.contains(value)) {
        slaSet.add(value);
      }
    }
  }
  if (exempt) {
    return exemptSlaSet;
  }
  return slaSet;
}"
49515,"@Override public Serializable getId(){
  return null;
}","@Override @XmlTransient public Serializable getId(){
  return null;
}"
49516,"void addDefaultEntitlementsConsumedByFamily(int physical,int virtual){
  for (  String key : entitlementsConsumedByFamily.keySet()) {
    ConsumptionTypeCounts count=entitlementsConsumedByFamily.get(key);
    physical-=count.physical;
    virtual-=count.guest;
  }
  if (physical > 0 || virtual > 0) {
    addToEntitlementsConsumedByFamily(""String_Node_Str"",physical,virtual);
  }
}","public void addDefaultEntitlementsConsumedByFamily(int physical,int virtual){
  for (  String key : entitlementsConsumedByFamily.keySet()) {
    ConsumptionTypeCounts count=entitlementsConsumedByFamily.get(key);
    physical-=count.physical;
    virtual-=count.guest;
  }
  if (physical > 0 || virtual > 0) {
    addToEntitlementsConsumedByFamily(""String_Node_Str"",physical,virtual);
  }
}"
49517,"/** 
 * @return a Pool
 * @httpcode 400
 * @httpcode 200
 */
@POST @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Pool addPoolToKey(@PathParam(""String_Node_Str"") @Verify(ActivationKey.class) String activationKeyId,@PathParam(""String_Node_Str"") @Verify(value=Pool.class,require=Access.READ_POOLS) String poolId,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") long quantity){
  if (quantity < 1) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  ActivationKey key=findKey(activationKeyId);
  Pool pool=findPool(poolId);
  if (pool.getAttributeValue(""String_Node_Str"") != null && pool.getAttributeValue(""String_Node_Str"").equals(""String_Node_Str"") || pool.getProductAttribute(""String_Node_Str"") != null && pool.getProductAttribute(""String_Node_Str"").getValue().equals(""String_Node_Str"")) {
    throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""));
  }
  if (quantity > 1) {
    ProductPoolAttribute ppa=pool.getProductAttribute(""String_Node_Str"");
    if (ppa == null || !ppa.getValue().equalsIgnoreCase(""String_Node_Str"")) {
      throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
    }
  }
  if ((!pool.isUnlimited()) && (quantity > pool.getQuantity())) {
    throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  key.addPool(pool,quantity);
  activationKeyCurator.update(key);
  return pool;
}","/** 
 * @return a Pool
 * @httpcode 400
 * @httpcode 200
 */
@POST @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Pool addPoolToKey(@PathParam(""String_Node_Str"") @Verify(ActivationKey.class) String activationKeyId,@PathParam(""String_Node_Str"") @Verify(value=Pool.class,require=Access.READ_POOLS) String poolId,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") long quantity){
  if (quantity < 1) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  ActivationKey key=findKey(activationKeyId);
  Pool pool=findPool(poolId);
  if (pool.getAttributeValue(""String_Node_Str"") != null && pool.getAttributeValue(""String_Node_Str"").equals(""String_Node_Str"") || pool.getProductAttribute(""String_Node_Str"") != null && pool.getProductAttribute(""String_Node_Str"").getValue().equals(""String_Node_Str"")) {
    throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  if (quantity > 1) {
    ProductPoolAttribute ppa=pool.getProductAttribute(""String_Node_Str"");
    if (ppa == null || !ppa.getValue().equalsIgnoreCase(""String_Node_Str"")) {
      throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
    }
  }
  if ((!pool.isUnlimited()) && (quantity > pool.getQuantity())) {
    throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
  }
  key.addPool(pool,quantity);
  activationKeyCurator.update(key);
  return pool;
}"
49518,"public void store(Owner owner,ConsumerDto consumer) throws SyncDataFormatException {
  if (consumer.getUuid() == null) {
    throw new SyncDataFormatException(i18n.tr(""String_Node_Str""));
  }
  Owner alreadyUsing=curator.lookupWithUpstreamUuid(consumer.getUuid());
  if (alreadyUsing != null && alreadyUsing.getKey() != owner.getKey()) {
    throw new SyncDataFormatException(i18n.tr(""String_Node_Str""));
  }
  if (owner.getUpstreamUuid() != null && !owner.getUpstreamUuid().equals(consumer.getUuid())) {
    throw new SyncDataFormatException(i18n.tr(""String_Node_Str""));
  }
  owner.setUpstreamUuid(consumer.getUuid());
  curator.merge(owner);
}","public void store(Owner owner,ConsumerDto consumer) throws SyncDataFormatException {
  if (consumer.getUuid() == null) {
    throw new SyncDataFormatException(i18n.tr(""String_Node_Str""));
  }
  Owner alreadyUsing=curator.lookupWithUpstreamUuid(consumer.getUuid());
  if (alreadyUsing != null && !alreadyUsing.getKey().equals(owner.getKey())) {
    log.error(""String_Node_Str"" + owner.getKey());
    log.error(""String_Node_Str"" + consumer.getUuid() + ""String_Node_Str""+ alreadyUsing.getKey());
    throw new SyncDataFormatException(i18n.tr(""String_Node_Str""));
  }
  if (owner.getUpstreamUuid() != null && !owner.getUpstreamUuid().equals(consumer.getUuid())) {
    throw new SyncDataFormatException(i18n.tr(""String_Node_Str""));
  }
  owner.setUpstreamUuid(consumer.getUuid());
  curator.merge(owner);
}"
49519,"@Transactional public void createOrUpdate(Content c){
  Content existing=findByLabel(c.getLabel());
  if (existing == null) {
    create(c);
    return;
  }
 else {
    merge(c);
  }
}","@Transactional public void createOrUpdate(Content c){
  Content existing=find(c.getId());
  if (existing == null) {
    create(c);
    return;
  }
 else {
    merge(c);
  }
}"
49520,"@Transactional public Pool replicate(Pool pool){
  for (  ProvidedProduct pp : pool.getProvidedProducts()) {
    pp.setPool(pool);
  }
  for (  PoolAttribute pa : pool.getAttributes()) {
    pa.setPool(pool);
  }
  pool.setSourceEntitlement(null);
  this.currentSession().replicate(pool,ReplicationMode.EXCEPTION);
  return pool;
}","@Transactional public Pool replicate(Pool pool){
  for (  ProvidedProduct pp : pool.getProvidedProducts()) {
    pp.setPool(pool);
  }
  for (  PoolAttribute pa : pool.getAttributes()) {
    pa.setPool(pool);
  }
  for (  ProductPoolAttribute ppa : pool.getProductAttributes()) {
    ppa.setPool(pool);
  }
  pool.setSourceEntitlement(null);
  this.currentSession().replicate(pool,ReplicationMode.EXCEPTION);
  return pool;
}"
49521,"/** 
 * Connects to another Candlepin instance located at the given uri.
 * @param clazz the client class to create.
 * @param creds authentication credentials for the given uri.
 * @param uri the Candlepin instance to connect to
 * @return Client proxy used to interact with Candlepin via REST API.
 */
public <T>T connect(Class<T> clazz,Credentials creds,String uri){
  HttpClient httpclient=new HttpClient();
  httpclient.getState().setCredentials(AuthScope.ANY,creds);
  ClientExecutor clientExecutor=new ApacheHttpClientExecutor(httpclient);
  return ProxyFactory.create(clazz,uri,clientExecutor);
}","/** 
 * Connects to another Candlepin instance located at the given uri.
 * @param clazz the client class to create.
 * @param creds authentication credentials for the given uri.
 * @param uri the Candlepin instance to connect to
 * @return Client proxy used to interact with Candlepin via REST API.
 */
public <T>T connect(Class<T> clazz,Credentials creds,String uri){
  HttpClient httpclient=new HttpClient();
  httpclient.getParams().setAuthenticationPreemptive(true);
  httpclient.getState().setCredentials(AuthScope.ANY,creds);
  ClientExecutor clientExecutor=new ApacheHttpClientExecutor(httpclient);
  return ProxyFactory.create(clazz,uri,clientExecutor);
}"
49522,"/** 
 * Lookup consumer by its name
 * @param name consumer name to find
 * @return Consumer whose name matches the given name, null otherwise.
 */
@Transactional @EnforceAccessControl public Consumer findByName(String name){
  return (Consumer)currentSession().createCriteria(Consumer.class).add(Restrictions.eq(""String_Node_Str"",name)).uniqueResult();
}","/** 
 * Lookup consumer by its name
 * @param name consumer name to find
 * @return Consumer whose name matches the given name, null otherwise.
 */
@Transactional @EnforceAccessControl public Consumer findByName(Owner o,String name){
  return (Consumer)currentSession().createCriteria(Consumer.class).add(Restrictions.eq(""String_Node_Str"",name)).add(Restrictions.eq(""String_Node_Str"",o)).uniqueResult();
}"
49523,"/** 
 * @return an EntitlementCertificate
 * @httpcode 404
 * @httpcode 200
 */
@GET @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public EntitlementCertificate getUeberCertificate(@Context Principal principal,@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey){
  Owner o=findOwner(ownerKey);
  if (o == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",ownerKey));
  }
  Consumer ueberConsumer=consumerCurator.findByName(UEBER_CERT_CONSUMER);
  if (ueberConsumer == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",o.getKey()));
  }
  List<EntitlementCertificate> ueberCertificate=entitlementCertCurator.listForConsumer(ueberConsumer);
  return ueberCertificate.get(0);
}","/** 
 * @return an EntitlementCertificate
 * @httpcode 404
 * @httpcode 200
 */
@GET @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public EntitlementCertificate getUeberCertificate(@Context Principal principal,@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey){
  Owner o=findOwner(ownerKey);
  if (o == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",ownerKey));
  }
  Consumer ueberConsumer=consumerCurator.findByName(o,UEBER_CERT_CONSUMER);
  if (ueberConsumer == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",o.getKey()));
  }
  List<EntitlementCertificate> ueberCertificate=entitlementCertCurator.listForConsumer(ueberConsumer);
  return ueberCertificate.get(0);
}"
49524,"/** 
 * @return an EntitlementCertificate
 * @httpcode 400
 * @httpcode 404
 * @httpcode 200
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public EntitlementCertificate createUeberCertificate(@Context Principal principal,@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey){
  Owner o=findOwner(ownerKey);
  if (o == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",ownerKey));
  }
  Consumer ueberConsumer=consumerCurator.findByName(UEBER_CERT_CONSUMER);
  if (ueberConsumer != null) {
    List<Entitlement> ueberEntitlement=entitlementCurator.listByConsumer(ueberConsumer);
    poolManager.regenerateCertificatesOf(ueberEntitlement.get(0),true);
    return entitlementCertCurator.listForConsumer(ueberConsumer).get(0);
  }
  try {
    Product ueberProduct=createUeberProduct(o);
    createUeberSubscription(o,ueberProduct);
    poolManager.refreshPools(o);
    Consumer consumer=createUeberConsumer(principal,o);
    List<Pool> ueberPool=poolCurator.listAvailableEntitlementPools(null,o,ueberProduct.getId(),null,false,false);
    return generateUeberCertificate(consumer,ueberPool);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + o.getKey(),e);
    throw new BadRequestException(i18n.tr(""String_Node_Str"",e));
  }
}","/** 
 * @return an EntitlementCertificate
 * @httpcode 400
 * @httpcode 404
 * @httpcode 200
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public EntitlementCertificate createUeberCertificate(@Context Principal principal,@Verify(Owner.class) @PathParam(""String_Node_Str"") String ownerKey){
  Owner o=findOwner(ownerKey);
  if (o == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",ownerKey));
  }
  Consumer ueberConsumer=consumerCurator.findByName(o,UEBER_CERT_CONSUMER);
  if (ueberConsumer != null) {
    List<Entitlement> ueberEntitlement=entitlementCurator.listByConsumer(ueberConsumer);
    poolManager.regenerateCertificatesOf(ueberEntitlement.get(0),true);
    return entitlementCertCurator.listForConsumer(ueberConsumer).get(0);
  }
  try {
    Product ueberProduct=createUeberProduct(o);
    createUeberSubscription(o,ueberProduct);
    poolManager.refreshPools(o);
    Consumer consumer=createUeberConsumer(principal,o);
    List<Pool> ueberPool=poolCurator.listAvailableEntitlementPools(null,o,ueberProduct.getId(),null,false,false);
    return generateUeberCertificate(consumer,ueberPool);
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + o.getKey(),e);
    throw new BadRequestException(i18n.tr(""String_Node_Str"",e));
  }
}"
49525,"@Test public void testUeberConsumerIsCreated() throws Exception {
  or.createUeberCertificate(principal,owner.getKey());
  assertNotNull(consumerCurator.findByName(""String_Node_Str""));
}","@Test public void testUeberConsumerIsCreated() throws Exception {
  or.createUeberCertificate(principal,owner.getKey());
  assertNotNull(consumerCurator.findByName(owner,""String_Node_Str""));
}"
49526,"@Test public void testUeberEntitlementIsGenerated() throws Exception {
  or.createUeberCertificate(principal,owner.getKey());
  Consumer c=consumerCurator.findByName(""String_Node_Str"");
  assertTrue(poolCurator.listByConsumer(c).size() == 1);
}","@Test public void testUeberEntitlementIsGenerated() throws Exception {
  or.createUeberCertificate(principal,owner.getKey());
  Consumer c=consumerCurator.findByName(owner,""String_Node_Str"");
  assertTrue(poolCurator.listByConsumer(c).size() == 1);
}"
49527,"@Test(expected=NotFoundException.class) public void certificateRetrievalRaisesExceptionIfNoCertificateWasGenerated() throws Exception {
  Owner anotherOwner=ownerCurator.create(new Owner(OWNER_NAME + ""String_Node_Str""));
  or.getUeberCertificate(principal,anotherOwner.getKey());
}","@Test(expected=NotFoundException.class) public void certificateRetrievalRaisesExceptionIfNoCertificateWasGenerated() throws Exception {
  or.createUeberCertificate(principal,owner.getKey());
  Owner anotherOwner=ownerCurator.create(new Owner(OWNER_NAME + ""String_Node_Str""));
  or.getUeberCertificate(principal,anotherOwner.getKey());
}"
49528,"/** 
 * Create a pool for a product and limit it to consumers a particular user has registered.
 * @param productId Label of the product the pool is for.
 * @param quantity Number of entitlements for this pool, also accepts ""unlimited"".
 */
public void createParentConsumerRestrictedPool(String productId,Pool pool,String quantity,Map<String,String> newPoolAttributes){
  Pool consumerSpecificPool=createPool(productId,pool.getOwner(),quantity,pool.getStartDate(),pool.getEndDate(),pool.getContractNumber(),pool.getAccountNumber(),pool.getProvidedProducts());
  consumerSpecificPool.setRestrictedToParentConsumer(this.sourceEntitlement.getConsumer().getUuid());
  consumerSpecificPool.setSubscriptionId(pool.getSubscriptionId());
  for (  String key : newPoolAttributes.keySet()) {
    PoolAttribute pa=new PoolAttribute(key,newPoolAttributes.get(key));
    consumerSpecificPool.addAttribute(pa);
  }
  poolManager.createPool(consumerSpecificPool);
}","/** 
 * Create a pool for a product and limit it to consumers a particular user has registered.
 * @param productId Label of the product the pool is for.
 * @param quantity Number of entitlements for this pool, also accepts ""unlimited"".
 */
public void createParentConsumerRestrictedPool(String productId,Pool pool,String quantity,Map<String,String> newPoolAttributes){
  Pool consumerSpecificPool=createPool(productId,pool.getOwner(),quantity,pool.getStartDate(),pool.getEndDate(),pool.getContractNumber(),pool.getAccountNumber(),pool.getProvidedProducts());
  consumerSpecificPool.setRestrictedToParentConsumer(this.sourceEntitlement.getConsumer().getUuid());
  consumerSpecificPool.setAttribute(""String_Node_Str"",""String_Node_Str"");
  consumerSpecificPool.setSubscriptionId(pool.getSubscriptionId());
  for (  String key : newPoolAttributes.keySet()) {
    PoolAttribute pa=new PoolAttribute(key,newPoolAttributes.get(key));
    consumerSpecificPool.addAttribute(pa);
  }
  poolManager.createPool(consumerSpecificPool);
}"
49529,"/** 
 * Create a Consumer. NOTE: Opening this method up to everyone, as we have nothing we can reliably verify in the method signature. Instead we have to figure out what owner this consumer is destined for (due to backward compatability with existing clients which do not specify an owner during registration), and then check the access to the specified owner in the method itself.
 * @param consumer Consumer metadata
 * @return newly created Consumer
 * @throws BadRequestException generic exception type for web services Weare calling this ""registerConsumer"" in the api discussions
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @SecurityHole(noAuth=true) public Consumer create(Consumer consumer,@Context Principal principal,@QueryParam(""String_Node_Str"") String userName,@QueryParam(""String_Node_Str"") String ownerKey,@QueryParam(""String_Node_Str"") String activationKeys) throws BadRequestException {
  Set<String> keyStrings=splitKeys(activationKeys);
  if ((principal instanceof NoAuthPrincipal) && (keyStrings.size() == 0)) {
    throw new ForbiddenException(i18n.tr(""String_Node_Str""));
  }
  if (keyStrings.size() > 0) {
    if (ownerKey == null) {
      throw new BadRequestException(i18n.tr(""String_Node_Str""));
    }
    if (userName != null) {
      throw new BadRequestException(i18n.tr(""String_Node_Str""));
    }
  }
  if (!isConsumerNameValid(consumer.getName())) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  if (consumer.getName().indexOf('#') == 0) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  if (userName == null) {
    userName=principal.getUsername();
  }
  Owner owner=setupOwner(principal,ownerKey);
  List<ActivationKey> keys=new ArrayList<ActivationKey>();
  if (keyStrings.size() > 0) {
    for (    String keyString : keyStrings) {
      ActivationKey key=findKey(keyString,owner);
      keys.add(key);
    }
  }
  ConsumerType type=lookupConsumerType(consumer.getType().getLabel());
  if (type.isType(ConsumerTypeEnum.PERSON)) {
    if (keys.size() > 0) {
      throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
    }
    verifyPersonConsumer(consumer,type,owner,userName);
  }
  if (userName != null) {
    consumer.setUsername(userName);
  }
  consumer.setOwner(owner);
  consumer.setType(type);
  consumer.setCanActivate(subAdapter.canActivateSubscription(consumer));
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + type.getLabel());
    log.debug(""String_Node_Str"");
    log.debug(consumer.getFacts());
    for (    String key : consumer.getFacts().keySet()) {
      log.debug(""String_Node_Str"" + key + ""String_Node_Str""+ consumer.getFact(key));
    }
    log.debug(""String_Node_Str"");
    for (    ActivationKey activationKey : keys) {
      log.debug(""String_Node_Str"" + activationKey.getName());
    }
  }
  for (  ConsumerInstalledProduct p : consumer.getInstalledProducts()) {
    p.setConsumer(consumer);
  }
  try {
    consumer=consumerCurator.create(consumer);
    IdentityCertificate idCert=generateIdCert(consumer,false);
    consumer.setIdCert(idCert);
    sink.emitConsumerCreated(consumer);
    for (    ActivationKey ak : keys) {
      for (      ActivationKeyPool akp : ak.getPools()) {
        List<Entitlement> entitlements=null;
        String poolId=Util.assertNotNull(akp.getPool().getId(),i18n.tr(""String_Node_Str""));
        entitlements=entitler.bindByPool(poolId,consumer,akp.getQuantity().intValue());
        entitler.sendEvents(entitlements);
      }
    }
    return consumer;
  }
 catch (  CandlepinException ce) {
    throw ce;
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    e.printStackTrace();
    throw new BadRequestException(i18n.tr(""String_Node_Str"",consumer));
  }
}","/** 
 * Create a Consumer. NOTE: Opening this method up to everyone, as we have nothing we can reliably verify in the method signature. Instead we have to figure out what owner this consumer is destined for (due to backward compatability with existing clients which do not specify an owner during registration), and then check the access to the specified owner in the method itself.
 * @param consumer Consumer metadata
 * @return newly created Consumer
 * @throws BadRequestException generic exception type for web services Weare calling this ""registerConsumer"" in the api discussions
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @SecurityHole(noAuth=true) public Consumer create(Consumer consumer,@Context Principal principal,@QueryParam(""String_Node_Str"") String userName,@QueryParam(""String_Node_Str"") String ownerKey,@QueryParam(""String_Node_Str"") String activationKeys) throws BadRequestException {
  Set<String> keyStrings=splitKeys(activationKeys);
  if ((principal instanceof NoAuthPrincipal) && (keyStrings.size() == 0)) {
    throw new ForbiddenException(i18n.tr(""String_Node_Str""));
  }
  if (keyStrings.size() > 0) {
    if (ownerKey == null) {
      throw new BadRequestException(i18n.tr(""String_Node_Str""));
    }
    if (userName != null) {
      throw new BadRequestException(i18n.tr(""String_Node_Str""));
    }
  }
  if (!isConsumerNameValid(consumer.getName())) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  if (consumer.getName().indexOf('#') == 0) {
    throw new BadRequestException(i18n.tr(""String_Node_Str""));
  }
  if (userName == null) {
    userName=principal.getUsername();
  }
  Owner owner=setupOwner(principal,ownerKey);
  List<ActivationKey> keys=new ArrayList<ActivationKey>();
  if (keyStrings.size() > 0) {
    for (    String keyString : keyStrings) {
      ActivationKey key=findKey(keyString,owner);
      keys.add(key);
    }
  }
  ConsumerType type=lookupConsumerType(consumer.getType().getLabel());
  if (type.isType(ConsumerTypeEnum.PERSON)) {
    if (keys.size() > 0) {
      throw new BadRequestException(i18n.tr(""String_Node_Str"" + ""String_Node_Str""));
    }
    verifyPersonConsumer(consumer,type,owner,userName);
  }
  if (userName != null) {
    consumer.setUsername(userName);
  }
  consumer.setOwner(owner);
  consumer.setType(type);
  consumer.setCanActivate(subAdapter.canActivateSubscription(consumer));
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + type.getLabel());
    log.debug(""String_Node_Str"");
    log.debug(consumer.getFacts());
    if (consumer.getFacts() != null) {
      for (      String key : consumer.getFacts().keySet()) {
        log.debug(""String_Node_Str"" + key + ""String_Node_Str""+ consumer.getFact(key));
      }
    }
    log.debug(""String_Node_Str"");
    for (    ActivationKey activationKey : keys) {
      log.debug(""String_Node_Str"" + activationKey.getName());
    }
  }
  if (consumer.getInstalledProducts() != null) {
    for (    ConsumerInstalledProduct p : consumer.getInstalledProducts()) {
      p.setConsumer(consumer);
    }
  }
  try {
    consumer=consumerCurator.create(consumer);
    IdentityCertificate idCert=generateIdCert(consumer,false);
    consumer.setIdCert(idCert);
    sink.emitConsumerCreated(consumer);
    for (    ActivationKey ak : keys) {
      for (      ActivationKeyPool akp : ak.getPools()) {
        List<Entitlement> entitlements=null;
        String poolId=Util.assertNotNull(akp.getPool().getId(),i18n.tr(""String_Node_Str""));
        entitlements=entitler.bindByPool(poolId,consumer,akp.getQuantity().intValue());
        entitler.sendEvents(entitlements);
      }
    }
    return consumer;
  }
 catch (  CandlepinException ce) {
    throw ce;
  }
catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    e.printStackTrace();
    throw new BadRequestException(i18n.tr(""String_Node_Str"",consumer));
  }
}"
49530,"@GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public List<Role> getUserRoles(@PathParam(""String_Node_Str"") @Verify(User.class) String username){
  List<Role> roles=userService.getRoles(username);
  User myUser=userService.findByLogin(username);
  Set<User> s=new HashSet<User>();
  s.add(myUser);
  for (  Role r : roles) {
    r.setUsers(s);
  }
  return roles;
}","@GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public List<Role> getUserRoles(@PathParam(""String_Node_Str"") @Verify(User.class) String username){
  User myUser=userService.findByLogin(username);
  List<Role> roles=new LinkedList<Role>(myUser.getRoles());
  Set<User> s=new HashSet<User>();
  s.add(myUser);
  for (  Role r : roles) {
    r.setUsers(s);
  }
  return roles;
}"
49531,"/** 
 * Return the entitlement pools for the owner of the given id.
 * @param ownerKey id of the owner whose entitlement pools are sought.
 * @return the entitlement pools for the owner of the given id.
 */
@GET @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public List<Pool> getPools(@PathParam(""String_Node_Str"") @Verify(value=Owner.class,require=Access.READ_POOLS) String ownerKey,@QueryParam(""String_Node_Str"") String consumerUuid,@QueryParam(""String_Node_Str"") String productId,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") boolean listAll,@QueryParam(""String_Node_Str"") String activeOn){
  Owner owner=findOwner(ownerKey);
  Date activeOnDate=new Date();
  if (activeOn != null) {
    activeOnDate=parseDateString(activeOn);
  }
  Consumer c=null;
  if (consumerUuid != null) {
    c=consumerCurator.findByUuid(consumerUuid);
    if (c == null) {
      throw new NotFoundException(i18n.tr(""String_Node_Str"",consumerUuid));
    }
    if (c.getOwner().getId().equals(owner.getId())) {
      throw new BadRequestException(""String_Node_Str"");
    }
  }
  return poolCurator.listAvailableEntitlementPools(c,owner,productId,activeOnDate,true,listAll);
}","/** 
 * Return the entitlement pools for the owner of the given id.
 * @param ownerKey id of the owner whose entitlement pools are sought.
 * @return the entitlement pools for the owner of the given id.
 */
@GET @Produces(MediaType.APPLICATION_JSON) @Path(""String_Node_Str"") public List<Pool> getPools(@PathParam(""String_Node_Str"") @Verify(value=Owner.class,require=Access.READ_POOLS) String ownerKey,@QueryParam(""String_Node_Str"") String consumerUuid,@QueryParam(""String_Node_Str"") String productId,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") boolean listAll,@QueryParam(""String_Node_Str"") String activeOn){
  Owner owner=findOwner(ownerKey);
  Date activeOnDate=new Date();
  if (activeOn != null) {
    activeOnDate=parseDateString(activeOn);
  }
  Consumer c=null;
  if (consumerUuid != null) {
    c=consumerCurator.findByUuid(consumerUuid);
    if (c == null) {
      throw new NotFoundException(i18n.tr(""String_Node_Str"",consumerUuid));
    }
    if (!c.getOwner().getId().equals(owner.getId())) {
      throw new BadRequestException(""String_Node_Str"");
    }
  }
  return poolCurator.listAvailableEntitlementPools(c,owner,productId,activeOnDate,true,listAll);
}"
49532,"@Override public Object lookup(String key){
  return poolCurator.find(key);
}","@Override public Object lookup(String key){
  if (poolCurator == null) {
    poolCurator=injector.getInstance(PoolCurator.class);
  }
  return poolCurator.find(key);
}"
49533,"@Override public boolean canAccessTarget(Entitlement target,Access action){
  return target.getOwner().getKey().equals(consumer.getOwner().getKey());
}","@Override public boolean canAccessTarget(Entitlement target,Access action){
  return target.getConsumer().getUuid().equals(consumer.getUuid());
}"
49534,"@Test public void testGetUsers(){
  String ownerName=owner.getKey();
  User user=new User();
  user.setUsername(""String_Node_Str"");
  user.setPassword(""String_Node_Str"");
  userCurator.create(user);
  Role role=new Role();
  role.addUser(user);
  role.addPermission(new Permission(owner,Verb.OWNER_ADMIN));
  user.addRole(role);
  roleCurator.create(role);
  User user2=new User();
  user2.setUsername(""String_Node_Str"");
  user2.setPassword(""String_Node_Str"");
  user2.addRole(role);
  userCurator.create(user2);
  roleCurator.merge(role);
  List<User> users=ownerResource.getUsers(ownerName);
  assertEquals(users.size(),2);
  assertEquals(users.get(1),user2);
}","@Test public void testGetUsers(){
  String ownerName=owner.getKey();
  User user=new User();
  user.setUsername(""String_Node_Str"");
  user.setPassword(""String_Node_Str"");
  userCurator.create(user);
  Role role=new Role();
  role.addUser(user);
  role.addPermission(new Permission(owner,Verb.OWNER_ADMIN));
  user.addRole(role);
  roleCurator.create(role);
  User user2=new User();
  user2.setUsername(""String_Node_Str"");
  user2.setPassword(""String_Node_Str"");
  user2.addRole(role);
  userCurator.create(user2);
  roleCurator.merge(role);
  List<User> users=ownerResource.getUsers(ownerName);
  assertEquals(users.size(),2);
  assertTrue(users.contains(user2));
}"
49535,"/** 
 * {@inheritDoc}
 */
@Override public Object invoke(MethodInvocation invocation) throws Throwable {
  Principal currentUser=this.principalProvider.get();
  log.debug(""String_Node_Str"");
  EnumSet<Verb> allowedRoles=EnumSet.noneOf(Verb.class);
  allowedRoles.add(Verb.SUPER_ADMIN);
  log.debug(invocation.getClass().getName());
  log.debug(invocation.getClass().getAnnotations().length);
  AllowRoles annotation=invocation.getMethod().getAnnotation(AllowRoles.class);
  log.debug(""String_Node_Str"" + annotation);
  if (annotation != null) {
    for (    Verb allowed : annotation.roles()) {
      log.debug(""String_Node_Str"" + allowed);
      allowedRoles.add(allowed);
    }
  }
  boolean foundRole=false;
  for (  Verb allowed : allowedRoles) {
    if (hasRole(currentUser,allowed)) {
      foundRole=true;
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + currentUser + ""String_Node_Str""+ allowed);
      }
      break;
    }
  }
  if (!foundRole) {
    log.warn(""String_Node_Str"" + currentUser + ""String_Node_Str""+ invocation.getMethod().getName());
    I18n i18n=this.i18nProvider.get();
    String error=""String_Node_Str"";
    throw new ForbiddenException(i18n.tr(error));
  }
  return invocation.proceed();
}","/** 
 * {@inheritDoc}
 */
@Override public Object invoke(MethodInvocation invocation) throws Throwable {
  Principal currentUser=this.principalProvider.get();
  log.debug(""String_Node_Str"");
  EnumSet<Verb> allowedRoles=EnumSet.of(Verb.SUPER_ADMIN);
  AllowRoles annotation=invocation.getMethod().getAnnotation(AllowRoles.class);
  log.debug(""String_Node_Str"" + annotation);
  if (annotation != null) {
    for (    Verb allowed : annotation.roles()) {
      log.debug(""String_Node_Str"" + allowed);
      allowedRoles.add(allowed);
    }
  }
  boolean foundRole=false;
  for (  Verb allowed : allowedRoles) {
    if (hasRole(currentUser,allowed)) {
      foundRole=true;
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + currentUser + ""String_Node_Str""+ allowed);
      }
      break;
    }
  }
  if (!foundRole) {
    log.warn(""String_Node_Str"" + currentUser + ""String_Node_Str""+ invocation.getMethod().getName());
    I18n i18n=this.i18nProvider.get();
    String error=""String_Node_Str"";
    throw new ForbiddenException(i18n.tr(error));
  }
  return invocation.proceed();
}"
49536,"public static Principal createPrincipal(String username,Owner owner,Verb role){
  List<Verb> roles=new LinkedList<Verb>();
  roles.add(role);
  Principal ownerAdmin=new UserPrincipal(username,Arrays.asList(new Permission[]{new Permission(owner,Verb.OWNER_ADMIN)}));
  return ownerAdmin;
}","public static Principal createPrincipal(String username,Owner owner,Verb role){
  return new UserPrincipal(username,Arrays.asList(new Permission[]{new Permission(owner,role)}));
}"
49537,"private Consumer createConsumer(String consumerName){
  Consumer consumer=new Consumer(consumerName,null,null,system);
  Principal principal=new UserPrincipal(USER,null,null);
  return this.resource.create(consumer,principal,USER,null);
}","private Consumer createConsumer(String consumerName){
  Consumer consumer=new Consumer(consumerName,null,null,system);
  Principal principal=new UserPrincipal(USER,null);
  return this.resource.create(consumer,principal,USER,null);
}"
49538,"/** 
 * Valid credentials are given - checks if the correct principal is created.
 * @throws Exception
 */
@Test public void correctPrincipal() throws Exception {
  Owner owner=new Owner(""String_Node_Str"",""String_Node_Str"");
  List<Owner> owners=Arrays.asList(new Owner[]{owner});
  setUserAndPassword(""String_Node_Str"",""String_Node_Str"");
  when(userService.validateUser(""String_Node_Str"",""String_Node_Str"")).thenReturn(true);
  when(userService.getOwners(""String_Node_Str"")).thenReturn(owners);
  when(ownerCurator.lookupByKey(""String_Node_Str"")).thenReturn(owner);
  UserPrincipal expected=new UserPrincipal(""String_Node_Str"",owners,null);
  assertEquals(expected,this.auth.getPrincipal(request));
}","/** 
 * Valid credentials are given - checks if the correct principal is created.
 * @throws Exception
 */
@Test public void correctPrincipal() throws Exception {
  Owner owner=new Owner(""String_Node_Str"",""String_Node_Str"");
  setUserAndPassword(""String_Node_Str"",""String_Node_Str"");
  when(userService.validateUser(""String_Node_Str"",""String_Node_Str"")).thenReturn(true);
  when(ownerCurator.lookupByKey(""String_Node_Str"")).thenReturn(owner);
  List<Permission> permissions=Arrays.asList(new Permission[]{new Permission(owner,EnumSet.of(Role.OWNER_ADMIN))});
  UserPrincipal expected=new UserPrincipal(""String_Node_Str"",permissions);
  assertEquals(expected,this.auth.getPrincipal(request));
}"
49539,"@Test public void existingJobMapPrincipal(){
  List<Owner> owners=new ArrayList<Owner>();
  owners.add(new Owner(""String_Node_Str""));
  Principal principal=new UserPrincipal(""String_Node_Str"",owners,null);
  when(this.principalProvider.get()).thenReturn(principal);
  JobDetail detail=new JobDetail();
  JobDataMap map=new JobDataMap();
  map.put(""String_Node_Str"",""String_Node_Str"");
  detail.setJobDataMap(map);
  when(response.getEntity()).thenReturn(detail);
  this.interceptor.postProcess(response);
  Assert.assertSame(principal,detail.getJobDataMap().get(PinsetterJobListener.PRINCIPAL_KEY));
}","@Test public void existingJobMapPrincipal(){
  List<Permission> permissions=Arrays.asList(new Permission[]{new Permission(new Owner(""String_Node_Str""),EnumSet.of(Role.OWNER_ADMIN))});
  Principal principal=new UserPrincipal(""String_Node_Str"",permissions);
  when(this.principalProvider.get()).thenReturn(principal);
  JobDetail detail=new JobDetail();
  JobDataMap map=new JobDataMap();
  map.put(""String_Node_Str"",""String_Node_Str"");
  detail.setJobDataMap(map);
  when(response.getEntity()).thenReturn(detail);
  this.interceptor.postProcess(response);
  Assert.assertSame(principal,detail.getJobDataMap().get(PinsetterJobListener.PRINCIPAL_KEY));
}"
49540,"@Test public void noJobMapPrincipal(){
  List<Owner> owners=new ArrayList<Owner>();
  owners.add(new Owner(""String_Node_Str""));
  Principal principal=new UserPrincipal(""String_Node_Str"",owners,null);
  when(this.principalProvider.get()).thenReturn(principal);
  JobDetail detail=new JobDetail();
  when(response.getEntity()).thenReturn(detail);
  this.interceptor.postProcess(response);
  Assert.assertEquals(principal,detail.getJobDataMap().get(PinsetterJobListener.PRINCIPAL_KEY));
}","@Test public void noJobMapPrincipal(){
  List<Permission> permissions=Arrays.asList(new Permission[]{new Permission(new Owner(""String_Node_Str""),EnumSet.of(Role.OWNER_ADMIN))});
  Principal principal=new UserPrincipal(""String_Node_Str"",permissions);
  when(this.principalProvider.get()).thenReturn(principal);
  JobDetail detail=new JobDetail();
  when(response.getEntity()).thenReturn(detail);
  this.interceptor.postProcess(response);
  Assert.assertEquals(principal,detail.getJobDataMap().get(PinsetterJobListener.PRINCIPAL_KEY));
}"
49541,"/** 
 * @param clientKeyPair
 * @param extensions
 * @return
 * @throws IOException
 * @throws CertificateParsingException
 */
DEREncodable getSubjectKeyIdentifier(KeyPair clientKeyPair,Set<X509ExtensionWrapper> extensions) throws CertificateParsingException, IOException ;","/** 
 * @param clientKeyPair
 * @param extensions
 * @return DER encoded subjet key identifier
 * @throws CertificateParsingException thrown if problem parsing cert
 * @throws IOException thrown if error reading cert
 */
DEREncodable getSubjectKeyIdentifier(KeyPair clientKeyPair,Set<X509ExtensionWrapper> extensions) throws CertificateParsingException, IOException ;"
49542,"@Override public void configure(){
  bind(JPAInitializer.class).asEagerSingleton();
  bindConstant().annotatedWith(JpaUnit.class).to(""String_Node_Str"");
  bind(X509ExtensionUtil.class);
  bind(Config.class).to(CandlepinCommonTestConfig.class).asEagerSingleton();
  bind(ConsumerResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(SubscriptionResource.class);
  bind(SubscriptionTokenResource.class);
  bind(ProductServiceAdapter.class).to(DefaultProductServiceAdapter.class);
  bind(ProductResource.class);
  bind(DateSource.class).to(DateSourceForTesting.class).asEagerSingleton();
  bind(Enforcer.class).to(EnforcerForTesting.class);
  bind(PKIUtility.class).to(CandlepinPKIUtility.class);
  bind(PKIReader.class).to(PKIReaderForTesting.class).asEagerSingleton();
  bind(SubscriptionServiceAdapter.class).to(DefaultSubscriptionServiceAdapter.class);
  bind(EntitlementCertServiceAdapter.class).to(StubEntitlementCertServiceAdapter.class);
  bind(RulesCurator.class).to(TestRulesCurator.class);
  bind(ScriptEngineProvider.class);
  bind(I18n.class).toProvider(I18nProvider.class);
  bind(JobFactory.class).to(GuiceJobFactory.class);
  bind(JobListener.class).to(PinsetterJobListener.class);
  bind(UserServiceAdapter.class).to(DefaultUserServiceAdapter.class);
  bind(JsRulesProvider.class).asEagerSingleton();
  bind(JsRules.class).toProvider(JsRulesProvider.class);
  bind(PrincipalProvider.class).to(TestPrincipalProvider.class);
  bind(Principal.class).toProvider(TestPrincipalProvider.class);
  bind(EventSink.class).to(EventSinkForTesting.class);
  SecurityInterceptor se=new SecurityInterceptor();
  requestInjection(se);
  securityInterceptor=new TestingInterceptor(se);
  bindInterceptor(Matchers.inPackage(Package.getPackage(""String_Node_Str"")),Matchers.any(),securityInterceptor);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(AllowRoles.class),securityInterceptor);
  AccessControlInterceptor crud=new AccessControlInterceptor();
  requestInjection(crud);
  crudInterceptor=new TestingInterceptor(crud);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(EnforceAccessControl.class),crudInterceptor);
  bind(CertificateRevocationListTask.class);
  bind(String.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(""String_Node_Str"");
  bind(IdentityCertServiceAdapter.class).to(DefaultIdentityCertServiceAdapter.class);
  bind(PoolRules.class).to(JsPoolRules.class);
  bind(PoolManager.class).to(CandlepinPoolManager.class);
  bind(Function.class).annotatedWith(Names.named(""String_Node_Str"")).to(ExpiryDateFunction.class).in(Singleton.class);
}","@Override public void configure(){
  bind(JPAInitializer.class).asEagerSingleton();
  bindConstant().annotatedWith(JpaUnit.class).to(""String_Node_Str"");
  bind(X509ExtensionUtil.class);
  bind(Config.class).to(CandlepinCommonTestConfig.class).asEagerSingleton();
  bind(ConsumerResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(SubscriptionResource.class);
  bind(SubscriptionTokenResource.class);
  bind(ProductServiceAdapter.class).to(DefaultProductServiceAdapter.class);
  bind(ProductResource.class);
  bind(DateSource.class).to(DateSourceForTesting.class).asEagerSingleton();
  bind(Enforcer.class).to(EnforcerForTesting.class);
  bind(PKIUtility.class).to(CandlepinPKIUtility.class);
  bind(PKIReader.class).to(PKIReaderForTesting.class).asEagerSingleton();
  bind(SubscriptionServiceAdapter.class).to(DefaultSubscriptionServiceAdapter.class);
  bind(EntitlementCertServiceAdapter.class).to(StubEntitlementCertServiceAdapter.class);
  bind(ScriptEngineProvider.class);
  bind(I18n.class).toProvider(I18nProvider.class);
  bind(JobFactory.class).to(GuiceJobFactory.class);
  bind(JobListener.class).to(PinsetterJobListener.class);
  bind(UserServiceAdapter.class).to(DefaultUserServiceAdapter.class);
  bind(JsRulesProvider.class).asEagerSingleton();
  bind(JsRules.class).toProvider(JsRulesProvider.class);
  bind(PrincipalProvider.class).to(TestPrincipalProvider.class);
  bind(Principal.class).toProvider(TestPrincipalProvider.class);
  bind(EventSink.class).to(EventSinkForTesting.class);
  SecurityInterceptor se=new SecurityInterceptor();
  requestInjection(se);
  securityInterceptor=new TestingInterceptor(se);
  bindInterceptor(Matchers.inPackage(Package.getPackage(""String_Node_Str"")),Matchers.any(),securityInterceptor);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(AllowRoles.class),securityInterceptor);
  AccessControlInterceptor crud=new AccessControlInterceptor();
  requestInjection(crud);
  crudInterceptor=new TestingInterceptor(crud);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(EnforceAccessControl.class),crudInterceptor);
  bind(CertificateRevocationListTask.class);
  bind(String.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(""String_Node_Str"");
  bind(IdentityCertServiceAdapter.class).to(DefaultIdentityCertServiceAdapter.class);
  bind(PoolRules.class).to(JsPoolRules.class);
  bind(PoolManager.class).to(CandlepinPoolManager.class);
  bind(Function.class).annotatedWith(Names.named(""String_Node_Str"")).to(ExpiryDateFunction.class).in(Singleton.class);
}"
49543,"@Before public void setUp() throws Exception {
  o=createOwner();
  ownerCurator.create(o);
  virtHost=new Product(PRODUCT_VIRT_HOST,PRODUCT_VIRT_HOST);
  virtHostPlatform=new Product(PRODUCT_VIRT_HOST_PLATFORM,PRODUCT_VIRT_HOST_PLATFORM);
  virtGuest=new Product(PRODUCT_VIRT_GUEST,PRODUCT_VIRT_GUEST);
  monitoring=new Product(PRODUCT_MONITORING,PRODUCT_MONITORING);
  provisioning=new Product(PRODUCT_PROVISIONING,PRODUCT_PROVISIONING);
  virtHost.addAttribute(new ProductAttribute(PRODUCT_VIRT_HOST,""String_Node_Str""));
  virtHostPlatform.addAttribute(new ProductAttribute(PRODUCT_VIRT_HOST_PLATFORM,""String_Node_Str""));
  virtGuest.addAttribute(new ProductAttribute(PRODUCT_VIRT_GUEST,""String_Node_Str""));
  monitoring.addAttribute(new ProductAttribute(PRODUCT_MONITORING,""String_Node_Str""));
  provisioning.addAttribute(new ProductAttribute(PRODUCT_PROVISIONING,""String_Node_Str""));
  productAdapter.createProduct(virtHost);
  productAdapter.createProduct(virtHostPlatform);
  productAdapter.createProduct(virtGuest);
  productAdapter.createProduct(monitoring);
  productAdapter.createProduct(provisioning);
  subCurator.create(new Subscription(o,virtHost,new HashSet<Product>(),5L,new Date(),TestUtil.createDate(3020,12,12),new Date()));
  subCurator.create(new Subscription(o,virtHostPlatform,new HashSet<Product>(),5L,new Date(),TestUtil.createDate(3020,12,12),new Date()));
  subCurator.create(new Subscription(o,monitoring,new HashSet<Product>(),5L,new Date(),TestUtil.createDate(3020,12,12),new Date()));
  subCurator.create(new Subscription(o,provisioning,new HashSet<Product>(),5L,new Date(),TestUtil.createDate(3020,12,12),new Date()));
  poolManager.refreshPools(o);
  this.systemType=new ConsumerType(ConsumerTypeEnum.SYSTEM);
  consumerTypeCurator.create(systemType);
  parentSystem=new Consumer(""String_Node_Str"",""String_Node_Str"",o,systemType);
  parentSystem.getFacts().put(""String_Node_Str"",""String_Node_Str"");
  consumerCurator.create(parentSystem);
  childVirtSystem=new Consumer(""String_Node_Str"",""String_Node_Str"",o,systemType);
  parentSystem.addChildConsumer(childVirtSystem);
  consumerCurator.create(childVirtSystem);
}","@Before public void setUp() throws Exception {
  o=createOwner();
  ownerCurator.create(o);
  virtHost=new Product(PRODUCT_VIRT_HOST,PRODUCT_VIRT_HOST);
  virtHostPlatform=new Product(PRODUCT_VIRT_HOST_PLATFORM,PRODUCT_VIRT_HOST_PLATFORM);
  virtGuest=new Product(PRODUCT_VIRT_GUEST,PRODUCT_VIRT_GUEST);
  monitoring=new Product(PRODUCT_MONITORING,PRODUCT_MONITORING);
  monitoring.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  provisioning=new Product(PRODUCT_PROVISIONING,PRODUCT_PROVISIONING);
  virtHost.addAttribute(new ProductAttribute(PRODUCT_VIRT_HOST,""String_Node_Str""));
  virtHostPlatform.addAttribute(new ProductAttribute(PRODUCT_VIRT_HOST_PLATFORM,""String_Node_Str""));
  virtGuest.addAttribute(new ProductAttribute(PRODUCT_VIRT_GUEST,""String_Node_Str""));
  monitoring.addAttribute(new ProductAttribute(PRODUCT_MONITORING,""String_Node_Str""));
  provisioning.addAttribute(new ProductAttribute(PRODUCT_PROVISIONING,""String_Node_Str""));
  productAdapter.createProduct(virtHost);
  productAdapter.createProduct(virtHostPlatform);
  productAdapter.createProduct(virtGuest);
  productAdapter.createProduct(monitoring);
  productAdapter.createProduct(provisioning);
  subCurator.create(new Subscription(o,virtHost,new HashSet<Product>(),5L,new Date(),TestUtil.createDate(3020,12,12),new Date()));
  subCurator.create(new Subscription(o,virtHostPlatform,new HashSet<Product>(),5L,new Date(),TestUtil.createDate(3020,12,12),new Date()));
  subCurator.create(new Subscription(o,monitoring,new HashSet<Product>(),5L,new Date(),TestUtil.createDate(3020,12,12),new Date()));
  subCurator.create(new Subscription(o,provisioning,new HashSet<Product>(),5L,new Date(),TestUtil.createDate(3020,12,12),new Date()));
  poolManager.refreshPools(o);
  this.systemType=new ConsumerType(ConsumerTypeEnum.SYSTEM);
  consumerTypeCurator.create(systemType);
  parentSystem=new Consumer(""String_Node_Str"",""String_Node_Str"",o,systemType);
  parentSystem.getFacts().put(""String_Node_Str"",""String_Node_Str"");
  consumerCurator.create(parentSystem);
  childVirtSystem=new Consumer(""String_Node_Str"",""String_Node_Str"",o,systemType);
  parentSystem.addChildConsumer(childVirtSystem);
  consumerCurator.create(childVirtSystem);
}"
49544,"@Test public void testLookupRuleFiltering(){
  Product p=new Product(CPU_LIMITED_PRODUCT,CPU_LIMITED_PRODUCT);
  p.addAttribute(new ProductAttribute(CPU_LIMITED_PRODUCT,""String_Node_Str""));
  productCurator.create(p);
  Pool pool=createPoolAndSub(owner,p,100L,TestUtil.createDate(2000,3,2),TestUtil.createDate(2050,3,2));
  poolCurator.create(pool);
  List<Pool> results=poolCurator.listByConsumer(consumer);
  assertEquals(0,results.size());
}","@Test public void testLookupRuleFiltering(){
  Product p=new Product(CPU_LIMITED_PRODUCT,CPU_LIMITED_PRODUCT);
  p.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  productCurator.create(p);
  Pool pool=createPoolAndSub(owner,p,100L,TestUtil.createDate(2000,3,2),TestUtil.createDate(2050,3,2));
  poolCurator.create(pool);
  consumer.setFact(""String_Node_Str"",""String_Node_Str"");
  List<Pool> results=poolCurator.listByConsumer(consumer);
  assertEquals(0,results.size());
}"
49545,"@Test public void concurrentCreationOfEntitlementsShouldWorkIfUnderMaxMemberLimit() throws Exception {
  Long numAvailEntitlements=2L;
  Product newProduct=TestUtil.createProduct();
  productCurator.create(newProduct);
  Pool consumerPool=createPoolAndSub(owner,newProduct,numAvailEntitlements,TestUtil.createDate(2009,11,30),TestUtil.createDate(2050,11,30));
  consumerPool=poolCurator.create(consumerPool);
  CandlepinPoolManager anotherEntitler=injector.getInstance(CandlepinPoolManager.class);
  anotherEntitler.entitleByProduct(consumer,newProduct.getId(),new Integer(""String_Node_Str""));
  anotherEntitler.entitleByProduct(consumer,newProduct.getId(),new Integer(""String_Node_Str""));
  assertFalse(poolCurator.find(consumerPool.getId()).entitlementsAvailable(1));
}","@Test public void concurrentCreationOfEntitlementsShouldWorkIfUnderMaxMemberLimit() throws Exception {
  Long numAvailEntitlements=2L;
  Product newProduct=TestUtil.createProduct();
  newProduct.addAttribute(new ProductAttribute(""String_Node_Str"",""String_Node_Str""));
  productCurator.create(newProduct);
  Pool consumerPool=createPoolAndSub(owner,newProduct,numAvailEntitlements,TestUtil.createDate(2009,11,30),TestUtil.createDate(2050,11,30));
  consumerPool=poolCurator.create(consumerPool);
  CandlepinPoolManager anotherEntitler=injector.getInstance(CandlepinPoolManager.class);
  anotherEntitler.entitleByProduct(consumer,newProduct.getId(),new Integer(""String_Node_Str""));
  anotherEntitler.entitleByProduct(consumer,newProduct.getId(),new Integer(""String_Node_Str""));
  assertFalse(poolCurator.find(consumerPool.getId()).entitlementsAvailable(1));
}"
49546,"@Before public void setUp(){
  owner=createOwner();
  ownerCurator.create(owner);
  product=TestUtil.createProduct();
  productCurator.create(product);
  consumer=TestUtil.createConsumer(owner);
  consumer.setFact(""String_Node_Str"",""String_Node_Str"");
  consumerTypeCurator.create(consumer.getType());
  consumerCurator.create(consumer);
}","@Before public void setUp(){
  owner=createOwner();
  ownerCurator.create(owner);
  product=TestUtil.createProduct();
  productCurator.create(product);
  consumer=TestUtil.createConsumer(owner);
  consumer.setFact(""String_Node_Str"",""String_Node_Str"");
  consumer.setType(new ConsumerType(""String_Node_Str""));
  consumerTypeCurator.create(consumer.getType());
  consumerCurator.create(consumer);
}"
49547,"@Override public List<UpdatedPool> updatePools(Subscription sub,List<Pool> existingPools){
  Map<String,Object> args=new HashMap<String,Object>();
  args.put(""String_Node_Str"",sub);
  args.put(""String_Node_Str"",existingPools);
  args.put(""String_Node_Str"",jsRules.getFlattenedAttributes(sub.getProduct(),null));
  args.put(""String_Node_Str"",new PoolHelper(this.poolManager,this.productAdapter,null));
  List<UpdatedPool> poolsUpdated=null;
  try {
    poolsUpdated=jsRules.invokeMethod(""String_Node_Str"",args);
  }
 catch (  NoSuchMethodException e) {
    log.error(""String_Node_Str"");
    log.error(e);
    throw new IseException(""String_Node_Str"");
  }
  return poolsUpdated;
}","@Override public List<UpdatedPool> updatePools(Subscription sub,List<Pool> existingPools){
  Map<String,Object> args=new HashMap<String,Object>();
  args.put(""String_Node_Str"",sub);
  args.put(""String_Node_Str"",existingPools);
  args.put(""String_Node_Str"",jsRules.getFlattenedAttributes(sub.getProduct(),null));
  args.put(""String_Node_Str"",log);
  args.put(""String_Node_Str"",new PoolHelper(this.poolManager,this.productAdapter,null));
  List<UpdatedPool> poolsUpdated=null;
  try {
    poolsUpdated=jsRules.invokeMethod(""String_Node_Str"",args);
  }
 catch (  NoSuchMethodException e) {
    log.error(""String_Node_Str"");
    log.error(e);
    throw new IseException(""String_Node_Str"");
  }
  return poolsUpdated;
}"
49548,"/** 
 * @param sub
 * @return the newly created Pool
 */
public Pool createPoolForSubscription(Subscription sub){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + sub.getId());
  }
  Long quantity=sub.getQuantity() * sub.getProduct().getMultiplier();
  Set<ProvidedProduct> providedProducts=new HashSet<ProvidedProduct>();
  for (  Product p : sub.getProvidedProducts()) {
    ProvidedProduct providedProduct=new ProvidedProduct(p.getId(),p.getName());
    providedProducts.add(providedProduct);
  }
  Pool newPool=new Pool(sub.getOwner(),sub.getProduct().getId(),providedProducts,quantity,sub.getStartDate(),sub.getEndDate(),sub.getContractNumber());
  newPool.setSubscriptionId(sub.getId());
  createPool(newPool);
  return newPool;
}","/** 
 * @param sub
 * @return the newly created Pool
 */
public Pool createPoolForSubscription(Subscription sub){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + sub.getId());
  }
  Long quantity=sub.getQuantity() * sub.getProduct().getMultiplier();
  Set<ProvidedProduct> providedProducts=new HashSet<ProvidedProduct>();
  Pool newPool=new Pool(sub.getOwner(),sub.getProduct().getId(),providedProducts,quantity,sub.getStartDate(),sub.getEndDate(),sub.getContractNumber());
  for (  Product p : sub.getProvidedProducts()) {
    ProvidedProduct providedProduct=new ProvidedProduct(p.getId(),p.getName());
    providedProduct.setPool(newPool);
    providedProducts.add(providedProduct);
  }
  createPool(newPool);
  return newPool;
}"
49549,"/** 
 * @return the pool
 */
public Pool getPool(){
  return pool;
}","/** 
 * @return the pool
 */
@XmlTransient public Pool getPool(){
  return pool;
}"
49550,"@Inject public PoolResource(PoolCurator poolCurator,ConsumerCurator consumerCurator,OwnerCurator ownerCurator,ProductServiceAdapter productServiceAdapter,I18n i18n,EventSink eventSink){
  this.poolCurator=poolCurator;
  this.consumerCurator=consumerCurator;
  this.ownerCurator=ownerCurator;
  this.productServiceAdapter=productServiceAdapter;
  this.i18n=i18n;
  this.eventSink=eventSink;
}","@Inject public PoolResource(PoolCurator poolCurator,ConsumerCurator consumerCurator,OwnerCurator ownerCurator,I18n i18n,EventSink eventSink){
  this.poolCurator=poolCurator;
  this.consumerCurator=consumerCurator;
  this.ownerCurator=ownerCurator;
  this.i18n=i18n;
  this.eventSink=eventSink;
}"
49551,"@POST @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Pool createPool(Pool pool){
  Owner owner=ownerCurator.find(pool.getOwner().getId());
  if (owner == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",pool.getOwner().getId()));
  }
  pool.setOwner(owner);
  for (  PoolAttribute attr : pool.getAttributes()) {
    attr.setPool(pool);
  }
  Pool toReturn=poolCurator.create(pool);
  if (toReturn != null) {
    eventSink.emitPoolCreated(toReturn);
    return toReturn;
  }
  throw new BadRequestException(i18n.tr(""String_Node_Str"",pool));
}","@POST @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Pool createPool(Pool pool){
  Owner owner=ownerCurator.find(pool.getOwner().getId());
  if (owner == null) {
    throw new NotFoundException(i18n.tr(""String_Node_Str"",pool.getOwner().getId()));
  }
  pool.setOwner(owner);
  Pool toReturn=poolCurator.create(pool);
  if (toReturn != null) {
    eventSink.emitPoolCreated(toReturn);
    return toReturn;
  }
  throw new BadRequestException(i18n.tr(""String_Node_Str"",pool));
}"
49552,"/** 
 * @param product
 * @return the newly created product, or the product that alreadyexists
 */
@POST @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @AllowRoles(roles={Role.SUPER_ADMIN}) public Product createProduct(Product product){
  for (  ProductAttribute attr : product.getAttributes()) {
    attr.setProduct(product);
  }
  return prodAdapter.createProduct(product);
}","/** 
 * @param product
 * @return the newly created product, or the product that alreadyexists
 */
@POST @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @AllowRoles(roles={Role.SUPER_ADMIN}) public Product createProduct(Product product){
  return prodAdapter.createProduct(product);
}"
49553,"private Entitlement addEntitlement(Consumer consumer,Pool pool,Integer quantity) throws EntitlementRefusedException {
  PreEntHelper preHelper=enforcer.preEntitlement(consumer,pool,quantity);
  ValidationResult result=preHelper.getResult();
  if (!result.isSuccessful()) {
    log.warn(""String_Node_Str"" + result.getErrors().toString());
    throw new EntitlementRefusedException(result);
  }
  Entitlement e=new Entitlement(pool,consumer,new Date(),pool.getEndDate(),quantity);
  consumer.addEntitlement(e);
  if (preHelper.getGrantFreeEntitlement()) {
    log.info(""String_Node_Str"");
    e.setIsFree(Boolean.TRUE);
  }
 else {
    pool.bumpConsumed(quantity);
  }
  postEntHelper.init(e);
  enforcer.postEntitlement(consumer,postEntHelper,e);
  entitlementCurator.create(e);
  consumerCurator.update(consumer);
  Pool mergedPool=epCurator.merge(pool);
  generateEntitlementCertificate(consumer,mergedPool,e);
  return e;
}","private Entitlement addEntitlement(Consumer consumer,Pool pool,Integer quantity) throws EntitlementRefusedException {
  PreEntHelper preHelper=enforcer.preEntitlement(consumer,pool,quantity);
  ValidationResult result=preHelper.getResult();
  if (!result.isSuccessful()) {
    log.warn(""String_Node_Str"" + result.getErrors().toString());
    throw new EntitlementRefusedException(result);
  }
  Entitlement e=new Entitlement(pool,consumer,new Date(),pool.getEndDate(),quantity);
  consumer.addEntitlement(e);
  pool.getEntitlements().add(e);
  if (preHelper.getGrantFreeEntitlement()) {
    log.info(""String_Node_Str"");
    e.setIsFree(Boolean.TRUE);
  }
 else {
    pool.bumpConsumed(quantity);
  }
  postEntHelper.init(e);
  enforcer.postEntitlement(consumer,postEntHelper,e);
  entitlementCurator.create(e);
  consumerCurator.update(consumer);
  Pool mergedPool=epCurator.merge(pool);
  generateEntitlementCertificate(consumer,mergedPool,e);
  return e;
}"
49554,"@SuppressWarnings(""String_Node_Str"") @Transactional public void delete(Entitlement entity){
  Entitlement toDelete=find(entity.getId());
  log.debug(""String_Node_Str"" + toDelete);
  log.debug(""String_Node_Str"" + toDelete.getCertificates().size());
  for (  EntitlementCertificate cert : toDelete.getCertificates()) {
    currentSession().delete(cert);
  }
  toDelete.getCertificates().clear();
  List<Pool> pools=currentSession().createCriteria(Pool.class).add(Restrictions.eq(""String_Node_Str"",entity)).list();
  for (  Pool pool : pools) {
    pool.setSourceEntitlement(null);
    currentSession().merge(pool);
  }
  currentSession().delete(toDelete);
  flush();
}","@SuppressWarnings(""String_Node_Str"") @Transactional public void delete(Entitlement entity){
  Entitlement toDelete=find(entity.getId());
  log.debug(""String_Node_Str"" + toDelete);
  log.debug(""String_Node_Str"" + toDelete.getCertificates().size());
  for (  EntitlementCertificate cert : toDelete.getCertificates()) {
    currentSession().delete(cert);
  }
  toDelete.getCertificates().clear();
  List<Pool> pools=currentSession().createCriteria(Pool.class).add(Restrictions.eq(""String_Node_Str"",entity)).list();
  for (  Pool pool : pools) {
    pool.setSourceEntitlement(null);
    currentSession().merge(pool);
  }
  toDelete.getPool().getEntitlements().remove(toDelete);
  currentSession().delete(toDelete);
  flush();
}"
49555,"/** 
 * Gets the entitlements for this instance.
 * @return The entitlements.
 */
public Set<Entitlement> getEntitlements(){
  return this.entitlements;
}","/** 
 * Gets the entitlements for this instance.
 * @return The entitlements.
 */
@XmlTransient public Set<Entitlement> getEntitlements(){
  return this.entitlements;
}"
49556,"@Test public void createEntitlementShouldIncreaseNumberOfMembers() throws Exception {
  Long numAvailEntitlements=new Long(1);
  Product newProduct=TestUtil.createProduct();
  productCurator.create(newProduct);
  Pool consumerPool=createPoolAndSub(owner,newProduct,numAvailEntitlements,TestUtil.createDate(2009,11,30),TestUtil.createDate(2050,11,30));
  consumerPool=poolCurator.create(consumerPool);
  entitler.entitleByProduct(consumer,newProduct.getId(),new Integer(""String_Node_Str""));
  assertFalse(poolCurator.find(consumerPool.getId()).entitlementsAvailable(new Integer(1)));
}","@Test public void createEntitlementShouldIncreaseNumberOfMembers() throws Exception {
  Long numAvailEntitlements=new Long(1);
  Product newProduct=TestUtil.createProduct();
  productCurator.create(newProduct);
  Pool consumerPool=createPoolAndSub(owner,newProduct,numAvailEntitlements,TestUtil.createDate(2009,11,30),TestUtil.createDate(2050,11,30));
  consumerPool=poolCurator.create(consumerPool);
  entitler.entitleByProduct(consumer,newProduct.getId(),new Integer(""String_Node_Str""));
  consumerPool=poolCurator.find(consumerPool.getId());
  assertFalse(consumerPool.entitlementsAvailable(new Integer(1)));
  assertEquals(1,consumerPool.getEntitlements().size());
}"
49557,"/** 
 * Gets the serial.
 * @return the serial
 */
@JsonIgnore public BigInteger getSerial(){
  if (this.serial != null) {
    return serial;
  }
  return this.getX509Certificate().getSerialNumber();
}","/** 
 * Gets the serial.
 * @return the serial
 */
@JsonIgnore public BigInteger getSerial(){
  return this.getX509Certificate().getSerialNumber();
}"
49558,"/** 
 * List entitlement pools. Pools will be refreshed from the underlying subscription service. If a consumer is specified, a pass through the rules will be done for each potentially usable pool.
 * @param c
 * @param o
 * @param productId
 * @param activeOnly
 * @return List of entitlement pools.
 */
@SuppressWarnings(""String_Node_Str"") @Transactional @EnforceAccessControl public List<Pool> listAvailableEntitlementPools(Consumer c,Owner o,String productId,boolean activeOnly){
  if (o == null && c != null) {
    o=c.getOwner();
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
    log.debug(""String_Node_Str"" + c);
    log.debug(""String_Node_Str"" + o);
    log.debug(""String_Node_Str"" + productId);
  }
  List<Pool> results=null;
  Criteria crit=currentSession().createCriteria(Pool.class);
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
  }
  crit.add(Restrictions.lt(""String_Node_Str"",new Date()));
  crit.add(Restrictions.gt(""String_Node_Str"",new Date()));
  results=crit.list();
  log.debug(""String_Node_Str"" + results.size());
  if (results == null) {
    log.debug(""String_Node_Str"");
    return new ArrayList<Pool>();
  }
  if (productId != null) {
    List<Pool> newResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      if (p.provides(productId)) {
        newResults.add(p);
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + productId + ""String_Node_Str""+ p);
        }
      }
    }
    results=newResults;
  }
  addProductNames(results);
  if (c != null) {
    List<Pool> newResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      PreEntHelper helper=enforcer.pre(c,p,1);
      if (helper.getResult().isSuccessful() && !helper.getResult().hasWarnings()) {
        newResults.add(p);
      }
 else {
        log.info(""String_Node_Str"" + p.getId());
        log.info(helper.getResult().getErrors());
        log.info(helper.getResult().getWarnings());
      }
    }
    results=newResults;
  }
  return results;
}","/** 
 * List entitlement pools. Pools will be refreshed from the underlying subscription service. If a consumer is specified, a pass through the rules will be done for each potentially usable pool.
 * @param c
 * @param o
 * @param productId
 * @param activeOnly
 * @return List of entitlement pools.
 */
@SuppressWarnings(""String_Node_Str"") @Transactional @EnforceAccessControl public List<Pool> listAvailableEntitlementPools(Consumer c,Owner o,String productId,boolean activeOnly){
  if (o == null && c != null) {
    o=c.getOwner();
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
    log.debug(""String_Node_Str"" + c);
    log.debug(""String_Node_Str"" + o);
    log.debug(""String_Node_Str"" + productId);
  }
  Criteria crit=currentSession().createCriteria(Pool.class);
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
  }
  crit.add(Restrictions.lt(""String_Node_Str"",new Date()));
  crit.add(Restrictions.gt(""String_Node_Str"",new Date()));
  List<Pool> results=crit.list();
  log.debug(""String_Node_Str"" + results.size());
  if (results == null) {
    log.debug(""String_Node_Str"");
    return new ArrayList<Pool>();
  }
  if (productId != null) {
    List<Pool> newResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      if (p.provides(productId)) {
        newResults.add(p);
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + productId + ""String_Node_Str""+ p);
        }
      }
    }
    results=newResults;
  }
  addProductNames(results);
  if (c != null) {
    List<Pool> newResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      PreEntHelper helper=enforcer.pre(c,p,1);
      if (helper.getResult().isSuccessful() && !helper.getResult().hasWarnings()) {
        newResults.add(p);
      }
 else {
        log.info(""String_Node_Str"" + p.getId());
        log.info(helper.getResult().getErrors());
        log.info(helper.getResult().getWarnings());
      }
    }
    results=newResults;
  }
  return results;
}"
49559,"public static Product createProduct(){
  int random=randomInt();
  Product rhel=new Product(""String_Node_Str"" + random,""String_Node_Str"" + random);
  rhel.setId(""String_Node_Str"" + random);
  ProductAttribute a1=new ProductAttribute(""String_Node_Str"",""String_Node_Str"");
  a1.setId(new Long(1001));
  rhel.addAttribute(a1);
  ProductAttribute a2=new ProductAttribute(""String_Node_Str"",""String_Node_Str"");
  a2.setId(new Long(1002));
  rhel.addAttribute(a2);
  return rhel;
}","public static Product createProduct(){
  int random=randomInt();
  Product rhel=new Product(""String_Node_Str"" + random,""String_Node_Str"" + random);
  rhel.setId(""String_Node_Str"" + random);
  ProductAttribute a1=new ProductAttribute(""String_Node_Str"",""String_Node_Str"");
  rhel.addAttribute(a1);
  ProductAttribute a2=new ProductAttribute(""String_Node_Str"",""String_Node_Str"");
  rhel.addAttribute(a2);
  return rhel;
}"
49560,"@Test public void testRefreshPoolsWithRemovedSubscriptions(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Subscription sub=new Subscription(owner,prod,new HashSet<Product>(),2000L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub);
  ownerResource.refreshEntitlementPools(owner.getKey());
  List<Pool> pools=poolCurator.listByOwnerAndProduct(owner,prod.getId());
  assertEquals(1,pools.size());
  Pool newPool=pools.get(0);
  subCurator.delete(sub);
  ownerResource.refreshEntitlementPools(owner.getKey());
  assertEquals(1,pools.size());
  newPool=pools.get(0);
  assertFalse(newPool.isActive());
}","@Test public void testRefreshPoolsWithRemovedSubscriptions(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Subscription sub=new Subscription(owner,prod,new HashSet<Product>(),2000L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub);
  ownerResource.refreshEntitlementPools(owner.getKey(),false);
  List<Pool> pools=poolCurator.listByOwnerAndProduct(owner,prod.getId());
  assertEquals(1,pools.size());
  Pool newPool=pools.get(0);
  subCurator.delete(sub);
  ownerResource.refreshEntitlementPools(owner.getKey(),false);
  assertEquals(1,pools.size());
  newPool=pools.get(0);
  assertFalse(newPool.isActive());
}"
49561,"@Test public void testRefreshMultiplePools(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Product prod2=TestUtil.createProduct();
  productCurator.create(prod2);
  Subscription sub=new Subscription(owner,prod,new HashSet<Product>(),2000L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub);
  Subscription sub2=new Subscription(owner,prod2,new HashSet<Product>(),800L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub2);
  ownerResource.refreshEntitlementPools(owner.getKey());
  List<Pool> pools=poolCurator.listByOwner(owner);
  assertEquals(2,pools.size());
}","@Test public void testRefreshMultiplePools(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Product prod2=TestUtil.createProduct();
  productCurator.create(prod2);
  Subscription sub=new Subscription(owner,prod,new HashSet<Product>(),2000L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub);
  Subscription sub2=new Subscription(owner,prod2,new HashSet<Product>(),800L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub2);
  ownerResource.refreshEntitlementPools(owner.getKey(),false);
  List<Pool> pools=poolCurator.listByOwner(owner);
  assertEquals(2,pools.size());
}"
49562,"@Test public void testRefreshPoolsWithChangedSubscriptions(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Pool pool=createPoolAndSub(createOwner(),prod,new Long(1000),TestUtil.createDate(2009,11,30),TestUtil.createDate(2015,11,30));
  Owner owner=pool.getOwner();
  Subscription sub=new Subscription(owner,prod,new HashSet<Product>(),2000L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub);
  assertTrue(pool.getQuantity() < sub.getQuantity());
  assertTrue(pool.getStartDate() != sub.getStartDate());
  assertTrue(pool.getEndDate() != sub.getEndDate());
  pool.setSubscriptionId(sub.getId());
  poolCurator.merge(pool);
  ownerResource.refreshEntitlementPools(owner.getKey());
  pool=poolCurator.find(pool.getId());
  assertEquals(sub.getId(),pool.getSubscriptionId());
  assertEquals(sub.getQuantity(),pool.getQuantity());
  assertEquals(sub.getStartDate(),pool.getStartDate());
  assertEquals(sub.getEndDate(),pool.getEndDate());
}","@Test public void testRefreshPoolsWithChangedSubscriptions(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Pool pool=createPoolAndSub(createOwner(),prod,new Long(1000),TestUtil.createDate(2009,11,30),TestUtil.createDate(2015,11,30));
  Owner owner=pool.getOwner();
  Subscription sub=new Subscription(owner,prod,new HashSet<Product>(),2000L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub);
  assertTrue(pool.getQuantity() < sub.getQuantity());
  assertTrue(pool.getStartDate() != sub.getStartDate());
  assertTrue(pool.getEndDate() != sub.getEndDate());
  pool.setSubscriptionId(sub.getId());
  poolCurator.merge(pool);
  ownerResource.refreshEntitlementPools(owner.getKey(),false);
  pool=poolCurator.find(pool.getId());
  assertEquals(sub.getId(),pool.getSubscriptionId());
  assertEquals(sub.getQuantity(),pool.getQuantity());
  assertEquals(sub.getStartDate(),pool.getStartDate());
  assertEquals(sub.getEndDate(),pool.getEndDate());
}"
49563,"@Test public void testRefreshPoolsWithNewSubscriptions(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Subscription sub=new Subscription(owner,prod,new HashSet<Product>(),2000L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub);
  ownerResource.refreshEntitlementPools(owner.getKey());
  List<Pool> pools=poolCurator.listByOwnerAndProduct(owner,prod.getId());
  assertEquals(1,pools.size());
  Pool newPool=pools.get(0);
  assertEquals(sub.getId(),newPool.getSubscriptionId());
  assertEquals(sub.getQuantity(),newPool.getQuantity());
  assertEquals(sub.getStartDate(),newPool.getStartDate());
  assertEquals(sub.getEndDate(),newPool.getEndDate());
}","@Test public void testRefreshPoolsWithNewSubscriptions(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Subscription sub=new Subscription(owner,prod,new HashSet<Product>(),2000L,TestUtil.createDate(2010,2,9),TestUtil.createDate(3000,2,9),TestUtil.createDate(2010,2,12));
  subCurator.create(sub);
  ownerResource.refreshEntitlementPools(owner.getKey(),false);
  List<Pool> pools=poolCurator.listByOwnerAndProduct(owner,prod.getId());
  assertEquals(1,pools.size());
  Pool newPool=pools.get(0);
  assertEquals(sub.getId(),newPool.getSubscriptionId());
  assertEquals(sub.getQuantity(),newPool.getQuantity());
  assertEquals(sub.getStartDate(),newPool.getStartDate());
  assertEquals(sub.getEndDate(),newPool.getEndDate());
}"
49564,"/** 
 * @return
 */
private void doTestEntitlementsRevocationCommon(long subQ,int e1,int e2,boolean fifo){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Pool pool=createPoolAndSub(createOwner(),prod,new Long(1000),TestUtil.createDate(2009,11,30),TestUtil.createDate(2015,11,30));
  Owner owner=pool.getOwner();
  Consumer consumer=createConsumer(owner);
  Consumer consumer1=createConsumer(owner);
  Subscription sub=this.subCurator.find(pool.getSubscriptionId());
  sub.setQuantity(subQ);
  this.subCurator.merge(sub);
  this.ownerResource.refreshEntitlementPools(owner.getKey());
  pool=this.poolCurator.find(pool.getId());
  createEntitlementWithQ(pool,owner,consumer,e1,""String_Node_Str"");
  createEntitlementWithQ(pool,owner,consumer1,e2,""String_Node_Str"");
  assertEquals(pool.getConsumed(),Long.valueOf(e1 + e2));
  this.config.setProperty(ConfigProperties.REVOKE_ENTITLEMENT_IN_FIFO_ORDER,fifo ? ""String_Node_Str"" : ""String_Node_Str"");
  this.ownerResource.refreshEntitlementPools(owner.getKey());
  pool=poolCurator.find(pool.getId());
}","/** 
 * @return
 */
private void doTestEntitlementsRevocationCommon(long subQ,int e1,int e2,boolean fifo){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Pool pool=createPoolAndSub(createOwner(),prod,new Long(1000),TestUtil.createDate(2009,11,30),TestUtil.createDate(2015,11,30));
  Owner owner=pool.getOwner();
  Consumer consumer=createConsumer(owner);
  Consumer consumer1=createConsumer(owner);
  Subscription sub=this.subCurator.find(pool.getSubscriptionId());
  sub.setQuantity(subQ);
  this.subCurator.merge(sub);
  this.ownerResource.refreshEntitlementPools(owner.getKey(),false);
  pool=this.poolCurator.find(pool.getId());
  createEntitlementWithQ(pool,owner,consumer,e1,""String_Node_Str"");
  createEntitlementWithQ(pool,owner,consumer1,e2,""String_Node_Str"");
  assertEquals(pool.getConsumed(),Long.valueOf(e1 + e2));
  this.config.setProperty(ConfigProperties.REVOKE_ENTITLEMENT_IN_FIFO_ORDER,fifo ? ""String_Node_Str"" : ""String_Node_Str"");
  this.ownerResource.refreshEntitlementPools(owner.getKey(),false);
  pool=poolCurator.find(pool.getId());
}"
49565,"@Override public void configure(){
  bind(JPAInitializer.class).asEagerSingleton();
  bind(Properties.class).annotatedWith(JpaUnit.class).toInstance(new Config().jpaConfiguration());
  bindConstant().annotatedWith(JpaUnit.class).to(""String_Node_Str"");
  bind(Config.class);
  bind(PKIUtility.class).to(CandlepinPKIUtility.class).asEagerSingleton();
  bind(PKIReader.class).to(CandlepinPKIReader.class).asEagerSingleton();
  bind(X509ExtensionUtil.class);
  bind(ConsumerResource.class);
  bind(ConsumerTypeResource.class);
  bind(ContentResource.class);
  bind(AtomFeedResource.class);
  bind(EventResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(ProductResource.class);
  bind(SubscriptionResource.class);
  bind(SubscriptionTokenResource.class);
  bind(DateSource.class).to(DateSourceImpl.class).asEagerSingleton();
  bind(Enforcer.class).to(JavascriptEnforcer.class);
  bind(RulesResource.class);
  bind(AdminResource.class);
  bind(StatusResource.class);
  bind(CandlepinExceptionMapper.class);
  bind(Principal.class).toProvider(PrincipalProvider.class);
  bind(I18n.class).toProvider(I18nProvider.class);
  bind(AuthInterceptor.class);
  bind(JsonProvider.class);
  bind(EventSink.class).to(EventSinkImpl.class);
  bind(HighlanderJobFactory.class);
  bind(PinsetterKernel.class);
  bind(CertificateRevocationListTask.class);
  Matcher resourcePkgMatcher=Matchers.inPackage(Package.getPackage(""String_Node_Str""));
  SecurityInterceptor securityEnforcer=new SecurityInterceptor();
  requestInjection(securityEnforcer);
  bindInterceptor(resourcePkgMatcher,Matchers.any(),securityEnforcer);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(AllowRoles.class),securityEnforcer);
  AccessControlInterceptor accessControlInterceptor=new AccessControlInterceptor();
  requestInjection(accessControlInterceptor);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(EnforceAccessControl.class),accessControlInterceptor);
}","@Override public void configure(){
  bind(JPAInitializer.class).asEagerSingleton();
  bind(Properties.class).annotatedWith(JpaUnit.class).toInstance(new Config().jpaConfiguration());
  bindConstant().annotatedWith(JpaUnit.class).to(""String_Node_Str"");
  bind(Config.class);
  bind(PKIUtility.class).to(CandlepinPKIUtility.class).asEagerSingleton();
  bind(PKIReader.class).to(CandlepinPKIReader.class).asEagerSingleton();
  bind(X509ExtensionUtil.class);
  bind(ConsumerResource.class);
  bind(ConsumerTypeResource.class);
  bind(ContentResource.class);
  bind(AtomFeedResource.class);
  bind(EventResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(ProductResource.class);
  bind(SubscriptionResource.class);
  bind(SubscriptionTokenResource.class);
  bind(DateSource.class).to(DateSourceImpl.class).asEagerSingleton();
  bind(Enforcer.class).to(JavascriptEnforcer.class);
  bind(RulesResource.class);
  bind(AdminResource.class);
  bind(StatusResource.class);
  bind(CandlepinExceptionMapper.class);
  bind(Principal.class).toProvider(PrincipalProvider.class);
  bind(I18n.class).toProvider(I18nProvider.class);
  bind(AuthInterceptor.class);
  bind(JsonProvider.class);
  bind(EventSink.class).to(EventSinkImpl.class);
  bind(HighlanderJobFactory.class);
  bind(PinsetterKernel.class);
  bind(CertificateRevocationListTask.class);
  bind(String.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(""String_Node_Str"");
  Matcher resourcePkgMatcher=Matchers.inPackage(Package.getPackage(""String_Node_Str""));
  SecurityInterceptor securityEnforcer=new SecurityInterceptor();
  requestInjection(securityEnforcer);
  bindInterceptor(resourcePkgMatcher,Matchers.any(),securityEnforcer);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(AllowRoles.class),securityEnforcer);
  AccessControlInterceptor accessControlInterceptor=new AccessControlInterceptor();
  requestInjection(accessControlInterceptor);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(EnforceAccessControl.class),accessControlInterceptor);
}"
49566,"public CertificateSerial(Long id){
  this.id=id;
}","/** 
 */
public CertificateSerial(){
  super();
}"
49567,"@Inject public CertificateRevocationListTask(PKIReader rdr,Config conf){
  this.pkiReader=rdr;
  this.config=conf;
}","/** 
 * Instantiates a new certificate revocation list task.
 * @param rdr the rdr
 * @param conf the conf
 * @param curator the curator
 * @param algorithm the algorithm
 */
@Inject public CertificateRevocationListTask(PKIReader rdr,Config conf,CertificateSerialCurator curator,@Named(""String_Node_Str"") String algorithm){
  this.pkiReader=rdr;
  this.config=conf;
  this.certificateSerialCurator=curator;
  this.algorithm=algorithm;
}"
49568,"protected List<SimpleCRLEntry> toSimpleCRLEntries(Set<? extends X509CRLEntry> entries){
  List<SimpleCRLEntry> crlEntries=newList();
  for (  X509CRLEntry entry : entries) {
    crlEntries.add(new SimpleCRLEntry(entry.getSerialNumber(),entry.getRevocationDate()));
  }
  return crlEntries;
}","/** 
 * To simple crl entries.
 * @param entries the entries
 * @return the list
 */
protected List<SimpleCRLEntry> toSimpleCRLEntries(Set<? extends X509CRLEntry> entries){
  List<SimpleCRLEntry> crlEntries=newList();
  for (  X509CRLEntry entry : entries) {
    crlEntries.add(new SimpleCRLEntry(entry.getSerialNumber(),entry.getRevocationDate()));
  }
  return crlEntries;
}"
49569,"protected X509CRL generateCRL(Iterator<SimpleCRLEntry> entries,String principal,BigInteger crlNumber){
  try {
    X509V2CRLGenerator generator=new X509V2CRLGenerator();
    generator.setIssuerDN(new X500Principal(principal));
    generator.setThisUpdate(new Date());
    while (entries.hasNext()) {
      SimpleCRLEntry entry=entries.next();
      generator.addCRLEntry(entry.serialNumber,entry.revocationDate,CRLReason.privilegeWithdrawn);
    }
    generator.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(pkiReader.getCACert()));
    generator.addExtension(X509Extensions.CRLNumber,false,new CRLNumber(crlNumber));
    return generator.generate(pkiReader.getCaKey());
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Generate crl.
 * @param entries the entries
 * @param principal the principal
 * @param crlNumber the crl number
 * @return the x509 crl
 */
protected X509CRL generateCRL(Iterator<SimpleCRLEntry> entries,String principal,BigInteger crlNumber){
  try {
    X509V2CRLGenerator generator=new X509V2CRLGenerator();
    generator.setIssuerDN(new X500Principal(principal));
    generator.setThisUpdate(new Date());
    generator.setNextUpdate(Util.tomorrow());
    generator.setSignatureAlgorithm(algorithm);
    while (entries.hasNext()) {
      SimpleCRLEntry entry=entries.next();
      generator.addCRLEntry(entry.serialNumber,entry.revocationDate,CRLReason.privilegeWithdrawn);
    }
    L.info(""String_Node_Str"");
    generator.addExtension(X509Extensions.AuthorityKeyIdentifier,false,new AuthorityKeyIdentifierStructure(pkiReader.getCACert()));
    generator.addExtension(X509Extensions.CRLNumber,false,new CRLNumber(crlNumber));
    return generator.generate(pkiReader.getCaKey());
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
49570,"protected List<SimpleCRLEntry> getNewSerialsToAppendAndSetThemConsumed(){
  List<SimpleCRLEntry> entries=Util.newList();
  List<CertificateSerial> serials=this.certificateSerialCurator.retrieveTobeCollectedSerials();
  for (  CertificateSerial cs : serials) {
    entries.add(new SimpleCRLEntry(cs.getSerial(),cs.getExpiration()));
    cs.setCollected(true);
  }
  this.certificateSerialCurator.saveOrUpdateAll(serials);
  return entries;
}","/** 
 * Gets the new serials to append and set them consumed.
 * @return the new serials to append and set them consumed
 */
protected List<SimpleCRLEntry> getNewSerialsToAppendAndSetThemConsumed(){
  List<SimpleCRLEntry> entries=Util.newList();
  List<CertificateSerial> serials=this.certificateSerialCurator.retrieveTobeCollectedSerials();
  for (  CertificateSerial cs : serials) {
    entries.add(new SimpleCRLEntry(cs.getSerial(),cs.getExpiration()));
    cs.setCollected(true);
  }
  L.info(""String_Node_Str"" + serials.size() + ""String_Node_Str"");
  if (L.isDebugEnabled()) {
    StringBuilder builder=new StringBuilder(""String_Node_Str"");
    for (    CertificateSerial cs : serials) {
      builder.append(cs.getSerial()).append(""String_Node_Str"");
    }
    builder.append(""String_Node_Str"");
    L.debug(""String_Node_Str"" + builder.toString());
  }
  this.certificateSerialCurator.saveOrUpdateAll(serials);
  return entries;
}"
49571,"public void updateCRL(File file,String principal){
  FileInputStream in=null;
  ByteArrayOutputStream stream=new ByteArrayOutputStream();
  try {
    if (file.exists()) {
      in=new FileInputStream(file);
    }
    updateCRL(in,principal,stream);
    FileUtils.writeByteArrayToFile(file,stream.toByteArray());
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Update crl.
 * @param file the file
 * @param principal the principal
 */
public void updateCRL(File file,String principal){
  FileInputStream in=null;
  ByteArrayOutputStream stream=new ByteArrayOutputStream();
  try {
    if (file.exists() && file.length() > 0) {
      L.info(""String_Node_Str"" + file + ""String_Node_Str"");
      in=new FileInputStream(file);
    }
 else {
      L.info(""String_Node_Str"" + file + ""String_Node_Str"");
    }
    updateCRL(in,principal,stream);
    L.info(""String_Node_Str"");
    FileUtils.writeByteArrayToFile(file,stream.toByteArray());
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
49572,"/** 
 * @param serialNumber
 * @param revocationDate
 */
private SimpleCRLEntry(BigInteger serialNumber,Date revocationDate){
  super();
  this.serialNumber=serialNumber;
  this.revocationDate=revocationDate;
}","/** 
 * Instantiates a new simple crl entry.
 * @param serialNumber the serial number
 * @param revocationDate the revocation date
 */
private SimpleCRLEntry(BigInteger serialNumber,Date revocationDate){
  this.serialNumber=serialNumber;
  this.revocationDate=revocationDate;
}"
49573,"/** 
 * @param x509crl
 * @return
 */
protected BigInteger getCRLNumber(X509CRL x509crl){
  if (x509crl == null) {
    return BigInteger.ONE;
  }
  return new BigInteger(getValue(x509crl,""String_Node_Str""));
}","/** 
 * Gets the cRL number.
 * @param x509crl the x509crl
 * @return the cRL number
 */
protected BigInteger getCRLNumber(X509CRL x509crl){
  if (x509crl == null) {
    return BigInteger.ZERO;
  }
  return new BigInteger(getValue(x509crl,""String_Node_Str""));
}"
49574,"@Override public void execute(JobExecutionContext ctx) throws JobExecutionException {
  File crlFile=new File(config.getString(ConfigProperties.CRL_FILE_PATH));
  this.updateCRL(crlFile,""String_Node_Str"");
}","@Override public void execute(JobExecutionContext ctx) throws JobExecutionException {
  String filePath=config.getString(ConfigProperties.CRL_FILE_PATH);
  L.info(""String_Node_Str"" + filePath);
  File crlFile=new File(filePath);
  Principal systemPrincipal=new SystemPrincipal();
  ResteasyProviderFactory.pushContext(Principal.class,systemPrincipal);
  this.updateCRL(crlFile,""String_Node_Str"" + UUID.randomUUID());
  ResteasyProviderFactory.popContextData(Principal.class);
}"
49575,"protected Set<? extends X509CRLEntry> removeExpiredSerials(Set<? extends X509CRLEntry> revokedEntries){
  if (revokedEntries == null || revokedEntries.size() == 0) {
    return revokedEntries;
  }
  Map<BigInteger,X509CRLEntry> map=newMap();
  for (  X509CRLEntry entry : revokedEntries) {
    map.put(entry.getSerialNumber(),entry);
  }
  for (  CertificateSerial cs : this.certificateSerialCurator.getExpiredSerials()) {
    X509CRLEntry entry=map.get(cs.getSerial());
    if (entry != null) {
      revokedEntries.remove(entry);
    }
  }
  return revokedEntries;
}","/** 
 * Removes the expired serials.
 * @param revokedEntries the revoked entries
 * @return the set
 */
protected Set<? extends X509CRLEntry> removeExpiredSerials(Set<? extends X509CRLEntry> revokedEntries){
  if (revokedEntries == null || revokedEntries.size() == 0) {
    return Util.newSet();
  }
  Map<BigInteger,X509CRLEntry> map=newMap();
  for (  X509CRLEntry entry : revokedEntries) {
    map.put(entry.getSerialNumber(),entry);
  }
  for (  CertificateSerial cs : this.certificateSerialCurator.getExpiredSerials()) {
    X509CRLEntry entry=map.get(cs.getSerial());
    if (entry != null) {
      revokedEntries.remove(entry);
      L.info(""String_Node_Str"" + cs.getId() + ""String_Node_Str"");
    }
  }
  return revokedEntries;
}"
49576,"@Override public void configure(){
  bind(JPAInitializer.class).asEagerSingleton();
  bindConstant().annotatedWith(JpaUnit.class).to(""String_Node_Str"");
  bind(X509ExtensionUtil.class);
  bind(Config.class).to(CandlepinCommonTestConfig.class).asEagerSingleton();
  bind(ConsumerResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(ProductServiceAdapter.class).to(DefaultProductServiceAdapter.class);
  bind(ProductResource.class);
  bind(DateSource.class).to(DateSourceForTesting.class).asEagerSingleton();
  bind(Enforcer.class).to(EnforcerForTesting.class);
  bind(PKIUtility.class).to(CandlepinPKIUtility.class);
  bind(PKIReader.class).to(CandlepinPKIReader.class);
  bind(SubscriptionServiceAdapter.class).to(DefaultSubscriptionServiceAdapter.class);
  bind(IdentityCertServiceAdapter.class).to(StubIdentityCertServiceAdapter.class);
  bind(EntitlementCertServiceAdapter.class).to(StubEntitlementCertServiceAdapter.class);
  bind(RulesCurator.class).to(TestRulesCurator.class);
  bind(ScriptEngine.class).toProvider(ScriptEngineProvider.class);
  bind(Reader.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(RulesReaderProvider.class);
  bind(UserServiceAdapter.class).to(ConfigUserServiceAdapter.class);
  bind(I18n.class).toProvider(I18nProvider.class);
  bind(PrincipalProvider.class).to(TestPrincipalProvider.class);
  bind(Principal.class).toProvider(TestPrincipalProvider.class);
  bind(EventSink.class).to(EventSinkForTesting.class);
  SecurityInterceptor se=new SecurityInterceptor();
  requestInjection(se);
  securityInterceptor=new TestingInterceptor(se);
  bindInterceptor(Matchers.inPackage(Package.getPackage(""String_Node_Str"")),Matchers.any(),securityInterceptor);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(AllowRoles.class),securityInterceptor);
  AccessControlInterceptor crud=new AccessControlInterceptor();
  requestInjection(crud);
  crudInterceptor=new TestingInterceptor(crud);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(EnforceAccessControl.class),crudInterceptor);
}","@Override public void configure(){
  bind(JPAInitializer.class).asEagerSingleton();
  bindConstant().annotatedWith(JpaUnit.class).to(""String_Node_Str"");
  bind(X509ExtensionUtil.class);
  bind(Config.class).to(CandlepinCommonTestConfig.class).asEagerSingleton();
  bind(ConsumerResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(ProductServiceAdapter.class).to(DefaultProductServiceAdapter.class);
  bind(ProductResource.class);
  bind(DateSource.class).to(DateSourceForTesting.class).asEagerSingleton();
  bind(Enforcer.class).to(EnforcerForTesting.class);
  bind(PKIUtility.class).to(CandlepinPKIUtility.class);
  bind(PKIReader.class).to(CandlepinPKIReader.class);
  bind(SubscriptionServiceAdapter.class).to(DefaultSubscriptionServiceAdapter.class);
  bind(IdentityCertServiceAdapter.class).to(StubIdentityCertServiceAdapter.class);
  bind(EntitlementCertServiceAdapter.class).to(StubEntitlementCertServiceAdapter.class);
  bind(RulesCurator.class).to(TestRulesCurator.class);
  bind(ScriptEngine.class).toProvider(ScriptEngineProvider.class);
  bind(Reader.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(RulesReaderProvider.class);
  bind(UserServiceAdapter.class).to(ConfigUserServiceAdapter.class);
  bind(I18n.class).toProvider(I18nProvider.class);
  bind(PrincipalProvider.class).to(TestPrincipalProvider.class);
  bind(Principal.class).toProvider(TestPrincipalProvider.class);
  bind(EventSink.class).to(EventSinkForTesting.class);
  SecurityInterceptor se=new SecurityInterceptor();
  requestInjection(se);
  securityInterceptor=new TestingInterceptor(se);
  bindInterceptor(Matchers.inPackage(Package.getPackage(""String_Node_Str"")),Matchers.any(),securityInterceptor);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(AllowRoles.class),securityInterceptor);
  AccessControlInterceptor crud=new AccessControlInterceptor();
  requestInjection(crud);
  crudInterceptor=new TestingInterceptor(crud);
  bindInterceptor(Matchers.subclassesOf(AbstractHibernateCurator.class),Matchers.annotatedWith(EnforceAccessControl.class),crudInterceptor);
  bind(CertificateRevocationListTask.class);
  bind(String.class).annotatedWith(Names.named(""String_Node_Str"")).toInstance(""String_Node_Str"");
}"
49577,"private void exportProducts(File baseDir,Consumer consumer) throws IOException {
  File productDir=new File(baseDir.getCanonicalPath(),""String_Node_Str"");
  productDir.mkdir();
  Map<String,Product> products=new HashMap<String,Product>();
  for (  Entitlement entitlement : consumer.getEntitlements()) {
    for (    String productId : entitlement.getPool().getProvidedProductIds()) {
      if (!products.containsKey(productId)) {
        products.put(productId,productAdapter.getProductById(productId));
      }
    }
  }
  for (  Product product : products.values()) {
    File file=new File(productDir.getCanonicalPath(),product.getId() + ""String_Node_Str"");
    FileWriter writer=new FileWriter(file);
    productExporter.export(mapper,writer,product);
    writer.close();
    if (!product.getAttribute(""String_Node_Str"").equals(""String_Node_Str"")) {
      file=new File(productDir.getCanonicalPath(),product.getId() + ""String_Node_Str"");
      writer=new FileWriter(file);
      productCertExporter.export(writer,productAdapter.getProductCertificate(product));
      writer.close();
    }
  }
}","private void exportProducts(File baseDir,Consumer consumer) throws IOException {
  File productDir=new File(baseDir.getCanonicalPath(),""String_Node_Str"");
  productDir.mkdir();
  Map<String,Product> products=new HashMap<String,Product>();
  for (  Entitlement entitlement : consumer.getEntitlements()) {
    for (    String productId : entitlement.getPool().getProvidedProductIds()) {
      if (!products.containsKey(productId)) {
        products.put(productId,productAdapter.getProductById(productId));
      }
    }
  }
  for (  Product product : products.values()) {
    File file=new File(productDir.getCanonicalPath(),product.getId() + ""String_Node_Str"");
    FileWriter writer=new FileWriter(file);
    productExporter.export(mapper,writer,product);
    writer.close();
    if (!product.getAttributeValue(""String_Node_Str"").equals(""String_Node_Str"")) {
      file=new File(productDir.getCanonicalPath(),product.getId() + ""String_Node_Str"");
      writer=new FileWriter(file);
      productCertExporter.export(writer,productAdapter.getProductCertificate(product));
      writer.close();
    }
  }
}"
49578,"private Entitlement addEntitlement(Consumer consumer,Pool pool,Integer quantity) throws EntitlementRefusedException {
  PreEntHelper preHelper=enforcer.pre(consumer,pool,quantity);
  ValidationResult result=preHelper.getResult();
  if (!result.isSuccessful()) {
    log.warn(""String_Node_Str"" + result.getErrors().toString());
    throw new EntitlementRefusedException(result);
  }
  Entitlement e=new Entitlement(pool,consumer,new Date(),quantity);
  consumer.addEntitlement(e);
  if (preHelper.getGrantFreeEntitlement()) {
    log.info(""String_Node_Str"");
    e.setIsFree(Boolean.TRUE);
  }
 else {
    pool.bumpConsumed();
  }
  postEntHelper.init(e);
  enforcer.post(postEntHelper,e);
  entitlementCurator.create(e);
  consumerCurator.update(consumer);
  Pool mergedPool=epCurator.merge(pool);
  Subscription sub=subAdapter.getSubscription(mergedPool.getSubscriptionId());
  if (sub == null) {
    log.warn(""String_Node_Str"" + pool.getId());
  }
 else {
    try {
      EntitlementCertificate cert=this.entCertAdapter.generateEntitlementCert(consumer,e,sub,sub.getProduct(),sub.getEndDate(),new BigInteger(serialCurator.getNextSerial().toString()));
      e.getCertificates().add(cert);
      this.entCertCurator.create(cert);
    }
 catch (    Exception ex) {
      throw new RuntimeException(ex);
    }
  }
  return e;
}","private Entitlement addEntitlement(Consumer consumer,Pool pool,Integer quantity) throws EntitlementRefusedException {
  PreEntHelper preHelper=enforcer.pre(consumer,pool,quantity);
  ValidationResult result=preHelper.getResult();
  if (!result.isSuccessful()) {
    log.warn(""String_Node_Str"" + result.getErrors().toString());
    throw new EntitlementRefusedException(result);
  }
  Entitlement e=new Entitlement(pool,consumer,new Date(),quantity);
  consumer.addEntitlement(e);
  if (preHelper.getGrantFreeEntitlement()) {
    log.info(""String_Node_Str"");
    e.setIsFree(Boolean.TRUE);
  }
 else {
    pool.bumpConsumed(quantity);
  }
  postEntHelper.init(e);
  enforcer.post(postEntHelper,e);
  entitlementCurator.create(e);
  consumerCurator.update(consumer);
  Pool mergedPool=epCurator.merge(pool);
  Subscription sub=subAdapter.getSubscription(mergedPool.getSubscriptionId());
  if (sub == null) {
    log.warn(""String_Node_Str"" + pool.getId());
  }
 else {
    try {
      EntitlementCertificate cert=this.entCertAdapter.generateEntitlementCert(consumer,e,sub,sub.getProduct(),sub.getEndDate(),new BigInteger(serialCurator.getNextSerial().toString()));
      e.getCertificates().add(cert);
      this.entCertCurator.create(cert);
    }
 catch (    Exception ex) {
      throw new RuntimeException(ex);
    }
  }
  return e;
}"
49579,"@Transactional public void revokeEntitlement(Entitlement entitlement){
  if (!entitlement.isFree()) {
    entitlement.getPool().dockConsumed();
  }
  Consumer consumer=entitlement.getConsumer();
  consumer.removeEntitlement(entitlement);
  Event event=eventFactory.entitlementDeleted(entitlement);
  epCurator.merge(entitlement.getPool());
  entitlementCurator.delete(entitlement);
  sink.sendEvent(event);
}","@Transactional public void revokeEntitlement(Entitlement entitlement){
  if (!entitlement.isFree()) {
    Pool.dockConsumed(entitlement);
  }
  Consumer consumer=entitlement.getConsumer();
  consumer.removeEntitlement(entitlement);
  Event event=eventFactory.entitlementDeleted(entitlement);
  epCurator.merge(entitlement.getPool());
  entitlementCurator.delete(entitlement);
  sink.sendEvent(event);
}"
49580,"/** 
 * Increment consumed quantity by one.
 */
public void bumpConsumed(){
  this.consumed++;
}","public void bumpConsumed(int quantity){
  consumed+=quantity;
}"
49581,"public void dockConsumed(){
  this.consumed--;
}","public static void dockConsumed(Entitlement e){
  e.getPool().dockConsumed(e.getQuantity());
}"
49582,"@Test public void testGetSerialFiltering(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  List<EntitlementCertificate> serials=consumerResource.getEntitlementCertificates(consumer.getUuid(),null);
  assertEquals(4,serials.size());
  BigInteger serial1=serials.get(0).getSerial();
  BigInteger serial2=serials.get(3).getSerial();
  String serialsToFilter=serial1.toString() + ""String_Node_Str"" + serial2.toString();
  serials=consumerResource.getEntitlementCertificates(consumer.getUuid(),serialsToFilter);
  assertEquals(2,serials.size());
  assertEquals(serial1,serials.get(0).getSerial());
  assertEquals(serial2,serials.get(1).getSerial());
}","@Test public void testGetSerialFiltering(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  List<EntitlementCertificate> serials=consumerResource.getEntitlementCertificates(consumer.getUuid(),null);
  assertEquals(4,serials.size());
  BigInteger serial1=serials.get(0).getSerial();
  BigInteger serial2=serials.get(3).getSerial();
  String serialsToFilter=serial1.toString() + ""String_Node_Str"" + serial2.toString();
  serials=consumerResource.getEntitlementCertificates(consumer.getUuid(),serialsToFilter);
  assertEquals(2,serials.size());
  assertEquals(serial1,serials.get(0).getSerial());
  assertEquals(serial2,serials.get(1).getSerial());
}"
49583,"@Test public void bindByTokenPreExistingSubscription(){
  setupPrincipal(owner,Role.CONSUMER);
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Subscription sub=TestUtil.createSubscription(owner,prod);
  SubscriptionToken token=TestUtil.createSubscriptionToken();
  token.setSubscription(sub);
  subCurator.create(sub);
  subTokenCurator.create(token);
  poolCurator.refreshPools(owner);
  List<Pool> pools=poolCurator.listByOwnerAndProduct(owner,prod.getId());
  assertEquals(1,pools.size());
  List<Entitlement> ents=consumerResource.bind(consumer.getUuid(),null,token.getToken(),null,null,null,null);
  assertEquals(1,ents.size());
  assertEquals(sub.getId(),ents.get(0).getPool().getSubscriptionId());
  assertEquals(1,poolCurator.listByOwnerAndProduct(owner,prod.getId()).size());
}","@Test public void bindByTokenPreExistingSubscription(){
  setupPrincipal(owner,Role.CONSUMER);
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Subscription sub=TestUtil.createSubscription(owner,prod);
  SubscriptionToken token=TestUtil.createSubscriptionToken();
  token.setSubscription(sub);
  subCurator.create(sub);
  subTokenCurator.create(token);
  poolCurator.refreshPools(owner);
  List<Pool> pools=poolCurator.listByOwnerAndProduct(owner,prod.getId());
  assertEquals(1,pools.size());
  List<Entitlement> ents=consumerResource.bind(consumer.getUuid(),null,token.getToken(),null,1,null,null);
  assertEquals(1,ents.size());
  assertEquals(sub.getId(),ents.get(0).getPool().getSubscriptionId());
  assertEquals(1,poolCurator.listByOwnerAndProduct(owner,prod.getId()).size());
}"
49584,"@Test public void testCanGetOwnedConsumersCerts(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  setupPrincipal(new ConsumerPrincipal(consumer));
  assertEquals(3,consumerResource.getEntitlementCertificates(consumer.getUuid(),null).size());
}","@Test public void testCanGetOwnedConsumersCerts(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  setupPrincipal(new ConsumerPrincipal(consumer));
  assertEquals(3,consumerResource.getEntitlementCertificates(consumer.getUuid(),null).size());
}"
49585,"@Test public void unbindBySerialWithExistingCertificateShouldPass(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  List<EntitlementCertificate> serials=consumerResource.getEntitlementCertificates(consumer.getUuid(),null);
  assertEquals(1,serials.size());
  consumerResource.unbindBySerial(consumer.getUuid(),serials.get(0).getSerial().longValue());
  assertEquals(0,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}","@Test public void unbindBySerialWithExistingCertificateShouldPass(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  List<EntitlementCertificate> serials=consumerResource.getEntitlementCertificates(consumer.getUuid(),null);
  assertEquals(1,serials.size());
  consumerResource.unbindBySerial(consumer.getUuid(),serials.get(0).getSerial().longValue());
  assertEquals(0,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}"
49586,"@Test public void consumerShouldNotSeeAnotherConsumersEntitlements(){
  Consumer evilConsumer=TestUtil.createConsumer(standardSystemType,owner);
  consumerCurator.create(evilConsumer);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(evilConsumer.getUuid(),pool.getId(),null,null,null,null,null);
  setupPrincipal(new ConsumerPrincipal(evilConsumer));
  securityInterceptor.enable();
  crudInterceptor.enable();
  assertEquals(0,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}","@Test public void consumerShouldNotSeeAnotherConsumersEntitlements(){
  Consumer evilConsumer=TestUtil.createConsumer(standardSystemType,owner);
  consumerCurator.create(evilConsumer);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(evilConsumer.getUuid(),pool.getId(),null,null,1,null,null);
  setupPrincipal(new ConsumerPrincipal(evilConsumer));
  securityInterceptor.enable();
  crudInterceptor.enable();
  assertEquals(0,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}"
49587,"@Test public void testBindByPool() throws Exception {
  List<Entitlement> resultList=consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumer=consumerCurator.lookupByUuid(consumer.getUuid());
  assertEquals(1,consumer.getEntitlements().size());
  pool=poolCurator.find(pool.getId());
  assertEquals(new Long(1),pool.getConsumed());
  assertEquals(1,resultList.size());
  assertEquals(pool.getId(),resultList.get(0).getPool().getId());
  assertEquals(1,entCertCurator.listForEntitlement(resultList.get(0)).size());
}","@Test public void testBindByPool() throws Exception {
  List<Entitlement> resultList=consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumer=consumerCurator.lookupByUuid(consumer.getUuid());
  assertEquals(1,consumer.getEntitlements().size());
  pool=poolCurator.find(pool.getId());
  assertEquals(new Long(1),pool.getConsumed());
  assertEquals(1,resultList.size());
  assertEquals(pool.getId(),resultList.get(0).getPool().getId());
  assertEquals(1,entCertCurator.listForEntitlement(resultList.get(0)).size());
}"
49588,"@Test public void testGetCerts(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  List<EntitlementCertificate> serials=consumerResource.getEntitlementCertificates(consumer.getUuid(),null);
  assertEquals(1,serials.size());
}","@Test public void testGetCerts(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  List<EntitlementCertificate> serials=consumerResource.getEntitlementCertificates(consumer.getUuid(),null);
  assertEquals(1,serials.size());
}"
49589,"@Test public void testCannotGetAnotherConsumersCerts(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  Consumer evilConsumer=TestUtil.createConsumer(standardSystemType,owner);
  consumerCurator.create(evilConsumer);
  setupPrincipal(new ConsumerPrincipal(evilConsumer));
  securityInterceptor.enable();
  crudInterceptor.enable();
  assertEquals(0,consumerResource.getEntitlementCertificates(consumer.getUuid(),null).size());
}","@Test public void testCannotGetAnotherConsumersCerts(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  Consumer evilConsumer=TestUtil.createConsumer(standardSystemType,owner);
  consumerCurator.create(evilConsumer);
  setupPrincipal(new ConsumerPrincipal(evilConsumer));
  securityInterceptor.enable();
  crudInterceptor.enable();
  assertEquals(0,consumerResource.getEntitlementCertificates(consumer.getUuid(),null).size());
}"
49590,"@Test public void testEntitle() throws Exception {
  consumerResource.bind(consumer.getUuid(),null,null,product.getId(),null,null,null);
  consumer=consumerCurator.lookupByUuid(consumer.getUuid());
  assertEquals(1,consumer.getEntitlements().size());
  pool=poolCurator.find(pool.getId());
  assertEquals(new Long(1),pool.getConsumed());
}","@Test public void testEntitle() throws Exception {
  consumerResource.bind(consumer.getUuid(),null,null,product.getId(),1,null,null);
  consumer=consumerCurator.lookupByUuid(consumer.getUuid());
  assertEquals(1,consumer.getEntitlements().size());
  pool=poolCurator.find(pool.getId());
  assertEquals(new Long(1),pool.getConsumed());
}"
49591,"@Test public void bindByTokenNewSubscription(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Subscription sub=TestUtil.createSubscription(owner,prod);
  SubscriptionToken token=TestUtil.createSubscriptionToken();
  token.setSubscription(sub);
  subCurator.create(sub);
  subTokenCurator.create(token);
  assertEquals(0,poolCurator.listByOwnerAndProduct(owner,prod.getId()).size());
  consumerResource.bind(consumer.getUuid(),null,token.getToken(),null,null,null,null);
  assertEquals(1,poolCurator.listByOwnerAndProduct(owner,prod.getId()).size());
}","@Test public void bindByTokenNewSubscription(){
  Product prod=TestUtil.createProduct();
  productCurator.create(prod);
  Subscription sub=TestUtil.createSubscription(owner,prod);
  SubscriptionToken token=TestUtil.createSubscriptionToken();
  token.setSubscription(sub);
  subCurator.create(sub);
  subTokenCurator.create(token);
  assertEquals(0,poolCurator.listByOwnerAndProduct(owner,prod.getId()).size());
  consumerResource.bind(consumer.getUuid(),null,token.getToken(),null,1,null,null);
  assertEquals(1,poolCurator.listByOwnerAndProduct(owner,prod.getId()).size());
}"
49592,"@Test public void testGetCertSerials(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  List<CertificateSerialDto> serials=consumerResource.getEntitlementCertificateSerials(consumer.getUuid());
  assertEquals(1,serials.size());
}","@Test public void testGetCertSerials(){
  Consumer consumer=createConsumer();
  List<EntitlementCertificate> certificates=createEntitlementCertificates();
  when(mockedEntitlementCertServiceAdapter.listForConsumer(consumer)).thenReturn(certificates);
  when(mockedConsumerCurator.lookupByUuid(consumer.getUuid())).thenReturn(consumer);
  ConsumerResource consumerResource=new ConsumerResource(mockedConsumerCurator,null,null,null,null,null,null,null,mockedEntitlementCertServiceAdapter,null,null,null,null,null);
  List<CertificateSerialDto> serials=consumerResource.getEntitlementCertificateSerials(consumer.getUuid());
  verifyCertificateSerialNumbers(serials);
}"
49593,"@Test public void consumerShouldSeeOwnEntitlements(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  setupPrincipal(new ConsumerPrincipal(consumer));
  securityInterceptor.enable();
  crudInterceptor.enable();
  assertEquals(3,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}","@Test public void consumerShouldSeeOwnEntitlements(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  setupPrincipal(new ConsumerPrincipal(consumer));
  securityInterceptor.enable();
  crudInterceptor.enable();
  assertEquals(3,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}"
49594,"@Test public void ownerShouldNotSeeOtherOwnerEntitlements(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  Owner evilOwner=ownerCurator.create(new Owner(""String_Node_Str""));
  ownerCurator.create(evilOwner);
  securityInterceptor.enable();
  crudInterceptor.enable();
  setupPrincipal(evilOwner,Role.OWNER_ADMIN);
  assertEquals(0,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}","@Test public void ownerShouldNotSeeOtherOwnerEntitlements(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  Owner evilOwner=ownerCurator.create(new Owner(""String_Node_Str""));
  ownerCurator.create(evilOwner);
  securityInterceptor.enable();
  crudInterceptor.enable();
  setupPrincipal(evilOwner,Role.OWNER_ADMIN);
  assertEquals(0,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}"
49595,"@Test public void ownerShouldSeeOwnEntitlements(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,null,null,null);
  securityInterceptor.enable();
  crudInterceptor.enable();
  setupPrincipal(owner,Role.OWNER_ADMIN);
  assertEquals(3,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}","@Test public void ownerShouldSeeOwnEntitlements(){
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  consumerResource.bind(consumer.getUuid(),pool.getId(),null,null,1,null,null);
  securityInterceptor.enable();
  crudInterceptor.enable();
  setupPrincipal(owner,Role.OWNER_ADMIN);
  assertEquals(3,consumerResource.listEntitlements(consumer.getUuid(),null).size());
}"
49596,"Principal getPrincipal(HttpRequest request) throws Exception {
  List<String> header=request.getHttpHeaders().getRequestHeader(""String_Node_Str"");
  String auth=null;
  if (null != header && header.size() > 0) {
    auth=header.get(0);
  }
  if (auth != null && auth.toUpperCase().startsWith(""String_Node_Str"")) {
    String userpassEncoded=auth.substring(6);
    String[] userpass=new String(Base64.decodeBase64(userpassEncoded)).split(""String_Node_Str"");
    String username=userpass[0];
    String password=userpass[1];
    log.debug(""String_Node_Str"" + username + ""String_Node_Str""+ password);
    if (userServiceAdapter.validateUser(username,password)) {
      Principal principal=createPrincipal(username);
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + principal.getOwner().getDisplayName() + ""String_Node_Str""+ username+ ""String_Node_Str"");
      }
      return principal;
    }
  }
  return null;
}","Principal getPrincipal(HttpRequest request) throws Exception {
  List<String> header=request.getHttpHeaders().getRequestHeader(""String_Node_Str"");
  String auth=null;
  if (null != header && header.size() > 0) {
    auth=header.get(0);
  }
  if (auth != null && auth.toUpperCase().startsWith(""String_Node_Str"")) {
    String userpassEncoded=auth.substring(6);
    String[] userpass=new String(Base64.decodeBase64(userpassEncoded)).split(""String_Node_Str"");
    String username=userpass[0];
    String password=userpass[1];
    log.debug(""String_Node_Str"" + username + ""String_Node_Str""+ password.length()+ ""String_Node_Str"");
    if (userServiceAdapter.validateUser(username,password)) {
      Principal principal=createPrincipal(username);
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + principal.getOwner().getDisplayName() + ""String_Node_Str""+ username+ ""String_Node_Str"");
      }
      return principal;
    }
  }
  return null;
}"
49597,"/** 
 * Check if this pool provides the given product ID.
 * @param productId
 * @return
 */
public Boolean provides(String productId){
  if (this.productId == productId) {
    return true;
  }
  return this.providedProductIds.contains(productId);
}","/** 
 * Check if this pool provides the given product ID.
 * @param productId
 * @return
 */
public Boolean provides(String productId){
  if (this.productId.equals(productId)) {
    return true;
  }
  return this.providedProductIds.contains(productId);
}"
49598,"public String toString(){
  return ""String_Node_Str"" + getId() + ""String_Node_Str""+ owner.getId()+ ""String_Node_Str""+ getProvidedProductIds()+ ""String_Node_Str""+ getSubscriptionId()+ ""String_Node_Str""+ getQuantity()+ ""String_Node_Str""+ getEndDate()+ ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + getId() + ""String_Node_Str""+ owner.getId()+ ""String_Node_Str""+ productId+ ""String_Node_Str""+ getProvidedProductIds()+ ""String_Node_Str""+ getSubscriptionId()+ ""String_Node_Str""+ getQuantity()+ ""String_Node_Str""+ getEndDate()+ ""String_Node_Str"";
}"
49599,"/** 
 * List entitlement pools. Pools will be refreshed from the underlying subscription service. If a consumer is specified, a pass through the rules will be done for each potentially usable pool.
 * @param c
 * @param o
 * @param productId
 * @param activeOnly
 * @return
 */
@SuppressWarnings(""String_Node_Str"") @Transactional private List<Pool> listAvailableEntitlementPools(Consumer c,Owner o,String productId,boolean activeOnly){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
    log.debug(""String_Node_Str"" + c);
    log.debug(""String_Node_Str"" + o);
    log.debug(""String_Node_Str"" + productId);
  }
  List<Pool> results=null;
  Criteria crit=currentSession().createCriteria(Pool.class);
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
  }
  crit.add(Restrictions.lt(""String_Node_Str"",new Date()));
  crit.add(Restrictions.gt(""String_Node_Str"",new Date()));
  results=crit.list();
  if (results == null) {
    log.debug(""String_Node_Str"");
    return new ArrayList<Pool>();
  }
  if (productId != null) {
    List<Pool> newResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      if (p.provides(productId)) {
        newResults.add(p);
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + productId + ""String_Node_Str""+ p);
        }
      }
    }
    results=newResults;
  }
  addProductNames(results);
  if (c != null) {
    List<Pool> newResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      PreEntHelper helper=enforcer.pre(c,p,new Integer(1));
      if (helper.getResult().isSuccessful() && !helper.getResult().hasWarnings()) {
        newResults.add(p);
      }
 else {
        log.info(""String_Node_Str"" + p.getId());
        log.info(helper.getResult().getErrors());
        log.info(helper.getResult().getWarnings());
      }
    }
    results=newResults;
  }
  return results;
}","/** 
 * List entitlement pools. Pools will be refreshed from the underlying subscription service. If a consumer is specified, a pass through the rules will be done for each potentially usable pool.
 * @param c
 * @param o
 * @param productId
 * @param activeOnly
 * @return
 */
@SuppressWarnings(""String_Node_Str"") @Transactional private List<Pool> listAvailableEntitlementPools(Consumer c,Owner o,String productId,boolean activeOnly){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
    log.debug(""String_Node_Str"" + c);
    log.debug(""String_Node_Str"" + o);
    log.debug(""String_Node_Str"" + productId);
  }
  List<Pool> results=null;
  Criteria crit=currentSession().createCriteria(Pool.class);
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
  }
  crit.add(Restrictions.lt(""String_Node_Str"",new Date()));
  crit.add(Restrictions.gt(""String_Node_Str"",new Date()));
  results=crit.list();
  log.debug(""String_Node_Str"" + results.size());
  if (results == null) {
    log.debug(""String_Node_Str"");
    return new ArrayList<Pool>();
  }
  if (productId != null) {
    List<Pool> newResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      if (p.provides(productId)) {
        newResults.add(p);
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + productId + ""String_Node_Str""+ p);
        }
      }
    }
    results=newResults;
  }
  addProductNames(results);
  if (c != null) {
    List<Pool> newResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      PreEntHelper helper=enforcer.pre(c,p,new Integer(1));
      if (helper.getResult().isSuccessful() && !helper.getResult().hasWarnings()) {
        newResults.add(p);
      }
 else {
        log.info(""String_Node_Str"" + p.getId());
        log.info(helper.getResult().getErrors());
        log.info(helper.getResult().getWarnings());
      }
    }
    results=newResults;
  }
  return results;
}"
49600,"@SuppressWarnings(""String_Node_Str"") public List<Pool> listAvailableEntitlementPools(Consumer c,Owner o,String productId,boolean activeOnly){
  List<Pool> results=null;
  Criteria crit=currentSession().createCriteria(Pool.class);
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
  }
  if (productId != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",productId));
  }
  crit.add(Restrictions.lt(""String_Node_Str"",new Date()));
  crit.add(Restrictions.gt(""String_Node_Str"",new Date()));
  results=(List<Pool>)crit.list();
  if (results == null) {
    results=new ArrayList<Pool>();
  }
  if (c != null) {
    List<Pool> finalResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      PreEntHelper helper=enforcer.pre(c,p);
      if (helper.getResult().isSuccessful()) {
        finalResults.add(p);
      }
 else {
        log.info(""String_Node_Str"" + p.getId());
        log.info(helper.getResult().getErrors());
      }
    }
    return finalResults;
  }
  return results;
}","@SuppressWarnings(""String_Node_Str"") public List<Pool> listAvailableEntitlementPools(Consumer c,Owner o,String productId,boolean activeOnly){
  log.debug(""String_Node_Str"");
  log.debug(""String_Node_Str"" + c);
  log.debug(""String_Node_Str"" + o);
  log.debug(""String_Node_Str"" + productId);
  List<Pool> results=null;
  Criteria crit=currentSession().createCriteria(Pool.class);
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
  }
  if (productId != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",productId));
  }
  crit.add(Restrictions.lt(""String_Node_Str"",new Date()));
  crit.add(Restrictions.gt(""String_Node_Str"",new Date()));
  results=(List<Pool>)crit.list();
  if (results == null) {
    log.debug(""String_Node_Str"");
    results=new ArrayList<Pool>();
  }
  if (c != null) {
    List<Pool> finalResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      PreEntHelper helper=enforcer.pre(c,p);
      if (helper.getResult().isSuccessful()) {
        finalResults.add(p);
      }
 else {
        log.info(""String_Node_Str"" + p.getId());
        log.info(helper.getResult().getErrors());
      }
    }
    return finalResults;
  }
  return results;
}"
49601,"/** 
 * Before executing any entitlement pool query, check our underlying subscription service and update the pool data. Must be careful to call this before we do any pool query. Note that refreshing the pools doesn't actually take any action, should a subscription be reduced, expired, or revoked. Pre-existing entitlements will need to be dealt with separately from this event.
 * @param owner Owner to be refreshed.
 * @param productId Products to refresh.
 */
private void refreshPools(Owner owner,String productId){
  List<Subscription> subs=subAdapter.getSubscriptions(owner,productId);
  List<Pool> pools=listByOwnerAndProductNoRefresh(owner,productId);
  Map<Long,Pool> subToPoolMap=new HashMap<Long,Pool>();
  for (  Pool p : pools) {
    if (p.getSubscriptionId() != null) {
      subToPoolMap.put(p.getSubscriptionId(),p);
    }
  }
  for (  Subscription sub : subs) {
    if (!subToPoolMap.containsKey(sub.getId())) {
      Pool newPool=new Pool(owner,productId,sub.getQuantity(),sub.getStartDate(),sub.getEndDate());
      newPool.setSubscriptionId(sub.getId());
      create(newPool);
      subToPoolMap.remove(sub.getId());
    }
 else {
      Pool existingPool=subToPoolMap.get(sub.getId());
      existingPool.setQuantity(sub.getQuantity());
      existingPool.setStartDate(sub.getStartDate());
      existingPool.setEndDate(sub.getEndDate());
      merge(existingPool);
    }
  }
  for (  Entry<Long,Pool> entry : subToPoolMap.entrySet()) {
    entry.getValue().setActiveSubscription(Boolean.FALSE);
    merge(entry.getValue());
  }
}","/** 
 * Before executing any entitlement pool query, check our underlying subscription service and update the pool data. Must be careful to call this before we do any pool query. Note that refreshing the pools doesn't actually take any action, should a subscription be reduced, expired, or revoked. Pre-existing entitlements will need to be dealt with separately from this event.
 * @param owner Owner to be refreshed.
 * @param productId Products to refresh.
 */
private void refreshPools(Owner owner,String productId){
  log.debug(""String_Node_Str"");
  List<Subscription> subs=subAdapter.getSubscriptions(owner,productId);
  List<Pool> pools=listByOwnerAndProductNoRefresh(owner,productId);
  Map<Long,Pool> subToPoolMap=new HashMap<Long,Pool>();
  for (  Pool p : pools) {
    if (p.getSubscriptionId() != null) {
      subToPoolMap.put(p.getSubscriptionId(),p);
    }
  }
  for (  Subscription sub : subs) {
    if (!subToPoolMap.containsKey(sub.getId())) {
      log.debug(""String_Node_Str"" + sub.getId());
      Pool newPool=new Pool(owner,productId,sub.getQuantity(),sub.getStartDate(),sub.getEndDate());
      newPool.setSubscriptionId(sub.getId());
      create(newPool);
      subToPoolMap.remove(sub.getId());
    }
 else {
      log.debug(""String_Node_Str"" + sub.getId());
      Pool existingPool=subToPoolMap.get(sub.getId());
      existingPool.setQuantity(sub.getQuantity());
      existingPool.setStartDate(sub.getStartDate());
      existingPool.setEndDate(sub.getEndDate());
      merge(existingPool);
      subToPoolMap.remove(sub.getId());
    }
  }
  for (  Entry<Long,Pool> entry : subToPoolMap.entrySet()) {
    log.debug(""String_Node_Str"" + entry.getValue());
    entry.getValue().setActiveSubscription(Boolean.FALSE);
    merge(entry.getValue());
  }
}"
49602,"/** 
 * default constructor
 */
@Inject public ConsumerIdentityCertificateCurator(CertificateServiceAdapter certServiceAdapter){
  super(ConsumerIdentityCertificate.class);
  this.certServiceAdapter=certServiceAdapter;
}","/** 
 * default constructor
 */
@Inject public ConsumerIdentityCertificateCurator(){
  super(ConsumerIdentityCertificate.class);
}"
49603,"/** 
 * Create a Consumer
 * @param in Consumer metadata encapsulated in a ConsumerInfo.
 * @return newly created Consumer
 * @throws BadRequestException generic exception type for web services We are calling this ""registerConsumer"" in the api discussions
 */
@POST @Consumes({MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Consumer create(Consumer in) throws BadRequestException {
  Owner owner=ownerCurator.findAll().get(0);
  Consumer consumer=new Consumer();
  log.debug(""String_Node_Str"" + in.getType().getLabel());
  ConsumerType type=consumerTypeCurator.lookupByLabel(in.getType().getLabel());
  log.debug(""String_Node_Str"");
  log.debug(in.getFacts().getMetadata());
  for (  String key : in.getFacts().getMetadata().keySet()) {
    log.debug(""String_Node_Str"" + key + ""String_Node_Str""+ in.getFact(key));
  }
  if (type == null) {
    throw new BadRequestException(""String_Node_Str"" + in.getType().getLabel());
  }
  try {
    consumer=consumerCurator.create(new Consumer(in,owner,type));
    ConsumerIdentityCertificate idCert=identityCertService.generateIdentityCert(consumer,this.username);
    log.debug(""String_Node_Str"" + idCert);
    if (idCert == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    ConsumerIdentityCertificate idCert=consumerIdCertCurator.getCert(consumer);
    consumer.setIdCert(idCert);
    return consumer;
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new BadRequestException(e.getMessage());
  }
}","/** 
 * Create a Consumer
 * @param in Consumer metadata encapsulated in a ConsumerInfo.
 * @return newly created Consumer
 * @throws BadRequestException generic exception type for web services We are calling this ""registerConsumer"" in the api discussions
 */
@POST @Consumes({MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Consumer create(Consumer in) throws BadRequestException {
  Owner owner=ownerCurator.findAll().get(0);
  Consumer consumer=new Consumer();
  log.debug(""String_Node_Str"" + in.getType().getLabel());
  ConsumerType type=consumerTypeCurator.lookupByLabel(in.getType().getLabel());
  log.debug(""String_Node_Str"");
  log.debug(in.getFacts().getMetadata());
  for (  String key : in.getFacts().getMetadata().keySet()) {
    log.debug(""String_Node_Str"" + key + ""String_Node_Str""+ in.getFact(key));
  }
  if (type == null) {
    throw new BadRequestException(""String_Node_Str"" + in.getType().getLabel());
  }
  try {
    consumer=consumerCurator.create(new Consumer(in,owner,type));
    ConsumerIdentityCertificate idCert=identityCertService.generateIdentityCert(consumer,this.username);
    log.debug(""String_Node_Str"" + idCert);
    if (idCert == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    consumer.setIdCert(idCert);
    return consumer;
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new BadRequestException(e.getMessage());
  }
}"
49604,"@Override public void configure(){
  bind(JPAInitializer.class).asEagerSingleton();
  bindConstant().annotatedWith(JpaUnit.class).to(""String_Node_Str"");
  bind(CertificateResource.class);
  bind(ConsumerResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(ProductServiceAdapter.class).to(DefaultProductServiceAdapter.class);
  bind(ProductResource.class);
  bind(TestResource.class);
  bind(DateSource.class).to(DateSourceForTesting.class).asEagerSingleton();
  bind(Enforcer.class).to(JavascriptEnforcer.class);
  bind(BouncyCastlePKI.class);
  bind(SubscriptionServiceAdapter.class).to(DefaultSubscriptionServiceAdapter.class);
  bind(IdentityCertServiceAdapter.class).to(StubIdentityCertServiceAdapter.class);
  bind(Config.class);
  bind(CertificateServiceAdapter.class).to(DefaultCertificateServiceAdapter.class);
  bind(RulesCurator.class).to(TestRulesCurator.class);
  bind(ScriptEngine.class).toProvider(ScriptEngineProvider.class);
  bind(Reader.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(RulesReaderProvider.class);
}","@Override public void configure(){
  bind(JPAInitializer.class).asEagerSingleton();
  bindConstant().annotatedWith(JpaUnit.class).to(""String_Node_Str"");
  bind(CertificateResource.class);
  bind(ConsumerResource.class);
  bind(PoolResource.class);
  bind(EntitlementResource.class);
  bind(OwnerResource.class);
  bind(ProductServiceAdapter.class).to(DefaultProductServiceAdapter.class);
  bind(ProductResource.class);
  bind(TestResource.class);
  bind(DateSource.class).to(DateSourceForTesting.class).asEagerSingleton();
  bind(Enforcer.class).to(JavascriptEnforcer.class);
  bind(BouncyCastlePKI.class);
  bind(SubscriptionServiceAdapter.class).to(DefaultSubscriptionServiceAdapter.class);
  bind(IdentityCertServiceAdapter.class).to(StubIdentityCertServiceAdapter.class);
  bind(Config.class);
  bind(EntitlementCertServiceAdapter.class).to(DefaultEntitlementCertServiceAdapter.class);
  bind(RulesCurator.class).to(TestRulesCurator.class);
  bind(ScriptEngine.class).toProvider(ScriptEngineProvider.class);
  bind(Reader.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(RulesReaderProvider.class);
}"
49605,"/** 
 * we generate a certificate signed by our CA's intermediate certficate
 * @param name Name on certificate
 * @param email on certificate
 * @param pubKey public key
 * @param caPrivKey ca private key
 * @param caPubKey ca public key
 * @throws Exception thrown in the event of an error.
 * @return X.509 Certificate
 */
public static X509Certificate createClientCert(String name,String email,PublicKey pubKey,PrivateKey caPrivKey,PublicKey caPubKey) throws Exception {
  String issuer=""String_Node_Str"";
  Hashtable<DERObjectIdentifier,Object> attrs=new Hashtable<DERObjectIdentifier,Object>();
  Vector<DERObjectIdentifier> order=new Vector<DERObjectIdentifier>();
  attrs.put(X509Principal.C,""String_Node_Str"");
  attrs.put(X509Principal.O,""String_Node_Str"");
  attrs.put(X509Principal.L,""String_Node_Str"");
  attrs.put(X509Principal.CN,name);
  attrs.put(X509Principal.EmailAddress,email);
  order.addElement(X509Principal.C);
  order.addElement(X509Principal.O);
  order.addElement(X509Principal.L);
  order.addElement(X509Principal.CN);
  order.addElement(X509Principal.EmailAddress);
  v3CertGen.reset();
  v3CertGen.setSerialNumber(BigInteger.valueOf(20));
  v3CertGen.setIssuerDN(new X509Principal(issuer));
  v3CertGen.setNotBefore(new Date(System.currentTimeMillis() - 1000L * 60 * 60* 24* 30));
  v3CertGen.setNotAfter(new Date(System.currentTimeMillis() + (1000L * 60 * 60* 24* 30)));
  v3CertGen.setSubjectDN(new X509Principal(order,attrs));
  v3CertGen.setPublicKey(pubKey);
  v3CertGen.setSignatureAlgorithm(""String_Node_Str"");
  new NetscapeCertType(NetscapeCertType.PRINTABLE_STRING);
  GeneralNames altnames=new GeneralNames(new GeneralName(GeneralName.rfc822Name,""String_Node_Str""));
  v3CertGen.addExtension(X509Extensions.SubjectAlternativeName,false,altnames);
  X509Certificate cert=v3CertGen.generate(caPrivKey);
  cert.checkValidity(new Date());
  cert.verify(caPubKey);
  return cert;
}","/** 
 * we generate a certificate signed by our CA's intermediate certficate
 * @param name Name on certificate
 * @param email on certificate
 * @param pubKey public key
 * @param caPrivKey ca private key
 * @param caPubKey ca public key
 * @throws Exception thrown in the event of an error.
 * @return X.509 Certificate
 */
public static X509Certificate createClientCert(String name,String email,PublicKey pubKey,PrivateKey caPrivKey,PublicKey caPubKey) throws Exception {
  String issuer=""String_Node_Str"" + ""String_Node_Str"";
  Hashtable<DERObjectIdentifier,Object> attrs=new Hashtable<DERObjectIdentifier,Object>();
  Vector<DERObjectIdentifier> order=new Vector<DERObjectIdentifier>();
  attrs.put(X509Principal.C,""String_Node_Str"");
  attrs.put(X509Principal.O,""String_Node_Str"");
  attrs.put(X509Principal.L,""String_Node_Str"");
  attrs.put(X509Principal.CN,name);
  attrs.put(X509Principal.EmailAddress,email);
  order.addElement(X509Principal.C);
  order.addElement(X509Principal.O);
  order.addElement(X509Principal.L);
  order.addElement(X509Principal.CN);
  order.addElement(X509Principal.EmailAddress);
  v3CertGen.reset();
  v3CertGen.setSerialNumber(BigInteger.valueOf(20));
  v3CertGen.setIssuerDN(new X509Principal(issuer));
  v3CertGen.setNotBefore(new Date(System.currentTimeMillis() - 1000L * 60 * 60* 24* 30));
  v3CertGen.setNotAfter(new Date(System.currentTimeMillis() + (1000L * 60 * 60* 24* 30)));
  v3CertGen.setSubjectDN(new X509Principal(order,attrs));
  v3CertGen.setPublicKey(pubKey);
  v3CertGen.setSignatureAlgorithm(""String_Node_Str"");
  new NetscapeCertType(NetscapeCertType.PRINTABLE_STRING);
  GeneralNames altnames=new GeneralNames(new GeneralName(GeneralName.rfc822Name,""String_Node_Str""));
  v3CertGen.addExtension(X509Extensions.SubjectAlternativeName,false,altnames);
  X509Certificate cert=v3CertGen.generate(caPrivKey);
  cert.checkValidity(new Date());
  cert.verify(caPubKey);
  return cert;
}"
49606,"/** 
 * returns certificate string
 * @return certificate string
 */
public static X509Certificate genCert(){
  X509Certificate retval=null;
  Security.addProvider(new BouncyCastleProvider());
  RSAPublicKeySpec pubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPublicKeySpec caPubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPrivateCrtKeySpec caPrivKeySpec=new RSAPrivateCrtKeySpec(new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16));
  try {
    KeyFactory fact=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
    PrivateKey caPrivKey=fact.generatePrivate(caPrivKeySpec);
    PublicKey caPubKey=fact.generatePublic(caPubKeySpec);
    PublicKey pubKey=fact.generatePublic(pubKeySpec);
    X509Certificate clientCert=createClientCert(""String_Node_Str"",""String_Node_Str"",pubKey,caPrivKey,caPubKey);
    retval=clientCert;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return retval;
}","/** 
 * returns certificate string
 * @return certificate string
 */
public static X509Certificate genCert(){
  X509Certificate retval=null;
  Security.addProvider(new BouncyCastleProvider());
  RSAPublicKeySpec pubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPublicKeySpec caPubKeySpec=new RSAPublicKeySpec(new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16));
  RSAPrivateCrtKeySpec caPrivKeySpec=new RSAPrivateCrtKeySpec(new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",16),new BigInteger(""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16),new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",16));
  try {
    KeyFactory fact=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
    PrivateKey caPrivKey=fact.generatePrivate(caPrivKeySpec);
    PublicKey caPubKey=fact.generatePublic(caPubKeySpec);
    PublicKey pubKey=fact.generatePublic(pubKeySpec);
    X509Certificate clientCert=createClientCert(""String_Node_Str"",""String_Node_Str"",pubKey,caPrivKey,caPubKey);
    retval=clientCert;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return retval;
}"
49607,"@Override public ConsumerIdentityCertificate generateIdentityCert(Consumer consumer){
  ConsumerIdentityCertificate idCert=new ConsumerIdentityCertificate();
  idCert.setId(43l);
  idCert.setKey(""String_Node_Str"".getBytes());
  idCert.setPem(""String_Node_Str"".getBytes());
  return idCert;
}","@Override public ConsumerIdentityCertificate generateIdentityCert(Consumer consumer){
  ConsumerIdentityCertificate idCert=new ConsumerIdentityCertificate();
  idCert.setId(43L);
  idCert.setKey(""String_Node_Str"".getBytes());
  idCert.setPem(""String_Node_Str"".getBytes());
  return idCert;
}"
49608,"@SuppressWarnings(""String_Node_Str"") public List<Pool> listAvailableEntitlementPools(Consumer c,Owner o,String productId,boolean activeOnly){
  List<Pool> results=null;
  Criteria crit=currentSession().createCriteria(Pool.class);
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
  }
  if (productId != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",productId));
  }
  crit.add(Restrictions.lt(""String_Node_Str"",new Date()));
  crit.add(Restrictions.gt(""String_Node_Str"",new Date()));
  results=(List<Pool>)crit.list();
  if (results == null) {
    results=new ArrayList<Pool>();
  }
  if (c != null) {
    List<Pool> finalResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      PreEntHelper helper=enforcer.pre(c,p);
      if (helper.getResult().isSuccessful()) {
        finalResults.add(p);
      }
 else {
        log.info(""String_Node_Str"" + p.getId());
      }
    }
    return finalResults;
  }
  return results;
}","@SuppressWarnings(""String_Node_Str"") public List<Pool> listAvailableEntitlementPools(Consumer c,Owner o,String productId,boolean activeOnly){
  List<Pool> results=null;
  Criteria crit=currentSession().createCriteria(Pool.class);
  if (activeOnly) {
    crit.add(Restrictions.eq(""String_Node_Str"",Boolean.TRUE));
  }
  if (c != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",c.getOwner()));
  }
  if (o != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",o));
  }
  if (productId != null) {
    crit.add(Restrictions.eq(""String_Node_Str"",productId));
  }
  crit.add(Restrictions.lt(""String_Node_Str"",new Date()));
  crit.add(Restrictions.gt(""String_Node_Str"",new Date()));
  results=(List<Pool>)crit.list();
  if (results == null) {
    results=new ArrayList<Pool>();
  }
  if (c != null) {
    List<Pool> finalResults=new LinkedList<Pool>();
    for (    Pool p : results) {
      PreEntHelper helper=enforcer.pre(c,p);
      if (helper.getResult().isSuccessful()) {
        finalResults.add(p);
      }
 else {
        log.info(""String_Node_Str"" + p.getId());
        log.info(helper.getResult().getErrors());
      }
    }
    return finalResults;
  }
  return results;
}"
49609,"@Override public PreEntHelper pre(Consumer consumer,Pool entitlementPool){
  runPre(preHelper,consumer,entitlementPool);
  if (entitlementPool.isExpired(dateSource)) {
    preHelper.getResult().addError(new ValidationError(""String_Node_Str"" + entitlementPool.getProductId() + ""String_Node_Str""+ entitlementPool.getEndDate()));
    return preHelper;
  }
  return preHelper;
}","@Override public PreEntHelper pre(Consumer consumer,Pool entitlementPool){
  PreEntHelper preHelper=runPre(consumer,entitlementPool);
  if (entitlementPool.isExpired(dateSource)) {
    preHelper.getResult().addError(new ValidationError(""String_Node_Str"" + entitlementPool.getProductId() + ""String_Node_Str""+ entitlementPool.getEndDate()));
    return preHelper;
  }
  return preHelper;
}"
49610,"private void runPre(PreEntHelper preHelper,Consumer consumer,Pool pool){
  Invocable inv=(Invocable)jsEngine;
  String productId=pool.getProductId();
  jsEngine.put(""String_Node_Str"",new ReadOnlyConsumer(consumer));
  jsEngine.put(""String_Node_Str"",new ReadOnlyProduct(prodAdapter.getProductById(productId)));
  jsEngine.put(""String_Node_Str"",new ReadOnlyEntitlementPool(pool));
  jsEngine.put(""String_Node_Str"",preHelper);
  log.debug(""String_Node_Str"" + consumer.getUuid() + ""String_Node_Str""+ pool.getProductId());
  try {
    inv.invokeFunction(PRE_PREFIX + productId);
    log.debug(""String_Node_Str"" + PRE_PREFIX + productId);
  }
 catch (  NoSuchMethodException e) {
    try {
      inv.invokeFunction(GLOBAL_PRE_FUNCTION);
      log.debug(""String_Node_Str"" + GLOBAL_PRE_FUNCTION);
    }
 catch (    NoSuchMethodException ex) {
      log.warn(""String_Node_Str"" + GLOBAL_PRE_FUNCTION);
    }
catch (    ScriptException ex) {
      throw new RuleExecutionException(ex);
    }
  }
catch (  ScriptException e) {
    throw new RuleExecutionException(e);
  }
}","private PreEntHelper runPre(Consumer consumer,Pool pool){
  Invocable inv=(Invocable)jsEngine;
  String productId=pool.getProductId();
  PreEntHelper preHelper=new PreEntHelper();
  jsEngine.put(""String_Node_Str"",new ReadOnlyConsumer(consumer));
  jsEngine.put(""String_Node_Str"",new ReadOnlyProduct(prodAdapter.getProductById(productId)));
  jsEngine.put(""String_Node_Str"",new ReadOnlyEntitlementPool(pool));
  jsEngine.put(""String_Node_Str"",preHelper);
  log.debug(""String_Node_Str"" + consumer.getUuid() + ""String_Node_Str""+ pool.getProductId());
  try {
    inv.invokeFunction(PRE_PREFIX + productId);
    log.debug(""String_Node_Str"" + PRE_PREFIX + productId);
  }
 catch (  NoSuchMethodException e) {
    try {
      inv.invokeFunction(GLOBAL_PRE_FUNCTION);
      log.debug(""String_Node_Str"" + GLOBAL_PRE_FUNCTION);
    }
 catch (    NoSuchMethodException ex) {
      log.warn(""String_Node_Str"" + GLOBAL_PRE_FUNCTION);
    }
catch (    ScriptException ex) {
      throw new RuleExecutionException(ex);
    }
  }
catch (  ScriptException e) {
    throw new RuleExecutionException(e);
  }
  return preHelper;
}"
49611,"@Override public PostEntHelper post(Entitlement ent){
  postHelper.init(ent);
  runPost(postHelper,ent);
  return postHelper;
}","@Override public PostEntHelper post(Entitlement ent){
  PostEntHelper postHelper=new PostEntHelper();
  postHelper.init(ent);
  runPost(postHelper,ent);
  return postHelper;
}"
49612,"@Inject public JavascriptEnforcer(DateSource dateSource,RulesCurator rulesCurator,PreEntHelper preHelper,PostEntHelper postHelper,ProductServiceAdapter prodAdapter){
  this.dateSource=dateSource;
  this.rulesCurator=rulesCurator;
  this.preHelper=preHelper;
  this.postHelper=postHelper;
  this.prodAdapter=prodAdapter;
  ScriptEngineManager mgr=new ScriptEngineManager();
  jsEngine=mgr.getEngineByName(""String_Node_Str"");
  if (jsEngine == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    Reader reader=new StringReader(this.rulesCurator.getRules().getRules());
    jsEngine.eval(reader);
  }
 catch (  ScriptException ex) {
    throw new RuleParseException(ex);
  }
}","@Inject public JavascriptEnforcer(DateSource dateSource,RulesCurator rulesCurator,ProductServiceAdapter prodAdapter){
  this.dateSource=dateSource;
  this.rulesCurator=rulesCurator;
  this.prodAdapter=prodAdapter;
  ScriptEngineManager mgr=new ScriptEngineManager();
  jsEngine=mgr.getEngineByName(""String_Node_Str"");
  if (jsEngine == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    Reader reader=new StringReader(this.rulesCurator.getRules().getRules());
    jsEngine.eval(reader);
  }
 catch (  ScriptException ex) {
    throw new RuleParseException(ex);
  }
}"
49613,"/** 
 * default ctor
 */
public PreEntHelper(){
  result=new ValidationResult();
}","public PreEntHelper(){
  result=new ValidationResult();
}"
49614,"/** 
 * Return the value of the fact assigned to the given key.
 * @param factKey Fact key
 * @return Fact value assigned to the given key.
 */
public String getFact(String factKey){
  return consumer.getFact(factKey);
}","/** 
 * Return the value of the fact assigned to the given key.
 * @param factKey Fact key
 * @return Fact value assigned to the given key.
 */
public String getFact(String factKey){
  String result=consumer.getFact(factKey);
  if (result == null) {
    throw new MissingFactException(consumer.getUuid(),factKey);
  }
  return result;
}"
49615,"/** 
 * Returns the list of available entitlement pools.
 * @param ownerId optional parameter to limit the search by owner
 * @param productId optional parameter to limit the search by product      
 * @return the list of available entitlement pools.
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public List<Pool> list(@QueryParam(""String_Node_Str"") Long ownerId,@QueryParam(""String_Node_Str"") String consumerUuid,@QueryParam(""String_Node_Str"") String productId){
  List<Pool> returnValue=new LinkedList<Pool>();
  if ((ownerId == null) && (productId == null) && (consumerUuid == null)) {
    return poolCurator.findAll();
  }
 else {
    Product p=null;
    if (productId != null) {
      p=productServiceAdapter.getProductById(productId);
      if (p == null) {
        return returnValue;
      }
    }
    Consumer c=null;
    if (consumerUuid != null) {
      c=consumerCurator.lookupByUuid(consumerUuid);
      if (c == null) {
        return returnValue;
      }
    }
    Owner o=null;
    if (ownerId != null) {
      o=ownerCurator.find(ownerId);
      if (o == null) {
        return returnValue;
      }
    }
    return poolCurator.listAvailableEntitlementPools(c,o,p,true);
  }
}","/** 
 * Returns the list of available entitlement pools.
 * @param ownerId optional parameter to limit the search by owner
 * @param productId optional parameter to limit the search by product      
 * @return the list of available entitlement pools.
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public List<Pool> list(@QueryParam(""String_Node_Str"") Long ownerId,@QueryParam(""String_Node_Str"") String consumerUuid,@QueryParam(""String_Node_Str"") String productId){
  if (consumerUuid != null && ownerId != null) {
    throw new BadRequestException(""String_Node_Str"");
  }
  List<Pool> returnValue=new LinkedList<Pool>();
  if ((ownerId == null) && (productId == null) && (consumerUuid == null)) {
    return poolCurator.findAll();
  }
 else {
    Product p=null;
    if (productId != null) {
      p=productServiceAdapter.getProductById(productId);
      if (p == null) {
        return returnValue;
      }
    }
    Consumer c=null;
    if (consumerUuid != null) {
      c=consumerCurator.lookupByUuid(consumerUuid);
      if (c == null) {
        return returnValue;
      }
    }
    Owner o=null;
    if (ownerId != null) {
      o=ownerCurator.find(ownerId);
      if (o == null) {
        return returnValue;
      }
    }
    return poolCurator.listAvailableEntitlementPools(c,o,p,true);
  }
}"
49616,"@Before public void createEnforcer(){
  owner=TestUtil.createOwner();
  ownerCurator.create(owner);
  consumer=TestUtil.createConsumer(owner);
  consumerTypeCurator.create(consumer.getType());
  consumerCurator.create(consumer);
  PreEntHelper preHelper=new PreEntHelper();
  PostEntHelper postHelper=new PostEntHelper(productAdapter);
  enforcer=new JavascriptEnforcer(new DateSourceForTesting(2010,1,1),rulesCurator,preHelper,postHelper,productAdapter);
}","@Before public void createEnforcer(){
  owner=TestUtil.createOwner();
  ownerCurator.create(owner);
  consumer=TestUtil.createConsumer(owner);
  consumerTypeCurator.create(consumer.getType());
  consumerCurator.create(consumer);
  enforcer=new JavascriptEnforcer(new DateSourceForTesting(2010,1,1),rulesCurator,productAdapter);
}"
49617,"@Before public void setUp(){
  owner1=TestUtil.createOwner();
  owner2=TestUtil.createOwner();
  ownerCurator.create(owner1);
  ownerCurator.create(owner2);
  product1=TestUtil.createProduct();
  product2=TestUtil.createProduct();
  productCurator.create(product1);
  productCurator.create(product2);
  pool1=new Pool(owner1,product1.getId(),new Long(500),TestUtil.createDate(2000,1,1),TestUtil.createDate(3000,1,1));
  pool2=new Pool(owner1,product2.getId(),new Long(500),TestUtil.createDate(2000,1,1),TestUtil.createDate(3000,1,1));
  pool3=new Pool(owner2,product1.getId(),new Long(500),TestUtil.createDate(2000,1,1),TestUtil.createDate(3000,1,1));
  poolCurator.create(pool1);
  poolCurator.create(pool2);
  poolCurator.create(pool3);
  poolResource=new PoolResource(poolCurator,consumerCurator,ownerCurator,productAdapter);
}","@Before public void setUp(){
  owner1=TestUtil.createOwner();
  owner2=TestUtil.createOwner();
  ownerCurator.create(owner1);
  ownerCurator.create(owner2);
  product1=new Product(PRODUCT_CPULIMITED,PRODUCT_CPULIMITED);
  product2=TestUtil.createProduct();
  productCurator.create(product1);
  productCurator.create(product2);
  pool1=new Pool(owner1,product1.getId(),new Long(500),TestUtil.createDate(2000,1,1),TestUtil.createDate(3000,1,1));
  pool2=new Pool(owner1,product2.getId(),new Long(500),TestUtil.createDate(2000,1,1),TestUtil.createDate(3000,1,1));
  pool3=new Pool(owner2,product1.getId(),new Long(500),TestUtil.createDate(2000,1,1),TestUtil.createDate(3000,1,1));
  poolCurator.create(pool1);
  poolCurator.create(pool2);
  poolCurator.create(pool3);
  poolResource=new PoolResource(poolCurator,consumerCurator,ownerCurator,productAdapter);
  failConsumer=TestUtil.createConsumer(owner1);
  failConsumer.setMetadataField(""String_Node_Str"",""String_Node_Str"");
  consumerTypeCurator.create(failConsumer.getType());
  consumerCurator.create(failConsumer);
  passConsumer=TestUtil.createConsumer(owner1);
  passConsumer.setMetadataField(""String_Node_Str"",""String_Node_Str"");
  consumerTypeCurator.create(passConsumer.getType());
  consumerCurator.create(passConsumer);
}"
49618,"public static Date createDate(int year,int month,int day){
  Calendar cal=Calendar.getInstance();
  cal.set(Calendar.YEAR,year);
  cal.set(Calendar.MONTH,month);
  cal.set(Calendar.DATE,day);
  cal.set(Calendar.HOUR_OF_DAY,0);
  cal.set(Calendar.MINUTE,0);
  cal.set(Calendar.SECOND,0);
  cal.set(Calendar.MILLISECOND,0);
  Date jsqlD=new Date(cal.getTime().getTime());
  return jsqlD;
}","public static Date createDate(int year,int month,int day){
  Calendar cal=Calendar.getInstance();
  cal.set(Calendar.YEAR,year);
  cal.set(Calendar.MONTH,month - 1);
  cal.set(Calendar.DATE,day);
  cal.set(Calendar.HOUR_OF_DAY,0);
  cal.set(Calendar.MINUTE,0);
  cal.set(Calendar.SECOND,0);
  cal.set(Calendar.MILLISECOND,0);
  Date jsqlD=new Date(cal.getTime().getTime());
  return jsqlD;
}"
49619,"@Test public void hasEntitlementWithEntitledProductShouldReturnTrue(){
  Entitlement entitlement=entitler.entitle(owner,consumer,product);
  assertNotNull(entitlementCurator.find(entitlement.getId()));
  WebResource r=resource().path(""String_Node_Str"" + consumer.getUuid() + ""String_Node_Str""+ product.getId());
  Entitlement returned=r.accept(""String_Node_Str"").type(""String_Node_Str"").get(Entitlement.class);
  assertEntitlementsAreSame(entitlement,returned);
}","@Test public void hasEntitlementWithEntitledProductShouldReturnTrue(){
  Entitlement entitlement=entitler.entitle(consumer,product);
  assertNotNull(entitlementCurator.find(entitlement.getId()));
  WebResource r=resource().path(""String_Node_Str"" + consumer.getUuid() + ""String_Node_Str""+ product.getId());
  Entitlement returned=r.accept(""String_Node_Str"").type(""String_Node_Str"").get(Entitlement.class);
  assertEntitlementsAreSame(entitlement,returned);
}"
49620,"@Test public void getSingleEntitlement(){
  Consumer c=TestUtil.createConsumer(consumerType,owner);
  consumerCurator.create(c);
  Entitlement entitlement=entitler.entitle(owner,c,product);
  WebResource r=resource().path(""String_Node_Str"" + entitlement.getId());
  Entitlement returned=r.accept(""String_Node_Str"").type(""String_Node_Str"").get(Entitlement.class);
  assertEntitlementsAreSame(entitlement,returned);
  assertNotNull(entitlementCurator.find(entitlement.getId()));
}","@Test public void getSingleEntitlement(){
  Consumer c=TestUtil.createConsumer(consumerType,owner);
  consumerCurator.create(c);
  Entitlement entitlement=entitler.entitle(c,product);
  WebResource r=resource().path(""String_Node_Str"" + entitlement.getId());
  Entitlement returned=r.accept(""String_Node_Str"").type(""String_Node_Str"").get(Entitlement.class);
  assertEntitlementsAreSame(entitlement,returned);
  assertNotNull(entitlementCurator.find(entitlement.getId()));
}"
49621,"@Test public void deleteEntitlementWithValidIdShouldPass(){
  unitOfWork.beginWork();
  Entitlement entitlement=entitler.entitle(owner,consumer,product);
  assertNotNull(entitlementCurator.find(entitlement.getId()));
  unitOfWork.endWork();
  unitOfWork.beginWork();
  WebResource r=resource().path(""String_Node_Str"" + entitlement.getId());
  r.accept(""String_Node_Str"").type(""String_Node_Str"").delete();
  unitOfWork.endWork();
  assertNull(entitlementCurator.find(entitlement.getId()));
}","@Test public void deleteEntitlementWithValidIdShouldPass(){
  unitOfWork.beginWork();
  Entitlement entitlement=entitler.entitle(consumer,product);
  assertNotNull(entitlementCurator.find(entitlement.getId()));
  unitOfWork.endWork();
  unitOfWork.beginWork();
  WebResource r=resource().path(""String_Node_Str"" + entitlement.getId());
  r.accept(""String_Node_Str"").type(""String_Node_Str"").delete();
  unitOfWork.endWork();
  assertNull(entitlementCurator.find(entitlement.getId()));
}"
49622,"protected void assertEntitlementSucceeded(){
  assertEquals(new Long(1),new Long(entitlementCurator.findAll().size()));
  assertEquals(new Long(1),poolCurator.listByOwnerAndProduct(owner,product).get(0).getCurrentMembers());
  assertEquals(1,consumerCurator.find(consumer.getId()).getConsumedProducts().size());
  assertEquals(product.getId(),consumerCurator.find(consumer.getId()).getConsumedProducts().iterator().next().getProductId());
  assertEquals(1,consumerCurator.find(consumer.getId()).getEntitlements().size());
}","protected void assertEntitlementSucceeded(){
  assertEquals(new Long(1),new Long(entitlementCurator.findAll().size()));
  assertEquals(new Long(1),poolCurator.listByOwnerAndProduct(owner,product).get(0).getCurrentMembers());
  assertEquals(1,consumerCurator.find(consumer.getId()).getEntitlements().size());
}"
49623,"@Test public void listEntitlements(){
  for (int i=0; i < entitlementPool.getMaxMembers(); i++) {
    Consumer c=TestUtil.createConsumer(consumerType,owner);
    consumerCurator.create(c);
    entitler.entitle(owner,c,product);
  }
  WebResource r=resource().path(""String_Node_Str"");
  List<Entitlement> returned=r.accept(""String_Node_Str"").type(""String_Node_Str"").get(new GenericType<List<Entitlement>>(){
  }
);
  assertTrue(10 == returned.size());
  assertTrue(10 == entitlementCurator.findAll().size());
}","@Test public void listEntitlements(){
  for (int i=0; i < entitlementPool.getMaxMembers(); i++) {
    Consumer c=TestUtil.createConsumer(consumerType,owner);
    consumerCurator.create(c);
    entitler.entitle(c,product);
  }
  WebResource r=resource().path(""String_Node_Str"");
  List<Entitlement> returned=r.accept(""String_Node_Str"").type(""String_Node_Str"").get(new GenericType<List<Entitlement>>(){
  }
);
  assertTrue(10 == returned.size());
  assertTrue(10 == entitlementCurator.findAll().size());
}"
49624,"@Test public void listEntitlementsForExistingOwnerShouldPass(){
  for (int i=0; i < MAX_POOL_MEMBERS.longValue() / 2; i++) {
    Consumer c=TestUtil.createConsumer(type,owner);
    consumerCurator.create(c);
    entitler.entitle(owner,c,product);
  }
  for (int i=0; i < MAX_POOL_MEMBERS.longValue() / 2; i++) {
    Consumer c=TestUtil.createConsumer(type,owner);
    consumerCurator.create(c);
    entitler.entitle(owner,c,anotherProduct);
  }
  WebResource r=resource().path(""String_Node_Str"" + owner.getId() + ""String_Node_Str"");
  List<Entitlement> returned=r.accept(""String_Node_Str"").type(""String_Node_Str"").get(new GenericType<List<Entitlement>>(){
  }
);
  assertEquals(MAX_POOL_MEMBERS,new Long(returned.size()));
}","@Test public void listEntitlementsForExistingOwnerShouldPass(){
  for (int i=0; i < MAX_POOL_MEMBERS.longValue() / 2; i++) {
    Consumer c=TestUtil.createConsumer(type,owner);
    consumerCurator.create(c);
    entitler.entitle(c,product);
  }
  for (int i=0; i < MAX_POOL_MEMBERS.longValue() / 2; i++) {
    Consumer c=TestUtil.createConsumer(type,owner);
    consumerCurator.create(c);
    entitler.entitle(c,anotherProduct);
  }
  WebResource r=resource().path(""String_Node_Str"" + owner.getId() + ""String_Node_Str"");
  List<Entitlement> returned=r.accept(""String_Node_Str"").type(""String_Node_Str"").get(new GenericType<List<Entitlement>>(){
  }
);
  assertEquals(MAX_POOL_MEMBERS,new Long(returned.size()));
}"
49625,"@Override protected Injector getInjector(){
  return Guice.createInjector(new LinkedList<Module>(){
{
      add(PersistenceService.usingJpa().across(UnitOfWork.REQUEST).buildModule());
      add(new CandlepinProductionConfiguration());
      add(Servlets.configure().filters().filter(""String_Node_Str"").through(LoggingFilter.class).filter(""String_Node_Str"").through(Key.get(Filter.class,named(FilterConstants.BASIC_AUTH))).servlets().serve(""String_Node_Str"").with(ServletContainer.class).buildModule());
      add(Modules.override(new DefaultConfig()).with(new CustomizableModules().load()));
    }
  }
);
}","@Override protected Injector getInjector(){
  return Guice.createInjector(new LinkedList<Module>(){
{
      add(PersistenceService.usingJpa().across(UnitOfWork.REQUEST).buildModule());
      add(new CandlepinProductionConfiguration());
      add(Servlets.configure().filters().filter(""String_Node_Str"").through(LoggingFilter.class).filter(""String_Node_Str"").through(Key.get(Filter.class,named(FilterConstants.BASIC_AUTH))).servlets().serve(""String_Node_Str"").with(Key.get(ServletContainer.class,named(CANDLEPIN_SERVLET)),new HashMap<String,String>(){
{
          put(""String_Node_Str"",""String_Node_Str"");
        }
      }
).buildModule());
      add(new ServletConfig());
      add(Modules.override(new DefaultConfig()).with(new CustomizableModules().load()));
    }
  }
);
}"
49626,"public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws IOException, ServletException {
}","public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws IOException, ServletException {
  log.debug(""String_Node_Str"");
  HttpServletRequest httpRequest=(HttpServletRequest)request;
  HttpServletResponse httpResponse=(HttpServletResponse)response;
  String auth=httpRequest.getHeader(""String_Node_Str"");
  if (auth != null && auth.toUpperCase().startsWith(""String_Node_Str"") && httpRequest.getMethod().equals(""String_Node_Str"")) {
    String userpassEncoded=auth.substring(6);
    String[] userpass=Base64.base64Decode(userpassEncoded).split(""String_Node_Str"");
    try {
      doBasicAuth(userpass[0],userpass[1]);
      request.setAttribute(""String_Node_Str"",userpass[0]);
      chain.doFilter(request,response);
    }
 catch (    ForbiddenException ex) {
      httpResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
    }
catch (    Exception ex) {
      log.error(ex.getMessage());
      httpResponse.setStatus(HttpServletResponse.SC_BAD_GATEWAY);
    }
  }
  chain.doFilter(request,response);
  log.debug(""String_Node_Str"");
}"
49627,"@Before public void setUp(){
  consumerResource=new ConsumerResource(ownerCurator,consumerCurator,consumerTypeCurator,consumerIdCertCurator);
  standardSystemType=consumerTypeCurator.create(new ConsumerType(""String_Node_Str""));
  owner=ownerCurator.create(new Owner(""String_Node_Str""));
}","@Before public void setUp(){
  consumerResource=new ConsumerResource(ownerCurator,consumerCurator,consumerTypeCurator,consumerIdCertCurator,httpServletRequest);
  standardSystemType=consumerTypeCurator.create(new ConsumerType(""String_Node_Str""));
  owner=ownerCurator.create(new Owner(""String_Node_Str""));
}"
49628,"public Properties parseConfig(Map<String,String> inputConfiguration){
  Properties toReturn=new Properties(defaultConfigurationSettings());
  toReturn.putAll(stripPrefixFromConfigKeys(inputConfiguration));
  return toReturn;
}","public Properties parseConfig(Map<String,String> inputConfiguration){
  Properties toReturn=new Properties();
  toReturn.putAll(stripPrefixFromConfigKeys(inputConfiguration));
  return toReturn;
}"
49629,"public Properties loadDefaultConfigurationSettings(String persistenceUnit,File configFile) throws XPathExpressionException, IOException, ParserConfigurationException, SAXException {
  return parsePropertiesFromConfigFile(persistenceUnit,parseXML(configFile));
}","/** 
 * loads the default configuration from the file.
 * @param persistenceUnit JPA persistence unit name.
 * @param configFile location of the configuration file.
 * @return jpa configuration as a JPA for the given unit name.
 * @throws XPathExpressionException thrown for invalid xml file
 * @throws IOException thrown if file is not found.
 * @throws ParserConfigurationException thrown for invalid xml file
 * @throws SAXException thrown for invalid xml file
 */
public Properties loadDefaultConfigurationSettings(String persistenceUnit,File configFile) throws XPathExpressionException, IOException, ParserConfigurationException, SAXException {
  return parsePropertiesFromConfigFile(persistenceUnit,parseXML(configFile));
}"
49630,"public Document parseXML(File file) throws IOException, ParserConfigurationException, SAXException {
  DocumentBuilderFactory domFactory=DocumentBuilderFactory.newInstance();
  domFactory.setNamespaceAware(false);
  DocumentBuilder builder=domFactory.newDocumentBuilder();
  Document doc=builder.parse(file);
  return doc;
}","/** 
 * parses the XML file.
 * @param file file to parse
 * @return returns XML Document for the given file.
 * @throws IOException thrown if there's a problem reading a file.
 * @throws ParserConfigurationException thrown for invalid xml file.
 * @throws SAXException thrown for invalid xml file.
 */
public Document parseXML(File file) throws IOException, ParserConfigurationException, SAXException {
  DocumentBuilderFactory domFactory=DocumentBuilderFactory.newInstance();
  domFactory.setNamespaceAware(false);
  DocumentBuilder builder=domFactory.newDocumentBuilder();
  Document doc=builder.parse(file);
  return doc;
}"
49631,"public Properties parseConfig(Map<String,String> inputConfiguration){
  Properties toReturn=new Properties(defaultConfigurationSettings());
  toReturn.putAll(stripPrefixFromConfigKeys(inputConfiguration));
  return toReturn;
}","/** 
 * Converts the given Map into a Properties object. 
 * @param inputConfiguration Configuration to be converted.
 * @return config as a Properties file
 */
public Properties parseConfig(Map<String,String> inputConfiguration){
  Properties toReturn=new Properties(defaultConfigurationSettings());
  toReturn.putAll(stripPrefixFromConfigKeys(inputConfiguration));
  return toReturn;
}"
49632,"public Properties parsePropertiesFromConfigFile(String persistenceUnitName,Document doc) throws XPathExpressionException {
  XPath xpath=XPathFactory.newInstance().newXPath();
  XPathExpression expr=xpath.compile(""String_Node_Str"" + persistenceUnitName + ""String_Node_Str"");
  Object result=expr.evaluate(doc,XPathConstants.NODESET);
  NodeList nodes=(NodeList)result;
  Properties toReturn=new Properties();
  for (int i=0; i < nodes.getLength(); i++) {
    String name=nodeValue(nodes,i,""String_Node_Str"");
    String value=nodeValue(nodes,i,""String_Node_Str"");
    toReturn.put(name,value);
  }
  return toReturn;
}","/** 
 * @param persistenceUnitName jpa persistence unit name
 * @param doc XML Document
 * @return configuration as a Properties.
 * @throws XPathExpressionException thrown for invalid xml file.
 */
public Properties parsePropertiesFromConfigFile(String persistenceUnitName,Document doc) throws XPathExpressionException {
  XPath xpath=XPathFactory.newInstance().newXPath();
  XPathExpression expr=xpath.compile(""String_Node_Str"" + persistenceUnitName + ""String_Node_Str"");
  Object result=expr.evaluate(doc,XPathConstants.NODESET);
  NodeList nodes=(NodeList)result;
  Properties toReturn=new Properties();
  for (int i=0; i < nodes.getLength(); i++) {
    String name=nodeValue(nodes,i,""String_Node_Str"");
    String value=nodeValue(nodes,i,""String_Node_Str"");
    toReturn.put(name,value);
  }
  return toReturn;
}"
49633,"public Properties defaultConfigurationSettings(){
  try {
    return loadDefaultConfigurationSettings(""String_Node_Str"",new File(getClass().getResource(""String_Node_Str"").toURI()));
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","/** 
 * @return the default jpa configuration
 */
public Properties defaultConfigurationSettings(){
  try {
    return loadDefaultConfigurationSettings(""String_Node_Str"",new File(getClass().getResource(""String_Node_Str"").toURI()));
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}"
49634,"public Properties stripPrefixFromConfigKeys(Map<String,String> inputConfiguration){
  Properties toReturn=new Properties();
  for (  String key : inputConfiguration.keySet()) {
    toReturn.put(key.substring(PREFIX_LENGTH + 1),inputConfiguration.get(key));
  }
  return toReturn;
}","/** 
 * Return a copy of the input without the prefixes.
 * @param inputConfiguration Configuration to be converted.
 * @return config as a Properties object without the prefixes.
 */
public Properties stripPrefixFromConfigKeys(Map<String,String> inputConfiguration){
  Properties toReturn=new Properties();
  for (  String key : inputConfiguration.keySet()) {
    toReturn.put(key.substring(PREFIX_LENGTH + 1),inputConfiguration.get(key));
  }
  return toReturn;
}"
49635,"/** 
 * Returns all the entitlement pools for the consumer with the given uuid.
 * @param consumerUuid whose entitlement pools are sought.
 * @return all the entitlement pools for the consumer with the given uuid.
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @Path(""String_Node_Str"") public List<EntitlementPool> listByConsumer(@PathParam(""String_Node_Str"") String consumerUuid){
  log.debug(""String_Node_Str"" + consumer_uuid);
  Consumer consumer=consumerCurator.lookupByUuid(consumer_uuid);
  log.debug(""String_Node_Str"" + consumer.toString());
  List<EntitlementPool> eps=entitlementPoolCurator.listByConsumer(consumer);
  log.debug(""String_Node_Str"" + eps.toString());
  return eps;
}","/** 
 * Returns all the entitlement pools for the consumer with the given uuid.
 * @param consumerUuid whose entitlement pools are sought.
 * @return all the entitlement pools for the consumer with the given uuid.
 */
@GET @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @Path(""String_Node_Str"") public List<EntitlementPool> listByConsumer(@PathParam(""String_Node_Str"") String consumerUuid){
  log.debug(""String_Node_Str"" + consumerUuid);
  Consumer consumer=consumerCurator.lookupByUuid(consumerUuid);
  log.debug(""String_Node_Str"" + consumer.toString());
  List<EntitlementPool> eps=entitlementPoolCurator.listByConsumer(consumer);
  log.debug(""String_Node_Str"" + eps.toString());
  return eps;
}"
49636,"public static Properties stripPrefixFromConfigKeys(Map<String,String> inputConfiguration){
  Properties toReturn=new Properties();
  for (  String key : inputConfiguration.keySet()) {
    toReturn.put(key.substring(PREFIX_LENGTH),inputConfiguration.get(key));
  }
  return toReturn;
}","public static Properties stripPrefixFromConfigKeys(Map<String,String> inputConfiguration){
  Properties toReturn=new Properties();
  for (  String key : inputConfiguration.keySet()) {
    toReturn.put(key.substring(PREFIX_LENGTH + 1),inputConfiguration.get(key));
  }
  return toReturn;
}"
49637,"@Test public void shouldStripJPAConfigKeyPrefixes(){
  final String key1=""String_Node_Str"";
  final String key2=""String_Node_Str"";
  Map<String,String> configuraton=new HashMap<String,String>(){
{
      put(JPAConfiguration.JPA_CONFIG_PREFIX + key1,""String_Node_Str"");
      put(JPAConfiguration.JPA_CONFIG_PREFIX + key2,""String_Node_Str"");
    }
  }
;
  Properties stripped=JPAConfiguration.stripPrefixFromConfigKeys(configuraton);
  assertEquals(2,stripped.size());
  assertTrue(stripped.containsKey(key1));
  assertTrue(stripped.containsKey(key2));
}","@Test public void shouldStripJPAConfigKeyPrefixes(){
  final String key1=""String_Node_Str"";
  final String key2=""String_Node_Str"";
  Map<String,String> configuraton=new HashMap<String,String>(){
{
      put(JPAConfiguration.JPA_CONFIG_PREFIX + ""String_Node_Str"" + key1,""String_Node_Str"");
      put(JPAConfiguration.JPA_CONFIG_PREFIX + ""String_Node_Str"" + key2,""String_Node_Str"");
    }
  }
;
  Properties stripped=JPAConfiguration.stripPrefixFromConfigKeys(configuraton);
  assertEquals(2,stripped.size());
  assertTrue(stripped.containsKey(key1));
  assertTrue(stripped.containsKey(key2));
}"
49638,"@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Consumer getConsumer(){
  Consumer consumer=new Consumer();
  Product product=new Product(""String_Node_Str"",""String_Node_Str"");
  consumer.addConsumedProduct(product);
  return consumer;
}","@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public Consumer getConsumer(){
  Consumer consumer=new Consumer();
  Product product=new Product(""String_Node_Str"",""String_Node_Str"");
  return consumer;
}"
49639,"private void runPre(PreEntHelper preHelper,Consumer consumer,EntitlementPool pool){
  Invocable inv=(Invocable)jsEngine;
  Product p=pool.getProduct();
  jsEngine.put(""String_Node_Str"",new ReadOnlyConsumer(consumer));
  jsEngine.put(""String_Node_Str"",new ReadOnlyProduct(pool.getProduct()));
  jsEngine.put(""String_Node_Str"",new ReadOnlyEntitlementPool(pool));
  jsEngine.put(""String_Node_Str"",preHelper);
  try {
    inv.invokeFunction(PRE_PREFIX + p.getLabel());
  }
 catch (  NoSuchMethodException e) {
    try {
      inv.invokeFunction(GLOBAL_PRE_FUNCTION);
    }
 catch (    NoSuchMethodException ex) {
    }
catch (    ScriptException ex) {
      throw new RuleExecutionException(ex);
    }
  }
catch (  ScriptException e) {
    throw new RuleExecutionException(e);
  }
}","private void runPre(PreEntHelper preHelper,Consumer consumer,EntitlementPool pool){
  Invocable inv=(Invocable)jsEngine;
  String productOID=pool.getProduct();
  jsEngine.put(""String_Node_Str"",new ReadOnlyConsumer(consumer));
  jsEngine.put(""String_Node_Str"",new ReadOnlyProduct(prodAdapter.getProductByOID(productOID)));
  jsEngine.put(""String_Node_Str"",new ReadOnlyEntitlementPool(pool));
  jsEngine.put(""String_Node_Str"",preHelper);
  try {
    inv.invokeFunction(PRE_PREFIX + productOID);
  }
 catch (  NoSuchMethodException e) {
    try {
      inv.invokeFunction(GLOBAL_PRE_FUNCTION);
    }
 catch (    NoSuchMethodException ex) {
    }
catch (    ScriptException ex) {
      throw new RuleExecutionException(ex);
    }
  }
catch (  ScriptException e) {
    throw new RuleExecutionException(e);
  }
}"
49640,"private void runPost(PostEntHelper postHelper,Entitlement ent){
  Invocable inv=(Invocable)jsEngine;
  EntitlementPool pool=ent.getPool();
  Consumer c=ent.getConsumer();
  Product p=pool.getProduct();
  jsEngine.put(""String_Node_Str"",new ReadOnlyConsumer(c));
  jsEngine.put(""String_Node_Str"",new ReadOnlyProduct(pool.getProduct()));
  jsEngine.put(""String_Node_Str"",postHelper);
  jsEngine.put(""String_Node_Str"",new ReadOnlyEntitlement(ent));
  try {
    inv.invokeFunction(POST_PREFIX + p.getLabel());
  }
 catch (  NoSuchMethodException e) {
    try {
      inv.invokeFunction(GLOBAL_POST_FUNCTION);
    }
 catch (    NoSuchMethodException ex) {
    }
catch (    ScriptException ex) {
      throw new RuleExecutionException(ex);
    }
  }
catch (  ScriptException e) {
    throw new RuleExecutionException(e);
  }
}","private void runPost(PostEntHelper postHelper,Entitlement ent){
  Invocable inv=(Invocable)jsEngine;
  EntitlementPool pool=ent.getPool();
  Consumer c=ent.getConsumer();
  String productOID=pool.getProduct();
  jsEngine.put(""String_Node_Str"",new ReadOnlyConsumer(c));
  jsEngine.put(""String_Node_Str"",new ReadOnlyProduct(prodAdapter.getProductByOID(productOID)));
  jsEngine.put(""String_Node_Str"",postHelper);
  jsEngine.put(""String_Node_Str"",new ReadOnlyEntitlement(ent));
  try {
    inv.invokeFunction(POST_PREFIX + productOID);
  }
 catch (  NoSuchMethodException e) {
    try {
      inv.invokeFunction(GLOBAL_POST_FUNCTION);
    }
 catch (    NoSuchMethodException ex) {
    }
catch (    ScriptException ex) {
      throw new RuleExecutionException(ex);
    }
  }
catch (  ScriptException e) {
    throw new RuleExecutionException(e);
  }
}"
49641,"@Inject public JavascriptEnforcer(DateSource dateSource,RulesCurator rulesCurator,PreEntHelper preHelper,PostEntHelper postHelper,ProductServiceAdapter prodAdapter){
  this.dateSource=dateSource;
  this.rulesCurator=rulesCurator;
  this.preHelper=preHelper;
  this.postHelper=postHelper;
  this.prodAdapter=prodAdapter;
  ScriptEngineManager mgr=new ScriptEngineManager();
  jsEngine=mgr.getEngineByName(""String_Node_Str"");
  if (jsEngine == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    Reader reader=new StringReader(this.rulesCurator.getRules().getRules());
    jsEngine.eval(reader);
  }
 catch (  ScriptException ex) {
    throw new RuleParseException(ex);
  }
  this.rules=new Rules(this.rulesCurator.getRules().getRules(),prodAdapter);
}","@Inject public JavascriptEnforcer(DateSource dateSource,RulesCurator rulesCurator,PreEntHelper preHelper,PostEntHelper postHelper,ProductServiceAdapter prodAdapter){
  this.dateSource=dateSource;
  this.rulesCurator=rulesCurator;
  this.preHelper=preHelper;
  this.postHelper=postHelper;
  this.prodAdapter=prodAdapter;
  ScriptEngineManager mgr=new ScriptEngineManager();
  jsEngine=mgr.getEngineByName(""String_Node_Str"");
  if (jsEngine == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    Reader reader=new StringReader(this.rulesCurator.getRules().getRules());
    jsEngine.eval(reader);
  }
 catch (  ScriptException ex) {
    throw new RuleParseException(ex);
  }
}"
49642,"public EnforcerImpl(DateSource dateSource){
  this.dateSource=dateSource;
}","public EnforcerImpl(DateSource dateSource,EntitlementPoolCurator epCurator){
  this.dateSource=dateSource;
  this.epCurator=epCurator;
}"
49643,"@Override public boolean validate(Consumer consumer,EntitlementPool enitlementPool){
  if (!enitlementPool.hasAvailableEntitlements()) {
    errors.add(new ValidationError(""String_Node_Str""));
    return false;
  }
  if (enitlementPool.isExpired(dateSource)) {
    errors.add(new ValidationError(""String_Node_Str"" + enitlementPool.getProduct().getName() + ""String_Node_Str""+ enitlementPool.getEndDate()));
    return false;
  }
  return true;
}","@Override public boolean validate(Consumer consumer,EntitlementPool enitlementPool){
  if (!epCurator.entitlementsAvailable(enitlementPool)) {
    errors.add(new ValidationError(""String_Node_Str""));
    return false;
  }
  if (enitlementPool.isExpired(dateSource)) {
    errors.add(new ValidationError(""String_Node_Str"" + enitlementPool.getProduct().getName() + ""String_Node_Str""+ enitlementPool.getEndDate()));
    return false;
  }
  return true;
}"
49644,"/** 
 * Entitles the given Consumer with the given Product.
 * @param c Consumer to be entitled
 * @param p The Product
 * @return Entitled object
 */
@POST @Consumes({MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @Path(""String_Node_Str"") public Object entitle(@FormParam(""String_Node_Str"") String consumerUuid,@FormParam(""String_Node_Str"") String productLabel){
  Owner owner=getCurrentUsersOwner(ownerCurator);
  Consumer consumer=consumerCurator.lookupByUuid(consumerUuid);
  if (consumer == null) {
    throw new RuntimeException(""String_Node_Str"" + consumerUuid);
  }
  Product p=productCurator.lookupByLabel(productLabel);
  if (p == null) {
    throw new RuntimeException(""String_Node_Str"" + productLabel);
  }
  EntitlementPool ePool=epCurator.lookupByOwnerAndProduct(owner,consumer,p);
  if (ePool == null) {
    throw new RuntimeException(""String_Node_Str"" + p.getName());
  }
  if (!enforcer.validate(consumer,ePool)) {
    throw new RuntimeException(enforcer.errors().toString());
  }
  Entitlement e=epCurator.createEntitlement(ePool,consumer);
  return CertGenerator.getCertString();
}","/** 
 * Entitles the given Consumer with the given Product.
 * @param c Consumer to be entitled
 * @param p The Product
 * @return Entitled object
 */
@POST @Consumes({MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) @Path(""String_Node_Str"") public Object entitle(@FormParam(""String_Node_Str"") String consumerUuid,@FormParam(""String_Node_Str"") String productLabel){
  Owner owner=getCurrentUsersOwner(ownerCurator);
  Consumer consumer=consumerCurator.lookupByUuid(consumerUuid);
  if (consumer == null) {
    throw new RuntimeException(""String_Node_Str"" + consumerUuid);
  }
  Product p=productCurator.lookupByLabel(productLabel);
  if (p == null) {
    throw new RuntimeException(""String_Node_Str"" + productLabel);
  }
  EntitlementPool ePool=epCurator.lookupByOwnerAndProduct(owner,consumer,p);
  if (ePool == null) {
    throw new RuntimeException(""String_Node_Str"" + p.getName());
  }
  Enforcer enforcer=new EnforcerImpl(dateSource,epCurator);
  if (!enforcer.validate(consumer,ePool)) {
    throw new RuntimeException(enforcer.errors().toString());
  }
  Entitlement e=epCurator.createEntitlement(ePool,consumer);
  return CertGenerator.getCertString();
}"
49645,"@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public ConsumerInfo getInfo(){
  ConsumerInfo ci=new ConsumerInfo();
  ci.setType(ConsumerInfo.TYPE_SYSTEM);
  ci.setParent(null);
  ci.setMetadataField(""String_Node_Str"",""String_Node_Str"");
  ci.setMetadataField(""String_Node_Str"",""String_Node_Str"");
  System.out.println(ci.getMetadata());
  return ci;
}","@GET @Path(""String_Node_Str"") @Produces({MediaType.APPLICATION_JSON,MediaType.APPLICATION_XML}) public ConsumerInfo getInfo(){
  ConsumerInfo ci=new ConsumerInfo();
  ci.setType(new ConsumerType(""String_Node_Str""));
  ci.setParent(null);
  ci.setMetadataField(""String_Node_Str"",""String_Node_Str"");
  ci.setMetadataField(""String_Node_Str"",""String_Node_Str"");
  System.out.println(ci.getMetadata());
  return ci;
}"
49646,"public void testJSON(){
}","public void testJSON(){
  ClientConfig cc=new DefaultClientConfig();
  Client c=Client.create(cc);
  Consumer consumer=TestUtil.createConsumer();
  String uuid=consumer.getUuid();
  WebResource deleteResource=c.resource(""String_Node_Str"");
  deleteResource.accept(""String_Node_Str"").type(""String_Node_Str"").delete(consumer);
  assertNull(ObjectFactory.get().lookupByUUID(c.getClass(),uuid));
}"
49647,"public void setName(String name){
  this.name=name;
}","/** 
 * Set the name of the model object.
 * @param name name of the object
 */
public void setName(String name){
  this.name=name;
}"
49648,"public String getName(){
  return name;
}","/** 
 * Returns the name of the object.
 * @return the name of the object.
 */
public String getName(){
  return name;
}"
49649,"public String getUuid(){
  return uuid;
}","/** 
 * Returns the unique id of the model object.
 * @return the unique id of the model object.
 */
public String getUuid(){
  return uuid;
}"
49650,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  BaseModel other=(BaseModel)obj;
  if (this.getUuid() == null) {
    if (other.getUuid() != null)     return false;
  }
 else   if (!this.getUuid().equals(other.getUuid()))   return false;
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  BaseModel other=(BaseModel)obj;
  if (this.getUuid() == null) {
    if (other.getUuid() != null) {
      return false;
    }
  }
 else   if (!this.getUuid().equals(other.getUuid())) {
    return false;
  }
  return true;
}"
49651,"public void setUuid(String uuid){
  this.uuid=uuid;
}","/** 
 * Sets the unique id of the model object.
 * @param uuid unique id of the model.
 */
public void setUuid(String uuid){
  this.uuid=uuid;
}"
49652,"/** 
 * @param uuid
 */
public Consumer(String uuid){
  super(uuid);
  this.info=new ConsumerInfo();
  this.info.setParent(this);
}","/** 
 * @param uuid unique id of consumer
 */
public Consumer(String uuid){
  super(uuid);
  this.info=new ConsumerInfo();
  this.info.setParent(this);
}"
49653,"/** 
 * Add a Product to this Consumer.
 */
public void addConsumedProduct(Product p){
  if (this.consumedProducts == null) {
    this.consumedProducts=new LinkedList<Product>();
  }
  this.consumedProducts.add(p);
}","/** 
 * Add a Product to this Consumer.
 * @param p Product to be consumed.
 */
public void addConsumedProduct(Product p){
  if (this.consumedProducts == null) {
    this.consumedProducts=new LinkedList<Product>();
  }
  this.consumedProducts.add(p);
}"
49654,"/** 
 * @param uuid
 */
public Entitlement(String uuid){
  super(uuid);
}","/** 
 * @param uuid unique id of the entitlement
 */
public Entitlement(String uuid){
  super(uuid);
}"
49655,"/** 
 * @param org the org to set
 */
public void setOwner(Owner ownerIn){
  this.owner=ownerIn;
}","/** 
 * @param ownerIn the owner to set
 */
public void setOwner(Owner ownerIn){
  this.owner=ownerIn;
}"
49656,"public JsonTestObject getParent(){
  return parent;
}","/** 
 * returns parent object
 * @return parent object
 */
public JsonTestObject getParent(){
  return parent;
}"
49657,"public void setParent(JsonTestObject p){
  parent=p;
}","/** 
 * sets the parent
 * @param p Parent
 */
public void setParent(JsonTestObject p){
  parent=p;
}"
49658,"public List<String> getStringList(){
  return stringlist;
}","/** 
 * returns the string list
 * @return the string list
 */
public List<String> getStringList(){
  return stringlist;
}"
49659,"public void setStringList(List<String> items){
  stringlist=items;
}","/** 
 * sets the list string
 * @param items items to set
 */
public void setStringList(List<String> items){
  stringlist=items;
}"
49660,"/** 
 * Lookup an object by a field name
 * @param clazz
 * @param fieldName
 * @return BaseModel if found.
 */
public Object lookupByFieldName(Class<?> clazz,String fieldName,String value){
  String key=clazz.getName();
  if (!objects.containsKey(key)) {
    return null;
  }
  List typelist=(List)objects.get(key);
  for (int i=0; i < typelist.size(); i++) {
    Object o=typelist.get(i);
    logger.debug(""String_Node_Str"" + o);
    String getter=""String_Node_Str"" + fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
    logger.debug(""String_Node_Str"" + getter);
    Object v=MethodUtil.callMethod(o,getter,new Object[0]);
    logger.debug(""String_Node_Str"" + v);
    if (v != null && v.equals(value)) {
      return o;
    }
  }
  return null;
}","/** 
 * Lookup an object by a field name
 * @param clazz class to lookup
 * @param fieldName field to use
 * @param value value to match
 * @return BaseModel if found, null otherwise.
 */
public Object lookupByFieldName(Class<?> clazz,String fieldName,String value){
  String key=clazz.getName();
  if (!objects.containsKey(key)) {
    return null;
  }
  List typelist=(List)objects.get(key);
  for (int i=0; i < typelist.size(); i++) {
    Object o=typelist.get(i);
    logger.debug(""String_Node_Str"" + o);
    String getter=""String_Node_Str"" + fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
    logger.debug(""String_Node_Str"" + getter);
    Object v=MethodUtil.callMethod(o,getter,new Object[0]);
    logger.debug(""String_Node_Str"" + v);
    if (v != null && v.equals(value)) {
      return o;
    }
  }
  return null;
}"
49661,"/** 
 * Store an object
 * @param u
 */
public Object store(Object u){
  String key=u.getClass().getName();
  if (!objects.containsKey(key)) {
    List newtype=new LinkedList();
    newtype.add(u);
    objects.put(u.getClass().getName(),newtype);
  }
  List typelist=(List)objects.get(key);
  typelist.add(u);
  return u;
}","/** 
 * Store an object
 * @param u object to store
 * @return The stored object
 */
public Object store(Object u){
  String key=u.getClass().getName();
  if (!objects.containsKey(key)) {
    List newtype=new LinkedList();
    newtype.add(u);
    objects.put(u.getClass().getName(),newtype);
  }
  List typelist=(List)objects.get(key);
  typelist.add(u);
  return u;
}"
49662,"/** 
 * Delete an object 
 * @param clazz to lookup  
 * @param uuidIn to lookup and delete
 */
public void delete(Class clazz,BaseModel removeMe){
  String key=clazz.getName();
  List typelist=(List)objects.get(key);
  typelist.remove(removeMe);
}","/** 
 * Delete an object 
 * @param clazz to lookup  
 * @param removeMe model to remove
 */
public void delete(Class clazz,BaseModel removeMe){
  String key=clazz.getName();
  List typelist=(List)objects.get(key);
  typelist.remove(removeMe);
}"
49663,"/** 
 * Get a List of objects by type
 * @param clazz
 * @return List if found. null if not.
 */
public List<Object> listObjectsByClass(Class<?> clazz){
  List<Object> retval=null;
  retval=(List<Object>)objects.get(clazz.getName());
  if (retval == null) {
    retval=new LinkedList();
  }
  return retval;
}","/** 
 * Get a List of objects by type
 * @param clazz class to lookup
 * @return List if found. null if not.
 */
public List<Object> listObjectsByClass(Class<?> clazz){
  List<Object> retval=null;
  retval=(List<Object>)objects.get(clazz.getName());
  if (retval == null) {
    retval=new LinkedList();
  }
  return retval;
}"
49664,"/** 
 * Lookup an Owner by UUID
 * @param uuid to lookup
 * @return Owner
 */
public BaseModel lookupByUUID(Class<?> clazz,String uuid){
  return (BaseModel)lookupByFieldName(clazz,""String_Node_Str"",uuid);
}","/** 
 * Lookup an Owner by UUID
 * @param clazz class to lookup
 * @param uuid to lookup
 * @return BaseModel if found, null otherwise.
 */
public BaseModel lookupByUUID(Class<?> clazz,String uuid){
  return (BaseModel)lookupByFieldName(clazz,""String_Node_Str"",uuid);
}"
49665,"public void addConsumer(Consumer c){
  c.setOwner(this);
  if (this.consumers == null) {
    this.consumers=new LinkedList<Consumer>();
  }
  this.consumers.add(c);
}","/** 
 * Add a consumer to this owner
 * @param c consumer for this owner.
 */
public void addConsumer(Consumer c){
  c.setOwner(this);
  if (this.consumers == null) {
    this.consumers=new LinkedList<Consumer>();
  }
  this.consumers.add(c);
}"
49666,"public void addEntitlementPool(EntitlementPool pool){
  pool.setOwner(this);
  if (this.entitlementPools == null) {
    this.entitlementPools=new LinkedList<EntitlementPool>();
  }
  this.entitlementPools.add(pool);
}","/** 
 * add owner to the pool, and reference to the pool.
 * @param pool EntitlementPool for this owner.
 */
public void addEntitlementPool(EntitlementPool pool){
  pool.setOwner(this);
  if (this.entitlementPools == null) {
    this.entitlementPools=new LinkedList<EntitlementPool>();
  }
  this.entitlementPools.add(pool);
}"
49667,"/** 
 * Get the list of 
 * @return
 */
public List<String> getCompatibleConsumerTypes(){
  return null;
}","/** 
 * Get the list of compatible consumer types
 * @return list of compatible consumer types
 */
public List<String> getCompatibleConsumerTypes(){
  return null;
}"
49668,"/** 
 * Create a new instance of the classname passed in.
 * @param className
 * @return instance of class passed in.
 */
public static Object callNewMethod(String className,Object... args){
  Object retval=null;
  try {
    Class clazz=Thread.currentThread().getContextClassLoader().loadClass(className);
    System.out.println(""String_Node_Str"" + clazz.getName());
    if (args == null || args.length == 0) {
      retval=clazz.newInstance();
    }
 else {
      try {
        Constructor[] ctors=clazz.getConstructors();
        for (        Constructor ctor : ctors) {
          if (isCompatible(ctor.getParameterTypes(),args)) {
            return ctor.newInstance(args);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        throw new RuntimeException(e);
      }
catch (      InvocationTargetException e) {
        throw new RuntimeException(e);
      }
    }
  }
 catch (  InstantiationException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
  return retval;
}","/** 
 * Create a new instance of the classname passed in.
 * @param className the class to construct
 * @param args arguments to the ctor of the given className
 * @return instance of class passed in.
 */
public static Object callNewMethod(String className,Object... args){
  Object retval=null;
  try {
    Class clazz=Thread.currentThread().getContextClassLoader().loadClass(className);
    System.out.println(""String_Node_Str"" + clazz.getName());
    if (args == null || args.length == 0) {
      retval=clazz.newInstance();
    }
 else {
      try {
        Constructor[] ctors=clazz.getConstructors();
        for (        Constructor ctor : ctors) {
          if (isCompatible(ctor.getParameterTypes(),args)) {
            return ctor.newInstance(args);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        throw new RuntimeException(e);
      }
catch (      InvocationTargetException e) {
        throw new RuntimeException(e);
      }
    }
  }
 catch (  InstantiationException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
catch (  ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
  return retval;
}"
49669,"public static void callSetter(Object o,String fieldName,Object param){
  String setter=""String_Node_Str"" + fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
  MethodUtil.callMethod(o,setter,param);
}","/** 
 * Calls the setter for the <code>fieldName</code> of the object <code>o</code> with the given <code>param</code> 
 * @param o object being modified
 * @param fieldName field to be set
 * @param param value to be used
 */
public static void callSetter(Object o,String fieldName,Object param){
  String setter=""String_Node_Str"" + fieldName.substring(0,1).toUpperCase() + fieldName.substring(1);
  MethodUtil.callMethod(o,setter,param);
}"
49670,"/** 
 * This position may be a draw with a the pawn in a, c, f, h and in 7th with the defending king near
 */
private static int endgameKQKP(Board board,boolean whiteDominant){
  long ranks12=BitboardUtils.RANK[whiteDominant ? 0 : 7] | BitboardUtils.RANK[whiteDominant ? 1 : 6];
  long pawn=board.pawns;
  long pawnZone;
  if ((BitboardUtils.A & pawn) != 0) {
    pawnZone=(BitboardUtils.FILES_LEFT[3]) & ranks12;
  }
 else   if ((BitboardUtils.C & pawn) != 0) {
    pawnZone=(BitboardUtils.FILES_LEFT[4]) & ranks12;
  }
 else   if ((BitboardUtils.F & pawn) != 0) {
    pawnZone=(BitboardUtils.FILES_RIGHT[3]) & ranks12;
  }
 else   if ((BitboardUtils.F & pawn) != 0) {
    pawnZone=(BitboardUtils.FILES_RIGHT[4]) & ranks12;
  }
 else {
    return Evaluator.NO_VALUE;
  }
  long dominantKing=board.kings & (whiteDominant ? board.whites : board.blacks);
  long otherKing=board.kings & (whiteDominant ? board.blacks : board.whites);
  int dominantKingIndex=BitboardUtils.square2Index(dominantKing);
  int pawnIndex=BitboardUtils.square2Index(pawn);
  if ((pawnZone & otherKing) != 0 && BitboardUtils.distance(dominantKingIndex,pawnIndex) >= 2) {
    return Evaluator.DRAW;
  }
  return Evaluator.NO_VALUE;
}","/** 
 * This position may be a draw with a the pawn in a, c, f, h and in 7th with the defending king near
 */
private static int endgameKQKP(Board board,boolean whiteDominant){
  long ranks12=whiteDominant ? BitboardUtils.R1 | BitboardUtils.R2 : BitboardUtils.R7 | BitboardUtils.R8;
  long pawn=board.pawns;
  long pawnZone;
  if ((BitboardUtils.A & pawn) != 0) {
    pawnZone=(BitboardUtils.FILES_LEFT[3]) & ranks12;
  }
 else   if ((BitboardUtils.C & pawn) != 0) {
    pawnZone=(BitboardUtils.FILES_LEFT[4]) & ranks12;
  }
 else   if ((BitboardUtils.F & pawn) != 0) {
    pawnZone=(BitboardUtils.FILES_RIGHT[3]) & ranks12;
  }
 else   if ((BitboardUtils.H & pawn) != 0) {
    pawnZone=(BitboardUtils.FILES_RIGHT[4]) & ranks12;
  }
 else {
    return Evaluator.NO_VALUE;
  }
  long dominantKing=board.kings & (whiteDominant ? board.whites : board.blacks);
  long otherKing=board.kings & (whiteDominant ? board.blacks : board.whites);
  int dominantKingIndex=BitboardUtils.square2Index(dominantKing);
  int pawnIndex=BitboardUtils.square2Index(pawn);
  if ((pawnZone & otherKing) != 0 && BitboardUtils.distance(dominantKingIndex,pawnIndex) >= 1) {
    return Evaluator.DRAW;
  }
  return Evaluator.NO_VALUE;
}"
49671,"public void run(){
  try {
    prepareRun();
    while (true) {
      runStepped();
    }
  }
 catch (  SearchFinishedException ignored) {
  }
  finishRun();
}","public void run(){
  int bestMove=Move.NONE, ponderMove=Move.NONE;
synchronized (searchLock) {
    try {
      prepareRun();
      while (true) {
        runStepped();
      }
    }
 catch (    SearchFinishedException ignored) {
    }
    board.undoMove(initialPly);
    bestMove=globalBestMove;
    ponderMove=globalPonderMove;
    searching=false;
  }
  if (observer != null) {
    observer.bestMove(bestMove,ponderMove);
  }
  if (debug) {
    searchStats();
  }
}"
49672,"private void prepareRun() throws SearchFinishedException {
  startTime=System.currentTimeMillis();
  setSearchLimits(searchParameters,false);
  panicTime=false;
  engineIsWhite=board.getTurn();
  logger.debug(""String_Node_Str"" + board);
  positionCounter=0;
  pvPositionCounter=0;
  qsPositionCounter=0;
  globalBestMove=Move.NONE;
  ponderMove=Move.NONE;
  initialPly=board.getMoveNumber();
  if (config.getUseBook() && config.getBook() != null && board.isUsingBook() && (config.getBookKnowledge() == 100 || ((random.nextFloat() * 100) < config.getBookKnowledge()))) {
    logger.debug(""String_Node_Str"");
    int bookMove=config.getBook().getMove(board);
    if (bookMove != Move.NONE) {
      globalBestMove=bookMove;
      logger.debug(""String_Node_Str"");
      throw new SearchFinishedException();
    }
 else {
      logger.debug(""String_Node_Str"");
      board.setOutBookMove(board.getMoveNumber());
    }
  }
  depth=1;
  boolean foundTT=tt.search(board,0,false);
  if (canUseTT(0,-Evaluator.MATE,Evaluator.MATE)) {
    rootScore=tt.getScore();
  }
 else {
    rootScore=evaluate(foundTT,0);
  }
  tt.newGeneration();
  aspWindows=ASPIRATION_WINDOW_SIZES;
}","private void prepareRun() throws SearchFinishedException {
  startTime=System.currentTimeMillis();
  setSearchLimits(searchParameters,false);
  panicTime=false;
  engineIsWhite=board.getTurn();
  logger.debug(""String_Node_Str"" + board);
  positionCounter=0;
  pvPositionCounter=0;
  qsPositionCounter=0;
  globalBestMove=Move.NONE;
  globalPonderMove=Move.NONE;
  initialPly=board.getMoveNumber();
  if (config.getUseBook() && config.getBook() != null && board.isUsingBook() && (config.getBookKnowledge() == 100 || ((random.nextFloat() * 100) < config.getBookKnowledge()))) {
    logger.debug(""String_Node_Str"");
    int bookMove=config.getBook().getMove(board);
    if (bookMove != Move.NONE) {
      globalBestMove=bookMove;
      logger.debug(""String_Node_Str"");
      throw new SearchFinishedException();
    }
 else {
      logger.debug(""String_Node_Str"");
      board.setOutBookMove(board.getMoveNumber());
    }
  }
  depth=1;
  boolean foundTT=tt.search(board,0,false);
  if (canUseTT(0,-Evaluator.MATE,Evaluator.MATE)) {
    rootScore=tt.getScore();
  }
 else {
    rootScore=evaluate(foundTT,0);
  }
  tt.newGeneration();
  aspWindows=ASPIRATION_WINDOW_SIZES;
}"
49673,"/** 
 * Gets the principal variation from the transposition table
 */
private String getPv(int firstMove){
  if (firstMove == Move.NONE) {
    return ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder();
  List<Long> keys=new ArrayList<>();
  sb.append(Move.toString(firstMove));
  int savedMoveNumber=board.getMoveNumber();
  board.doMove(firstMove,true,false);
  int i=1;
  while (i < 256) {
    if (tt.search(board,i,false)) {
      if (tt.getBestMove() == Move.NONE || keys.contains(board.getKey())) {
        break;
      }
      keys.add(board.getKey());
      if (i == 1) {
        ponderMove=tt.getBestMove();
      }
      sb.append(""String_Node_Str"");
      sb.append(Move.toString(tt.getBestMove()));
      board.doMove(tt.getBestMove(),true,false);
      i++;
      if (board.isMate()) {
        break;
      }
    }
 else {
      break;
    }
  }
  board.undoMove(savedMoveNumber);
  return sb.toString();
}","/** 
 * Gets the principal variation from the transposition table
 */
private String getPv(int firstMove){
  if (firstMove == Move.NONE) {
    return ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder();
  List<Long> keys=new ArrayList<>();
  sb.append(Move.toString(firstMove));
  int savedMoveNumber=board.getMoveNumber();
  board.doMove(firstMove,true,false);
  int i=1;
  while (i < 256) {
    if (tt.search(board,i,false)) {
      if (tt.getBestMove() == Move.NONE || keys.contains(board.getKey())) {
        break;
      }
      keys.add(board.getKey());
      if (i == 1) {
        globalPonderMove=tt.getBestMove();
      }
      sb.append(""String_Node_Str"");
      sb.append(Move.toString(tt.getBestMove()));
      board.doMove(tt.getBestMove(),true,false);
      i++;
      if (board.isMate()) {
        break;
      }
    }
 else {
      break;
    }
  }
  board.undoMove(savedMoveNumber);
  return sb.toString();
}"
49674,"/** 
 * It searches for the best movement
 */
public void go(SearchParameters searchParameters){
  if (initialized && !searching) {
    searching=true;
    setSearchParameters(searchParameters);
    run();
  }
}","/** 
 * It searches for the best movement
 */
public void go(SearchParameters searchParameters){
synchronized (startSearchLock) {
    if (!initialized || searching) {
      return;
    }
    searching=true;
  }
  setSearchParameters(searchParameters);
  run();
}"
49675,"/** 
 * Threaded version
 */
public void go(SearchParameters searchParameters){
  if (initialized && !searching) {
    searching=true;
    setSearchParameters(searchParameters);
    thread=new Thread(this);
    thread.start();
  }
}","/** 
 * Threaded version
 */
public void go(SearchParameters searchParameters){
synchronized (startSearchLock) {
    if (!initialized || searching) {
      return;
    }
    searching=true;
  }
  setSearchParameters(searchParameters);
  thread=new Thread(this);
  thread.start();
}"
49676,"/** 
 * Multiply with negative numbers (in the factor or in one of the oe components) cannot be done directly
 */
public static int oeMul(int factor,int oeValue){
  return (((oeValue >> 16) * factor) << 16) | ((oeValue & 0xffff) * factor) & 0xffff;
}","/** 
 * Multiply with negative numbers (in the factor or in one of the oe components) cannot be done directly
 */
public static int oeMul(int factor,int oeValue){
  return oe((o(oeValue) * factor),e(oeValue) * factor);
}"
49677,"public static int e(int oe){
  return (short)(oe & 0xffff);
}","/** 
 * Get the ""Endgame"" part
 */
public static int e(int oe){
  return (short)(oe & 0xffff);
}"
49678,"/** 
 * Merges two short Opening - Ending values in one int
 */
public static int oe(int opening,int endgame){
  return (opening << 16) | (endgame & 0xffff);
}","/** 
 * Merges two short Opening - Ending values in one int
 */
public static int oe(int opening,int endgame){
  return ((opening < 0 ? opening - 1 : opening) << 16) | (endgame & 0xffff);
}"
49679,"/** 
 * shift right each part by factor positions
 */
public static int oeShr(int factor,int oeValue){
  return (((oeValue >> (16 + factor))) << 16) | ((oeValue & 0xffff) >> factor) & 0xffff;
}","/** 
 * Shift right each part by factor positions
 */
public static int oeShr(int factor,int oeValue){
  return (((oeValue >> (16 + factor))) << 16) | ((oeValue & 0xffff) >> factor) & 0xffff;
}"
49680,"public static int o(int oe){
  return oe >> 16;
}","/** 
 * Get the ""Opening"" part
 */
public static int o(int oe){
  int i=oe >> 16;
  return i < 0 ? i + 1 : i;
}"
49681,"public void setScore(int score,int alpha,int beta){
  this.score=score;
  if (Math.abs(score) == Evaluator.MATE) {
    upperBound=false;
    lowerBound=false;
  }
 else {
    upperBound=score <= alpha;
    lowerBound=score >= beta;
  }
}","public void setScore(int score,int alpha,int beta){
  this.score=score;
  upperBound=score <= alpha;
  lowerBound=score >= beta;
}"
49682,"/** 
 * It does not append + or #
 * @param board
 * @param move
 * @return
 */
public static String toSan(Board board,int move){
  board.generateLegalMoves();
  boolean isLegal=false;
  boolean disambiguate=false;
  boolean fileEqual=false;
  boolean rankEqual=false;
  for (int i=0; i < board.legalMoveCount; i++) {
    int move2=board.legalMoves[i];
    if (move == move2) {
      isLegal=true;
    }
 else     if (getToIndex(move) == getToIndex(move2) && (getPieceMoved(move) == getPieceMoved(move2))) {
      disambiguate=true;
      if ((getFromIndex(move) % 8) == (getFromIndex(move2) % 8)) {
        fileEqual=true;
      }
      if ((getFromIndex(move) / 8) == (getFromIndex(move2) / 8)) {
        rankEqual=true;
      }
    }
  }
  if (move == 0 || move == -1 || !isLegal) {
    return ""String_Node_Str"";
  }
 else   if (Move.getMoveType(move) == TYPE_KINGSIDE_CASTLING) {
    return Move.isCheck(move) ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (Move.getMoveType(move) == TYPE_QUEENSIDE_CASTLING) {
    return Move.isCheck(move) ? ""String_Node_Str"" : ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder();
  if (getPieceMoved(move) != Piece.PAWN) {
    sb.append(PIECE_LETTERS_UPPERCASE.charAt(getPieceMoved(move)));
  }
  String fromSq=BitboardUtils.index2Algebraic(Move.getFromIndex(move));
  if (isCapture(move) && getPieceMoved(move) == Piece.PAWN) {
    disambiguate=true;
  }
  if (disambiguate) {
    if (fileEqual && rankEqual) {
      sb.append(fromSq);
    }
 else     if (fileEqual && !rankEqual) {
      sb.append(fromSq.charAt(1));
    }
 else {
      sb.append(fromSq.charAt(0));
    }
  }
  if (isCapture(move)) {
    sb.append(""String_Node_Str"");
  }
  sb.append(BitboardUtils.index2Algebraic(Move.getToIndex(move)));
  if (isPromotion(move)) {
    sb.append(PIECE_LETTERS_UPPERCASE.charAt(getPiecePromoted(move)));
  }
  if (isCheck(move)) {
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","/** 
 * It does not append + or #
 * @param board
 * @param move
 * @return
 */
public static String toSan(Board board,int move){
  board.generateLegalMoves();
  boolean isLegal=false;
  boolean disambiguate=false;
  boolean fileEqual=false;
  boolean rankEqual=false;
  for (int i=0; i < board.legalMoveCount; i++) {
    int move2=board.legalMoves[i];
    if (move == move2) {
      isLegal=true;
    }
 else     if (getToIndex(move) == getToIndex(move2) && (getPieceMoved(move) == getPieceMoved(move2))) {
      disambiguate=true;
      if ((getFromIndex(move) % 8) == (getFromIndex(move2) % 8)) {
        fileEqual=true;
      }
      if ((getFromIndex(move) / 8) == (getFromIndex(move2) / 8)) {
        rankEqual=true;
      }
    }
  }
  if (move == 0 || move == -1 || !isLegal) {
    return ""String_Node_Str"";
  }
 else   if (Move.getMoveType(move) == TYPE_KINGSIDE_CASTLING) {
    return Move.isCheck(move) ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (Move.getMoveType(move) == TYPE_QUEENSIDE_CASTLING) {
    return Move.isCheck(move) ? ""String_Node_Str"" : ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder();
  if (getPieceMoved(move) != Piece.PAWN) {
    sb.append(PIECE_LETTERS_UPPERCASE.charAt(getPieceMoved(move)));
  }
  String fromSq=BitboardUtils.index2Algebraic(Move.getFromIndex(move));
  if (isCapture(move) && getPieceMoved(move) == Piece.PAWN) {
    disambiguate=true;
  }
  if (disambiguate) {
    if (fileEqual && rankEqual) {
      sb.append(fromSq);
    }
 else     if (fileEqual) {
      sb.append(fromSq.charAt(1));
    }
 else {
      sb.append(fromSq.charAt(0));
    }
  }
  if (isCapture(move)) {
    sb.append(""String_Node_Str"");
  }
  sb.append(BitboardUtils.index2Algebraic(Move.getToIndex(move)));
  if (isPromotion(move)) {
    sb.append(PIECE_LETTERS_UPPERCASE.charAt(getPiecePromoted(move)));
  }
  if (isCheck(move)) {
    sb.append(""String_Node_Str"");
  }
  return sb.toString();
}"
49683,"/** 
 * Gets a random move from the book taking care of weights
 */
public int getMove(Board board);","/** 
 * Gets a random move from the book taking care of weights
 */
int getMove(Board board);"
49684,"public int generateMoves(Board board,int moves[],int index);","int generateMoves(Board board,int moves[],int index);"
49685,"public void bestMove(int bestMove,int ponder);","void bestMove(int bestMove,int ponder);"
49686,public void info(SearchStatusInfo info);,void info(SearchStatusInfo info);
49687,public String standard();,String standard();
49688,public String advanced();,String advanced();
49689,public String about();,String about();
49690,public String blacksVsComputer();,String blacksVsComputer();
49691,public String confirmRestart();,String confirmRestart();
49692,public String redo();,String redo();
49693,public String chess960();,String chess960();
49694,public String aboutTab();,String aboutTab();
49695,public String thinking();,String thinking();
49696,public String fen();,String fen();
49697,public String setFen();,String setFen();
49698,public String computerVsComputer();,String computerVsComputer();
49699,public String mode();,String mode();
49700,public String undo();,String undo();
49701,public String white();,String white();
49702,public String mt10s();,String mt10s();
49703,public String mt30s();,String mt30s();
49704,public String player();,String player();
49705,public String blacksWin();,String blacksWin();
49706,public String whitesVsBlacks();,String whitesVsBlacks();
49707,public String restart();,String restart();
49708,public String userMove();,String userMove();
49709,public String reflectionTime();,String reflectionTime();
49710,public String black();,String black();
49711,public String whitesVsComputer();,String whitesVsComputer();
49712,public String history();,String history();
49713,public String draw();,String draw();
49714,public String mt7s();,String mt7s();
49715,public String confirmYes();,String confirmYes();
49716,public String waitMessage();,String waitMessage();
49717,public String infoTab();,String infoTab();
49718,public String confirmNo();,String confirmNo();
49719,public String mt3s();,String mt3s();
49720,public String settingsTab();,String settingsTab();
49721,public String mt5s();,String mt5s();
49722,public String mt1s();,String mt1s();
49723,public String actions();,String actions();
49724,public String whitesWin();,String whitesWin();
49725,public String mt15s();,String mt15s();
49726,public String status();,String status();
49727,public void doMove(int move);,void doMove(int move);
49728,"@Source(""String_Node_Str"") public ChessCss getCss();","@Source(""String_Node_Str"") ChessCss getCss();"
49729,"@Source(""String_Node_Str"") public TextResource getBoard();","@Source(""String_Node_Str"") TextResource getBoard();"
49730,"public KPKPosition(int idx){
  whiteKingIndex=(idx >>> 0) & 0x3F;
  blackKingIndex=(idx >>> 6) & 0x3F;
  whiteToMove=((idx >>> 12) & 0x01) != 0;
  pawnIndex=7 - ((idx >>> 13) & 0x03) + ((RANK_7 - (idx >>> 15)) << 3);
  result=RESULT_UNKNOWN;
  long blackKingSquare=BitboardUtils.index2Square((byte)blackKingIndex);
  long pawnSquare=BitboardUtils.index2Square((byte)(pawnIndex));
  long pawnAttacks=BitboardAttacks.getInstance().pawnUpwards[pawnIndex];
  long pawnSquareNextRank=BitboardUtils.index2Square((byte)(pawnIndex + 8));
  long whiteKingAttacks=BitboardAttacks.getInstance().king[whiteKingIndex];
  long blackKingAttacks=BitboardAttacks.getInstance().king[blackKingIndex];
  if (BitboardUtils.distance(whiteKingIndex,blackKingIndex) <= 1 || whiteKingIndex == pawnIndex || blackKingIndex == pawnIndex || (whiteToMove && (pawnAttacks & blackKingSquare) != 0)) {
    result=RESULT_INVALID;
  }
 else   if (whiteToMove) {
    if (BitboardUtils.getRankOfIndex(pawnIndex) == RANK_7 && whiteKingIndex != pawnIndex + DELTA_N && ((BitboardUtils.distance(blackKingIndex,pawnIndex + DELTA_N) > 1 || (whiteKingAttacks & pawnSquareNextRank) != 0))) {
      result=RESULT_WIN;
    }
  }
 else   if ((blackKingAttacks & ~(whiteKingAttacks | pawnAttacks)) == 0 || (blackKingAttacks & pawnSquare & ~whiteKingAttacks) != 0) {
    result=RESULT_DRAW;
  }
}","public KPKPosition(int idx){
  whiteKingIndex=idx & 0x3F;
  blackKingIndex=(idx >>> 6) & 0x3F;
  whiteToMove=((idx >>> 12) & 0x01) != 0;
  pawnIndex=7 - ((idx >>> 13) & 0x03) + ((RANK_7 - (idx >>> 15)) << 3);
  result=RESULT_UNKNOWN;
  long blackKingSquare=BitboardUtils.index2Square((byte)blackKingIndex);
  long pawnSquare=BitboardUtils.index2Square((byte)(pawnIndex));
  long pawnAttacks=BitboardAttacks.getInstance().pawnUpwards[pawnIndex];
  long pawnSquareNextRank=BitboardUtils.index2Square((byte)(pawnIndex + 8));
  long whiteKingAttacks=BitboardAttacks.getInstance().king[whiteKingIndex];
  long blackKingAttacks=BitboardAttacks.getInstance().king[blackKingIndex];
  if (BitboardUtils.distance(whiteKingIndex,blackKingIndex) <= 1 || whiteKingIndex == pawnIndex || blackKingIndex == pawnIndex || (whiteToMove && (pawnAttacks & blackKingSquare) != 0)) {
    result=RESULT_INVALID;
  }
 else   if (whiteToMove) {
    if (BitboardUtils.getRankOfIndex(pawnIndex) == RANK_7 && whiteKingIndex != pawnIndex + DELTA_N && ((BitboardUtils.distance(blackKingIndex,pawnIndex + DELTA_N) > 1 || (whiteKingAttacks & pawnSquareNextRank) != 0))) {
      result=RESULT_WIN;
    }
  }
 else   if ((blackKingAttacks & ~(whiteKingAttacks | pawnAttacks)) == 0 || (blackKingAttacks & pawnSquare & ~whiteKingAttacks) != 0) {
    result=RESULT_DRAW;
  }
}"
49731,"void loop(){
  System.out.println(NAME + ""String_Node_Str"" + AUTHOR);
  BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
  try {
    while (true) {
      String in=reader.readLine();
      String[] tokens=in.split(""String_Node_Str"");
      int index=0;
      String command=tokens[index++].toLowerCase();
      if (""String_Node_Str"".equals(command)) {
        System.out.println(""String_Node_Str"" + NAME);
        System.out.println(""String_Node_Str"" + AUTHOR);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_TRANSPOSITION_TABLE_SIZE + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_PONDER);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_USE_BOOK);
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_NULL_MOVE);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_STATIC_NULL_MOVE);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_LMR);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_IID);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_IID_MARGIN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_CHECK + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_PAWN_PUSH + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_PASSED_PAWN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_MATE_THREAT + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_SINGULAR + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_SINGULAR_EXTENSION_MARGIN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVALUATOR + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_ASPIRATION_WINDOW);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_ASPIRATION_WINDOW_SIZES);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_FUTILITY);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_FUTILITY_MARGIN_QS + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_FUTILITY_MARGIN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_FUTILITY_MARGIN_AGGRESSIVE + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_RAZORING);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_RAZORING_MARGIN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_CONTEMPT_FACTOR + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_CENTER + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_POSITIONAL + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_ATTACKS + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_MOBILITY + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_PAWN_STRUCTURE + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_PASSED_PAWNS + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_KING_SAFETY + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_ELO + ""String_Node_Str""+ Config.DEFAULT_ELO);
        System.out.println(""String_Node_Str"");
      }
 else       if (""String_Node_Str"".equals(command)) {
        index++;
        StringBuilder nameSB=new StringBuilder();
        String tok;
        while (!""String_Node_Str"".equals(tok=tokens[index++])) {
          nameSB.append(tok);
        }
        String name=nameSB.toString();
        String value=tokens[index++];
        if (""String_Node_Str"".equals(name)) {
          config.setTranspositionTableSize(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setPonder(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setUseBook(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setUciChess960(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setNullMove(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setStaticNullMove(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setIid(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setIidMargin(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsCheck(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsPawnPush(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsPassedPawn(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsMateThreat(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsSingular(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setSingularExtensionMargin(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvaluator(value);
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setAspirationWindow(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setAspirationWindowSizes(value);
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setFutility(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setFutilityMarginQS(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setFutilityMargin(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setFutilityMarginAggressive(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setRazoring(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setRazoringMargin(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setContemptFactor(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalCenter(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalPositional(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalAttacks(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalMobility(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalPawnStructure(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalPassedPawns(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalKingSafety(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setElo(Integer.parseInt(value));
        }
        needsReload=true;
      }
 else       if (""String_Node_Str"".equals(command)) {
        if (needsReload) {
          engine=new SearchEngineThreaded(config);
          engine.setObserver(this);
          needsReload=false;
          System.gc();
        }
 else {
          while (engine.isSearching()) {
            try {
              Thread.sleep(10);
            }
 catch (            Exception e) {
            }
          }
        }
        System.out.println(""String_Node_Str"");
      }
 else       if (""String_Node_Str"".equals(command)) {
        System.exit(0);
      }
 else       if (""String_Node_Str"".equals(command)) {
        searchParameters=new SearchParameters();
        while (index < tokens.length) {
          String arg1=tokens[index++];
          if (""String_Node_Str"".equals(arg1)) {
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setPonder(true);
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setWtime(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setBtime(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setWinc(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setBinc(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setMovesToGo(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setDepth(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setNodes(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setMate(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setMoveTime(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setInfinite(true);
          }
        }
        engine.go(searchParameters);
      }
 else       if (""String_Node_Str"".equals(command)) {
        engine.stop();
      }
 else       if (""String_Node_Str"".equals(command)) {
        engine.getBoard().startPosition();
        engine.clear();
      }
 else       if (""String_Node_Str"".equals(command)) {
        if (index < tokens.length) {
          String arg1=tokens[index++];
          if (""String_Node_Str"".equals(arg1)) {
            engine.getBoard().startPosition();
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            StringBuilder fenSb=new StringBuilder();
            while (index < tokens.length) {
              if (""String_Node_Str"".equals(tokens[index])) {
                break;
              }
              fenSb.append(tokens[index++]);
              if (index < tokens.length) {
                fenSb.append(""String_Node_Str"");
              }
            }
            engine.getBoard().setFen(fenSb.toString());
          }
        }
        if (index < tokens.length) {
          String arg1=tokens[index++];
          if (""String_Node_Str"".equals(arg1)) {
            while (index < tokens.length) {
              int move=Move.getFromString(engine.getBoard(),tokens[index++],true);
              engine.getBoard().doMove(move);
            }
          }
        }
      }
 else       if (""String_Node_Str"".equals(command)) {
      }
 else       if (""String_Node_Str"".equals(command)) {
        if (searchParameters != null) {
          searchParameters.setPonder(false);
          engine.setSearchLimits(searchParameters,false);
        }
      }
 else       if (""String_Node_Str"".equals(command)) {
      }
 else {
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","void loop(){
  System.out.println(NAME + ""String_Node_Str"" + AUTHOR);
  BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
  try {
    while (true) {
      String in=reader.readLine();
      String[] tokens=in.split(""String_Node_Str"");
      int index=0;
      String command=tokens[index++].toLowerCase();
      if (""String_Node_Str"".equals(command)) {
        System.out.println(""String_Node_Str"" + NAME);
        System.out.println(""String_Node_Str"" + AUTHOR);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_TRANSPOSITION_TABLE_SIZE + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_PONDER);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_USE_BOOK);
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_NULL_MOVE);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_STATIC_NULL_MOVE);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_LMR);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_IID);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_IID_MARGIN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_CHECK + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_PAWN_PUSH + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_PASSED_PAWN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_MATE_THREAT + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EXTENSIONS_SINGULAR + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_SINGULAR_EXTENSION_MARGIN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVALUATOR + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_ASPIRATION_WINDOW);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_ASPIRATION_WINDOW_SIZES);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_FUTILITY);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_FUTILITY_MARGIN_QS + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_FUTILITY_MARGIN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_FUTILITY_MARGIN_AGGRESSIVE + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_RAZORING);
        System.out.println(""String_Node_Str"" + Config.DEFAULT_RAZORING_MARGIN + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_CONTEMPT_FACTOR + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_CENTER + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_POSITIONAL + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_ATTACKS + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_MOBILITY + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_PAWN_STRUCTURE + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_PASSED_PAWNS + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_EVAL_KING_SAFETY + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + Config.DEFAULT_ELO + ""String_Node_Str""+ Config.DEFAULT_ELO);
        System.out.println(""String_Node_Str"");
      }
 else       if (""String_Node_Str"".equals(command)) {
        index++;
        StringBuilder nameSB=new StringBuilder();
        String tok;
        while (!""String_Node_Str"".equals(tok=tokens[index++])) {
          nameSB.append(tok);
        }
        String name=nameSB.toString();
        String value=tokens[index];
        if (""String_Node_Str"".equals(name)) {
          config.setTranspositionTableSize(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setPonder(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setUseBook(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setUciChess960(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setNullMove(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setStaticNullMove(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setIid(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setIidMargin(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsCheck(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsPawnPush(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsPassedPawn(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsMateThreat(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setExtensionsSingular(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setSingularExtensionMargin(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvaluator(value);
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setAspirationWindow(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setAspirationWindowSizes(value);
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setFutility(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setFutilityMarginQS(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setFutilityMargin(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setFutilityMarginAggressive(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setRazoring(Boolean.parseBoolean(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setRazoringMargin(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setContemptFactor(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalCenter(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalPositional(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalAttacks(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalMobility(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalPawnStructure(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalPassedPawns(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setEvalKingSafety(Integer.parseInt(value));
        }
 else         if (""String_Node_Str"".equals(name)) {
          config.setElo(Integer.parseInt(value));
        }
        needsReload=true;
      }
 else       if (""String_Node_Str"".equals(command)) {
        if (needsReload) {
          engine=new SearchEngineThreaded(config);
          engine.setObserver(this);
          needsReload=false;
          System.gc();
        }
 else {
          while (engine.isSearching()) {
            try {
              Thread.sleep(10);
            }
 catch (            Exception e) {
            }
          }
        }
        System.out.println(""String_Node_Str"");
      }
 else       if (""String_Node_Str"".equals(command)) {
        System.exit(0);
      }
 else       if (""String_Node_Str"".equals(command)) {
        searchParameters=new SearchParameters();
        while (index < tokens.length) {
          String arg1=tokens[index++];
          if (""String_Node_Str"".equals(arg1)) {
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setPonder(true);
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setWtime(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setBtime(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setWinc(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setBinc(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setMovesToGo(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setDepth(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setNodes(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setMate(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setMoveTime(Integer.parseInt(tokens[index++]));
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            searchParameters.setInfinite(true);
          }
        }
        engine.go(searchParameters);
      }
 else       if (""String_Node_Str"".equals(command)) {
        engine.stop();
      }
 else       if (""String_Node_Str"".equals(command)) {
        engine.getBoard().startPosition();
        engine.clear();
      }
 else       if (""String_Node_Str"".equals(command)) {
        if (index < tokens.length) {
          String arg1=tokens[index++];
          if (""String_Node_Str"".equals(arg1)) {
            engine.getBoard().startPosition();
          }
 else           if (""String_Node_Str"".equals(arg1)) {
            StringBuilder fenSb=new StringBuilder();
            while (index < tokens.length) {
              if (""String_Node_Str"".equals(tokens[index])) {
                break;
              }
              fenSb.append(tokens[index++]);
              if (index < tokens.length) {
                fenSb.append(""String_Node_Str"");
              }
            }
            engine.getBoard().setFen(fenSb.toString());
          }
        }
        if (index < tokens.length) {
          String arg1=tokens[index++];
          if (""String_Node_Str"".equals(arg1)) {
            while (index < tokens.length) {
              int move=Move.getFromString(engine.getBoard(),tokens[index++],true);
              engine.getBoard().doMove(move);
            }
          }
        }
      }
 else       if (""String_Node_Str"".equals(command)) {
      }
 else       if (""String_Node_Str"".equals(command)) {
        if (searchParameters != null) {
          searchParameters.setPonder(false);
          engine.setSearchLimits(searchParameters,false);
        }
      }
 else       if (""String_Node_Str"".equals(command)) {
      }
 else {
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
49732,"@Test public void testKPpk(){
  String fen=""String_Node_Str"";
  search.getBoard().setFen(fen);
  searchParams=new SearchParameters();
  searchParams.setNodes(30000);
  search.go(searchParams);
  assertTrue(""String_Node_Str"",search.getBestMoveScore() < -ExperimentalEvaluator.QUEEN);
}","@Test public void testKPpk(){
  String fen=""String_Node_Str"";
  search.getBoard().setFen(fen);
  searchParams=new SearchParameters();
  searchParams.setNodes(30000);
  search.go(searchParams);
  assertTrue(""String_Node_Str"",search.getBestMoveScore() < -Config.QUEEN);
}"
49733,"@Test public void testPawnPromotion(){
  fen=""String_Node_Str"";
  board.setFen(fen);
  System.out.print(board.toString());
  assertTrue(""String_Node_Str"",kpkBitbase.probe(board));
  fen=""String_Node_Str"";
  board.setFen(fen);
  System.out.print(board.toString());
  assertTrue(""String_Node_Str"",kpkBitbase.probe(board) == false);
}","@Test public void testPawnPromotion(){
  fen=""String_Node_Str"";
  board.setFen(fen);
  System.out.print(board.toString());
  assertTrue(""String_Node_Str"",kpkBitbase.probe(board));
  fen=""String_Node_Str"";
  board.setFen(fen);
  System.out.print(board.toString());
  assertTrue(""String_Node_Str"",!kpkBitbase.probe(board));
}"
49734,"@Before public void setUp() throws Exception {
  movegen=new MagicMoveGenerator();
  legalMovegen=new LegalMoveGenerator();
  BitboardUtils b=new BitboardUtils();
  b.toString();
  testBoards=new Board[tests.length];
  for (int i=0; i < tests.length; i++) {
    testBoards[i]=new Board();
    testBoards[i].setFen(tests[i]);
  }
}","@Before public void setUp() throws Exception {
  movegen=new MagicMoveGenerator();
  legalMovegen=new LegalMoveGenerator();
  BitboardUtils b=new BitboardUtils();
  testBoards=new Board[tests.length];
  for (int i=0; i < tests.length; i++) {
    testBoards[i]=new Board();
    testBoards[i].setFen(tests[i]);
  }
}"
49735,"@Override public void info(SearchStatusInfo info){
  if (bestMove != search.getBestMove()) {
    bestMove=search.getBestMove();
    solutionTime=(int)info.getTime();
    solutionNodes=info.getNodes();
  }
  boolean found=bestMoves.length > 0 ? false : true;
  for (  int move : bestMoves) {
    if (move == search.getBestMove()) {
      found=true;
      break;
    }
  }
  for (  int move : avoidMoves) {
    if (move == search.getBestMove()) {
      found=false;
      break;
    }
  }
  solutionFound=found;
  if (found) {
    logger.debug(TestColors.ANSI_GREEN + info.toString() + TestColors.ANSI_RESET);
  }
 else {
    logger.debug(TestColors.ANSI_RED + info.toString() + TestColors.ANSI_RESET);
  }
}","@Override public void info(SearchStatusInfo info){
  if (bestMove != search.getBestMove()) {
    bestMove=search.getBestMove();
    solutionTime=(int)info.getTime();
    solutionNodes=info.getNodes();
  }
  boolean found=bestMoves.length <= 0;
  for (  int move : bestMoves) {
    if (move == search.getBestMove()) {
      found=true;
      break;
    }
  }
  for (  int move : avoidMoves) {
    if (move == search.getBestMove()) {
      found=false;
      break;
    }
  }
  solutionFound=found;
  if (found) {
    logger.debug(TestColors.ANSI_GREEN + info.toString() + TestColors.ANSI_RESET);
  }
 else {
    logger.debug(TestColors.ANSI_RED + info.toString() + TestColors.ANSI_RESET);
  }
}"
49736,"public int getPieceIntAt(long square){
  return ((pawns & square) != 0 ? Piece.PAWN : ((queens & square) != 0 ? Piece.QUEEN : ((rooks & square) != 0 ? Piece.ROOK : ((bishops & square) != 0 ? Piece.BISHOP : ((knights & square) != 0 ? Piece.KNIGHT : ((kings & square) != 0 ? Piece.KING : '.'))))));
}","public int getPieceIntAt(long square){
  return ((pawns & square) != 0 ? Piece.PAWN : ((knights & square) != 0 ? Piece.KNIGHT : ((bishops & square) != 0 ? Piece.BISHOP : ((rooks & square) != 0 ? Piece.ROOK : ((queens & square) != 0 ? Piece.QUEEN : ((kings & square) != 0 ? Piece.KING : '.'))))));
}"
49737,"public char getPieceAt(long square){
  char p=((pawns & square) != 0 ? 'p' : ((queens & square) != 0 ? 'q' : ((rooks & square) != 0 ? 'r' : ((bishops & square) != 0 ? 'b' : ((knights & square) != 0 ? 'n' : ((kings & square) != 0 ? 'k' : '.'))))));
  return ((whites & square) != 0 ? Character.toUpperCase(p) : p);
}","public char getPieceAt(long square){
  char p=((pawns & square) != 0 ? 'p' : ((knights & square) != 0 ? 'n' : ((bishops & square) != 0 ? 'b' : ((rooks & square) != 0 ? 'r' : ((queens & square) != 0 ? 'q' : ((kings & square) != 0 ? 'k' : '.'))))));
  return ((whites & square) != 0 ? Character.toUpperCase(p) : p);
}"
49738,"private int evalAttacks(Board board,AttacksInfo ai,int us){
  long pawnAttacks=ai.pawnAttacks[W] & (us == 0 ? board.whites : board.blacks);
  int attacks=PAWN_ATTACKS[Piece.KNIGHT] * BitboardUtils.popCount(pawnAttacks & board.knights) + PAWN_ATTACKS[Piece.BISHOP] * BitboardUtils.popCount(pawnAttacks & board.bishops) + PAWN_ATTACKS[Piece.ROOK] * BitboardUtils.popCount(pawnAttacks & board.rooks) + PAWN_ATTACKS[Piece.QUEEN] * BitboardUtils.popCount(pawnAttacks & board.queens);
  long otherWeak=(us == 0 ? board.blacks : board.whites) & ai.attackedSquares[us] & ~ai.pawnAttacks[1 - us];
  if (otherWeak != 0) {
    long attackedByMinor=otherWeak & (ai.knightAttacks[us] | ai.bishopAttacks[us]);
    while (attackedByMinor != 0) {
      long lsb=BitboardUtils.lsb(attackedByMinor);
      attacks+=MINOR_ATTACKS[board.getPieceIntAt(lsb)];
      attackedByMinor&=~lsb;
    }
    long attackedByMajor=otherWeak & (ai.rookAttacks[us] | ai.queenAttacks[us]);
    while (attackedByMajor != 0) {
      long lsb=BitboardUtils.lsb(attackedByMajor);
      attacks+=MAJOR_ATTACKS[board.getPieceIntAt(lsb)];
      attackedByMajor&=~lsb;
    }
  }
  return attacks;
}","private int evalAttacks(Board board,AttacksInfo ai,int us){
  int attacks=0;
  long others=(us == 0 ? board.blacks : board.whites);
  long attackedByPawn=others & ai.pawnAttacks[us];
  while (attackedByPawn != 0) {
    long lsb=BitboardUtils.lsb(attackedByPawn);
    attacks+=PAWN_ATTACKS[board.getPieceIntAt(lsb)];
    attackedByPawn&=~lsb;
  }
  long otherWeak=others & ai.attackedSquares[us] & ~ai.pawnAttacks[1 - us];
  if (otherWeak != 0) {
    long attackedByMinor=otherWeak & (ai.knightAttacks[us] | ai.bishopAttacks[us]);
    while (attackedByMinor != 0) {
      long lsb=BitboardUtils.lsb(attackedByMinor);
      attacks+=MINOR_ATTACKS[board.getPieceIntAt(lsb)];
      attackedByMinor&=~lsb;
    }
    long attackedByMajor=otherWeak & (ai.rookAttacks[us] | ai.queenAttacks[us]);
    while (attackedByMajor != 0) {
      long lsb=BitboardUtils.lsb(attackedByMajor);
      attacks+=MAJOR_ATTACKS[board.getPieceIntAt(lsb)];
      attackedByMajor&=~lsb;
    }
  }
  long superiorAttacks=others & ai.pawnAttacks[us] & (board.knights | board.bishops | board.rooks| board.queens) | others & (ai.knightAttacks[us] | ai.bishopAttacks[us]) & (board.rooks | board.queens) | others & ai.rookAttacks[us] & board.queens;
  int superiorAttacksCount=BitboardUtils.popCount(superiorAttacks);
  if (superiorAttacksCount >= 2) {
    attacks+=superiorAttacksCount * HUNG_PIECES;
  }
  return attacks;
}"
49739,"public void run(){
  setSearchLimits(searchParameters);
  try {
    newRun();
    while (true) {
      runStepped();
    }
  }
 catch (  SearchFinishedException ignored) {
  }
  finishRun();
}","public void run(){
  try {
    newRun();
    while (true) {
      runStepped();
    }
  }
 catch (  SearchFinishedException ignored) {
  }
  finishRun();
}"
49740,"private void runStepped() throws SearchFinishedException {
  selDepth=0;
  int failHighCount=0;
  int failLowCount=0;
  int initialScore=rootScore;
  int alpha=(initialScore - aspWindows[failLowCount] > -Evaluator.VICTORY ? initialScore - aspWindows[failLowCount] : -Evaluator.VICTORY);
  int beta=(initialScore + aspWindows[failHighCount] < Evaluator.VICTORY ? initialScore + aspWindows[failHighCount] : Evaluator.VICTORY);
  while (true) {
    aspirationWindowProbe++;
    rootScore=search(NODE_ROOT,depth * PLY,alpha,beta,false,0);
    if (rootScore <= alpha) {
      failLowCount++;
      alpha=(failLowCount < aspWindows.length && (initialScore - aspWindows[failLowCount] > -Evaluator.VICTORY) ? initialScore - aspWindows[failLowCount] : -Evaluator.VICTORY);
    }
 else     if (rootScore >= beta) {
      failHighCount++;
      beta=(failHighCount < aspWindows.length && (initialScore + aspWindows[failHighCount] < Evaluator.VICTORY) ? initialScore + aspWindows[failHighCount] : Evaluator.VICTORY);
    }
 else {
      aspirationWindowHit++;
      break;
    }
  }
  if ((thinkToTime != Long.MAX_VALUE) && ((rootScore <= -VALUE_IS_MATE) || (rootScore > VALUE_IS_MATE))) {
    throw new SearchFinishedException();
  }
  depth++;
  if (depth == MAX_DEPTH || depth > thinkToDepth) {
    throw new SearchFinishedException();
  }
}","private void runStepped() throws SearchFinishedException {
  selDepth=0;
  int failHighCount=0;
  int failLowCount=0;
  int initialScore=rootScore;
  int alpha=(initialScore - aspWindows[failLowCount] > -Evaluator.VICTORY ? initialScore - aspWindows[failLowCount] : -Evaluator.VICTORY);
  int beta=(initialScore + aspWindows[failHighCount] < Evaluator.VICTORY ? initialScore + aspWindows[failHighCount] : Evaluator.VICTORY);
  while (true) {
    aspirationWindowProbe++;
    rootScore=search(NODE_ROOT,depth * PLY,alpha,beta,false,0);
    if (rootScore <= alpha) {
      failLowCount++;
      alpha=(failLowCount < aspWindows.length && (initialScore - aspWindows[failLowCount] > -Evaluator.VICTORY) ? initialScore - aspWindows[failLowCount] : -Evaluator.VICTORY);
    }
 else     if (rootScore >= beta) {
      failHighCount++;
      beta=(failHighCount < aspWindows.length && (initialScore + aspWindows[failHighCount] < Evaluator.VICTORY) ? initialScore + aspWindows[failHighCount] : Evaluator.VICTORY);
    }
 else {
      aspirationWindowHit++;
      break;
    }
  }
  if (depth <= 6) {
    notifyMoveFound(globalBestMove,bestMoveScore,alpha,beta);
  }
  depth++;
  if (((thinkToTime != Long.MAX_VALUE) && ((rootScore <= -VALUE_IS_MATE) || (rootScore > VALUE_IS_MATE))) || (depth == MAX_DEPTH) || (depth > thinkToDepth)) {
    throw new SearchFinishedException();
  }
}"
49741,"private void newRun() throws SearchFinishedException {
  foundOneMove=false;
  searching=true;
  logger.debug(""String_Node_Str"" + board);
  positionCounter=0;
  pvPositionCounter=0;
  qsPositionCounter=0;
  globalBestMove=Move.NONE;
  ponderMove=Move.NONE;
  pv=null;
  initialPly=board.getMoveNumber();
  if (config.getUseBook() && config.getBook() != null && board.isUsingBook() && (config.getBookKnowledge() == 100 || ((random.nextFloat() * 100) < config.getBookKnowledge()))) {
    logger.debug(""String_Node_Str"");
    int bookMove=config.getBook().getMove(board);
    if (bookMove != 0) {
      globalBestMove=bookMove;
      logger.debug(""String_Node_Str"");
      throw new SearchFinishedException();
    }
 else {
      logger.debug(""String_Node_Str"");
      board.setOutBookMove(board.getMoveNumber());
    }
  }
  depth=1;
  rootScore=evaluate(tt.search(board,0,false),0);
  tt.newGeneration();
  aspWindows=config.getAspirationWindowSizes();
}","private void newRun() throws SearchFinishedException {
  startTime=System.currentTimeMillis();
  setSearchLimits(searchParameters);
  foundOneMove=false;
  searching=true;
  logger.debug(""String_Node_Str"" + board);
  positionCounter=0;
  pvPositionCounter=0;
  qsPositionCounter=0;
  globalBestMove=Move.NONE;
  ponderMove=Move.NONE;
  pv=null;
  initialPly=board.getMoveNumber();
  if (config.getUseBook() && config.getBook() != null && board.isUsingBook() && (config.getBookKnowledge() == 100 || ((random.nextFloat() * 100) < config.getBookKnowledge()))) {
    logger.debug(""String_Node_Str"");
    int bookMove=config.getBook().getMove(board);
    if (bookMove != 0) {
      globalBestMove=bookMove;
      logger.debug(""String_Node_Str"");
      throw new SearchFinishedException();
    }
 else {
      logger.debug(""String_Node_Str"");
      board.setOutBookMove(board.getMoveNumber());
    }
  }
  depth=1;
  rootScore=evaluate(tt.search(board,0,false),0);
  tt.newGeneration();
  aspWindows=config.getAspirationWindowSizes();
}"
49742,"public void setSearchLimits(SearchParameters searchParameters){
  startTime=System.currentTimeMillis();
  thinkToNodes=searchParameters.getNodes();
  thinkToDepth=searchParameters.getDepth();
  thinkToTime=searchParameters.calculateMoveTime(board,startTime);
}","public void setSearchLimits(SearchParameters searchParameters){
  thinkToNodes=searchParameters.getNodes();
  thinkToDepth=searchParameters.getDepth();
  thinkToTime=searchParameters.calculateMoveTime(board,startTime);
}"
49743,"/** 
 * The SWAP algorithm https://chessprogramming.wikispaces.com/SEE+-+The+Swap+Algorithm
 */
public int see(int fromIndex,int toIndex,int pieceMoved,int targetPiece){
  int d=0;
  long mayXray=pawns | bishops | rooks| queens;
  long fromSquare=0x1L << fromIndex;
  long all=getAll();
  long attacks=bbAttacks.getIndexAttacks(this,toIndex);
  long fromCandidates;
  seeGain[d]=SEE_PIECE_VALUES[targetPiece];
  do {
    long side=(d & 1) == 0 ? getOthers() : getMines();
    d++;
    seeGain[d]=SEE_PIECE_VALUES[pieceMoved] - seeGain[d - 1];
    if (Math.max(-seeGain[d - 1],seeGain[d]) < 0)     break;
    attacks^=fromSquare;
    all^=fromSquare;
    if ((fromSquare & mayXray) != 0) {
      attacks|=bbAttacks.getXrayAttacks(this,toIndex,all);
    }
    if ((fromCandidates=attacks & pawns & side) != 0) {
      pieceMoved=Move.PAWN;
    }
 else     if ((fromCandidates=attacks & knights & side) != 0) {
      pieceMoved=Move.KNIGHT;
    }
 else     if ((fromCandidates=attacks & bishops & side) != 0) {
      pieceMoved=Move.BISHOP;
    }
 else     if ((fromCandidates=attacks & rooks & side) != 0) {
      pieceMoved=Move.ROOK;
    }
 else     if ((fromCandidates=attacks & queens & side) != 0) {
      pieceMoved=Move.QUEEN;
    }
 else     if ((fromCandidates=attacks & kings & side) != 0) {
      pieceMoved=Move.KING;
    }
    fromSquare=BitboardUtils.lsb(fromCandidates);
  }
 while (fromSquare != 0);
  while (--d != 0) {
    seeGain[d - 1]=-Math.max(-seeGain[d - 1],seeGain[d]);
  }
  return seeGain[0];
}","/** 
 * The SWAP algorithm https://chessprogramming.wikispaces.com/SEE+-+The+Swap+Algorithm
 */
public int see(int fromIndex,int toIndex,int pieceMoved,int targetPiece){
  int d=0;
  long mayXray=pawns | bishops | rooks| queens;
  long fromSquare=0x1L << fromIndex;
  long all=getAll();
  long attacks=bbAttacks.getIndexAttacks(this,toIndex);
  long fromCandidates;
  seeGain[d]=SEE_PIECE_VALUES[targetPiece];
  do {
    long side=(d & 1) == 0 ? getOthers() : getMines();
    d++;
    seeGain[d]=SEE_PIECE_VALUES[pieceMoved] - seeGain[d - 1];
    attacks^=fromSquare;
    all^=fromSquare;
    if ((fromSquare & mayXray) != 0) {
      attacks|=bbAttacks.getXrayAttacks(this,toIndex,all);
    }
    if ((fromCandidates=attacks & pawns & side) != 0) {
      pieceMoved=Move.PAWN;
    }
 else     if ((fromCandidates=attacks & knights & side) != 0) {
      pieceMoved=Move.KNIGHT;
    }
 else     if ((fromCandidates=attacks & bishops & side) != 0) {
      pieceMoved=Move.BISHOP;
    }
 else     if ((fromCandidates=attacks & rooks & side) != 0) {
      pieceMoved=Move.ROOK;
    }
 else     if ((fromCandidates=attacks & queens & side) != 0) {
      pieceMoved=Move.QUEEN;
    }
 else     if ((fromCandidates=attacks & kings & side) != 0) {
      pieceMoved=Move.KING;
    }
    fromSquare=BitboardUtils.lsb(fromCandidates);
  }
 while (fromSquare != 0);
  while (--d != 0) {
    seeGain[d - 1]=-Math.max(-seeGain[d - 1],seeGain[d]);
  }
  return seeGain[0];
}"
49744,"@Test public void test4(){
  String fen=""String_Node_Str"";
  Board board=new Board();
  board.setFen(fen);
  System.out.print(board);
  int move=Move.getFromString(board,""String_Node_Str"",true);
  int value=board.see(Move.getFromIndex(move),Move.getToIndex(move),Move.getPieceMoved(move),Move.PAWN);
  System.out.println(""String_Node_Str"" + value);
  assertTrue(value == -225);
}","@Test public void test4(){
  testSee(""String_Node_Str"",""String_Node_Str"",-225);
}"
49745,"@Test public void testNoOtherPiecesAttack(){
  String fen=""String_Node_Str"";
  Board board=new Board();
  board.setFen(fen);
  System.out.print(board);
  int move=Move.getFromString(board,""String_Node_Str"",true);
  System.out.println(Move.getFromIndex(move));
  int value=board.see(Move.getFromIndex(move),Move.getToIndex(move),Move.getPieceMoved(move),Move.PAWN);
  System.out.println(""String_Node_Str"" + value);
  assertTrue(value == 100);
}","@Test public void testNoOtherPiecesAttack(){
  testSee(""String_Node_Str"",""String_Node_Str"",100);
}"
49746,"@Test public void test2(){
  String fen=""String_Node_Str"";
  Board board=new Board();
  board.setFen(fen);
  System.out.print(board);
  int move=Move.getFromString(board,""String_Node_Str"",true);
  int value=board.see(Move.getFromIndex(move),Move.getToIndex(move),Move.getPieceMoved(move),Move.ROOK);
  System.out.println(""String_Node_Str"" + value);
  assertTrue(value == 0);
}","@Test public void test2(){
  testSee(""String_Node_Str"",""String_Node_Str"",0);
}"
49747,"@Test public void test3(){
  String fen=""String_Node_Str"";
  Board board=new Board();
  board.setFen(fen);
  System.out.print(board);
  int move=Move.getFromString(board,""String_Node_Str"",true);
  int value=board.see(Move.getFromIndex(move),Move.getToIndex(move),Move.getPieceMoved(move),Move.ROOK);
  System.out.println(""String_Node_Str"" + value);
  assertTrue(value == 330);
}","@Test public void test3(){
  testSee(""String_Node_Str"",""String_Node_Str"",330);
}"
49748,"@Test public void test1(){
  String fen=""String_Node_Str"";
  Board board=new Board();
  board.setFen(fen);
  System.out.print(board);
  int move=Move.getFromString(board,""String_Node_Str"",true);
  System.out.println(""String_Node_Str"" + Move.toStringExt(move));
  int value=board.see(Move.getFromIndex(move),Move.getToIndex(move),Move.getPieceMoved(move),Move.PAWN);
  System.out.println(""String_Node_Str"" + value);
  assertTrue(value == 100);
}","@Test public void test1(){
  testSee(""String_Node_Str"",""String_Node_Str"",100);
}"
49749,"public int see(int fromIndex,int toIndex,int pieceMoved,int targetPiece){
  int d=0;
  long mayXray=pawns | bishops | rooks| queens;
  long fromSquare=1 << fromIndex;
  long all=getAll();
  long attacks=bbAttacks.getIndexAttacks(this,toIndex);
  long fromCandidates;
  seeGain[d]=SEE_PIECE_VALUES[targetPiece];
  do {
    long side=(d & 1) == 0 ? getOthers() : getMines();
    d++;
    seeGain[d]=SEE_PIECE_VALUES[pieceMoved] - seeGain[d - 1];
    attacks^=fromSquare;
    all^=fromSquare;
    if ((fromSquare & mayXray) != 0) {
      attacks|=bbAttacks.getXrayAttacks(this,toIndex,all);
    }
    if ((fromCandidates=attacks & pawns & side) != 0) {
      pieceMoved=Move.PAWN;
    }
 else     if ((fromCandidates=attacks & knights & side) != 0) {
      pieceMoved=Move.KNIGHT;
    }
 else     if ((fromCandidates=attacks & bishops & side) != 0) {
      pieceMoved=Move.BISHOP;
    }
 else     if ((fromCandidates=attacks & rooks & side) != 0) {
      pieceMoved=Move.ROOK;
    }
 else     if ((fromCandidates=attacks & queens & side) != 0) {
      pieceMoved=Move.QUEEN;
    }
 else     if ((fromCandidates=attacks & kings & side) != 0) {
      pieceMoved=Move.KING;
    }
    fromSquare=BitboardUtils.lsb(fromCandidates);
  }
 while (fromSquare != 0);
  while (--d != 0) {
    seeGain[d - 1]=-Math.max(-seeGain[d - 1],seeGain[d]);
  }
  return seeGain[0];
}","/** 
 * The SWAP algorithm https://chessprogramming.wikispaces.com/SEE+-+The+Swap+Algorithm
 */
public int see(int fromIndex,int toIndex,int pieceMoved,int targetPiece){
  int d=0;
  long mayXray=pawns | bishops | rooks| queens;
  long fromSquare=0x1L << fromIndex;
  long all=getAll();
  long attacks=bbAttacks.getIndexAttacks(this,toIndex);
  long fromCandidates;
  seeGain[d]=SEE_PIECE_VALUES[targetPiece];
  do {
    long side=(d & 1) == 0 ? getOthers() : getMines();
    d++;
    seeGain[d]=SEE_PIECE_VALUES[pieceMoved] - seeGain[d - 1];
    if (Math.max(-seeGain[d - 1],seeGain[d]) < 0) {
      break;
    }
    attacks^=fromSquare;
    all^=fromSquare;
    if ((fromSquare & mayXray) != 0) {
      attacks|=bbAttacks.getXrayAttacks(this,toIndex,all);
    }
    if ((fromCandidates=attacks & pawns & side) != 0) {
      pieceMoved=Move.PAWN;
    }
 else     if ((fromCandidates=attacks & knights & side) != 0) {
      pieceMoved=Move.KNIGHT;
    }
 else     if ((fromCandidates=attacks & bishops & side) != 0) {
      pieceMoved=Move.BISHOP;
    }
 else     if ((fromCandidates=attacks & rooks & side) != 0) {
      pieceMoved=Move.ROOK;
    }
 else     if ((fromCandidates=attacks & queens & side) != 0) {
      pieceMoved=Move.QUEEN;
    }
 else     if ((fromCandidates=attacks & kings & side) != 0) {
      pieceMoved=Move.KING;
    }
    fromSquare=BitboardUtils.lsb(fromCandidates);
  }
 while (fromSquare != 0);
  while (--d != 0) {
    seeGain[d - 1]=-Math.max(-seeGain[d - 1],seeGain[d]);
  }
  return seeGain[0];
}"
49750,"/** 
 * The SWAP algorithm https://chessprogramming.wikispaces.com/SEE+-+The+Swap+Algorithm
 */
public int see(int fromIndex,int toIndex,int pieceMoved,int targetPiece){
  int d=0;
  long mayXray=pawns | bishops | rooks| queens;
  long fromSquare=1 << fromIndex;
  long all=getAll();
  long attacks=bbAttacks.getIndexAttacks(this,toIndex);
  long fromCandidates;
  seeGain[d]=SEE_PIECE_VALUES[targetPiece];
  do {
    long side=(d & 1) == 0 ? getOthers() : getMines();
    d++;
    seeGain[d]=SEE_PIECE_VALUES[pieceMoved] - seeGain[d - 1];
    attacks^=fromSquare;
    all^=fromSquare;
    if ((fromSquare & mayXray) != 0) {
      attacks|=bbAttacks.getXrayAttacks(this,toIndex,all);
    }
    if ((fromCandidates=attacks & pawns & side) != 0) {
      pieceMoved=Move.PAWN;
    }
 else     if ((fromCandidates=attacks & knights & side) != 0) {
      pieceMoved=Move.KNIGHT;
    }
 else     if ((fromCandidates=attacks & bishops & side) != 0) {
      pieceMoved=Move.BISHOP;
    }
 else     if ((fromCandidates=attacks & rooks & side) != 0) {
      pieceMoved=Move.ROOK;
    }
 else     if ((fromCandidates=attacks & queens & side) != 0) {
      pieceMoved=Move.QUEEN;
    }
 else     if ((fromCandidates=attacks & kings & side) != 0) {
      pieceMoved=Move.KING;
    }
    fromSquare=BitboardUtils.lsb(fromCandidates);
  }
 while (fromSquare != 0);
  while (--d != 0) {
    seeGain[d - 1]=-Math.max(-seeGain[d - 1],seeGain[d]);
  }
  return seeGain[0];
}","/** 
 * The SWAP algorithm https://chessprogramming.wikispaces.com/SEE+-+The+Swap+Algorithm
 */
public int see(int fromIndex,int toIndex,int pieceMoved,int targetPiece){
  int d=0;
  long mayXray=pawns | bishops | rooks| queens;
  long fromSquare=0x1L << fromIndex;
  long all=getAll();
  long attacks=bbAttacks.getIndexAttacks(this,toIndex);
  long fromCandidates;
  seeGain[d]=SEE_PIECE_VALUES[targetPiece];
  do {
    long side=(d & 1) == 0 ? getOthers() : getMines();
    d++;
    seeGain[d]=SEE_PIECE_VALUES[pieceMoved] - seeGain[d - 1];
    if (Math.max(-seeGain[d - 1],seeGain[d]) < 0)     break;
    attacks^=fromSquare;
    all^=fromSquare;
    if ((fromSquare & mayXray) != 0) {
      attacks|=bbAttacks.getXrayAttacks(this,toIndex,all);
    }
    if ((fromCandidates=attacks & pawns & side) != 0) {
      pieceMoved=Move.PAWN;
    }
 else     if ((fromCandidates=attacks & knights & side) != 0) {
      pieceMoved=Move.KNIGHT;
    }
 else     if ((fromCandidates=attacks & bishops & side) != 0) {
      pieceMoved=Move.BISHOP;
    }
 else     if ((fromCandidates=attacks & rooks & side) != 0) {
      pieceMoved=Move.ROOK;
    }
 else     if ((fromCandidates=attacks & queens & side) != 0) {
      pieceMoved=Move.QUEEN;
    }
 else     if ((fromCandidates=attacks & kings & side) != 0) {
      pieceMoved=Move.KING;
    }
    fromSquare=BitboardUtils.lsb(fromCandidates);
  }
 while (fromSquare != 0);
  while (--d != 0) {
    seeGain[d - 1]=-Math.max(-seeGain[d - 1],seeGain[d]);
  }
  return seeGain[0];
}"
49751,"/** 
 * in UCI format TODO complete
 */
public String toString(){
  StringBuilder sb=new StringBuilder();
  if (depth != 0) {
    sb.append(""String_Node_Str"");
    sb.append(depth);
  }
  if (selDepth != 0) {
    sb.append(""String_Node_Str"");
    sb.append(selDepth);
  }
  if (scoreMate != null) {
    sb.append(""String_Node_Str"");
    sb.append(scoreMate);
  }
 else   if (scoreCp != null) {
    sb.append(""String_Node_Str"");
    sb.append(scoreCp);
    if (lowerBound) {
      sb.append(""String_Node_Str"");
    }
 else     if (upperBound) {
      sb.append(""String_Node_Str"");
    }
  }
  if (nodes != 0) {
    sb.append(""String_Node_Str"");
    sb.append(nodes);
  }
  if (time != 0) {
    sb.append(""String_Node_Str"");
    sb.append(time);
  }
  if (hashFull != 0) {
    sb.append(""String_Node_Str"");
    sb.append(hashFull);
  }
  if (nps != 0) {
    sb.append(""String_Node_Str"");
    sb.append(nps);
  }
  if (pv != null) {
    sb.append(""String_Node_Str"");
    sb.append(pv);
  }
  return sb.toString();
}","/** 
 * in UCI format TODO complete
 */
public String toString(){
  StringBuilder sb=new StringBuilder();
  if (depth != 0) {
    sb.append(""String_Node_Str"");
    sb.append(depth);
  }
  if (selDepth != 0) {
    sb.append(""String_Node_Str"");
    sb.append(selDepth);
  }
  if ((score < -SearchEngine.VALUE_IS_MATE) || (score > SearchEngine.VALUE_IS_MATE)) {
    sb.append(""String_Node_Str"");
    int x=(score < 0 ? -Evaluator.VICTORY : Evaluator.VICTORY) - score;
    if ((x & 1) != 0) {
      sb.append((x >> 1) + 1);
    }
 else {
      sb.append(x >> 1);
    }
  }
 else {
    sb.append(""String_Node_Str"");
    sb.append(score);
  }
  if (lowerBound) {
    sb.append(""String_Node_Str"");
  }
 else   if (upperBound) {
    sb.append(""String_Node_Str"");
  }
  if (nodes != 0) {
    sb.append(""String_Node_Str"");
    sb.append(nodes);
  }
  if (time != 0) {
    sb.append(""String_Node_Str"");
    sb.append(time);
  }
  if (hashFull != 0) {
    sb.append(""String_Node_Str"");
    sb.append(hashFull);
  }
  if (nps != 0) {
    sb.append(""String_Node_Str"");
    sb.append(nps);
  }
  if (pv != null) {
    sb.append(""String_Node_Str"");
    sb.append(pv);
  }
  return sb.toString();
}"
49752,"public void setScore(int score,int alpha,int beta){
  if ((score < -SearchEngine.VALUE_IS_MATE) || (score > SearchEngine.VALUE_IS_MATE)) {
    int x=(score < 0 ? -Evaluator.VICTORY : Evaluator.VICTORY) - score;
    if ((x & 1) != 0) {
      scoreMate=(x >> 1) + 1;
    }
 else {
      scoreMate=x >> 1;
    }
  }
 else {
    scoreCp=score;
  }
  upperBound=score <= alpha;
  lowerBound=score >= beta;
}","public void setScore(int score,int alpha,int beta){
  this.score=score;
  upperBound=score <= alpha;
  lowerBound=score >= beta;
}"
49753,"public int generateMoves(Board board,int[] moves,int mIndex){
  this.moves=moves;
  bbAttacks=BitboardAttacks.getInstance();
  moveIndex=mIndex;
  all=board.getAll();
  mines=board.getMines();
  others=board.getOthers();
  byte index=0;
  long square=0x1L;
  while (square != 0) {
    if (board.getTurn() == ((square & board.whites) != 0)) {
      if ((square & board.rooks) != 0) {
        generateMovesFromAttacks(Move.ROOK,index,bbAttacks.getRookAttacks(index,all));
      }
 else       if ((square & board.bishops) != 0) {
        generateMovesFromAttacks(Move.BISHOP,index,bbAttacks.getBishopAttacks(index,all));
      }
 else       if ((square & board.queens) != 0) {
        generateMovesFromAttacks(Move.QUEEN,index,bbAttacks.getRookAttacks(index,all));
        generateMovesFromAttacks(Move.QUEEN,index,bbAttacks.getBishopAttacks(index,all));
      }
 else       if ((square & board.kings) != 0) {
        generateMovesFromAttacks(Move.KING,index,bbAttacks.king[index]);
      }
 else       if ((square & board.knights) != 0) {
        generateMovesFromAttacks(Move.KNIGHT,index,bbAttacks.knight[index]);
      }
 else       if ((square & board.pawns) != 0) {
        if ((square & board.whites) != 0) {
          if (((square << 8) & all) == 0) {
            addMoves(Move.PAWN,index,index + 8,(square << 8),false,true,0);
            if (((square & BitboardUtils.b2_d) != 0) && (((square << 16) & all) == 0))             addMoves(Move.PAWN,index,index + 16,(square << 16),false,false,0);
          }
          generatePawnCapturesFromAttacks(index,bbAttacks.pawnUpwards[index],board.getPassantSquare());
        }
 else {
          if (((square >>> 8) & all) == 0) {
            addMoves(Move.PAWN,index,index - 8,(square >>> 8),false,true,0);
            if (((square & BitboardUtils.b2_u) != 0) && (((square >>> 16) & all) == 0))             addMoves(Move.PAWN,index,index - 16,(square >>> 16),false,false,0);
          }
          generatePawnCapturesFromAttacks(index,bbAttacks.pawnDownwards[index],board.getPassantSquare());
        }
      }
    }
    square<<=1;
    index++;
  }
  square=board.kings & mines;
  byte myKingIndex=-1;
  if ((((all & (board.getTurn() ? 0x06L : 0x0600000000000000L)) == 0 && (board.getTurn() ? board.getWhiteKingsideCastling() : board.getBlackKingsideCastling())))) {
    myKingIndex=BitboardUtils.square2Index(square);
    if (!board.getCheck() && !bbAttacks.isIndexAttacked(board,(byte)(myKingIndex - 1),board.getTurn()) && !bbAttacks.isIndexAttacked(board,(byte)(myKingIndex - 2),board.getTurn()))     addMoves(Move.KING,myKingIndex,myKingIndex - 2,0,false,false,Move.TYPE_KINGSIDE_CASTLING);
  }
  if ((((all & (board.getTurn() ? 0x70L : 0x7000000000000000L)) == 0 && (board.getTurn() ? board.getWhiteQueensideCastling() : board.getBlackQueensideCastling())))) {
    if (myKingIndex == -1) {
      myKingIndex=BitboardUtils.square2Index(square);
    }
    if (!board.getCheck() && !bbAttacks.isIndexAttacked(board,(byte)(myKingIndex + 1),board.getTurn()) && !bbAttacks.isIndexAttacked(board,(byte)(myKingIndex + 2),board.getTurn()))     addMoves(Move.KING,myKingIndex,myKingIndex + 2,0,false,false,Move.TYPE_QUEENSIDE_CASTLING);
  }
  return moveIndex;
}","public int generateMoves(Board board,int[] moves,int mIndex){
  this.moves=moves;
  bbAttacks=BitboardAttacks.getInstance();
  moveIndex=mIndex;
  all=board.getAll();
  mines=board.getMines();
  others=board.getOthers();
  byte index=0;
  long square=0x1L;
  while (square != 0) {
    if (board.getTurn() == ((square & board.whites) != 0)) {
      if ((square & board.rooks) != 0) {
        generateMovesFromAttacks(Move.ROOK,index,bbAttacks.getRookAttacks(index,all));
      }
 else       if ((square & board.bishops) != 0) {
        generateMovesFromAttacks(Move.BISHOP,index,bbAttacks.getBishopAttacks(index,all));
      }
 else       if ((square & board.queens) != 0) {
        generateMovesFromAttacks(Move.QUEEN,index,bbAttacks.getRookAttacks(index,all));
        generateMovesFromAttacks(Move.QUEEN,index,bbAttacks.getBishopAttacks(index,all));
      }
 else       if ((square & board.kings) != 0) {
        generateMovesFromAttacks(Move.KING,index,bbAttacks.king[index]);
      }
 else       if ((square & board.knights) != 0) {
        generateMovesFromAttacks(Move.KNIGHT,index,bbAttacks.knight[index]);
      }
 else       if ((square & board.pawns) != 0) {
        if ((square & board.whites) != 0) {
          if (((square << 8) & all) == 0) {
            addMoves(Move.PAWN,index,index + 8,(square << 8),false,true,0);
            if (((square & BitboardUtils.b2_d) != 0) && (((square << 16) & all) == 0))             addMoves(Move.PAWN,index,index + 16,(square << 16),false,false,0);
          }
          generatePawnCapturesFromAttacks(index,bbAttacks.pawnUpwards[index],board.getPassantSquare());
        }
 else {
          if (((square >>> 8) & all) == 0) {
            addMoves(Move.PAWN,index,index - 8,(square >>> 8),false,true,0);
            if (((square & BitboardUtils.b2_u) != 0) && (((square >>> 16) & all) == 0))             addMoves(Move.PAWN,index,index - 16,(square >>> 16),false,false,0);
          }
          generatePawnCapturesFromAttacks(index,bbAttacks.pawnDownwards[index],board.getPassantSquare());
        }
      }
    }
    square<<=1;
    index++;
  }
  square=board.kings & mines;
  int myKingIndex=-1;
  if ((((all & (board.getTurn() ? 0x06L : 0x0600000000000000L)) == 0 && (board.getTurn() ? board.getWhiteKingsideCastling() : board.getBlackKingsideCastling())))) {
    myKingIndex=BitboardUtils.square2Index(square);
    if (!board.getCheck() && !bbAttacks.isIndexAttacked(board,(byte)(myKingIndex - 1),board.getTurn()) && !bbAttacks.isIndexAttacked(board,(byte)(myKingIndex - 2),board.getTurn()))     addMoves(Move.KING,myKingIndex,myKingIndex - 2,0,false,false,Move.TYPE_KINGSIDE_CASTLING);
  }
  if ((((all & (board.getTurn() ? 0x70L : 0x7000000000000000L)) == 0 && (board.getTurn() ? board.getWhiteQueensideCastling() : board.getBlackQueensideCastling())))) {
    if (myKingIndex == -1) {
      myKingIndex=BitboardUtils.square2Index(square);
    }
    if (!board.getCheck() && !bbAttacks.isIndexAttacked(board,(byte)(myKingIndex + 1),board.getTurn()) && !bbAttacks.isIndexAttacked(board,(byte)(myKingIndex + 2),board.getTurn()))     addMoves(Move.KING,myKingIndex,myKingIndex + 2,0,false,false,Move.TYPE_QUEENSIDE_CASTLING);
  }
  return moveIndex;
}"
49754,"public void newRun() throws SearchFinishedException {
  startTime=System.currentTimeMillis();
  foundOneMove=false;
  searching=true;
  logger.debug(""String_Node_Str"" + board);
  positionCounter=0;
  pvPositionCounter=0;
  qsPositionCounter=0;
  bestMoveTime=0;
  globalBestMove=0;
  ponderMove=0;
  pv=null;
  initialPly=board.getMoveNumber();
  thinkToTime=Long.MAX_VALUE;
  thinkToNodes=Long.MAX_VALUE;
  thinkToDepth=Long.MAX_VALUE;
  long moveTime=searchParameters.calculateMoveTime(board);
  if (moveTime > 0) {
    thinkToTime=startTime + moveTime;
  }
  if (searchParameters.getNodes() > 0) {
    thinkToNodes=searchParameters.getNodes();
  }
  if (searchParameters.getDepth() > 0) {
    thinkToDepth=searchParameters.getDepth();
  }
  if (config.getUseBook() && config.getBook() != null && board.isUsingBook() && (config.getBookKnowledge() == 100 || ((random.nextFloat() * 100) < config.getBookKnowledge()))) {
    logger.debug(""String_Node_Str"");
    int bookMove=config.getBook().getMove(board);
    if (bookMove != 0) {
      globalBestMove=bookMove;
      logger.debug(""String_Node_Str"");
      throw new SearchFinishedException();
    }
 else {
      logger.debug(""String_Node_Str"");
      board.setOutBookMove(board.getMoveNumber());
    }
  }
  depth=1;
  score=eval(false,false);
  tt.newGeneration();
  aspWindows=config.getAspirationWindowSizes();
}","public void newRun() throws SearchFinishedException {
  startTime=System.currentTimeMillis();
  foundOneMove=false;
  searching=true;
  logger.debug(""String_Node_Str"" + board);
  positionCounter=0;
  pvPositionCounter=0;
  qsPositionCounter=0;
  bestMoveTime=0;
  globalBestMove=0;
  ponderMove=0;
  pv=null;
  initialPly=board.getMoveNumber();
  thinkToTime=Long.MAX_VALUE;
  thinkToNodes=Long.MAX_VALUE;
  thinkToDepth=Long.MAX_VALUE;
  boolean searchLimitSet=false;
  if (searchParameters.getNodes() > 0) {
    thinkToNodes=searchParameters.getNodes();
    searchLimitSet=true;
  }
  if (searchParameters.getDepth() > 0) {
    thinkToDepth=searchParameters.getDepth();
    searchLimitSet=true;
  }
  long moveTime=searchParameters.calculateMoveTime(board);
  if (moveTime > 0 || !searchLimitSet) {
    thinkToTime=startTime + moveTime;
  }
  if (config.getUseBook() && config.getBook() != null && board.isUsingBook() && (config.getBookKnowledge() == 100 || ((random.nextFloat() * 100) < config.getBookKnowledge()))) {
    logger.debug(""String_Node_Str"");
    int bookMove=config.getBook().getMove(board);
    if (bookMove != 0) {
      globalBestMove=bookMove;
      logger.debug(""String_Node_Str"");
      throw new SearchFinishedException();
    }
 else {
      logger.debug(""String_Node_Str"");
      board.setOutBookMove(board.getMoveNumber());
    }
  }
  depth=1;
  score=eval(false,false);
  tt.newGeneration();
  aspWindows=config.getAspirationWindowSizes();
}"
49755,"public int quiescentSearch(int qsdepth,int alpha,int beta) throws SearchFinishedException {
  if (System.currentTimeMillis() > thinkTo && foundOneMove) {
    throw new SearchFinishedException();
  }
  qsPositionCounter++;
  if (board.isDraw()) {
    return evaluateDraw();
  }
  int eval=-Evaluator.VICTORY;
  int score;
  boolean pv=beta - alpha > 1;
  ttProbe++;
  boolean foundTT=tt.search(board,false);
  if (foundTT) {
    if (!pv && canUseTT(0,alpha,beta)) {
      return tt.getScore();
    }
  }
  if (!board.getCheck()) {
    eval=eval(foundTT,true);
    if (eval >= beta) {
      return eval;
    }
    if (eval > alpha) {
      alpha=eval;
    }
  }
  if (board.getMoveNumber() - initialPly >= MAX_DEPTH) {
    System.out.println(""String_Node_Str"" + qsdepth);
    System.out.println(board.toString());
    for (int i=0; i < board.getMoveNumber(); i++) {
      System.out.println(Move.toStringExt(board.moveHistory[i]));
    }
    return eval;
  }
  boolean validOperations=false;
  boolean checkEvasion=board.getCheck();
  boolean generateChecks=pv && (qsdepth == 0);
  MoveIterator moveIterator=moveIterators[board.getMoveNumber() - initialPly];
  moveIterator.genMoves(0,true,generateChecks);
  int move;
  while ((move=moveIterator.next()) != 0) {
    if (board.doMove(move,false)) {
      validOperations=true;
      if (!board.getCheck() && !checkEvasion && !Move.isPromotion(move)&& !Move.isPawnPush(move)&& !pv&& (((board.queens | board.rooks) & board.getMines()) != 0 || (BitboardUtils.popCount(board.bishops | board.knights) & board.getMines()) > 1)) {
        int futilityValue=eval + lastCapturedPieceValue(board) + config.getFutilityMarginQS();
        if (futilityValue < alpha) {
          board.undoMove();
          continue;
        }
      }
      if (!checkEvasion && !(board.getCheck() && generateChecks) && moveIterator.getPhase() > MoveIterator.PHASE_GOOD_CAPTURES_AND_PROMOS) {
        board.undoMove();
        continue;
      }
      score=-quiescentSearch(qsdepth + 1,-beta,-alpha);
      board.undoMove();
      if (score > alpha) {
        alpha=score;
        if (score >= beta) {
          break;
        }
      }
    }
  }
  if (board.getCheck() && !validOperations) {
    return valueMatedIn(board.getMoveNumber() - initialPly);
  }
  return alpha;
}","public int quiescentSearch(int qsdepth,int alpha,int beta) throws SearchFinishedException {
  if (System.currentTimeMillis() > thinkTo && foundOneMove) {
    throw new SearchFinishedException();
  }
  qsPositionCounter++;
  if (board.isDraw()) {
    return evaluateDraw();
  }
  int eval=-Evaluator.VICTORY;
  int score;
  boolean pv=beta - alpha > 1;
  ttProbe++;
  boolean foundTT=tt.search(board,false);
  if (foundTT) {
    if (!pv && canUseTT(0,alpha,beta)) {
      return tt.getScore();
    }
  }
  if (!board.getCheck()) {
    eval=eval(foundTT,true);
    if (eval >= beta) {
      return eval;
    }
    if (eval > alpha) {
      alpha=eval;
    }
  }
  if (board.getMoveNumber() - initialPly >= MAX_DEPTH) {
    System.out.println(""String_Node_Str"" + qsdepth);
    System.out.println(board.toString());
    for (int i=0; i < board.getMoveNumber(); i++) {
      System.out.print(Move.toStringExt(board.moveHistory[i]));
      System.out.print(""String_Node_Str"");
    }
    System.out.println();
    return eval;
  }
  boolean validOperations=false;
  boolean checkEvasion=board.getCheck();
  boolean generateChecks=pv && (qsdepth == 0);
  MoveIterator moveIterator=moveIterators[board.getMoveNumber() - initialPly];
  moveIterator.genMoves(0,true,generateChecks);
  int move;
  while ((move=moveIterator.next()) != 0) {
    if (board.doMove(move,false)) {
      validOperations=true;
      if (!board.getCheck() && !checkEvasion && !Move.isPromotion(move)&& !Move.isPawnPush(move)&& !pv&& (((board.queens | board.rooks) & board.getMines()) != 0 || (BitboardUtils.popCount(board.bishops | board.knights) & board.getMines()) > 1)) {
        int futilityValue=eval + lastCapturedPieceValue(board) + config.getFutilityMarginQS();
        if (futilityValue < alpha) {
          board.undoMove();
          continue;
        }
      }
      if (!checkEvasion && !(board.getCheck() && generateChecks) && moveIterator.getPhase() > MoveIterator.PHASE_GOOD_CAPTURES_AND_PROMOS) {
        board.undoMove();
        continue;
      }
      score=-quiescentSearch(qsdepth + 1,-beta,-alpha);
      board.undoMove();
      if (score > alpha) {
        alpha=score;
        if (score >= beta) {
          break;
        }
      }
    }
  }
  if (board.getCheck() && !validOperations) {
    return valueMatedIn(board.getMoveNumber() - initialPly);
  }
  return alpha;
}"
49756,"/** 
 * Search Root, PV and null window
 */
public int search(int nodeType,int depthRemaining,int alpha,int beta,boolean allowNullMove,int excludedMove) throws SearchFinishedException {
  if (System.currentTimeMillis() > thinkTo && foundOneMove) {
    throw new SearchFinishedException();
  }
  if (nodeType == NODE_PV || nodeType == NODE_ROOT) {
    pvPositionCounter++;
  }
 else {
    positionCounter++;
  }
  if (board.isDraw()) {
    return evaluateDraw();
  }
  alpha=Math.max(valueMatedIn(board.getMoveNumber() - initialPly),alpha);
  beta=Math.min(valueMateIn(board.getMoveNumber() - initialPly + 1),beta);
  if (alpha >= beta) {
    return alpha;
  }
  int ttMove=0;
  int ttScore=0;
  int score=0;
  ttProbe++;
  boolean foundTT=tt.search(board,excludedMove != 0);
  if (foundTT) {
    if (nodeType != NODE_ROOT && canUseTT(depthRemaining,alpha,beta)) {
      return tt.getScore();
    }
    ttMove=tt.getBestMove();
    ttScore=tt.getScore();
  }
  if (depthRemaining < PLY) {
    return quiescentSearch(0,alpha,beta);
  }
  int eval=-Evaluator.VICTORY;
  if (!board.getCheck()) {
    eval=eval(foundTT,true);
  }
  if (nodeType == NODE_NULL && config.getRazoring() && !board.getCheck() && ttMove == 0 && allowNullMove && depthRemaining < RAZOR_DEPTH && !valueIsMate(beta) && eval < beta - config.getRazoringMargin() && (board.pawns & ((board.whites & BitboardUtils.b2_u) | (board.blacks & BitboardUtils.b2_d))) == 0) {
    razoringProbe++;
    int rbeta=beta - config.getRazoringMargin();
    int v=quiescentSearch(0,rbeta - 1,rbeta);
    if (v < rbeta) {
      razoringHit++;
      return v;
    }
  }
  if (nodeType == NODE_NULL && config.getStaticNullMove() && allowNullMove && boardAllowNullMove() && depthRemaining < RAZOR_DEPTH && !valueIsMate(beta) && eval >= beta + config.getFutilityMargin()) {
    return eval - config.getFutilityMargin();
  }
  boolean mateThreat=false;
  if (nodeType == NODE_NULL && config.getNullMove() && allowNullMove && boardAllowNullMove() && depthRemaining > 3 * PLY && !valueIsMate(beta) && eval > beta - (depthRemaining >= 4 * PLY ? config.getNullMoveMargin() : 0)) {
    nullMoveProbe++;
    board.doMove(0,false);
    int R=3 * PLY + (depthRemaining >= 5 * PLY ? depthRemaining / (4 * PLY) : 0);
    if (eval - beta > CompleteEvaluator.PAWN) {
      R++;
    }
    score=-search(NODE_NULL,depthRemaining - R,-beta,-beta + 1,false,0);
    board.undoMove();
    if (score >= beta) {
      if (valueIsMate(score)) {
        score=beta;
      }
      if (depthRemaining < 6 * PLY || search(NODE_NULL,depthRemaining - 5 * PLY,beta - 1,beta,false,0) >= beta) {
        nullMoveHit++;
        return score;
      }
    }
 else {
      if (score < (-Evaluator.VICTORY + 100)) {
        mateThreat=true;
      }
    }
  }
  if (config.getIid() && ttMove == 0 && depthRemaining >= iidDepth[nodeType] && allowNullMove && !board.getCheck() && (nodeType != NODE_NULL || eval > beta - config.getIidMargin()) && excludedMove == 0) {
    int d=(nodeType == NODE_PV ? depthRemaining - 2 * PLY : depthRemaining >> 1);
    search(nodeType,d,alpha,beta,true,0);
    if (tt.search(board,false)) {
      ttMove=tt.getBestMove();
    }
  }
  boolean singularMoveExtension=nodeType != NODE_ROOT && ttMove != 0 && config.getExtensionsSingular() > 0 && depthRemaining >= singularMoveDepth[nodeType] && tt.getNodeType() == TranspositionTable.TYPE_FAIL_HIGH && tt.getDepthAnalyzed() >= depthRemaining - 3 * PLY && Math.abs(ttScore) < Evaluator.KNOWN_WIN;
  boolean futilityPrune=false;
  if (nodeType == NODE_NULL && !board.getCheck()) {
    if (depthRemaining <= PLY) {
      if (config.getFutility() && eval < beta - config.getFutilityMargin()) {
        futilityHit++;
        futilityPrune=true;
      }
    }
 else     if (depthRemaining <= 2 * PLY) {
      if (config.getAggressiveFutility() && eval < beta - config.getAggressiveFutilityMargin()) {
        aggressiveFutilityHit++;
        futilityPrune=true;
      }
    }
  }
  MoveIterator moveIterator=moveIterators[board.getMoveNumber() - initialPly];
  moveIterator.genMoves(ttMove);
  int movesDone=0;
  boolean validOperations=false;
  boolean checkEvasion=board.getCheck();
  int bestScore=-Evaluator.VICTORY;
  int move, bestMove=0;
  while ((move=moveIterator.next()) != 0) {
    int extension=0;
    int reduction=0;
    if (board.doMove(move,false)) {
      validOperations=true;
      if (move == excludedMove) {
        board.undoMove();
        continue;
      }
      extension+=extensions(move,mateThreat);
      if (singularMoveExtension && move == ttMove && extension < PLY && excludedMove == 0) {
        singularExtensionProbe++;
        board.undoMove();
        int seBeta=ttScore - config.getSingularExtensionMargin();
        int excScore=search(nodeType,depthRemaining >> 1,seBeta - 1,seBeta,false,move);
        board.doMove(move);
        if (excScore < seBeta) {
          singularExtensionHit++;
          extension+=config.getExtensionsSingular();
          if (extension > PLY) {
            extension=PLY;
          }
        }
      }
      boolean importantMove=nodeType == NODE_ROOT || extension != 0 || Move.isCapture(move) || Move.isPromotion(move) || Move.isCastling(move) || checkEvasion || move == ttMove || sortInfo.isKiller(move,board.getMoveNumber() - initialPly);
      if (futilityPrune && bestScore > -Evaluator.KNOWN_WIN && !importantMove) {
        board.undoMove();
        continue;
      }
      if (config.getLmr() && depthRemaining >= LMR_DEPTHS_NOT_REDUCED && !importantMove) {
        reduction+=getReduction(nodeType,depthRemaining,movesDone);
      }
      movesDone++;
      int lowBound=(alpha > bestScore ? alpha : bestScore);
      if ((nodeType == NODE_PV || nodeType == NODE_ROOT) && movesDone == 1) {
        score=-search(NODE_PV,depthRemaining + extension - PLY,-beta,-lowBound,true,0);
      }
 else {
        boolean doFullSearch=true;
        if (reduction > 0) {
          score=-search(NODE_NULL,depthRemaining - reduction - PLY,-lowBound - 1,-lowBound,true,0);
          doFullSearch=(score > lowBound);
        }
        if (doFullSearch) {
          score=-search(NODE_NULL,depthRemaining + extension - PLY,-lowBound - 1,-lowBound,true,0);
          if ((nodeType == NODE_PV || nodeType == NODE_ROOT) && score > lowBound && (nodeType == NODE_ROOT || score < beta)) {
            score=-search(NODE_PV,depthRemaining + extension - PLY,-beta,-lowBound,true,0);
          }
        }
      }
      board.undoMove();
      if (score > bestScore && (nodeType != NODE_ROOT || config.getRand() == 0 || (random.nextInt(100) > config.getRand()))) {
        bestMove=move;
        bestScore=score;
      }
      if (score >= beta) {
        break;
      }
    }
  }
  if (excludedMove == 0 && !validOperations) {
    bestScore=evaluateEndgame();
  }
  if (bestScore >= beta) {
    if (excludedMove == 0) {
      sortInfo.betaCutoff(bestMove,board.getMoveNumber() - initialPly);
    }
    if (nodeType == NODE_NULL) {
      nullCutNodes++;
    }
 else {
      pvCutNodes++;
    }
  }
 else {
    if (nodeType == NODE_NULL) {
      nullAllNodes++;
    }
 else {
      pvAllNodes++;
    }
  }
  tt.save(board,(byte)depthRemaining,bestMove,bestScore,alpha,beta,excludedMove != 0);
  return bestScore;
}","/** 
 * Search Root, PV and null window
 */
public int search(int nodeType,int depthRemaining,int alpha,int beta,boolean allowNullMove,int excludedMove) throws SearchFinishedException {
  if (System.currentTimeMillis() > thinkTo && foundOneMove) {
    throw new SearchFinishedException();
  }
  if (nodeType == NODE_PV || nodeType == NODE_ROOT) {
    pvPositionCounter++;
  }
 else {
    positionCounter++;
  }
  if (board.isDraw()) {
    return evaluateDraw();
  }
  alpha=Math.max(valueMatedIn(board.getMoveNumber() - initialPly),alpha);
  beta=Math.min(valueMateIn(board.getMoveNumber() - initialPly + 1),beta);
  if (alpha >= beta) {
    return alpha;
  }
  int ttMove=0;
  int ttScore=0;
  int score=0;
  ttProbe++;
  boolean foundTT=tt.search(board,excludedMove != 0);
  if (foundTT) {
    if (nodeType != NODE_ROOT && canUseTT(depthRemaining,alpha,beta)) {
      return tt.getScore();
    }
    ttMove=tt.getBestMove();
    ttScore=tt.getScore();
  }
  if (depthRemaining < PLY || board.getMoveNumber() - initialPly >= MAX_DEPTH - 1) {
    return quiescentSearch(0,alpha,beta);
  }
  int eval=-Evaluator.VICTORY;
  if (!board.getCheck()) {
    eval=eval(foundTT,true);
  }
  if (nodeType == NODE_NULL && config.getRazoring() && !board.getCheck() && ttMove == 0 && allowNullMove && depthRemaining < RAZOR_DEPTH && !valueIsMate(beta) && eval < beta - config.getRazoringMargin() && (board.pawns & ((board.whites & BitboardUtils.b2_u) | (board.blacks & BitboardUtils.b2_d))) == 0) {
    razoringProbe++;
    int rbeta=beta - config.getRazoringMargin();
    int v=quiescentSearch(0,rbeta - 1,rbeta);
    if (v < rbeta) {
      razoringHit++;
      return v;
    }
  }
  if (nodeType == NODE_NULL && config.getStaticNullMove() && allowNullMove && boardAllowNullMove() && depthRemaining < RAZOR_DEPTH && !valueIsMate(beta) && eval >= beta + config.getFutilityMargin()) {
    return eval - config.getFutilityMargin();
  }
  boolean mateThreat=false;
  if (nodeType == NODE_NULL && config.getNullMove() && allowNullMove && boardAllowNullMove() && depthRemaining > 3 * PLY && !valueIsMate(beta) && eval > beta - (depthRemaining >= 4 * PLY ? config.getNullMoveMargin() : 0)) {
    nullMoveProbe++;
    board.doMove(0,false);
    int R=3 * PLY + (depthRemaining >= 5 * PLY ? depthRemaining / (4 * PLY) : 0);
    if (eval - beta > CompleteEvaluator.PAWN) {
      R++;
    }
    score=-search(NODE_NULL,depthRemaining - R,-beta,-beta + 1,false,0);
    board.undoMove();
    if (score >= beta) {
      if (valueIsMate(score)) {
        score=beta;
      }
      if (depthRemaining < 6 * PLY || search(NODE_NULL,depthRemaining - 5 * PLY,beta - 1,beta,false,0) >= beta) {
        nullMoveHit++;
        return score;
      }
    }
 else {
      if (score < (-Evaluator.VICTORY + 100)) {
        mateThreat=true;
      }
    }
  }
  if (config.getIid() && ttMove == 0 && depthRemaining >= iidDepth[nodeType] && allowNullMove && !board.getCheck() && (nodeType != NODE_NULL || eval > beta - config.getIidMargin()) && excludedMove == 0) {
    int d=(nodeType == NODE_PV ? depthRemaining - 2 * PLY : depthRemaining >> 1);
    search(nodeType,d,alpha,beta,true,0);
    if (tt.search(board,false)) {
      ttMove=tt.getBestMove();
    }
  }
  boolean singularMoveExtension=nodeType != NODE_ROOT && ttMove != 0 && config.getExtensionsSingular() > 0 && depthRemaining >= singularMoveDepth[nodeType] && tt.getNodeType() == TranspositionTable.TYPE_FAIL_HIGH && tt.getDepthAnalyzed() >= depthRemaining - 3 * PLY && Math.abs(ttScore) < Evaluator.KNOWN_WIN;
  boolean futilityPrune=false;
  if (nodeType == NODE_NULL && !board.getCheck()) {
    if (depthRemaining <= PLY) {
      if (config.getFutility() && eval < beta - config.getFutilityMargin()) {
        futilityHit++;
        futilityPrune=true;
      }
    }
 else     if (depthRemaining <= 2 * PLY) {
      if (config.getAggressiveFutility() && eval < beta - config.getAggressiveFutilityMargin()) {
        aggressiveFutilityHit++;
        futilityPrune=true;
      }
    }
  }
  MoveIterator moveIterator=moveIterators[board.getMoveNumber() - initialPly];
  moveIterator.genMoves(ttMove);
  int movesDone=0;
  boolean validOperations=false;
  boolean checkEvasion=board.getCheck();
  int bestScore=-Evaluator.VICTORY;
  int move, bestMove=0;
  while ((move=moveIterator.next()) != 0) {
    int extension=0;
    int reduction=0;
    if (board.doMove(move,false)) {
      validOperations=true;
      if (move == excludedMove) {
        board.undoMove();
        continue;
      }
      extension+=extensions(move,mateThreat);
      if (singularMoveExtension && move == ttMove && extension < PLY && excludedMove == 0) {
        singularExtensionProbe++;
        board.undoMove();
        int seBeta=ttScore - config.getSingularExtensionMargin();
        int excScore=search(nodeType,depthRemaining >> 1,seBeta - 1,seBeta,false,move);
        board.doMove(move);
        if (excScore < seBeta) {
          singularExtensionHit++;
          extension+=config.getExtensionsSingular();
          if (extension > PLY) {
            extension=PLY;
          }
        }
      }
      boolean importantMove=nodeType == NODE_ROOT || extension != 0 || Move.isCapture(move) || Move.isPromotion(move) || Move.isCastling(move) || checkEvasion || move == ttMove || sortInfo.isKiller(move,board.getMoveNumber() - initialPly);
      if (futilityPrune && bestScore > -Evaluator.KNOWN_WIN && !importantMove) {
        board.undoMove();
        continue;
      }
      if (config.getLmr() && depthRemaining >= LMR_DEPTHS_NOT_REDUCED && !importantMove) {
        reduction+=getReduction(nodeType,depthRemaining,movesDone);
      }
      movesDone++;
      int lowBound=(alpha > bestScore ? alpha : bestScore);
      if ((nodeType == NODE_PV || nodeType == NODE_ROOT) && movesDone == 1) {
        score=-search(NODE_PV,depthRemaining + extension - PLY,-beta,-lowBound,true,0);
      }
 else {
        boolean doFullSearch=true;
        if (reduction > 0) {
          score=-search(NODE_NULL,depthRemaining - reduction - PLY,-lowBound - 1,-lowBound,true,0);
          doFullSearch=(score > lowBound);
        }
        if (doFullSearch) {
          score=-search(NODE_NULL,depthRemaining + extension - PLY,-lowBound - 1,-lowBound,true,0);
          if ((nodeType == NODE_PV || nodeType == NODE_ROOT) && score > lowBound && (nodeType == NODE_ROOT || score < beta)) {
            score=-search(NODE_PV,depthRemaining + extension - PLY,-beta,-lowBound,true,0);
          }
        }
      }
      board.undoMove();
      if (score > bestScore && (nodeType != NODE_ROOT || config.getRand() == 0 || (random.nextInt(100) > config.getRand()))) {
        bestMove=move;
        bestScore=score;
      }
      if (score >= beta) {
        break;
      }
    }
  }
  if (excludedMove == 0 && !validOperations) {
    bestScore=evaluateEndgame();
  }
  if (bestScore >= beta) {
    if (excludedMove == 0) {
      sortInfo.betaCutoff(bestMove,board.getMoveNumber() - initialPly);
    }
    if (nodeType == NODE_NULL) {
      nullCutNodes++;
    }
 else {
      pvCutNodes++;
    }
  }
 else {
    if (nodeType == NODE_NULL) {
      nullAllNodes++;
    }
 else {
      pvAllNodes++;
    }
  }
  tt.save(board,(byte)depthRemaining,bestMove,bestScore,alpha,beta,excludedMove != 0);
  return bestScore;
}"
49757,"/** 
 * Accepts any new connections and reads or writes any pending data for the current connections.
 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to returnimmediately if there are no connections to process. 
 */
public void update(int timeout) throws IOException {
  updateThread=Thread.currentThread();
synchronized (updateLock) {
  }
  long startTime=System.currentTimeMillis();
  int select=0;
  if (timeout > 0) {
    select=selector.select(timeout);
  }
 else {
    select=selector.selectNow();
  }
  System.out.println(select);
  if (select == 0) {
    long elapsedTime=System.currentTimeMillis() - startTime;
    try {
      if (elapsedTime < 25)       Thread.sleep(25 - elapsedTime);
    }
 catch (    InterruptedException ex) {
    }
  }
 else {
    Set<SelectionKey> keys=selector.selectedKeys();
synchronized (keys) {
      UdpConnection udp=this.udp;
      outer:       for (Iterator<SelectionKey> iter=keys.iterator(); iter.hasNext(); ) {
        SelectionKey selectionKey=iter.next();
        iter.remove();
        try {
          int ops=selectionKey.readyOps();
          Connection fromConnection=(Connection)selectionKey.attachment();
          if (fromConnection != null) {
            if (udp != null && fromConnection.udpRemoteAddress == null) {
              fromConnection.close();
              continue;
            }
            if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
              try {
                while (true) {
                  Object object=fromConnection.tcp.readObject(fromConnection);
                  if (object == null)                   break;
                  if (DEBUG) {
                    String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
                    if (!(object instanceof FrameworkMessage)) {
                      debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                    }
 else                     if (TRACE) {
                      trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                    }
                  }
                  fromConnection.notifyReceived(object);
                }
              }
 catch (              IOException ex) {
                if (TRACE) {
                  trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                }
 else                 if (DEBUG) {
                  debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
                }
                fromConnection.close();
              }
catch (              KryoNetException ex) {
                if (ERROR)                 error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                fromConnection.close();
              }
            }
            if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
              try {
                fromConnection.tcp.writeOperation();
              }
 catch (              IOException ex) {
                if (TRACE) {
                  trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                }
 else                 if (DEBUG) {
                  debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
                }
                fromConnection.close();
              }
            }
            continue;
          }
          if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
            ServerSocketChannel serverChannel=this.serverChannel;
            if (serverChannel == null)             continue;
            try {
              SocketChannel socketChannel=serverChannel.accept();
              if (socketChannel != null)               acceptOperation(socketChannel);
            }
 catch (            IOException ex) {
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"",ex);
            }
            continue;
          }
          if (udp == null)           continue;
          InetSocketAddress fromAddress;
          try {
            fromAddress=udp.readFromAddress();
          }
 catch (          IOException ex) {
            if (WARN)             warn(""String_Node_Str"",""String_Node_Str"",ex);
            continue;
          }
          if (fromAddress == null)           continue;
          Connection[] connections=this.connections;
          for (int i=0, n=connections.length; i < n; i++) {
            Connection connection=connections[i];
            if (fromAddress.equals(connection.udpRemoteAddress)) {
              fromConnection=connection;
              break;
            }
          }
          Object object;
          try {
            object=udp.readObject(fromConnection);
          }
 catch (          KryoNetException ex) {
            if (WARN) {
              if (fromConnection != null) {
                if (ERROR)                 error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
              }
 else               warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
            }
            continue;
          }
          if (object instanceof FrameworkMessage) {
            if (object instanceof RegisterUDP) {
              int fromConnectionID=((RegisterUDP)object).connectionID;
              Connection connection=pendingConnections.remove(fromConnectionID);
              if (connection != null) {
                if (connection.udpRemoteAddress != null)                 continue outer;
                connection.udpRemoteAddress=fromAddress;
                addConnection(connection);
                connection.sendTCP(new RegisterUDP());
                if (DEBUG)                 debug(""String_Node_Str"",""String_Node_Str"" + udp.datagramChannel.socket().getLocalPort() + ""String_Node_Str""+ fromAddress);
                connection.notifyConnected();
                continue;
              }
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"" + fromConnectionID);
              continue;
            }
            if (object instanceof DiscoverHost) {
              try {
                udp.datagramChannel.send(emptyBuffer,fromAddress);
                if (DEBUG)                 debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
              }
 catch (              IOException ex) {
                if (WARN)                 warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
              }
              continue;
            }
          }
          if (fromConnection != null) {
            if (DEBUG) {
              String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
              if (object instanceof FrameworkMessage) {
                if (TRACE)                 trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
              }
 else               debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
            }
            fromConnection.notifyReceived(object);
            continue;
          }
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
        }
 catch (        CancelledKeyException ignored) {
        }
      }
    }
  }
  long time=System.currentTimeMillis();
  Connection[] connections=this.connections;
  for (int i=0, n=connections.length; i < n; i++) {
    Connection connection=connections[i];
    if (connection.tcp.isTimedOut(time)) {
      if (DEBUG)       debug(""String_Node_Str"",connection + ""String_Node_Str"");
      connection.close();
    }
 else {
      if (connection.tcp.needsKeepAlive(time))       connection.sendTCP(FrameworkMessage.keepAlive);
    }
    if (connection.isIdle())     connection.notifyIdle();
  }
}","/** 
 * Accepts any new connections and reads or writes any pending data for the current connections.
 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to returnimmediately if there are no connections to process. 
 */
public void update(int timeout) throws IOException {
  updateThread=Thread.currentThread();
synchronized (updateLock) {
  }
  long startTime=System.currentTimeMillis();
  int select=0;
  if (timeout > 0) {
    select=selector.select(timeout);
  }
 else {
    select=selector.selectNow();
  }
  System.out.println(select);
  if (select == 0) {
    long elapsedTime=System.currentTimeMillis() - startTime;
    try {
      if (elapsedTime < 25)       Thread.sleep(25 - elapsedTime);
    }
 catch (    InterruptedException ex) {
    }
  }
 else {
    Set<SelectionKey> keys=selector.selectedKeys();
synchronized (keys) {
      UdpConnection udp=this.udp;
      outer:       for (Iterator<SelectionKey> iter=keys.iterator(); iter.hasNext(); ) {
        SelectionKey selectionKey=iter.next();
        iter.remove();
        Connection fromConnection=(Connection)selectionKey.attachment();
        try {
          int ops=selectionKey.readyOps();
          if (fromConnection != null) {
            if (udp != null && fromConnection.udpRemoteAddress == null) {
              fromConnection.close();
              continue;
            }
            if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
              try {
                while (true) {
                  Object object=fromConnection.tcp.readObject(fromConnection);
                  if (object == null)                   break;
                  if (DEBUG) {
                    String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
                    if (!(object instanceof FrameworkMessage)) {
                      debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                    }
 else                     if (TRACE) {
                      trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                    }
                  }
                  fromConnection.notifyReceived(object);
                }
              }
 catch (              IOException ex) {
                if (TRACE) {
                  trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                }
 else                 if (DEBUG) {
                  debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
                }
                fromConnection.close();
              }
catch (              KryoNetException ex) {
                if (ERROR)                 error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                fromConnection.close();
              }
            }
            if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
              try {
                fromConnection.tcp.writeOperation();
              }
 catch (              IOException ex) {
                if (TRACE) {
                  trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                }
 else                 if (DEBUG) {
                  debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
                }
                fromConnection.close();
              }
            }
            continue;
          }
          if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
            ServerSocketChannel serverChannel=this.serverChannel;
            if (serverChannel == null)             continue;
            try {
              SocketChannel socketChannel=serverChannel.accept();
              if (socketChannel != null)               acceptOperation(socketChannel);
            }
 catch (            IOException ex) {
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"",ex);
            }
            continue;
          }
          if (udp == null) {
            selectionKey.channel().close();
            continue;
          }
          InetSocketAddress fromAddress;
          try {
            fromAddress=udp.readFromAddress();
          }
 catch (          IOException ex) {
            if (WARN)             warn(""String_Node_Str"",""String_Node_Str"",ex);
            continue;
          }
          if (fromAddress == null)           continue;
          Connection[] connections=this.connections;
          for (int i=0, n=connections.length; i < n; i++) {
            Connection connection=connections[i];
            if (fromAddress.equals(connection.udpRemoteAddress)) {
              fromConnection=connection;
              break;
            }
          }
          Object object;
          try {
            object=udp.readObject(fromConnection);
          }
 catch (          KryoNetException ex) {
            if (WARN) {
              if (fromConnection != null) {
                if (ERROR)                 error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
              }
 else               warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
            }
            continue;
          }
          if (object instanceof FrameworkMessage) {
            if (object instanceof RegisterUDP) {
              int fromConnectionID=((RegisterUDP)object).connectionID;
              Connection connection=pendingConnections.remove(fromConnectionID);
              if (connection != null) {
                if (connection.udpRemoteAddress != null)                 continue outer;
                connection.udpRemoteAddress=fromAddress;
                addConnection(connection);
                connection.sendTCP(new RegisterUDP());
                if (DEBUG)                 debug(""String_Node_Str"",""String_Node_Str"" + udp.datagramChannel.socket().getLocalPort() + ""String_Node_Str""+ fromAddress);
                connection.notifyConnected();
                continue;
              }
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"" + fromConnectionID);
              continue;
            }
            if (object instanceof DiscoverHost) {
              try {
                udp.datagramChannel.send(emptyBuffer,fromAddress);
                if (DEBUG)                 debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
              }
 catch (              IOException ex) {
                if (WARN)                 warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
              }
              continue;
            }
          }
          if (fromConnection != null) {
            if (DEBUG) {
              String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
              if (object instanceof FrameworkMessage) {
                if (TRACE)                 trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
              }
 else               debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
            }
            fromConnection.notifyReceived(object);
            continue;
          }
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
        }
 catch (        CancelledKeyException ex) {
          if (fromConnection != null)           fromConnection.close();
 else           selectionKey.channel().close();
        }
      }
    }
  }
  long time=System.currentTimeMillis();
  Connection[] connections=this.connections;
  for (int i=0, n=connections.length; i < n; i++) {
    Connection connection=connections[i];
    if (connection.tcp.isTimedOut(time)) {
      if (DEBUG)       debug(""String_Node_Str"",connection + ""String_Node_Str"");
      connection.close();
    }
 else {
      if (connection.tcp.needsKeepAlive(time))       connection.sendTCP(FrameworkMessage.keepAlive);
    }
    if (connection.isIdle())     connection.notifyIdle();
  }
}"
49758,"public void connect(Selector selector,SocketAddress remoteAddress,int timeout) throws IOException {
  close();
  writeBuffer.clear();
  readBuffer.clear();
  readBuffer.flip();
  currentObjectLength=0;
  try {
    SocketChannel socketChannel=selector.provider().openSocketChannel();
    Socket socket=socketChannel.socket();
    socket.setTcpNoDelay(true);
    socket.setTrafficClass(IPTOS_LOWDELAY);
    socket.connect(remoteAddress,timeout);
    socketChannel.configureBlocking(false);
    this.socketChannel=socketChannel;
    selectionKey=socketChannel.register(selector,SelectionKey.OP_READ);
    selectionKey.attach(this);
    if (DEBUG) {
      debug(""String_Node_Str"",""String_Node_Str"" + socketChannel.socket().getLocalPort() + ""String_Node_Str""+ socketChannel.socket().getRemoteSocketAddress());
    }
    lastReadTime=lastWriteTime=System.currentTimeMillis();
  }
 catch (  IOException ex) {
    close();
    IOException ioEx=new IOException(""String_Node_Str"" + remoteAddress);
    ioEx.initCause(ex);
    throw ioEx;
  }
}","public void connect(Selector selector,SocketAddress remoteAddress,int timeout) throws IOException {
  close();
  writeBuffer.clear();
  readBuffer.clear();
  readBuffer.flip();
  currentObjectLength=0;
  try {
    SocketChannel socketChannel=selector.provider().openSocketChannel();
    Socket socket=socketChannel.socket();
    socket.setTcpNoDelay(true);
    socket.connect(remoteAddress,timeout);
    socketChannel.configureBlocking(false);
    this.socketChannel=socketChannel;
    selectionKey=socketChannel.register(selector,SelectionKey.OP_READ);
    selectionKey.attach(this);
    if (DEBUG) {
      debug(""String_Node_Str"",""String_Node_Str"" + socketChannel.socket().getLocalPort() + ""String_Node_Str""+ socketChannel.socket().getRemoteSocketAddress());
    }
    lastReadTime=lastWriteTime=System.currentTimeMillis();
  }
 catch (  IOException ex) {
    close();
    IOException ioEx=new IOException(""String_Node_Str"" + remoteAddress);
    ioEx.initCause(ex);
    throw ioEx;
  }
}"
49759,"/** 
 * Accepts any new connections and reads or writes any pending data for the current connections.
 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to returnimmediately if there are no connections to process. 
 */
public void update(int timeout) throws IOException {
  updateThread=Thread.currentThread();
synchronized (updateLock) {
  }
  long startTime=System.currentTimeMillis();
  int select=0;
  if (timeout > 0) {
    select=selector.select(timeout);
  }
 else {
    select=selector.selectNow();
  }
  if (select == 0) {
    long elapsedTime=System.currentTimeMillis() - startTime;
    try {
      if (elapsedTime < 25)       Thread.sleep(25 - elapsedTime);
    }
 catch (    InterruptedException ex) {
    }
  }
 else {
    Set<SelectionKey> keys=selector.selectedKeys();
synchronized (keys) {
      UdpConnection udp=this.udp;
      outer:       for (Iterator<SelectionKey> iter=keys.iterator(); iter.hasNext(); ) {
        SelectionKey selectionKey=iter.next();
        iter.remove();
        try {
          int ops=selectionKey.readyOps();
          Connection fromConnection=(Connection)selectionKey.attachment();
          if (fromConnection != null) {
            if (udp != null && fromConnection.udpRemoteAddress == null)             continue;
            if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
              try {
                while (true) {
                  Object object=fromConnection.tcp.readObject(fromConnection);
                  if (object == null)                   break;
                  if (DEBUG) {
                    String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
                    if (!(object instanceof FrameworkMessage)) {
                      debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                    }
 else                     if (TRACE) {
                      trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                    }
                  }
                  fromConnection.notifyReceived(object);
                }
              }
 catch (              IOException ex) {
                if (TRACE) {
                  trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                }
 else                 if (DEBUG) {
                  debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
                }
                fromConnection.close();
              }
catch (              KryoNetException ex) {
                if (ERROR)                 error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                fromConnection.close();
              }
            }
            if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
              try {
                fromConnection.tcp.writeOperation();
              }
 catch (              IOException ex) {
                if (TRACE) {
                  trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                }
 else                 if (DEBUG) {
                  debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
                }
                fromConnection.close();
              }
            }
            continue;
          }
          if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
            ServerSocketChannel serverChannel=this.serverChannel;
            if (serverChannel == null)             continue;
            try {
              SocketChannel socketChannel=serverChannel.accept();
              if (socketChannel != null)               acceptOperation(socketChannel);
            }
 catch (            IOException ex) {
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"",ex);
            }
            continue;
          }
          if (udp == null)           continue;
          InetSocketAddress fromAddress;
          try {
            fromAddress=udp.readFromAddress();
          }
 catch (          IOException ex) {
            if (WARN)             warn(""String_Node_Str"",""String_Node_Str"",ex);
            continue;
          }
          if (fromAddress == null)           continue;
          Connection[] connections=this.connections;
          for (int i=0, n=connections.length; i < n; i++) {
            Connection connection=connections[i];
            if (fromAddress.equals(connection.udpRemoteAddress)) {
              fromConnection=connection;
              break;
            }
          }
          Object object;
          try {
            object=udp.readObject(fromConnection);
          }
 catch (          KryoNetException ex) {
            if (WARN) {
              if (fromConnection != null) {
                if (ERROR)                 error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
              }
 else               warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
            }
            continue;
          }
          if (object instanceof FrameworkMessage) {
            if (object instanceof RegisterUDP) {
              int fromConnectionID=((RegisterUDP)object).connectionID;
              Connection connection=pendingConnections.remove(fromConnectionID);
              if (connection != null) {
                if (connection.udpRemoteAddress != null)                 continue outer;
                connection.udpRemoteAddress=fromAddress;
                addConnection(connection);
                connection.sendTCP(new RegisterUDP());
                if (DEBUG)                 debug(""String_Node_Str"",""String_Node_Str"" + udp.datagramChannel.socket().getLocalPort() + ""String_Node_Str""+ fromAddress);
                connection.notifyConnected();
                continue;
              }
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"" + fromConnectionID);
              continue;
            }
            if (object instanceof DiscoverHost) {
              try {
                udp.datagramChannel.send(emptyBuffer,fromAddress);
                if (DEBUG)                 debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
              }
 catch (              IOException ex) {
                if (WARN)                 warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
              }
              continue;
            }
          }
          if (fromConnection != null) {
            if (DEBUG) {
              String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
              if (object instanceof FrameworkMessage) {
                if (TRACE)                 trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
              }
 else               debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
            }
            fromConnection.notifyReceived(object);
            continue;
          }
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
        }
 catch (        CancelledKeyException ignored) {
        }
      }
    }
  }
  long time=System.currentTimeMillis();
  Connection[] connections=this.connections;
  for (int i=0, n=connections.length; i < n; i++) {
    Connection connection=connections[i];
    if (connection.tcp.isTimedOut(time)) {
      if (DEBUG)       debug(""String_Node_Str"",connection + ""String_Node_Str"");
      connection.close();
    }
 else {
      if (connection.tcp.needsKeepAlive(time))       connection.sendTCP(FrameworkMessage.keepAlive);
    }
    if (connection.isIdle())     connection.notifyIdle();
  }
}","/** 
 * Accepts any new connections and reads or writes any pending data for the current connections.
 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to returnimmediately if there are no connections to process. 
 */
public void update(int timeout) throws IOException {
  updateThread=Thread.currentThread();
synchronized (updateLock) {
  }
  long startTime=System.currentTimeMillis();
  int select=0;
  if (timeout > 0) {
    select=selector.select(timeout);
  }
 else {
    select=selector.selectNow();
  }
  System.out.println(select);
  if (select == 0) {
    long elapsedTime=System.currentTimeMillis() - startTime;
    try {
      if (elapsedTime < 25)       Thread.sleep(25 - elapsedTime);
    }
 catch (    InterruptedException ex) {
    }
  }
 else {
    Set<SelectionKey> keys=selector.selectedKeys();
synchronized (keys) {
      UdpConnection udp=this.udp;
      outer:       for (Iterator<SelectionKey> iter=keys.iterator(); iter.hasNext(); ) {
        SelectionKey selectionKey=iter.next();
        iter.remove();
        try {
          int ops=selectionKey.readyOps();
          Connection fromConnection=(Connection)selectionKey.attachment();
          if (fromConnection != null) {
            if (udp != null && fromConnection.udpRemoteAddress == null) {
              fromConnection.close();
              continue;
            }
            if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
              try {
                while (true) {
                  Object object=fromConnection.tcp.readObject(fromConnection);
                  if (object == null)                   break;
                  if (DEBUG) {
                    String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
                    if (!(object instanceof FrameworkMessage)) {
                      debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                    }
 else                     if (TRACE) {
                      trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                    }
                  }
                  fromConnection.notifyReceived(object);
                }
              }
 catch (              IOException ex) {
                if (TRACE) {
                  trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                }
 else                 if (DEBUG) {
                  debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
                }
                fromConnection.close();
              }
catch (              KryoNetException ex) {
                if (ERROR)                 error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                fromConnection.close();
              }
            }
            if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
              try {
                fromConnection.tcp.writeOperation();
              }
 catch (              IOException ex) {
                if (TRACE) {
                  trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
                }
 else                 if (DEBUG) {
                  debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
                }
                fromConnection.close();
              }
            }
            continue;
          }
          if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
            ServerSocketChannel serverChannel=this.serverChannel;
            if (serverChannel == null)             continue;
            try {
              SocketChannel socketChannel=serverChannel.accept();
              if (socketChannel != null)               acceptOperation(socketChannel);
            }
 catch (            IOException ex) {
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"",ex);
            }
            continue;
          }
          if (udp == null)           continue;
          InetSocketAddress fromAddress;
          try {
            fromAddress=udp.readFromAddress();
          }
 catch (          IOException ex) {
            if (WARN)             warn(""String_Node_Str"",""String_Node_Str"",ex);
            continue;
          }
          if (fromAddress == null)           continue;
          Connection[] connections=this.connections;
          for (int i=0, n=connections.length; i < n; i++) {
            Connection connection=connections[i];
            if (fromAddress.equals(connection.udpRemoteAddress)) {
              fromConnection=connection;
              break;
            }
          }
          Object object;
          try {
            object=udp.readObject(fromConnection);
          }
 catch (          KryoNetException ex) {
            if (WARN) {
              if (fromConnection != null) {
                if (ERROR)                 error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
              }
 else               warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
            }
            continue;
          }
          if (object instanceof FrameworkMessage) {
            if (object instanceof RegisterUDP) {
              int fromConnectionID=((RegisterUDP)object).connectionID;
              Connection connection=pendingConnections.remove(fromConnectionID);
              if (connection != null) {
                if (connection.udpRemoteAddress != null)                 continue outer;
                connection.udpRemoteAddress=fromAddress;
                addConnection(connection);
                connection.sendTCP(new RegisterUDP());
                if (DEBUG)                 debug(""String_Node_Str"",""String_Node_Str"" + udp.datagramChannel.socket().getLocalPort() + ""String_Node_Str""+ fromAddress);
                connection.notifyConnected();
                continue;
              }
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"" + fromConnectionID);
              continue;
            }
            if (object instanceof DiscoverHost) {
              try {
                udp.datagramChannel.send(emptyBuffer,fromAddress);
                if (DEBUG)                 debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
              }
 catch (              IOException ex) {
                if (WARN)                 warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
              }
              continue;
            }
          }
          if (fromConnection != null) {
            if (DEBUG) {
              String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
              if (object instanceof FrameworkMessage) {
                if (TRACE)                 trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
              }
 else               debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
            }
            fromConnection.notifyReceived(object);
            continue;
          }
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
        }
 catch (        CancelledKeyException ignored) {
        }
      }
    }
  }
  long time=System.currentTimeMillis();
  Connection[] connections=this.connections;
  for (int i=0, n=connections.length; i < n; i++) {
    Connection connection=connections[i];
    if (connection.tcp.isTimedOut(time)) {
      if (DEBUG)       debug(""String_Node_Str"",connection + ""String_Node_Str"");
      connection.close();
    }
 else {
      if (connection.tcp.needsKeepAlive(time))       connection.sendTCP(FrameworkMessage.keepAlive);
    }
    if (connection.isIdle())     connection.notifyIdle();
  }
}"
49760,"public ChatClient(){
  client=new Client();
  client.start();
  Network.register(client);
  client.addListener(new Listener(){
    public void received(    Connection connection,    Object object){
      if (object instanceof UpdateNames) {
        UpdateNames updateNames=(UpdateNames)object;
        chatFrame.setNames(updateNames.names);
        return;
      }
      if (object instanceof ChatMessage) {
        ChatMessage chatMessage=(ChatMessage)object;
        chatFrame.addMessage(chatMessage.text);
        return;
      }
    }
    public void disconnected(    Connection connection){
      EventQueue.invokeLater(new Runnable(){
        public void run(){
          chatFrame.dispose();
        }
      }
);
    }
  }
);
  String input=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,null,null,""String_Node_Str"");
  if (input == null || input.trim().length() == 0)   System.exit(1);
  final String host=input.trim();
  input=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,null,null,""String_Node_Str"");
  if (input == null || input.trim().length() == 0)   System.exit(1);
  final String name=input.trim();
  chatFrame=new ChatFrame(host);
  chatFrame.setSendListener(new Runnable(){
    public void run(){
      ChatMessage chatMessage=new ChatMessage();
      chatMessage.text=chatFrame.getSendText();
      client.sendTCP(chatMessage);
    }
  }
);
  chatFrame.setCloseListener(new Runnable(){
    public void run(){
      client.stop();
    }
  }
);
  chatFrame.setVisible(true);
  new Thread(""String_Node_Str""){
    public void run(){
      try {
        client.connect(5000,host,Network.port);
      }
 catch (      IOException ex) {
        ex.printStackTrace();
        System.exit(1);
      }
      RegisterName registerName=new RegisterName();
      registerName.name=name;
      client.sendTCP(registerName);
    }
  }
.start();
}","public ChatClient(){
  client=new Client();
  client.start();
  Network.register(client);
  client.addListener(new Listener(){
    public void connected(    Connection connection){
      RegisterName registerName=new RegisterName();
      registerName.name=""String_Node_Str"";
      client.sendTCP(registerName);
    }
    public void received(    Connection connection,    Object object){
      if (object instanceof UpdateNames) {
        UpdateNames updateNames=(UpdateNames)object;
        chatFrame.setNames(updateNames.names);
        return;
      }
      if (object instanceof ChatMessage) {
        ChatMessage chatMessage=(ChatMessage)object;
        chatFrame.addMessage(chatMessage.text);
        return;
      }
    }
    public void disconnected(    Connection connection){
      EventQueue.invokeLater(new Runnable(){
        public void run(){
          chatFrame.dispose();
        }
      }
);
    }
  }
);
  String input=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,null,null,""String_Node_Str"");
  if (input == null || input.trim().length() == 0)   System.exit(1);
  final String host=input.trim();
  input=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,null,null,""String_Node_Str"");
  if (input == null || input.trim().length() == 0)   System.exit(1);
  final String name=input.trim();
  chatFrame=new ChatFrame(host);
  chatFrame.setSendListener(new Runnable(){
    public void run(){
      ChatMessage chatMessage=new ChatMessage();
      chatMessage.text=chatFrame.getSendText();
      client.sendTCP(chatMessage);
    }
  }
);
  chatFrame.setCloseListener(new Runnable(){
    public void run(){
      client.stop();
    }
  }
);
  chatFrame.setVisible(true);
  new Thread(""String_Node_Str""){
    public void run(){
      try {
        client.connect(5000,host,Network.port);
      }
 catch (      IOException ex) {
        ex.printStackTrace();
        System.exit(1);
      }
    }
  }
.start();
}"
49761,"public ChatRmiClient(){
  client=new Client();
  client.start();
  Network.register(client);
  player=ObjectSpace.getRemoteObject(client,Network.PLAYER,IPlayer.class);
  client.addListener(new Listener(){
    public void disconnected(    Connection connection){
      EventQueue.invokeLater(new Runnable(){
        public void run(){
          chatFrame.dispose();
        }
      }
);
    }
  }
);
  String input=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,null,null,""String_Node_Str"");
  if (input == null || input.trim().length() == 0)   System.exit(1);
  final String host=input.trim();
  input=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,null,null,""String_Node_Str"");
  if (input == null || input.trim().length() == 0)   System.exit(1);
  final String name=input.trim();
  chatFrame=new ChatFrame(host);
  new ObjectSpace(client).register(Network.CHAT_FRAME,chatFrame);
  chatFrame.setSendListener(new Runnable(){
    public void run(){
      player.sendMessage(chatFrame.getSendText());
    }
  }
);
  chatFrame.setCloseListener(new Runnable(){
    public void run(){
      client.stop();
    }
  }
);
  chatFrame.setVisible(true);
  new Thread(""String_Node_Str""){
    public void run(){
      try {
        client.connect(5000,host,Network.port);
      }
 catch (      IOException ex) {
        ex.printStackTrace();
        System.exit(1);
      }
      player.registerName(name);
    }
  }
.start();
}","public ChatRmiClient(){
  client=new Client();
  client.start();
  Network.register(client);
  player=ObjectSpace.getRemoteObject(client,Network.PLAYER,IPlayer.class);
  client.addListener(new Listener(){
    public void disconnected(    Connection connection){
      EventQueue.invokeLater(new Runnable(){
        public void run(){
          chatFrame.dispose();
        }
      }
);
    }
  }
);
  String input=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,null,null,""String_Node_Str"");
  if (input == null || input.trim().length() == 0)   System.exit(1);
  final String host=input.trim();
  input=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.QUESTION_MESSAGE,null,null,""String_Node_Str"");
  if (input == null || input.trim().length() == 0)   System.exit(1);
  final String name=input.trim();
  chatFrame=new ChatFrame(host);
  new ObjectSpace(client).register(Network.CHAT_FRAME,chatFrame);
  chatFrame.setSendListener(new Runnable(){
    public void run(){
      player.sendMessage(chatFrame.getSendText());
    }
  }
);
  chatFrame.setCloseListener(new Runnable(){
    public void run(){
      client.stop();
    }
  }
);
  chatFrame.setVisible(true);
  new Thread(""String_Node_Str""){
    public void run(){
      try {
        client.connect(5000,host,Network.port);
        player.registerName(name);
      }
 catch (      IOException ex) {
        ex.printStackTrace();
        System.exit(1);
      }
    }
  }
.start();
}"
49762,"public void queue(Runnable runnable){
synchronized (runnables) {
    runnables.addFirst(runnable);
  }
  int lag=lagMillisMax + (int)(Math.random() * (lagMillisMax - lagMillisMin));
  threadPool.schedule(new Runnable(){
    public void run(){
      Runnable runnable;
synchronized (runnables) {
        runnable=runnables.removeLast();
      }
      runnable.run();
    }
  }
,lag,TimeUnit.MILLISECONDS);
}","public void queue(Runnable runnable){
synchronized (runnables) {
    runnables.addFirst(runnable);
  }
  int lag=lagMillisMin + (int)(Math.random() * (lagMillisMax - lagMillisMin));
  threadPool.schedule(new Runnable(){
    public void run(){
      Runnable runnable;
synchronized (runnables) {
        runnable=runnables.removeLast();
      }
      runnable.run();
    }
  }
,lag,TimeUnit.MILLISECONDS);
}"
49763,"/** 
 * Accepts any new connections and reads or writes any pending data for the current connections.
 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to returnimmediately if there are no connections to process.
 */
public void update(int timeout) throws IOException {
  updateThread=Thread.currentThread();
synchronized (updateLock) {
  }
  if (timeout > 0) {
    selector.select(timeout);
  }
 else {
    selector.selectNow();
  }
  Set<SelectionKey> keys=selector.selectedKeys();
synchronized (keys) {
    outer:     for (Iterator<SelectionKey> iter=keys.iterator(); iter.hasNext(); ) {
      SelectionKey selectionKey=iter.next();
      iter.remove();
      try {
        int ops=selectionKey.readyOps();
        Connection keyConnection=(Connection)selectionKey.attachment();
        if (keyConnection != null) {
          if (udp != null && keyConnection.udpRemoteAddress == null)           continue;
          if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
            try {
              while (true) {
                Object object=keyConnection.tcp.readObject(keyConnection);
                if (object == null)                 break;
                if (DEBUG) {
                  String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
                  if (!(object instanceof FrameworkMessage)) {
                    debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + objectString);
                  }
 else                   if (TRACE) {
                    trace(""String_Node_Str"",keyConnection + ""String_Node_Str"" + objectString);
                  }
                }
                keyConnection.notifyReceived(object);
              }
            }
 catch (            IOException ex) {
              if (TRACE) {
                trace(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
              }
 else               if (DEBUG) {
                debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + ex.getMessage());
              }
              keyConnection.close();
            }
catch (            SerializationException ex) {
              if (ERROR)               error(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
              keyConnection.close();
            }
          }
          if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
            try {
              keyConnection.tcp.writeOperation();
            }
 catch (            IOException ex) {
              if (TRACE) {
                trace(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
              }
 else               if (DEBUG) {
                debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + ex.getMessage());
              }
              keyConnection.close();
            }
          }
          continue;
        }
        if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
          try {
            SocketChannel socketChannel=serverChannel.accept();
            if (socketChannel != null)             acceptOperation(socketChannel);
          }
 catch (          IOException ex) {
            if (DEBUG)             debug(""String_Node_Str"",""String_Node_Str"",ex);
          }
          continue;
        }
        if (udp == null)         continue;
        InetSocketAddress fromAddress;
        try {
          fromAddress=udp.readFromAddress();
        }
 catch (        IOException ex) {
          IOException ioEx=new IOException(""String_Node_Str"");
          ioEx.initCause(ex);
          throw ioEx;
        }
        if (fromAddress == null)         continue;
        Connection[] connections=this.connections;
        Connection fromConnection=null;
        for (int i=0, n=connections.length; i < n; i++) {
          Connection connection=connections[i];
          if (fromAddress.equals(connection.udpRemoteAddress)) {
            fromConnection=connection;
            break;
          }
        }
        Object object;
        try {
          object=udp.readObject(fromConnection);
        }
 catch (        SerializationException ex) {
          if (WARN) {
            Connection errorConnection=null;
            for (int i=0, n=connections.length; i < n; i++) {
              Connection connection=connections[i];
              if (fromAddress.equals(connection.udpRemoteAddress)) {
                errorConnection=connection;
                break;
              }
            }
            if (errorConnection != null) {
              if (ERROR)               error(""String_Node_Str"",""String_Node_Str"" + errorConnection,ex);
            }
 else             warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
          }
          continue;
        }
        if (object instanceof FrameworkMessage) {
          if (object instanceof RegisterUDP) {
            int fromConnectionID=((RegisterUDP)object).connectionID;
            Connection connection=pendingConnections.remove(fromConnectionID);
            if (connection != null) {
              if (connection.udpRemoteAddress != null)               continue outer;
              connection.udpRemoteAddress=fromAddress;
              addConnection(connection);
              connection.sendTCP(new RegisterUDP());
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"" + udp.datagramChannel.socket().getLocalPort() + ""String_Node_Str""+ fromAddress);
              connection.notifyConnected();
              continue;
            }
            if (DEBUG)             debug(""String_Node_Str"",""String_Node_Str"" + fromConnectionID);
            continue;
          }
          if (object instanceof DiscoverHost) {
            udp.datagramChannel.send(emptyBuffer,fromAddress);
            if (DEBUG)             debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
            continue;
          }
        }
        if (fromConnection != null) {
          if (DEBUG) {
            String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
            if (object instanceof KeepAlive) {
              if (TRACE)               trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
            }
 else             debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
          }
          fromConnection.notifyReceived(object);
          continue;
        }
        if (DEBUG)         debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
      }
 catch (      CancelledKeyException ignored) {
      }
    }
  }
}","/** 
 * Accepts any new connections and reads or writes any pending data for the current connections.
 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to returnimmediately if there are no connections to process.
 */
public void update(int timeout) throws IOException {
  updateThread=Thread.currentThread();
synchronized (updateLock) {
  }
  if (timeout > 0) {
    selector.select(timeout);
  }
 else {
    selector.selectNow();
  }
  Set<SelectionKey> keys=selector.selectedKeys();
synchronized (keys) {
    outer:     for (Iterator<SelectionKey> iter=keys.iterator(); iter.hasNext(); ) {
      SelectionKey selectionKey=iter.next();
      iter.remove();
      try {
        int ops=selectionKey.readyOps();
        Connection fromConnection=(Connection)selectionKey.attachment();
        if (fromConnection != null) {
          if (udp != null && fromConnection.udpRemoteAddress == null)           continue;
          if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
            try {
              while (true) {
                Object object=fromConnection.tcp.readObject(fromConnection);
                if (object == null)                 break;
                if (DEBUG) {
                  String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
                  if (!(object instanceof FrameworkMessage)) {
                    debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                  }
 else                   if (TRACE) {
                    trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
                  }
                }
                fromConnection.notifyReceived(object);
              }
            }
 catch (            IOException ex) {
              if (TRACE) {
                trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
              }
 else               if (DEBUG) {
                debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
              }
              fromConnection.close();
            }
catch (            SerializationException ex) {
              if (ERROR)               error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
              fromConnection.close();
            }
          }
          if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
            try {
              fromConnection.tcp.writeOperation();
            }
 catch (            IOException ex) {
              if (TRACE) {
                trace(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
              }
 else               if (DEBUG) {
                debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + ex.getMessage());
              }
              fromConnection.close();
            }
          }
          continue;
        }
        if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
          try {
            SocketChannel socketChannel=serverChannel.accept();
            if (socketChannel != null)             acceptOperation(socketChannel);
          }
 catch (          IOException ex) {
            if (DEBUG)             debug(""String_Node_Str"",""String_Node_Str"",ex);
          }
          continue;
        }
        if (udp == null)         continue;
        InetSocketAddress fromAddress;
        try {
          fromAddress=udp.readFromAddress();
        }
 catch (        IOException ex) {
          if (WARN)           warn(""String_Node_Str"",""String_Node_Str"",ex);
          continue;
        }
        if (fromAddress == null)         continue;
        Connection[] connections=this.connections;
        for (int i=0, n=connections.length; i < n; i++) {
          Connection connection=connections[i];
          if (fromAddress.equals(connection.udpRemoteAddress)) {
            fromConnection=connection;
            break;
          }
        }
        Object object;
        try {
          object=udp.readObject(fromConnection);
        }
 catch (        SerializationException ex) {
          if (WARN) {
            if (fromConnection != null) {
              if (ERROR)               error(""String_Node_Str"",""String_Node_Str"" + fromConnection,ex);
            }
 else             warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
          }
          continue;
        }
        if (object instanceof FrameworkMessage) {
          if (object instanceof RegisterUDP) {
            int fromConnectionID=((RegisterUDP)object).connectionID;
            Connection connection=pendingConnections.remove(fromConnectionID);
            if (connection != null) {
              if (connection.udpRemoteAddress != null)               continue outer;
              connection.udpRemoteAddress=fromAddress;
              addConnection(connection);
              connection.sendTCP(new RegisterUDP());
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"" + udp.datagramChannel.socket().getLocalPort() + ""String_Node_Str""+ fromAddress);
              connection.notifyConnected();
              continue;
            }
            if (DEBUG)             debug(""String_Node_Str"",""String_Node_Str"" + fromConnectionID);
            continue;
          }
          if (object instanceof DiscoverHost) {
            try {
              udp.datagramChannel.send(emptyBuffer,fromAddress);
              if (DEBUG)               debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
            }
 catch (            IOException ex) {
              if (WARN)               warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
            }
            continue;
          }
        }
        if (fromConnection != null) {
          if (DEBUG) {
            String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
            if (object instanceof KeepAlive) {
              if (TRACE)               trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
            }
 else             debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
          }
          fromConnection.notifyReceived(object);
          continue;
        }
        if (DEBUG)         debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
      }
 catch (      CancelledKeyException ignored) {
      }
    }
  }
}"
49764,"public void connect(Selector selector,SocketAddress remoteAddress,int timeout) throws IOException {
  close();
  try {
    SocketChannel socketChannel=selector.provider().openSocketChannel();
    Socket socket=socketChannel.socket();
    socket.setTcpNoDelay(true);
    socket.setTrafficClass(IPTOS_LOWDELAY);
    socket.connect(remoteAddress,timeout);
    socketChannel.configureBlocking(false);
    this.socketChannel=socketChannel;
    selectionKey=socketChannel.register(selector,SelectionKey.OP_READ);
    selectionKey.attach(this);
    if (DEBUG) {
      debug(""String_Node_Str"",""String_Node_Str"" + socketChannel.socket().getLocalPort() + ""String_Node_Str""+ socketChannel.socket().getRemoteSocketAddress());
    }
    if (keepAliveTime > 0)     lastCommunicationTime=System.currentTimeMillis();
  }
 catch (  IOException ex) {
    close();
    IOException ioEx=new IOException(""String_Node_Str"" + remoteAddress);
    ioEx.initCause(ex);
    throw ioEx;
  }
}","public void connect(Selector selector,SocketAddress remoteAddress,int timeout) throws IOException {
  close();
  writeBuffer.clear();
  readBuffer.clear();
  readBuffer.flip();
  try {
    SocketChannel socketChannel=selector.provider().openSocketChannel();
    Socket socket=socketChannel.socket();
    socket.setTcpNoDelay(true);
    socket.setTrafficClass(IPTOS_LOWDELAY);
    socket.connect(remoteAddress,timeout);
    socketChannel.configureBlocking(false);
    this.socketChannel=socketChannel;
    selectionKey=socketChannel.register(selector,SelectionKey.OP_READ);
    selectionKey.attach(this);
    if (DEBUG) {
      debug(""String_Node_Str"",""String_Node_Str"" + socketChannel.socket().getLocalPort() + ""String_Node_Str""+ socketChannel.socket().getRemoteSocketAddress());
    }
    if (keepAliveTime > 0)     lastCommunicationTime=System.currentTimeMillis();
  }
 catch (  IOException ex) {
    close();
    IOException ioEx=new IOException(""String_Node_Str"" + remoteAddress);
    ioEx.initCause(ex);
    throw ioEx;
  }
}"
49765,"static CachedMethod[] getMethods(Kryo kryo,Class type){
  CachedMethod[] cachedMethods=methodCache.get(type);
  if (cachedMethods != null)   return cachedMethods;
  ArrayList<Method> allMethods=new ArrayList();
  Class nextClass=type;
  while (nextClass != null && nextClass != Object.class) {
    Collections.addAll(allMethods,nextClass.getDeclaredMethods());
    nextClass=nextClass.getSuperclass();
  }
  PriorityQueue<Method> methods=new PriorityQueue(Math.max(1,allMethods.size()),new Comparator<Method>(){
    public int compare(    Method o1,    Method o2){
      int diff=o1.getName().compareTo(o2.getName());
      if (diff != 0)       return diff;
      Class[] argTypes1=o1.getParameterTypes();
      Class[] argTypes2=o2.getParameterTypes();
      if (argTypes1.length > argTypes2.length)       return 1;
      if (argTypes1.length < argTypes2.length)       return -1;
      for (int i=0; i < argTypes1.length; i++) {
        diff=argTypes1[i].getName().compareTo(argTypes2[i].getName());
        if (diff != 0)         return diff;
      }
      throw new RuntimeException(""String_Node_Str"");
    }
  }
);
  for (int i=0, n=allMethods.size(); i < n; i++) {
    Method method=allMethods.get(i);
    int modifiers=method.getModifiers();
    if (Modifier.isStatic(modifiers))     continue;
    if (Modifier.isPrivate(modifiers))     continue;
    if (method.isSynthetic())     continue;
    methods.add(method);
  }
  int n=methods.size();
  cachedMethods=new CachedMethod[n];
  for (int i=0; i < n; i++) {
    CachedMethod cachedMethod=new CachedMethod();
    cachedMethod.method=methods.poll();
    Class[] parameterTypes=cachedMethod.method.getParameterTypes();
    cachedMethod.serializers=new Serializer[parameterTypes.length];
    for (int ii=0, nn=parameterTypes.length; ii < nn; ii++)     if (Modifier.isFinal(parameterTypes[ii].getModifiers()))     cachedMethod.serializers[ii]=kryo.getSerializer(parameterTypes[ii]);
    cachedMethods[i]=cachedMethod;
  }
  methodCache.put(type,cachedMethods);
  return cachedMethods;
}","static CachedMethod[] getMethods(Kryo kryo,Class type){
  CachedMethod[] cachedMethods=methodCache.get(type);
  if (cachedMethods != null)   return cachedMethods;
  ArrayList<Method> allMethods=new ArrayList();
  Class nextClass=type;
  while (nextClass != null && nextClass != Object.class) {
    Collections.addAll(allMethods,nextClass.getDeclaredMethods());
    nextClass=nextClass.getSuperclass();
  }
  PriorityQueue<Method> methods=new PriorityQueue(Math.max(1,allMethods.size()),new Comparator<Method>(){
    public int compare(    Method o1,    Method o2){
      int diff=o1.getName().compareTo(o2.getName());
      if (diff != 0)       return diff;
      Class[] argTypes1=o1.getParameterTypes();
      Class[] argTypes2=o2.getParameterTypes();
      if (argTypes1.length > argTypes2.length)       return 1;
      if (argTypes1.length < argTypes2.length)       return -1;
      for (int i=0; i < argTypes1.length; i++) {
        diff=argTypes1[i].getName().compareTo(argTypes2[i].getName());
        if (diff != 0)         return diff;
      }
      throw new RuntimeException(""String_Node_Str"");
    }
  }
);
  for (int i=0, n=allMethods.size(); i < n; i++) {
    Method method=allMethods.get(i);
    int modifiers=method.getModifiers();
    if (Modifier.isStatic(modifiers))     continue;
    if (Modifier.isPrivate(modifiers))     continue;
    if (method.isSynthetic())     continue;
    methods.add(method);
  }
  int n=methods.size();
  cachedMethods=new CachedMethod[n];
  for (int i=0; i < n; i++) {
    CachedMethod cachedMethod=new CachedMethod();
    cachedMethod.method=methods.poll();
    Class[] parameterTypes=cachedMethod.method.getParameterTypes();
    cachedMethod.serializers=new Serializer[parameterTypes.length];
    for (int ii=0, nn=parameterTypes.length; ii < nn; ii++)     if (Serializer.isFinal(parameterTypes[ii]))     cachedMethod.serializers[ii]=kryo.getSerializer(parameterTypes[ii]);
    cachedMethods[i]=cachedMethod;
  }
  methodCache.put(type,cachedMethods);
  return cachedMethods;
}"
49766,"/** 
 * Accepts any new connections and reads or writes any pending data for the current connections.
 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to returnimmediately if there are no connections to process.
 */
public void update(int timeout) throws IOException {
  updateThread=Thread.currentThread();
synchronized (updateLock) {
  }
  if (timeout > 0) {
    selector.select(timeout);
  }
 else {
    selector.selectNow();
  }
  Set<SelectionKey> keys=selector.selectedKeys();
  outer:   for (Iterator<SelectionKey> iter=keys.iterator(); iter.hasNext(); ) {
    SelectionKey selectionKey=iter.next();
    iter.remove();
    try {
      int ops=selectionKey.readyOps();
      Connection keyConnection=(Connection)selectionKey.attachment();
      if (keyConnection != null) {
        if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
          try {
            while (true) {
              Object object=keyConnection.tcp.readObject(keyConnection);
              if (object == null)               break;
              if (DEBUG) {
                String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
                if (!(object instanceof FrameworkMessage)) {
                  debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + objectString);
                }
 else                 if (TRACE) {
                  trace(""String_Node_Str"",keyConnection + ""String_Node_Str"" + objectString);
                }
              }
              keyConnection.notifyReceived(object);
            }
          }
 catch (          IOException ex) {
            if (TRACE) {
              trace(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
            }
 else             if (DEBUG) {
              debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + ex.getMessage());
            }
            keyConnection.close();
          }
catch (          SerializationException ex) {
            if (ERROR)             error(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
            keyConnection.close();
          }
        }
        if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
          try {
            keyConnection.tcp.writeOperation();
          }
 catch (          IOException ex) {
            if (TRACE) {
              trace(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
            }
 else             if (DEBUG) {
              debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + ex.getMessage());
            }
            keyConnection.close();
          }
        }
        continue;
      }
      if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
        try {
          SocketChannel socketChannel=serverChannel.accept();
          if (socketChannel != null)           acceptOperation(socketChannel);
        }
 catch (        IOException ex) {
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"",ex);
        }
        continue;
      }
      if (udp == null)       continue;
      InetSocketAddress fromAddress;
      try {
        fromAddress=udp.readFromAddress();
      }
 catch (      IOException ex) {
        IOException ioEx=new IOException(""String_Node_Str"");
        ioEx.initCause(ex);
        throw ioEx;
      }
      if (fromAddress == null)       continue;
      Connection[] connections=this.connections;
      Connection fromConnection=null;
      for (int i=0, n=connections.length; i < n; i++) {
        Connection connection=connections[i];
        if (fromAddress.equals(connection.udpRemoteAddress)) {
          fromConnection=connection;
          break;
        }
      }
      Object object;
      try {
        object=udp.readObject(fromConnection);
      }
 catch (      SerializationException ex) {
        if (WARN) {
          Connection errorConnection=null;
          for (int i=0, n=connections.length; i < n; i++) {
            Connection connection=connections[i];
            if (fromAddress.equals(connection.udpRemoteAddress)) {
              errorConnection=connection;
              break;
            }
          }
          if (errorConnection != null) {
            if (ERROR)             error(""String_Node_Str"",""String_Node_Str"" + errorConnection,ex);
          }
 else           warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
        }
        continue;
      }
      if (object instanceof FrameworkMessage) {
        if (object instanceof RegisterUDP) {
          int fromConnectionID=((RegisterUDP)object).connectionID;
          Connection connection=pendingConnections.remove(fromConnectionID);
          if (connection != null) {
            if (connection.udpRemoteAddress != null)             continue outer;
            connection.udpRemoteAddress=fromAddress;
            addConnection(connection);
            connection.sendTCP(new RegisterUDP());
            if (DEBUG)             debug(""String_Node_Str"",""String_Node_Str"" + udp.datagramChannel.socket().getLocalPort() + ""String_Node_Str""+ fromAddress);
            connection.notifyConnected();
            continue;
          }
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"" + fromConnectionID);
          continue;
        }
        if (object instanceof DiscoverHost) {
          udp.datagramChannel.send(udp.writeBuffer,fromAddress);
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
          continue;
        }
      }
      if (fromConnection != null) {
        if (DEBUG) {
          String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
          if (object instanceof KeepAlive) {
            if (TRACE)             trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
          }
 else           debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
        }
        fromConnection.notifyReceived(object);
        continue;
      }
      if (DEBUG)       debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
    }
 catch (    CancelledKeyException ignored) {
    }
  }
}","/** 
 * Accepts any new connections and reads or writes any pending data for the current connections.
 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to returnimmediately if there are no connections to process.
 */
public void update(int timeout) throws IOException {
  updateThread=Thread.currentThread();
synchronized (updateLock) {
  }
  if (timeout > 0) {
    selector.select(timeout);
  }
 else {
    selector.selectNow();
  }
  Set<SelectionKey> keys=selector.selectedKeys();
  outer:   for (Iterator<SelectionKey> iter=keys.iterator(); iter.hasNext(); ) {
    SelectionKey selectionKey=iter.next();
    iter.remove();
    try {
      int ops=selectionKey.readyOps();
      Connection keyConnection=(Connection)selectionKey.attachment();
      if (keyConnection != null) {
        if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
          try {
            while (true) {
              Object object=keyConnection.tcp.readObject(keyConnection);
              if (object == null)               break;
              if (DEBUG) {
                String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
                if (!(object instanceof FrameworkMessage)) {
                  debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + objectString);
                }
 else                 if (TRACE) {
                  trace(""String_Node_Str"",keyConnection + ""String_Node_Str"" + objectString);
                }
              }
              keyConnection.notifyReceived(object);
            }
          }
 catch (          IOException ex) {
            if (TRACE) {
              trace(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
            }
 else             if (DEBUG) {
              debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + ex.getMessage());
            }
            keyConnection.close();
          }
catch (          SerializationException ex) {
            if (ERROR)             error(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
            keyConnection.close();
          }
        }
        if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
          try {
            keyConnection.tcp.writeOperation();
          }
 catch (          IOException ex) {
            if (TRACE) {
              trace(""String_Node_Str"",""String_Node_Str"" + keyConnection,ex);
            }
 else             if (DEBUG) {
              debug(""String_Node_Str"",keyConnection + ""String_Node_Str"" + ex.getMessage());
            }
            keyConnection.close();
          }
        }
        continue;
      }
      if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
        try {
          SocketChannel socketChannel=serverChannel.accept();
          if (socketChannel != null)           acceptOperation(socketChannel);
        }
 catch (        IOException ex) {
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"",ex);
        }
        continue;
      }
      if (udp == null)       continue;
      InetSocketAddress fromAddress;
      try {
        fromAddress=udp.readFromAddress();
      }
 catch (      IOException ex) {
        IOException ioEx=new IOException(""String_Node_Str"");
        ioEx.initCause(ex);
        throw ioEx;
      }
      if (fromAddress == null)       continue;
      Connection[] connections=this.connections;
      Connection fromConnection=null;
      for (int i=0, n=connections.length; i < n; i++) {
        Connection connection=connections[i];
        if (fromAddress.equals(connection.udpRemoteAddress)) {
          fromConnection=connection;
          break;
        }
      }
      Object object;
      try {
        object=udp.readObject(fromConnection);
      }
 catch (      SerializationException ex) {
        if (WARN) {
          Connection errorConnection=null;
          for (int i=0, n=connections.length; i < n; i++) {
            Connection connection=connections[i];
            if (fromAddress.equals(connection.udpRemoteAddress)) {
              errorConnection=connection;
              break;
            }
          }
          if (errorConnection != null) {
            if (ERROR)             error(""String_Node_Str"",""String_Node_Str"" + errorConnection,ex);
          }
 else           warn(""String_Node_Str"",""String_Node_Str"" + fromAddress,ex);
        }
        continue;
      }
      if (object instanceof FrameworkMessage) {
        if (object instanceof RegisterUDP) {
          int fromConnectionID=((RegisterUDP)object).connectionID;
          Connection connection=pendingConnections.remove(fromConnectionID);
          if (connection != null) {
            if (connection.udpRemoteAddress != null)             continue outer;
            connection.udpRemoteAddress=fromAddress;
            addConnection(connection);
            connection.sendTCP(new RegisterUDP());
            if (DEBUG)             debug(""String_Node_Str"",""String_Node_Str"" + udp.datagramChannel.socket().getLocalPort() + ""String_Node_Str""+ fromAddress);
            connection.notifyConnected();
            continue;
          }
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"" + fromConnectionID);
          continue;
        }
        if (object instanceof DiscoverHost) {
          udp.datagramChannel.send(emptyBuffer,fromAddress);
          if (DEBUG)           debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
          continue;
        }
      }
      if (fromConnection != null) {
        if (DEBUG) {
          String objectString=object == null ? ""String_Node_Str"" : object.getClass().getSimpleName();
          if (object instanceof KeepAlive) {
            if (TRACE)             trace(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
          }
 else           debug(""String_Node_Str"",fromConnection + ""String_Node_Str"" + objectString);
        }
        fromConnection.notifyReceived(object);
        continue;
      }
      if (DEBUG)       debug(""String_Node_Str"",""String_Node_Str"" + fromAddress);
    }
 catch (    CancelledKeyException ignored) {
    }
  }
}"
49767,"/** 
 * Creates new form GeneralPanel
 */
public GeneralPanel(){
  initComponents();
  QuickOpenerProperty customSeparator=PrefsUtil.load(null,""String_Node_Str"",getOSSeparator());
  jLabel2.setText(customSeparator.getValue());
  QuickOpenerProperty customShell=PrefsUtil.load(null,""String_Node_Str"",null);
  cShellLabel.setText((customShell.getValue() == null) ? ""String_Node_Str"" : customShell.getValue());
  QuickOpenerProperty customFileManager=PrefsUtil.load(null,""String_Node_Str"",null);
  cFileManagerLabel.setText(customFileManager.getValue() == null ? ""String_Node_Str"" : customFileManager.getValue());
  QuickOpenerProperty confirmation=PrefsUtil.load(null,""String_Node_Str"",""String_Node_Str"");
  boolean isConfirmSelected=Boolean.parseBoolean(confirmation.getValue());
  confirmationCheckBox.setSelected(isConfirmSelected);
  shellConfigureButton.setEnabled(!getAvailableConfigurators().isEmpty());
}","/** 
 * Creates new form GeneralPanel
 */
public GeneralPanel(){
  initComponents();
  QuickOpenerProperty customSeparator=PrefsUtil.load(null,""String_Node_Str"",getOSSeparator());
  jLabel2.setText(customSeparator.getValue());
  QuickOpenerProperty customShell=PrefsUtil.load(null,""String_Node_Str"",null);
  cShellLabel.setText((customShell.getValue() == null) ? ""String_Node_Str"" : customShell.getValue());
  QuickOpenerProperty customFileManager=PrefsUtil.load(null,""String_Node_Str"",null);
  cFileManagerLabel.setText(customFileManager.getValue() == null ? ""String_Node_Str"" : customFileManager.getValue());
  QuickOpenerProperty confirmation=PrefsUtil.load(null,""String_Node_Str"",""String_Node_Str"");
  boolean isConfirmSelected=Boolean.parseBoolean(confirmation.getValue());
  confirmationCheckBox.setSelected(isConfirmSelected);
  shellConfigureButton.setEnabled(!getAvailableConfigurators().isEmpty());
  fileManagerConfigureButton.setEnabled(!getAvailableFileManagerConfigurators().isEmpty());
}"
49768,"private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
    String path=(String)jTable2.getModel().getValueAt(row,1);
    cmdTextField.setText(path);
  }
}","private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    if (-1 != thisrow) {
      final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
      String path=(String)jTable2.getModel().getValueAt(row,1);
      cmdTextField.setText(path);
    }
  }
}"
49769,"private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
    String path=(String)jTable2.getModel().getValueAt(row,1);
    cmdTextField.setText(path);
  }
}","private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    if (-1 != thisrow) {
      final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
      String path=(String)jTable2.getModel().getValueAt(row,1);
      cmdTextField.setText(path);
    }
  }
}"
49770,"private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
    String path=(String)jTable2.getModel().getValueAt(row,1);
    cmdTextField.setText(path);
  }
}","private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    if (-1 != thisrow) {
      final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
      String path=(String)jTable2.getModel().getValueAt(row,1);
      cmdTextField.setText(path);
    }
  }
}"
49771,"private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
    String path=(String)jTable2.getModel().getValueAt(row,1);
    cmdTextField.setText(path);
  }
}","private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    if (-1 != thisrow) {
      final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
      String path=(String)jTable2.getModel().getValueAt(row,1);
      cmdTextField.setText(path);
    }
  }
}"
49772,"private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
    String description=(String)jTable2.getModel().getValueAt(row,0);
    String command=(String)jTable2.getModel().getValueAt(row,1);
    cmddescription.setText(description);
    cmdvalue.setText(command);
  }
}","private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    if (-1 != thisrow) {
      final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
      String description=(String)jTable2.getModel().getValueAt(row,0);
      String command=(String)jTable2.getModel().getValueAt(row,1);
      cmddescription.setText(description);
      cmdvalue.setText(command);
    }
  }
}"
49773,"private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
    String desc=(String)jTable2.getModel().getValueAt(row,0);
    String path=(String)jTable2.getModel().getValueAt(row,1);
    folderDescriptionTextField.setText(desc);
    favoritePathTextField.setText(path);
  }
}","private void jTable2MouseClicked(java.awt.event.MouseEvent evt){
  if (evt.getClickCount() == 1) {
    final int thisrow=jTable2.getSelectedRow();
    if (-1 != thisrow) {
      final int row=jTable2.getRowSorter().convertRowIndexToModel(thisrow);
      String desc=(String)jTable2.getModel().getValueAt(row,0);
      String path=(String)jTable2.getModel().getValueAt(row,1);
      folderDescriptionTextField.setText(desc);
      favoritePathTextField.setText(path);
    }
  }
}"
49774,"public Class getColumnClass(int c){
  return String.class;
}","@Override public Class getColumnClass(int c){
  return String.class;
}"
49775,"public PropertyTableModel(String prefix){
  try {
    List<QuickOpenerProperty> prefs=PrefsUtil.getAllMatching(prefix);
    this.data=new Object[prefs.size()][2];
    for (int i=0; i < prefs.size(); i++) {
      QuickOpenerProperty pref=prefs.get(i);
      this.data[i]=new String[]{pref.getDescription(),pref.getValue()};
    }
  }
 catch (  BackingStoreException ex) {
    Exceptions.printStackTrace(ex);
  }
}","public PropertyTableModel(String prefix){
  setColumnNames(prefix);
  try {
    List<QuickOpenerProperty> prefs=PrefsUtil.getAllMatching(prefix);
    this.data=new Object[prefs.size()][2];
    for (int i=0; i < prefs.size(); i++) {
      QuickOpenerProperty pref=prefs.get(i);
      this.data[i]=new String[]{pref.getDescription(),pref.getValue()};
    }
  }
 catch (  BackingStoreException ex) {
    Exceptions.printStackTrace(ex);
  }
}"
49776,"public static String getFileFromSelectedNode(boolean isFolder){
  TopComponent topActive=TopComponent.getRegistry().getActivated();
  Node[] nodes=topActive.getActivatedNodes();
  if (nodes.length == 1) {
    DataObject dataObj=nodes[0].getLookup().lookup(DataObject.class);
    return (dataObj != null) ? getPathFromDataObject(dataObj,isFolder) : null;
  }
 else {
    return null;
  }
}","public static String getFileFromSelectedNode(boolean isFolder){
  try {
    TopComponent topActive=TopComponent.getRegistry().getActivated();
    Node[] nodes=topActive.getActivatedNodes();
    if (nodes.length == 1) {
      DataObject dataObj=nodes[0].getLookup().lookup(DataObject.class);
      return (dataObj != null) ? getPathFromDataObject(dataObj,isFolder) : null;
    }
 else {
      return null;
    }
  }
 catch (  Exception e) {
    return null;
  }
}"
49777,"public static File getFileFromDataObject(DataObject dataObj,boolean isFolder){
  File current=FileUtil.toFile(dataObj.getPrimaryFile());
  if (!isFolder) {
    return current;
  }
 else {
    return (current.isDirectory()) ? current : current.getParentFile();
  }
}","public static File getFileFromDataObject(DataObject dataObj,boolean isFolder){
  try {
    File current=FileUtil.toFile(dataObj.getPrimaryFile());
    if (!isFolder) {
      return current;
    }
 else {
      return (current.isDirectory()) ? current : current.getParentFile();
    }
  }
 catch (  Exception e) {
    return null;
  }
}"
49778,"public static String getPathFromDataObject(DataObject dataObj,boolean isFolder){
  return getFileFromDataObject(dataObj,isFolder).getAbsolutePath();
}","public static String getPathFromDataObject(DataObject dataObj,boolean isFolder){
  try {
    return getFileFromDataObject(dataObj,isFolder).getAbsolutePath();
  }
 catch (  Exception e) {
    return null;
  }
}"
49779,"@Override public void actionPerformed(ActionEvent e){
  File toOpen=PathFinder.getFileFromDataObject(dataObj,true);
  try {
    Commands.getPlatform().browseInFileSystem(toOpen);
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(null,ex.getMessage());
  }
}","@Override public void actionPerformed(ActionEvent e){
  File toOpen=PathFinder.getFileFromDataObject(dataObj,true);
  if (toOpen == null) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"");
    return;
  }
  try {
    Commands.getPlatform().browseInFileSystem(toOpen);
  }
 catch (  Exception ex) {
  }
}"
49780,"@Override public void actionPerformed(ActionEvent e){
  String path=PathFinder.getPathFromDataObject(dataObj,false);
  try {
    Toolkit toolkit=Toolkit.getDefaultToolkit();
    Clipboard clipboard=toolkit.getSystemClipboard();
    StringSelection strSel=new StringSelection(path);
    clipboard.setContents(strSel,null);
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(null,ex.getMessage());
  }
}","@Override public void actionPerformed(ActionEvent e){
  String path=PathFinder.getPathFromDataObject(dataObj,false);
  if (path == null) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"");
    return;
  }
  try {
    Toolkit toolkit=Toolkit.getDefaultToolkit();
    Clipboard clipboard=toolkit.getSystemClipboard();
    StringSelection strSel=new StringSelection(path);
    clipboard.setContents(strSel,null);
  }
 catch (  Exception ex) {
  }
}"
49781,"@Override public void actionPerformed(ActionEvent e){
  try {
    String path=PathFinder.getPathFromDataObject(dataObj,true);
    Commands.getPlatform().openInShell(path);
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(null,ex.getMessage());
  }
}","@Override public void actionPerformed(ActionEvent e){
  try {
    String path=PathFinder.getPathFromDataObject(dataObj,true);
    if (path == null) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      return;
    }
    Commands.getPlatform().openInShell(path);
  }
 catch (  Exception ex) {
  }
}"
49782,"@Override public void actionPerformed(ActionEvent e){
  String path=PathFinder.getPathFromDataObject(dataObj,false);
  if (path == null) {
    NotifyDescriptor d=new NotifyDescriptor.Message(QuickMessages.NO_FILE_IN_SELECTION,NotifyDescriptor.WARNING_MESSAGE);
    DialogDisplayer.getDefault().notify(d);
    return;
  }
  try {
    Toolkit toolkit=Toolkit.getDefaultToolkit();
    Clipboard clipboard=toolkit.getSystemClipboard();
    StringSelection strSel=new StringSelection(path);
    clipboard.setContents(strSel,null);
  }
 catch (  Exception ex) {
  }
}","@Override public void actionPerformed(ActionEvent e){
  String path=PathFinder.getPathFromDataObject(dataObj,false);
  if (path == null) {
    NotifyDescriptor d=new NotifyDescriptor.Message(QuickMessages.NO_FILE_IN_SELECTION,NotifyDescriptor.WARNING_MESSAGE);
    DialogDisplayer.getDefault().notify(d);
    return;
  }
  String ossep=getOSSeparator();
  QuickOpenerProperty prop=PrefsUtil.load(null,""String_Node_Str"",ossep);
  if (!prop.getValue().equals(ossep)) {
    String torep=(ossep.equals(""String_Node_Str"")) ? ""String_Node_Str"" : ossep;
    String repl=(prop.getValue().equals(""String_Node_Str"")) ? ""String_Node_Str"" : prop.getValue();
    path=path.replaceAll(torep,repl);
  }
  try {
    Toolkit toolkit=Toolkit.getDefaultToolkit();
    Clipboard clipboard=toolkit.getSystemClipboard();
    StringSelection strSel=new StringSelection(path);
    clipboard.setContents(strSel,null);
  }
 catch (  Exception ex) {
  }
}"
49783,"private static File getActiveFileFromDataObject(DataObject dataObj,boolean isFolder){
  if (dataObj == null) {
    return null;
  }
 else {
    try {
      if ((dataObj instanceof DataFolder)) {
        DataFolder df=(DataFolder)dataObj;
        FileObject fobj=df.getPrimaryFile();
        File found=getFileFromFileObject(fobj);
        if (found == null) {
          return null;
        }
 else {
          return isFolder ? found.getParentFile() : found;
        }
      }
 else       if (dataObj instanceof MultiDataObject) {
        MultiDataObject mdo=(MultiDataObject)dataObj;
        FileObject fobj=mdo.getPrimaryFile();
        File found=getFileFromFileObject(fobj);
        if (found == null) {
          return null;
        }
 else {
          return isFolder ? found.getParentFile() : found;
        }
      }
 else {
        return getFileFromDataObject(dataObj,isFolder);
      }
    }
 catch (    Exception e) {
      return null;
    }
  }
}","private static File getActiveFileFromDataObject(DataObject dataObj,boolean isFolder){
  if (dataObj == null) {
    return null;
  }
 else {
    try {
      File toReturn=getFileFromDataObject(dataObj,isFolder);
      if (toReturn != null && toReturn.exists()) {
        return toReturn;
      }
 else {
        if ((dataObj instanceof DataFolder)) {
          DataFolder df=(DataFolder)dataObj;
          FileObject fobj=df.getPrimaryFile();
          File found=getFileFromFileObject(fobj);
          if (found == null) {
            return null;
          }
 else {
            return isFolder ? found.getParentFile() : found;
          }
        }
 else         if (dataObj instanceof MultiDataObject) {
          MultiDataObject mdo=(MultiDataObject)dataObj;
          FileObject fobj=mdo.getPrimaryFile();
          File found=getFileFromFileObject(fobj);
          if (found == null) {
            return null;
          }
 else {
            return isFolder ? found.getParentFile() : found;
          }
        }
      }
    }
 catch (    Exception e) {
      return null;
    }
    return null;
  }
}"
49784,"private void setIntentData(){
  Intent intent=getIntent();
  if (null != intent.getStringExtra(""String_Node_Str"")) {
    version=intent.getStringExtra(""String_Node_Str"");
  }
  if (null != intent.getStringExtra(""String_Node_Str"")) {
    search=intent.getStringExtra(""String_Node_Str"");
  }
  if (null != intent.getParcelableArrayListExtra(""String_Node_Str"")) {
    index=0;
    items=intent.getParcelableArrayListExtra(""String_Node_Str"");
  }
}","private void setIntentData(){
  Intent intent=getIntent();
  if (null != intent.getStringExtra(""String_Node_Str"")) {
    version=intent.getStringExtra(""String_Node_Str"");
  }
  if (null != intent.getStringExtra(""String_Node_Str"")) {
    search=intent.getStringExtra(""String_Node_Str"");
  }
  if (null != intent.getParcelableArrayListExtra(""String_Node_Str"")) {
    items=intent.getParcelableArrayListExtra(""String_Node_Str"");
  }
}"
49785,"private void resume(){
  String wanted=""String_Node_Str"";
  String current=((TextView)header.findViewById(R.id.version)).getText().toString();
  if (bible != null) {
    wanted=bible.getVersionName(bible.getVersion());
  }
  if (refresh || !wanted.equals(current)) {
    refresh=false;
    handler.sendEmptyMessage(CHECKBIBLEDATA);
    if (bible == null) {
      bible=Bible.getBible(getBaseContext());
    }
 else {
      bible.checkLocale();
    }
    Log.d(TAG,""String_Node_Str"" + version);
    if (""String_Node_Str"".equals(version)) {
      version=bible.getVersion();
    }
    if (version.endsWith(""String_Node_Str"")) {
      bible.setDefaultVersion();
    }
    handler.sendEmptyMessage(SHOWDATA);
  }
  synced=false;
  if (bible != null) {
    final long mtime=System.currentTimeMillis();
    bible.checkBibleData(false,new Runnable(){
      @Override public void run(){
        synced=true;
        if (notifySync) {
          String duration=String.valueOf(System.currentTimeMillis() - mtime);
          handler.sendMessage(handler.obtainMessage(SYNCED,duration));
        }
      }
    }
);
  }
  handler.sendEmptyMessage(DISMISSBAR);
}","private void resume(){
  String wanted=""String_Node_Str"";
  String current=((TextView)header.findViewById(R.id.version)).getText().toString();
  if (bible != null) {
    wanted=bible.getVersionName(bible.getVersion());
  }
  if (refresh || !wanted.equals(current)) {
    refresh=false;
    handler.sendEmptyMessage(CHECKBIBLEDATA);
    if (bible == null) {
      bible=Bible.getBible(getBaseContext());
    }
 else {
      bible.checkLocale();
    }
    Log.d(TAG,""String_Node_Str"" + version);
    if (""String_Node_Str"".equals(version)) {
      version=bible.getVersion();
    }
    if (version.endsWith(""String_Node_Str"")) {
      bible.setDefaultVersion();
    }
    handler.sendEmptyMessage(SHOWDATA);
  }
  if (bible != null) {
    final long mtime=System.currentTimeMillis();
    bible.checkBibleData(false,new Runnable(){
      @Override public void run(){
        synced=true;
        if (notifySync) {
          String duration=String.valueOf(System.currentTimeMillis() - mtime);
          handler.sendMessage(handler.obtainMessage(SYNCED,duration));
        }
      }
    }
);
  }
  handler.sendEmptyMessage(DISMISSBAR);
}"
49786,"protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.versions);
  bible=Bible.getBible(this);
  String[] from={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] to={R.id.code,R.id.name,R.id.action,0};
  adapter=new SimpleAdapter(this,data,R.layout.version,from,to){
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      View view=super.getView(position,convertView,parent);
      final TextView action=(TextView)view.findViewById(R.id.action);
      if (action != null) {
        action.setTag(position);
        action.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View view){
            int position=(Integer)view.getTag();
            @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)getItem(position);
            clickVersion((TextView)view,map);
          }
        }
);
      }
      return view;
    }
    Filter mFilter;
    public Filter getFilter(){
      if (mFilter == null) {
        mFilter=new SimpleFilter();
      }
      return mFilter;
    }
class SimpleFilter extends Filter {
      @Override protected FilterResults performFiltering(      CharSequence prefix){
        FilterResults results=new FilterResults();
        String filter=null;
        if (prefix != null && prefix.length() > 0) {
          filter=prefix.toString().toLowerCase(Locale.US);
        }
        data.clear();
        for (        Map<String,String> map : versions) {
          if (filter == null) {
            data.add(map);
          }
 else {
            for (            String value : map.values()) {
              if (value.toLowerCase(Locale.US).contains(filter)) {
                data.add(map);
                break;
              }
            }
          }
        }
        results.count=data.size();
        return results;
      }
      @Override protected void publishResults(      CharSequence constraint,      FilterResults results){
        if (results.count > 0) {
          notifyDataSetChanged();
        }
 else {
          notifyDataSetInvalidated();
        }
      }
    }
  }
;
  final ListView list=(ListView)findViewById(android.R.id.list);
  list.setAdapter(adapter);
  list.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)list.getItemAtPosition(position);
      TextView action=(TextView)view.findViewById(R.id.action);
      clickVersion(action,map);
    }
  }
);
  final EditText editText=(EditText)findViewById(R.id.query);
  editText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int before,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int after){
      filter=s;
      adapter.getFilter().filter(s);
    }
    @Override public void afterTextChanged(    Editable s){
    }
  }
);
  refresh=(ImageView)findViewById(R.id.refresh);
  refresh.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      refreshVersions();
    }
  }
);
}","protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.versions);
  bible=Bible.getBible(this);
  String[] from={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] to={R.id.code,R.id.name,R.id.action,0};
  adapter=new SimpleAdapter(this,data,R.layout.version,from,to){
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      if (data.size() <= position) {
synchronized (data) {
          data.clear();
          for (          Map<String,String> map : versions) {
            data.add(map);
          }
        }
      }
      View view=super.getView(position,convertView,parent);
      final TextView action=(TextView)view.findViewById(R.id.action);
      if (action != null) {
        action.setTag(position);
        action.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View view){
            int position=(Integer)view.getTag();
            @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)getItem(position);
            clickVersion((TextView)view,map);
          }
        }
);
      }
      return view;
    }
    Filter mFilter;
    public Filter getFilter(){
      if (mFilter == null) {
        mFilter=new SimpleFilter();
      }
      return mFilter;
    }
class SimpleFilter extends Filter {
      @Override protected FilterResults performFiltering(      CharSequence prefix){
        FilterResults results=new FilterResults();
        String filter=null;
        if (prefix != null && prefix.length() > 0) {
          filter=prefix.toString().toLowerCase(Locale.US);
        }
synchronized (data) {
          data.clear();
          for (          Map<String,String> map : versions) {
            if (filter == null) {
              data.add(map);
            }
 else {
              for (              String value : map.values()) {
                if (value.toLowerCase(Locale.US).contains(filter)) {
                  data.add(map);
                  break;
                }
              }
            }
          }
        }
        results.count=data.size();
        return results;
      }
      @Override protected void publishResults(      CharSequence constraint,      FilterResults results){
        if (results.count > 0) {
          notifyDataSetChanged();
        }
 else {
          notifyDataSetInvalidated();
        }
      }
    }
  }
;
  final ListView list=(ListView)findViewById(android.R.id.list);
  list.setAdapter(adapter);
  list.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)list.getItemAtPosition(position);
      TextView action=(TextView)view.findViewById(R.id.action);
      clickVersion(action,map);
    }
  }
);
  query=(EditText)findViewById(R.id.query);
  query.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int before,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int after){
      adapter.getFilter().filter(s);
    }
    @Override public void afterTextChanged(    Editable s){
    }
  }
);
  refresh=(ImageView)findViewById(R.id.refresh);
  refresh.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      refreshVersions();
    }
  }
);
}"
49787,"@Override public void onTextChanged(CharSequence s,int start,int before,int after){
  filter=s;
  adapter.getFilter().filter(s);
}","@Override public void onTextChanged(CharSequence s,int start,int before,int after){
  adapter.getFilter().filter(s);
}"
49788,"static void refresh(long id){
  if (resume) {
    boolean changed=false;
    String code=queue.get(String.valueOf(id));
    if (code != null) {
      queue.remove(String.valueOf(id));
      queue.remove(code);
      data.clear();
      for (      Map<String,String> map : versions) {
        if (String.valueOf(map.get(""String_Node_Str"")).equalsIgnoreCase(code)) {
          changed=true;
          String action=bible.getContext().getString(R.string.uninstall);
          map.put(""String_Node_Str"",action);
          map.put(""String_Node_Str"",action);
        }
        data.add(map);
      }
      if (changed) {
        adapter.notifyDataSetChanged();
        adapter.getFilter().filter(filter);
      }
    }
  }
}","static void refresh(long id){
  if (resume) {
    boolean changed=false;
    String code=queue.get(String.valueOf(id));
    if (code != null) {
      queue.remove(String.valueOf(id));
      queue.remove(code);
synchronized (data) {
        data.clear();
        for (        Map<String,String> map : versions) {
          if (String.valueOf(map.get(""String_Node_Str"")).equalsIgnoreCase(code)) {
            changed=true;
            String action=bible.getContext().getString(R.string.uninstall);
            map.put(""String_Node_Str"",action);
            map.put(""String_Node_Str"",action);
          }
          data.add(map);
        }
      }
      if (changed) {
        adapter.notifyDataSetChanged();
        query.setText(""String_Node_Str"");
      }
    }
  }
}"
49789,"@Override protected FilterResults performFiltering(CharSequence prefix){
  FilterResults results=new FilterResults();
  String filter=null;
  if (prefix != null && prefix.length() > 0) {
    filter=prefix.toString().toLowerCase(Locale.US);
  }
  data.clear();
  for (  Map<String,String> map : versions) {
    if (filter == null) {
      data.add(map);
    }
 else {
      for (      String value : map.values()) {
        if (value.toLowerCase(Locale.US).contains(filter)) {
          data.add(map);
          break;
        }
      }
    }
  }
  results.count=data.size();
  return results;
}","@Override protected FilterResults performFiltering(CharSequence prefix){
  FilterResults results=new FilterResults();
  String filter=null;
  if (prefix != null && prefix.length() > 0) {
    filter=prefix.toString().toLowerCase(Locale.US);
  }
synchronized (data) {
    data.clear();
    for (    Map<String,String> map : versions) {
      if (filter == null) {
        data.add(map);
      }
 else {
        for (        String value : map.values()) {
          if (value.toLowerCase(Locale.US).contains(filter)) {
            data.add(map);
            break;
          }
        }
      }
    }
  }
  results.count=data.size();
  return results;
}"
49790,"void setVersions(String json){
  if (json == null || json.length() == 0) {
    return;
  }
  data.clear();
  versions=parseVersions(json);
  for (  Map<String,String> map : versions) {
    data.add(map);
  }
  refresh(0);
  adapter.notifyDataSetChanged();
  adapter.getFilter().filter(filter);
}","void setVersions(String json){
  if (json == null || json.length() == 0) {
    return;
  }
  versions=parseVersions(json);
synchronized (data) {
    data.clear();
    for (    Map<String,String> map : versions) {
      data.add(map);
    }
  }
  refresh(0);
  adapter.notifyDataSetChanged();
  query.setText(""String_Node_Str"");
}"
49791,"@Override public View getView(int position,View convertView,ViewGroup parent){
  View view=super.getView(position,convertView,parent);
  final TextView action=(TextView)view.findViewById(R.id.action);
  if (action != null) {
    action.setTag(position);
    action.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        int position=(Integer)view.getTag();
        @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)getItem(position);
        clickVersion((TextView)view,map);
      }
    }
);
  }
  return view;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  if (data.size() <= position) {
synchronized (data) {
      data.clear();
      for (      Map<String,String> map : versions) {
        data.add(map);
      }
    }
  }
  View view=super.getView(position,convertView,parent);
  final TextView action=(TextView)view.findViewById(R.id.action);
  if (action != null) {
    action.setTag(position);
    action.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        int position=(Integer)view.getTag();
        @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)getItem(position);
        clickVersion((TextView)view,map);
      }
    }
);
  }
  return view;
}"
49792,"protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.versions);
  bible=Bible.getBible(this);
  String[] from={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] to={R.id.code,R.id.name,R.id.action,0};
  adapter=new SimpleAdapter(this,data,R.layout.version,from,to){
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      View view=super.getView(position,convertView,parent);
      final TextView action=(TextView)view.findViewById(R.id.action);
      if (action != null) {
        action.setTag(position);
        action.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View view){
            int position=(Integer)view.getTag();
            @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)getItem(position);
            clickVersion((TextView)view,map);
          }
        }
);
      }
      return view;
    }
    Filter mFilter;
    public Filter getFilter(){
      if (mFilter == null) {
        mFilter=new SimpleFilter();
      }
      return mFilter;
    }
class SimpleFilter extends Filter {
      @Override protected FilterResults performFiltering(      CharSequence prefix){
        FilterResults results=new FilterResults();
        String filter=null;
        if (prefix != null && prefix.length() > 0) {
          filter=prefix.toString().toLowerCase(Locale.US);
        }
        data.clear();
        List<Map<String,String>> values=versions;
        for (        Map<String,String> map : values) {
          if (filter == null) {
            data.add(map);
          }
 else {
            for (            String value : map.values()) {
              if (value.toLowerCase(Locale.US).contains(filter)) {
                data.add(map);
                break;
              }
            }
          }
        }
        results.count=data.size();
        return results;
      }
      @Override protected void publishResults(      CharSequence constraint,      FilterResults results){
        if (results.count > 0) {
          notifyDataSetChanged();
        }
 else {
          notifyDataSetInvalidated();
        }
      }
    }
  }
;
  final ListView list=(ListView)findViewById(android.R.id.list);
  list.setAdapter(adapter);
  list.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)list.getItemAtPosition(position);
      TextView action=(TextView)view.findViewById(R.id.action);
      clickVersion(action,map);
    }
  }
);
  final EditText editText=(EditText)findViewById(R.id.query);
  editText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int before,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int after){
      filter=s;
      adapter.getFilter().filter(s);
    }
    @Override public void afterTextChanged(    Editable s){
    }
  }
);
}","protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.versions);
  bible=Bible.getBible(this);
  String[] from={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] to={R.id.code,R.id.name,R.id.action,0};
  adapter=new SimpleAdapter(this,data,R.layout.version,from,to){
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      View view=super.getView(position,convertView,parent);
      final TextView action=(TextView)view.findViewById(R.id.action);
      if (action != null) {
        action.setTag(position);
        action.setOnClickListener(new View.OnClickListener(){
          @Override public void onClick(          View view){
            int position=(Integer)view.getTag();
            @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)getItem(position);
            clickVersion((TextView)view,map);
          }
        }
);
      }
      return view;
    }
    Filter mFilter;
    public Filter getFilter(){
      if (mFilter == null) {
        mFilter=new SimpleFilter();
      }
      return mFilter;
    }
class SimpleFilter extends Filter {
      @Override protected FilterResults performFiltering(      CharSequence prefix){
        FilterResults results=new FilterResults();
        String filter=null;
        if (prefix != null && prefix.length() > 0) {
          filter=prefix.toString().toLowerCase(Locale.US);
        }
        data.clear();
        for (        Map<String,String> map : versions) {
          if (filter == null) {
            data.add(map);
          }
 else {
            for (            String value : map.values()) {
              if (value.toLowerCase(Locale.US).contains(filter)) {
                data.add(map);
                break;
              }
            }
          }
        }
        results.count=data.size();
        return results;
      }
      @Override protected void publishResults(      CharSequence constraint,      FilterResults results){
        if (results.count > 0) {
          notifyDataSetChanged();
        }
 else {
          notifyDataSetInvalidated();
        }
      }
    }
  }
;
  final ListView list=(ListView)findViewById(android.R.id.list);
  list.setAdapter(adapter);
  list.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)list.getItemAtPosition(position);
      TextView action=(TextView)view.findViewById(R.id.action);
      clickVersion(action,map);
    }
  }
);
  final EditText editText=(EditText)findViewById(R.id.query);
  editText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int before,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int after){
      filter=s;
      adapter.getFilter().filter(s);
    }
    @Override public void afterTextChanged(    Editable s){
    }
  }
);
}"
49793,"static void refresh(long id){
  if (resume) {
    boolean changed=false;
    String code=queue.get(String.valueOf(id));
    if (code != null) {
      queue.remove(String.valueOf(id));
      queue.remove(code);
      for (      Map<String,String> map : data) {
        if (String.valueOf(map.get(""String_Node_Str"")).equalsIgnoreCase(code)) {
          changed=true;
          String action=bible.getContext().getString(R.string.uninstall);
          map.put(""String_Node_Str"",action);
          map.put(""String_Node_Str"",action);
        }
      }
      if (changed) {
        adapter.notifyDataSetChanged();
        adapter.getFilter().filter(filter);
      }
    }
  }
}","static void refresh(long id){
  if (resume) {
    boolean changed=false;
    String code=queue.get(String.valueOf(id));
    if (code != null) {
      queue.remove(String.valueOf(id));
      queue.remove(code);
      data.clear();
      for (      Map<String,String> map : versions) {
        if (String.valueOf(map.get(""String_Node_Str"")).equalsIgnoreCase(code)) {
          changed=true;
          String action=bible.getContext().getString(R.string.uninstall);
          map.put(""String_Node_Str"",action);
          map.put(""String_Node_Str"",action);
        }
        data.add(map);
      }
      if (changed) {
        adapter.notifyDataSetChanged();
        adapter.getFilter().filter(filter);
      }
    }
  }
}"
49794,"@Override protected FilterResults performFiltering(CharSequence prefix){
  FilterResults results=new FilterResults();
  String filter=null;
  if (prefix != null && prefix.length() > 0) {
    filter=prefix.toString().toLowerCase(Locale.US);
  }
  data.clear();
  List<Map<String,String>> values=versions;
  for (  Map<String,String> map : values) {
    if (filter == null) {
      data.add(map);
    }
 else {
      for (      String value : map.values()) {
        if (value.toLowerCase(Locale.US).contains(filter)) {
          data.add(map);
          break;
        }
      }
    }
  }
  results.count=data.size();
  return results;
}","@Override protected FilterResults performFiltering(CharSequence prefix){
  FilterResults results=new FilterResults();
  String filter=null;
  if (prefix != null && prefix.length() > 0) {
    filter=prefix.toString().toLowerCase(Locale.US);
  }
  data.clear();
  for (  Map<String,String> map : versions) {
    if (filter == null) {
      data.add(map);
    }
 else {
      for (      String value : map.values()) {
        if (value.toLowerCase(Locale.US).contains(filter)) {
          data.add(map);
          break;
        }
      }
    }
  }
  results.count=data.size();
  return results;
}"
49795,"public boolean checkVersions(){
  if (!setDatabasePath()) {
    return false;
  }
  File path=getExternalFilesDirWrapper();
  File oldpath=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  Long oldmtime=mtime.get(path.getAbsolutePath());
  if (oldmtime == null) {
    oldmtime=0L;
  }
  if (versions.size() != 0 && path.lastModified() <= oldmtime && (!oldpath.exists() || !oldpath.isDirectory() || oldpath.lastModified() <= oldmtime)) {
    return true;
  }
  versions.clear();
  checkVersion(oldpath);
  checkVersion(path);
  Collections.sort(versions);
  if (versions.size() == 0) {
    setDemoVersions();
    unpacked=true;
    if (Locale.getDefault().equals(Locale.SIMPLIFIED_CHINESE)) {
      versions.add(""String_Node_Str"");
      versions.add(""String_Node_Str"");
    }
 else {
      versions.add(""String_Node_Str"");
      versions.add(""String_Node_Str"");
    }
    checkVersion(mContext.getFilesDir());
  }
  mtime.put(path.getAbsolutePath(),path.lastModified());
  return true;
}","public boolean checkVersions(){
  if (!setDatabasePath()) {
    checkInternalVersions();
    return false;
  }
  File path=getExternalFilesDirWrapper();
  File oldpath=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  Long oldmtime=mtime.get(path.getAbsolutePath());
  if (oldmtime == null) {
    oldmtime=0L;
  }
  if (versions.size() != 0 && path.lastModified() <= oldmtime && (!oldpath.exists() || !oldpath.isDirectory() || oldpath.lastModified() <= oldmtime)) {
    return true;
  }
  versions.clear();
  checkVersion(oldpath);
  checkVersion(path);
  Collections.sort(versions);
  if (versions.size() == 0) {
    checkInternalVersions();
  }
  mtime.put(path.getAbsolutePath(),path.lastModified());
  return true;
}"
49796,"public boolean setVersion(String version){
  if (version == null) {
    return false;
  }
  File file=getFile(version);
  if (file == null || !file.exists() || !file.isFile()) {
    if (""String_Node_Str"".equals(databaseVersion)) {
      return setDefaultVersion();
    }
 else {
      return false;
    }
  }
  if (database != null) {
    if (databaseVersion.equals(version)) {
      return true;
    }
    Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
    database.close();
  }
  databaseVersion=version;
  try {
    database=SQLiteDatabase.openDatabase(file.getAbsolutePath(),null,SQLiteDatabase.OPEN_READONLY | SQLiteDatabase.NO_LOCALIZED_COLLATORS);
    Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
    setMetadata(database,databaseVersion);
    return true;
  }
 catch (  Exception e) {
    try {
      file.delete();
    }
 catch (    Exception f) {
    }
    checkVersions();
    return setDefaultVersion();
  }
}","public boolean setVersion(String version){
  if (version == null) {
    return false;
  }
  File file=getFile(version);
  if (file == null || !file.isFile()) {
    if (""String_Node_Str"".equals(databaseVersion)) {
      return setDefaultVersion();
    }
 else {
      return false;
    }
  }
  if (database != null) {
    if (databaseVersion.equals(version)) {
      return true;
    }
    Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
    database.close();
  }
  databaseVersion=version;
  try {
    database=SQLiteDatabase.openDatabase(file.getAbsolutePath(),null,SQLiteDatabase.OPEN_READONLY | SQLiteDatabase.NO_LOCALIZED_COLLATORS);
    Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
    setMetadata(database,databaseVersion);
    return true;
  }
 catch (  Exception e) {
    try {
      file.delete();
    }
 catch (    Exception f) {
    }
    checkVersions();
    return setDefaultVersion();
  }
}"
49797,"public boolean deleteVersion(String version){
  File file=getFile(version);
  return file.delete();
}","public boolean deleteVersion(String version){
}"
49798,"public boolean setDefaultVersion(){
  if (versions.size() == 0) {
    return false;
  }
  String version=PreferenceManager.getDefaultSharedPreferences(mContext).getString(""String_Node_Str"",null);
  if (version != null && getPosition(TYPE.VERSION,version) < 0) {
    version=null;
  }
  if (version == null && getCount(TYPE.VERSION) > 0) {
    version=get(TYPE.VERSION,0);
  }
  if (version != null) {
    return setVersion(version);
  }
  return false;
}","public boolean setDefaultVersion(){
  if (versions.size() == 0) {
    return false;
  }
  String version=PreferenceManager.getDefaultSharedPreferences(mContext).getString(""String_Node_Str"",null);
  if (version != null) {
    File file=getFile(version);
    if (file == null || !file.isFile()) {
      checkVersions();
      version=null;
    }
  }
  if (version == null && getCount(TYPE.VERSION) > 0) {
    version=get(TYPE.VERSION,0);
  }
  if (version != null) {
    return setVersion(version);
  }
  return false;
}"
49799,"private void setDemoVersions(){
  if (unpacked) {
    return;
  }
  int demoVersion=PreferenceManager.getDefaultSharedPreferences(mContext).getInt(""String_Node_Str"",0);
  int versionCode=0;
  try {
    versionCode=mContext.getPackageManager().getPackageInfo(mContext.getPackageName(),0).versionCode;
  }
 catch (  Throwable t) {
  }
  boolean newVersion=(demoVersion != versionCode);
  boolean unpack=unpackRaw(newVersion,R.raw.niv84demo,new File(mContext.getFilesDir(),""String_Node_Str""));
  if (unpack) {
    unpack=unpackRaw(newVersion,R.raw.cunpssdemo,new File(mContext.getFilesDir(),""String_Node_Str""));
  }
  if (newVersion && unpack) {
    PreferenceManager.getDefaultSharedPreferences(mContext).edit().putInt(""String_Node_Str"",versionCode).commit();
  }
}","private void setDemoVersions(){
  int demoVersion=PreferenceManager.getDefaultSharedPreferences(mContext).getInt(""String_Node_Str"",0);
  int versionCode=0;
  try {
    versionCode=mContext.getPackageManager().getPackageInfo(mContext.getPackageName(),0).versionCode;
  }
 catch (  Throwable t) {
  }
  boolean newVersion=(demoVersion != versionCode);
  boolean unpack=unpackRaw(newVersion,R.raw.niv84demo,new File(mContext.getFilesDir(),""String_Node_Str""));
  if (unpack) {
    unpack=unpackRaw(newVersion,R.raw.cunpssdemo,new File(mContext.getFilesDir(),""String_Node_Str""));
  }
  if (newVersion && unpack) {
    PreferenceManager.getDefaultSharedPreferences(mContext).edit().putInt(""String_Node_Str"",versionCode).commit();
  }
}"
49800,"private Bible(Context context){
  Log.d(TAG,""String_Node_Str"");
  mContext=context;
  checkLocale();
  checkVersions();
  setDefaultVersion();
}","private Bible(Context context){
  Log.d(TAG,""String_Node_Str"");
  mContext=context;
  checkLocale();
  checkVersions();
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")) {
  }
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")) {
  }
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")) {
  }
  setDefaultVersion();
}"
49801,"public void run(){
  setMetadata(datapath,dataversion);
}","public void run(){
  getBible(context);
}"
49802,"public boolean setVersion(String version){
  if (version == null) {
    return false;
  }
  if (databasePath == null) {
    return false;
  }
  if (database != null) {
    if (databaseVersion.equals(version)) {
      return true;
    }
    Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
    database.close();
  }
  File file=null;
  version=version.toLowerCase(Locale.US);
  if (version.endsWith(""String_Node_Str"")) {
    file=new File(mContext.getFilesDir(),version + ""String_Node_Str"");
  }
 else   if (version.equals(""String_Node_Str"")) {
    file=new File(databasePath,""String_Node_Str"");
  }
 else   if (version.equals(""String_Node_Str"")) {
    file=new File(databasePath,""String_Node_Str"");
  }
  if (file == null || !file.exists() || !file.isFile()) {
    file=new File(databasePath,version + ""String_Node_Str"");
  }
  if (file.exists() && file.isFile()) {
    databaseVersion=version;
    try {
      database=SQLiteDatabase.openDatabase(file.getAbsolutePath(),null,SQLiteDatabase.OPEN_READONLY | SQLiteDatabase.NO_LOCALIZED_COLLATORS);
      Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
      final String datapath=file.getAbsolutePath();
      final String dataversion=databaseVersion;
      new Thread(new Runnable(){
        public void run(){
          setMetadata(datapath,dataversion);
        }
      }
).start();
      return true;
    }
 catch (    Exception e) {
      try {
        file.delete();
      }
 catch (      Exception f) {
      }
      checkVersions();
      return setDefaultVersion();
    }
  }
 else {
    Log.e(TAG,""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
    databaseVersion=""String_Node_Str"";
    database=null;
    return false;
  }
}","public boolean setVersion(String version){
  if (version == null) {
    return false;
  }
  if (databasePath == null) {
    return false;
  }
  if (database != null) {
    if (databaseVersion.equals(version)) {
      return true;
    }
    Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
    database.close();
  }
  File file=null;
  version=version.toLowerCase(Locale.US);
  if (version.endsWith(""String_Node_Str"")) {
    file=new File(mContext.getFilesDir(),version + ""String_Node_Str"");
  }
 else   if (version.equals(""String_Node_Str"")) {
    file=new File(databasePath,""String_Node_Str"");
  }
 else   if (version.equals(""String_Node_Str"")) {
    file=new File(databasePath,""String_Node_Str"");
  }
  if (file == null || !file.exists() || !file.isFile()) {
    file=new File(databasePath,version + ""String_Node_Str"");
  }
  if (file.exists() && file.isFile()) {
    databaseVersion=version;
    try {
      database=SQLiteDatabase.openDatabase(file.getAbsolutePath(),null,SQLiteDatabase.OPEN_READONLY | SQLiteDatabase.NO_LOCALIZED_COLLATORS);
      Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
      setMetadata(database,databaseVersion);
      return true;
    }
 catch (    Exception e) {
      try {
        file.delete();
      }
 catch (      Exception f) {
      }
      checkVersions();
      return setDefaultVersion();
    }
  }
 else {
    Log.e(TAG,""String_Node_Str"" + file.getAbsolutePath() + ""String_Node_Str"");
    databaseVersion=""String_Node_Str"";
    database=null;
    return false;
  }
}"
49803,"private boolean setDefaultVersion(){
  if (versions.size() == 0) {
    return false;
  }
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")) {
  }
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")) {
  }
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")) {
  }
  String version=PreferenceManager.getDefaultSharedPreferences(mContext).getString(""String_Node_Str"",null);
  if (version != null && getPosition(TYPE.VERSION,version) < 0) {
    version=null;
  }
  if (version == null && getCount(TYPE.VERSION) > 0) {
    version=get(TYPE.VERSION,0);
  }
  if (version != null) {
    return setVersion(version);
  }
  return false;
}","private boolean setDefaultVersion(){
  if (versions.size() == 0) {
    return false;
  }
  String version=PreferenceManager.getDefaultSharedPreferences(mContext).getString(""String_Node_Str"",null);
  if (version != null && getPosition(TYPE.VERSION,version) < 0) {
    version=null;
  }
  if (version == null && getCount(TYPE.VERSION) > 0) {
    version=get(TYPE.VERSION,0);
  }
  if (version != null) {
    return setVersion(version);
  }
  return false;
}"
49804,"private void setMetadata(String datapath,String dataversion){
  SQLiteDatabase metadata=SQLiteDatabase.openDatabase(datapath,null,SQLiteDatabase.OPEN_READONLY | SQLiteDatabase.NO_LOCALIZED_COLLATORS);
  Cursor cursor=metadata.query(Provider.TABLE_BOOKS,Provider.COLUMNS_BOOKS,null,null,null,null,null);
  osiss.clear();
  books.clear();
  chapters.clear();
  humans.clear();
  try {
    while (cursor.moveToNext()) {
      String osis=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_OSIS));
      String human=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_HUMAN));
      String chapter=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_CHAPTERS));
      if (""String_Node_Str"".equals(human)) {
        human=""String_Node_Str"";
      }
      if (!isCJK(human)) {
        humanEN.put(osis,human);
      }
 else       if (isVersionZHCN(dataversion)) {
        humanZHCN.put(osis,human);
      }
 else       if (isVersionZHTW(dataversion)) {
        humanZHTW.put(osis,human);
      }
      osiss.add(osis);
      if (scale > 1.0f) {
        books.add(human);
      }
 else {
        if (dataversion.endsWith(""String_Node_Str"")) {
          books.add(getResourceValue(osisZHTW,osis));
        }
 else         if (dataversion.endsWith(""String_Node_Str"") || dataversion.equals(""String_Node_Str"")) {
          books.add(getResourceValue(osisZHCN,osis));
        }
 else {
          books.add(osis);
        }
      }
      chapters.add(chapter);
      humans.add(human);
    }
  }
  finally {
    cursor.close();
  }
  metadata.close();
}","private void setMetadata(SQLiteDatabase metadata,String dataversion){
  Cursor cursor=metadata.query(Provider.TABLE_BOOKS,Provider.COLUMNS_BOOKS,null,null,null,null,null);
  osiss.clear();
  books.clear();
  chapters.clear();
  humans.clear();
  try {
    while (cursor.moveToNext()) {
      String osis=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_OSIS));
      String human=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_HUMAN));
      String chapter=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_CHAPTERS));
      if (""String_Node_Str"".equals(human)) {
        human=""String_Node_Str"";
      }
      if (!isCJK(human)) {
        humanEN.put(osis,human);
      }
 else       if (isVersionZHCN(dataversion)) {
        humanZHCN.put(osis,human);
      }
 else       if (isVersionZHTW(dataversion)) {
        humanZHTW.put(osis,human);
      }
      osiss.add(osis);
      if (scale > 1.0f) {
        books.add(human);
      }
 else {
        if (dataversion.endsWith(""String_Node_Str"")) {
          books.add(getResourceValue(osisZHTW,osis));
        }
 else         if (dataversion.endsWith(""String_Node_Str"") || dataversion.equals(""String_Node_Str"")) {
          books.add(getResourceValue(osisZHCN,osis));
        }
 else {
          books.add(osis);
        }
      }
      chapters.add(chapter);
      humans.add(human);
    }
  }
  finally {
    cursor.close();
  }
}"
49805,"@Override public void onPause(){
  getVerse();
  Log.d(TAG,""String_Node_Str"");
  storeOsisVersion();
  super.onPause();
}","@Override public void onPause(){
  getVerse();
  Log.d(TAG,""String_Node_Str"");
  storeOsisVersion();
  hasIntentData=false;
  super.onPause();
}"
49806,"private boolean openOsis(String newOsis,String verse,String end){
  if (newOsis == null || newOsis.equals(""String_Node_Str"")) {
    return false;
  }
  if (!osis.equals(newOsis)) {
    uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(newOsis).build();
    this.verse=verse;
    this.end=end;
    showUri();
  }
  return true;
}","private boolean openOsis(String newOsis,String verse,String end){
  if (newOsis == null || newOsis.equals(""String_Node_Str"")) {
    return false;
  }
  if (!osis.equals(newOsis)) {
    uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(newOsis).build();
    if (""String_Node_Str"".equals(this.verse)) {
      this.verse=verse;
    }
    this.end=end;
    showUri();
  }
  return true;
}"
49807,"public void setItemText(int index){
  if (items != null && index >= 0 && index < items.size()) {
    OsisItem item=items.get(index);
    String book=bible.get(Bible.TYPE.BOOK,bible.getPosition(Bible.TYPE.OSIS,item.book)) + item.chapter;
    if (!verse.equals(""String_Node_Str"") || !end.equals(""String_Node_Str"")) {
      book+=""String_Node_Str"" + verse + ""String_Node_Str""+ end;
    }
    ((TextView)findViewById(R.id.items)).setText(book);
  }
}","public void setItemText(int index){
  if (items != null && index >= 0 && index < items.size()) {
    OsisItem item=items.get(index);
    String book=bible.get(Bible.TYPE.BOOK,bible.getPosition(Bible.TYPE.OSIS,item.book)) + item.chapter;
    if (!item.verse.equals(""String_Node_Str"") || !item.end.equals(""String_Node_Str"")) {
      book+=""String_Node_Str"" + item.verse + ""String_Node_Str""+ item.end;
    }
    ((TextView)findViewById(R.id.items)).setText(book);
  }
}"
49808,"@Override @SuppressLint(""String_Node_Str"") protected void onCreate(Bundle savedInstanceState){
  if (Build.MODEL.equals(""String_Node_Str"")) {
    setTheme(android.R.style.Theme_Light_NoTitleBar);
  }
  super.onCreate(savedInstanceState);
  setContentView(R.layout.chapter);
  findViewById(R.id.book).setOnClickListener(this);
  findViewById(R.id.chapter).setOnClickListener(this);
  findViewById(R.id.search).setOnClickListener(this);
  findViewById(R.id.version).setOnClickListener(this);
  findViewById(R.id.share).setOnClickListener(this);
  findViewById(R.id.items).setOnClickListener(this);
  adapter=new ArrayAdapter<String>(this,R.layout.grid){
    private LayoutInflater inflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      View view=convertView;
      ToggleButton grid=null;
      if (view == null) {
        view=inflater.inflate(R.layout.grid,null);
      }
      grid=(ToggleButton)view.findViewById(R.id.text1);
      grid.setTextOn(getItem(position));
      grid.setTextOff(getItem(position));
      grid.setChecked(getItem(position).equals(selected));
      grid.setVisibility(getItem(position).equals(""String_Node_Str"") ? View.INVISIBLE : View.VISIBLE);
      return view;
    }
  }
;
  gridview=(GridView)findViewById(R.id.gridview);
  gridview.setAdapter(adapter);
  gridview.setVisibility(View.GONE);
  gridview.setOnItemClickListener(this);
  setGestureDetector();
  webview=(WebView)findViewById(R.id.webview);
  webview.getSettings().setJavaScriptEnabled(true);
  webview.getSettings().setSupportZoom(true);
  webview.getSettings().setBuiltInZoomControls(true);
  webview.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
  webview.addJavascriptInterface(new Object(){
    @SuppressWarnings(""String_Node_Str"") public void setVerse(    String string){
synchronized (verseLock) {
        verse=string;
        Log.d(TAG,""String_Node_Str"" + verse);
        verseLock.notifyAll();
      }
    }
    @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void setCopyText(    String text){
      if (!text.equals(""String_Node_Str"")) {
        copytext=bible.getVersionFullname(version).replace(""String_Node_Str"" + getString(R.string.demo) + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        copytext+=bible.get(Bible.TYPE.HUMAN,bible.getPosition(Bible.TYPE.OSIS,book)) + ""String_Node_Str"" + chapter+ ""String_Node_Str""+ text;
        ((android.text.ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE)).setText(copytext);
        Log.d(TAG,""String_Node_Str"" + copytext);
      }
 else {
        copytext=""String_Node_Str"";
      }
      handler.sendEmptyMessage(COPYTEXT);
    }
  }
,""String_Node_Str"");
  setZoomButtonsController(webview);
  osis=PreferenceManager.getDefaultSharedPreferences(this).getString(""String_Node_Str"",""String_Node_Str"");
  verse=PreferenceManager.getDefaultSharedPreferences(this).getString(""String_Node_Str"",""String_Node_Str"");
  uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(osis).fragment(version).build();
  setIntentData();
  int color=0x6633B5E5;
  Integer mHighlightColor=(Integer)Bible.getField(findViewById(R.id.version),TextView.class,""String_Node_Str"");
  if (mHighlightColor != null) {
    color=mHighlightColor.intValue();
  }
  background=String.format(""String_Node_Str"",(color >> 16) & 0xFF,(color >> 8) & 0xFF,color & 0xFF,(color >>> 24) / 255.0);
  Log.d(TAG,""String_Node_Str"");
}","@Override @SuppressLint(""String_Node_Str"") protected void onCreate(Bundle savedInstanceState){
  if (Build.MODEL.equals(""String_Node_Str"")) {
    setTheme(android.R.style.Theme_Light_NoTitleBar);
  }
  super.onCreate(savedInstanceState);
  setContentView(R.layout.chapter);
  findViewById(R.id.book).setOnClickListener(this);
  findViewById(R.id.chapter).setOnClickListener(this);
  findViewById(R.id.search).setOnClickListener(this);
  findViewById(R.id.version).setOnClickListener(this);
  findViewById(R.id.share).setOnClickListener(this);
  findViewById(R.id.items).setOnClickListener(this);
  adapter=new ArrayAdapter<String>(this,R.layout.grid){
    private LayoutInflater inflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      View view=convertView;
      ToggleButton grid=null;
      if (view == null) {
        view=inflater.inflate(R.layout.grid,null);
      }
      grid=(ToggleButton)view.findViewById(R.id.text1);
      grid.setTextOn(getItem(position));
      grid.setTextOff(getItem(position));
      grid.setChecked(getItem(position).equals(selected));
      grid.setVisibility(getItem(position).equals(""String_Node_Str"") ? View.INVISIBLE : View.VISIBLE);
      return view;
    }
  }
;
  gridview=(GridView)findViewById(R.id.gridview);
  gridview.setAdapter(adapter);
  gridview.setVisibility(View.GONE);
  gridview.setOnItemClickListener(this);
  setGestureDetector();
  webview=(WebView)findViewById(R.id.webview);
  webview.getSettings().setJavaScriptEnabled(true);
  webview.getSettings().setSupportZoom(true);
  webview.getSettings().setBuiltInZoomControls(true);
  webview.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
  webview.addJavascriptInterface(new Object(){
    @SuppressWarnings(""String_Node_Str"") public void setVerse(    String string){
synchronized (verseLock) {
        verse=string;
        Log.d(TAG,""String_Node_Str"" + verse);
        verseLock.notifyAll();
      }
    }
    @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void setCopyText(    String text){
      if (!text.equals(""String_Node_Str"")) {
        copytext=bible.getVersionFullname(version).replace(""String_Node_Str"" + getString(R.string.demo) + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        copytext+=bible.get(Bible.TYPE.HUMAN,bible.getPosition(Bible.TYPE.OSIS,book)) + ""String_Node_Str"" + chapter+ ""String_Node_Str""+ text;
        ((android.text.ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE)).setText(copytext);
        Log.d(TAG,""String_Node_Str"" + copytext);
      }
 else {
        copytext=""String_Node_Str"";
      }
      handler.sendEmptyMessage(COPYTEXT);
    }
  }
,""String_Node_Str"");
  setZoomButtonsController(webview);
  osis=PreferenceManager.getDefaultSharedPreferences(this).getString(""String_Node_Str"",""String_Node_Str"");
  uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(osis).fragment(version).build();
  setIntentData();
  int color=0x6633B5E5;
  Integer mHighlightColor=(Integer)Bible.getField(findViewById(R.id.version),TextView.class,""String_Node_Str"");
  if (mHighlightColor != null) {
    color=mHighlightColor.intValue();
  }
  background=String.format(""String_Node_Str"",(color >> 16) & 0xFF,(color >> 8) & 0xFF,color & 0xFF,(color >>> 24) / 255.0);
  Log.d(TAG,""String_Node_Str"");
  hasIntentData=true;
}"
49809,"@Override public void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"" + items);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(this);
  verse=sp.getString(""String_Node_Str"",""String_Node_Str"");
  if (items == null && search == null) {
    if (!""String_Node_Str"".equals(sp.getString(""String_Node_Str"",""String_Node_Str""))) {
      index=sp.getInt(""String_Node_Str"",0);
      Log.d(TAG,""String_Node_Str"");
      Intent passageIntent=new Intent(getApplicationContext(),Passage.class);
      passageIntent.setAction(Intent.ACTION_VIEW);
      passageIntent.setData(Uri.parse(""String_Node_Str"" + sp.getString(""String_Node_Str"",""String_Node_Str"")));
      startActivity(passageIntent);
      finish();
    }
  }
  showData();
}","@Override public void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"" + items);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(this);
  if (!hasIntentData) {
    verse=sp.getString(""String_Node_Str"",""String_Node_Str"");
  }
  if (items == null && search == null) {
    if (!""String_Node_Str"".equals(sp.getString(""String_Node_Str"",""String_Node_Str""))) {
      index=sp.getInt(""String_Node_Str"",0);
      Log.d(TAG,""String_Node_Str"");
      Intent passageIntent=new Intent(getApplicationContext(),Passage.class);
      passageIntent.setAction(Intent.ACTION_VIEW);
      passageIntent.setData(Uri.parse(""String_Node_Str"" + sp.getString(""String_Node_Str"",""String_Node_Str"")));
      startActivity(passageIntent);
      finish();
    }
  }
  showData();
}"
49810,"@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  setIntent(intent);
  setIntentData();
}","@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  setIntent(intent);
  setIntentData();
  hasIntentData=true;
}"
49811,"private void _showContent(String title,String content){
  if (!title.equals(""String_Node_Str"")) {
    versename=""String_Node_Str"" + version + ""String_Node_Str""+ book.toLowerCase(Locale.US)+ ""String_Node_Str""+ chapter;
  }
 else {
    versename=""String_Node_Str"";
  }
  copytext=""String_Node_Str"";
  showView(R.id.share,!copytext.equals(""String_Node_Str""));
  String context=content;
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"" + versename + ""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"" + versename + ""String_Node_Str"");
  if (Locale.getDefault().equals(Locale.SIMPLIFIED_CHINESE)) {
    context=context.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    context=context.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  fontsize=(int)(fontsize * scale);
  if (fontsize > 32) {
    fontsize=24;
  }
  String body=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"" + fontsize + ""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"" + background + ""String_Node_Str"";
  body+=""String_Node_Str"" + background + ""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"" + title + ""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=String.format(""String_Node_Str"",verse.equals(""String_Node_Str"") ? ""String_Node_Str"" : verse,end.equals(""String_Node_Str"") ? ""String_Node_Str"" : verse,versename,items != null ? search : ""String_Node_Str"");
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  if (!""String_Node_Str"".equals(title) && bible.getVersion().endsWith(""String_Node_Str"")) {
    String link_market=""String_Node_Str"" + getString(R.string.bibledatalink) + ""String_Node_Str""+ getString(R.string.bibledatahuman)+ ""String_Node_Str"";
    body+=""String_Node_Str"" + getString(R.string.noversion,new Object[]{link_market,link_github}) + ""String_Node_Str"";
  }
  body+=""String_Node_Str"";
  body+=context;
  body+=""String_Node_Str"";
  webview.clearCache(true);
  webview.setInitialScale(100);
  scale=1.0f;
  webview.loadDataWithBaseURL(""String_Node_Str"",body,""String_Node_Str"",""String_Node_Str"",null);
}","private void _showContent(String title,String content){
  if (!title.equals(""String_Node_Str"")) {
    versename=""String_Node_Str"" + version + ""String_Node_Str""+ book.toLowerCase(Locale.US)+ ""String_Node_Str""+ chapter;
  }
 else {
    versename=""String_Node_Str"";
  }
  copytext=""String_Node_Str"";
  showView(R.id.share,!copytext.equals(""String_Node_Str""));
  String context=content;
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"" + versename + ""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"" + versename + ""String_Node_Str"");
  if (Locale.getDefault().equals(Locale.SIMPLIFIED_CHINESE)) {
    context=context.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    context=context.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  }
  fontsize=(int)(fontsize * scale);
  if (fontsize > 32) {
    fontsize=24;
  }
  String body=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"" + fontsize + ""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"" + background + ""String_Node_Str"";
  body+=""String_Node_Str"" + background + ""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"" + title + ""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=String.format(""String_Node_Str"",verse.equals(""String_Node_Str"") ? ""String_Node_Str"" : verse,end.equals(""String_Node_Str"") ? ""String_Node_Str"" : verse,versename,items != null ? search : ""String_Node_Str"");
  verse=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  if (!""String_Node_Str"".equals(title) && bible.getVersion().endsWith(""String_Node_Str"")) {
    String link_market=""String_Node_Str"" + getString(R.string.bibledatalink) + ""String_Node_Str""+ getString(R.string.bibledatahuman)+ ""String_Node_Str"";
    body+=""String_Node_Str"" + getString(R.string.noversion,new Object[]{link_market,link_github}) + ""String_Node_Str"";
  }
  body+=""String_Node_Str"";
  body+=context;
  body+=""String_Node_Str"";
  webview.clearCache(true);
  webview.setInitialScale(100);
  scale=1.0f;
  webview.loadDataWithBaseURL(""String_Node_Str"",body,""String_Node_Str"",""String_Node_Str"",null);
}"
49812,"public static ArrayList<OsisItem> parseSearch(String s,Context context){
  ArrayList<OsisItem> items=new ArrayList<OsisItem>();
  if (s == null) {
    return items;
  }
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  Pattern p=Pattern.compile(""String_Node_Str"");
  Matcher m=p.matcher(s);
  while (m.find()) {
    String book=m.group(1);
    if (book.startsWith(""String_Node_Str"")) {
      book=""String_Node_Str"";
    }
    String osis=Bible.getBible(context).getOsis(book);
    String start_chapter=m.group(2);
    String start_verse=m.group(3);
    String end_chapter=m.group(4);
    String end_verse=m.group(5);
    Log.d(""String_Node_Str"",String.format(""String_Node_Str"",book,osis,start_chapter,start_verse,end_chapter,end_verse));
    if (osis == null) {
      continue;
    }
    if (""String_Node_Str"".equals(start_chapter)) {
      items.add(new OsisItem(osis));
    }
 else     if (""String_Node_Str"".equals(end_chapter) || (!""String_Node_Str"".equals(start_verse) && ""String_Node_Str"".equals(end_verse))) {
      items.add(new OsisItem(osis,start_chapter,start_verse,end_chapter));
    }
 else     if (""String_Node_Str"".equals(start_verse) || (!""String_Node_Str"".equals(start_verse) && !""String_Node_Str"".equals(end_verse))) {
      int start=Integer.parseInt(start_chapter);
      int end=Integer.parseInt(end_chapter);
      items.add(new OsisItem(osis,start_chapter,start_verse));
      for (int i=start + 1; i < end; i++) {
        items.add(new OsisItem(osis,i));
      }
      if (end > start) {
        items.add(new OsisItem(osis,end_chapter,end_verse.equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"",end_verse));
      }
    }
  }
  return items;
}","public static ArrayList<OsisItem> parseSearch(String s,Context context){
  ArrayList<OsisItem> items=new ArrayList<OsisItem>();
  if (s == null) {
    return items;
  }
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  Pattern p=Pattern.compile(""String_Node_Str"");
  Matcher m=p.matcher(s);
  while (m.find()) {
    String book=m.group(1);
    if (book.startsWith(""String_Node_Str"")) {
      book=""String_Node_Str"";
    }
    String osis=Bible.getBible(context).getOsis(book);
    String start_chapter=m.group(2);
    String start_verse=m.group(3);
    String end_chapter=m.group(4);
    String end_verse=m.group(5);
    Log.d(""String_Node_Str"",String.format(""String_Node_Str"",book,osis,start_chapter,start_verse,end_chapter,end_verse));
    if (osis == null) {
      continue;
    }
    if (""String_Node_Str"".equals(start_chapter)) {
      items.add(new OsisItem(osis));
    }
 else     if (""String_Node_Str"".equals(end_chapter) || (!""String_Node_Str"".equals(start_verse) && ""String_Node_Str"".equals(end_verse))) {
      items.add(new OsisItem(osis,start_chapter,start_verse,end_chapter));
    }
 else     if (""String_Node_Str"".equals(start_verse) || (!""String_Node_Str"".equals(start_verse) && !""String_Node_Str"".equals(end_verse))) {
      int start=Integer.parseInt(start_chapter);
      int end=Integer.parseInt(end_chapter);
      items.add(new OsisItem(osis,start_chapter,start_verse));
      for (int i=start + 1; i < end; i++) {
        items.add(new OsisItem(osis,i));
      }
      if (end > start) {
        items.add(new OsisItem(osis,end_chapter,end_verse.equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"",end_verse));
      }
    }
  }
  return items;
}"
49813,"@Override public void onClick(View v){
  if (bible.getCount(Bible.TYPE.VERSION) == 0 && bible.getDatabase() == null && v.getId() != R.id.version) {
    return;
  }
switch (v.getId()) {
case R.id.version:
    getVerse();
case R.id.book:
case R.id.chapter:
case R.id.items:
  showSpinner(v);
break;
case R.id.search:
onSearchRequested();
break;
case R.id.share:
if (!copytext.equals(""String_Node_Str"")) {
Intent sendIntent=new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT,copytext);
sendIntent.setType(""String_Node_Str"");
startActivity(Intent.createChooser(sendIntent,getResources().getText(R.string.share)));
}
}
}","@Override public void onClick(View v){
  gridview.setVisibility(View.GONE);
  if (bible.getCount(Bible.TYPE.VERSION) == 0 && bible.getDatabase() == null && v.getId() != R.id.version) {
    return;
  }
switch (v.getId()) {
case R.id.version:
    getVerse();
case R.id.book:
case R.id.chapter:
case R.id.items:
  showSpinner(v);
break;
case R.id.search:
onSearchRequested();
break;
case R.id.share:
if (!copytext.equals(""String_Node_Str"")) {
Intent sendIntent=new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT,copytext);
sendIntent.setType(""String_Node_Str"");
startActivity(Intent.createChooser(sendIntent,getResources().getText(R.string.share)));
}
}
}"
49814,"private void storeOsisVersion(){
  final Editor editor=PreferenceManager.getDefaultSharedPreferences(this).edit();
  editor.putString(""String_Node_Str"",osis);
  if (!version.endsWith(""String_Node_Str"") && !version.equals(""String_Node_Str"")) {
    editor.putString(""String_Node_Str"",version);
  }
  editor.putString(""String_Node_Str"",verse);
  editor.putInt(""String_Node_Str"",fontsize);
  if (items != null && items.size() > 0 && search != null && !search.equals(""String_Node_Str"")) {
    editor.putString(""String_Node_Str"",search);
    editor.putInt(""String_Node_Str"",index);
  }
 else {
    editor.remove(""String_Node_Str"");
    editor.remove(""String_Node_Str"");
  }
  if (!book.equals(""String_Node_Str"") && !chapter.equals(""String_Node_Str"")) {
    editor.putString(book,chapter);
  }
  if (!version.equals(""String_Node_Str"")) {
    editor.putInt(""String_Node_Str"" + version,fontsize);
  }
  editor.commit();
}","private void storeOsisVersion(){
  final Editor editor=PreferenceManager.getDefaultSharedPreferences(this).edit();
  editor.putString(""String_Node_Str"",osis);
  if (!version.endsWith(""String_Node_Str"") && !version.equals(""String_Node_Str"")) {
    editor.putString(""String_Node_Str"",version);
  }
  editor.putString(""String_Node_Str"",verse);
  editor.putInt(""String_Node_Str"",fontsize);
  if (items != null && items.size() > 0 && search != null && !search.equals(""String_Node_Str"")) {
    editor.putString(""String_Node_Str"",search);
    editor.putInt(""String_Node_Str"",index);
  }
 else {
    search=null;
    editor.remove(""String_Node_Str"");
    editor.remove(""String_Node_Str"");
  }
  if (!book.equals(""String_Node_Str"") && !chapter.equals(""String_Node_Str"")) {
    editor.putString(book,chapter);
  }
  if (!version.equals(""String_Node_Str"")) {
    editor.putInt(""String_Node_Str"" + version,fontsize);
  }
  editor.commit();
}"
49815,"private void setBookChapter(String osis){
  book=osis.split(""String_Node_Str"")[0];
  chapter=osis.split(""String_Node_Str"")[1];
  Log.d(TAG,""String_Node_Str"" + osis);
  setItemText();
  ((TextView)findViewById(R.id.version)).setText(bible.getVersionName(bible.getVersion()));
  ((TextView)findViewById(R.id.book)).setText(bible.get(Bible.TYPE.BOOK,bible.getPosition(Bible.TYPE.OSIS,book)));
  ((TextView)findViewById(R.id.chapter)).setText(chapter);
}","private void setBookChapter(String osis){
  book=osis.split(""String_Node_Str"")[0];
  chapter=osis.split(""String_Node_Str"")[1];
  Log.d(TAG,""String_Node_Str"" + osis);
  setItemText(this.index);
  ((TextView)findViewById(R.id.version)).setText(bible.getVersionName(bible.getVersion()));
  ((TextView)findViewById(R.id.book)).setText(bible.get(Bible.TYPE.BOOK,bible.getPosition(Bible.TYPE.OSIS,book)));
  ((TextView)findViewById(R.id.chapter)).setText(chapter);
}"
49816,"public void setItemText(){
  if (items != null && index >= 0 && index < items.size()) {
    OsisItem item=items.get(index);
    String book=bible.get(Bible.TYPE.BOOK,bible.getPosition(Bible.TYPE.OSIS,item.book)) + ""String_Node_Str"" + item.chapter;
    if (!verse.equals(""String_Node_Str"") || !end.equals(""String_Node_Str"")) {
      book+=""String_Node_Str"" + verse + ""String_Node_Str""+ end;
    }
    ((TextView)findViewById(R.id.items)).setText(book);
  }
}","public void setItemText(int index){
  if (items != null && index >= 0 && index < items.size()) {
    OsisItem item=items.get(index);
    String book=bible.get(Bible.TYPE.BOOK,bible.getPosition(Bible.TYPE.OSIS,item.book)) + item.chapter;
    if (!verse.equals(""String_Node_Str"") || !end.equals(""String_Node_Str"")) {
      book+=""String_Node_Str"" + verse + ""String_Node_Str""+ end;
    }
    ((TextView)findViewById(R.id.items)).setText(book);
  }
}"
49817,"@Override @SuppressLint(""String_Node_Str"") protected void onCreate(Bundle savedInstanceState){
  if (Build.MODEL.equals(""String_Node_Str"")) {
    setTheme(android.R.style.Theme_Light_NoTitleBar);
  }
  super.onCreate(savedInstanceState);
  setContentView(R.layout.chapter);
  findViewById(R.id.book).setOnClickListener(this);
  findViewById(R.id.chapter).setOnClickListener(this);
  findViewById(R.id.search).setOnClickListener(this);
  findViewById(R.id.version).setOnClickListener(this);
  findViewById(R.id.share).setOnClickListener(this);
  findViewById(R.id.items).setOnClickListener(this);
  adapter=new ArrayAdapter<String>(this,R.layout.grid){
    private LayoutInflater inflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      View view=convertView;
      ToggleButton grid=null;
      if (view == null) {
        view=inflater.inflate(R.layout.grid,null);
      }
      grid=(ToggleButton)view.findViewById(R.id.text1);
      grid.setTextOn(getItem(position));
      grid.setTextOff(getItem(position));
      grid.setChecked(getItem(position).equals(selected));
      grid.setVisibility(getItem(position).equals(""String_Node_Str"") ? View.INVISIBLE : View.VISIBLE);
      return view;
    }
  }
;
  gridview=(GridView)findViewById(R.id.gridview);
  gridview.setAdapter(adapter);
  gridview.setVisibility(View.GONE);
  gridview.setOnItemClickListener(this);
  setGestureDetector();
  webview=(WebView)findViewById(R.id.webview);
  webview.getSettings().setJavaScriptEnabled(true);
  webview.getSettings().setSupportZoom(true);
  webview.getSettings().setBuiltInZoomControls(true);
  webview.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
  webview.addJavascriptInterface(new Object(){
    @SuppressWarnings(""String_Node_Str"") public void setVerse(    String string){
synchronized (verseLock) {
        verse=string;
        Log.d(TAG,""String_Node_Str"" + verse);
        verseLock.notifyAll();
      }
    }
    @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void setCopyText(    String text){
      if (!text.equals(""String_Node_Str"")) {
        copytext=bible.getVersionFullname(version).replace(""String_Node_Str"" + getString(R.string.demo) + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        copytext+=bible.get(Bible.TYPE.HUMAN,bible.getPosition(Bible.TYPE.OSIS,book)) + ""String_Node_Str"" + chapter+ ""String_Node_Str""+ text;
        ((android.text.ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE)).setText(copytext);
        Log.d(TAG,""String_Node_Str"" + copytext);
      }
 else {
        copytext=""String_Node_Str"";
      }
      handler.sendEmptyMessage(COPYTEXT);
    }
  }
,""String_Node_Str"");
  setZoomButtonsController(webview);
  bible=Bible.getBible(getBaseContext());
  osis=PreferenceManager.getDefaultSharedPreferences(this).getString(""String_Node_Str"",""String_Node_Str"");
  verse=PreferenceManager.getDefaultSharedPreferences(this).getString(""String_Node_Str"",""String_Node_Str"");
  uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(osis).fragment(version).build();
  Log.d(TAG,""String_Node_Str"");
}","@Override @SuppressLint(""String_Node_Str"") protected void onCreate(Bundle savedInstanceState){
  if (Build.MODEL.equals(""String_Node_Str"")) {
    setTheme(android.R.style.Theme_Light_NoTitleBar);
  }
  super.onCreate(savedInstanceState);
  setContentView(R.layout.chapter);
  findViewById(R.id.book).setOnClickListener(this);
  findViewById(R.id.chapter).setOnClickListener(this);
  findViewById(R.id.search).setOnClickListener(this);
  findViewById(R.id.version).setOnClickListener(this);
  findViewById(R.id.share).setOnClickListener(this);
  findViewById(R.id.items).setOnClickListener(this);
  adapter=new ArrayAdapter<String>(this,R.layout.grid){
    private LayoutInflater inflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      View view=convertView;
      ToggleButton grid=null;
      if (view == null) {
        view=inflater.inflate(R.layout.grid,null);
      }
      grid=(ToggleButton)view.findViewById(R.id.text1);
      grid.setTextOn(getItem(position));
      grid.setTextOff(getItem(position));
      grid.setChecked(getItem(position).equals(selected));
      grid.setVisibility(getItem(position).equals(""String_Node_Str"") ? View.INVISIBLE : View.VISIBLE);
      return view;
    }
  }
;
  gridview=(GridView)findViewById(R.id.gridview);
  gridview.setAdapter(adapter);
  gridview.setVisibility(View.GONE);
  gridview.setOnItemClickListener(this);
  setGestureDetector();
  webview=(WebView)findViewById(R.id.webview);
  webview.getSettings().setJavaScriptEnabled(true);
  webview.getSettings().setSupportZoom(true);
  webview.getSettings().setBuiltInZoomControls(true);
  webview.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
  webview.addJavascriptInterface(new Object(){
    @SuppressWarnings(""String_Node_Str"") public void setVerse(    String string){
synchronized (verseLock) {
        verse=string;
        Log.d(TAG,""String_Node_Str"" + verse);
        verseLock.notifyAll();
      }
    }
    @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void setCopyText(    String text){
      if (!text.equals(""String_Node_Str"")) {
        copytext=bible.getVersionFullname(version).replace(""String_Node_Str"" + getString(R.string.demo) + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
        copytext+=bible.get(Bible.TYPE.HUMAN,bible.getPosition(Bible.TYPE.OSIS,book)) + ""String_Node_Str"" + chapter+ ""String_Node_Str""+ text;
        ((android.text.ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE)).setText(copytext);
        Log.d(TAG,""String_Node_Str"" + copytext);
      }
 else {
        copytext=""String_Node_Str"";
      }
      handler.sendEmptyMessage(COPYTEXT);
    }
  }
,""String_Node_Str"");
  setZoomButtonsController(webview);
  bible=Bible.getBible(getBaseContext());
  osis=PreferenceManager.getDefaultSharedPreferences(this).getString(""String_Node_Str"",""String_Node_Str"");
  verse=PreferenceManager.getDefaultSharedPreferences(this).getString(""String_Node_Str"",""String_Node_Str"");
  uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(osis).fragment(version).build();
  setIntentData();
  Log.d(TAG,""String_Node_Str"");
}"
49818,"@Override public void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"" + items);
  Intent intent=getIntent();
  version=intent.getStringExtra(""String_Node_Str"");
  if (version != null) {
    Log.d(TAG,""String_Node_Str"" + version);
    bible.checkVersions();
    bible.setVersion(version);
  }
 else {
    version=bible.getVersion();
  }
  if (items == null) {
    search=intent.getStringExtra(""String_Node_Str"");
    items=intent.getParcelableArrayListExtra(""String_Node_Str"");
  }
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(this);
  if (items == null && search == null) {
    search=sp.getString(""String_Node_Str"",""String_Node_Str"");
    if (!""String_Node_Str"".equals(search)) {
      Log.d(TAG,""String_Node_Str"");
      Intent passageIntent=new Intent(getApplicationContext(),Passage.class);
      passageIntent.setAction(Intent.ACTION_VIEW);
      passageIntent.setData(Uri.parse(""String_Node_Str"" + search));
      startActivity(passageIntent);
      finish();
    }
  }
  index=sp.getInt(""String_Node_Str"",0);
  fontsize=sp.getInt(""String_Node_Str"" + bible.getVersion(),0);
  if (fontsize == 0) {
    fontsize=sp.getInt(""String_Node_Str"",16);
  }
  if (fontsize > 32) {
    fontsize=32;
  }
  if (!version.equals(bible.getVersion()) && !osis.equals(""String_Node_Str"")) {
    uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(osis).build();
  }
  if (background == null) {
    int color=0x6633B5E5;
    Integer mHighlightColor=(Integer)getField(findViewById(R.id.version),TextView.class,""String_Node_Str"");
    if (mHighlightColor != null) {
      color=mHighlightColor.intValue();
    }
    background=String.format(""String_Node_Str"",(color >> 16) & 0xFF,(color >> 8) & 0xFF,color & 0xFF,(color >>> 24) / 255.0);
    Log.d(TAG,String.format(""String_Node_Str"",color,background));
  }
  showView(R.id.search,true);
  if (items == null || items.size() == 0) {
    showView(R.id.items,false);
    showView(R.id.book,true);
    showView(R.id.chapter,true);
    showUri(uri);
  }
 else {
    showView(R.id.items,true);
    showView(R.id.book,false);
    showView(R.id.chapter,false);
    if (this.index > -1 && this.index < items.size()) {
      showItem(this.index);
    }
 else {
      showItem(0);
    }
  }
}","@Override public void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"" + items);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(this);
  if (items == null && search == null) {
    if (!""String_Node_Str"".equals(sp.getString(""String_Node_Str"",""String_Node_Str""))) {
      index=sp.getInt(""String_Node_Str"",0);
      Log.d(TAG,""String_Node_Str"");
      Intent passageIntent=new Intent(getApplicationContext(),Passage.class);
      passageIntent.setAction(Intent.ACTION_VIEW);
      passageIntent.setData(Uri.parse(""String_Node_Str"" + sp.getString(""String_Node_Str"",""String_Node_Str"")));
      startActivity(passageIntent);
      finish();
    }
  }
  fontsize=sp.getInt(""String_Node_Str"" + bible.getVersion(),0);
  if (fontsize == 0) {
    fontsize=sp.getInt(""String_Node_Str"",16);
  }
  if (fontsize > 32) {
    fontsize=32;
  }
  if (!version.equals(bible.getVersion()) && !osis.equals(""String_Node_Str"")) {
    uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(osis).build();
  }
  if (background == null) {
    int color=0x6633B5E5;
    Integer mHighlightColor=(Integer)getField(findViewById(R.id.version),TextView.class,""String_Node_Str"");
    if (mHighlightColor != null) {
      color=mHighlightColor.intValue();
    }
    background=String.format(""String_Node_Str"",(color >> 16) & 0xFF,(color >> 8) & 0xFF,color & 0xFF,(color >>> 24) / 255.0);
    Log.d(TAG,String.format(""String_Node_Str"",color,background));
  }
  showView(R.id.search,true);
  if (items == null || items.size() == 0) {
    showView(R.id.items,false);
    showView(R.id.book,true);
    showView(R.id.chapter,true);
    showUri(uri);
  }
 else {
    showView(R.id.items,true);
    showView(R.id.book,false);
    showView(R.id.chapter,false);
    if (this.index > -1 && this.index < items.size()) {
      showItem(this.index);
    }
 else {
      showItem(0);
    }
  }
}"
49819,"public void showItem(int index){
  osis=""String_Node_Str"";
  if (items == null) {
    showView(R.id.items,false);
    showView(R.id.book,true);
    showView(R.id.chapter,true);
    openOsis(this.index > index ? osis_prev : osis_next);
  }
 else   if (index >= 0 && index < items.size()) {
    showView(R.id.items,true);
    showView(R.id.book,false);
    showView(R.id.chapter,false);
    this.index=index;
    setItemText();
    OsisItem item=items.get(index);
    Log.d(TAG,String.format(""String_Node_Str"",item.book,item.chapter,item.verse,item.end));
    if (item.chapter.equals(""String_Node_Str"")) {
      item.chapter=PreferenceManager.getDefaultSharedPreferences(this).getString(item.book,""String_Node_Str"");
    }
    openOsis(item.book + ""String_Node_Str"" + item.chapter,item.verse,item.end);
  }
}","public void showItem(int index){
  osis=""String_Node_Str"";
  if (items == null || items.size() < 2) {
    showView(R.id.items,false);
    showView(R.id.book,true);
    showView(R.id.chapter,true);
    if (items == null || items.size() == 0) {
      openOsis(this.index > index ? osis_prev : osis_next);
    }
 else {
      setItemText(0);
      OsisItem item=items.get(0);
      if (item.chapter.equals(""String_Node_Str"")) {
        item.chapter=PreferenceManager.getDefaultSharedPreferences(this).getString(item.book,""String_Node_Str"");
      }
      items.clear();
      Log.d(TAG,""String_Node_Str"" + item.book + ""String_Node_Str""+ item.chapter);
      openOsis(item.book + ""String_Node_Str"" + item.chapter,item.verse,item.end);
    }
    openOsis(this.index > index ? osis_prev : osis_next);
  }
 else   if (index >= 0 && index < items.size()) {
    showView(R.id.items,true);
    showView(R.id.book,false);
    showView(R.id.chapter,false);
    this.index=index;
    setItemText(index);
    OsisItem item=items.get(index);
    Log.d(TAG,String.format(""String_Node_Str"",item.book,item.chapter,item.verse,item.end));
    if (item.chapter.equals(""String_Node_Str"")) {
      item.chapter=PreferenceManager.getDefaultSharedPreferences(this).getString(item.book,""String_Node_Str"");
    }
    openOsis(item.book + ""String_Node_Str"" + item.chapter,item.verse,item.end);
  }
}"
49820,"@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  setIntent(intent);
}","@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  setIntent(intent);
  setIntentData();
}"
49821,"private boolean setDefaultVersion(){
  if (setVersion(""String_Node_Str"") || setVersion(""String_Node_Str"") || setVersion(""String_Node_Str"")) {
  }
  if (setVersion(""String_Node_Str"") || setVersion(""String_Node_Str"") || setVersion(""String_Node_Str"")|| setVersion(""String_Node_Str"")) {
  }
  if (setVersion(""String_Node_Str"") || setVersion(""String_Node_Str"")) {
  }
  String version=PreferenceManager.getDefaultSharedPreferences(mContext).getString(""String_Node_Str"",null);
  if (version != null && getPosition(TYPE.VERSION,version) < 0) {
    version=null;
  }
  if (version == null && getCount(TYPE.VERSION) > 0) {
    version=get(TYPE.VERSION,0);
  }
  if (version != null) {
    return setVersion(version);
  }
  return false;
}","private boolean setDefaultVersion(){
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")) {
  }
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")|| setVersionMetaData(""String_Node_Str"")) {
  }
  if (setVersionMetaData(""String_Node_Str"") || setVersionMetaData(""String_Node_Str"")) {
  }
  String version=PreferenceManager.getDefaultSharedPreferences(mContext).getString(""String_Node_Str"",null);
  if (version != null && getPosition(TYPE.VERSION,version) < 0) {
    version=null;
  }
  if (version == null && getCount(TYPE.VERSION) > 0) {
    version=get(TYPE.VERSION,0);
  }
  if (version != null) {
    return setVersion(version);
  }
  return false;
}"
49822,"private void setDemoVersions(){
  int demoVersion=PreferenceManager.getDefaultSharedPreferences(mContext).getInt(""String_Node_Str"",0);
  int versionCode=0;
  try {
    versionCode=mContext.getPackageManager().getPackageInfo(mContext.getPackageName(),0).versionCode;
  }
 catch (  NameNotFoundException e) {
  }
  boolean newVersion=(demoVersion != versionCode);
  boolean unpack=unpackRaw(newVersion,R.raw.niv84demo,new File(mContext.getFilesDir(),""String_Node_Str""));
  if (unpack) {
    unpack=unpackRaw(newVersion,R.raw.cunpssdemo,new File(mContext.getFilesDir(),""String_Node_Str""));
  }
  if (newVersion && unpack) {
    PreferenceManager.getDefaultSharedPreferences(mContext).edit().putInt(""String_Node_Str"",versionCode).commit();
  }
  if (!versions.contains(""String_Node_Str"")) {
    versions.add(""String_Node_Str"");
  }
  if (!versions.contains(""String_Node_Str"")) {
    versions.add(""String_Node_Str"");
  }
}","private void setDemoVersions(){
  int demoVersion=PreferenceManager.getDefaultSharedPreferences(mContext).getInt(""String_Node_Str"",0);
  int versionCode=0;
  try {
    versionCode=mContext.getPackageManager().getPackageInfo(mContext.getPackageName(),0).versionCode;
  }
 catch (  Exception e) {
  }
  boolean newVersion=(demoVersion != versionCode);
  boolean unpack=unpackRaw(newVersion,R.raw.niv84demo,new File(mContext.getFilesDir(),""String_Node_Str""));
  if (unpack) {
    unpack=unpackRaw(newVersion,R.raw.cunpssdemo,new File(mContext.getFilesDir(),""String_Node_Str""));
  }
  if (newVersion && unpack) {
    PreferenceManager.getDefaultSharedPreferences(mContext).edit().putInt(""String_Node_Str"",versionCode).commit();
  }
  if (!versions.contains(""String_Node_Str"")) {
    versions.add(""String_Node_Str"");
  }
  if (!versions.contains(""String_Node_Str"")) {
    versions.add(""String_Node_Str"");
  }
}"
49823,"private void showUri(Uri uri){
  version=bible.getVersion();
  if (uri == null) {
    Log.d(TAG,""String_Node_Str"");
    uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(null).fragment(version).build();
  }
  Cursor cursor=null;
  try {
    cursor=getContentResolver().query(uri,null,null,null,null);
  }
 catch (  SQLiteException e) {
    showContent(""String_Node_Str"",getString(R.string.queryerror));
    return;
  }
  if (cursor != null) {
    cursor.moveToFirst();
    osis=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_OSIS));
    osis_next=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_NEXT));
    osis_prev=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_PREVIOUS));
    final String human=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_HUMAN));
    final String content=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_CONTENT));
    cursor.close();
    setBookChapter(osis);
    showContent(human + ""String_Node_Str"" + version,content);
  }
 else {
    Log.d(TAG,""String_Node_Str"");
    Uri nulluri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(null).fragment(version).build();
    if (!nulluri.equals(uri)) {
      showUri(nulluri);
    }
 else {
      showContent(""String_Node_Str"",getString(R.string.queryerror));
    }
  }
}","private void showUri(Uri uri){
  version=bible.getVersion();
  if (uri == null) {
    Log.d(TAG,""String_Node_Str"");
    uri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(null).fragment(version).build();
  }
  Cursor cursor=null;
  try {
    cursor=getContentResolver().query(uri,null,null,null,null);
  }
 catch (  SQLiteException e) {
    showContent(""String_Node_Str"",getString(R.string.queryerror));
    return;
  }
catch (  Exception e) {
  }
  if (cursor != null) {
    cursor.moveToFirst();
    osis=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_OSIS));
    osis_next=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_NEXT));
    osis_prev=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_PREVIOUS));
    final String human=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_HUMAN));
    final String content=cursor.getString(cursor.getColumnIndexOrThrow(Provider.COLUMN_CONTENT));
    cursor.close();
    setBookChapter(osis);
    showContent(human + ""String_Node_Str"" + version,content);
  }
 else {
    Log.d(TAG,""String_Node_Str"");
    Uri nulluri=Provider.CONTENT_URI_CHAPTER.buildUpon().appendEncodedPath(null).fragment(version).build();
    if (!nulluri.equals(uri)) {
      showUri(nulluri);
    }
 else {
      showContent(""String_Node_Str"",getString(R.string.queryerror));
    }
  }
}"
49824,"public static ArrayList<OsisItem> parseSearch(String s,Context context){
  ArrayList<OsisItem> items=new ArrayList<OsisItem>();
  if (s == null) {
    return items;
  }
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  Pattern p=Pattern.compile(""String_Node_Str"");
  Matcher m=p.matcher(s);
  while (m.find()) {
    String book=m.group(1);
    String osis=Bible.getBible(context).getOsis(book);
    String start_chapter=m.group(2);
    String start_verse=m.group(3);
    String end_chapter=m.group(4);
    String end_verse=m.group(5);
    if (osis == null) {
      continue;
    }
    if (""String_Node_Str"".equals(start_chapter)) {
      items.add(new OsisItem(osis));
    }
 else     if (""String_Node_Str"".equals(end_chapter) || (!""String_Node_Str"".equals(start_verse) && ""String_Node_Str"".equals(end_verse))) {
      items.add(new OsisItem(osis,start_chapter,start_verse,end_chapter));
    }
 else     if (""String_Node_Str"".equals(start_verse) || (!""String_Node_Str"".equals(start_verse) && !""String_Node_Str"".equals(end_verse))) {
      int start=Integer.parseInt(start_chapter);
      int end=Integer.parseInt(end_chapter);
      items.add(new OsisItem(osis,start_chapter,start_verse));
      for (int i=start + 1; i < end; i++) {
        items.add(new OsisItem(osis,i));
      }
      if (end > start) {
        items.add(new OsisItem(osis,end_chapter,""String_Node_Str"",end_verse));
      }
    }
  }
  return items;
}","public static ArrayList<OsisItem> parseSearch(String s,Context context){
  ArrayList<OsisItem> items=new ArrayList<OsisItem>();
  if (s == null) {
    return items;
  }
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  s=s.replace(""String_Node_Str"",""String_Node_Str"");
  Pattern p=Pattern.compile(""String_Node_Str"");
  Matcher m=p.matcher(s);
  while (m.find()) {
    String book=m.group(1);
    String osis=Bible.getBible(context).getOsis(book);
    String start_chapter=m.group(2);
    String start_verse=m.group(3);
    String end_chapter=m.group(4);
    String end_verse=m.group(5);
    if (osis == null) {
      continue;
    }
    if (""String_Node_Str"".equals(start_chapter)) {
      items.add(new OsisItem(osis));
    }
 else     if (""String_Node_Str"".equals(end_chapter) || (!""String_Node_Str"".equals(start_verse) && ""String_Node_Str"".equals(end_verse))) {
      items.add(new OsisItem(osis,start_chapter,start_verse,end_chapter));
    }
 else     if (""String_Node_Str"".equals(start_verse) || (!""String_Node_Str"".equals(start_verse) && !""String_Node_Str"".equals(end_verse))) {
      int start=Integer.parseInt(start_chapter);
      int end=Integer.parseInt(end_chapter);
      items.add(new OsisItem(osis,start_chapter,start_verse));
      for (int i=start + 1; i < end; i++) {
        items.add(new OsisItem(osis,i));
      }
      if (end > start) {
        items.add(new OsisItem(osis,end_chapter,end_verse.equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"",end_verse));
      }
    }
  }
  return items;
}"
49825,"private void showContent(String content){
  String context=content;
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll('『','‘').replaceAll('』','’');
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String body=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"" + fontsize + ""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=context;
  body+=""String_Node_Str"";
  webview.clearCache(true);
  webview.loadData(body,""String_Node_Str"",""String_Node_Str"");
  webview.getSettings().setSupportZoom(true);
  webview.getSettings().setBuiltInZoomControls(true);
  webview.computeScroll();
}","private void showContent(String content){
  String context=content;
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  context=context.replaceAll(""String_Node_Str"",""String_Node_Str"");
  String body=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"" + fontsize + ""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=""String_Node_Str"";
  body+=context;
  body+=""String_Node_Str"";
  webview.clearCache(true);
  webview.loadData(body,""String_Node_Str"",""String_Node_Str"");
  webview.getSettings().setSupportZoom(true);
  webview.getSettings().setBuiltInZoomControls(true);
  webview.computeScroll();
}"
49826,"@Override public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder){
  if (uri == null) {
    return null;
  }
  Log.d(TAG,""String_Node_Str"" + uri);
  String version=uri.getFragment();
  if (version != null && !setVersion(version)) {
    return null;
  }
  Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
  if (databaseVersion.equals(""String_Node_Str"")) {
    return null;
  }
switch (uriMatcher.match(uri)) {
case URI_SEARCH:
    String query=uri.getLastPathSegment();
  return queryVerse(query);
case URI_VERSE:
String id=uri.getLastPathSegment();
return getVerse(id);
case URI_CHAPTER:
String osis=uri.getLastPathSegment();
return getChapter(osis);
default :
throw new IllegalArgumentException(""String_Node_Str"" + uri);
}
}","@Override public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder){
  if (uri == null) {
    return null;
  }
  Log.d(TAG,""String_Node_Str"" + uri);
  String version=uri.getFragment();
  if (version != null && !setVersion(version)) {
    return null;
  }
  if (database == null) {
    return null;
  }
  Log.d(TAG,""String_Node_Str"" + database.getPath() + ""String_Node_Str"");
  if (databaseVersion.equals(""String_Node_Str"")) {
    return null;
  }
switch (uriMatcher.match(uri)) {
case URI_SEARCH:
    String query=uri.getLastPathSegment();
  return queryVerse(query);
case URI_VERSE:
String id=uri.getLastPathSegment();
return getVerse(id);
case URI_CHAPTER:
String osis=uri.getLastPathSegment();
return getChapter(osis);
default :
throw new IllegalArgumentException(""String_Node_Str"" + uri);
}
}"
49827,"private void init(){
  NodeIterator rdfsIterator=model.listObjectsOfProperty(resource,Constants.RDFS_LABEL);
  while (rdfsIterator.hasNext()) {
    RDFNode rdfNode=(RDFNode)rdfsIterator.next();
    String language=rdfNode.asLiteral().getLanguage();
    String label=rdfNode.asLiteral().getLexicalForm();
    this.labels.put(language,label);
  }
  NodeIterator skosAltIterator=model.listObjectsOfProperty(resource,Constants.SKOS_ALT_LABEL);
  while (skosAltIterator.hasNext()) {
    RDFNode rdfNode=(RDFNode)skosAltIterator.next();
    String language=rdfNode.asLiteral().getLanguage();
    String label=rdfNode.asLiteral().getLexicalForm();
    this.altLabels.get(language).add(label);
  }
  NodeIterator sameAsIterator=model.listObjectsOfProperty(resource,Constants.OWL_SAME_AS);
  while (sameAsIterator.hasNext()) {
    RDFNode rdfNode=(RDFNode)sameAsIterator.next();
    this.owlSameAs.add(rdfNode.asResource());
  }
}","private void init(){
  NodeIterator rdfsIterator=model.listObjectsOfProperty(resource,Constants.RDFS_LABEL);
  while (rdfsIterator.hasNext()) {
    RDFNode rdfNode=(RDFNode)rdfsIterator.next();
    String language=rdfNode.asLiteral().getLanguage();
    String label=rdfNode.asLiteral().getLexicalForm();
    this.labels.put(language,label);
  }
  NodeIterator skosAltIterator=model.listObjectsOfProperty(resource,Constants.SKOS_ALT_LABEL);
  while (skosAltIterator.hasNext()) {
    RDFNode rdfNode=(RDFNode)skosAltIterator.next();
    String language=rdfNode.asLiteral().getLanguage();
    String label=rdfNode.asLiteral().getLexicalForm();
    this.altLabels.get(language).add(label);
  }
  NodeIterator sameAsIterator=model.listObjectsOfProperty(resource,Constants.OWL_SAME_AS);
  while (sameAsIterator.hasNext()) {
    RDFNode rdfNode=(RDFNode)sameAsIterator.next();
    this.owlSameAs.add(rdfNode.asResource());
    NodeIterator listObjectsOfProperty=model.listObjectsOfProperty(rdfNode.asResource(),Constants.SKOS_ALT_LABEL);
    while (listObjectsOfProperty.hasNext()) {
      RDFNode node=listObjectsOfProperty.next();
      this.altLabels.get(node.asLiteral().getLanguage()).add(node.asLiteral().getLexicalForm());
    }
  }
}"
49828,"/** 
 * Creates a new DefactoModel. The model uses the filename of the provided file as name and is initialized as <code>isCorrect</code>. The model  supports the provided languages (e.g. 'en', 'fr' and 'de'). If the file is not found a  FileNotFoundExcpetion is thrown.
 * @param pathToModel - the absolute path to the file
 * @param isCorrect - true if the fact is true, false otherwise
 * @param languages - a list of iso code languages
 * @return a new DefactoModel(true, de/fr/en)
 * @throws FileNotFoundException
 */
public static final DefactoModel readModel(String pathToModel,Boolean isCorrect,List<String> languages) throws FileNotFoundException {
  Model model=ModelFactory.createDefaultModel();
  model.read(new FileReader(pathToModel),""String_Node_Str"",""String_Node_Str"");
  String absolutePath=new File(pathToModel).getAbsolutePath();
  absolutePath=absolutePath.replace(""String_Node_Str"",""String_Node_Str"");
  return new DefactoModel(model,absolutePath,isCorrect,languages);
}","/** 
 * Creates a new DefactoModel. The model uses the filename of the provided file as name and is initialized as <code>isCorrect</code>. The model  supports the provided languages (e.g. 'en', 'fr' and 'de'). If the file is not found a  FileNotFoundExcpetion is thrown.
 * @param pathToModel - the absolute path to the file
 * @param isCorrect - true if the fact is true, false otherwise
 * @param languages - a list of iso code languages
 * @return a new DefactoModel(true, de/fr/en)
 * @throws FileNotFoundException
 */
public static final DefactoModel readModel(String pathToModel,Boolean isCorrect,List<String> languages) throws FileNotFoundException {
  Model model=ModelFactory.createDefaultModel();
  model.read(new FileReader(pathToModel),""String_Node_Str"",""String_Node_Str"");
  String absolutePath=new File(pathToModel).getAbsolutePath();
  absolutePath=absolutePath.replace(""String_Node_Str"",""String_Node_Str"");
  DefactoModel defactoModel=new DefactoModel(model,absolutePath,isCorrect,languages);
  return defactoModel;
}"
49829,"/** 
 * Returns all patterns from the index and their factFeatures for reverb and the wordnet distance and the overall boa-boaScore.
 * @param propertyUri
 * @param language 
 * @return a list of patterns
 */
public List<Pattern> querySolrIndex(String propertyUri,int numberOfBoaPatterns,double scoreThreshold,String language){
  this.logger.debug(""String_Node_Str"" + propertyUri + ""String_Node_Str""+ language+ ""String_Node_Str"");
  Map<String,Pattern> patterns=new HashMap<String,Pattern>();
  try {
    if (propertyUri.equals(""String_Node_Str""))     propertyUri=""String_Node_Str"";
    SolrQuery query=new SolrQuery(""String_Node_Str"" + propertyUri + ""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addSortField(""String_Node_Str"",ORDER.desc);
    if (numberOfBoaPatterns > 0)     query.setRows(numberOfBoaPatterns);
    String key=propertyUri + numberOfBoaPatterns + language;
    if (!this.queryCache.containsKey(key)) {
      if (language.equals(""String_Node_Str""))       this.queryCache.put(key,enIndex.query(query));
 else       if (language.equals(""String_Node_Str""))       this.queryCache.put(key,deIndex.query(query));
 else       if (language.equals(""String_Node_Str""))       this.queryCache.put(key,frIndex.query(query));
    }
    SolrDocumentList docList=this.queryCache.get(key).getResults();
    for (    SolrDocument d : docList) {
      Pattern pattern=new Pattern();
      pattern.naturalLanguageRepresentation=(String)d.get(""String_Node_Str"");
      pattern.generalized=(String)d.get(""String_Node_Str"");
      pattern.naturalLanguageRepresentationWithoutVariables=(String)d.get(""String_Node_Str"");
      pattern.posTags=(String)d.get(""String_Node_Str"");
      pattern.boaScore=(Double)d.get(""String_Node_Str"");
      pattern.language=language;
      this.logger.debug(""String_Node_Str"" + pattern.naturalLanguageRepresentation);
      if (!patterns.containsKey(pattern.normalize()) && patterns.size() < Defacto.DEFACTO_CONFIG.getIntegerSetting(""String_Node_Str"",""String_Node_Str""))       patterns.put(pattern.normalize(),pattern);
    }
  }
 catch (  SolrServerException e) {
    System.out.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
  List<Pattern> patternList=new ArrayList<Pattern>(patterns.values());
  Collections.sort(patternList,new Comparator<Pattern>(){
    @Override public int compare(    Pattern pattern1,    Pattern pattern2){
      double difference=pattern1.boaScore - pattern2.boaScore;
      if (difference > 0)       return -1;
      if (difference < 0)       return 1;
      return pattern1.naturalLanguageRepresentation.compareTo(pattern2.naturalLanguageRepresentation);
    }
  }
);
  return patternList;
}","/** 
 * Returns all patterns from the index and their factFeatures for reverb and the wordnet distance and the overall boa-boaScore.
 * @param propertyUri
 * @param language 
 * @return a list of patterns
 */
public List<Pattern> querySolrIndex(String propertyUri,int numberOfBoaPatterns,double scoreThreshold,String language){
  this.logger.debug(""String_Node_Str"" + propertyUri + ""String_Node_Str""+ language+ ""String_Node_Str"");
  Map<String,Pattern> patterns=new HashMap<String,Pattern>();
  try {
    if (propertyUri.equals(""String_Node_Str""))     propertyUri=""String_Node_Str"";
    SolrQuery query=new SolrQuery(""String_Node_Str"" + propertyUri + ""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addSortField(""String_Node_Str"",ORDER.desc);
    if (numberOfBoaPatterns > 0)     query.setRows(numberOfBoaPatterns);
    String key=propertyUri + numberOfBoaPatterns + language;
    System.out.println(query);
    if (!this.queryCache.containsKey(key)) {
      if (language.equals(""String_Node_Str""))       this.queryCache.put(key,enIndex.query(query));
 else       if (language.equals(""String_Node_Str""))       this.queryCache.put(key,deIndex.query(query));
 else       if (language.equals(""String_Node_Str""))       this.queryCache.put(key,frIndex.query(query));
    }
    SolrDocumentList docList=this.queryCache.get(key).getResults();
    for (    SolrDocument d : docList) {
      Pattern pattern=new Pattern();
      pattern.naturalLanguageRepresentation=(String)d.get(""String_Node_Str"");
      pattern.generalized=(String)d.get(""String_Node_Str"");
      pattern.naturalLanguageRepresentationWithoutVariables=(String)d.get(""String_Node_Str"");
      pattern.posTags=(String)d.get(""String_Node_Str"");
      pattern.boaScore=(Double)d.get(""String_Node_Str"");
      pattern.language=language;
      this.logger.debug(""String_Node_Str"" + pattern.naturalLanguageRepresentation);
      if (!patterns.containsKey(pattern.normalize()) && patterns.size() < Defacto.DEFACTO_CONFIG.getIntegerSetting(""String_Node_Str"",""String_Node_Str""))       patterns.put(pattern.normalize(),pattern);
    }
  }
 catch (  SolrServerException e) {
    System.out.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
  List<Pattern> patternList=new ArrayList<Pattern>(patterns.values());
  Collections.sort(patternList,new Comparator<Pattern>(){
    @Override public int compare(    Pattern pattern1,    Pattern pattern2){
      double difference=pattern1.boaScore - pattern2.boaScore;
      if (difference > 0)       return -1;
      if (difference < 0)       return 1;
      return pattern1.naturalLanguageRepresentation.compareTo(pattern2.naturalLanguageRepresentation);
    }
  }
);
  return patternList;
}"
49830,"public static void main(String[] args){
  Defacto.init();
  BoaPatternSearcher bps=new BoaPatternSearcher();
  for (  Pattern p : bps.getNaturalLanguageRepresentations(""String_Node_Str"",""String_Node_Str"")) {
    System.out.println(p.naturalLanguageRepresentation);
  }
  System.out.println(""String_Node_Str"");
  for (  Pattern p : bps.getNaturalLanguageRepresentations(""String_Node_Str"",""String_Node_Str"")) {
    System.out.println(p.naturalLanguageRepresentation);
  }
  System.out.println(""String_Node_Str"");
  for (  Pattern p : bps.getNaturalLanguageRepresentations(""String_Node_Str"",""String_Node_Str"")) {
    System.out.println(p.naturalLanguageRepresentation);
  }
}","public static void main(String[] args){
  Defacto.init();
  queryPatterns(""String_Node_Str"");
}"
49831,"@POST @Produces(""String_Node_Str"") public Response getJson(@QueryParam(""String_Node_Str"") String subject,@QueryParam(""String_Node_Str"") List<String> slabels,@QueryParam(""String_Node_Str"") List<String> sAltLabels,@QueryParam(""String_Node_Str"") String object,@QueryParam(""String_Node_Str"") List<String> olabels,@QueryParam(""String_Node_Str"") List<String> oAltLabels,@QueryParam(""String_Node_Str"") String property,@QueryParam(""String_Node_Str"") String from,@QueryParam(""String_Node_Str"") String to,@QueryParam(""String_Node_Str"") List<String> languages){
  DefactoServer.log.log(Level.INFO,""String_Node_Str"" + subject + ""String_Node_Str""+ property+ ""String_Node_Str""+ object+ ""String_Node_Str"");
  if (olabels != null && slabels != null)   DefactoServer.log.log(Level.INFO,""String_Node_Str"" + slabels + ""String_Node_Str""+ property+ ""String_Node_Str""+ olabels+ ""String_Node_Str"");
  try {
    org.apache.log4j.PropertyConfigurator.configure(""String_Node_Str"");
    Defacto.init();
    Model model=ModelFactory.createDefaultModel();
    Resource subj=model.createResource(subject);
    for (    String labelToLang : slabels) {
      String label=labelToLang.substring(0,labelToLang.length() - 3);
      String lang=labelToLang.substring(labelToLang.length() - 2);
      subj.addProperty(RDFS.label,label,lang);
    }
    for (    String altLabel : sAltLabels) {
      String label=altLabel.substring(0,altLabel.length() - 3);
      String lang=altLabel.substring(altLabel.length() - 2);
      subj.addProperty(Constants.SKOS_ALT_LABEL,label,lang);
    }
    Resource obj=model.createResource(object);
    for (    String labelToLang : olabels) {
      String label=labelToLang.substring(0,labelToLang.length() - 3);
      String lang=labelToLang.substring(labelToLang.length() - 2);
      obj.addProperty(RDFS.label,label,lang);
    }
    for (    String altLabel : oAltLabels) {
      String label=altLabel.substring(0,altLabel.length() - 3);
      String lang=altLabel.substring(altLabel.length() - 2);
      obj.addProperty(Constants.SKOS_ALT_LABEL,label,lang);
    }
    Resource bnode=model.createResource(""String_Node_Str"");
    subj.addProperty(ResourceFactory.createProperty(""String_Node_Str""),bnode);
    bnode.addProperty(model.createProperty(property),obj);
    bnode.addProperty(Constants.DEFACTO_FROM,from == null ? ""String_Node_Str"" : from);
    bnode.addProperty(Constants.DEFACTO_TO,to == null ? ""String_Node_Str"" : to);
    Evidence ev=Defacto.checkFact(new DefactoModel(model,subject + ""String_Node_Str"" + property+ ""String_Node_Str""+ object,true,languages),Defacto.TIME_DISTRIBUTION_ONLY.YES);
    JSONObject result=new JSONObject();
    result.put(""String_Node_Str"",subject);
    result.put(""String_Node_Str"",StringUtils.join(slabels,""String_Node_Str""));
    result.put(""String_Node_Str"",subject);
    result.put(""String_Node_Str"",subject);
    result.put(""String_Node_Str"",StringUtils.join(olabels,""String_Node_Str""));
    result.put(""String_Node_Str"",from == null ? ""String_Node_Str"" : from);
    result.put(""String_Node_Str"",to == null ? ""String_Node_Str"" : to);
    buildYearOccurrences(result,ev);
    return Response.ok(result.toString()).header(""String_Node_Str"",""String_Node_Str"").build();
  }
 catch (  Exception e) {
    DefactoServer.log.log(Level.WARNING,""String_Node_Str"" + subject + ""String_Node_Str""+ property+ ""String_Node_Str""+ object+ ""String_Node_Str"");
    DefactoServer.log.log(Level.WARNING,e.getMessage());
    e.printStackTrace();
  }
  return Response.serverError().build();
}","@POST @Produces(""String_Node_Str"") public Response getJson(@QueryParam(""String_Node_Str"") String subject,@QueryParam(""String_Node_Str"") List<String> slabels,@QueryParam(""String_Node_Str"") List<String> sAltLabels,@QueryParam(""String_Node_Str"") String object,@QueryParam(""String_Node_Str"") List<String> olabels,@QueryParam(""String_Node_Str"") List<String> oAltLabels,@QueryParam(""String_Node_Str"") String property,@QueryParam(""String_Node_Str"") String from,@QueryParam(""String_Node_Str"") String to,@QueryParam(""String_Node_Str"") List<String> languages){
  DefactoServer.log.log(Level.INFO,""String_Node_Str"" + subject + ""String_Node_Str""+ property+ ""String_Node_Str""+ object+ ""String_Node_Str"");
  if (olabels != null && slabels != null)   DefactoServer.log.log(Level.INFO,""String_Node_Str"" + slabels + ""String_Node_Str""+ property+ ""String_Node_Str""+ olabels+ ""String_Node_Str"");
  try {
    org.apache.log4j.PropertyConfigurator.configure(""String_Node_Str"");
    Defacto.init();
    Model model=ModelFactory.createDefaultModel();
    Resource subj=model.createResource(subject);
    for (    String labelToLang : slabels) {
      String label=labelToLang.substring(0,labelToLang.length() - 3);
      String lang=labelToLang.substring(labelToLang.length() - 2);
      subj.addProperty(RDFS.label,label,lang);
    }
    for (    String altLabel : sAltLabels) {
      String label=altLabel.substring(0,altLabel.length() - 3);
      String lang=altLabel.substring(altLabel.length() - 2);
      subj.addProperty(Constants.SKOS_ALT_LABEL,label,lang);
    }
    Resource obj=model.createResource(object);
    for (    String labelToLang : olabels) {
      String label=labelToLang.substring(0,labelToLang.length() - 3);
      String lang=labelToLang.substring(labelToLang.length() - 2);
      obj.addProperty(RDFS.label,label,lang);
    }
    for (    String altLabel : oAltLabels) {
      String label=altLabel.substring(0,altLabel.length() - 3);
      String lang=altLabel.substring(altLabel.length() - 2);
      obj.addProperty(Constants.SKOS_ALT_LABEL,label,lang);
    }
    Resource bnode=model.createResource(""String_Node_Str"");
    subj.addProperty(ResourceFactory.createProperty(""String_Node_Str""),bnode);
    bnode.addProperty(model.createProperty(property),obj);
    bnode.addProperty(Constants.DEFACTO_FROM,from == null ? ""String_Node_Str"" : from);
    bnode.addProperty(Constants.DEFACTO_TO,to == null ? ""String_Node_Str"" : to);
    Evidence ev=Defacto.checkFact(new DefactoModel(model,subject + ""String_Node_Str"" + property+ ""String_Node_Str""+ object,true,languages),Defacto.TIME_DISTRIBUTION_ONLY.YES);
    JSONObject result=new JSONObject();
    result.put(""String_Node_Str"",subject);
    result.put(""String_Node_Str"",StringUtils.join(slabels,""String_Node_Str""));
    result.put(""String_Node_Str"",property);
    result.put(""String_Node_Str"",object);
    result.put(""String_Node_Str"",StringUtils.join(olabels,""String_Node_Str""));
    result.put(""String_Node_Str"",from == null ? ""String_Node_Str"" : from);
    result.put(""String_Node_Str"",to == null ? ""String_Node_Str"" : to);
    buildYearOccurrences(result,ev);
    return Response.ok(result.toString()).header(""String_Node_Str"",""String_Node_Str"").build();
  }
 catch (  Exception e) {
    DefactoServer.log.log(Level.WARNING,""String_Node_Str"" + subject + ""String_Node_Str""+ property+ ""String_Node_Str""+ object+ ""String_Node_Str"");
    DefactoServer.log.log(Level.WARNING,e.getMessage());
    e.printStackTrace();
  }
  return Response.serverError().build();
}"
49832,"/** 
 * @param args
 * @throws FileNotFoundException 
 */
public static void main(String[] args) throws FileNotFoundException {
  Defacto.init();
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
}","/** 
 * @param args
 * @throws FileNotFoundException 
 */
public static void main(String[] args) throws FileNotFoundException {
  Defacto.init();
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
  generateArffFiles(""String_Node_Str"");
}"
49833,"private static void generateArffFiles(String set) throws FileNotFoundException {
  List<String> languages=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String trainDirectory=Defacto.DEFACTO_CONFIG.getStringSetting(""String_Node_Str"",""String_Node_Str"") + Defacto.DEFACTO_CONFIG.getStringSetting(""String_Node_Str"",""String_Node_Str"");
  List<DefactoModel> models=new ArrayList<>();
  models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",true,languages));
  if (!set.equals(""String_Node_Str""))   models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"" + set,false,languages));
 else {
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
  }
  Collections.shuffle(models);
  LOGGER.info(""String_Node_Str"" + models.size() + ""String_Node_Str""+ set);
  for (int i=0; i < models.size(); i++) {
    LOGGER.info(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ models.get(i));
    System.out.println(String.format(""String_Node_Str"",set,i + 1,models.size()));
    Evidence evidence=Defacto.checkFact(models.get(i),TIME_DISTRIBUTION_ONLY.NO);
    Defacto.writeEvidenceTrainingFiles(""String_Node_Str"" + set + ""String_Node_Str"");
  }
}","private static void generateArffFiles(String set) throws FileNotFoundException {
  List<String> languages=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String trainDirectory=Defacto.DEFACTO_CONFIG.getStringSetting(""String_Node_Str"",""String_Node_Str"") + Defacto.DEFACTO_CONFIG.getStringSetting(""String_Node_Str"",""String_Node_Str"");
  List<DefactoModel> models=new ArrayList<>();
  models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",true,languages));
  if (!set.equals(""String_Node_Str""))   models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"" + set,false,languages));
 else {
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
    models.addAll(DefactoModelReader.readModels(trainDirectory + ""String_Node_Str"",false,languages));
  }
  Collections.shuffle(models);
  LOGGER.info(""String_Node_Str"" + models.size() + ""String_Node_Str""+ set);
  for (int i=0; i < models.size(); i++) {
    LOGGER.info(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ models.get(i));
    System.out.println(String.format(""String_Node_Str"",set,i + 1,models.size()));
    Evidence evidence=Defacto.checkFact(models.get(i),TIME_DISTRIBUTION_ONLY.NO);
    Defacto.writeEvidenceTrainingFiles(""String_Node_Str"" + set + ""String_Node_Str"");
  }
  AbstractEvidenceFeature.createInstances();
}"
49834,"/** 
 * Returns all patterns from the index and their factFeatures for reverb and the wordnet distance and the overall boa-boaScore.
 * @param propertyUri
 * @param language 
 * @return a list of patterns
 */
public List<Pattern> querySolrIndex(String propertyUri,int numberOfBoaPatterns,double scoreThreshold,String language){
  this.logger.debug(""String_Node_Str"" + propertyUri + ""String_Node_Str""+ language+ ""String_Node_Str"");
  Map<String,Pattern> patterns=new HashMap<String,Pattern>();
  try {
    if (propertyUri.equals(""String_Node_Str""))     propertyUri=""String_Node_Str"";
    SolrQuery query=new SolrQuery(""String_Node_Str"" + propertyUri + ""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addSortField(""String_Node_Str"",ORDER.desc);
    if (numberOfBoaPatterns > 0)     query.setRows(numberOfBoaPatterns);
    String key=propertyUri + numberOfBoaPatterns + language;
    System.out.println(query);
    if (!this.queryCache.containsKey(key)) {
      if (language.equals(""String_Node_Str""))       this.queryCache.put(key,enIndex.query(query));
 else       if (language.equals(""String_Node_Str""))       this.queryCache.put(key,deIndex.query(query));
 else       if (language.equals(""String_Node_Str""))       this.queryCache.put(key,frIndex.query(query));
    }
    SolrDocumentList docList=this.queryCache.get(key).getResults();
    for (    SolrDocument d : docList) {
      Pattern pattern=new Pattern();
      pattern.naturalLanguageRepresentation=(String)d.get(""String_Node_Str"");
      pattern.generalized=(String)d.get(""String_Node_Str"");
      pattern.naturalLanguageRepresentationWithoutVariables=(String)d.get(""String_Node_Str"");
      pattern.posTags=(String)d.get(""String_Node_Str"");
      pattern.boaScore=(Double)d.get(""String_Node_Str"");
      pattern.language=language;
      this.logger.debug(""String_Node_Str"" + pattern.naturalLanguageRepresentation);
      if (!patterns.containsKey(pattern.normalize()) && patterns.size() < Defacto.DEFACTO_CONFIG.getIntegerSetting(""String_Node_Str"",""String_Node_Str""))       patterns.put(pattern.normalize(),pattern);
    }
  }
 catch (  SolrServerException e) {
    System.out.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
  List<Pattern> patternList=new ArrayList<Pattern>(patterns.values());
  Collections.sort(patternList,new Comparator<Pattern>(){
    @Override public int compare(    Pattern pattern1,    Pattern pattern2){
      double difference=pattern1.boaScore - pattern2.boaScore;
      if (difference > 0)       return -1;
      if (difference < 0)       return 1;
      return pattern1.naturalLanguageRepresentation.compareTo(pattern2.naturalLanguageRepresentation);
    }
  }
);
  return patternList;
}","/** 
 * Returns all patterns from the index and their factFeatures for reverb and the wordnet distance and the overall boa-boaScore.
 * @param propertyUri
 * @param language 
 * @return a list of patterns
 */
public List<Pattern> querySolrIndex(String propertyUri,int numberOfBoaPatterns,double scoreThreshold,String language){
  this.logger.debug(""String_Node_Str"" + propertyUri + ""String_Node_Str""+ language+ ""String_Node_Str"");
  Map<String,Pattern> patterns=new HashMap<String,Pattern>();
  try {
    if (propertyUri.equals(""String_Node_Str""))     propertyUri=""String_Node_Str"";
    SolrQuery query=new SolrQuery(""String_Node_Str"" + propertyUri + ""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addField(""String_Node_Str"");
    query.addSortField(""String_Node_Str"",ORDER.desc);
    if (numberOfBoaPatterns > 0)     query.setRows(numberOfBoaPatterns);
    String key=propertyUri + numberOfBoaPatterns + language;
    if (!this.queryCache.containsKey(key)) {
      if (language.equals(""String_Node_Str""))       this.queryCache.put(key,enIndex.query(query));
 else       if (language.equals(""String_Node_Str""))       this.queryCache.put(key,deIndex.query(query));
 else       if (language.equals(""String_Node_Str""))       this.queryCache.put(key,frIndex.query(query));
    }
    SolrDocumentList docList=this.queryCache.get(key).getResults();
    for (    SolrDocument d : docList) {
      Pattern pattern=new Pattern();
      pattern.naturalLanguageRepresentation=(String)d.get(""String_Node_Str"");
      pattern.generalized=(String)d.get(""String_Node_Str"");
      pattern.naturalLanguageRepresentationWithoutVariables=(String)d.get(""String_Node_Str"");
      pattern.posTags=(String)d.get(""String_Node_Str"");
      pattern.boaScore=(Double)d.get(""String_Node_Str"");
      pattern.language=language;
      this.logger.debug(""String_Node_Str"" + pattern.naturalLanguageRepresentation);
      if (!patterns.containsKey(pattern.normalize()) && patterns.size() < Defacto.DEFACTO_CONFIG.getIntegerSetting(""String_Node_Str"",""String_Node_Str""))       patterns.put(pattern.normalize(),pattern);
    }
  }
 catch (  SolrServerException e) {
    System.out.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
  List<Pattern> patternList=new ArrayList<Pattern>(patterns.values());
  Collections.sort(patternList,new Comparator<Pattern>(){
    @Override public int compare(    Pattern pattern1,    Pattern pattern2){
      double difference=pattern1.boaScore - pattern2.boaScore;
      if (difference > 0)       return -1;
      if (difference < 0)       return 1;
      return pattern1.naturalLanguageRepresentation.compareTo(pattern2.naturalLanguageRepresentation);
    }
  }
);
  return patternList;
}"
49835,"public static JSONObject queryDefacto(String subjectUri,String propertyUri,String objectUri,List<String> languages,String from,String to,Map<String,String> subjectLabels,Map<String,String> objectLabels,Map<String,Set<String>> altSubjectLabels,Map<String,Set<String>> altObjectLabels) throws UniformInterfaceException, ClientHandlerException, JSONException {
  MultivaluedMap<String,String> queryParams=new MultivaluedMapImpl();
  queryParams.add(""String_Node_Str"",subjectUri);
  for (  String lang : languages) {
    queryParams.add(""String_Node_Str"",subjectLabels.get(lang) + ""String_Node_Str"" + lang);
    for (    String altLabel : altSubjectLabels.get(lang)) {
      queryParams.add(""String_Node_Str"",altLabel + ""String_Node_Str"" + lang);
    }
  }
  queryParams.add(""String_Node_Str"",propertyUri);
  queryParams.add(""String_Node_Str"",objectUri);
  for (  String lang : languages) {
    queryParams.add(""String_Node_Str"",objectLabels.get(lang) + ""String_Node_Str"" + lang);
    for (    String altLabel : altObjectLabels.get(lang)) {
      queryParams.add(""String_Node_Str"",altLabel + ""String_Node_Str"" + lang);
    }
  }
  for (  String lang : languages)   queryParams.add(""String_Node_Str"",lang);
  queryParams.add(""String_Node_Str"",from);
  queryParams.add(""String_Node_Str"",to);
  return new JSONObject(webResource.queryParams(queryParams).post(String.class));
}","public static JSONObject queryDefacto(String subjectUri,String propertyUri,String objectUri,List<String> languages,String from,String to,String contextSize,Map<String,String> subjectLabels,Map<String,String> objectLabels,Map<String,Set<String>> altSubjectLabels,Map<String,Set<String>> altObjectLabels) throws UniformInterfaceException, ClientHandlerException, JSONException {
  MultivaluedMap<String,String> queryParams=new MultivaluedMapImpl();
  queryParams.add(""String_Node_Str"",subjectUri);
  for (  String lang : languages) {
    queryParams.add(""String_Node_Str"",subjectLabels.get(lang) + ""String_Node_Str"" + lang);
    for (    String altLabel : altSubjectLabels.get(lang)) {
      queryParams.add(""String_Node_Str"",altLabel + ""String_Node_Str"" + lang);
    }
  }
  queryParams.add(""String_Node_Str"",propertyUri);
  queryParams.add(""String_Node_Str"",objectUri);
  for (  String lang : languages) {
    queryParams.add(""String_Node_Str"",objectLabels.get(lang) + ""String_Node_Str"" + lang);
    for (    String altLabel : altObjectLabels.get(lang)) {
      queryParams.add(""String_Node_Str"",altLabel + ""String_Node_Str"" + lang);
    }
  }
  for (  String lang : languages)   queryParams.add(""String_Node_Str"",lang);
  queryParams.add(""String_Node_Str"",contextSize);
  queryParams.add(""String_Node_Str"",from);
  queryParams.add(""String_Node_Str"",to);
  return new JSONObject(webResource.queryParams(queryParams).post(String.class));
}"
49836,"public static void main(String[] args) throws IOException, JSONException {
  Map<String,String> subjectLabels=new HashMap<>();
  subjectLabels.put(""String_Node_Str"",""String_Node_Str"");
  subjectLabels.put(""String_Node_Str"",""String_Node_Str"");
  subjectLabels.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,String> objectLabels=new HashMap<>();
  objectLabels.put(""String_Node_Str"",""String_Node_Str"");
  objectLabels.put(""String_Node_Str"",""String_Node_Str"");
  objectLabels.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Set<String>> altSubjectLabels=new HashMap<>();
  Set<String> enSAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  Set<String> deSAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  Set<String> frSAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  altSubjectLabels.put(""String_Node_Str"",enSAltLabels);
  altSubjectLabels.put(""String_Node_Str"",deSAltLabels);
  altSubjectLabels.put(""String_Node_Str"",frSAltLabels);
  Map<String,Set<String>> altObjectLabels=new HashMap<>();
  Set<String> enOAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  Set<String> deOAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  Set<String> frOAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  altObjectLabels.put(""String_Node_Str"",enOAltLabels);
  altObjectLabels.put(""String_Node_Str"",deOAltLabels);
  altObjectLabels.put(""String_Node_Str"",frOAltLabels);
  JSONObject result=queryDefacto(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",subjectLabels,objectLabels,altSubjectLabels,altObjectLabels);
  writeData(result);
}","public static void main(String[] args) throws IOException, JSONException {
  Map<String,String> subjectLabels=new HashMap<>();
  subjectLabels.put(""String_Node_Str"",""String_Node_Str"");
  subjectLabels.put(""String_Node_Str"",""String_Node_Str"");
  subjectLabels.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,String> objectLabels=new HashMap<>();
  objectLabels.put(""String_Node_Str"",""String_Node_Str"");
  objectLabels.put(""String_Node_Str"",""String_Node_Str"");
  objectLabels.put(""String_Node_Str"",""String_Node_Str"");
  Map<String,Set<String>> altSubjectLabels=new HashMap<>();
  Set<String> enSAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  Set<String> deSAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  Set<String> frSAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  altSubjectLabels.put(""String_Node_Str"",enSAltLabels);
  altSubjectLabels.put(""String_Node_Str"",deSAltLabels);
  altSubjectLabels.put(""String_Node_Str"",frSAltLabels);
  Map<String,Set<String>> altObjectLabels=new HashMap<>();
  Set<String> enOAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  Set<String> deOAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  Set<String> frOAltLabels=new HashSet<>(Arrays.asList(""String_Node_Str""));
  altObjectLabels.put(""String_Node_Str"",enOAltLabels);
  altObjectLabels.put(""String_Node_Str"",deOAltLabels);
  altObjectLabels.put(""String_Node_Str"",frOAltLabels);
  JSONObject result=queryDefacto(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",subjectLabels,objectLabels,altSubjectLabels,altObjectLabels);
  writeData(result);
}"
49837,"@POST @Produces(""String_Node_Str"") public Response getJson(@QueryParam(""String_Node_Str"") String subject,@QueryParam(""String_Node_Str"") List<String> slabels,@QueryParam(""String_Node_Str"") List<String> sAltLabels,@QueryParam(""String_Node_Str"") String object,@QueryParam(""String_Node_Str"") List<String> olabels,@QueryParam(""String_Node_Str"") List<String> oAltLabels,@QueryParam(""String_Node_Str"") String property,@QueryParam(""String_Node_Str"") String from,@QueryParam(""String_Node_Str"") String to,@QueryParam(""String_Node_Str"") List<String> languages){
  DefactoServer.log.log(Level.INFO,""String_Node_Str"" + subject + ""String_Node_Str""+ property+ ""String_Node_Str""+ object+ ""String_Node_Str"");
  if (olabels != null && slabels != null)   DefactoServer.log.log(Level.INFO,""String_Node_Str"" + slabels + ""String_Node_Str""+ property+ ""String_Node_Str""+ olabels+ ""String_Node_Str"");
  try {
    org.apache.log4j.PropertyConfigurator.configure(""String_Node_Str"");
    Defacto.init();
    Model model=ModelFactory.createDefaultModel();
    Resource subj=model.createResource(subject);
    for (    String labelToLang : slabels) {
      String label=labelToLang.substring(0,labelToLang.length() - 3);
      String lang=labelToLang.substring(labelToLang.length() - 2);
      subj.addProperty(RDFS.label,label,lang);
    }
    for (    String altLabel : sAltLabels) {
      String label=altLabel.substring(0,altLabel.length() - 3);
      String lang=altLabel.substring(altLabel.length() - 2);
      subj.addProperty(Constants.SKOS_ALT_LABEL,label,lang);
    }
    Resource obj=model.createResource(object);
    for (    String labelToLang : olabels) {
      String label=labelToLang.substring(0,labelToLang.length() - 3);
      String lang=labelToLang.substring(labelToLang.length() - 2);
      obj.addProperty(RDFS.label,label,lang);
    }
    for (    String altLabel : oAltLabels) {
      String label=altLabel.substring(0,altLabel.length() - 3);
      String lang=altLabel.substring(altLabel.length() - 2);
      obj.addProperty(Constants.SKOS_ALT_LABEL,label,lang);
    }
    Resource bnode=model.createResource(""String_Node_Str"");
    subj.addProperty(ResourceFactory.createProperty(""String_Node_Str""),bnode);
    bnode.addProperty(model.createProperty(property),obj);
    bnode.addProperty(Constants.DEFACTO_FROM,from == null ? ""String_Node_Str"" : from);
    bnode.addProperty(Constants.DEFACTO_TO,to == null ? ""String_Node_Str"" : to);
    Evidence ev=Defacto.checkFact(new DefactoModel(model,subject + ""String_Node_Str"" + property+ ""String_Node_Str""+ object,true,languages),Defacto.TIME_DISTRIBUTION_ONLY.YES);
    JSONObject result=new JSONObject();
    result.put(""String_Node_Str"",subject);
    result.put(""String_Node_Str"",StringUtils.join(slabels,""String_Node_Str""));
    result.put(""String_Node_Str"",property);
    result.put(""String_Node_Str"",object);
    result.put(""String_Node_Str"",StringUtils.join(olabels,""String_Node_Str""));
    result.put(""String_Node_Str"",from == null ? ""String_Node_Str"" : from);
    result.put(""String_Node_Str"",to == null ? ""String_Node_Str"" : to);
    buildYearOccurrences(result,ev);
    return Response.ok(result.toString()).header(""String_Node_Str"",""String_Node_Str"").build();
  }
 catch (  Exception e) {
    DefactoServer.log.log(Level.WARNING,""String_Node_Str"" + subject + ""String_Node_Str""+ property+ ""String_Node_Str""+ object+ ""String_Node_Str"");
    DefactoServer.log.log(Level.WARNING,e.getMessage());
    e.printStackTrace();
  }
  return Response.serverError().build();
}","@POST @Produces(""String_Node_Str"") public Response getJson(@QueryParam(""String_Node_Str"") String subject,@QueryParam(""String_Node_Str"") List<String> slabels,@QueryParam(""String_Node_Str"") List<String> sAltLabels,@QueryParam(""String_Node_Str"") String object,@QueryParam(""String_Node_Str"") List<String> olabels,@QueryParam(""String_Node_Str"") List<String> oAltLabels,@QueryParam(""String_Node_Str"") String property,@QueryParam(""String_Node_Str"") String from,@QueryParam(""String_Node_Str"") String to,@QueryParam(""String_Node_Str"") List<String> languages,@QueryParam(""String_Node_Str"") String contextSize){
  DefactoServer.log.log(Level.INFO,""String_Node_Str"" + subject + ""String_Node_Str""+ property+ ""String_Node_Str""+ object+ ""String_Node_Str"");
  if (olabels != null && slabels != null)   DefactoServer.log.log(Level.INFO,""String_Node_Str"" + slabels + ""String_Node_Str""+ property+ ""String_Node_Str""+ olabels+ ""String_Node_Str"");
  try {
    org.apache.log4j.PropertyConfigurator.configure(""String_Node_Str"");
    Defacto.init();
    Defacto.DEFACTO_CONFIG.setStringSetting(""String_Node_Str"",""String_Node_Str"",contextSize);
    Model model=ModelFactory.createDefaultModel();
    Resource subj=model.createResource(subject);
    for (    String labelToLang : slabels) {
      String label=labelToLang.substring(0,labelToLang.length() - 3);
      String lang=labelToLang.substring(labelToLang.length() - 2);
      subj.addProperty(RDFS.label,label,lang);
    }
    for (    String altLabel : sAltLabels) {
      String label=altLabel.substring(0,altLabel.length() - 3);
      String lang=altLabel.substring(altLabel.length() - 2);
      subj.addProperty(Constants.SKOS_ALT_LABEL,label,lang);
    }
    Resource obj=model.createResource(object);
    for (    String labelToLang : olabels) {
      String label=labelToLang.substring(0,labelToLang.length() - 3);
      String lang=labelToLang.substring(labelToLang.length() - 2);
      obj.addProperty(RDFS.label,label,lang);
    }
    for (    String altLabel : oAltLabels) {
      String label=altLabel.substring(0,altLabel.length() - 3);
      String lang=altLabel.substring(altLabel.length() - 2);
      obj.addProperty(Constants.SKOS_ALT_LABEL,label,lang);
    }
    Resource bnode=model.createResource(""String_Node_Str"");
    subj.addProperty(ResourceFactory.createProperty(""String_Node_Str""),bnode);
    bnode.addProperty(model.createProperty(property),obj);
    bnode.addProperty(Constants.DEFACTO_FROM,from == null ? ""String_Node_Str"" : from);
    bnode.addProperty(Constants.DEFACTO_TO,to == null ? ""String_Node_Str"" : to);
    Evidence ev=Defacto.checkFact(new DefactoModel(model,subject + ""String_Node_Str"" + property+ ""String_Node_Str""+ object,true,languages),Defacto.TIME_DISTRIBUTION_ONLY.YES);
    JSONObject result=new JSONObject();
    result.put(""String_Node_Str"",subject);
    result.put(""String_Node_Str"",StringUtils.join(slabels,""String_Node_Str""));
    result.put(""String_Node_Str"",property);
    result.put(""String_Node_Str"",object);
    result.put(""String_Node_Str"",StringUtils.join(olabels,""String_Node_Str""));
    result.put(""String_Node_Str"",from == null ? ""String_Node_Str"" : from);
    result.put(""String_Node_Str"",to == null ? ""String_Node_Str"" : to);
    buildYearOccurrences(result,ev);
    return Response.ok(result.toString()).header(""String_Node_Str"",""String_Node_Str"").build();
  }
 catch (  Exception e) {
    DefactoServer.log.log(Level.WARNING,""String_Node_Str"" + subject + ""String_Node_Str""+ property+ ""String_Node_Str""+ object+ ""String_Node_Str"");
    DefactoServer.log.log(Level.WARNING,e.getMessage());
    e.printStackTrace();
  }
  return Response.serverError().build();
}"
49838,"/** 
 * @param models
 * @return
 */
public static void checkFacts(DefactoConfig config,List<DefactoModel> defactoModel){
  SubjectObjectFactSearcher.getInstance();
  startTime=System.currentTimeMillis();
  numberOfModels=defactoModel.size();
  currentModel=1;
  DEFACTO_CONFIG=config;
  for (  DefactoModel model : defactoModel) {
    if (currentModel++ < 80)     continue;
    Evidence evidence=checkFact(model);
    System.out.println(model.getFact());
    if (!Defacto.DEFACTO_CONFIG.getBooleanSetting(""String_Node_Str"",""String_Node_Str""))     System.out.println(""String_Node_Str"" + new DecimalFormat(""String_Node_Str"").format(evidence.getDeFactoScore()) + ""String_Node_Str""+ model.isCorrect()+ ""String_Node_Str"");
  }
  if (DEFACTO_CONFIG.getBooleanSetting(""String_Node_Str"",""String_Node_Str""))   writeFactTrainingDataFile();
  if (DEFACTO_CONFIG.getBooleanSetting(""String_Node_Str"",""String_Node_Str""))   writeEvidenceTrainingDataFile();
}","/** 
 * @param models
 * @return
 */
public static void checkFacts(DefactoConfig config,List<DefactoModel> defactoModel){
  SubjectObjectFactSearcher.getInstance();
  startTime=System.currentTimeMillis();
  numberOfModels=defactoModel.size();
  currentModel=1;
  DEFACTO_CONFIG=config;
  for (  DefactoModel model : defactoModel) {
    Evidence evidence=checkFact(model);
    if (!Defacto.DEFACTO_CONFIG.getBooleanSetting(""String_Node_Str"",""String_Node_Str""))     System.out.println(""String_Node_Str"" + new DecimalFormat(""String_Node_Str"").format(evidence.getDeFactoScore()) + ""String_Node_Str""+ model.isCorrect()+ ""String_Node_Str"");
    if (DEFACTO_CONFIG.getBooleanSetting(""String_Node_Str"",""String_Node_Str""))     writeEvidenceTrainingDataFile();
  }
  if (DEFACTO_CONFIG.getBooleanSetting(""String_Node_Str"",""String_Node_Str""))   writeFactTrainingDataFile();
}"
49839,"/** 
 * @param args
 * @throws IOException 
 */
public static void main(String[] args) throws IOException {
  org.apache.log4j.PropertyConfigurator.configure(""String_Node_Str"");
  DefactoConfig config=new DefactoConfig(new Ini(new File(""String_Node_Str"")));
  List<String> pathToFalseData=new ArrayList<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  String falseDataDir : pathToFalseData) {
    AbstractFeature.provenance=new Instances(""String_Node_Str"",AbstractFeature.attributes,0);
    config.setStringSetting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + falseDataDir + ""String_Node_Str"");
    Defacto.checkFacts(config,getTrainingData(falseDataDir));
  }
}","/** 
 * @param args
 * @throws IOException 
 */
public static void main(String[] args) throws IOException {
  org.apache.log4j.PropertyConfigurator.configure(""String_Node_Str"");
  DefactoConfig config=new DefactoConfig(new Ini(new File(""String_Node_Str"")));
  List<String> pathToFalseData=new ArrayList<String>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  String falseDataDir : pathToFalseData) {
    AbstractFeature.provenance=new Instances(""String_Node_Str"",AbstractFeature.attributes,0);
    config.setStringSetting(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + falseDataDir + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + falseDataDir);
    Defacto.checkFacts(config,getTrainingData(falseDataDir));
  }
}"
49840,"@Override public String generateQuery(MetaQuery query){
  String subject=query.getSubjectLabel();
  String property=normalizePredicate(query.getPropertyLabel().substring(0,query.getPropertyLabel().length() - 3).substring(3).trim());
  String object=query.getObjectLabel();
  String queryString=""String_Node_Str"";
  if (query.getTopicTerms().isEmpty()) {
    if (query.getPropertyLabel().equals(""String_Node_Str""))     queryString=String.format(""String_Node_Str"",subject,object);
 else     queryString=String.format(""String_Node_Str"",subject,property,object);
  }
 else {
    queryString=String.format(""String_Node_Str"",subject,property,object);
    for (int i=0; i < 3 && i < query.getTopicTerms().size(); i++)     queryString+=""String_Node_Str"" + query.getTopicTerms().get(i).getWord() + ""String_Node_Str"";
  }
  return queryString;
}","@Override public String generateQuery(MetaQuery query){
  String subject=query.getSubjectLabel().replace(""String_Node_Str"",""String_Node_Str"");
  String property=normalizePredicate(query.getPropertyLabel().substring(0,query.getPropertyLabel().length() - 3).substring(3).trim());
  String object=query.getObjectLabel().replace(""String_Node_Str"",""String_Node_Str"");
  String queryString=""String_Node_Str"";
  if (query.getTopicTerms().isEmpty()) {
    if (query.getPropertyLabel().equals(""String_Node_Str""))     queryString=String.format(""String_Node_Str"",subject,object);
 else     queryString=String.format(""String_Node_Str"",subject,property,object);
  }
 else {
    queryString=String.format(""String_Node_Str"",subject,property,object);
    for (int i=0; i < 3 && i < query.getTopicTerms().size(); i++)     queryString+=""String_Node_Str"" + query.getTopicTerms().get(i).getWord() + ""String_Node_Str"";
  }
  return queryString;
}"
49841,"@Override public String readPage(String url,int timeout){
  try {
    return Jsoup.connect(url).timeout(timeout).get().text();
  }
 catch (  Throwable e) {
    if (e.getMessage().contains(""String_Node_Str"") || e.getMessage().contains(""String_Node_Str"") || e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e instanceof UnknownHostException|| e instanceof SSLHandshakeException|| e instanceof SocketException) {
      logger.debug(String.format(""String_Node_Str"",url));
    }
 else     logger.error(String.format(""String_Node_Str"",url),e);
  }
  return ""String_Node_Str"";
}","@Override public String readPage(String url,int timeout){
  try {
    return Jsoup.connect(url).timeout(timeout).get().text();
  }
 catch (  Throwable e) {
    if (e.getMessage().contains(""String_Node_Str"") || e.getMessage().contains(""String_Node_Str"") || e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e.getMessage().contains(""String_Node_Str"")|| e instanceof UnknownHostException|| e instanceof SSLHandshakeException|| e instanceof SocketException) {
      logger.debug(String.format(""String_Node_Str"",url));
    }
 else     logger.error(String.format(""String_Node_Str"",url),e);
  }
  return ""String_Node_Str"";
}"
49842,"public static String fixName(String n){
  if (n.contains(""String_Node_Str"")) {
    n=n.replace(""String_Node_Str"",""String_Node_Str"");
  }
  if (n.equals(""String_Node_Str"")) {
    n=""String_Node_Str"";
  }
  return Character.toUpperCase(n.charAt(0)) + n.substring(1);
}","public static String fixName(String n){
  if (n.contains(""String_Node_Str"")) {
    n=n.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return Character.toUpperCase(n.charAt(0)) + n.substring(1);
}"
49843,"@Override public void onPostLoad(){
  for (  LiquidDictionary.LiquidRegisterEvent e : events) {
    liquids.processLiquidFromDictionary(e);
  }
  containers=new LRContainerManager();
  if (LRItems.barrel != null) {
    containers.registerContainer(LRItems.barrelEmpty,LRItems.barrel,PfF.Proxy.translate(""String_Node_Str""),PfFTuning.getInt(PfFTuning.Items.barrel_capacity),Blacklists.barrel);
  }
  if (LRItems.capsule != null) {
    containers.registerContainer(Forestry.items(""String_Node_Str""),LRItems.capsule,PfF.Proxy.translate(""String_Node_Str""),LiquidContainerRegistry.BUCKET_VOLUME,Blacklists.capsule);
  }
  if (LRItems.rcapsule != null) {
    containers.registerContainer(Forestry.items(""String_Node_Str""),LRItems.rcapsule,PfF.Proxy.translate(""String_Node_Str""),LiquidContainerRegistry.BUCKET_VOLUME,Blacklists.capsule);
  }
  if (LRItems.can != null) {
    containers.registerContainer(Forestry.items(""String_Node_Str""),LRItems.can,PfF.Proxy.translate(""String_Node_Str""),LiquidContainerRegistry.BUCKET_VOLUME,Blacklists.capsule);
  }
  bucket=new LRBucketManager(LRItems.bucket,Blacklists.ironBucket);
  if (LRItems.ItemStackWoodenBucketEmpty != null) {
    woodenBucket=new LRBucketManager(LRItems.woodenBucket,Blacklists.woodenBucket);
  }
}","@Override public void onPostLoad(){
  for (  LiquidDictionary.LiquidRegisterEvent e : events) {
    liquids.processLiquidFromDictionary(e);
  }
  containers=new LRContainerManager();
  if (LRItems.barrel != null) {
    containers.registerContainer(LRItems.barrelEmpty,LRItems.barrel,PfF.Proxy.translate(""String_Node_Str""),PfFTuning.getInt(PfFTuning.Barrel.barrel_capacity),Blacklists.barrel);
  }
  if (LRItems.capsule != null) {
    containers.registerContainer(Forestry.items(""String_Node_Str""),LRItems.capsule,PfF.Proxy.translate(""String_Node_Str""),LiquidContainerRegistry.BUCKET_VOLUME,Blacklists.capsule);
  }
  if (LRItems.rcapsule != null) {
    containers.registerContainer(Forestry.items(""String_Node_Str""),LRItems.rcapsule,PfF.Proxy.translate(""String_Node_Str""),LiquidContainerRegistry.BUCKET_VOLUME,Blacklists.capsule);
  }
  if (LRItems.can != null) {
    containers.registerContainer(Forestry.items(""String_Node_Str""),LRItems.can,PfF.Proxy.translate(""String_Node_Str""),LiquidContainerRegistry.BUCKET_VOLUME,Blacklists.capsule);
  }
  bucket=new LRBucketManager(LRItems.bucket,Blacklists.ironBucket);
  if (LRItems.ItemStackWoodenBucketEmpty != null) {
    woodenBucket=new LRBucketManager(LRItems.woodenBucket,Blacklists.woodenBucket);
  }
}"
49844,"public static boolean isPluginLoaded(String var0){
  try {
    Class var2=Class.forName(""String_Node_Str"");
    Method var3=var2.getMethod(""String_Node_Str"",new Class[]{String.class});
    String var4=var3.invoke((Object)null,new Object[]{var0}).toString();
    boolean var1;
    if (var4.toLowerCase().equals(""String_Node_Str"")) {
      var1=true;
    }
 else {
      var1=false;
    }
    return var1;
  }
 catch (  Exception var5) {
    var5.printStackTrace();
    return false;
  }
}","public static boolean isPluginLoaded(String var0){
  String var2=API.class.getPackage().toString();
  String var3=""String_Node_Str"";
  String var4=""String_Node_Str"";
  if (!var2.equals(var3)) {
    var4=""String_Node_Str"" + var4;
  }
  try {
    Class var5=Class.forName(var4);
    Method var6=var5.getMethod(""String_Node_Str"",new Class[]{String.class});
    String var7=var6.invoke((Object)null,new Object[]{var0}).toString();
    boolean var1;
    if (var7.toLowerCase().equals(""String_Node_Str"")) {
      var1=true;
    }
 else {
      var1=false;
    }
    return var1;
  }
 catch (  Exception var8) {
    var8.printStackTrace();
    return false;
  }
}"
49845,"public static boolean isPluginLoaded(String name){
  boolean loaded;
  try {
    Class pluginCore=Class.forName(""String_Node_Str"");
    Method isPluginAlive=pluginCore.getMethod(""String_Node_Str"",new Class[]{String.class});
    String l=isPluginAlive.invoke(null,name).toString();
    if (l.toLowerCase().equals(""String_Node_Str"")) {
      if (API.verbose) {
        System.out.println(name + ""String_Node_Str"");
      }
      loaded=true;
    }
 else {
      if (API.verbose) {
        System.out.println(name + ""String_Node_Str"");
      }
      loaded=false;
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return false;
  }
  return loaded;
}","public static boolean isPluginLoaded(String name){
  boolean loaded;
  String Package=API.class.getPackage().toString();
  String expectedSSP=""String_Node_Str"";
  String pluginCore_Class=""String_Node_Str"";
  if (!Package.equals(expectedSSP)) {
    pluginCore_Class=""String_Node_Str"" + pluginCore_Class;
  }
  try {
    Class pluginCore=Class.forName(pluginCore_Class);
    Method isPluginAlive=pluginCore.getMethod(""String_Node_Str"",new Class[]{String.class});
    String l=isPluginAlive.invoke(null,name).toString();
    if (l.toLowerCase().equals(""String_Node_Str"")) {
      if (API.verbose) {
        System.out.println(name + ""String_Node_Str"");
      }
      loaded=true;
    }
 else {
      if (API.verbose) {
        System.out.println(name + ""String_Node_Str"");
      }
      loaded=false;
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return false;
  }
  return loaded;
}"
49846,"public static boolean isPluginLoaded(String name){
  boolean loaded;
  try {
    Class pluginCore=Class.forName(""String_Node_Str"");
    Method isPluginAlive=pluginCore.getMethod(""String_Node_Str"",new Class[]{String.class});
    String l=isPluginAlive.invoke(null,name).toString();
    if (l.toLowerCase().equals(""String_Node_Str"")) {
      if (API.verbose) {
        System.out.println(name + ""String_Node_Str"");
      }
      loaded=true;
    }
 else {
      if (API.verbose) {
        System.out.println(name + ""String_Node_Str"");
      }
      loaded=false;
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return false;
  }
  return loaded;
}","public static boolean isPluginLoaded(String name){
  boolean loaded;
  String Package=API.class.getPackage().toString();
  String expectedSSP=""String_Node_Str"";
  String pluginCore_Class=""String_Node_Str"";
  if (!Package.equals(expectedSSP)) {
    pluginCore_Class=""String_Node_Str"" + pluginCore_Class;
  }
  try {
    Class pluginCore=Class.forName(pluginCore_Class);
    Method isPluginAlive=pluginCore.getMethod(""String_Node_Str"",new Class[]{String.class});
    String l=isPluginAlive.invoke(null,name).toString();
    if (l.toLowerCase().equals(""String_Node_Str"")) {
      if (API.verbose) {
        System.out.println(name + ""String_Node_Str"");
      }
      loaded=true;
    }
 else {
      if (API.verbose) {
        System.out.println(name + ""String_Node_Str"");
      }
      loaded=false;
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return false;
  }
  return loaded;
}"
49847,"public BoardPanel(BoardSize boardSize,SquareConfig squareConfig,Function<BoardCoordinate,Set<BoardCoordinate>> getMovesCallback){
  super(false);
  mSquareConfig=squareConfig;
  mGetMovesCallback=getMovesCallback;
  mBoardSize=boardSize;
  mSquareLabels=new ArrayList<>(boardSize.width * boardSize.height);
  GridLayout gridLayout=new GridLayout(mBoardSize.width + 2,mBoardSize.height + 2);
  setLayout(gridLayout);
  createGrid(gridLayout);
}","public BoardPanel(BoardSize boardSize,SquareConfig squareConfig,Function<BoardCoordinate,Set<BoardCoordinate>> getMovesCallback){
  super(false);
  mSquareConfig=squareConfig;
  mGetMovesCallback=getMovesCallback;
  mBoardSize=boardSize;
  mSquareLabels=new ArrayList<>(boardSize.width * boardSize.height);
  GridLayout gridLayout=new GridLayout(mBoardSize.height + 1,mBoardSize.width + 2);
  setLayout(gridLayout);
  createGrid(gridLayout);
}"
49848,"private void createGrid(GridLayout gridLayout){
  for (int y=gridLayout.getRows() - 1; y >= 0; y--) {
    for (int x=0; x < gridLayout.getColumns(); x++) {
      add(getComponentForCell(x,y,gridLayout.getColumns() - 1,gridLayout.getRows() - 1));
    }
  }
}","private void createGrid(GridLayout gridLayout){
  for (int y=gridLayout.getRows() - 1; y >= 0; y--) {
    for (int x=0; x < gridLayout.getColumns(); x++) {
      add(getComponentForCell(x,y,gridLayout.getColumns() - 1));
    }
  }
}"
49849,"public void updateDimensions(int width,int height){
  int size=Math.min(width,height);
  setMinimumSize(new Dimension(size,size));
  setPreferredSize(new Dimension(size,size));
  setMaximumSize(new Dimension(size,size));
  revalidate();
  repaint();
}","public void updateDimensions(int width,int height){
  int newHeight=height;
  int newWidth=width;
  if (width < height) {
    newHeight=(width / (mBoardSize.width + 2)) * (mBoardSize.height + 1);
  }
 else {
    newWidth=(height / (mBoardSize.height + 1)) * (mBoardSize.width + 2);
  }
  setMinimumSize(new Dimension(newWidth,newHeight));
  setPreferredSize(new Dimension(newWidth,newHeight));
  setMaximumSize(new Dimension(newWidth,newHeight));
  revalidate();
  repaint();
}"
49850,"private JLabel getComponentForCell(int x,int y,int maxColumns,int maxRows){
  if ((x == 0 && y == 0) || (x == maxColumns) || (y == maxRows)) {
    return UiUtility.createJLabel(""String_Node_Str"");
  }
 else   if (x == 0) {
    JLabel label=UiUtility.createJLabel(String.valueOf(y));
    label.setHorizontalAlignment(SwingConstants.CENTER);
    return label;
  }
 else   if (y == 0) {
    JLabel label=UiUtility.createJLabel(String.valueOf((char)(x - 1 + 'A')));
    label.setHorizontalAlignment(SwingConstants.CENTER);
    return label;
  }
 else {
    SquareJLabel square=new SquareJLabel(BoardCoordinate.at(x,y));
    mSquareConfig.configureSquare(square,() -> {
      Set<BoardCoordinate> coordinates=mGetMovesCallback.apply(square.getCoordinates());
      return !coordinates.isEmpty() ? getLabelsForCoordinates(coordinates) : Collections.emptyList();
    }
);
    mSquareLabels.add(square);
    return square;
  }
}","private JLabel getComponentForCell(int x,int y,int maxColumns){
  if ((x == 0 && y == 0) || x == maxColumns) {
    return UiUtility.createJLabel(""String_Node_Str"");
  }
 else   if (x == 0) {
    JLabel label=UiUtility.createJLabel(String.valueOf(y));
    label.setHorizontalAlignment(SwingConstants.CENTER);
    return label;
  }
 else   if (y == 0) {
    JLabel label=UiUtility.createJLabel(String.valueOf((char)(x - 1 + 'A')));
    label.setHorizontalAlignment(SwingConstants.CENTER);
    return label;
  }
 else {
    SquareJLabel square=new SquareJLabel(BoardCoordinate.at(x,y));
    mSquareConfig.configureSquare(square,() -> {
      Set<BoardCoordinate> coordinates=mGetMovesCallback.apply(square.getCoordinates());
      return !coordinates.isEmpty() ? getLabelsForCoordinates(coordinates) : Collections.emptyList();
    }
);
    mSquareLabels.add(square);
    return square;
  }
}"
49851,"private void initComponents(){
  setLayout(new BoxLayout(this,BoxLayout.LINE_AXIS));
  Board[] boards=mGame.getBoards();
  JPanel boardPanels=new JPanel();
  boardPanels.setOpaque(false);
  boardPanels.setLayout(new BoxLayout(boardPanels,BoxLayout.LINE_AXIS));
  boardPanels.addComponentListener(new ComponentListener(){
    @Override public void componentResized(    ComponentEvent e){
      Stream.of(mGameBoards).forEach(board -> board.updateDimensions(e.getComponent().getWidth(),e.getComponent().getHeight()));
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentShown(    ComponentEvent e){
    }
    @Override public void componentHidden(    ComponentEvent e){
    }
  }
);
  IntStream.range(0,boards.length).forEach(boardIndex -> {
    mGameBoards[boardIndex]=new BoardPanel(boards[boardIndex].getBoardSize(),mSquareConfig,coordinate -> {
      Piece piece=mGame.getPiece(boardIndex,coordinate);
      if (piece != null && piece.getTeamId() == mGame.getTurnKeeper().getActiveTeamId()) {
        return mGame.getMovesFrom(boardIndex,coordinate);
      }
 else {
        return Collections.emptySet();
      }
    }
);
    boardPanels.add(mGameBoards[boardIndex]);
  }
);
  Stream.of(mGame.getTeams()).forEach(team -> mTeamStatusPanels.add(new TeamStatusPanel(team)));
  mTeamStatusPanels.forEach(panel -> mTabbedPane.addTab(panel.getName(),panel));
  mUndoButton.addActionListener(event -> {
    mGame.undoMove();
    refresh();
  }
);
  mForwardButton.addActionListener(event -> {
    mGame.nextMove();
    refresh();
  }
);
  mBackButton.addActionListener(event -> {
    mGame.previousMove();
    refresh();
  }
);
  GridBagConstraints gbc=new GridBagConstraints();
  JPanel detailsPanel=new JPanel();
  detailsPanel.setLayout(new GridBagLayout());
  detailsPanel.setOpaque(false);
  gbc.gridwidth=2;
  gbc.weightx=1.0;
  gbc.fill=GridBagConstraints.BOTH;
  gbc.weighty=1.0;
  gbc.insets=new Insets(0,10,10,10);
  detailsPanel.add(mTabbedPane,gbc);
  gbc.gridy=1;
  gbc.gridx=0;
  gbc.gridwidth=2;
  gbc.weighty=0.0;
  detailsPanel.add(mUndoButton,gbc);
  gbc.gridy=2;
  gbc.gridx=0;
  gbc.gridwidth=1;
  detailsPanel.add(mBackButton,gbc);
  gbc.gridx=1;
  detailsPanel.add(mForwardButton,gbc);
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,boardPanels,detailsPanel);
  splitPane.setPreferredSize(new Dimension(755,475));
  splitPane.setDividerLocation(350);
  splitPane.setOpaque(false);
  splitPane.setDividerSize(1);
  splitPane.setResizeWeight(0.55);
  splitPane.setEnabled(false);
  add(splitPane);
  refresh();
}","private void initComponents(){
  setLayout(new BoxLayout(this,BoxLayout.LINE_AXIS));
  Board[] boards=mGame.getBoards();
  JPanel boardPanels=new JPanel();
  boardPanels.setOpaque(false);
  boardPanels.setLayout(new BoxLayout(boardPanels,BoxLayout.LINE_AXIS));
  boardPanels.addComponentListener(new ComponentListener(){
    @Override public void componentResized(    ComponentEvent e){
      Stream.of(mGameBoards).forEach(board -> board.updateDimensions(e.getComponent().getWidth(),e.getComponent().getHeight()));
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentShown(    ComponentEvent e){
    }
    @Override public void componentHidden(    ComponentEvent e){
    }
  }
);
  IntStream.range(0,boards.length).forEach(boardIndex -> {
    mGameBoards[boardIndex]=new BoardPanel(boards[boardIndex].getBoardSize(),mSquareConfig,coordinate -> {
      Piece piece=mGame.getPiece(boardIndex,coordinate);
      if (piece != null && piece.getTeamId() == mGame.getTurnKeeper().getActiveTeamId()) {
        return mGame.getMovesFrom(boardIndex,coordinate);
      }
 else {
        return Collections.emptySet();
      }
    }
);
    boardPanels.add(mGameBoards[boardIndex]);
  }
);
  Stream.of(mGame.getTeams()).forEach(team -> mTeamStatusPanels.add(new TeamStatusPanel(team)));
  mTeamStatusPanels.forEach(panel -> mTabbedPane.addTab(panel.getName(),panel));
  mUndoButton.addActionListener(event -> {
    mGame.undoMove();
    refresh();
  }
);
  mForwardButton.addActionListener(event -> {
    mGame.nextMove();
    refresh();
  }
);
  mBackButton.addActionListener(event -> {
    mGame.previousMove();
    refresh();
  }
);
  GridBagConstraints gbc=new GridBagConstraints();
  JPanel detailsPanel=new JPanel();
  detailsPanel.setLayout(new GridBagLayout());
  detailsPanel.setOpaque(false);
  gbc.gridwidth=2;
  gbc.weightx=1.0;
  gbc.fill=GridBagConstraints.BOTH;
  gbc.weighty=1.0;
  gbc.insets=new Insets(0,10,10,10);
  detailsPanel.add(mTabbedPane,gbc);
  gbc.gridy=1;
  gbc.gridx=0;
  gbc.gridwidth=2;
  gbc.weighty=0.0;
  detailsPanel.add(mUndoButton,gbc);
  gbc.gridy=2;
  gbc.gridx=0;
  gbc.gridwidth=1;
  detailsPanel.add(mBackButton,gbc);
  gbc.gridx=1;
  detailsPanel.add(mForwardButton,gbc);
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,boardPanels,detailsPanel);
  splitPane.setPreferredSize(new Dimension(755,475));
  splitPane.setDividerLocation(375);
  splitPane.setOpaque(false);
  splitPane.setDividerSize(1);
  splitPane.setResizeWeight(0.55);
  splitPane.setEnabled(false);
  add(splitPane);
  refresh();
}"
49852,"private void initComponents(){
  setLayout(new BoxLayout(this,BoxLayout.PAGE_AXIS));
  JPanel namePanel=new JPanel();
  namePanel.setOpaque(false);
  namePanel.add(UiUtility.createJLabel(Messages.getString(""String_Node_Str"")));
  namePanel.add(mPieceNameField);
  mImageButton.setToolTipText(Messages.getString(""String_Node_Str""));
  mImageButton.setPreferredSize(new Dimension(75,75));
  namePanel.add(mImageButton);
  JPanel allMovementsPanel=new JPanel();
  allMovementsPanel.setOpaque(false);
  allMovementsPanel.setLayout(new GridBagLayout());
  allMovementsPanel.setBorder(BorderFactory.createEmptyBorder(10,10,0,10));
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.fill=GridBagConstraints.BOTH;
  gbc.weightx=1.0;
  gbc.weighty=1.0;
  gbc.gridwidth=3;
  allMovementsPanel.add(namePanel,gbc);
  dataStream().forEachOrdered(data -> {
    createScrollPane(allMovementsPanel,data.list,data.buttons,data.title);
    data.buttons.addAddActionListener(e -> data.showInputDialog.accept(false));
    data.buttons.addEditActionListener(e -> data.showInputDialog.accept(true));
    data.buttons.addRemoveActionListener(e -> data.model.remove(data.list.getSelectedIndex()));
    data.list.addListSelectionListener(e -> refreshButtonState(data));
  }
);
  JPanel boardPanels=new JPanel();
  boardPanels.setOpaque(false);
  boardPanels.setLayout(new BoxLayout(boardPanels,BoxLayout.LINE_AXIS));
  boardPanels.add(Box.createHorizontalGlue());
  boardPanels.add(mBoardPanel);
  boardPanels.add(Box.createHorizontalGlue());
  boardPanels.addComponentListener(new ComponentListener(){
    @Override public void componentResized(    ComponentEvent e){
      mBoardPanel.updateDimensions(e.getComponent().getWidth(),e.getComponent().getHeight());
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentShown(    ComponentEvent e){
    }
    @Override public void componentHidden(    ComponentEvent e){
    }
  }
);
  JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,allMovementsPanel,boardPanels);
  splitPane.setPreferredSize(new Dimension(755,475));
  splitPane.setDividerLocation(230);
  splitPane.setOpaque(false);
  splitPane.setDividerSize(0);
  splitPane.setResizeWeight(0.3);
  splitPane.setEnabled(false);
  add(splitPane);
}","private void initComponents(){
  setLayout(new BoxLayout(this,BoxLayout.PAGE_AXIS));
  JPanel namePanel=new JPanel();
  namePanel.setOpaque(false);
  namePanel.add(UiUtility.createJLabel(Messages.getString(""String_Node_Str"")));
  namePanel.add(mPieceNameField);
  mImageButton.setToolTipText(Messages.getString(""String_Node_Str""));
  mImageButton.setPreferredSize(new Dimension(70,70));
  namePanel.add(mImageButton);
  JPanel allMovementsPanel=new JPanel();
  allMovementsPanel.setOpaque(false);
  allMovementsPanel.setLayout(new GridBagLayout());
  allMovementsPanel.setBorder(BorderFactory.createEmptyBorder(5,10,10,10));
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.fill=GridBagConstraints.BOTH;
  gbc.weightx=1.0;
  gbc.weighty=1.0;
  gbc.gridwidth=3;
  allMovementsPanel.add(namePanel,gbc);
  dataStream().forEachOrdered(data -> {
    createScrollPane(allMovementsPanel,data.list,data.buttons,data.title);
    data.buttons.addAddActionListener(e -> data.showInputDialog.accept(false));
    data.buttons.addEditActionListener(e -> data.showInputDialog.accept(true));
    data.buttons.addRemoveActionListener(e -> data.model.remove(data.list.getSelectedIndex()));
    data.list.addListSelectionListener(e -> refreshButtonState(data));
  }
);
  JPanel boardPanels=new JPanel();
  boardPanels.setOpaque(false);
  boardPanels.setLayout(new BoxLayout(boardPanels,BoxLayout.LINE_AXIS));
  boardPanels.add(Box.createHorizontalGlue());
  boardPanels.add(mBoardPanel);
  boardPanels.add(Box.createHorizontalGlue());
  boardPanels.addComponentListener(new ComponentListener(){
    @Override public void componentResized(    ComponentEvent e){
      mBoardPanel.updateDimensions(e.getComponent().getWidth(),e.getComponent().getHeight());
    }
    @Override public void componentMoved(    ComponentEvent e){
    }
    @Override public void componentShown(    ComponentEvent e){
    }
    @Override public void componentHidden(    ComponentEvent e){
    }
  }
);
  JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,allMovementsPanel,boardPanels);
  splitPane.setPreferredSize(new Dimension(755,475));
  splitPane.setDividerLocation(230);
  splitPane.setOpaque(false);
  splitPane.setDividerSize(0);
  splitPane.setResizeWeight(0.3);
  splitPane.setEnabled(false);
  add(splitPane);
}"
49853,"public void loadPieceType(PieceType pieceType){
  clearPieceData();
  Icon pieceIcon=PieceIconUtility.getPieceIcon(pieceType.getInternalId(),Color.WHITE);
  mImageButton.setIcon(pieceIcon);
  mImageButton.setPressedIcon(pieceIcon);
  mPieceNameField.setText(pieceType.getName());
  pieceType.getMovements().forEach(mMovementData.model::addElement);
  pieceType.getCapturingMovements().forEach(mCapturingData.model::addElement);
  pieceType.getTwoHopMovements().forEach(mTwoHopData.model::addElement);
  mBoard.addPiece(new Piece(Piece.TEAM_ONE,pieceType),BoardCoordinate.at(4,4));
  dataStream().forEach(this::refreshButtonState);
  refreshBoard();
}","public void loadPieceType(PieceType pieceType){
  clearPieceData();
  Icon pieceIcon=PieceIconUtility.getPieceIcon(pieceType.getInternalId(),Color.WHITE);
  mImageButton.setIcon(pieceIcon);
  mImageButton.setPressedIcon(pieceIcon);
  mPieceNameField.setText(pieceType.getName());
  pieceType.getMovements().forEach(mMovementData.model::addElement);
  pieceType.getCapturingMovements().forEach(mCapturingData.model::addElement);
  pieceType.getTwoHopMovements().forEach(mTwoHopData.model::addElement);
  mBoard.addPiece(new Piece(Piece.TEAM_ONE,pieceType),BoardCoordinate.at(mBoard.getBoardSize().width / 2,mBoard.getBoardSize().height / 2));
  dataStream().forEach(this::refreshButtonState);
  refreshBoard();
}"
49854,"private void deletePiece(){
  PieceType pieceType=mPieceList.getSelectedValue();
  Preconditions.checkState(!PieceTypeManager.INSTANCE.isSystemPiece(pieceType.getInternalId()));
  if (FileManager.INSTANCE.deletePiece(pieceType)) {
    PieceTypeManager.INSTANCE.unregisterPieceType(pieceType);
    mPieceListModel.removeElement(pieceType);
  }
 else {
  }
}","private void deletePiece(){
  PieceType pieceType=mPieceList.getSelectedValue();
  Preconditions.checkState(!PieceTypeManager.INSTANCE.isSystemPiece(pieceType.getInternalId()));
  if (FileManager.INSTANCE.deletePiece(pieceType)) {
    PieceTypeManager.INSTANCE.unregisterPieceType(pieceType.getInternalId());
    mPieceListModel.removeElement(pieceType);
  }
 else {
  }
}"
49855,"private void initComponents(){
  GridBagConstraints constraints=new GridBagConstraints();
  setLayout(new GridBagLayout());
  JPanel teamMetaData=new JPanel();
  teamMetaData.setOpaque(false);
  teamMetaData.setLayout(new GridBagLayout());
  teamMetaData.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
  GridBagConstraints teamConstraint=new GridBagConstraints();
  teamConstraint.fill=GridBagConstraints.BOTH;
  teamConstraint.gridx=0;
  teamConstraint.gridy=0;
  teamConstraint.insets=new Insets(5,0,5,5);
  teamMetaData.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.weightx=1.0;
  teamConstraint.gridx=1;
  teamConstraint.insets=new Insets(5,0,5,0);
  teamMetaData.add(mPlayerName,teamConstraint);
  teamConstraint.gridx=0;
  teamConstraint.gridy=1;
  teamConstraint.weightx=0.0;
  teamMetaData.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.gridx=1;
  teamConstraint.weightx=1.0;
  teamMetaData.add(mTeamLabel,teamConstraint);
  teamConstraint.gridy=2;
  teamConstraint.gridx=0;
  teamConstraint.gridwidth=2;
  teamConstraint.weighty=0.1;
  teamConstraint.weightx=1.0;
  teamMetaData.add(mJailPanel,teamConstraint);
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.fill=GridBagConstraints.BOTH;
  constraints.gridy=0;
  constraints.weightx=1.0;
  constraints.weighty=0.5;
  constraints.gridwidth=2;
  constraints.insets=new Insets(10,10,10,10);
  add(teamMetaData,constraints);
}","private void initComponents(){
  GridBagConstraints constraints=new GridBagConstraints();
  setLayout(new GridBagLayout());
  JPanel teamMetadata=new JPanel();
  teamMetadata.setOpaque(false);
  teamMetadata.setLayout(new GridBagLayout());
  teamMetadata.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
  GridBagConstraints teamConstraint=new GridBagConstraints();
  teamConstraint.fill=GridBagConstraints.BOTH;
  teamConstraint.gridx=0;
  teamConstraint.gridy=0;
  teamConstraint.insets=new Insets(5,0,5,5);
  teamMetadata.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.weightx=1.0;
  teamConstraint.gridx=1;
  teamConstraint.insets=new Insets(5,0,5,0);
  teamMetadata.add(mPlayerName,teamConstraint);
  teamConstraint.gridx=0;
  teamConstraint.gridy=1;
  teamConstraint.weightx=0.0;
  teamMetadata.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.gridx=1;
  teamConstraint.weightx=1.0;
  teamMetadata.add(mTeamLabel,teamConstraint);
  teamConstraint.gridy=2;
  teamConstraint.gridx=0;
  teamConstraint.gridwidth=2;
  teamConstraint.weighty=0.1;
  teamConstraint.weightx=1.0;
  teamMetadata.add(mJailPanel,teamConstraint);
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.fill=GridBagConstraints.BOTH;
  constraints.gridy=0;
  constraints.weightx=1.0;
  constraints.weighty=0.5;
  constraints.gridwidth=2;
  constraints.insets=new Insets(10,10,10,10);
  add(teamMetadata,constraints);
}"
49856,"private void initComponents(){
  GridBagConstraints constraints=new GridBagConstraints();
  setLayout(new GridBagLayout());
  JPanel teamMetaData=new JPanel();
  teamMetaData.setOpaque(false);
  teamMetaData.setLayout(new GridBagLayout());
  teamMetaData.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
  GridBagConstraints teamConstraint=new GridBagConstraints();
  teamConstraint.fill=GridBagConstraints.BOTH;
  teamConstraint.gridx=0;
  teamConstraint.gridy=0;
  teamConstraint.insets=new Insets(5,0,5,0);
  teamMetaData.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.weightx=1.0;
  teamConstraint.gridx=1;
  teamMetaData.add(mPlayerName,teamConstraint);
  teamConstraint.gridx=0;
  teamConstraint.gridy=1;
  teamConstraint.weightx=0.0;
  teamMetaData.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.gridx=1;
  teamConstraint.weightx=1.0;
  teamMetaData.add(mTeamLabel,teamConstraint);
  teamConstraint.gridy=2;
  teamConstraint.gridx=0;
  teamConstraint.gridwidth=2;
  teamConstraint.weighty=0.1;
  teamConstraint.weightx=1.0;
  teamMetaData.add(mJailPanel,teamConstraint);
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.fill=GridBagConstraints.BOTH;
  constraints.gridy=0;
  constraints.weightx=1.0;
  constraints.weighty=0.5;
  constraints.gridwidth=2;
  constraints.insets=new Insets(10,10,10,10);
  add(teamMetaData,constraints);
}","private void initComponents(){
  GridBagConstraints constraints=new GridBagConstraints();
  setLayout(new GridBagLayout());
  JPanel teamMetaData=new JPanel();
  teamMetaData.setOpaque(false);
  teamMetaData.setLayout(new GridBagLayout());
  teamMetaData.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
  GridBagConstraints teamConstraint=new GridBagConstraints();
  teamConstraint.fill=GridBagConstraints.BOTH;
  teamConstraint.gridx=0;
  teamConstraint.gridy=0;
  teamConstraint.insets=new Insets(5,0,5,5);
  teamMetaData.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.weightx=1.0;
  teamConstraint.gridx=1;
  teamConstraint.insets=new Insets(5,0,5,0);
  teamMetaData.add(mPlayerName,teamConstraint);
  teamConstraint.gridx=0;
  teamConstraint.gridy=1;
  teamConstraint.weightx=0.0;
  teamMetaData.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.gridx=1;
  teamConstraint.weightx=1.0;
  teamMetaData.add(mTeamLabel,teamConstraint);
  teamConstraint.gridy=2;
  teamConstraint.gridx=0;
  teamConstraint.gridwidth=2;
  teamConstraint.weighty=0.1;
  teamConstraint.weightx=1.0;
  teamMetaData.add(mJailPanel,teamConstraint);
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.fill=GridBagConstraints.BOTH;
  constraints.gridy=0;
  constraints.weightx=1.0;
  constraints.weighty=0.5;
  constraints.gridwidth=2;
  constraints.insets=new Insets(10,10,10,10);
  add(teamMetaData,constraints);
}"
49857,"public BoardPanel(BoardSize boardSize,SquareConfig squareConfig,Function<BoardCoordinate,Set<BoardCoordinate>> getMovesCallback){
  super(false);
  mSquareConfig=squareConfig;
  mGetMovesCallback=getMovesCallback;
  mBoardSize=boardSize;
  mSquareLabels=new ArrayList<>(boardSize.width * boardSize.height);
  GridLayout gridLayout=new GridLayout(mBoardSize.width + 1,mBoardSize.height + 1);
  setLayout(gridLayout);
  createGrid(gridLayout);
}","public BoardPanel(BoardSize boardSize,SquareConfig squareConfig,Function<BoardCoordinate,Set<BoardCoordinate>> getMovesCallback){
  super(false);
  mSquareConfig=squareConfig;
  mGetMovesCallback=getMovesCallback;
  mBoardSize=boardSize;
  mSquareLabels=new ArrayList<>(boardSize.width * boardSize.height);
  GridLayout gridLayout=new GridLayout(mBoardSize.width + 2,mBoardSize.height + 2);
  setLayout(gridLayout);
  createGrid(gridLayout);
}"
49858,"private void createGrid(GridLayout gridLayout){
  for (int y=gridLayout.getRows() - 1; y >= 0; y--) {
    for (int x=0; x < gridLayout.getColumns(); x++) {
      add(getComponentForCell(x,y));
    }
  }
}","private void createGrid(GridLayout gridLayout){
  for (int y=gridLayout.getRows() - 1; y >= 0; y--) {
    for (int x=0; x < gridLayout.getColumns(); x++) {
      add(getComponentForCell(x,y,gridLayout.getColumns() - 1,gridLayout.getRows() - 1));
    }
  }
}"
49859,"private JLabel getComponentForCell(int x,int y){
  if (x == 0 && y == 0) {
    return GuiUtility.createJLabel(""String_Node_Str"");
  }
 else   if (x == 0) {
    JLabel label=GuiUtility.createJLabel(String.valueOf(y));
    label.setHorizontalAlignment(SwingConstants.CENTER);
    return label;
  }
 else   if (y == 0) {
    JLabel label=GuiUtility.createJLabel(String.valueOf((char)(x - 1 + 'A')));
    label.setHorizontalAlignment(SwingConstants.CENTER);
    return label;
  }
 else {
    SquareJLabel square=new SquareJLabel(BoardCoordinate.at(x,y));
    mSquareConfig.configureSquare(square,() -> {
      Set<BoardCoordinate> coordinates=mGetMovesCallback.apply(square.getCoordinates());
      return !coordinates.isEmpty() ? getLabelsForCoordinates(coordinates) : Collections.emptyList();
    }
);
    mSquareLabels.add(square);
    return square;
  }
}","private JLabel getComponentForCell(int x,int y,int maxColumns,int maxRows){
  if ((x == 0 && y == 0) || (x == maxColumns) || (y == maxRows)) {
    return GuiUtility.createJLabel(""String_Node_Str"");
  }
 else   if (x == 0) {
    JLabel label=GuiUtility.createJLabel(String.valueOf(y));
    label.setHorizontalAlignment(SwingConstants.CENTER);
    return label;
  }
 else   if (y == 0) {
    JLabel label=GuiUtility.createJLabel(String.valueOf((char)(x - 1 + 'A')));
    label.setHorizontalAlignment(SwingConstants.CENTER);
    return label;
  }
 else {
    SquareJLabel square=new SquareJLabel(BoardCoordinate.at(x,y));
    mSquareConfig.configureSquare(square,() -> {
      Set<BoardCoordinate> coordinates=mGetMovesCallback.apply(square.getCoordinates());
      return !coordinates.isEmpty() ? getLabelsForCoordinates(coordinates) : Collections.emptyList();
    }
);
    mSquareLabels.add(square);
    return square;
  }
}"
49860,"private void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  Board[] boards=mGame.getBoards();
  IntStream.range(0,boards.length).forEach(boardIndex -> {
    mGameBoards[boardIndex]=new BoardPanel(boards[boardIndex].getBoardSize(),mSquareConfig,coordinate -> {
      Piece piece=mGame.getPiece(boardIndex,coordinate);
      if (piece != null && piece.getTeamId() == mGame.getTurnKeeper().getActiveTeamId()) {
        return mGame.getMovesFrom(boardIndex,coordinate);
      }
 else {
        return Collections.emptySet();
      }
    }
);
    constraints.gridx=boardIndex;
    constraints.weightx=1.0;
    constraints.weighty=1.0;
    constraints.gridheight=2;
    constraints.fill=GridBagConstraints.BOTH;
    constraints.insets=new Insets(10,0,0,0);
    add(mGameBoards[boardIndex],constraints);
  }
);
  Stream.of(mGame.getTeams()).forEach(team -> mTeamStatusPanels.add(new TeamStatusPanel(team)));
  mTeamStatusPanels.forEach(panel -> mTabbedPane.addTab(panel.getName(),panel));
  constraints.gridx=boards.length * 2;
  constraints.weightx=0.3;
  constraints.gridheight=1;
  constraints.weighty=1.0;
  constraints.insets=new Insets(0,25,0,10);
  add(mTabbedPane,constraints);
  mUndoButton.addActionListener(event -> {
    mGame.undoMove();
    refresh();
  }
);
  mForwardButton.addActionListener(event -> {
    mGame.nextMove();
    refresh();
  }
);
  mBackButton.addActionListener(event -> {
    mGame.previousMove();
    refresh();
  }
);
  GridBagConstraints gbc=new GridBagConstraints();
  JPanel buttonPanel=new JPanel();
  buttonPanel.setLayout(new GridBagLayout());
  buttonPanel.setOpaque(false);
  gbc.gridy=0;
  gbc.gridx=0;
  gbc.gridwidth=2;
  gbc.weightx=1.0;
  gbc.fill=GridBagConstraints.BOTH;
  buttonPanel.add(mUndoButton,gbc);
  gbc.gridy=1;
  gbc.gridx=0;
  gbc.gridwidth=1;
  buttonPanel.add(mBackButton,gbc);
  gbc.gridx=1;
  buttonPanel.add(mForwardButton,gbc);
  constraints.gridy=1;
  constraints.gridx=boards.length * 2;
  constraints.weighty=0.2;
  add(buttonPanel,constraints);
  refresh();
}","private void initComponents(){
  setLayout(new GridBagLayout());
  JPanel boardPanels=new JPanel();
  boardPanels.setOpaque(false);
  boardPanels.setLayout(new GridBagLayout());
  Board[] boards=mGame.getBoards();
  IntStream.range(0,boards.length).forEach(boardIndex -> {
    mGameBoards[boardIndex]=new BoardPanel(boards[boardIndex].getBoardSize(),mSquareConfig,coordinate -> {
      Piece piece=mGame.getPiece(boardIndex,coordinate);
      if (piece != null && piece.getTeamId() == mGame.getTurnKeeper().getActiveTeamId()) {
        return mGame.getMovesFrom(boardIndex,coordinate);
      }
 else {
        return Collections.emptySet();
      }
    }
);
    GridBagConstraints gridBagConstraints=new GridBagConstraints();
    gridBagConstraints.gridx=boardIndex;
    gridBagConstraints.fill=GridBagConstraints.BOTH;
    gridBagConstraints.weightx=1.0;
    gridBagConstraints.weighty=1.0;
    boardPanels.add(mGameBoards[boardIndex],gridBagConstraints);
  }
);
  Stream.of(mGame.getTeams()).forEach(team -> mTeamStatusPanels.add(new TeamStatusPanel(team)));
  mTeamStatusPanels.forEach(panel -> mTabbedPane.addTab(panel.getName(),panel));
  mUndoButton.addActionListener(event -> {
    mGame.undoMove();
    refresh();
  }
);
  mForwardButton.addActionListener(event -> {
    mGame.nextMove();
    refresh();
  }
);
  mBackButton.addActionListener(event -> {
    mGame.previousMove();
    refresh();
  }
);
  GridBagConstraints gbc=new GridBagConstraints();
  JPanel detailsPanel=new JPanel();
  detailsPanel.setLayout(new GridBagLayout());
  detailsPanel.setOpaque(false);
  gbc.gridwidth=2;
  gbc.weightx=1.0;
  gbc.fill=GridBagConstraints.BOTH;
  gbc.weighty=1.0;
  gbc.insets=new Insets(0,10,10,10);
  detailsPanel.add(mTabbedPane,gbc);
  gbc.gridy=1;
  gbc.gridx=0;
  gbc.gridwidth=2;
  gbc.weighty=0.0;
  detailsPanel.add(mUndoButton,gbc);
  gbc.gridy=2;
  gbc.gridx=0;
  gbc.gridwidth=1;
  detailsPanel.add(mBackButton,gbc);
  gbc.gridx=1;
  detailsPanel.add(mForwardButton,gbc);
  GridBagConstraints constraints=new GridBagConstraints();
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,boardPanels,detailsPanel);
  splitPane.setPreferredSize(new Dimension(755,475));
  splitPane.setDividerLocation(450);
  splitPane.setOpaque(false);
  splitPane.setDividerSize(1);
  splitPane.setResizeWeight(0.7);
  splitPane.setEnabled(false);
  constraints.weightx=1.0;
  constraints.weighty=1.0;
  constraints.gridheight=1;
  constraints.fill=GridBagConstraints.BOTH;
  add(splitPane,constraints);
  refresh();
}"
49861,"private void initComponents(){
  GridBagConstraints constraints=new GridBagConstraints();
  setLayout(new GridBagLayout());
  JPanel teamMetadata=new JPanel();
  teamMetadata.setOpaque(false);
  teamMetadata.setLayout(new GridBagLayout());
  teamMetadata.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
  GridBagConstraints teamConstraint=new GridBagConstraints();
  teamConstraint.fill=GridBagConstraints.BOTH;
  teamConstraint.gridx=0;
  teamConstraint.gridy=0;
  teamConstraint.insets=new Insets(5,0,5,5);
  teamMetadata.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.weightx=1.0;
  teamConstraint.gridx=1;
  teamMetadata.add(mPlayerName,teamConstraint);
  teamConstraint.gridx=0;
  teamConstraint.gridy=1;
  teamConstraint.weightx=0.0;
  teamMetadata.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.gridx=1;
  teamConstraint.weightx=1.0;
  teamMetadata.add(mTeamLabel,teamConstraint);
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.fill=GridBagConstraints.BOTH;
  constraints.gridy=0;
  constraints.weightx=1.0;
  constraints.weighty=0.5;
  constraints.gridwidth=2;
  constraints.insets=new Insets(10,10,10,10);
  add(teamMetadata,constraints);
  constraints.gridy=2;
  constraints.weighty=1.0;
  constraints.weightx=1.0;
  add(mJailPanel,constraints);
}","private void initComponents(){
  GridBagConstraints constraints=new GridBagConstraints();
  setLayout(new GridBagLayout());
  JPanel teamMetaData=new JPanel();
  teamMetaData.setOpaque(false);
  teamMetaData.setLayout(new GridBagLayout());
  teamMetaData.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
  GridBagConstraints teamConstraint=new GridBagConstraints();
  teamConstraint.fill=GridBagConstraints.BOTH;
  teamConstraint.gridx=0;
  teamConstraint.gridy=0;
  teamConstraint.insets=new Insets(5,0,5,0);
  teamMetaData.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.weightx=1.0;
  teamConstraint.gridx=1;
  teamMetaData.add(mPlayerName,teamConstraint);
  teamConstraint.gridx=0;
  teamConstraint.gridy=1;
  teamConstraint.weightx=0.0;
  teamMetaData.add(new JLabel(Messages.getString(""String_Node_Str"")),teamConstraint);
  teamConstraint.gridx=1;
  teamConstraint.weightx=1.0;
  teamMetaData.add(mTeamLabel,teamConstraint);
  teamConstraint.gridy=2;
  teamConstraint.gridx=0;
  teamConstraint.gridwidth=2;
  teamConstraint.weighty=0.1;
  teamConstraint.weightx=1.0;
  teamMetaData.add(mJailPanel,teamConstraint);
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.fill=GridBagConstraints.BOTH;
  constraints.gridy=0;
  constraints.weightx=1.0;
  constraints.weighty=0.5;
  constraints.gridwidth=2;
  constraints.insets=new Insets(10,10,10,10);
  add(teamMetaData,constraints);
}"
49862,"public TeamCreationPanel(SquareConfig squareConfig){
  super(false);
  setLayout(new GridBagLayout());
  int teamIDCounter=1;
  mTeamInfos=new ArrayList<>(2);
  mTeamNameFields=new JTextField[2];
  mTeamColorFields=new JLabel[2];
  TeamInfo white=new TeamInfo();
  white.color=Color.WHITE;
  white.teamName=""String_Node_Str"";
  white.teamId=teamIDCounter++;
  TeamInfo black=new TeamInfo();
  black.color=Color.BLACK;
  black.teamName=""String_Node_Str"";
  black.teamId=teamIDCounter;
  mTeamInfos.add(white);
  mTeamInfos.add(black);
  initComponents(squareConfig);
}","public TeamCreationPanel(SquareConfig squareConfig){
  super(false);
  setLayout(new GridBagLayout());
  int teamIDCounter=1;
  mTeamInfos=new ArrayList<>(2);
  mTeamNameFields=new JTextField[2];
  mTeamColorFields=new JTextField[2];
  TeamInfo white=new TeamInfo();
  white.color=Color.WHITE;
  white.teamName=""String_Node_Str"";
  white.teamId=teamIDCounter++;
  TeamInfo black=new TeamInfo();
  black.color=Color.BLACK;
  black.teamName=""String_Node_Str"";
  black.teamId=teamIDCounter;
  mTeamInfos.add(white);
  mTeamInfos.add(black);
  initComponents(squareConfig);
}"
49863,"private void createMouseListener(JLabel colorField,TeamInfo teamInfo){
  colorField.addMouseListener(new MouseListener(){
    @Override public void mouseClicked(    MouseEvent e){
      Color c=JColorChooser.showDialog(colorField,Messages.getString(""String_Node_Str""),colorField.getBackground());
      colorField.setBackground(c);
      teamInfo.color=c;
    }
    @Override public void mousePressed(    MouseEvent e){
    }
    @Override public void mouseReleased(    MouseEvent e){
    }
    @Override public void mouseEntered(    MouseEvent e){
    }
    @Override public void mouseExited(    MouseEvent e){
    }
  }
);
}","private void createMouseListener(JTextField colorField,TeamInfo teamInfo){
  colorField.addMouseListener(new MouseListener(){
    @Override public void mouseClicked(    MouseEvent e){
      Color c=JColorChooser.showDialog(colorField,Messages.getString(""String_Node_Str""),colorField.getBackground());
      colorField.setBackground(c);
      teamInfo.color=c;
    }
    @Override public void mousePressed(    MouseEvent e){
    }
    @Override public void mouseReleased(    MouseEvent e){
    }
    @Override public void mouseEntered(    MouseEvent e){
    }
    @Override public void mouseExited(    MouseEvent e){
    }
  }
);
}"
49864,"private void initComponents(SquareConfig squareConfig){
  mTeamInfos.forEach(teamInfo -> {
    int offsetTeamId=teamInfo.teamId - 1;
    GridBagConstraints constraints=new GridBagConstraints();
    JPanel teamPanel=new JPanel();
    teamPanel.setLayout(new GridBagLayout());
    teamPanel.setOpaque(false);
    constraints.gridy=0;
    constraints.insets=new Insets(0,0,10,0);
    constraints.gridwidth=2;
    constraints.anchor=GridBagConstraints.CENTER;
    constraints.fill=GridBagConstraints.BOTH;
    constraints.weightx=1.0;
    teamPanel.add(GuiUtility.createJLabel(Messages.getString(""String_Node_Str"") + teamInfo.teamId),constraints);
    teamInfo.label=new SquareJLabel(BoardCoordinate.at(1,teamInfo.teamId));
    squareConfig.configureSquare(teamInfo.label);
    constraints.gridy=1;
    constraints.weightx=0.5;
    constraints.weighty=1.0;
    constraints.insets=new Insets(0,0,10,0);
    teamPanel.add(teamInfo.label,constraints);
    constraints.gridy=2;
    constraints.gridwidth=1;
    constraints.weighty=0.0;
    constraints.weightx=0.0;
    constraints.insets=new Insets(0,0,10,10);
    teamPanel.add(GuiUtility.createJLabel(Messages.getString(""String_Node_Str"")),constraints);
    constraints.gridy=2;
    constraints.gridx=1;
    constraints.weightx=1.0;
    constraints.insets=new Insets(0,0,10,0);
    mTeamNameFields[offsetTeamId]=new JTextField(20);
    mTeamNameFields[offsetTeamId].setText(Messages.getString(""String_Node_Str""));
    mTeamNameFields[offsetTeamId].setPreferredSize(new Dimension(50,25));
    constraints.anchor=GridBagConstraints.WEST;
    teamPanel.add(mTeamNameFields[offsetTeamId],constraints);
    constraints.gridy=3;
    constraints.gridx=0;
    constraints.weightx=0.0;
    constraints.insets=new Insets(0,0,10,10);
    constraints.anchor=GridBagConstraints.CENTER;
    teamPanel.add(GuiUtility.createJLabel(Messages.getString(""String_Node_Str"")),constraints);
    constraints.gridy=3;
    constraints.gridx=1;
    constraints.weightx=1.0;
    constraints.insets=new Insets(0,0,10,0);
    constraints.anchor=GridBagConstraints.WEST;
    mTeamColorFields[offsetTeamId]=new JLabel();
    mTeamColorFields[offsetTeamId].setBackground(teamInfo.color);
    mTeamColorFields[offsetTeamId].setOpaque(true);
    createMouseListener(mTeamColorFields[offsetTeamId],teamInfo);
    teamPanel.add(mTeamColorFields[offsetTeamId],constraints);
    constraints.gridx=teamInfo.teamId;
    constraints.gridy=0;
    constraints.insets=new Insets(0,25,0,25);
    constraints.anchor=GridBagConstraints.CENTER;
    constraints.fill=GridBagConstraints.BOTH;
    add(teamPanel,constraints);
  }
);
}","private void initComponents(SquareConfig squareConfig){
  mTeamInfos.forEach(teamInfo -> {
    int offsetTeamId=teamInfo.teamId - 1;
    GridBagConstraints constraints=new GridBagConstraints();
    JPanel teamPanel=new JPanel();
    teamPanel.setLayout(new BoxLayout(teamPanel,BoxLayout.PAGE_AXIS));
    teamPanel.setOpaque(false);
    teamPanel.add(GuiUtility.createJLabel(Messages.getString(""String_Node_Str"") + ""String_Node_Str"" + teamInfo.teamId));
    teamInfo.label=new SquareJLabel(BoardCoordinate.at(1,teamInfo.teamId));
    squareConfig.configureSquare(teamInfo.label);
    teamInfo.label.setMaximumSize(new Dimension(100,100));
    teamPanel.add(teamInfo.label);
    JPanel teamNamePanel=new JPanel();
    teamNamePanel.setOpaque(false);
    teamNamePanel.setLayout(new BoxLayout(teamNamePanel,BoxLayout.LINE_AXIS));
    teamNamePanel.add(GuiUtility.createJLabel(Messages.getString(""String_Node_Str"")));
    Dimension minSize=new Dimension(5,25);
    Dimension prefSize=new Dimension(5,25);
    Dimension maxSize=new Dimension(Short.MAX_VALUE,25);
    teamNamePanel.add(new Box.Filler(minSize,prefSize,maxSize));
    teamNamePanel.add(Box.createHorizontalGlue());
    mTeamNameFields[offsetTeamId]=new JTextField(20);
    mTeamNameFields[offsetTeamId].setText(teamInfo.teamName);
    mTeamNameFields[offsetTeamId].setPreferredSize(new Dimension(50,25));
    teamNamePanel.add(mTeamNameFields[offsetTeamId]);
    teamPanel.add(new Box.Filler(new Dimension(5,10),new Dimension(5,10),new Dimension(Short.MAX_VALUE,10)));
    teamPanel.add(teamNamePanel);
    JPanel teamColorPanel=new JPanel();
    teamColorPanel.setOpaque(false);
    teamColorPanel.setLayout(new BoxLayout(teamColorPanel,BoxLayout.LINE_AXIS));
    teamColorPanel.add(GuiUtility.createJLabel(Messages.getString(""String_Node_Str"")));
    teamColorPanel.add(new Box.Filler(minSize,prefSize,maxSize));
    teamColorPanel.add(Box.createHorizontalGlue());
    mTeamColorFields[offsetTeamId]=new JTextField(20);
    mTeamColorFields[offsetTeamId].setBackground(teamInfo.color);
    mTeamColorFields[offsetTeamId].setEditable(false);
    createMouseListener(mTeamColorFields[offsetTeamId],teamInfo);
    teamColorPanel.add(mTeamColorFields[offsetTeamId]);
    teamPanel.add(new Box.Filler(new Dimension(5,10),new Dimension(5,10),new Dimension(Short.MAX_VALUE,10)));
    teamPanel.add(teamColorPanel);
    constraints.gridx=teamInfo.teamId;
    constraints.gridy=0;
    constraints.weightx=1.0;
    constraints.weighty=1.0;
    constraints.insets=new Insets(0,25,10,25);
    constraints.anchor=GridBagConstraints.CENTER;
    constraints.fill=GridBagConstraints.BOTH;
    add(teamPanel,constraints);
  }
);
}"
49865,"private void refreshNavigationButtonState(){
  mUndoButton.setVisible(mGame.canUndoMove());
  mUndoButton.setEnabled(mGame.canUndoMove());
  mForwardButton.setVisible(mGame.hasNextMove());
  mBackButton.setVisible(mGame.hasPreviousMove());
  mForwardButton.setEnabled(mGame.hasNextMove());
  mBackButton.setEnabled(mGame.hasPreviousMove());
}","private void refreshNavigationButtonState(){
  mUndoButton.setVisible(!mGame.hasPreviousMove() && !mGame.hasNextMove());
  mUndoButton.setEnabled(mGame.canUndoMove());
  mForwardButton.setVisible(mGame.hasPreviousMove() || mGame.hasNextMove());
  mBackButton.setVisible(mGame.hasPreviousMove() || mGame.hasNextMove());
  mForwardButton.setEnabled(mGame.hasNextMove());
  mBackButton.setEnabled(mGame.hasPreviousMove());
}"
49866,"private void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  Board[] boards=mGame.getBoards();
  IntStream.range(0,boards.length).forEach(boardIndex -> {
    mGameBoards[boardIndex]=new BoardPanel(boards[boardIndex].getBoardSize(),mSquareConfig,coordinate -> {
      Piece piece=mGame.getPiece(boardIndex,coordinate);
      if (piece != null && piece.getTeamId() == mGame.getTurnKeeper().getActiveTeamId()) {
        return mGame.getMovesFrom(boardIndex,coordinate);
      }
 else {
        return Collections.emptySet();
      }
    }
);
    constraints.gridx=boardIndex;
    constraints.weightx=1.0;
    constraints.weighty=1.0;
    constraints.gridheight=2;
    constraints.fill=GridBagConstraints.BOTH;
    constraints.insets=new Insets(10,0,0,0);
    add(mGameBoards[boardIndex],constraints);
  }
);
  Stream.of(mGame.getTeams()).forEach(team -> mTeamStatusPanels.add(new TeamStatusPanel(team)));
  mTeamStatusPanels.forEach(panel -> mTabbedPane.addTab(panel.getName(),panel));
  constraints.gridx=boards.length * 2;
  constraints.weightx=0.3;
  constraints.gridheight=1;
  constraints.weighty=1.0;
  constraints.insets=new Insets(0,25,0,10);
  add(mTabbedPane,constraints);
  mUndoButton.addActionListener(event -> {
    mGame.undoMove();
    refresh();
  }
);
  mForwardButton.addActionListener(event -> {
    mGame.nextMove();
    refresh();
  }
);
  mBackButton.addActionListener(event -> {
    mGame.previousMove();
    refresh();
  }
);
  GridBagConstraints gbc=new GridBagConstraints();
  JPanel buttonPanel=new JPanel();
  buttonPanel.setLayout(new GridBagLayout());
  buttonPanel.setOpaque(false);
  gbc.gridy=0;
  gbc.gridx=0;
  gbc.gridwidth=2;
  gbc.weightx=1.0;
  gbc.fill=GridBagConstraints.BOTH;
  buttonPanel.add(mUndoButton,gbc);
  gbc.gridy=1;
  gbc.gridx=0;
  gbc.gridwidth=1;
  buttonPanel.add(mBackButton,gbc);
  gbc.gridx=1;
  buttonPanel.add(mForwardButton,gbc);
  constraints.gridy=1;
  constraints.gridx=boards.length * 2;
  constraints.weighty=1.0;
  add(buttonPanel,constraints);
  refresh();
}","private void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  Board[] boards=mGame.getBoards();
  IntStream.range(0,boards.length).forEach(boardIndex -> {
    mGameBoards[boardIndex]=new BoardPanel(boards[boardIndex].getBoardSize(),mSquareConfig,coordinate -> {
      Piece piece=mGame.getPiece(boardIndex,coordinate);
      if (piece != null && piece.getTeamId() == mGame.getTurnKeeper().getActiveTeamId()) {
        return mGame.getMovesFrom(boardIndex,coordinate);
      }
 else {
        return Collections.emptySet();
      }
    }
);
    constraints.gridx=boardIndex;
    constraints.weightx=1.0;
    constraints.weighty=1.0;
    constraints.gridheight=2;
    constraints.fill=GridBagConstraints.BOTH;
    constraints.insets=new Insets(10,0,0,0);
    add(mGameBoards[boardIndex],constraints);
  }
);
  Stream.of(mGame.getTeams()).forEach(team -> mTeamStatusPanels.add(new TeamStatusPanel(team)));
  mTeamStatusPanels.forEach(panel -> mTabbedPane.addTab(panel.getName(),panel));
  constraints.gridx=boards.length * 2;
  constraints.weightx=0.3;
  constraints.gridheight=1;
  constraints.weighty=1.0;
  constraints.insets=new Insets(0,25,0,10);
  add(mTabbedPane,constraints);
  mUndoButton.addActionListener(event -> {
    mGame.undoMove();
    refresh();
  }
);
  mForwardButton.addActionListener(event -> {
    mGame.nextMove();
    refresh();
  }
);
  mBackButton.addActionListener(event -> {
    mGame.previousMove();
    refresh();
  }
);
  GridBagConstraints gbc=new GridBagConstraints();
  JPanel buttonPanel=new JPanel();
  buttonPanel.setLayout(new GridBagLayout());
  buttonPanel.setOpaque(false);
  gbc.gridy=0;
  gbc.gridx=0;
  gbc.gridwidth=2;
  gbc.weightx=1.0;
  gbc.fill=GridBagConstraints.BOTH;
  buttonPanel.add(mUndoButton,gbc);
  gbc.gridy=1;
  gbc.gridx=0;
  gbc.gridwidth=1;
  buttonPanel.add(mBackButton,gbc);
  gbc.gridx=1;
  buttonPanel.add(mForwardButton,gbc);
  constraints.gridy=1;
  constraints.gridx=boards.length * 2;
  constraints.weighty=0.2;
  add(buttonPanel,constraints);
  refresh();
}"
49867,"public static void playMove(MoveBuilder moveBuilder){
  if (moveBuilder.needsPromotion()) {
    createPromotionPopup(moveBuilder);
  }
 else {
    mGame.executeMove(moveBuilder.build());
    changeTurns(mGame.getResult());
    boardRefresh();
  }
}","public static void playMove(MoveBuilder moveBuilder){
  if (moveBuilder.needsPromotion() && !moveBuilder.hasPromotionType()) {
    createPromotionPopup(moveBuilder);
  }
 else {
    mGame.executeMove(moveBuilder.build());
    changeTurns(mGame.getResult());
    boardRefresh();
  }
}"
49868,"private List<BoardCoordinate> getVerticalPathSpaces(int maxSteps){
  int least=Math.min(mOrigin.y,mDestination.y);
  int most=Math.max(mOrigin.y,mDestination.y);
  List<BoardCoordinate> spaces=new ArrayList<>();
  for (int y=least + 1; y <= most; y++) {
    if (Math.abs(mOrigin.y - y) <= maxSteps) {
      spaces.add(BoardCoordinate.at(mOrigin.x,y));
    }
  }
  spaces.remove(mOrigin);
  return spaces;
}","private List<BoardCoordinate> getVerticalPathSpaces(int maxSteps){
  int least=Math.min(mOrigin.y,mDestination.y);
  int most=Math.max(mOrigin.y,mDestination.y);
  List<BoardCoordinate> spaces=new ArrayList<>();
  for (int y=least; y <= most; y++) {
    if (Math.abs(mOrigin.y - y) <= maxSteps) {
      spaces.add(BoardCoordinate.at(mOrigin.x,y));
    }
  }
  spaces.remove(mOrigin);
  int direction=(int)Math.signum(mDestination.y - mOrigin.y);
  if (direction < 0) {
    spaces=Lists.reverse(spaces);
  }
  return spaces;
}"
49869,"private List<BoardCoordinate> getHorizontalPathSpaces(int maxSteps){
  int least=Math.min(mOrigin.x,mDestination.x);
  int most=Math.max(mOrigin.x,mDestination.x);
  List<BoardCoordinate> spaces=new ArrayList<>();
  for (int x=least; x <= most; x++) {
    if (Math.abs(mOrigin.x - x) <= maxSteps) {
      spaces.add(BoardCoordinate.at(x,mOrigin.y));
    }
  }
  spaces.remove(mOrigin);
  return spaces;
}","private List<BoardCoordinate> getHorizontalPathSpaces(int maxSteps){
  int least=Math.min(mOrigin.x,mDestination.x);
  int most=Math.max(mOrigin.x,mDestination.x);
  List<BoardCoordinate> spaces=new ArrayList<>();
  for (int x=least; x <= most; x++) {
    if (Math.abs(mOrigin.x - x) <= maxSteps) {
      spaces.add(BoardCoordinate.at(x,mOrigin.y));
    }
  }
  spaces.remove(mOrigin);
  int direction=(int)Math.signum(mDestination.x - mOrigin.x);
  if (direction < 0) {
    spaces=Lists.reverse(spaces);
  }
  return spaces;
}"
49870,"@Test public void return7Spaces(){
  PathMaker target=new PathMaker(BoardCoordinate.at(1,1),BoardCoordinate.at(8,1));
  assertEquals(7,target.getPathToDestination(PieceType.UNLIMITED).size());
}","@Test public void return7Spaces(){
  PathMaker target=new PathMaker(BoardCoordinate.at(1,1),BoardCoordinate.at(8,1));
  assertEquals(7,target.getPathToDestination().size());
}"
49871,"@Test public void returnEmptyListFor1_1And2_3(){
  PathMaker target=new PathMaker(BoardCoordinate.at(1,1),BoardCoordinate.at(2,3));
  assertTrue(target.getPathToDestination(PieceType.UNLIMITED).isEmpty());
}","@Test public void returnEmptyListFor1_1And2_3(){
  PathMaker target=new PathMaker(BoardCoordinate.at(1,1),BoardCoordinate.at(2,3));
  assertTrue(target.getPathToDestination().isEmpty());
}"
49872,"@Test public void notReturn1_1Given1_1And8_1(){
  PathMaker target=new PathMaker(BoardCoordinate.at(1,1),BoardCoordinate.at(8,1));
  List<BoardCoordinate> moves=target.getPathToDestination(PieceType.UNLIMITED);
  assertFalse(moves.contains(BoardCoordinate.at(1,1)));
}","@Test public void notReturn1_1Given1_1And8_1(){
  PathMaker target=new PathMaker(BoardCoordinate.at(1,1),BoardCoordinate.at(8,1));
  List<BoardCoordinate> moves=target.getPathToDestination();
  assertFalse(moves.contains(BoardCoordinate.at(1,1)));
}"
49873,"public Set<BoardCoordinate> getMovesFrom(BoardCoordinate origin){
  Piece piece=getPiece(origin);
  Set<BoardCoordinate> allPossibleMoves=piece.getMovesFrom(origin,mBoardSize);
  Set<BoardCoordinate> capturingMoves=piece.getCapturingMovesFrom(origin,mBoardSize);
  Set<BoardCoordinate> validMoves=Sets.newHashSetWithExpectedSize(allPossibleMoves.size());
  for (  BoardCoordinate move : allPossibleMoves) {
    if (!isBlocked(origin,move) && !doesFriendlyPieceExistAt(origin,move)) {
      validMoves.add(move);
    }
  }
  for (  BoardCoordinate move : capturingMoves) {
    if (!isBlocked(origin,move) && doesPieceExistAt(move) && !doesFriendlyPieceExistAt(origin,move)) {
      validMoves.add(move);
    }
  }
  return validMoves;
}","public Set<BoardCoordinate> getMovesFrom(BoardCoordinate origin){
  Piece piece=getPiece(origin);
  Set<BoardCoordinate> allPossibleMoves=piece.getMovesFrom(origin,mBoardSize);
  Set<BoardCoordinate> capturingMoves=piece.getCapturingMovesFrom(origin,mBoardSize);
  Set<BoardCoordinate> validMoves=Sets.newHashSetWithExpectedSize(allPossibleMoves.size());
  for (  BoardCoordinate move : allPossibleMoves) {
    if (!isBlocked(origin,move) && !doesPieceExistAt(move)) {
      validMoves.add(move);
    }
  }
  for (  BoardCoordinate move : capturingMoves) {
    if (!isBlocked(origin,move) && doesPieceExistAt(move) && !doesFriendlyPieceExistAt(origin,move)) {
      validMoves.add(move);
    }
  }
  return validMoves;
}"
49874,"public static PieceType getKnightPieceType(){
  Set<TwoHopMovement> twoHopMovements=Sets.newHashSet(TwoHopMovement.with(2,1));
  return new PieceType(""String_Node_Str"",null,null,twoHopMovements);
}","public static PieceType getKnightPieceType(){
  Set<TwoHopMovement> twoHopMovements=Sets.newHashSet(TwoHopMovement.with(2,1));
  return new PieceType(""String_Node_Str"",null,twoHopMovements);
}"
49875,"public static PieceType getRookPieceType(){
  Map<Direction,Integer> movements=Maps.newHashMap();
  for (  Direction direction : Direction.ADJACENT_DIRECTIONS) {
    movements.put(direction,UNLIMITED);
  }
  return new PieceType(""String_Node_Str"",movements,null,null);
}","public static PieceType getRookPieceType(){
  Map<Direction,Integer> movements=Maps.newHashMap();
  for (  Direction direction : Direction.ADJACENT_DIRECTIONS) {
    movements.put(direction,UNLIMITED);
  }
  return new PieceType(""String_Node_Str"",movements,null);
}"
49876,"public static PieceType getQueenPieceType(){
  Map<Direction,Integer> movements=Maps.newHashMap();
  for (  Direction direction : Direction.values()) {
    movements.put(direction,UNLIMITED);
  }
  return new PieceType(""String_Node_Str"",movements,null,null);
}","public static PieceType getQueenPieceType(){
  Map<Direction,Integer> movements=Maps.newHashMap();
  for (  Direction direction : Direction.values()) {
    movements.put(direction,UNLIMITED);
  }
  return new PieceType(""String_Node_Str"",movements,null);
}"
49877,"public static PieceType getBishopPieceType(){
  Map<Direction,Integer> movements=Maps.newHashMap();
  for (  Direction direction : Direction.DIAGONAL_DIRECTIONS) {
    movements.put(direction,UNLIMITED);
  }
  return new PieceType(""String_Node_Str"",movements,null,null);
}","public static PieceType getBishopPieceType(){
  Map<Direction,Integer> movements=Maps.newHashMap();
  for (  Direction direction : Direction.DIAGONAL_DIRECTIONS) {
    movements.put(direction,UNLIMITED);
  }
  return new PieceType(""String_Node_Str"",movements,null);
}"
49878,"public Set<BoardCoordinate> getCapturingMovesFrom(@NotNull BoardCoordinate startLocation,@NotNull BoardSize boardSize){
  Set<BoardCoordinate> moves=new HashSet<>();
  for (  Direction direction : mCapturingMovements.keySet()) {
    PathMaker pathMaker=new PathMaker(startLocation,direction.getFurthestPoint(startLocation,boardSize));
    moves.addAll(pathMaker.getPathToDestination(mCapturingMovements.get(direction)));
  }
  return moves;
}","public Set<BoardCoordinate> getCapturingMovesFrom(@NotNull BoardCoordinate startLocation,@NotNull BoardSize boardSize){
  return getMovesFromImpl(startLocation,boardSize,mCapturingMovements);
}"
49879,"public Set<BoardCoordinate> getMovesFrom(@NotNull BoardCoordinate startLocation,@NotNull BoardSize boardSize,int moveCount){
  Set<BoardCoordinate> moves=new HashSet<>();
  if (moveCount == 0) {
    if (getName().equals(""String_Node_Str"")) {
      moves.add(BoardCoordinate.at(startLocation.x,startLocation.y + 2));
    }
 else     if (getName().equals(""String_Node_Str"")) {
      moves.add(BoardCoordinate.at(startLocation.x,startLocation.y - 2));
    }
  }
  for (  Direction direction : mMovements.keySet()) {
    PathMaker pathMaker=new PathMaker(startLocation,direction.getFurthestPoint(startLocation,boardSize));
    moves.addAll(pathMaker.getPathToDestination(mMovements.get(direction)));
  }
  for (  TwoHopMovement twoHopMovement : mTwoHopMovements) {
    Set<BoardCoordinate> allMoves=new HashSet<>();
    for (int quadrant=1; quadrant <= 4; quadrant++) {
      allMoves.addAll(getQuadrantMoves(startLocation,twoHopMovement,quadrant));
    }
    for (    BoardCoordinate move : allMoves) {
      if (move.isValid(boardSize)) {
        moves.add(move);
      }
    }
  }
  return moves;
}","public Set<BoardCoordinate> getMovesFrom(@NotNull BoardCoordinate startLocation,@NotNull BoardSize boardSize,int moveCount){
  Set<BoardCoordinate> moves=getMovesFromImpl(startLocation,boardSize,mMovements);
  if (moveCount == 0) {
    if (getName().equals(""String_Node_Str"")) {
      moves.add(BoardCoordinate.at(startLocation.x,startLocation.y + 2));
    }
 else     if (getName().equals(""String_Node_Str"")) {
      moves.add(BoardCoordinate.at(startLocation.x,startLocation.y - 2));
    }
  }
  return moves;
}"
49880,"public static PieceType getKingPieceType(){
  Map<Direction,Integer> movements=Maps.newHashMap();
  for (  Direction direction : Direction.values()) {
    movements.put(direction,1);
  }
  return new PieceType(""String_Node_Str"",movements,null,null);
}","public static PieceType getKingPieceType(){
  Map<Direction,Integer> movements=Maps.newHashMap();
  for (  Direction direction : Direction.values()) {
    movements.put(direction,1);
  }
  return new PieceType(""String_Node_Str"",movements,null);
}"
49881,"private void createGrid(BoardSize boardSize){
  for (int y=boardSize.height; y > 0; y--) {
    JLabel label=GuiUtility.createJLabel(""String_Node_Str"" + y);
    label.setHorizontalAlignment(SwingConstants.CENTER);
    add(label);
    for (int x=boardSize.width; x > 0; x--) {
      SquareJLabel square=new SquareJLabel(BoardCoordinate.at(x,y),true,48);
      square.addMouseMotionListener(new MotionAdapter(mGlassPane));
      square.addMouseListener(new SquareListener(square,mDropManager,mGlassPane));
      add(square);
      mSquareLabels[x - 1][y - 1]=square;
      square.refresh();
    }
  }
  for (int x=0; x <= boardSize.width; x++) {
    if (x != 0) {
      JLabel label=GuiUtility.createJLabel(""String_Node_Str"" + (char)(x - 1 + 'A'));
      label.setHorizontalAlignment(SwingConstants.CENTER);
      add(label);
    }
 else {
      add(GuiUtility.createJLabel(""String_Node_Str""));
    }
  }
}","private void createGrid(BoardSize boardSize){
  for (int y=boardSize.height; y > 0; y--) {
    JLabel label=GuiUtility.createJLabel(""String_Node_Str"" + y);
    label.setHorizontalAlignment(SwingConstants.CENTER);
    add(label);
    for (int x=1; x <= boardSize.width; x++) {
      SquareJLabel square=new SquareJLabel(BoardCoordinate.at(x,y),true,48);
      square.addMouseMotionListener(new MotionAdapter(mGlassPane));
      square.addMouseListener(new SquareListener(square,mDropManager,mGlassPane));
      add(square);
      mSquareLabels[x - 1][y - 1]=square;
      square.refresh();
    }
  }
  for (int x=0; x <= boardSize.width; x++) {
    if (x != 0) {
      JLabel label=GuiUtility.createJLabel(""String_Node_Str"" + (char)(x - 1 + 'A'));
      label.setHorizontalAlignment(SwingConstants.CENTER);
      add(label);
    }
 else {
      add(GuiUtility.createJLabel(""String_Node_Str""));
    }
  }
}"
49882,"private List<ChessCoordinate> getVerticalPathSpaces(int maxSteps){
  int least=Math.min(mOrigin.y,mDestination.y);
  int most=Math.max(mOrigin.y,mDestination.y);
  List<ChessCoordinate> spaces=new ArrayList<>();
  for (int y=least + 1, steps=1; y <= most && steps <= maxSteps; y++, steps++) {
    spaces.add(ChessCoordinate.at(mOrigin.x,y));
  }
  return spaces;
}","private List<ChessCoordinate> getVerticalPathSpaces(int maxSteps){
  int least=Math.min(mOrigin.y,mDestination.y);
  int most=Math.max(mOrigin.y,mDestination.y);
  List<ChessCoordinate> spaces=new ArrayList<>();
  for (int y=least + 1; y <= most; y++) {
    if (Math.abs(mOrigin.y - y) <= maxSteps) {
      spaces.add(ChessCoordinate.at(mOrigin.x,y));
    }
  }
  spaces.remove(mOrigin);
  return spaces;
}"
49883,"private List<ChessCoordinate> getHorizontalPathSpaces(int maxSteps){
  int least=Math.min(mOrigin.x,mDestination.x);
  int most=Math.max(mOrigin.x,mDestination.x);
  List<ChessCoordinate> spaces=new ArrayList<>();
  for (int x=least + 1, steps=1; x <= most && steps <= maxSteps; x++, steps++) {
    spaces.add(ChessCoordinate.at(x,mOrigin.y));
  }
  return spaces;
}","private List<ChessCoordinate> getHorizontalPathSpaces(int maxSteps){
  int least=Math.min(mOrigin.x,mDestination.x);
  int most=Math.max(mOrigin.x,mDestination.x);
  List<ChessCoordinate> spaces=new ArrayList<>();
  for (int x=least; x <= most; x++) {
    if (Math.abs(mOrigin.x - x) <= maxSteps) {
      spaces.add(ChessCoordinate.at(x,mOrigin.y));
    }
  }
  spaces.remove(mOrigin);
  return spaces;
}"
49884,"public void endOfGame(Result result){
  PlayNetGamePanel.mIsRunning=false;
  if (mGame.getHistory().size() != 0) {
    PlayNetGamePanel.mNetMove=mGame.moveToFakeMove(mGame.getHistory().get(mGame.getHistory().size() - 1));
  }
 else   if (result != Result.DRAW) {
    JOptionPane.showMessageDialog(null,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
    PlayNetGamePanel.mIsRunning=false;
    Driver.getInstance().revertToMainPanel();
    Driver.getInstance().setFileMenuVisibility(true);
    return;
  }
  Object[] options=new String[]{Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str"")};
  mOptionsMenu.setVisible(false);
switch (JOptionPane.showOptionDialog(Driver.getInstance(),result.getGUIText(),result.winText(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0])) {
case JOptionPane.YES_OPTION:
    m_preference=PreferenceUtility.getPreference();
  if (!m_preference.isPathSet()) {
    JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str"") + AppConstants.APP_NAME + Messages.getString(""String_Node_Str"")+ Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
    JFileChooser fileChooser=new JFileChooser();
    fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
    int returnVal=fileChooser.showOpenDialog(Driver.getInstance());
    if (returnVal == JFileChooser.APPROVE_OPTION)     m_preference.setSaveLocation(fileChooser.getSelectedFile().getAbsolutePath());
 else     m_preference.setSaveLocation(FileUtility.getDefaultCompletedLocation());
  }
String saveFileName=JOptionPane.showInputDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
getGame().saveGame(saveFileName,getGame().isClassicChess());
mGame.setBlackMove(false);
Driver.getInstance().setFileMenuVisibility(true);
Driver.getInstance().revertToMainPanel();
break;
case JOptionPane.NO_OPTION:
mGame.setBlackMove(false);
Driver.getInstance().setUpNewGame();
break;
case JOptionPane.CANCEL_OPTION:
mGame.setBlackMove(false);
System.exit(0);
break;
}
}","public void endOfGame(Result result){
  PlayNetGamePanel.mIsRunning=false;
  if (mGame.getHistory().size() != 0) {
    PlayNetGamePanel.mNetMove=mGame.moveToFakeMove(mGame.getHistory().get(mGame.getHistory().size() - 1));
  }
 else   if (result != Result.DRAW) {
    JOptionPane.showMessageDialog(null,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
    PlayNetGamePanel.mIsRunning=false;
    Driver.getInstance().revertToMainPanel();
    Driver.getInstance().setFileMenuVisibility(true);
    return;
  }
  Object[] options=new String[]{Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str"")};
  mOptionsMenu.setVisible(false);
switch (JOptionPane.showOptionDialog(Driver.getInstance(),result.getGUIText(),result.winText(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0])) {
case JOptionPane.YES_OPTION:
    m_preference=PreferenceUtility.getPreference();
  if (!m_preference.isPathSet()) {
    JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str"") + AppConstants.APP_NAME + Messages.getString(""String_Node_Str"")+ Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
    JFileChooser fileChooser=new JFileChooser();
    fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
    int returnVal=fileChooser.showOpenDialog(Driver.getInstance());
    if (returnVal == JFileChooser.APPROVE_OPTION)     m_preference.setSaveLocation(fileChooser.getSelectedFile().getAbsolutePath());
 else     m_preference.setSaveLocation(FileUtility.getDefaultCompletedLocation());
  }
String saveFileName=JOptionPane.showInputDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
getGame().saveGame(saveFileName,getGame().isClassicChess(),false);
mGame.setBlackMove(false);
Driver.getInstance().setFileMenuVisibility(true);
Driver.getInstance().revertToMainPanel();
break;
case JOptionPane.NO_OPTION:
mGame.setBlackMove(false);
Driver.getInstance().setUpNewGame();
break;
case JOptionPane.CANCEL_OPTION:
mGame.setBlackMove(false);
System.exit(0);
break;
}
}"
49885,"public void saveGame(){
  String fileName=JOptionPane.showInputDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
  if (fileName == null)   return;
  getGame().saveGame(fileName,false);
}","public void saveGame(){
  String fileName=JOptionPane.showInputDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
  if (fileName == null)   return;
  getGame().saveGame(fileName,false,true);
}"
49886,"public void boardRefresh(Board[] boards){
  refreshSquares(boards);
  Piece objectivePiece=getGame().isBlackMove() ? getGame().getBlackRules().objectivePiece(true) : getGame().getWhiteRules().objectivePiece(false);
  if (objectivePiece != null && objectivePiece.isInCheck()) {
    mInCheckLabel.setVisible(true);
    if (getGame().getBlackRules().objectivePiece(true).isInCheck())     mInCheckLabel.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
 else     mInCheckLabel.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
    for (    Piece piece : getGame().getThreats(objectivePiece))     piece.getSquare().setColor(Color.red);
  }
 else {
    mInCheckLabel.setVisible(false);
  }
  int index=0;
  Piece[] blackCapturedPieces=getGame().getCapturedPieces(true);
  for (int i=mWhiteCapturesJail.getMaxRow(); i >= 1; i--) {
    for (int j=1; j <= mWhiteCapturesJail.getMaxCol(); j++) {
      if (blackCapturedPieces != null && index < blackCapturedPieces.length) {
        mWhiteCapturesJail.getSquare(i,j).setPiece(blackCapturedPieces[index]);
        index++;
      }
      mWhiteCapturesJail.getSquare(i,j).refreshJail();
    }
  }
  index=0;
  Piece[] whiteCapturedPieces=getGame().getCapturedPieces(false);
  for (int i=mBlackCapturesJail.getMaxRow(); i >= 1; i--) {
    for (int j=1; j <= mBlackCapturesJail.getMaxCol(); j++) {
      if (whiteCapturedPieces != null && index < whiteCapturedPieces.length) {
        mBlackCapturesJail.getSquare(i,j).setPiece(whiteCapturedPieces[index]);
        index++;
      }
      mBlackCapturesJail.getSquare(i,j).refreshJail();
    }
  }
  mWhiteLabel.setBackground(getGame().isBlackMove() ? null : Square.HIGHLIGHT_COLOR);
  mWhiteLabel.setForeground(getGame().isBlackMove() ? Color.black : Color.white);
  mBlackLabel.setBackground(getGame().isBlackMove() ? Square.HIGHLIGHT_COLOR : null);
  mBlackLabel.setForeground(getGame().isBlackMove() ? Color.white : Color.black);
}","public void boardRefresh(Board[] boards){
  refreshSquares(boards);
  Piece objectivePiece=getGame().isBlackMove() ? getGame().getBlackRules().objectivePiece(true) : getGame().getWhiteRules().objectivePiece(false);
  if (objectivePiece != null && objectivePiece.isInCheck()) {
    mInCheckLabel.setVisible(true);
    if (getGame().getBlackRules().objectivePiece(true).isInCheck())     mInCheckLabel.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
 else     mInCheckLabel.setBorder(BorderFactory.createTitledBorder(Messages.getString(""String_Node_Str"")));
    for (    Piece piece : getGame().getThreats(objectivePiece))     piece.getSquare().setColor(Color.red);
  }
 else {
    mInCheckLabel.setVisible(false);
  }
  int index=0;
  Piece[] blackCapturedPieces=getGame().getCapturedPieces(true);
  for (int i=mWhiteCapturesJail.getMaxRow(); i >= 1; i--) {
    for (int j=1; j <= mWhiteCapturesJail.getMaxCol(); j++) {
      if (blackCapturedPieces != null && index < blackCapturedPieces.length) {
        mWhiteCapturesJail.getSquare(i,j).setPiece(blackCapturedPieces[index]);
        index++;
      }
 else {
        mWhiteCapturesJail.getSquare(i,j).setPiece(null);
      }
      mWhiteCapturesJail.getSquare(i,j).refreshJail();
    }
  }
  index=0;
  Piece[] whiteCapturedPieces=getGame().getCapturedPieces(false);
  for (int i=mBlackCapturesJail.getMaxRow(); i >= 1; i--) {
    for (int j=1; j <= mBlackCapturesJail.getMaxCol(); j++) {
      if (whiteCapturedPieces != null && index < whiteCapturedPieces.length) {
        mBlackCapturesJail.getSquare(i,j).setPiece(whiteCapturedPieces[index]);
        index++;
      }
 else {
        mWhiteCapturesJail.getSquare(i,j).setPiece(null);
      }
      mBlackCapturesJail.getSquare(i,j).refreshJail();
    }
  }
  mWhiteLabel.setBackground(getGame().isBlackMove() ? null : Square.HIGHLIGHT_COLOR);
  mWhiteLabel.setForeground(getGame().isBlackMove() ? Color.black : Color.white);
  mBlackLabel.setBackground(getGame().isBlackMove() ? Square.HIGHLIGHT_COLOR : null);
  mBlackLabel.setForeground(getGame().isBlackMove() ? Color.white : Color.black);
}"
49887,"public WatchGamePanel(File acnFile){
  if (acnFile == null)   return;
  Game game=null;
  try {
    game=AlgebraicConverter.convert(Builder.newGame(Messages.getString(""String_Node_Str"")),acnFile);
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
  if (game != null)   setGame(game);
 else   game=getGame();
  WatchGamePanel.mWhiteTimer=ChessTimer.createTimer(TimerTypes.NO_TIMER,null,0,0,false);
  WatchGamePanel.mBlackTimer=ChessTimer.createTimer(TimerTypes.NO_TIMER,null,0,0,true);
  mHistory=new Move[game.getHistory().size()];
  game.getHistory().toArray(mHistory);
  try {
    initComponents();
    mHistoryIndex=mHistory.length - 1;
    while (mHistoryIndex >= 0) {
      mHistory[mHistoryIndex].undo();
      mHistoryIndex--;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  boardRefresh(game.getBoards());
}","public WatchGamePanel(File saveFile){
  if (saveFile == null)   return;
  Game game=null;
  try {
    game=AlgebraicConverter.convert(Builder.newGame(Messages.getString(""String_Node_Str"")),saveFile);
  }
 catch (  Exception e1) {
    try {
      ObjectInputStream in=new ObjectInputStream(new FileInputStream(saveFile));
      game=(Game)in.readObject();
      game.setIsPlayback(true);
      game.setBlackMove(false);
      in.close();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (game != null)   setGame(game);
 else   game=getGame();
  WatchGamePanel.mWhiteTimer=ChessTimer.createTimer(TimerTypes.NO_TIMER,null,0,0,false);
  WatchGamePanel.mBlackTimer=ChessTimer.createTimer(TimerTypes.NO_TIMER,null,0,0,true);
  mHistory=new Move[game.getHistory().size()];
  game.getHistory().toArray(mHistory);
  try {
    initComponents();
    mHistoryIndex=mHistory.length - 1;
    while (mHistoryIndex >= 0) {
      mHistory[mHistoryIndex].undo();
      mHistoryIndex--;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  boardRefresh(game.getBoards());
}"
49888,"public void saveGame(){
  String fileName=JOptionPane.showInputDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
  if (fileName == null)   return;
  getGame().saveGame(fileName,false);
}","@Override public void saveGame(){
}"
49889,"/** 
 * Revert to the previous turn
 */
public void prevTurn(){
  setBlackMove(getWhiteRules().prevTurn());
}","/** 
 * Revert to the previous turn
 */
public void prevTurn(){
  setBlackMove(getWhiteRules().prevTurn(mIsPlayback));
}"
49890,"/** 
 * Saves game's state to file.
 * @param dirName The directory in which to save the game
 * @param fileName The name for the game file
 * @param ACN Whether the game should be saved in ACN
 */
public void saveGame(String fileName,boolean ACN){
  try {
    if (ACN) {
      FileOutputStream f_out=new FileOutputStream(FileUtility.getCompletedGamesFile(fileName));
      ObjectOutputStream out=new ObjectOutputStream(f_out);
      out.writeObject(this);
      out.close();
      f_out.close();
      AlgebraicConverter.convert(getHistory(),(fileName));
    }
 else {
      FileOutputStream f_out=new FileOutputStream(FileUtility.getGamesInProgressFile(fileName));
      ObjectOutputStream out=new ObjectOutputStream(f_out);
      out.writeObject(this);
      out.close();
      f_out.close();
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Saves game's state to file.
 * @param dirName The directory in which to save the game
 * @param fileName The name for the game file
 * @param ACN Whether the game should be saved in ACN
 * @param inProgress 
 */
public void saveGame(String fileName,boolean ACN,boolean inProgress){
  try {
    if (!inProgress) {
      FileOutputStream f_out=new FileOutputStream(FileUtility.getCompletedGamesFile(fileName));
      ObjectOutputStream out=new ObjectOutputStream(f_out);
      out.writeObject(this);
      out.close();
      f_out.close();
      if (ACN)       AlgebraicConverter.convert(getHistory(),fileName);
    }
 else {
      FileOutputStream f_out=new FileOutputStream(FileUtility.getGamesInProgressFile(fileName));
      ObjectOutputStream out=new ObjectOutputStream(f_out);
      out.writeObject(this);
      out.close();
      f_out.close();
    }
  }
 catch (  Exception e) {
  }
}"
49891,"public CustomSetupPanel(String variantName){
  mDropManager=new DropManager();
  mGlobalGlassPane=new GlassPane();
  mGlobalGlassPane.setOpaque(false);
  Driver.getInstance().setGlassPane(mGlobalGlassPane);
  m_motionAdapter=new MotionAdapter(mGlobalGlassPane);
  Game gameToEdit=null;
  if (variantName != null) {
    gameToEdit=Builder.newGame(variantName);
    mBuilder=new Builder(variantName);
    mWhiteTeam=gameToEdit.getWhiteTeam();
    mBlackTeam=gameToEdit.getBlackTeam();
    mWhiteRules=gameToEdit.getWhiteRules();
    mBlackRules=gameToEdit.getBlackRules();
    mWhitePromotionMap=gameToEdit.getWhitePromotionMap();
    if (mWhitePromotionMap == null)     mWhitePromotionMap=Maps.newHashMap();
    mBlackPromotionMap=gameToEdit.getBlackPromotionMap();
    if (mBlackPromotionMap == null)     mBlackPromotionMap=Maps.newHashMap();
    mBoardPanels=new JPanel[gameToEdit.getBoards().length];
    for (int i=0; i < mBoardPanels.length; i++)     mBoardPanels[i]=new JPanel();
  }
 else {
    mBuilder=new Builder(Messages.getString(""String_Node_Str""));
    mWhiteTeam=Lists.newArrayList();
    mBlackTeam=Lists.newArrayList();
    mWhiteRules=new Rules(false);
    mBlackRules=new Rules(true);
    mWhitePromotionMap=Maps.newHashMap();
    mBlackPromotionMap=Maps.newHashMap();
    mBoardPanels=new JPanel[]{new JPanel(),new JPanel()};
  }
  Board board=new Board(2,1,false);
  mPieceDisplaySquares[WHITE_INDEX]=board.getSquare(1,1);
  mPieceDisplaySquares[BLACK_INDEX]=board.getSquare(2,1);
  mOptionsFrame=new JFrame();
  mOptionsFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
  mScrollPane.setPreferredSize(new Dimension(200,200));
  initGUIComponents(gameToEdit,variantName);
}","public CustomSetupPanel(String variantName){
  mDropManager=new DropManager();
  mGlobalGlassPane=new GlassPane();
  mGlobalGlassPane.setOpaque(false);
  Driver.getInstance().setGlassPane(mGlobalGlassPane);
  m_motionAdapter=new MotionAdapter(mGlobalGlassPane);
  Game gameToEdit=null;
  if (variantName != null) {
    gameToEdit=Builder.newGame(variantName);
    mWhiteTeam=gameToEdit.getWhiteTeam();
    mBlackTeam=gameToEdit.getBlackTeam();
    mWhiteRules=gameToEdit.getWhiteRules();
    mBlackRules=gameToEdit.getBlackRules();
    mWhitePromotionMap=gameToEdit.getWhitePromotionMap();
    if (mWhitePromotionMap == null)     mWhitePromotionMap=Maps.newHashMap();
    mBlackPromotionMap=gameToEdit.getBlackPromotionMap();
    if (mBlackPromotionMap == null)     mBlackPromotionMap=Maps.newHashMap();
    mBoardPanels=new JPanel[gameToEdit.getBoards().length];
    for (int i=0; i < mBoardPanels.length; i++)     mBoardPanels[i]=new JPanel();
    mBuilder=new Builder(variantName,gameToEdit.getBoards(),mWhiteTeam,mBlackTeam,mWhiteRules,mBlackRules);
  }
 else {
    mBuilder=new Builder(Messages.getString(""String_Node_Str""));
    mWhiteTeam=Lists.newArrayList();
    mBlackTeam=Lists.newArrayList();
    mWhiteRules=new Rules(false);
    mBlackRules=new Rules(true);
    mWhitePromotionMap=Maps.newHashMap();
    mBlackPromotionMap=Maps.newHashMap();
    mBoardPanels=new JPanel[]{new JPanel(),new JPanel()};
    mBuilder.mBlackTeam=mBlackTeam;
    mBuilder.mWhiteTeam=mWhiteTeam;
  }
  Board board=new Board(2,1,false);
  mPieceDisplaySquares[WHITE_INDEX]=board.getSquare(1,1);
  mPieceDisplaySquares[BLACK_INDEX]=board.getSquare(2,1);
  mOptionsFrame=new JFrame();
  mOptionsFrame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
  mScrollPane.setPreferredSize(new Dimension(200,200));
  initGUIComponents(gameToEdit,variantName);
}"
49892,"public PlayGamePanel(Game game,boolean isPlayback) throws Exception {
  PlayGamePanel.setGame(game);
  PlayGamePanel.mIsPlayback=isPlayback;
  m_dropManager=new DropManager();
  if (isPlayback) {
    PlayGamePanel.mWhiteTimer=ChessTimer.createTimer(TimerTypes.NO_TIMER,null,0,0,false);
    PlayGamePanel.mBlackTimer=ChessTimer.createTimer(TimerTypes.NO_TIMER,null,0,0,true);
    mHistory=new Move[game.getHistory().size()];
    game.getHistory().toArray(mHistory);
    initComponents(isPlayback);
    mHistoryIndex=mHistory.length - 1;
    while (mHistoryIndex >= 0) {
      mHistory[mHistoryIndex].undo();
      mHistoryIndex--;
    }
  }
 else {
    m_globalGlassPane=new GlassPane();
    m_globalGlassPane.setOpaque(false);
    Driver.getInstance().setGlassPane(m_globalGlassPane);
    PlayGamePanel.mWhiteTimer=game.getWhiteTimer();
    PlayGamePanel.mBlackTimer=game.getBlackTimer();
    mWhiteTimer.restart();
    mBlackTimer.restart();
    turn(game.isBlackMove());
    mHistory=null;
    mHistoryIndex=-3;
    initComponents(isPlayback);
  }
  m_instance=this;
  boardRefresh(game.getBoards());
}","public PlayGamePanel(Game game,boolean isPlayback) throws Exception {
  PlayGamePanel.setGame(game);
  mGame=game;
  PlayGamePanel.mIsPlayback=isPlayback;
  mIsPlayback=isPlayback;
  m_dropManager=new DropManager();
  if (isPlayback) {
    PlayGamePanel.mWhiteTimer=ChessTimer.createTimer(TimerTypes.NO_TIMER,null,0,0,false);
    PlayGamePanel.mBlackTimer=ChessTimer.createTimer(TimerTypes.NO_TIMER,null,0,0,true);
    mHistory=new Move[game.getHistory().size()];
    game.getHistory().toArray(mHistory);
    initComponents(isPlayback);
    mHistoryIndex=mHistory.length - 1;
    while (mHistoryIndex >= 0) {
      mHistory[mHistoryIndex].undo();
      mHistoryIndex--;
    }
  }
 else {
    m_globalGlassPane=new GlassPane();
    m_globalGlassPane.setOpaque(false);
    Driver.getInstance().setGlassPane(m_globalGlassPane);
    PlayGamePanel.mWhiteTimer=game.getWhiteTimer();
    PlayGamePanel.mBlackTimer=game.getBlackTimer();
    mWhiteTimer.restart();
    mBlackTimer.restart();
    turn(game.isBlackMove());
    mHistory=null;
    mHistoryIndex=-3;
    initComponents(isPlayback);
  }
  m_instance=this;
  boardRefresh(game.getBoards());
}"
49893,"public static void setGame(Game game){
  PlayGamePanel.mGame=game;
}","public static void setGame(Game game){
  mGame=game;
}"
49894,"/** 
 * Determine if a Move is legal to be executed
 * @param move The Move on which to check legality
 * @return Whether or not the Move is legal
 * @throws Exception Throws if there was an illegal move, or failure toundo.
 */
public boolean isLegalMove(Move move) throws Exception {
  if (move == null)   return false;
  move.execute();
  move.undo();
  return true;
}","/** 
 * Determine if a Move is legal to be executed
 * @param move The Move on which to check legality
 * @return Whether or not the Move is legal
 * @throws Exception Throws if there was an illegal move, or failure toundo.
 */
public boolean isLegalMove(Move move) throws Exception {
  if (move == null)   return false;
  move.board=this;
  move.execute();
  move.undo();
  return true;
}"
49895,"/** 
 * Create a piece that represents a queen, without requiring a concrete queen class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed queen.
 * @throws IOException
 */
public static Piece createQueen(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> queenMovement=Maps.newHashMap();
  queenMovement.put('N',-1);
  queenMovement.put('S',-1);
  queenMovement.put('W',-1);
  queenMovement.put('E',-1);
  queenMovement.put('R',-1);
  queenMovement.put('r',-1);
  queenMovement.put('L',-1);
  queenMovement.put('l',-1);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,queenMovement);
}","/** 
 * Create a piece that represents a queen, without requiring a concrete queen class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed queen.
 * @throws IOException
 */
public static Piece createQueen(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> queenMovement=Maps.newHashMap();
  queenMovement.put(PieceBuilder.NORTH,-1);
  queenMovement.put(PieceBuilder.SOUTH,-1);
  queenMovement.put(PieceBuilder.WEST,-1);
  queenMovement.put(PieceBuilder.EAST,-1);
  queenMovement.put(PieceBuilder.NORTHEAST,-1);
  queenMovement.put(PieceBuilder.SOUTHEAST,-1);
  queenMovement.put(PieceBuilder.NORTHWEST,-1);
  queenMovement.put(PieceBuilder.SOUTHWEST,-1);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,queenMovement);
}"
49896,"/** 
 * Create a piece that represents a knight, without requiring a concrete knight class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed knight.
 * @throws IOException
 */
public static Piece createKnight(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> knightMovement=Maps.newHashMap();
  knightMovement.put('x',1);
  knightMovement.put('y',2);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,knightMovement);
}","/** 
 * Create a piece that represents a knight, without requiring a concrete knight class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed knight.
 * @throws IOException
 */
public static Piece createKnight(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> knightMovement=Maps.newHashMap();
  knightMovement.put(PieceBuilder.KNIGHT_ONE,1);
  knightMovement.put(PieceBuilder.KNIGHT_TWO,2);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,knightMovement);
}"
49897,"/** 
 * Create a piece that represents a king, without requiring a concrete king class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed king.
 * @throws IOException
 */
public static Piece createKing(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> kingMovement=Maps.newHashMap();
  kingMovement.put('N',1);
  kingMovement.put('S',1);
  kingMovement.put('E',1);
  kingMovement.put('W',1);
  kingMovement.put('R',1);
  kingMovement.put('r',1);
  kingMovement.put('L',1);
  kingMovement.put('l',1);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,kingMovement);
}","/** 
 * Create a piece that represents a king, without requiring a concrete king class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed king.
 * @throws IOException
 */
public static Piece createKing(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> kingMovement=Maps.newHashMap();
  kingMovement.put(PieceBuilder.NORTH,1);
  kingMovement.put(PieceBuilder.SOUTH,1);
  kingMovement.put(PieceBuilder.EAST,1);
  kingMovement.put(PieceBuilder.WEST,1);
  kingMovement.put(PieceBuilder.NORTHEAST,1);
  kingMovement.put(PieceBuilder.SOUTHEAST,1);
  kingMovement.put(PieceBuilder.NORTHWEST,1);
  kingMovement.put(PieceBuilder.SOUTHWEST,1);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,kingMovement);
}"
49898,"/** 
 * Create a piece that represents a rook, without requiring a concrete rook class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed rook.
 * @throws IOException
 */
public static Piece createRook(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> rookMovement=Maps.newHashMap();
  rookMovement.put('N',-1);
  rookMovement.put('S',-1);
  rookMovement.put('W',-1);
  rookMovement.put('E',-1);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,rookMovement);
}","/** 
 * Create a piece that represents a rook, without requiring a concrete rook class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed rook.
 * @throws IOException
 */
public static Piece createRook(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> rookMovement=Maps.newHashMap();
  rookMovement.put(PieceBuilder.NORTH,-1);
  rookMovement.put(PieceBuilder.SOUTH,-1);
  rookMovement.put(PieceBuilder.WEST,-1);
  rookMovement.put(PieceBuilder.EAST,-1);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,rookMovement);
}"
49899,"/** 
 * Create a piece that represents a bishop, without requiring a concrete bishop class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed bishop.
 * @throws IOException
 */
public static Piece createBishop(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> bishopMovement=Maps.newHashMap();
  bishopMovement.put('R',-1);
  bishopMovement.put('r',-1);
  bishopMovement.put('L',-1);
  bishopMovement.put('l',-1);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,bishopMovement);
}","/** 
 * Create a piece that represents a bishop, without requiring a concrete bishop class.
 * @param isBlack Is this piece black?
 * @param square What square does this piece start on?
 * @param board The board the piece is on
 * @return The constructed bishop.
 * @throws IOException
 */
public static Piece createBishop(boolean isBlack,Square square,Board board) throws IOException {
  Map<Character,Integer> bishopMovement=Maps.newHashMap();
  bishopMovement.put(PieceBuilder.NORTHEAST,-1);
  bishopMovement.put(PieceBuilder.SOUTHEAST,-1);
  bishopMovement.put(PieceBuilder.NORTHWEST,-1);
  bishopMovement.put(PieceBuilder.SOUTHWEST,-1);
  return new Piece(Messages.getString(""String_Node_Str""),isBlack,square,board,bishopMovement);
}"
49900,"/** 
 * Convert a chess piece to it's corresponding character
 * @param p The piece to convert
 * @return The character representing this piece
 */
public char pieceToChar(Piece p){
  if (p.getName().equals(Messages.getString(""String_Node_Str"")))   return 'N';
 else   return p.getName().charAt(0);
}","/** 
 * Convert a chess piece to it's corresponding character
 * @param p The piece to convert
 * @return The character representing this piece
 */
public char pieceToChar(Piece p){
  if (p.getName().equals(Messages.getString(""String_Node_Str"")))   return AlgebraicConverter.KNIGHT;
 else   return p.getName().charAt(0);
}"
49901,"private JButton createNewGameButton(){
  JButton newGameButton=new JButton(Messages.getString(""String_Node_Str""));
  newGameButton.setToolTipText(Messages.getString(""String_Node_Str""));
  newGameButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      setPanel(new NewGamePanel());
    }
  }
);
  return newGameButton;
}","private JButton createNewGameButton(){
  JButton newGameButton=new JButton(Messages.getString(""String_Node_Str""));
  newGameButton.setToolTipText(Messages.getString(""String_Node_Str""));
  try {
    newGameButton.setIcon(GuiUtility.createImageIcon(30,30,FileUtility.getImagePath(""String_Node_Str"",true)));
  }
 catch (  IOException ae) {
    ae.printStackTrace();
  }
  newGameButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      setPanel(new NewGamePanel());
    }
  }
);
  return newGameButton;
}"
49902,"private JButton pieceMenuButton(){
  JButton pieceButton=new JButton(Messages.getString(""String_Node_Str""));
  pieceButton.setToolTipText(Messages.getString(""String_Node_Str""));
  pieceButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      setPanel(new PieceMenuPanel());
    }
  }
);
  return pieceButton;
}","private JButton pieceMenuButton(){
  JButton pieceButton=new JButton(Messages.getString(""String_Node_Str""));
  pieceButton.setToolTipText(Messages.getString(""String_Node_Str""));
  try {
    pieceButton.setIcon(GuiUtility.createImageIcon(10,30,FileUtility.getImagePath(""String_Node_Str"",true)));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  pieceButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      setPanel(new PieceMenuPanel());
    }
  }
);
  return pieceButton;
}"
49903,"private void initGuiComponents() throws ClassNotFoundException, InstantiationException, IllegalAccessException, UnsupportedLookAndFeelException {
  setTitle(AppConstants.APP_NAME);
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setLayout(new FlowLayout());
  setResizable(true);
  setLocationRelativeTo(null);
  UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  createWindowsTrayIconIfNecessary();
  createMenuBar();
  mMainPanel=new JPanel();
  mMainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  mMainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=4;
  c.gridx=0;
  c.gridy=0;
  try {
    mMainPanel.add(new JLabel(GuiUtility.createImageIcon(300,200,FileUtility.getImagePath(""String_Node_Str"",true))),c);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=1;
  mMainPanel.add(createNewGameButton(),c);
  c.gridx=2;
  c.gridy=1;
  mMainPanel.add(variantMenuButton(),c);
  c.gridx=3;
  c.gridy=1;
  mMainPanel.add(pieceMenuButton(),c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mMainPanel.add(createContinueGameButton(),c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mMainPanel.add(createViewCompletedGamesButton(),c);
  add(mMainPanel);
  setVisible(true);
}","private void initGuiComponents() throws ClassNotFoundException, InstantiationException, IllegalAccessException, UnsupportedLookAndFeelException {
  setTitle(AppConstants.APP_NAME);
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(685,450);
  setLayout(new FlowLayout());
  setResizable(true);
  setLocationRelativeTo(null);
  UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  createWindowsTrayIconIfNecessary();
  createMenuBar();
  mMainPanel=new JPanel();
  mMainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  mMainPanel.setLayout(new GridBagLayout());
  mButtonPanel=new JPanel();
  mButtonPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=0;
  try {
    mMainPanel.add(new JLabel(GuiUtility.createImageIcon(506,380,FileUtility.getImagePath(""String_Node_Str"",true))),c);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  c.gridx=0;
  c.gridy=0;
  mButtonPanel.add(createNewGameButton(),c);
  c.gridx=0;
  c.gridy=1;
  mButtonPanel.add(variantMenuButton(),c);
  c.gridx=0;
  c.gridy=2;
  mButtonPanel.add(pieceMenuButton(),c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=3;
  mButtonPanel.add(createContinueGameButton(),c);
  c.gridx=0;
  c.gridy=4;
  mButtonPanel.add(createViewCompletedGamesButton(),c);
  c.gridx=1;
  c.gridy=0;
  mMainPanel.add(mButtonPanel,c);
  add(mMainPanel);
  setVisible(true);
}"
49904,"public void setOptionsMenuVisibility(boolean isVisible){
  mOptionsMenu.setVisible(isVisible);
}","@Override public void setOptionsMenuVisibility(boolean isVisible){
  mOptionsMenu.setVisible(isVisible);
}"
49905,"public void setFileMenuVisibility(boolean isVisible){
  mFileMenu.setVisible(isVisible);
}","@Override public void setFileMenuVisibility(boolean isVisible){
  mFileMenu.setVisible(isVisible);
}"
49906,"public void revertToMainPanel(){
  remove(mOtherPanel);
  mMainMenuItem.setVisible(false);
  add(mMainPanel);
  deactivateWindowListener();
  pack();
  centerFrame();
}","@Override public void revertToMainPanel(){
  remove(mOtherPanel);
  mMainMenuItem.setVisible(false);
  add(mMainPanel);
  deactivateWindowListener();
  pack();
  centerFrame();
}"
49907,"private JButton variantMenuButton(){
  JButton variantButton=new JButton(Messages.getString(""String_Node_Str""));
  variantButton.setToolTipText(Messages.getString(""String_Node_Str""));
  variantButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      setPanel(new VariantMenuPanel());
    }
  }
);
  return variantButton;
}","private JButton variantMenuButton(){
  JButton variantButton=new JButton(Messages.getString(""String_Node_Str""));
  variantButton.setToolTipText(Messages.getString(""String_Node_Str""));
  try {
    variantButton.setIcon(GuiUtility.createImageIcon(30,30,FileUtility.getImagePath(""String_Node_Str"",true)));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  variantButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      setPanel(new VariantMenuPanel());
    }
  }
);
  return variantButton;
}"
49908,"private JButton createContinueGameButton(){
  JButton continueGameButton=new JButton(Messages.getString(""String_Node_Str""));
  continueGameButton.setToolTipText(Messages.getString(""String_Node_Str""));
  continueGameButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      String[] files=FileUtility.getGamesInProgressFileArray();
      if (files.length == 0) {
        JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JFrame poppedFrame=new JFrame(Messages.getString(""String_Node_Str""));
      poppedFrame.setLayout(new GridBagLayout());
      poppedFrame.setSize(225,200);
      poppedFrame.setResizable(false);
      poppedFrame.setLocationRelativeTo(Driver.this);
      GridBagConstraints constraints=new GridBagConstraints();
      final JList gamesInProgressList=new JList(FileUtility.getGamesInProgressFileArray());
      final JScrollPane scrollPane=new JScrollPane(gamesInProgressList);
      scrollPane.setPreferredSize(new Dimension(200,200));
      gamesInProgressList.setSelectedIndex(0);
      JButton nextButton=new JButton(Messages.getString(""String_Node_Str""));
      nextButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent event){
          FileInputStream fileInputStream;
          ObjectInputStream objectInputStream;
          Game gameToPlay;
          try {
            if (gamesInProgressList.getSelectedValue() == null) {
              JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
              return;
            }
            fileInputStream=new FileInputStream(FileUtility.getGamesInProgressFile(gamesInProgressList.getSelectedValue().toString()));
            objectInputStream=new ObjectInputStream(fileInputStream);
            gameToPlay=(Game)objectInputStream.readObject();
            gameToPlay.getWhiteRules().setGame(gameToPlay);
            gameToPlay.getBlackRules().setGame(gameToPlay);
            if (mOptionsMenu != null)             mOptionsMenu.setVisible(true);
            setPanel(new PlayGamePanel(gameToPlay,false));
            poppedFrame.dispose();
          }
 catch (          Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
          }
        }
      }
);
      JButton cancelButton=new JButton(Messages.getString(""String_Node_Str""));
      GuiUtility.setupCancelButton(cancelButton,poppedFrame);
      JButton deleteButton=new JButton(Messages.getString(""String_Node_Str""));
      deleteButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent event){
          if (gamesInProgressList.getSelectedValue() != null) {
            boolean didDeleteSuccessfully=FileUtility.getGamesInProgressFile(gamesInProgressList.getSelectedValue().toString()).delete();
            if (!didDeleteSuccessfully) {
              JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
            }
 else {
              gamesInProgressList.setListData(FileUtility.getGamesInProgressFileArray());
              gamesInProgressList.setSelectedIndex(0);
              if (gamesInProgressList.getSelectedValue() == null) {
                JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
                poppedFrame.dispose();
              }
              scrollPane.getViewport().add(gamesInProgressList,null);
            }
          }
 else {
            JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
          }
        }
      }
);
      constraints.gridx=0;
      constraints.gridy=0;
      constraints.gridwidth=2;
      constraints.insets=new Insets(5,5,5,5);
      poppedFrame.add(scrollPane,constraints);
      constraints.gridx=0;
      constraints.gridy=1;
      poppedFrame.add(deleteButton,constraints);
      constraints.weighty=1.0;
      constraints.weightx=1.0;
      constraints.gridx=0;
      constraints.gridy=2;
      constraints.gridwidth=1;
      constraints.anchor=GridBagConstraints.EAST;
      poppedFrame.add(nextButton,constraints);
      constraints.gridx=1;
      constraints.gridy=2;
      constraints.anchor=GridBagConstraints.WEST;
      poppedFrame.add(cancelButton,constraints);
      poppedFrame.setVisible(true);
      poppedFrame.pack();
    }
  }
);
  return continueGameButton;
}","private JButton createContinueGameButton(){
  JButton continueGameButton=new JButton(Messages.getString(""String_Node_Str""));
  continueGameButton.setToolTipText(Messages.getString(""String_Node_Str""));
  try {
    continueGameButton.setIcon(GuiUtility.createImageIcon(30,30,FileUtility.getImagePath(""String_Node_Str"",true)));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  continueGameButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      String[] files=FileUtility.getGamesInProgressFileArray();
      if (files.length == 0) {
        JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JFrame poppedFrame=new JFrame(Messages.getString(""String_Node_Str""));
      poppedFrame.setLayout(new GridBagLayout());
      poppedFrame.setSize(225,200);
      poppedFrame.setResizable(false);
      poppedFrame.setLocationRelativeTo(Driver.this);
      GridBagConstraints constraints=new GridBagConstraints();
      final JList gamesInProgressList=new JList(FileUtility.getGamesInProgressFileArray());
      final JScrollPane scrollPane=new JScrollPane(gamesInProgressList);
      scrollPane.setPreferredSize(new Dimension(200,200));
      gamesInProgressList.setSelectedIndex(0);
      JButton nextButton=new JButton(Messages.getString(""String_Node_Str""));
      nextButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent event){
          FileInputStream fileInputStream;
          ObjectInputStream objectInputStream;
          Game gameToPlay;
          try {
            if (gamesInProgressList.getSelectedValue() == null) {
              JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
              return;
            }
            fileInputStream=new FileInputStream(FileUtility.getGamesInProgressFile(gamesInProgressList.getSelectedValue().toString()));
            objectInputStream=new ObjectInputStream(fileInputStream);
            gameToPlay=(Game)objectInputStream.readObject();
            gameToPlay.getWhiteRules().setGame(gameToPlay);
            gameToPlay.getBlackRules().setGame(gameToPlay);
            if (mOptionsMenu != null)             mOptionsMenu.setVisible(true);
            setPanel(new PlayGamePanel(gameToPlay,false));
            poppedFrame.dispose();
          }
 catch (          Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
          }
        }
      }
);
      JButton cancelButton=new JButton(Messages.getString(""String_Node_Str""));
      GuiUtility.setupCancelButton(cancelButton,poppedFrame);
      JButton deleteButton=new JButton(Messages.getString(""String_Node_Str""));
      deleteButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent event){
          if (gamesInProgressList.getSelectedValue() != null) {
            boolean didDeleteSuccessfully=FileUtility.getGamesInProgressFile(gamesInProgressList.getSelectedValue().toString()).delete();
            if (!didDeleteSuccessfully) {
              JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
            }
 else {
              gamesInProgressList.setListData(FileUtility.getGamesInProgressFileArray());
              gamesInProgressList.setSelectedIndex(0);
              if (gamesInProgressList.getSelectedValue() == null) {
                JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
                poppedFrame.dispose();
              }
              scrollPane.getViewport().add(gamesInProgressList,null);
            }
          }
 else {
            JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
          }
        }
      }
);
      constraints.gridx=0;
      constraints.gridy=0;
      constraints.gridwidth=2;
      constraints.insets=new Insets(5,5,5,5);
      poppedFrame.add(scrollPane,constraints);
      constraints.gridx=0;
      constraints.gridy=1;
      poppedFrame.add(deleteButton,constraints);
      constraints.weighty=1.0;
      constraints.weightx=1.0;
      constraints.gridx=0;
      constraints.gridy=2;
      constraints.gridwidth=1;
      constraints.anchor=GridBagConstraints.EAST;
      poppedFrame.add(nextButton,constraints);
      constraints.gridx=1;
      constraints.gridy=2;
      constraints.anchor=GridBagConstraints.WEST;
      poppedFrame.add(cancelButton,constraints);
      poppedFrame.setVisible(true);
      poppedFrame.pack();
    }
  }
);
  return continueGameButton;
}"
49909,"private JButton createViewCompletedGamesButton(){
  JButton viewCompletedGameButton=new JButton(Messages.getString(""String_Node_Str""));
  viewCompletedGameButton.setToolTipText(Messages.getString(""String_Node_Str""));
  viewCompletedGameButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      try {
        String[] files=FileUtility.getCompletedGamesFileArray();
        if (files.length == 0) {
          JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
          return;
        }
        final JFrame poppedFrame=new JFrame(Messages.getString(""String_Node_Str""));
        poppedFrame.setLayout(new GridBagLayout());
        poppedFrame.setSize(225,200);
        poppedFrame.setResizable(false);
        poppedFrame.setLocationRelativeTo(Driver.this);
        GridBagConstraints constraints=new GridBagConstraints();
        final JList completedGamesList=new JList(FileUtility.getCompletedGamesFileArray());
        final JScrollPane scrollPane=new JScrollPane(completedGamesList);
        scrollPane.setPreferredSize(new Dimension(200,200));
        completedGamesList.setSelectedIndex(0);
        JButton nextButton=new JButton(Messages.getString(""String_Node_Str""));
        nextButton.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent event){
            if (completedGamesList.getSelectedValue() == null) {
              JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
              return;
            }
            File file=FileUtility.getCompletedGamesFile(completedGamesList.getSelectedValue().toString());
            FileInputStream fileInputStream;
            ObjectInputStream objectInputStream;
            Game gameToView;
            if (completedGamesList.getSelectedValue().toString().endsWith(""String_Node_Str"")) {
              try {
                mOtherPanel=new PlayGamePanel(true,file);
              }
 catch (              Exception e) {
                JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
                return;
              }
            }
 else {
              try {
                fileInputStream=new FileInputStream(file);
                objectInputStream=new ObjectInputStream(fileInputStream);
                gameToView=(Game)objectInputStream.readObject();
                setPanel(new PlayGamePanel(gameToView,false));
                poppedFrame.dispose();
              }
 catch (              Exception e) {
                e.printStackTrace();
                JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
              }
            }
            deactivateWindowListener();
            poppedFrame.dispose();
          }
        }
);
        JButton cancelButton=new JButton(Messages.getString(""String_Node_Str""));
        GuiUtility.setupCancelButton(cancelButton,poppedFrame);
        JButton deleteButton=new JButton(Messages.getString(""String_Node_Str""));
        deleteButton.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent event){
            if (completedGamesList.getSelectedValue() != null) {
              boolean didDeleteCompletedGameSuccessfully=FileUtility.getCompletedGamesFile(completedGamesList.getSelectedValue().toString()).delete();
              if (!didDeleteCompletedGameSuccessfully) {
                JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
              }
 else {
                completedGamesList.removeAll();
                completedGamesList.setListData(FileUtility.getCompletedGamesFileArray());
                completedGamesList.setSelectedIndex(0);
                if (completedGamesList.getSelectedValue() == null) {
                  JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
                  poppedFrame.dispose();
                }
                scrollPane.getViewport().add(completedGamesList,null);
              }
            }
 else {
              JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
            }
          }
        }
);
        constraints.gridx=0;
        constraints.gridy=0;
        constraints.gridwidth=2;
        constraints.insets=new Insets(5,5,5,5);
        poppedFrame.add(scrollPane,constraints);
        constraints.gridx=0;
        constraints.gridy=1;
        poppedFrame.add(deleteButton,constraints);
        constraints.weighty=1.0;
        constraints.weightx=1.0;
        constraints.gridx=0;
        constraints.gridy=2;
        constraints.gridwidth=1;
        constraints.anchor=GridBagConstraints.EAST;
        poppedFrame.add(nextButton,constraints);
        constraints.gridx=1;
        constraints.gridy=2;
        constraints.anchor=GridBagConstraints.WEST;
        poppedFrame.add(cancelButton,constraints);
        poppedFrame.setVisible(true);
        poppedFrame.pack();
      }
 catch (      Exception e) {
        e.printStackTrace();
        JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
      }
    }
  }
);
  return viewCompletedGameButton;
}","private JButton createViewCompletedGamesButton(){
  JButton viewCompletedGameButton=new JButton(Messages.getString(""String_Node_Str""));
  viewCompletedGameButton.setToolTipText(Messages.getString(""String_Node_Str""));
  try {
    viewCompletedGameButton.setIcon(GuiUtility.createImageIcon(30,30,FileUtility.getImagePath(""String_Node_Str"",true)));
  }
 catch (  IOException ae) {
    ae.printStackTrace();
  }
  viewCompletedGameButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      try {
        String[] files=FileUtility.getCompletedGamesFileArray();
        if (files.length == 0) {
          JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
          return;
        }
        final JFrame poppedFrame=new JFrame(Messages.getString(""String_Node_Str""));
        poppedFrame.setLayout(new GridBagLayout());
        poppedFrame.setSize(225,200);
        poppedFrame.setResizable(false);
        poppedFrame.setLocationRelativeTo(Driver.this);
        GridBagConstraints constraints=new GridBagConstraints();
        final JList completedGamesList=new JList(FileUtility.getCompletedGamesFileArray());
        final JScrollPane scrollPane=new JScrollPane(completedGamesList);
        scrollPane.setPreferredSize(new Dimension(200,200));
        completedGamesList.setSelectedIndex(0);
        JButton nextButton=new JButton(Messages.getString(""String_Node_Str""));
        nextButton.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent event){
            if (completedGamesList.getSelectedValue() == null) {
              JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
              return;
            }
            File file=FileUtility.getCompletedGamesFile(completedGamesList.getSelectedValue().toString());
            FileInputStream fileInputStream;
            ObjectInputStream objectInputStream;
            Game gameToView;
            if (completedGamesList.getSelectedValue().toString().endsWith(""String_Node_Str"")) {
              try {
                mOtherPanel=new PlayGamePanel(true,file);
              }
 catch (              Exception e) {
                JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
                return;
              }
            }
 else {
              try {
                fileInputStream=new FileInputStream(file);
                objectInputStream=new ObjectInputStream(fileInputStream);
                gameToView=(Game)objectInputStream.readObject();
                setPanel(new PlayGamePanel(gameToView,false));
                poppedFrame.dispose();
              }
 catch (              Exception e) {
                e.printStackTrace();
                JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
              }
            }
            deactivateWindowListener();
            poppedFrame.dispose();
          }
        }
);
        JButton cancelButton=new JButton(Messages.getString(""String_Node_Str""));
        GuiUtility.setupCancelButton(cancelButton,poppedFrame);
        JButton deleteButton=new JButton(Messages.getString(""String_Node_Str""));
        deleteButton.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent event){
            if (completedGamesList.getSelectedValue() != null) {
              boolean didDeleteCompletedGameSuccessfully=FileUtility.getCompletedGamesFile(completedGamesList.getSelectedValue().toString()).delete();
              if (!didDeleteCompletedGameSuccessfully) {
                JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
              }
 else {
                completedGamesList.removeAll();
                completedGamesList.setListData(FileUtility.getCompletedGamesFileArray());
                completedGamesList.setSelectedIndex(0);
                if (completedGamesList.getSelectedValue() == null) {
                  JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
                  poppedFrame.dispose();
                }
                scrollPane.getViewport().add(completedGamesList,null);
              }
            }
 else {
              JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
            }
          }
        }
);
        constraints.gridx=0;
        constraints.gridy=0;
        constraints.gridwidth=2;
        constraints.insets=new Insets(5,5,5,5);
        poppedFrame.add(scrollPane,constraints);
        constraints.gridx=0;
        constraints.gridy=1;
        poppedFrame.add(deleteButton,constraints);
        constraints.weighty=1.0;
        constraints.weightx=1.0;
        constraints.gridx=0;
        constraints.gridy=2;
        constraints.gridwidth=1;
        constraints.anchor=GridBagConstraints.EAST;
        poppedFrame.add(nextButton,constraints);
        constraints.gridx=1;
        constraints.gridy=2;
        constraints.anchor=GridBagConstraints.WEST;
        poppedFrame.add(cancelButton,constraints);
        poppedFrame.setVisible(true);
        poppedFrame.pack();
      }
 catch (      Exception e) {
        e.printStackTrace();
        JOptionPane.showMessageDialog(Driver.getInstance(),Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.PLAIN_MESSAGE);
      }
    }
  }
);
  return viewCompletedGameButton;
}"
49910,"@Override public void actionPerformed(ActionEvent event){
  Object[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
switch (JOptionPane.showOptionDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0])) {
case JOptionPane.YES_OPTION:
    JFileChooser fileChooser=new JFileChooser(""String_Node_Str"");
  fileChooser.setFileFilter(new FileFilter(){
    @Override public String getDescription(){
      return ""String_Node_Str"";
    }
    @Override public boolean accept(    File f){
      if (f.isDirectory() || f.getName().endsWith(""String_Node_Str""))       return true;
 else       return false;
    }
  }
);
if (fileChooser.showOpenDialog(Driver.getInstance()) == JFileChooser.APPROVE_OPTION) {
  try {
    if (m_isDarkImage) {
      mDarkImage=ImageIO.read(new File(fileChooser.toString()));
      m_imageLabel.setIcon(new ImageIcon(mDarkImage.getScaledInstance(48,48,Image.SCALE_SMOOTH)));
    }
 else {
      mLightImage=ImageIO.read(new File(fileChooser.toString()));
      m_imageLabel.setIcon(new ImageIcon(mLightImage.getScaledInstance(48,48,Image.SCALE_SMOOTH)));
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}
break;
case JOptionPane.NO_OPTION:
String url=JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
try {
if (m_isDarkImage) {
mDarkImage=ImageIO.read(new URL(url));
m_imageLabel.setIcon(new ImageIcon(mDarkImage.getScaledInstance(48,48,Image.SCALE_SMOOTH)));
}
 else {
mLightImage=ImageIO.read(new URL(url));
m_imageLabel.setIcon(new ImageIcon(mLightImage.getScaledInstance(48,48,Image.SCALE_SMOOTH)));
}
}
 catch (Exception e) {
e.printStackTrace();
}
break;
case JOptionPane.CANCEL_OPTION:
break;
}
}","@Override public void actionPerformed(ActionEvent event){
  Object[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
switch (JOptionPane.showOptionDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0])) {
case JOptionPane.YES_OPTION:
    JFileChooser fileChooser=new JFileChooser(""String_Node_Str"");
  fileChooser.setFileFilter(new FileFilter(){
    @Override public String getDescription(){
      return ""String_Node_Str"";
    }
    @Override public boolean accept(    File f){
      if (f.isDirectory() || f.getName().endsWith(""String_Node_Str""))       return true;
 else       return false;
    }
  }
);
if (fileChooser.showOpenDialog(Driver.getInstance()) == JFileChooser.APPROVE_OPTION) {
  try {
    if (m_isDarkImage) {
      mDarkImage=ImageIO.read(fileChooser.getSelectedFile());
      m_imageLabel.setIcon(new ImageIcon(mDarkImage.getScaledInstance(48,48,Image.SCALE_SMOOTH)));
    }
 else {
      mLightImage=ImageIO.read(fileChooser.getSelectedFile());
      m_imageLabel.setIcon(new ImageIcon(mLightImage.getScaledInstance(48,48,Image.SCALE_SMOOTH)));
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}
break;
case JOptionPane.NO_OPTION:
String url=JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
try {
if (m_isDarkImage) {
mDarkImage=ImageIO.read(new URL(url));
m_imageLabel.setIcon(new ImageIcon(mDarkImage.getScaledInstance(48,48,Image.SCALE_SMOOTH)));
}
 else {
mLightImage=ImageIO.read(new URL(url));
m_imageLabel.setIcon(new ImageIcon(mLightImage.getScaledInstance(48,48,Image.SCALE_SMOOTH)));
}
}
 catch (Exception e) {
e.printStackTrace();
}
break;
case JOptionPane.CANCEL_OPTION:
break;
}
}"
49911,"public void init(RunnableOfT<Boolean> timeElapsedCallback){
  m_displayLabel=new JLabel();
  m_displayLabel.setHorizontalAlignment(SwingConstants.CENTER);
  m_displayLabel.setOpaque(true);
  m_numberFormat=NumberFormat.getNumberInstance();
  m_numberFormat.setMinimumIntegerDigits(2);
  m_timer=new Timer(1000,this);
  m_timer.setInitialDelay(0);
  m_timeElapsedCallback=timeElapsedCallback;
}","public void init(RunnableOfT<Boolean> timeElapsedCallback){
  m_displayLabel=new JLabel();
  m_displayLabel.setHorizontalAlignment(SwingConstants.CENTER);
  m_displayLabel.setOpaque(true);
  m_numberFormat=NumberFormat.getNumberInstance();
  m_numberFormat.setMinimumIntegerDigits(2);
  m_timer=new Timer(1000,this);
  m_timer.setInitialDelay(0);
  m_timeElapsedCallback=timeElapsedCallback;
  m_isStopped=false;
}"
49912,"private void initComponents(boolean isPlayback) throws Exception {
  m_inCheckLabel=new JLabel(""String_Node_Str"");
  m_inCheckLabel.setHorizontalTextPosition(SwingConstants.CENTER);
  m_inCheckLabel.setForeground(Color.RED);
  m_undoButton=new JButton(""String_Node_Str"");
  m_undoButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      if (getGame().getHistory().size() == 0)       return;
      try {
        getGame().getHistory().get(getGame().getHistory().size() - 1).undo();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      getGame().getHistory().remove(getGame().getHistory().size() - 1);
      (getGame().isBlackMove() ? getGame().getBlackRules() : getGame().getWhiteRules()).undoEndOfGame();
      boardRefresh(getGame().getBoards());
    }
  }
);
  int twoBoardsGridBagOffset=0;
  if (m_optionsMenu == null || !m_optionsMenu.isVisible())   Driver.getInstance().setMenu(createMenuBar());
  Driver.m_gameOptionsMenu.setVisible(!isPlayback);
  setLayout(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  setBorder(BorderFactory.createLoweredBevelBorder());
  m_inCheckLabel.setHorizontalTextPosition(SwingConstants.CENTER);
  m_inCheckLabel.setHorizontalAlignment(SwingConstants.CENTER);
  constraints.fill=GridBagConstraints.NONE;
  constraints.gridy=0;
  constraints.gridx=9;
  m_inCheckLabel.setVisible(false);
  add(m_inCheckLabel,constraints);
  if (boards.length == 1) {
    constraints.gridheight=12;
    constraints.gridy=2;
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridwidth=10;
    constraints.gridheight=10;
    constraints.insets=new Insets(10,0,0,0);
    constraints.gridx=0;
    add(createGrid(boards[0],isPlayback,false),constraints);
  }
 else {
    constraints.gridheight=12;
    constraints.gridy=2;
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridwidth=10;
    constraints.insets=new Insets(10,0,0,0);
    constraints.gridx=0;
    add(createGrid(boards[0],isPlayback,false),constraints);
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridwidth=10;
    constraints.insets=new Insets(10,0,0,0);
    constraints.gridx=11;
    add(createGrid(boards[1],isPlayback,false),constraints);
    twoBoardsGridBagOffset+=10;
  }
  JButton nextButton=new JButton(""String_Node_Str"");
  nextButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      if (m_historyIndex + 1 == m_history.length)       return;
      try {
        m_history[++m_historyIndex].execute();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  JButton prevButton=new JButton(""String_Node_Str"");
  prevButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      if (m_historyIndex == -1)       return;
      try {
        m_history[m_historyIndex--].undo();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  m_whiteLabel=new JLabel(""String_Node_Str"");
  m_whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  m_whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  m_blackLabel=new JLabel(""String_Node_Str"");
  m_blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  m_blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  m_whiteLabel.setOpaque(true);
  m_blackLabel.setOpaque(true);
  m_whiteLabel.setVisible(true);
  m_blackLabel.setVisible(true);
  int jailBoardSize;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    jailBoardSize=4;
  }
 else {
    double size=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    jailBoardSize=(int)Math.ceil(size);
  }
  m_whiteCapturesJail=new Board(jailBoardSize,jailBoardSize,false);
  m_whiteCapturePanel=createGrid(m_whiteCapturesJail,isPlayback,true);
  m_whiteCapturePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  m_whiteCapturePanel.setLayout(new GridLayout(jailBoardSize,jailBoardSize));
  m_whiteCapturePanel.setPreferredSize(new Dimension((m_whiteCapturesJail.getMaxCol() + 1) * 25,(m_whiteCapturesJail.getMaxRow() + 1) * 25));
  m_blackCapturesJail=new Board(jailBoardSize,jailBoardSize,false);
  m_blackCapturePanel=createGrid(m_blackCapturesJail,isPlayback,true);
  m_blackCapturePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  m_blackCapturePanel.setLayout(new GridLayout(jailBoardSize,jailBoardSize));
  m_blackCapturePanel.setPreferredSize(new Dimension((m_blackCapturesJail.getMaxCol() + 1) * 25,(m_blackCapturesJail.getMaxRow() + 1) * 25));
  constraints.fill=GridBagConstraints.NONE;
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.gridwidth=3;
  constraints.gridheight=1;
  constraints.insets=new Insets(10,10,10,0);
  constraints.ipadx=100;
  constraints.gridx=11 + twoBoardsGridBagOffset;
  constraints.gridy=0;
  add(m_blackLabel,constraints);
  constraints.fill=GridBagConstraints.NONE;
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.gridwidth=3;
  constraints.gridheight=3;
  constraints.ipadx=0;
  constraints.insets=new Insets(0,25,10,25);
  constraints.gridx=11 + twoBoardsGridBagOffset;
  constraints.gridy=1;
  add(m_blackCapturePanel,constraints);
  if (!isPlayback) {
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=4;
    add(m_blackTimer.getDisplayLabel(),constraints);
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=5;
    add(m_undoButton,constraints);
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=6;
    add(m_whiteTimer.getDisplayLabel(),constraints);
  }
 else {
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=4;
    add(nextButton,constraints);
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=5;
    add(prevButton,constraints);
  }
  constraints.fill=GridBagConstraints.NONE;
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.gridwidth=3;
  constraints.gridheight=3;
  constraints.ipadx=0;
  constraints.gridx=11 + twoBoardsGridBagOffset;
  if (m_whiteTimer instanceof NoTimer) {
    constraints.gridy=6;
    constraints.insets=new Insets(10,25,0,25);
  }
 else {
    constraints.gridy=7;
    constraints.insets=new Insets(0,25,0,25);
  }
  add(m_whiteCapturePanel,constraints);
  constraints.fill=GridBagConstraints.NONE;
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.gridwidth=3;
  constraints.weightx=0.0;
  constraints.weighty=0.0;
  constraints.insets=new Insets(10,0,10,0);
  if (m_whiteTimer instanceof NoTimer) {
    constraints.gridheight=1;
    constraints.gridy=9;
  }
 else {
    constraints.gridheight=2;
    constraints.gridy=11;
  }
  constraints.ipadx=100;
  constraints.gridx=11 + twoBoardsGridBagOffset;
  add(m_whiteLabel,constraints);
  Dimension dimension=Toolkit.getDefaultToolkit().getScreenSize();
  int x=(int)((dimension.getWidth() / 3.3));
  int y=(int)((dimension.getHeight() / 4));
  Driver.getInstance().setLocation(x,y);
}","private void initComponents(boolean isPlayback) throws Exception {
  m_inCheckLabel=new JLabel(""String_Node_Str"");
  m_inCheckLabel.setHorizontalTextPosition(SwingConstants.CENTER);
  m_inCheckLabel.setForeground(Color.RED);
  m_undoButton=new JButton(""String_Node_Str"");
  m_undoButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      if (getGame().getHistory().size() == 0)       return;
      try {
        getGame().getHistory().get(getGame().getHistory().size() - 1).undo();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      getGame().getHistory().remove(getGame().getHistory().size() - 1);
      (getGame().isBlackMove() ? getGame().getBlackRules() : getGame().getWhiteRules()).undoEndOfGame();
      boardRefresh(getGame().getBoards());
    }
  }
);
  int twoBoardsGridBagOffset=0;
  if (m_optionsMenu == null || !m_optionsMenu.isVisible())   Driver.getInstance().setMenu(createMenuBar());
  Driver.m_gameOptionsMenu.setVisible(!isPlayback);
  setLayout(new GridBagLayout());
  GridBagConstraints constraints=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  setBorder(BorderFactory.createLoweredBevelBorder());
  m_inCheckLabel.setHorizontalTextPosition(SwingConstants.CENTER);
  m_inCheckLabel.setHorizontalAlignment(SwingConstants.CENTER);
  constraints.fill=GridBagConstraints.NONE;
  constraints.gridy=0;
  constraints.gridx=9;
  m_inCheckLabel.setVisible(false);
  add(m_inCheckLabel,constraints);
  if (boards.length == 1) {
    constraints.gridheight=12;
    constraints.gridy=2;
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridwidth=10;
    constraints.gridheight=10;
    constraints.insets=new Insets(10,0,0,0);
    constraints.gridx=0;
    add(createGrid(boards[0],isPlayback,false),constraints);
  }
 else {
    constraints.gridheight=12;
    constraints.gridy=2;
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridwidth=10;
    constraints.insets=new Insets(10,0,0,0);
    constraints.gridx=0;
    add(createGrid(boards[0],isPlayback,false),constraints);
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.gridwidth=10;
    constraints.insets=new Insets(10,0,0,0);
    constraints.gridx=11;
    add(createGrid(boards[1],isPlayback,false),constraints);
    twoBoardsGridBagOffset+=10;
  }
  JButton nextButton=new JButton(""String_Node_Str"");
  nextButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      if (m_historyIndex + 1 == m_history.length)       return;
      try {
        m_history[++m_historyIndex].execute();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  JButton prevButton=new JButton(""String_Node_Str"");
  prevButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      if (m_historyIndex == -1)       return;
      try {
        m_history[m_historyIndex--].undo();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  m_whiteLabel=new JLabel(""String_Node_Str"");
  m_whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  m_whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  m_blackLabel=new JLabel(""String_Node_Str"");
  m_blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  m_blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  m_whiteLabel.setOpaque(true);
  m_blackLabel.setOpaque(true);
  m_whiteLabel.setVisible(true);
  m_blackLabel.setVisible(true);
  int jailBoardSize;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    jailBoardSize=4;
  }
 else {
    double size=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    jailBoardSize=(int)Math.ceil(size);
  }
  m_whiteCapturesJail=new Board(jailBoardSize,jailBoardSize,false);
  m_whiteCapturePanel=createGrid(m_whiteCapturesJail,isPlayback,true);
  m_whiteCapturePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  m_whiteCapturePanel.setLayout(new GridLayout(jailBoardSize,jailBoardSize));
  m_whiteCapturePanel.setPreferredSize(new Dimension((m_whiteCapturesJail.getMaxCol() + 1) * 25,(m_whiteCapturesJail.getMaxRow() + 1) * 25));
  m_blackCapturesJail=new Board(jailBoardSize,jailBoardSize,false);
  m_blackCapturePanel=createGrid(m_blackCapturesJail,isPlayback,true);
  m_blackCapturePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  m_blackCapturePanel.setLayout(new GridLayout(jailBoardSize,jailBoardSize));
  m_blackCapturePanel.setPreferredSize(new Dimension((m_blackCapturesJail.getMaxCol() + 1) * 25,(m_blackCapturesJail.getMaxRow() + 1) * 25));
  constraints.fill=GridBagConstraints.NONE;
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.gridwidth=3;
  constraints.gridheight=1;
  constraints.insets=new Insets(10,10,10,0);
  constraints.ipadx=100;
  constraints.gridx=11 + twoBoardsGridBagOffset;
  constraints.gridy=0;
  add(m_blackLabel,constraints);
  constraints.fill=GridBagConstraints.NONE;
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.gridwidth=3;
  constraints.gridheight=3;
  constraints.ipadx=0;
  constraints.insets=new Insets(0,25,10,25);
  constraints.gridx=11 + twoBoardsGridBagOffset;
  constraints.gridy=1;
  add(m_blackCapturePanel,constraints);
  if (!isPlayback) {
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=4;
    add(m_blackTimer.getDisplayLabel(),constraints);
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=5;
    add(m_undoButton,constraints);
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=6;
    add(m_whiteTimer.getDisplayLabel(),constraints);
  }
 else {
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=4;
    add(nextButton,constraints);
    constraints.fill=GridBagConstraints.HORIZONTAL;
    constraints.anchor=GridBagConstraints.BASELINE;
    constraints.gridwidth=3;
    constraints.gridheight=1;
    constraints.ipadx=100;
    constraints.gridx=11 + twoBoardsGridBagOffset;
    constraints.gridy=5;
    add(prevButton,constraints);
  }
  constraints.fill=GridBagConstraints.NONE;
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.gridwidth=3;
  constraints.gridheight=3;
  constraints.ipadx=0;
  constraints.gridx=11 + twoBoardsGridBagOffset;
  if (m_whiteTimer instanceof NoTimer) {
    constraints.gridy=6;
    constraints.insets=new Insets(10,25,0,25);
  }
 else {
    constraints.gridy=7;
    constraints.insets=new Insets(0,25,0,25);
  }
  add(m_whiteCapturePanel,constraints);
  constraints.fill=GridBagConstraints.NONE;
  constraints.anchor=GridBagConstraints.BASELINE;
  constraints.gridwidth=3;
  constraints.weightx=0.0;
  constraints.weighty=0.0;
  constraints.insets=new Insets(10,0,10,0);
  if (m_whiteTimer instanceof NoTimer) {
    constraints.gridheight=1;
    constraints.gridy=9;
  }
 else {
    constraints.gridheight=2;
    constraints.gridy=11;
  }
  constraints.ipadx=100;
  constraints.gridx=11 + twoBoardsGridBagOffset;
  add(m_whiteLabel,constraints);
}"
49913,"public static ImageIcon createImageIcon(int imageWidth,int imageHeight,String imageLocation,boolean isBuiltInFile){
  BufferedImage bufferedImage=null;
  try {
    if (isBuiltInFile)     bufferedImage=ImageIO.read(GUIUtility.class.getResource(imageLocation));
 else     bufferedImage=ImageIO.read(new File(imageLocation));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  ImageIcon imageIcon=new ImageIcon(bufferedImage);
  imageIcon.setImage(imageIcon.getImage().getScaledInstance(imageWidth,imageHeight,Image.SCALE_SMOOTH));
  return imageIcon;
}","public static ImageIcon createImageIcon(int imageWidth,int imageHeight,String imageLocation,boolean isBuiltInFile){
  try {
    BufferedImage bufferedImage;
    if (isBuiltInFile)     bufferedImage=ImageIO.read(GUIUtility.class.getResource(imageLocation));
 else     bufferedImage=ImageIO.read(new File(imageLocation));
    ImageIcon imageIcon=new ImageIcon(bufferedImage);
    imageIcon.setImage(imageIcon.getImage().getScaledInstance(imageWidth,imageHeight,Image.SCALE_SMOOTH));
    return imageIcon;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}"
49914,"/** 
 * q Convert a List of Moves to a text file of Algebraic Chess Notation Open the file to write to, then iterate through the list of Moves, printing each one in the proper format.
 * @param moves The List of Moves to convert to ACN
 * @param pathName The path to where to save the output File
 */
public static void convert(List<Move> moves,String pathName){
  try {
    BufferedWriter out=new BufferedWriter(new FileWriter(FileUtility.getCompletedGamesFile(pathName)));
    String toWrite=""String_Node_Str"";
    for (int i=0, j=1; i < moves.size(); i++) {
      String turn=moves.get(i).toString();
      if (moves.get(i).result != null) {
        turn=moves.get(i) + (i % 2 == 0 ? (""String_Node_Str"" + moves.get(i).result) : (""String_Node_Str"" + (j + 1) + ""String_Node_Str""+ moves.get(i).result));
      }
      if (i % 2 == 1 || moves.get(i).result != null) {
        out.write(j + ""String_Node_Str"" + toWrite+ ""String_Node_Str""+ turn+ '\n');
        toWrite=""String_Node_Str"";
        j++;
      }
 else {
        toWrite+=turn;
      }
    }
    out.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * q Convert a List of Moves to a text file of Algebraic Chess Notation Open the file to write to, then iterate through the list of Moves, printing each one in the proper format.
 * @param moves The List of Moves to convert to ACN
 * @param pathName The path to where to save the output File
 */
public static void convert(List<Move> moves,String pathName){
  try {
    BufferedWriter out=new BufferedWriter(new FileWriter(FileUtility.getCompletedGamesFile(pathName)));
    String toWrite=""String_Node_Str"";
    for (int i=0, j=1; i < moves.size(); i++) {
      String turn=moves.get(i).toString();
      if (moves.get(i).result != null) {
        turn=moves.get(i) + (i % 2 == 0 ? (""String_Node_Str"" + moves.get(i).result) : (""String_Node_Str"" + (j + 1) + ""String_Node_Str""+ moves.get(i).result));
      }
      if (i % 2 != 0 || moves.get(i).result != null) {
        out.write(j + ""String_Node_Str"" + toWrite+ ""String_Node_Str""+ turn+ '\n');
        toWrite=""String_Node_Str"";
        j++;
      }
 else {
        toWrite+=turn;
      }
    }
    out.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
49915,"/** 
 * This is the method to open the pop up to create a new game.
 * @param isNetwork boolean to see if this is a network game or not
 */
public void setupPopup(final boolean isNetwork){
  clicked=true;
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setLayout(new GridBagLayout());
  popup.setSize(325,225);
  popup.setResizable(false);
  popup.setLocationRelativeTo(null);
  GridBagConstraints c=new GridBagConstraints();
  String[] gametypes=Builder.getArray();
  if (isNetwork) {
    ArrayList<String> filtered=new ArrayList<String>();
    for (    String s : gametypes) {
      Game temp=Builder.newGame(s);
      if (temp.getWhiteRules().networkable() && temp.getBlackRules().networkable())       filtered.add(s);
    }
    gametypes=new String[filtered.size()];
    int i=0;
    for (    String s : filtered)     gametypes[i++]=s;
  }
  final JComboBox dropdown=new JComboBox(gametypes);
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.WEST;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(dropdown,c);
  final JButton done=new JButton(""String_Node_Str"");
  String[] timerNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox timers=new JComboBox(timerNames);
  final JLabel totalTimeText=new JLabel(""String_Node_Str"");
  totalTimeText.setVisible(false);
  final TextField totalTime=new TextField(""String_Node_Str"",3);
  totalTime.setVisible(false);
  final JLabel increaseText=new JLabel(""String_Node_Str"");
  increaseText.setVisible(false);
  final TextField increase=new TextField(""String_Node_Str"",3);
  increase.setVisible(false);
  timers.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      String timerName=(String)timers.getSelectedItem();
      if (timerName.equals(""String_Node_Str"") == false) {
        totalTimeText.setVisible(true);
        totalTime.setVisible(true);
        increaseText.setVisible(true);
        increase.setVisible(true);
      }
 else {
        totalTimeText.setVisible(false);
        totalTime.setVisible(false);
        increaseText.setVisible(false);
        increase.setVisible(false);
      }
    }
  }
);
  c.gridx=0;
  c.gridy=1;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(timers,c);
  c.gridx=0;
  c.gridy=2;
  popup.add(totalTimeText,c);
  c.gridx=1;
  c.gridy=2;
  popup.add(totalTime,c);
  c.gridx=0;
  c.gridy=3;
  c.anchor=GridBagConstraints.CENTER;
  popup.add(increaseText,c);
  c.gridx=1;
  c.gridy=3;
  popup.add(increase,c);
  popup.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
  popup.addWindowListener(new WindowListener(){
    @Override public void windowActivated(    WindowEvent arg0){
    }
    @Override public void windowClosed(    WindowEvent arg0){
    }
    @Override public void windowClosing(    WindowEvent arg0){
      clicked=false;
      popup.setVisible(false);
      popup.dispose();
    }
    @Override public void windowDeactivated(    WindowEvent arg0){
    }
    @Override public void windowDeiconified(    WindowEvent arg0){
    }
    @Override public void windowIconified(    WindowEvent arg0){
    }
    @Override public void windowOpened(    WindowEvent arg0){
    }
  }
);
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      clicked=false;
      String timerName=(String)timers.getSelectedItem();
      long startTime=Integer.parseInt(totalTime.getText()) * 1000;
      long increment=Integer.parseInt(increase.getText()) * 1000;
      ChessTimer blackTimer=null;
      ChessTimer whiteTimer=null;
      if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new NoTimer();
        whiteTimer=new NoTimer();
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new BronsteinDelay(increment,startTime,true);
        whiteTimer=new BronsteinDelay(increment,startTime,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new Fischer(increment,startTime,false,true);
        whiteTimer=new Fischer(increment,startTime,false,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new Fischer(increment,startTime,true,true);
        whiteTimer=new Fischer(increment,startTime,true,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new HourGlass(startTime / 2,true);
        whiteTimer=new HourGlass(startTime / 2,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new SimpleDelay(increment,startTime,true);
        whiteTimer=new SimpleDelay(increment,startTime,false);
      }
 else {
        blackTimer=new Word(startTime);
        whiteTimer=new Word(startTime);
      }
      if (isNetwork) {
        Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
        toPlay.setTimers(whiteTimer,blackTimer);
        final PlayNetGame game;
        if (host.equals(arg0)) {
          try {
            game=new PlayNetGame(toPlay,false,true);
          }
 catch (          Exception e) {
            return;
          }
        }
 else {
          try {
            game=new PlayNetGame(toPlay,false,false);
          }
 catch (          Exception e) {
            return;
          }
        }
        try {
          NewGameMenu.cancelled=false;
          Thread host=new Thread(new Runnable(){
            @Override public void run(){
              try {
                new NetworkServer().host(game);
              }
 catch (              Exception e) {
                e.printStackTrace();
              }
            }
          }
);
          Driver.getInstance().setPanel(new NetLoading(host));
          host.start();
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"");
          e.printStackTrace();
        }
      }
 else {
        Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
        toPlay.setTimers(whiteTimer,blackTimer);
        PlayGame game=null;
        try {
          game=new PlayGame(toPlay,false);
        }
 catch (        Exception e) {
          e.printStackTrace();
          return;
        }
        Driver.getInstance().setPanel(game);
      }
      popup.dispose();
    }
  }
);
  final JButton back=new JButton(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      clicked=false;
      popup.dispose();
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(done);
  buttons.add(back);
  c.gridx=0;
  c.gridy=4;
  c.gridwidth=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(buttons,c);
  popup.setVisible(true);
}","/** 
 * This is the method to open the pop up to create a new game.
 * @param isNetwork boolean to see if this is a network game or not
 */
public void setupPopup(final boolean isNetwork){
  clicked=true;
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setLayout(new GridBagLayout());
  popup.setSize(325,225);
  popup.setResizable(false);
  popup.setLocationRelativeTo(null);
  GridBagConstraints c=new GridBagConstraints();
  String[] gametypes=Builder.getArray();
  if (isNetwork) {
    ArrayList<String> filtered=new ArrayList<String>();
    for (    String s : gametypes) {
      Game temp=Builder.newGame(s);
      if (temp.getWhiteRules().networkable() && temp.getBlackRules().networkable())       filtered.add(s);
    }
    gametypes=new String[filtered.size()];
    int i=0;
    for (    String s : filtered)     gametypes[i++]=s;
  }
  final JComboBox dropdown=new JComboBox(gametypes);
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.WEST;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(dropdown,c);
  final JButton done=new JButton(""String_Node_Str"");
  String[] timerNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox timers=new JComboBox(timerNames);
  final JLabel totalTimeText=new JLabel(""String_Node_Str"");
  totalTimeText.setVisible(false);
  final JTextField totalTime=new JTextField(""String_Node_Str"",3);
  totalTime.setVisible(false);
  final JLabel increaseText=new JLabel(""String_Node_Str"");
  increaseText.setVisible(false);
  final JTextField increase=new JTextField(""String_Node_Str"",3);
  increase.setVisible(false);
  timers.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      String timerName=(String)timers.getSelectedItem();
      if (timerName.equals(""String_Node_Str"") == false) {
        totalTimeText.setVisible(true);
        totalTime.setVisible(true);
        increaseText.setVisible(true);
        increase.setVisible(true);
      }
 else {
        totalTimeText.setVisible(false);
        totalTime.setVisible(false);
        increaseText.setVisible(false);
        increase.setVisible(false);
      }
    }
  }
);
  c.gridx=0;
  c.gridy=1;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(timers,c);
  c.gridx=0;
  c.gridy=2;
  popup.add(totalTimeText,c);
  c.gridx=1;
  c.gridy=2;
  popup.add(totalTime,c);
  c.gridx=0;
  c.gridy=3;
  c.anchor=GridBagConstraints.CENTER;
  popup.add(increaseText,c);
  c.gridx=1;
  c.gridy=3;
  popup.add(increase,c);
  popup.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
  popup.addWindowListener(new WindowListener(){
    @Override public void windowActivated(    WindowEvent arg0){
    }
    @Override public void windowClosed(    WindowEvent arg0){
    }
    @Override public void windowClosing(    WindowEvent arg0){
      clicked=false;
      popup.setVisible(false);
      popup.dispose();
    }
    @Override public void windowDeactivated(    WindowEvent arg0){
    }
    @Override public void windowDeiconified(    WindowEvent arg0){
    }
    @Override public void windowIconified(    WindowEvent arg0){
    }
    @Override public void windowOpened(    WindowEvent arg0){
    }
  }
);
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      clicked=false;
      String timerName=(String)timers.getSelectedItem();
      long startTime=Integer.parseInt(totalTime.getText()) * 1000;
      long increment=Integer.parseInt(increase.getText()) * 1000;
      ChessTimer blackTimer=null;
      ChessTimer whiteTimer=null;
      if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new NoTimer();
        whiteTimer=new NoTimer();
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new BronsteinDelay(increment,startTime,true);
        whiteTimer=new BronsteinDelay(increment,startTime,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new Fischer(increment,startTime,false,true);
        whiteTimer=new Fischer(increment,startTime,false,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new Fischer(increment,startTime,true,true);
        whiteTimer=new Fischer(increment,startTime,true,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new HourGlass(startTime / 2,true);
        whiteTimer=new HourGlass(startTime / 2,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new SimpleDelay(increment,startTime,true);
        whiteTimer=new SimpleDelay(increment,startTime,false);
      }
 else {
        blackTimer=new Word(startTime);
        whiteTimer=new Word(startTime);
      }
      if (isNetwork) {
        Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
        toPlay.setTimers(whiteTimer,blackTimer);
        final PlayNetGame game;
        if (host.equals(arg0)) {
          try {
            game=new PlayNetGame(toPlay,false,true);
          }
 catch (          Exception e) {
            return;
          }
        }
 else {
          try {
            game=new PlayNetGame(toPlay,false,false);
          }
 catch (          Exception e) {
            return;
          }
        }
        try {
          NewGameMenu.cancelled=false;
          Thread host=new Thread(new Runnable(){
            @Override public void run(){
              try {
                new NetworkServer().host(game);
              }
 catch (              Exception e) {
                e.printStackTrace();
              }
            }
          }
);
          Driver.getInstance().setPanel(new NetLoading(host));
          host.start();
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"");
          e.printStackTrace();
        }
      }
 else {
        Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
        toPlay.setTimers(whiteTimer,blackTimer);
        PlayGame game=null;
        try {
          game=new PlayGame(toPlay,false);
        }
 catch (        Exception e) {
          e.printStackTrace();
          return;
        }
        Driver.getInstance().setPanel(game);
      }
      popup.dispose();
    }
  }
);
  final JButton back=new JButton(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      clicked=false;
      popup.dispose();
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(done);
  buttons.add(back);
  c.gridx=0;
  c.gridy=4;
  c.gridwidth=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(buttons,c);
  popup.setVisible(true);
}"
49916,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(final CustomSetupMenu variant){
  setBorder(BorderFactory.createLoweredBevelBorder());
  revalidate();
  repaint();
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      holder.removeAll();
      frame.setVisible(false);
    }
  }
);
  numBoardsLabel=new JLabel(""String_Node_Str"");
  oneBoard=new JRadioButton(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      oneBoard.requestFocus();
    }
  }
);
  oneBoard.setToolTipText(""String_Node_Str"");
  twoBoards=new JRadioButton(""String_Node_Str"");
  twoBoards.setToolTipText(""String_Node_Str"");
  Board[] board=variant.getBuilder().getBoards();
  if (board.length == 1) {
    oneBoard.setSelected(true);
  }
 else {
    twoBoards.setSelected(true);
  }
  ButtonGroup group=new ButtonGroup();
  group.add(oneBoard);
  group.add(twoBoards);
  dimensionsLabel=new JLabel(""String_Node_Str"");
  numRowsLabel=new JLabel(""String_Node_Str"");
  numRows=new JTextField(board[0].numRows() + ""String_Node_Str"");
  numRows.setToolTipText(""String_Node_Str"");
  numColsLabel=new JLabel(""String_Node_Str"");
  numCols=new JTextField(board[0].numCols() + ""String_Node_Str"");
  numCols.setToolTipText(""String_Node_Str"");
  wraparoundLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  wraparound=new JCheckBox(""String_Node_Str"");
  wraparound.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete()) {
        Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
        for (int i=0; i < boards.length; i++) {
          boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
        }
        if (twoBoards.isSelected())         variant.drawBoard(boards,true);
 else         variant.drawBoard(boards,false);
        holder.removeAll();
        frame.setVisible(false);
      }
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(numBoardsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(oneBoard)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(dimensionsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numColsLabel).addComponent(numRowsLabel)))).addGap(20,20,20)).addGroup(layout.createSequentialGroup().addGap(105,105,105).addComponent(backButton).addComponent(submitButton)).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,144,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(wraparound))).addContainerGap(10,Short.MAX_VALUE)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numCols,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(twoBoards).addComponent(numRows,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE))).addGap(10,10,10)))));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(15,15,15).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numBoardsLabel).addComponent(oneBoard).addComponent(twoBoards)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(dimensionsLabel).addComponent(numRowsLabel).addComponent(numRows,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numColsLabel).addComponent(numCols,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(5,5,5).addComponent(wraparound).addGap(5,5,5)).addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(backButton).addComponent(submitButton)).addContainerGap(15,Short.MAX_VALUE)));
  frame.pack();
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(final CustomSetupMenu variant){
  setBorder(BorderFactory.createLoweredBevelBorder());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  revalidate();
  repaint();
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      holder.removeAll();
      frame.setVisible(false);
    }
  }
);
  numBoardsLabel=new JLabel(""String_Node_Str"");
  oneBoard=new JRadioButton(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      oneBoard.requestFocus();
    }
  }
);
  oneBoard.setToolTipText(""String_Node_Str"");
  twoBoards=new JRadioButton(""String_Node_Str"");
  twoBoards.setToolTipText(""String_Node_Str"");
  JPanel boards=new JPanel();
  boards.add(oneBoard);
  boards.add(twoBoards);
  Board[] board=variant.getBuilder().getBoards();
  if (board.length == 1) {
    oneBoard.setSelected(true);
  }
 else {
    twoBoards.setSelected(true);
  }
  ButtonGroup group=new ButtonGroup();
  group.add(oneBoard);
  group.add(twoBoards);
  dimensionsLabel=new JLabel(""String_Node_Str"");
  numRowsLabel=new JLabel(""String_Node_Str"");
  numRows=new JTextField(5);
  numRows.setText(board[0].numRows() + ""String_Node_Str"");
  numRows.setToolTipText(""String_Node_Str"");
  numColsLabel=new JLabel(""String_Node_Str"");
  numCols=new JTextField(5);
  numCols.setText(board[0].numCols() + ""String_Node_Str"");
  numCols.setToolTipText(""String_Node_Str"");
  JPanel rowCol=new JPanel();
  rowCol.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=0;
  c.insets=new Insets(2,15,1,5);
  rowCol.add(numRowsLabel,c);
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.BOTH;
  rowCol.add(numRows,c);
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.NONE;
  rowCol.add(numColsLabel,c);
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  rowCol.add(numCols,c);
  wraparoundLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  wraparound=new JCheckBox(""String_Node_Str"");
  wraparound.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete()) {
        Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
        for (int i=0; i < boards.length; i++) {
          boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
        }
        if (twoBoards.isSelected())         variant.drawBoard(boards,true);
 else         variant.drawBoard(boards,false);
        holder.removeAll();
        frame.setVisible(false);
      }
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.add(submitButton);
  buttons.add(backButton);
  c.gridx=0;
  c.gridy=0;
  add(numBoardsLabel,c);
  c.gridx=1;
  c.gridy=0;
  add(boards,c);
  c.gridx=0;
  c.gridy=1;
  add(dimensionsLabel,c);
  c.gridx=1;
  c.gridy=1;
  add(rowCol,c);
  c.gridx=0;
  c.gridy=2;
  add(wraparoundLabel,c);
  c.gridx=1;
  c.gridy=2;
  c.anchor=GridBagConstraints.CENTER;
  c.fill=GridBagConstraints.NONE;
  add(wraparound,c);
  c.gridx=0;
  c.gridy=3;
  c.gridwidth=2;
  c.insets=new Insets(10,0,10,0);
  add(buttons,c);
  frame.pack();
}"
49917,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints a=new GridBagConstraints();
  setBorder(BorderFactory.createLoweredBevelBorder());
  final JPanel showPiece=new JPanel();
  showPiece.setLayout(new GridLayout(2,1));
  showPiece.setPreferredSize(new Dimension(50,100));
  showPiece.add(bShowPiece.getSquare(1,1));
  showPiece.add(bShowPiece.getSquare(2,1));
  a.gridx=5;
  a.gridy=1;
  a.gridwidth=1;
  add(showPiece,a);
  changePromote=new JButton(""String_Node_Str"");
  changePromote.setToolTipText(""String_Node_Str"");
  changePromote.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      promotion((String)piecesList.getSelectedValue());
    }
  }
);
  bShowPiece.getSquare(1,1).addMouseListener(new MouseListener(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (dragged.getPiece() != bShowPiece.getSquare(1,1).getPiece()) {
        bShowPiece.getSquare(1,1).setBackgroundColor(Square.HIGHLIGHT_COLOR);
        dragged.setPiece(bShowPiece.getSquare(1,1).getPiece());
        bShowPiece.getSquare(2,1).resetColor();
      }
 else {
        dragged.setPiece(null);
        bShowPiece.getSquare(1,1).resetColor();
      }
    }
    @Override public void mouseReleased(    MouseEvent arg0){
    }
    @Override public void mouseExited(    MouseEvent arg0){
    }
    @Override public void mouseEntered(    MouseEvent arg0){
    }
    @Override public void mouseClicked(    MouseEvent arg0){
    }
  }
);
  bShowPiece.getSquare(2,1).addMouseListener(new MouseListener(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (dragged.getPiece() != bShowPiece.getSquare(2,1).getPiece()) {
        bShowPiece.getSquare(2,1).setBackgroundColor(Square.HIGHLIGHT_COLOR);
        dragged.setPiece(bShowPiece.getSquare(2,1).getPiece());
        bShowPiece.getSquare(1,1).resetColor();
      }
 else {
        dragged.setPiece(null);
        bShowPiece.getSquare(2,1).resetColor();
      }
    }
    @Override public void mouseReleased(    MouseEvent arg0){
    }
    @Override public void mouseExited(    MouseEvent arg0){
    }
    @Override public void mouseEntered(    MouseEvent arg0){
    }
    @Override public void mouseClicked(    MouseEvent arg0){
    }
  }
);
  bShowPiece.getSquare(1,1).setBackgroundColor(Color.LIGHT_GRAY);
  bShowPiece.getSquare(2,1).setBackgroundColor(Color.getHSBColor(30,70,70));
  whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
  blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
  a.gridx=1;
  a.gridy=0;
  a.fill=GridBagConstraints.HORIZONTAL;
  a.insets=new Insets(10,10,10,5);
  add(new JLabel(""String_Node_Str""),a);
  final JTextField name=new JTextField(25);
  a.gridx=2;
  a.gridy=0;
  a.fill=GridBagConstraints.HORIZONTAL;
  a.insets=new Insets(0,0,0,0);
  add(name,a);
  Board[] temp=new Board[1];
  temp[0]=new Board(8,8,false);
  setupPieces();
  drawBoard(temp,false);
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().revertPanel();
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (name.getText().equals(""String_Node_Str"") || name.getText().equals(""String_Node_Str"")) {
        JOptionPane.showMessageDialog(getInstance(),""String_Node_Str"");
      }
 else {
        b.setName(name.getText());
        for (        Piece p : whiteTeam) {
          p.setPromotesTo(promotions.get(p.getName()));
        }
        for (        Piece p : blackTeam) {
          p.setPromotesTo(promotions.get(p.getName()));
        }
        int numObjectives=0;
        if (!whiteRules.getObjectiveName().equals(""String_Node_Str"")) {
          for (          Piece p : whiteTeam) {
            if (p.getName().equals(whiteRules.getObjectiveName()))             numObjectives++;
          }
          if (numObjectives != 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
        }
        numObjectives=0;
        if (!blackRules.getObjectiveName().equals(""String_Node_Str"")) {
          for (          Piece p : blackTeam) {
            if (p.getName().equals(blackRules.getObjectiveName()))             numObjectives++;
          }
          if (numObjectives != 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
        }
        b.whiteTeam=whiteTeam;
        boolean set=false;
        for (        Piece p : whiteTeam) {
          if (p.getName().equals(""String_Node_Str"")) {
            whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
            set=true;
            break;
          }
        }
        if (!set) {
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
        }
        b.blackTeam=blackTeam;
        set=false;
        for (        Piece p : blackTeam) {
          if (p.getName().equals(""String_Node_Str"")) {
            blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
            set=true;
            break;
          }
        }
        if (!set) {
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
        }
        b.writeFile(whiteRules,blackRules);
        Driver.getInstance().revertPanel();
      }
    }
  }
);
  JButton boardSetup=new JButton(""String_Node_Str"");
  boardSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") BoardCustomMenu makeObj=new BoardCustomMenu(getInstance(),optionsFrame);
    }
  }
);
  JButton objectivesSetup=new JButton(""String_Node_Str"");
  objectivesSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") ObjectiveMaker makeObj=new ObjectiveMaker(getInstance(),optionsFrame);
    }
  }
);
  JButton ruleSetup=new JButton(""String_Node_Str"");
  ruleSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") RuleMaker makeRules=new RuleMaker(getInstance(),optionsFrame);
    }
  }
);
  JButton playerSetup=new JButton(""String_Node_Str"");
  playerSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") PlayerCustomMenu makeObj=new PlayerCustomMenu(getInstance(),optionsFrame);
    }
  }
);
  JButton pieceSetup=new JButton(""String_Node_Str"");
  pieceSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") PieceMaker makeObj=new PieceMaker(getInstance(),optionsFrame);
    }
  }
);
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=1;
  c.gridy=1;
  c.insets=new Insets(5,3,3,3);
  pieceHolder.add(pieceSetup,c);
  c.gridx=0;
  c.gridy=2;
  pieceHolder.add(boardSetup,c);
  c.gridx=0;
  c.gridy=3;
  pieceHolder.add(objectivesSetup,c);
  c.gridx=1;
  c.gridy=3;
  pieceHolder.add(ruleSetup,c);
  c.gridx=1;
  c.gridy=2;
  pieceHolder.add(playerSetup,c);
  JPanel options=new JPanel();
  options.setLayout(new GridBagLayout());
  c.fill=GridBagConstraints.CENTER;
  c.gridx=0;
  c.gridy=1;
  options.add(backButton,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=1;
  c.gridy=1;
  options.add(submitButton,c);
  a.gridy=2;
  a.gridx=1;
  a.gridwidth=2;
  a.insets=new Insets(10,0,10,5);
  add(options,a);
  Dimension dimension=Toolkit.getDefaultToolkit().getScreenSize();
  int x=(int)((dimension.getWidth() / 4));
  int y=(int)((dimension.getHeight() / 4));
  Driver.getInstance().setLocation(x,y);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints a=new GridBagConstraints();
  setBorder(BorderFactory.createLoweredBevelBorder());
  final JPanel showPiece=new JPanel();
  showPiece.setLayout(new GridLayout(2,1));
  showPiece.setPreferredSize(new Dimension(50,100));
  showPiece.add(bShowPiece.getSquare(1,1));
  showPiece.add(bShowPiece.getSquare(2,1));
  a.gridx=5;
  a.gridy=1;
  a.gridwidth=1;
  add(showPiece,a);
  changePromote=new JButton(""String_Node_Str"");
  changePromote.setToolTipText(""String_Node_Str"");
  changePromote.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      promotion((String)piecesList.getSelectedValue());
    }
  }
);
  bShowPiece.getSquare(1,1).addMouseListener(new MouseListener(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (dragged.getPiece() != bShowPiece.getSquare(1,1).getPiece()) {
        bShowPiece.getSquare(1,1).setBackgroundColor(Square.HIGHLIGHT_COLOR);
        dragged.setPiece(bShowPiece.getSquare(1,1).getPiece());
        bShowPiece.getSquare(2,1).resetColor();
      }
 else {
        dragged.setPiece(null);
        bShowPiece.getSquare(1,1).resetColor();
      }
    }
    @Override public void mouseReleased(    MouseEvent arg0){
    }
    @Override public void mouseExited(    MouseEvent arg0){
    }
    @Override public void mouseEntered(    MouseEvent arg0){
    }
    @Override public void mouseClicked(    MouseEvent arg0){
    }
  }
);
  bShowPiece.getSquare(2,1).addMouseListener(new MouseListener(){
    @Override public void mousePressed(    MouseEvent arg0){
      if (dragged.getPiece() != bShowPiece.getSquare(2,1).getPiece()) {
        bShowPiece.getSquare(2,1).setBackgroundColor(Square.HIGHLIGHT_COLOR);
        dragged.setPiece(bShowPiece.getSquare(2,1).getPiece());
        bShowPiece.getSquare(1,1).resetColor();
      }
 else {
        dragged.setPiece(null);
        bShowPiece.getSquare(2,1).resetColor();
      }
    }
    @Override public void mouseReleased(    MouseEvent arg0){
    }
    @Override public void mouseExited(    MouseEvent arg0){
    }
    @Override public void mouseEntered(    MouseEvent arg0){
    }
    @Override public void mouseClicked(    MouseEvent arg0){
    }
  }
);
  bShowPiece.getSquare(1,1).setBackgroundColor(Color.LIGHT_GRAY);
  bShowPiece.getSquare(2,1).setBackgroundColor(Color.getHSBColor(30,70,70));
  whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
  blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
  a.gridx=1;
  a.gridy=0;
  a.fill=GridBagConstraints.HORIZONTAL;
  a.insets=new Insets(10,10,10,5);
  add(new JLabel(""String_Node_Str""),a);
  final JTextField name=new JTextField(25);
  a.gridx=2;
  a.gridy=0;
  a.fill=GridBagConstraints.HORIZONTAL;
  a.insets=new Insets(0,0,0,0);
  add(name,a);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      name.requestFocus();
    }
  }
);
  Board[] temp=new Board[1];
  temp[0]=new Board(8,8,false);
  setupPieces();
  drawBoard(temp,false);
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().revertPanel();
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (name.getText().equals(""String_Node_Str"") || name.getText().equals(""String_Node_Str"")) {
        JOptionPane.showMessageDialog(getInstance(),""String_Node_Str"");
      }
 else {
        b.setName(name.getText());
        for (        Piece p : whiteTeam) {
          p.setPromotesTo(promotions.get(p.getName()));
        }
        for (        Piece p : blackTeam) {
          p.setPromotesTo(promotions.get(p.getName()));
        }
        int numObjectives=0;
        if (!whiteRules.getObjectiveName().equals(""String_Node_Str"")) {
          for (          Piece p : whiteTeam) {
            if (p.getName().equals(whiteRules.getObjectiveName()))             numObjectives++;
          }
          if (numObjectives != 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
        }
        numObjectives=0;
        if (!blackRules.getObjectiveName().equals(""String_Node_Str"")) {
          for (          Piece p : blackTeam) {
            if (p.getName().equals(blackRules.getObjectiveName()))             numObjectives++;
          }
          if (numObjectives != 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
        }
        b.whiteTeam=whiteTeam;
        boolean set=false;
        for (        Piece p : whiteTeam) {
          if (p.getName().equals(""String_Node_Str"")) {
            whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
            set=true;
            break;
          }
        }
        if (!set) {
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
        }
        b.blackTeam=blackTeam;
        set=false;
        for (        Piece p : blackTeam) {
          if (p.getName().equals(""String_Node_Str"")) {
            blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
            set=true;
            break;
          }
        }
        if (!set) {
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
        }
        b.writeFile(whiteRules,blackRules);
        Driver.getInstance().revertPanel();
      }
    }
  }
);
  JButton boardSetup=new JButton(""String_Node_Str"");
  boardSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") BoardCustomMenu makeObj=new BoardCustomMenu(getInstance(),optionsFrame);
    }
  }
);
  JButton objectivesSetup=new JButton(""String_Node_Str"");
  objectivesSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") ObjectiveMaker makeObj=new ObjectiveMaker(getInstance(),optionsFrame);
    }
  }
);
  JButton ruleSetup=new JButton(""String_Node_Str"");
  ruleSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") RuleMaker makeRules=new RuleMaker(getInstance(),optionsFrame);
    }
  }
);
  JButton playerSetup=new JButton(""String_Node_Str"");
  playerSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") PlayerCustomMenu makeObj=new PlayerCustomMenu(getInstance(),optionsFrame);
    }
  }
);
  JButton pieceSetup=new JButton(""String_Node_Str"");
  pieceSetup.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      optionsFrame.dispose();
      optionsFrame=new JFrame();
      @SuppressWarnings(""String_Node_Str"") PieceMaker makeObj=new PieceMaker(getInstance(),optionsFrame);
    }
  }
);
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=1;
  c.gridy=1;
  c.insets=new Insets(5,3,3,3);
  pieceHolder.add(pieceSetup,c);
  c.gridx=0;
  c.gridy=2;
  pieceHolder.add(boardSetup,c);
  c.gridx=0;
  c.gridy=3;
  pieceHolder.add(objectivesSetup,c);
  c.gridx=1;
  c.gridy=3;
  pieceHolder.add(ruleSetup,c);
  c.gridx=1;
  c.gridy=2;
  pieceHolder.add(playerSetup,c);
  JPanel options=new JPanel();
  options.setLayout(new GridBagLayout());
  c.fill=GridBagConstraints.CENTER;
  c.gridx=0;
  c.gridy=1;
  options.add(submitButton,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=1;
  c.gridy=1;
  options.add(backButton,c);
  a.gridy=2;
  a.gridx=1;
  a.gridwidth=2;
  a.insets=new Insets(10,0,10,5);
  add(options,a);
  Dimension dimension=Toolkit.getDefaultToolkit().getScreenSize();
  int x=(int)((dimension.getWidth() / 4));
  int y=(int)((dimension.getHeight() / 4));
  Driver.getInstance().setLocation(x,y);
}"
49918,"/** 
 * Creates a pop up box for the Promotion Options.
 * @param type The type of piece that can be promoted.
 */
private void promotion(final String type){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(500,300);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new GridBagLayout());
  popup.setResizable(false);
  final DefaultListModel emptyList=new DefaultListModel();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    if (!allPieces[i].equals(type))     list.addElement(allPieces[i]);
  }
  final JList piecesList=new JList(list);
  final JList piecesList2=new JList(emptyList);
  final JButton moveLeft=new JButton();
  moveLeft.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      try {
        int index=piecesList2.getSelectedIndex();
        list.addElement(emptyList.elementAt(index));
        emptyList.remove(index);
      }
 catch (      Exception e) {
      }
    }
  }
);
  moveLeft.setText(""String_Node_Str"");
  final JButton moveRight=new JButton();
  moveRight.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList.getSelectedIndex();
      try {
        emptyList.addElement(list.elementAt(index));
        list.remove(index);
      }
 catch (      Exception e) {
      }
    }
  }
);
  moveRight.setText(""String_Node_Str"");
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  piecesList2.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList2.setLayoutOrientation(JList.VERTICAL);
  piecesList2.setVisibleRowCount(-1);
  piecesList2.setSelectedIndex(0);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList=piecesList.getSelectionModel();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JScrollPane scrollPane2=new JScrollPane(piecesList2);
  scrollPane2.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList2=piecesList2.getSelectionModel();
  selectList2.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList2.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JButton submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      ArrayList<String> promotesTo=new ArrayList<String>();
      for (int i=0; i < emptyList.size(); i++) {
        promotesTo.add((String)emptyList.get(i));
      }
      promotions.put(type,promotesTo);
      popup.dispose();
    }
  }
);
  JButton backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      popup.dispose();
    }
  }
);
  JPanel options=new JPanel();
  options.add(backButton);
  options.add(submitButton);
  JPanel otherCrap=new JPanel();
  otherCrap.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  otherCrap.add(moveRight,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  otherCrap.add(moveLeft,c);
  c.gridx=0;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  popup.add(scrollPane,c);
  c.gridx=1;
  c.gridy=1;
  popup.add(otherCrap,c);
  c.gridx=2;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=2;
  c.gridy=1;
  popup.add(scrollPane2,c);
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=3;
  popup.add(options,c);
  popup.setVisible(true);
}","/** 
 * Creates a pop up box for the Promotion Options.
 * @param type The type of piece that can be promoted.
 */
private void promotion(final String type){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(500,300);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new GridBagLayout());
  popup.setResizable(false);
  final DefaultListModel emptyList=new DefaultListModel();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    if (!allPieces[i].equals(type))     list.addElement(allPieces[i]);
  }
  final JList piecesList=new JList(list);
  final JList piecesList2=new JList(emptyList);
  final JButton moveLeft=new JButton();
  moveLeft.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      try {
        int index=piecesList2.getSelectedIndex();
        list.addElement(emptyList.elementAt(index));
        emptyList.remove(index);
      }
 catch (      Exception e) {
      }
    }
  }
);
  moveLeft.setText(""String_Node_Str"");
  final JButton moveRight=new JButton();
  moveRight.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList.getSelectedIndex();
      try {
        emptyList.addElement(list.elementAt(index));
        list.remove(index);
      }
 catch (      Exception e) {
      }
    }
  }
);
  moveRight.setText(""String_Node_Str"");
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  piecesList2.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList2.setLayoutOrientation(JList.VERTICAL);
  piecesList2.setVisibleRowCount(-1);
  piecesList2.setSelectedIndex(0);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList=piecesList.getSelectionModel();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JScrollPane scrollPane2=new JScrollPane(piecesList2);
  scrollPane2.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList2=piecesList2.getSelectionModel();
  selectList2.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList2.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JButton submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      ArrayList<String> promotesTo=new ArrayList<String>();
      for (int i=0; i < emptyList.size(); i++) {
        promotesTo.add((String)emptyList.get(i));
      }
      promotions.put(type,promotesTo);
      popup.dispose();
    }
  }
);
  JButton backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      popup.dispose();
    }
  }
);
  JPanel options=new JPanel();
  options.add(submitButton);
  options.add(backButton);
  JPanel otherCrap=new JPanel();
  otherCrap.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  otherCrap.add(moveRight,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  otherCrap.add(moveLeft,c);
  c.gridx=0;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  popup.add(scrollPane,c);
  c.gridx=1;
  c.gridy=1;
  popup.add(otherCrap,c);
  c.gridx=2;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=2;
  c.gridy=1;
  popup.add(scrollPane2,c);
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=3;
  popup.add(options,c);
  popup.setVisible(true);
}"
49919,"@Override public void actionPerformed(ActionEvent arg0){
  if (formComplete()) {
    Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
    for (int i=0; i < boards.length; i++) {
      boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
    }
    if (twoBoards.isSelected())     variant.drawBoard(boards,true);
 else     variant.drawBoard(boards,false);
    frame.removeAll();
    frame.dispose();
  }
}","@Override public void actionPerformed(ActionEvent arg0){
  if (formComplete()) {
    Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
    for (int i=0; i < boards.length; i++) {
      boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
    }
    if (twoBoards.isSelected())     variant.drawBoard(boards,true);
 else     variant.drawBoard(boards,false);
    holder.removeAll();
    frame.setVisible(false);
  }
}"
49920,"/** 
 * Constructor. Call initComponents to initialize the GUI.
 * @param b The builder which is creating the new game type.
 */
public BoardCustomMenu(CustomSetupMenu variant){
  frame=new JFrame();
  frame.add(this);
  frame.setVisible(true);
  frame.setSize(300,250);
  frame.setLocationRelativeTo(Driver.getInstance());
  initComponents(variant);
}","/** 
 * Constructor. Call initComponents to initialize the GUI.
 * @param b The builder which is creating the new game type.
 */
public BoardCustomMenu(CustomSetupMenu variant,JFrame optionsFrame){
  frame=optionsFrame;
  frame.setVisible(true);
  frame.add(this);
  frame.setVisible(true);
  frame.setSize(300,250);
  frame.setLocationRelativeTo(Driver.getInstance());
  initComponents(variant);
}"
49921,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(final CustomSetupMenu variant){
  setBorder(BorderFactory.createLoweredBevelBorder());
  revalidate();
  repaint();
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      frame.removeAll();
      frame.dispose();
    }
  }
);
  numBoardsLabel=new JLabel(""String_Node_Str"");
  oneBoard=new JRadioButton(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      oneBoard.requestFocus();
    }
  }
);
  oneBoard.setToolTipText(""String_Node_Str"");
  twoBoards=new JRadioButton(""String_Node_Str"");
  twoBoards.setToolTipText(""String_Node_Str"");
  Board[] board=variant.getBuilder().getBoards();
  if (board.length == 1) {
    oneBoard.setSelected(true);
  }
 else {
    twoBoards.setSelected(true);
  }
  ButtonGroup group=new ButtonGroup();
  group.add(oneBoard);
  group.add(twoBoards);
  dimensionsLabel=new JLabel(""String_Node_Str"");
  numRowsLabel=new JLabel(""String_Node_Str"");
  numRows=new JTextField(board[0].numRows() + ""String_Node_Str"");
  numRows.setToolTipText(""String_Node_Str"");
  numColsLabel=new JLabel(""String_Node_Str"");
  numCols=new JTextField(board[0].numCols() + ""String_Node_Str"");
  numCols.setToolTipText(""String_Node_Str"");
  wraparoundLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  wraparound=new JCheckBox(""String_Node_Str"");
  wraparound.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete()) {
        Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
        for (int i=0; i < boards.length; i++) {
          boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
        }
        if (twoBoards.isSelected())         variant.drawBoard(boards,true);
 else         variant.drawBoard(boards,false);
        frame.removeAll();
        frame.dispose();
      }
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(numBoardsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(oneBoard)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(dimensionsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numColsLabel).addComponent(numRowsLabel)))).addGap(20,20,20)).addGroup(layout.createSequentialGroup().addGap(105,105,105).addComponent(backButton).addComponent(submitButton)).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,144,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(wraparound))).addContainerGap(10,Short.MAX_VALUE)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numCols,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(twoBoards).addComponent(numRows,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE))).addGap(10,10,10)))));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(15,15,15).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numBoardsLabel).addComponent(oneBoard).addComponent(twoBoards)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(dimensionsLabel).addComponent(numRowsLabel).addComponent(numRows,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numColsLabel).addComponent(numCols,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(5,5,5).addComponent(wraparound).addGap(5,5,5)).addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(backButton).addComponent(submitButton)).addContainerGap(15,Short.MAX_VALUE)));
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(final CustomSetupMenu variant){
  setBorder(BorderFactory.createLoweredBevelBorder());
  revalidate();
  repaint();
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      holder.removeAll();
      frame.setVisible(false);
    }
  }
);
  numBoardsLabel=new JLabel(""String_Node_Str"");
  oneBoard=new JRadioButton(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      oneBoard.requestFocus();
    }
  }
);
  oneBoard.setToolTipText(""String_Node_Str"");
  twoBoards=new JRadioButton(""String_Node_Str"");
  twoBoards.setToolTipText(""String_Node_Str"");
  Board[] board=variant.getBuilder().getBoards();
  if (board.length == 1) {
    oneBoard.setSelected(true);
  }
 else {
    twoBoards.setSelected(true);
  }
  ButtonGroup group=new ButtonGroup();
  group.add(oneBoard);
  group.add(twoBoards);
  dimensionsLabel=new JLabel(""String_Node_Str"");
  numRowsLabel=new JLabel(""String_Node_Str"");
  numRows=new JTextField(board[0].numRows() + ""String_Node_Str"");
  numRows.setToolTipText(""String_Node_Str"");
  numColsLabel=new JLabel(""String_Node_Str"");
  numCols=new JTextField(board[0].numCols() + ""String_Node_Str"");
  numCols.setToolTipText(""String_Node_Str"");
  wraparoundLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  wraparound=new JCheckBox(""String_Node_Str"");
  wraparound.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete()) {
        Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
        for (int i=0; i < boards.length; i++) {
          boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
        }
        if (twoBoards.isSelected())         variant.drawBoard(boards,true);
 else         variant.drawBoard(boards,false);
        holder.removeAll();
        frame.setVisible(false);
      }
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(numBoardsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(oneBoard)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(dimensionsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numColsLabel).addComponent(numRowsLabel)))).addGap(20,20,20)).addGroup(layout.createSequentialGroup().addGap(105,105,105).addComponent(backButton).addComponent(submitButton)).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,144,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(wraparound))).addContainerGap(10,Short.MAX_VALUE)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numCols,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(twoBoards).addComponent(numRows,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE))).addGap(10,10,10)))));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(15,15,15).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numBoardsLabel).addComponent(oneBoard).addComponent(twoBoards)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(dimensionsLabel).addComponent(numRowsLabel).addComponent(numRows,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numColsLabel).addComponent(numCols,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(5,5,5).addComponent(wraparound).addGap(5,5,5)).addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(backButton).addComponent(submitButton)).addContainerGap(15,Short.MAX_VALUE)));
  frame.pack();
}"
49922,"@Override public void actionPerformed(ActionEvent arg0){
  if (formComplete()) {
    Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
    for (int i=0; i < boards.length; i++) {
      boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
    }
    if (twoBoards.isSelected())     variant.drawBoard(boards,true);
 else     variant.drawBoard(boards,false);
    frame.removeAll();
    frame.dispose();
  }
}","@Override public void actionPerformed(ActionEvent arg0){
  if (formComplete()) {
    Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
    for (int i=0; i < boards.length; i++) {
      boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
    }
    if (twoBoards.isSelected())     variant.drawBoard(boards,true);
 else     variant.drawBoard(boards,false);
    holder.removeAll();
    frame.setVisible(false);
  }
}"
49923,"/** 
 * Constructor. Call initComponents to initialize the GUI.
 * @param b The builder which is creating the new game type.
 */
public BoardCustomMenu(CustomSetupMenu variant){
  frame=new JFrame();
  frame.add(this);
  frame.setVisible(true);
  frame.setSize(300,250);
  frame.setLocationRelativeTo(Driver.getInstance());
  initComponents(variant);
}","/** 
 * Constructor. Call initComponents to initialize the GUI.
 * @param b The builder which is creating the new game type.
 */
public BoardCustomMenu(CustomSetupMenu variant,JFrame optionsFrame){
  frame=optionsFrame;
  frame.setVisible(true);
  frame.add(this);
  frame.setVisible(true);
  frame.setSize(300,250);
  frame.setLocationRelativeTo(Driver.getInstance());
  initComponents(variant);
}"
49924,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(final CustomSetupMenu variant){
  setBorder(BorderFactory.createLoweredBevelBorder());
  revalidate();
  repaint();
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      frame.removeAll();
      frame.dispose();
    }
  }
);
  numBoardsLabel=new JLabel(""String_Node_Str"");
  oneBoard=new JRadioButton(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      oneBoard.requestFocus();
    }
  }
);
  oneBoard.setToolTipText(""String_Node_Str"");
  twoBoards=new JRadioButton(""String_Node_Str"");
  twoBoards.setToolTipText(""String_Node_Str"");
  Board[] board=variant.getBuilder().getBoards();
  if (board.length == 1) {
    oneBoard.setSelected(true);
  }
 else {
    twoBoards.setSelected(true);
  }
  ButtonGroup group=new ButtonGroup();
  group.add(oneBoard);
  group.add(twoBoards);
  dimensionsLabel=new JLabel(""String_Node_Str"");
  numRowsLabel=new JLabel(""String_Node_Str"");
  numRows=new JTextField(board[0].numRows() + ""String_Node_Str"");
  numRows.setToolTipText(""String_Node_Str"");
  numColsLabel=new JLabel(""String_Node_Str"");
  numCols=new JTextField(board[0].numCols() + ""String_Node_Str"");
  numCols.setToolTipText(""String_Node_Str"");
  wraparoundLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  wraparound=new JCheckBox(""String_Node_Str"");
  wraparound.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete()) {
        Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
        for (int i=0; i < boards.length; i++) {
          boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
        }
        if (twoBoards.isSelected())         variant.drawBoard(boards,true);
 else         variant.drawBoard(boards,false);
        frame.removeAll();
        frame.dispose();
      }
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(numBoardsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(oneBoard)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(dimensionsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numColsLabel).addComponent(numRowsLabel)))).addGap(20,20,20)).addGroup(layout.createSequentialGroup().addGap(105,105,105).addComponent(backButton).addComponent(submitButton)).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,144,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(wraparound))).addContainerGap(10,Short.MAX_VALUE)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numCols,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(twoBoards).addComponent(numRows,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE))).addGap(10,10,10)))));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(15,15,15).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numBoardsLabel).addComponent(oneBoard).addComponent(twoBoards)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(dimensionsLabel).addComponent(numRowsLabel).addComponent(numRows,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numColsLabel).addComponent(numCols,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(5,5,5).addComponent(wraparound).addGap(5,5,5)).addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(backButton).addComponent(submitButton)).addContainerGap(15,Short.MAX_VALUE)));
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(final CustomSetupMenu variant){
  setBorder(BorderFactory.createLoweredBevelBorder());
  revalidate();
  repaint();
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      holder.removeAll();
      frame.setVisible(false);
    }
  }
);
  numBoardsLabel=new JLabel(""String_Node_Str"");
  oneBoard=new JRadioButton(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      oneBoard.requestFocus();
    }
  }
);
  oneBoard.setToolTipText(""String_Node_Str"");
  twoBoards=new JRadioButton(""String_Node_Str"");
  twoBoards.setToolTipText(""String_Node_Str"");
  Board[] board=variant.getBuilder().getBoards();
  if (board.length == 1) {
    oneBoard.setSelected(true);
  }
 else {
    twoBoards.setSelected(true);
  }
  ButtonGroup group=new ButtonGroup();
  group.add(oneBoard);
  group.add(twoBoards);
  dimensionsLabel=new JLabel(""String_Node_Str"");
  numRowsLabel=new JLabel(""String_Node_Str"");
  numRows=new JTextField(board[0].numRows() + ""String_Node_Str"");
  numRows.setToolTipText(""String_Node_Str"");
  numColsLabel=new JLabel(""String_Node_Str"");
  numCols=new JTextField(board[0].numCols() + ""String_Node_Str"");
  numCols.setToolTipText(""String_Node_Str"");
  wraparoundLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  wraparound=new JCheckBox(""String_Node_Str"");
  wraparound.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete()) {
        Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
        for (int i=0; i < boards.length; i++) {
          boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
        }
        if (twoBoards.isSelected())         variant.drawBoard(boards,true);
 else         variant.drawBoard(boards,false);
        holder.removeAll();
        frame.setVisible(false);
      }
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(numBoardsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(oneBoard)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(dimensionsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numColsLabel).addComponent(numRowsLabel)))).addGap(20,20,20)).addGroup(layout.createSequentialGroup().addGap(105,105,105).addComponent(backButton).addComponent(submitButton)).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,144,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(wraparound))).addContainerGap(10,Short.MAX_VALUE)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numCols,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(twoBoards).addComponent(numRows,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE))).addGap(10,10,10)))));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(15,15,15).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numBoardsLabel).addComponent(oneBoard).addComponent(twoBoards)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(dimensionsLabel).addComponent(numRowsLabel).addComponent(numRows,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numColsLabel).addComponent(numCols,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(5,5,5).addComponent(wraparound).addGap(5,5,5)).addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(backButton).addComponent(submitButton)).addContainerGap(15,Short.MAX_VALUE)));
  frame.pack();
}"
49925,"/** 
 * This is the method to open the pop up to create a new game.
 * @param isNetwork boolean to see if this is a network game or not
 */
public void setupPopup(final boolean isNetwork){
  clicked=true;
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setLayout(new GridBagLayout());
  popup.setSize(325,225);
  popup.setResizable(false);
  popup.setLocationRelativeTo(null);
  GridBagConstraints c=new GridBagConstraints();
  String[] gametypes=Builder.getArray();
  if (isNetwork) {
    ArrayList<String> filtered=new ArrayList<String>();
    for (    String s : gametypes) {
      Game temp=Builder.newGame(s);
      if (temp.getWhiteRules().networkable() && temp.getBlackRules().networkable())       filtered.add(s);
    }
    gametypes=new String[filtered.size()];
    int i=0;
    for (    String s : filtered)     gametypes[i++]=s;
  }
  final JComboBox dropdown=new JComboBox(gametypes);
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.WEST;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(dropdown,c);
  final JButton done=new JButton(""String_Node_Str"");
  String[] timerNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox timers=new JComboBox(timerNames);
  final JLabel totalTimeText=new JLabel(""String_Node_Str"");
  totalTimeText.setVisible(false);
  final TextField totalTime=new TextField(""String_Node_Str"",3);
  totalTime.setVisible(false);
  final JLabel increaseText=new JLabel(""String_Node_Str"");
  increaseText.setVisible(false);
  final TextField increase=new TextField(""String_Node_Str"",3);
  increase.setVisible(false);
  timers.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      String timerName=(String)timers.getSelectedItem();
      if (timerName.equals(""String_Node_Str"") == false) {
        totalTimeText.setVisible(true);
        totalTime.setVisible(true);
        increaseText.setVisible(true);
        increase.setVisible(true);
      }
 else {
        totalTimeText.setVisible(false);
        totalTime.setVisible(false);
        increaseText.setVisible(false);
        increase.setVisible(false);
      }
    }
  }
);
  c.gridx=0;
  c.gridy=1;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(timers,c);
  c.gridx=0;
  c.gridy=2;
  popup.add(totalTimeText,c);
  c.gridx=1;
  c.gridy=2;
  popup.add(totalTime,c);
  c.gridx=0;
  c.gridy=3;
  c.anchor=GridBagConstraints.CENTER;
  popup.add(increaseText,c);
  c.gridx=1;
  c.gridy=3;
  popup.add(increase,c);
  popup.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
  popup.addWindowListener(new WindowListener(){
    @Override public void windowActivated(    WindowEvent arg0){
    }
    @Override public void windowClosed(    WindowEvent arg0){
    }
    @Override public void windowClosing(    WindowEvent arg0){
      clicked=false;
      popup.setVisible(false);
      popup.dispose();
    }
    @Override public void windowDeactivated(    WindowEvent arg0){
    }
    @Override public void windowDeiconified(    WindowEvent arg0){
    }
    @Override public void windowIconified(    WindowEvent arg0){
    }
    @Override public void windowOpened(    WindowEvent arg0){
    }
  }
);
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      clicked=false;
      String timerName=(String)timers.getSelectedItem();
      long startTime=Integer.parseInt(totalTime.getText()) * 1000;
      long increment=Integer.parseInt(increase.getText()) * 1000;
      ChessTimer blackTimer=null;
      ChessTimer whiteTimer=null;
      if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new NoTimer();
        whiteTimer=new NoTimer();
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new BronsteinDelay(increment,startTime,true);
        whiteTimer=new BronsteinDelay(increment,startTime,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new Fischer(increment,startTime,false,true);
        whiteTimer=new Fischer(increment,startTime,false,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new Fischer(increment,startTime,true,true);
        whiteTimer=new Fischer(increment,startTime,true,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new HourGlass(startTime / 2,true);
        whiteTimer=new HourGlass(startTime / 2,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new SimpleDelay(increment,startTime,true);
        whiteTimer=new SimpleDelay(increment,startTime,false);
      }
 else {
        blackTimer=new Word(startTime);
        whiteTimer=new Word(startTime);
      }
      if (isNetwork) {
        Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
        toPlay.setTimers(whiteTimer,blackTimer);
        final PlayNetGame game;
        if (host.equals(arg0)) {
          try {
            game=new PlayNetGame(toPlay,false,true);
          }
 catch (          Exception e) {
            return;
          }
        }
 else {
          try {
            game=new PlayNetGame(toPlay,false,false);
          }
 catch (          Exception e) {
            return;
          }
        }
        try {
          NewGameMenu.cancelled=false;
          Thread host=new Thread(new Runnable(){
            @Override public void run(){
              try {
                new NetworkServer().host(game);
              }
 catch (              Exception e) {
                e.printStackTrace();
              }
            }
          }
);
          Driver.getInstance().setPanel(new NetLoading(host));
          host.start();
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"");
          e.printStackTrace();
        }
      }
 else {
        Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
        toPlay.setTimers(whiteTimer,blackTimer);
        PlayGame game=null;
        try {
          game=new PlayGame(toPlay,false);
        }
 catch (        Exception e) {
          e.printStackTrace();
          return;
        }
        Driver.getInstance().setPanel(game);
      }
      popup.dispose();
    }
  }
);
  final JButton back=new JButton(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      clicked=false;
      popup.dispose();
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(done);
  buttons.add(back);
  c.gridx=0;
  c.gridy=4;
  c.gridwidth=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(buttons,c);
  popup.setVisible(true);
}","/** 
 * This is the method to open the pop up to create a new game.
 * @param isNetwork boolean to see if this is a network game or not
 */
public void setupPopup(final boolean isNetwork){
  clicked=true;
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setLayout(new GridBagLayout());
  popup.setSize(325,225);
  popup.setResizable(false);
  popup.setLocationRelativeTo(null);
  GridBagConstraints c=new GridBagConstraints();
  String[] gametypes=Builder.getArray();
  if (isNetwork) {
    ArrayList<String> filtered=new ArrayList<String>();
    for (    String s : gametypes) {
      Game temp=Builder.newGame(s);
      if (temp.getWhiteRules().networkable() && temp.getBlackRules().networkable())       filtered.add(s);
    }
    gametypes=new String[filtered.size()];
    int i=0;
    for (    String s : filtered)     gametypes[i++]=s;
  }
  final JComboBox dropdown=new JComboBox(gametypes);
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.WEST;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(dropdown,c);
  final JButton done=new JButton(""String_Node_Str"");
  String[] timerNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox timers=new JComboBox(timerNames);
  final JLabel totalTimeText=new JLabel(""String_Node_Str"");
  totalTimeText.setVisible(false);
  final JTextField totalTime=new JTextField(""String_Node_Str"",3);
  totalTime.setVisible(false);
  final JLabel increaseText=new JLabel(""String_Node_Str"");
  increaseText.setVisible(false);
  final JTextField increase=new JTextField(""String_Node_Str"",3);
  increase.setVisible(false);
  timers.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      String timerName=(String)timers.getSelectedItem();
      if (timerName.equals(""String_Node_Str"") == false) {
        totalTimeText.setVisible(true);
        totalTime.setVisible(true);
        increaseText.setVisible(true);
        increase.setVisible(true);
      }
 else {
        totalTimeText.setVisible(false);
        totalTime.setVisible(false);
        increaseText.setVisible(false);
        increase.setVisible(false);
      }
    }
  }
);
  c.gridx=0;
  c.gridy=1;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(timers,c);
  c.gridx=0;
  c.gridy=2;
  popup.add(totalTimeText,c);
  c.gridx=1;
  c.gridy=2;
  popup.add(totalTime,c);
  c.gridx=0;
  c.gridy=3;
  c.anchor=GridBagConstraints.CENTER;
  popup.add(increaseText,c);
  c.gridx=1;
  c.gridy=3;
  popup.add(increase,c);
  popup.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
  popup.addWindowListener(new WindowListener(){
    @Override public void windowActivated(    WindowEvent arg0){
    }
    @Override public void windowClosed(    WindowEvent arg0){
    }
    @Override public void windowClosing(    WindowEvent arg0){
      clicked=false;
      popup.setVisible(false);
      popup.dispose();
    }
    @Override public void windowDeactivated(    WindowEvent arg0){
    }
    @Override public void windowDeiconified(    WindowEvent arg0){
    }
    @Override public void windowIconified(    WindowEvent arg0){
    }
    @Override public void windowOpened(    WindowEvent arg0){
    }
  }
);
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      clicked=false;
      String timerName=(String)timers.getSelectedItem();
      long startTime=Integer.parseInt(totalTime.getText()) * 1000;
      long increment=Integer.parseInt(increase.getText()) * 1000;
      ChessTimer blackTimer=null;
      ChessTimer whiteTimer=null;
      if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new NoTimer();
        whiteTimer=new NoTimer();
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new BronsteinDelay(increment,startTime,true);
        whiteTimer=new BronsteinDelay(increment,startTime,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new Fischer(increment,startTime,false,true);
        whiteTimer=new Fischer(increment,startTime,false,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new Fischer(increment,startTime,true,true);
        whiteTimer=new Fischer(increment,startTime,true,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new HourGlass(startTime / 2,true);
        whiteTimer=new HourGlass(startTime / 2,false);
      }
 else       if (timerName.equals(""String_Node_Str"")) {
        blackTimer=new SimpleDelay(increment,startTime,true);
        whiteTimer=new SimpleDelay(increment,startTime,false);
      }
 else {
        blackTimer=new Word(startTime);
        whiteTimer=new Word(startTime);
      }
      if (isNetwork) {
        Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
        toPlay.setTimers(whiteTimer,blackTimer);
        final PlayNetGame game;
        if (host.equals(arg0)) {
          try {
            game=new PlayNetGame(toPlay,false,true);
          }
 catch (          Exception e) {
            return;
          }
        }
 else {
          try {
            game=new PlayNetGame(toPlay,false,false);
          }
 catch (          Exception e) {
            return;
          }
        }
        try {
          NewGameMenu.cancelled=false;
          Thread host=new Thread(new Runnable(){
            @Override public void run(){
              try {
                new NetworkServer().host(game);
              }
 catch (              Exception e) {
                e.printStackTrace();
              }
            }
          }
);
          Driver.getInstance().setPanel(new NetLoading(host));
          host.start();
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"");
          e.printStackTrace();
        }
      }
 else {
        Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
        toPlay.setTimers(whiteTimer,blackTimer);
        PlayGame game=null;
        try {
          game=new PlayGame(toPlay,false);
        }
 catch (        Exception e) {
          e.printStackTrace();
          return;
        }
        Driver.getInstance().setPanel(game);
      }
      popup.dispose();
    }
  }
);
  final JButton back=new JButton(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      clicked=false;
      popup.dispose();
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(done);
  buttons.add(back);
  c.gridx=0;
  c.gridy=4;
  c.gridwidth=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  popup.add(buttons,c);
  popup.setVisible(true);
}"
49926,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 * @param isPlayback whether PlayGame is in playback mode
 * @throws Exception catches game history file failure.
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback) throws Exception {
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  undoItem=new JButton(""String_Node_Str"");
  undoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      mustMove=false;
      if (getGame().getHistory().size() == 0)       return;
      try {
        getGame().getHistory().get(getGame().getHistory().size() - 1).undo();
      }
 catch (      Exception e) {
      }
      getGame().getHistory().remove(getGame().getHistory().size() - 1);
      (getGame().isBlackMove() ? getGame().getBlackRules() : getGame().getWhiteRules()).undoEndOfGame();
      boardRefresh(getGame().getBoards());
    }
  }
);
  int ifDouble=0;
  if (menu == null)   Driver.getInstance().setMenu(createMenu());
 else   if (!menu.isVisible())   Driver.getInstance().setMenu(createMenu());
  Driver.gameOptions.setVisible(true);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      try {
        history[index--].undo();
      }
 catch (      Exception e1) {
      }
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  if (k < 4) {
    whiteCapturesBox=new Jail(4,4);
    whiteCaptures.setLayout(new GridLayout(4,4));
  }
 else {
    whiteCapturesBox=new Jail(k,k);
    whiteCaptures.setLayout(new GridLayout(k,k));
  }
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      Square whiteJail=new Square(i,j);
      whiteCaptures.add(whiteJail);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  if (k < 4) {
    blackCapturesBox=new Jail(4,4);
    blackCaptures.setLayout(new GridLayout(4,4));
  }
 else {
    blackCapturesBox=new Jail(k,k);
    blackCaptures.setLayout(new GridLayout(k,k));
  }
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      Square blackJail=new Square(i,j);
      blackCaptures.add(blackJail);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(undoItem,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 * @param isPlayback whether PlayGame is in playback mode
 * @throws Exception catches game history file failure.
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback) throws Exception {
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  undoItem=new JButton(""String_Node_Str"");
  undoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      mustMove=false;
      if (getGame().getHistory().size() == 0)       return;
      try {
        getGame().getHistory().get(getGame().getHistory().size() - 1).undo();
      }
 catch (      Exception e) {
      }
      getGame().getHistory().remove(getGame().getHistory().size() - 1);
      (getGame().isBlackMove() ? getGame().getBlackRules() : getGame().getWhiteRules()).undoEndOfGame();
      boardRefresh(getGame().getBoards());
    }
  }
);
  int ifDouble=0;
  if (menu == null)   Driver.getInstance().setMenu(createMenu());
 else   if (!menu.isVisible())   Driver.getInstance().setMenu(createMenu());
  if (!isPlayback) {
    Driver.gameOptions.setVisible(true);
  }
 else {
    Driver.gameOptions.setVisible(false);
  }
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      try {
        history[index--].undo();
      }
 catch (      Exception e1) {
      }
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  if (k < 4) {
    whiteCapturesBox=new Jail(4,4);
    whiteCaptures.setLayout(new GridLayout(4,4));
  }
 else {
    whiteCapturesBox=new Jail(k,k);
    whiteCaptures.setLayout(new GridLayout(k,k));
  }
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      Square whiteJail=new Square(i,j);
      whiteCaptures.add(whiteJail);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  if (k < 4) {
    blackCapturesBox=new Jail(4,4);
    blackCaptures.setLayout(new GridLayout(4,4));
  }
 else {
    blackCapturesBox=new Jail(k,k);
    blackCaptures.setLayout(new GridLayout(k,k));
  }
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      Square blackJail=new Square(i,j);
      blackCaptures.add(blackJail);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(undoItem,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}"
49927,"@Override public void mousePressed(MouseEvent e){
}","@Override public void mousePressed(MouseEvent e){
  if (mustPlace) {
    mustPlace=false;
    getGame().nextTurn();
    if (!clickedSquare.isOccupied() && clickedSquare.isHabitable() && placePiece != null) {
      placePiece.setSquare(clickedSquare);
      clickedSquare.setPiece(placePiece);
      placePiece=null;
      mustPlace=false;
      boardRefresh(getGame().getBoards());
      getGame().genLegalDests();
    }
    return;
  }
  if (mustMove && clickedSquare == storedSquare) {
    boardRefresh(getGame().getBoards());
    mustMove=false;
  }
 else   if (mustMove && clickedSquare.getColor() == Square.HIGHLIGHT_COLOR) {
    try {
      getGame().playMove(new Move(b,storedSquare,clickedSquare));
      mustMove=false;
      boardRefresh(getGame().getBoards());
    }
 catch (    Exception e1) {
      System.out.println(e1.getMessage());
      e1.printStackTrace();
    }
  }
 else   if (!mustMove && clickedSquare.getPiece() != null && clickedSquare.getPiece().isBlack() == getGame().isBlackMove()) {
    List<Square> dests=clickedSquare.getPiece().getLegalDests();
    if (dests.size() > 0) {
      for (      Square dest : dests) {
        dest.setBackgroundColor(Square.HIGHLIGHT_COLOR);
      }
      storedSquare=clickedSquare;
      mustMove=true;
    }
  }
}"
49928,"/** 
 * Control movement of pieces. Check if the Square is occupied and either highlight possible destinations or move the piece.
 */
@Override public void mouseClicked(MouseEvent e){
  if (mustPlace) {
    mustPlace=false;
    getGame().nextTurn();
    if (!clickedSquare.isOccupied() && clickedSquare.isHabitable() && placePiece != null) {
      placePiece.setSquare(clickedSquare);
      clickedSquare.setPiece(placePiece);
      placePiece=null;
      mustPlace=false;
      boardRefresh(getGame().getBoards());
      getGame().genLegalDests();
    }
    return;
  }
  if (mustMove && clickedSquare == storedSquare) {
    boardRefresh(getGame().getBoards());
    mustMove=false;
  }
 else   if (mustMove && clickedSquare.getColor() == Square.HIGHLIGHT_COLOR) {
    try {
      getGame().playMove(new Move(b,storedSquare,clickedSquare));
      mustMove=false;
      boardRefresh(getGame().getBoards());
    }
 catch (    Exception e1) {
      System.out.println(e1.getMessage());
      e1.printStackTrace();
    }
  }
 else   if (!mustMove && clickedSquare.getPiece() != null && clickedSquare.getPiece().isBlack() == getGame().isBlackMove()) {
    List<Square> dests=clickedSquare.getPiece().getLegalDests();
    if (dests.size() > 0) {
      for (      Square dest : dests) {
        dest.setBackgroundColor(Square.HIGHLIGHT_COLOR);
      }
      storedSquare=clickedSquare;
      mustMove=true;
    }
  }
}","/** 
 * Control movement of pieces. Check if the Square is occupied and either highlight possible destinations or move the piece.
 */
@Override public void mouseClicked(MouseEvent e){
}"
49929,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setBorder(BorderFactory.createLoweredBevelBorder());
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().setPanel(new NewTypeMenu());
    }
  }
);
  numBoardsLabel=new JLabel(""String_Node_Str"");
  oneBoard=new JRadioButton(""String_Node_Str"");
  oneBoard.setToolTipText(""String_Node_Str"");
  oneBoard.setSelected(true);
  twoBoards=new JRadioButton(""String_Node_Str"");
  twoBoards.setToolTipText(""String_Node_Str"");
  ButtonGroup group=new ButtonGroup();
  group.add(oneBoard);
  group.add(twoBoards);
  dimensionsLabel=new JLabel(""String_Node_Str"");
  numRowsLabel=new JLabel(""String_Node_Str"");
  numRows=new JTextField(""String_Node_Str"");
  numRows.setToolTipText(""String_Node_Str"");
  numColsLabel=new JLabel(""String_Node_Str"");
  numCols=new JTextField(""String_Node_Str"");
  numCols.setToolTipText(""String_Node_Str"");
  wraparoundLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  wraparound=new JCheckBox(""String_Node_Str"");
  wraparound.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete()) {
        Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
        for (int i=0; i < boards.length; i++) {
          boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
        }
        b.setBoards(boards);
        Driver.getInstance().setPanel(new PieceMaker(b));
      }
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(numBoardsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(oneBoard)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(dimensionsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numColsLabel).addComponent(numRowsLabel)))).addGap(20,20,20)).addGroup(layout.createSequentialGroup().addGap(105,105,105).addComponent(backButton).addComponent(submitButton)).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,144,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(wraparound))).addContainerGap(10,Short.MAX_VALUE)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numCols,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(twoBoards).addComponent(numRows,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE))).addGap(10,10,10)))));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(15,15,15).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numBoardsLabel).addComponent(oneBoard).addComponent(twoBoards)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(dimensionsLabel).addComponent(numRowsLabel).addComponent(numRows,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numColsLabel).addComponent(numCols,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(5,5,5).addComponent(wraparound).addGap(5,5,5)).addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(backButton).addComponent(submitButton)).addContainerGap(15,Short.MAX_VALUE)));
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setBorder(BorderFactory.createLoweredBevelBorder());
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().setPanel(new NewTypeMenu());
    }
  }
);
  numBoardsLabel=new JLabel(""String_Node_Str"");
  oneBoard=new JRadioButton(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      oneBoard.requestFocus();
    }
  }
);
  oneBoard.setToolTipText(""String_Node_Str"");
  oneBoard.setSelected(true);
  twoBoards=new JRadioButton(""String_Node_Str"");
  twoBoards.setToolTipText(""String_Node_Str"");
  ButtonGroup group=new ButtonGroup();
  group.add(oneBoard);
  group.add(twoBoards);
  dimensionsLabel=new JLabel(""String_Node_Str"");
  numRowsLabel=new JLabel(""String_Node_Str"");
  numRows=new JTextField(""String_Node_Str"");
  numRows.setToolTipText(""String_Node_Str"");
  numColsLabel=new JLabel(""String_Node_Str"");
  numCols=new JTextField(""String_Node_Str"");
  numCols.setToolTipText(""String_Node_Str"");
  wraparoundLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  wraparound=new JCheckBox(""String_Node_Str"");
  wraparound.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete()) {
        Board[] boards=(oneBoard.isSelected()) ? new Board[1] : new Board[2];
        for (int i=0; i < boards.length; i++) {
          boards[i]=new Board(Integer.parseInt(numRows.getText()),Integer.parseInt(numCols.getText()),wraparound.isSelected());
        }
        b.setBoards(boards);
        Driver.getInstance().setPanel(new PieceMaker(b));
      }
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addComponent(numBoardsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(oneBoard)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(dimensionsLabel,GroupLayout.DEFAULT_SIZE,157,Short.MAX_VALUE).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numColsLabel).addComponent(numRowsLabel)))).addGap(20,20,20)).addGroup(layout.createSequentialGroup().addGap(105,105,105).addComponent(backButton).addComponent(submitButton)).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,144,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(wraparound))).addContainerGap(10,Short.MAX_VALUE)).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addComponent(numCols,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(twoBoards).addComponent(numRows,GroupLayout.PREFERRED_SIZE,46,GroupLayout.PREFERRED_SIZE))).addGap(10,10,10)))));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(15,15,15).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numBoardsLabel).addComponent(oneBoard).addComponent(twoBoards)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(dimensionsLabel).addComponent(numRowsLabel).addComponent(numRows,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(numColsLabel).addComponent(numCols,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(5,5,5).addComponent(wraparound).addGap(5,5,5)).addComponent(wraparoundLabel,GroupLayout.PREFERRED_SIZE,GroupLayout.DEFAULT_SIZE,GroupLayout.PREFERRED_SIZE)).addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(backButton).addComponent(submitButton)).addContainerGap(15,Short.MAX_VALUE)));
}"
49930,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setResizable(false);
  setLocationRelativeTo(null);
  setResizable(false);
  setLayout(new FlowLayout());
  setResizable(true);
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
  }
  mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  BufferedImage temp=null;
  try {
    temp=ImageIO.read(getClass().getResource(""String_Node_Str""));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  ImageIcon picture=new ImageIcon(temp);
  JLabel pictureHolder=new JLabel();
  picture.setImage(picture.getImage().getScaledInstance(300,200,Image.SCALE_SMOOTH));
  pictureHolder.setIcon(picture);
  newGame=new JButton(""String_Node_Str"");
  newGame.setToolTipText(""String_Node_Str"");
  newGame.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      setPanel(otherPanel);
      pack();
    }
  }
);
  continueGame=new JButton(""String_Node_Str"");
  continueGame.setToolTipText(""String_Node_Str"");
  continueGame.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      try {
        String[] files=FileUtility.getGamesInProgressFileArray();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        FileInputStream f_in=new FileInputStream(FileUtility.getGamesInProgressFile(choice));
        ObjectInputStream obj_in=new ObjectInputStream(f_in);
        Game toPlay=(Game)obj_in.readObject();
        if (gameOptions != null)         gameOptions.setVisible(true);
        remove(mainPanel);
        otherPanel=new PlayGame(toPlay,false);
        setPanel(otherPanel);
        pack();
      }
 catch (      Exception e) {
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  viewGame=new JButton(""String_Node_Str"");
  viewGame.setToolTipText(""String_Node_Str"");
  viewGame.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      try {
        String[] files=FileUtility.getCompletedGamesFileArray();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        File file=FileUtility.getCompletedGamesFile(choice);
        Game toView;
        if (choice.endsWith(""String_Node_Str"")) {
          try {
            otherPanel=new PlayGame(true,file);
          }
 catch (          Exception e) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
        }
 else {
          FileInputStream f_in=new FileInputStream(file);
          ObjectInputStream obj_in=new ObjectInputStream(f_in);
          toView=(Game)obj_in.readObject();
          otherPanel=new PlayGame(toView,true);
        }
        remove(mainPanel);
        setPanel(otherPanel);
        pack();
      }
 catch (      Exception e) {
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  createType=new JButton(""String_Node_Str"");
  createType.setToolTipText(""String_Node_Str"");
  createType.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      remove(mainPanel);
      otherPanel=new NewTypeMenu();
      setPanel(otherPanel);
      pack();
    }
  }
);
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  fileMenu.setMnemonic('F');
  helpMenu=new JMenu(""String_Node_Str"");
  helpMenu.setMnemonic('H');
  final JFrame help=setUpHelp();
  final JFrame about=setUpAbout();
  JMenuItem helpMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_H);
  helpMenuItem.setToolTipText(""String_Node_Str"");
  helpMenuItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      help.setVisible(true);
    }
  }
);
  helpMenu.add(helpMenuItem);
  JMenuItem aboutItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_A);
  aboutItem.setToolTipText(""String_Node_Str"");
  aboutItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      about.setVisible(true);
    }
  }
);
  helpMenu.add(aboutItem);
  JMenuItem newGameItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  newGameItem.setToolTipText(""String_Node_Str"");
  newGameItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      setPanel(otherPanel);
      pack();
    }
  }
);
  fileMenu.add(newGameItem);
  mainMenu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_M);
  mainMenu.setToolTipText(""String_Node_Str"");
  mainMenu.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (gameOptions != null)       gameOptions.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      ChessTimer.stopTimers();
      add(mainPanel);
      pack();
    }
  }
);
  mainMenu.setVisible(false);
  fileMenu.add(mainMenu);
  JMenuItem exitMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_Q);
  exitMenuItem.setToolTipText(""String_Node_Str"");
  exitMenuItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
      if (answer == 0)       System.exit(0);
    }
  }
);
  fileMenu.add(exitMenuItem);
  menuBar.add(fileMenu);
  menuBar.add(helpMenu);
  setJMenuBar(menuBar);
  mainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=0;
  mainPanel.add(pictureHolder,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  mainPanel.add(newGame,c);
  c.gridx=2;
  c.gridy=1;
  c.gridwidth=1;
  mainPanel.add(createType,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mainPanel.add(continueGame,c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mainPanel.add(viewGame,c);
  add(mainPanel);
  setVisible(true);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setResizable(false);
  setLocationRelativeTo(null);
  setResizable(false);
  setLayout(new FlowLayout());
  setResizable(true);
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
  }
  mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  BufferedImage temp=null;
  try {
    temp=ImageIO.read(getClass().getResource(""String_Node_Str""));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  ImageIcon picture=new ImageIcon(temp);
  JLabel pictureHolder=new JLabel();
  picture.setImage(picture.getImage().getScaledInstance(300,200,Image.SCALE_SMOOTH));
  pictureHolder.setIcon(picture);
  newGame=new JButton(""String_Node_Str"");
  newGame.setToolTipText(""String_Node_Str"");
  newGame.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      setPanel(otherPanel);
      pack();
    }
  }
);
  continueGame=new JButton(""String_Node_Str"");
  continueGame.setToolTipText(""String_Node_Str"");
  continueGame.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      try {
        String[] files=FileUtility.getGamesInProgressFileArray();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        FileInputStream f_in=new FileInputStream(FileUtility.getGamesInProgressFile(choice));
        ObjectInputStream obj_in=new ObjectInputStream(f_in);
        Game toPlay=(Game)obj_in.readObject();
        if (gameOptions != null)         gameOptions.setVisible(true);
        remove(mainPanel);
        otherPanel=new PlayGame(toPlay,false);
        setPanel(otherPanel);
        pack();
      }
 catch (      Exception e) {
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  viewGame=new JButton(""String_Node_Str"");
  viewGame.setToolTipText(""String_Node_Str"");
  viewGame.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      try {
        String[] files=FileUtility.getCompletedGamesFileArray();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        File file=FileUtility.getCompletedGamesFile(choice);
        Game toView;
        if (choice.endsWith(""String_Node_Str"")) {
          try {
            otherPanel=new PlayGame(true,file);
          }
 catch (          Exception e) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
        }
 else {
          FileInputStream f_in=new FileInputStream(file);
          ObjectInputStream obj_in=new ObjectInputStream(f_in);
          toView=(Game)obj_in.readObject();
          otherPanel=new PlayGame(toView,true);
        }
        remove(mainPanel);
        setPanel(otherPanel);
        pack();
      }
 catch (      Exception e) {
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  createType=new JButton(""String_Node_Str"");
  createType.setToolTipText(""String_Node_Str"");
  createType.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      remove(mainPanel);
      otherPanel=new NewTypeMenu();
      setPanel(otherPanel);
      pack();
    }
  }
);
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  fileMenu.setMnemonic('F');
  helpMenu=new JMenu(""String_Node_Str"");
  helpMenu.setMnemonic('H');
  final JFrame help=setUpHelp();
  final JFrame about=setUpAbout();
  JMenuItem helpMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_H);
  helpMenuItem.setToolTipText(""String_Node_Str"");
  helpMenuItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      help.setVisible(true);
    }
  }
);
  helpMenu.add(helpMenuItem);
  JMenuItem aboutItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_A);
  aboutItem.setToolTipText(""String_Node_Str"");
  aboutItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      about.setVisible(true);
    }
  }
);
  helpMenu.add(aboutItem);
  JMenuItem newGameItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  newGameItem.setToolTipText(""String_Node_Str"");
  newGameItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      remove(mainPanel);
      if (otherPanel != null)       remove(otherPanel);
      otherPanel=new NewGameMenu();
      setPanel(otherPanel);
      pack();
    }
  }
);
  fileMenu.add(newGameItem);
  mainMenu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_M);
  mainMenu.setToolTipText(""String_Node_Str"");
  mainMenu.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (gameOptions != null)       gameOptions.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      ChessTimer.stopTimers();
      add(mainPanel);
      pack();
    }
  }
);
  mainMenu.setVisible(false);
  fileMenu.add(mainMenu);
  JMenuItem exitMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_Q);
  exitMenuItem.setToolTipText(""String_Node_Str"");
  exitMenuItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
      if (answer == 0)       System.exit(0);
    }
  }
);
  fileMenu.add(exitMenuItem);
  menuBar.add(fileMenu);
  menuBar.add(helpMenu);
  setJMenuBar(menuBar);
  mainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=0;
  mainPanel.add(pictureHolder,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  mainPanel.add(newGame,c);
  c.gridx=2;
  c.gridy=1;
  c.gridwidth=1;
  mainPanel.add(createType,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mainPanel.add(continueGame,c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mainPanel.add(viewGame,c);
  add(mainPanel);
  setVisible(true);
}"
49931,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        setupPopup(false);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  networkPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame pop=new JFrame(""String_Node_Str"");
      pop.setLayout(new FlowLayout());
      pop.setSize(350,150);
      pop.setResizable(false);
      pop.setLocationRelativeTo(null);
      JPanel options=new JPanel();
      final JLabel label=new JLabel(""String_Node_Str"");
      final JButton client=new JButton(""String_Node_Str"");
      client.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final JFrame popped=new JFrame(""String_Node_Str"");
          popped.setLayout(new GridBagLayout());
          popped.setSize(370,150);
          popped.setResizable(false);
          popped.setLocationRelativeTo(null);
          GridBagConstraints c=new GridBagConstraints();
          final JLabel hoster=new JLabel(""String_Node_Str"");
          final JTextField computer=new JTextField(""String_Node_Str"",2);
          final JButton save=new JButton(""String_Node_Str"");
          save.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (computer.getText().equals(""String_Node_Str"")) {
                JOptionPane.showMessageDialog(null,""String_Node_Str"");
                return;
              }
 else               if (computer.getText().length() < 2) {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
 else {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
              NewGameMenu.cancelled=false;
              Thread client;
              try {
                client=new Thread(new Runnable(){
                  @Override public void run(){
                    try {
                      new NetworkClient().join(host);
                    }
 catch (                    Exception e) {
                      e.printStackTrace();
                    }
                  }
                }
);
                client.start();
                Driver.getInstance().setPanel(new NetLoading(client));
              }
 catch (              Exception e1) {
                e1.printStackTrace();
              }
              popped.dispose();
              pop.dispose();
            }
          }
);
          final JButton back=new JButton(""String_Node_Str"");
          back.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent arg0){
              popped.dispose();
            }
          }
);
          JPanel everything=new JPanel();
          everything.setLayout(new GridBagLayout());
          c.gridx=0;
          c.gridy=0;
          c.gridwidth=2;
          c.insets=new Insets(3,3,3,3);
          popped.add(hoster,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(new JLabel(""String_Node_Str""),c);
          c.gridx=1;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(computer,c);
          c.gridx=0;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(back,c);
          c.gridx=1;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(save,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=2;
          popped.add(everything,c);
          popped.setVisible(true);
        }
      }
);
      final JButton host=new JButton(""String_Node_Str"");
      host.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          setupPopup(true);
          pop.dispose();
        }
      }
);
      options.add(label);
      pop.add(options);
      pop.add(host);
      pop.add(client);
      pop.setVisible(true);
    }
  }
);
  AIPlay=new JButton(""String_Node_Str"");
  AIPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final JFrame popped=new JFrame(""String_Node_Str"");
      popped.setLayout(new GridBagLayout());
      popped.setSize(225,150);
      popped.setResizable(false);
      popped.setLocationRelativeTo(null);
      GridBagConstraints c=new GridBagConstraints();
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      c.gridx=0;
      c.gridy=0;
      popped.add(new JLabel(""String_Node_Str""),c);
      c.gridx=1;
      c.gridy=0;
      c.insets=new Insets(3,0,3,0);
      popped.add(dropdown,c);
      c.gridx=0;
      c.gridy=1;
      popped.add(new JLabel(""String_Node_Str""),c);
      String[] allFiles=FileUtility.getAIFileList();
      List<String> tempFiles=new ArrayList<String>();
      for (      String st : allFiles)       if (st.endsWith(""String_Node_Str""))       tempFiles.add(st);
      String[] files=new String[tempFiles.size()];
      tempFiles.toArray(files);
      if (files.length == 0) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JComboBox ai=new JComboBox(files);
      c.gridx=1;
      c.gridy=1;
      c.fill=GridBagConstraints.HORIZONTAL;
      popped.add(ai,c);
      JButton next=new JButton(""String_Node_Str"");
      next.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final String choice=(String)ai.getSelectedItem();
          File file=FileUtility.getAIFile(choice);
          if (ai.getSelectedItem() == null) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
            return;
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
          StandardJavaFileManager fileManager=compiler.getStandardFileManager(null,Locale.getDefault(),null);
          String[] compileOptions=new String[]{""String_Node_Str"",""String_Node_Str""};
          Iterable<String> compilationOptions=Arrays.asList(compileOptions);
          List<File> sourceFileList=new ArrayList<File>();
          sourceFileList.add(file);
          Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(sourceFileList);
          CompilationTask task=compiler.getTask(null,fileManager,null,compilationOptions,null,compilationUnits);
          boolean result=task.call();
          if (!result) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            return;
          }
          try {
            fileManager.close();
          }
 catch (          IOException e) {
          }
          final AIPlugin plugin;
          final AIAdapter ai=new AIAdapter(toPlay);
          try {
            ClassLoader c=ClassLoader.getSystemClassLoader();
            Class<?> klazz=c.loadClass(choice.substring(0,choice.indexOf(""String_Node_Str"")));
            Constructor<?> construct=klazz.getConstructor();
            plugin=(AIPlugin)construct.newInstance();
            Thread aiThread;
            aiThread=new Thread(new Runnable(){
              @Override public void run(){
                try {
                  ai.runGame(plugin);
                }
 catch (                Exception e) {
                  e.printStackTrace();
                }
              }
            }
);
            aiThread.start();
          }
 catch (          Exception e1) {
            e1.printStackTrace();
          }
          try {
            PlayNetGame png=new PlayNetGame(toPlay,false,false);
            png.setAIGame(true);
            Driver.getInstance().setPanel(png);
          }
 catch (          Exception e) {
            return;
          }
          popped.dispose();
        }
      }
);
      JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          popped.dispose();
        }
      }
);
      JPanel buttons=new JPanel();
      buttons.setLayout(new FlowLayout());
      buttons.add(back);
      buttons.add(next);
      c.gridx=0;
      c.gridy=2;
      c.gridwidth=2;
      popped.add(buttons,c);
      popped.setVisible(true);
    }
  }
);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().revertPanel();
    }
  }
);
  try {
    if (InetAddress.getLocalHost().getHostName().contains(""String_Node_Str"")) {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,0);
      add(humanPlay,c);
      c.gridx=1;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(networkPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.gridwidth=2;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
 else {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(humanPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        setupPopup(false);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  networkPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame pop=new JFrame(""String_Node_Str"");
      pop.setLayout(new FlowLayout());
      pop.setSize(350,150);
      pop.setResizable(false);
      pop.setLocationRelativeTo(null);
      JPanel options=new JPanel();
      final JLabel label=new JLabel(""String_Node_Str"");
      final JButton client=new JButton(""String_Node_Str"");
      client.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final JFrame popped=new JFrame(""String_Node_Str"");
          popped.setLayout(new GridBagLayout());
          popped.setSize(370,150);
          popped.setResizable(false);
          popped.setLocationRelativeTo(null);
          GridBagConstraints c=new GridBagConstraints();
          final JLabel hoster=new JLabel(""String_Node_Str"");
          final JTextField computer=new JTextField(""String_Node_Str"",2);
          final JButton save=new JButton(""String_Node_Str"");
          save.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (computer.getText().equals(""String_Node_Str"")) {
                JOptionPane.showMessageDialog(null,""String_Node_Str"");
                return;
              }
 else               if (computer.getText().length() < 2) {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
 else {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
              NewGameMenu.cancelled=false;
              Thread client;
              try {
                client=new Thread(new Runnable(){
                  @Override public void run(){
                    try {
                      new NetworkClient().join(host);
                    }
 catch (                    Exception e) {
                      e.printStackTrace();
                    }
                  }
                }
);
                client.start();
                Driver.getInstance().setPanel(new NetLoading(client));
              }
 catch (              Exception e1) {
                e1.printStackTrace();
              }
              popped.dispose();
              pop.dispose();
            }
          }
);
          final JButton back=new JButton(""String_Node_Str"");
          back.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent arg0){
              popped.dispose();
            }
          }
);
          JPanel everything=new JPanel();
          everything.setLayout(new GridBagLayout());
          c.gridx=0;
          c.gridy=0;
          c.gridwidth=2;
          c.insets=new Insets(3,3,3,3);
          popped.add(hoster,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(new JLabel(""String_Node_Str""),c);
          c.gridx=1;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(computer,c);
          c.gridx=0;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(back,c);
          c.gridx=1;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(save,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=2;
          popped.add(everything,c);
          popped.setVisible(true);
        }
      }
);
      final JButton host=new JButton(""String_Node_Str"");
      host.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          setupPopup(true);
          pop.dispose();
        }
      }
);
      options.add(label);
      pop.add(options);
      pop.add(host);
      pop.add(client);
      pop.setVisible(true);
    }
  }
);
  AIPlay=new JButton(""String_Node_Str"");
  AIPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final JFrame popped=new JFrame(""String_Node_Str"");
      popped.setLayout(new GridBagLayout());
      popped.setSize(225,150);
      popped.setResizable(false);
      popped.setLocationRelativeTo(null);
      GridBagConstraints c=new GridBagConstraints();
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      c.gridx=0;
      c.gridy=0;
      popped.add(new JLabel(""String_Node_Str""),c);
      c.gridx=1;
      c.gridy=0;
      c.insets=new Insets(3,0,3,0);
      popped.add(dropdown,c);
      c.gridx=0;
      c.gridy=1;
      popped.add(new JLabel(""String_Node_Str""),c);
      String[] allFiles=FileUtility.getAIFileList();
      List<String> tempFiles=new ArrayList<String>();
      for (      String st : allFiles)       if (st.endsWith(""String_Node_Str""))       tempFiles.add(st);
      String[] files=new String[tempFiles.size()];
      tempFiles.toArray(files);
      if (files.length == 0) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JComboBox ai=new JComboBox(files);
      c.gridx=1;
      c.gridy=1;
      c.fill=GridBagConstraints.HORIZONTAL;
      popped.add(ai,c);
      JButton next=new JButton(""String_Node_Str"");
      next.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final String choice=(String)ai.getSelectedItem();
          File file=FileUtility.getAIFile(choice);
          if (ai.getSelectedItem() == null) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
            return;
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
          StandardJavaFileManager fileManager=compiler.getStandardFileManager(null,Locale.getDefault(),null);
          String[] compileOptions=new String[]{""String_Node_Str"",""String_Node_Str""};
          Iterable<String> compilationOptions=Arrays.asList(compileOptions);
          List<File> sourceFileList=new ArrayList<File>();
          sourceFileList.add(file);
          Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(sourceFileList);
          CompilationTask task=compiler.getTask(null,fileManager,null,compilationOptions,null,compilationUnits);
          boolean result=task.call();
          if (!result) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            return;
          }
          try {
            fileManager.close();
          }
 catch (          IOException e) {
          }
          final AIPlugin plugin;
          final AIAdapter ai=new AIAdapter(toPlay);
          try {
            ClassLoader c=ClassLoader.getSystemClassLoader();
            Class<?> klazz=c.loadClass(choice.substring(0,choice.indexOf(""String_Node_Str"")));
            Constructor<?> construct=klazz.getConstructor();
            plugin=(AIPlugin)construct.newInstance();
            Thread aiThread;
            aiThread=new Thread(new Runnable(){
              @Override public void run(){
                try {
                  ai.runGame(plugin);
                }
 catch (                Exception e) {
                  e.printStackTrace();
                }
              }
            }
);
            aiThread.start();
          }
 catch (          Exception e1) {
            e1.printStackTrace();
          }
          try {
            PlayNetGame png=new PlayNetGame(toPlay,false,false);
            png.setAIGame(true);
            Driver.getInstance().setPanel(png);
          }
 catch (          Exception e) {
            return;
          }
          popped.dispose();
        }
      }
);
      JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          popped.dispose();
        }
      }
);
      JPanel buttons=new JPanel();
      buttons.setLayout(new FlowLayout());
      buttons.add(back);
      buttons.add(next);
      c.gridx=0;
      c.gridy=2;
      c.gridwidth=2;
      popped.add(buttons,c);
      popped.setVisible(true);
    }
  }
);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().revertPanel();
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setBorder(BorderFactory.createLoweredBevelBorder());
  buttons.setLayout(new GridBagLayout());
  c.gridy=1;
  c.ipadx=7;
  c.insets=new Insets(5,5,0,5);
  buttons.add(humanPlay,c);
  c.gridy=2;
  c.ipadx=0;
  c.insets=new Insets(2,5,0,5);
  buttons.add(networkPlay,c);
  c.gridy=3;
  c.ipadx=28;
  c.insets=new Insets(2,5,5,5);
  buttons.add(AIPlay,c);
  try {
    if (InetAddress.getLocalHost().getHostName().contains(""String_Node_Str"")) {
      c.gridy=0;
      c.ipadx=0;
      c.insets=new Insets(5,50,5,50);
      c.anchor=GridBagConstraints.CENTER;
      add(new JLabel(""String_Node_Str""),c);
      c.gridy=1;
      add(buttons,c);
      c.gridy=2;
      add(backButton,c);
    }
 else {
      c.gridy=0;
      c.ipadx=0;
      c.insets=new Insets(5,50,5,50);
      c.anchor=GridBagConstraints.CENTER;
      add(new JLabel(""String_Node_Str""),c);
      c.gridy=1;
      c.ipadx=0;
      add(buttons,c);
      c.gridy=2;
      add(backButton,c);
      networkPlay.setVisible(false);
    }
  }
 catch (  Exception e) {
  }
}"
49932,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setBorder(BorderFactory.createLoweredBevelBorder());
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().revertPanel();
    }
  }
);
  nameLabel=new JLabel(""String_Node_Str"");
  nameField=new JTextField(20);
  nameField.setToolTipText(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!nameField.getText().equals(""String_Node_Str"") && !nameField.getText().equals(""String_Node_Str"")) {
        Builder b=new Builder(nameField.getText());
        Driver.getInstance().setPanel(new BoardCustomMenu(b));
      }
 else {
        JOptionPane.showMessageDialog(NewTypeMenu.this,""String_Node_Str"");
      }
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(backButton);
  buttons.add(submitButton);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=0;
  add(nameLabel,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=1;
  add(nameField,c);
  c.gridx=0;
  c.gridy=2;
  add(buttons,c);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setBorder(BorderFactory.createLoweredBevelBorder());
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().revertPanel();
    }
  }
);
  nameLabel=new JLabel(""String_Node_Str"");
  nameField=new JTextField(20);
  nameField.setToolTipText(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      nameField.requestFocus();
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!nameField.getText().equals(""String_Node_Str"") && !nameField.getText().equals(""String_Node_Str"")) {
        Builder b=new Builder(nameField.getText());
        Driver.getInstance().setPanel(new BoardCustomMenu(b));
      }
 else {
        JOptionPane.showMessageDialog(NewTypeMenu.this,""String_Node_Str"");
      }
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(backButton);
  buttons.add(submitButton);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=0;
  add(nameLabel,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=1;
  add(nameField,c);
  c.gridx=0;
  c.gridy=2;
  add(buttons,c);
}"
49933,"/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final JPanel objectiveWhiteCheckBox=new JPanel();
  objectiveWhiteCheckBox.setLayout(new GridLayout(5,1));
  final JRadioButton wCaptureAll=new JRadioButton(""String_Node_Str"",false);
  wCaptureAll.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCaptureAll);
  final JRadioButton wCaptureAllType=new JRadioButton(""String_Node_Str"",false);
  wCaptureAllType.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCaptureAllType);
  final JRadioButton wProtectObj=new JRadioButton(""String_Node_Str"",true);
  wProtectObj.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wProtectObj);
  final JRadioButton wLoseAll=new JRadioButton(""String_Node_Str"",false);
  wLoseAll.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wLoseAll);
  final JRadioButton wCheckTimes=new JRadioButton(""String_Node_Str"",false);
  wCheckTimes.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCheckTimes);
  final ButtonGroup white=new ButtonGroup();
  white.add(wCaptureAll);
  white.add(wCaptureAllType);
  white.add(wProtectObj);
  white.add(wLoseAll);
  white.add(wCheckTimes);
  final JPanel objectiveBlackCheckBox=new JPanel();
  objectiveBlackCheckBox.setLayout(new GridLayout(5,1));
  final JRadioButton bCaptureAll=new JRadioButton(""String_Node_Str"",false);
  bCaptureAll.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCaptureAll);
  final JRadioButton bCaptureAllType=new JRadioButton(""String_Node_Str"",false);
  bCaptureAllType.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCaptureAllType);
  final JRadioButton bProtectObj=new JRadioButton(""String_Node_Str"",true);
  bProtectObj.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bProtectObj);
  final JRadioButton bLoseAll=new JRadioButton(""String_Node_Str"",false);
  bLoseAll.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bLoseAll);
  final JRadioButton bCheckTimes=new JRadioButton(""String_Node_Str"",false);
  bCheckTimes.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCheckTimes);
  final ButtonGroup black=new ButtonGroup();
  black.add(bCaptureAll);
  black.add(bCaptureAllType);
  black.add(bProtectObj);
  black.add(bLoseAll);
  black.add(bCheckTimes);
  final JButton back=new JButton(""String_Node_Str"");
  back.setToolTipText(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new PieceMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wProtectObj.isSelected() || bProtectObj.isSelected()) {
        if (!(wProtectObj.isSelected() && bProtectObj.isSelected())) {
          int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (answer != 0)           return;
        }
      }
      if ((wCaptureAll.isSelected() && bLoseAll.isSelected()) || (bCaptureAll.isSelected() && wLoseAll.isSelected())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"");
        return;
      }
      if (wCheckTimes.isSelected() || bCheckTimes.isSelected()) {
        if (!(wCheckTimes.isSelected() && bCheckTimes.isSelected())) {
          int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (answer != 0)           return;
        }
      }
      if (wCaptureAll.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
      }
      if (wCaptureAllType.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
      }
      if (wProtectObj.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
        needsObj=true;
      }
      if (wLoseAll.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
      }
      if (wCheckTimes.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",3,""String_Node_Str"",false));
        needsObj=true;
      }
      if (bCaptureAll.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
      }
      if (bCaptureAllType.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
        needsObj=false;
      }
      if (bProtectObj.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
      }
      if (bLoseAll.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
      }
      if (bCheckTimes.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",3,""String_Node_Str"",true));
        needsObj=true;
      }
      Driver.getInstance().setPanel(new RuleMaker(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteObj=new JPanel();
  whiteObj.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteObj.add(objectiveWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=3;
  whiteObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(whiteObj,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackObj=new JPanel();
  blackObj.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackObj.add(objectiveBlackCheckBox,c);
  c.gridx=0;
  c.gridy=3;
  blackObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(blackObj,c);
  c.insets=new Insets(10,10,10,10);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(10,10,10,10);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
}","/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final JPanel objectiveWhiteCheckBox=new JPanel();
  objectiveWhiteCheckBox.setLayout(new GridLayout(5,1));
  final JRadioButton wCaptureAll=new JRadioButton(""String_Node_Str"",false);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      wCaptureAll.requestFocus();
    }
  }
);
  wCaptureAll.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCaptureAll);
  final JRadioButton wCaptureAllType=new JRadioButton(""String_Node_Str"",false);
  wCaptureAllType.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCaptureAllType);
  final JRadioButton wProtectObj=new JRadioButton(""String_Node_Str"",true);
  wProtectObj.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wProtectObj);
  final JRadioButton wLoseAll=new JRadioButton(""String_Node_Str"",false);
  wLoseAll.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wLoseAll);
  final JRadioButton wCheckTimes=new JRadioButton(""String_Node_Str"",false);
  wCheckTimes.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCheckTimes);
  final ButtonGroup white=new ButtonGroup();
  white.add(wCaptureAll);
  white.add(wCaptureAllType);
  white.add(wProtectObj);
  white.add(wLoseAll);
  white.add(wCheckTimes);
  final JPanel objectiveBlackCheckBox=new JPanel();
  objectiveBlackCheckBox.setLayout(new GridLayout(5,1));
  final JRadioButton bCaptureAll=new JRadioButton(""String_Node_Str"",false);
  bCaptureAll.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCaptureAll);
  final JRadioButton bCaptureAllType=new JRadioButton(""String_Node_Str"",false);
  bCaptureAllType.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCaptureAllType);
  final JRadioButton bProtectObj=new JRadioButton(""String_Node_Str"",true);
  bProtectObj.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bProtectObj);
  final JRadioButton bLoseAll=new JRadioButton(""String_Node_Str"",false);
  bLoseAll.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bLoseAll);
  final JRadioButton bCheckTimes=new JRadioButton(""String_Node_Str"",false);
  bCheckTimes.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCheckTimes);
  final ButtonGroup black=new ButtonGroup();
  black.add(bCaptureAll);
  black.add(bCaptureAllType);
  black.add(bProtectObj);
  black.add(bLoseAll);
  black.add(bCheckTimes);
  final JButton back=new JButton(""String_Node_Str"");
  back.setToolTipText(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new PieceMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wProtectObj.isSelected() || bProtectObj.isSelected()) {
        if (!(wProtectObj.isSelected() && bProtectObj.isSelected())) {
          int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (answer != 0)           return;
        }
      }
      if ((wCaptureAll.isSelected() && bLoseAll.isSelected()) || (bCaptureAll.isSelected() && wLoseAll.isSelected())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"");
        return;
      }
      if (wCheckTimes.isSelected() || bCheckTimes.isSelected()) {
        if (!(wCheckTimes.isSelected() && bCheckTimes.isSelected())) {
          int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (answer != 0)           return;
        }
      }
      if (wCaptureAll.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
      }
      if (wCaptureAllType.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
      }
      if (wProtectObj.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
        needsObj=true;
      }
      if (wLoseAll.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
      }
      if (wCheckTimes.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",3,""String_Node_Str"",false));
        needsObj=true;
      }
      if (bCaptureAll.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
      }
      if (bCaptureAllType.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
        needsObj=false;
      }
      if (bProtectObj.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
      }
      if (bLoseAll.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
      }
      if (bCheckTimes.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",3,""String_Node_Str"",true));
        needsObj=true;
      }
      Driver.getInstance().setPanel(new RuleMaker(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteObj=new JPanel();
  whiteObj.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteObj.add(objectiveWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=3;
  whiteObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(whiteObj,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackObj=new JPanel();
  blackObj.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackObj.add(objectiveBlackCheckBox,c);
  c.gridx=0;
  c.gridy=3;
  blackObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(blackObj,c);
  c.insets=new Insets(10,10,10,10);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(10,10,10,10);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
}"
49934,"/** 
 * Method to set up the piece making window.
 */
public void initComponents(){
  builder=new PieceBuilder();
  setSize(550,875);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  JPanel piecePanel=new JPanel();
  piecePanel.setLayout(new GridBagLayout());
  piecePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel namePanel=new JPanel();
  namePanel.setLayout(new FlowLayout());
  namePanel.add(new JLabel(""String_Node_Str""));
  final JTextField name=new JTextField(15);
  name.setToolTipText(""String_Node_Str"");
  namePanel.add(name);
  c.gridx=0;
  c.gridy=0;
  piecePanel.add(namePanel,c);
  final ImageIcon temp=new ImageIcon(""String_Node_Str"");
  temp.setImage(temp.getImage().getScaledInstance(48,48,Image.SCALE_SMOOTH));
  final JPanel lightIconPanel=new JPanel();
  lightIconPanel.setLayout(new FlowLayout());
  final JButton lightIconButton=new JButton();
  lightIconButton.setSize(48,48);
  lightIconButton.setIcon(temp);
  final JButton chooseLightImage=new JButton(""String_Node_Str"");
  chooseLightImage.setToolTipText(""String_Node_Str"");
  chooseLightImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        lightIconButton.setIcon(icon);
        builder.setLightImage(icon);
      }
    }
  }
);
  lightIconPanel.add(chooseLightImage);
  lightIconPanel.add(lightIconButton);
  builder.setLightImage(temp);
  c.gridx=0;
  c.gridy=3;
  piecePanel.add(lightIconPanel,c);
  final JPanel darkIconPanel=new JPanel();
  darkIconPanel.setLayout(new FlowLayout());
  final JButton darkIconButton=new JButton();
  darkIconButton.setSize(48,48);
  darkIconButton.setIcon(temp);
  final JButton chooseDarkImage=new JButton(""String_Node_Str"");
  chooseDarkImage.setToolTipText(""String_Node_Str"");
  chooseDarkImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        darkIconButton.setIcon(icon);
        builder.setDarkImage(icon);
      }
    }
  }
);
  darkIconPanel.add(chooseDarkImage);
  darkIconPanel.add(darkIconButton);
  builder.setDarkImage(temp);
  c.gridx=0;
  c.gridy=2;
  piecePanel.add(darkIconPanel,c);
  final String[] directions=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox dropdown=new JComboBox(directions);
  dropdown.setToolTipText(""String_Node_Str"");
  final JTextField dist=new JTextField(3);
  dist.setToolTipText(""String_Node_Str"");
  final JTextField knight=new JTextField(2);
  knight.setToolTipText(""String_Node_Str"");
  knight.setEnabled(false);
  final JTextField knightSecond=new JTextField(2);
  knightSecond.setToolTipText(""String_Node_Str"");
  knightSecond.setEnabled(false);
  final JCheckBox knightOn=new JCheckBox(""String_Node_Str"",false);
  knightOn.setToolTipText(""String_Node_Str"");
  knightOn.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      knightLike=!knightLike;
      if (knightLike) {
        knight.setEnabled(true);
        knightSecond.setEnabled(true);
      }
 else {
        knight.setEnabled(false);
        knightSecond.setEnabled(false);
      }
    }
  }
);
  final JCheckBox leaper=new JCheckBox(""String_Node_Str"",false);
  leaper.setToolTipText(""String_Node_Str"");
  final JPanel knightMoving=new JPanel();
  knightMoving.setToolTipText(""String_Node_Str"");
  knightMoving.setLayout(new FlowLayout());
  knightMoving.add(knight);
  knightMoving.add(new JLabel(""String_Node_Str""));
  knightMoving.add(knightSecond);
  final JButton addInstruction=new JButton(""String_Node_Str"");
  addInstruction.setToolTipText(""String_Node_Str"");
  addInstruction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (isIntDist()) {
        if (dropdown.getSelectedItem() != null) {
          builder.addMove(stringToChar((String)dropdown.getSelectedItem()),Integer.parseInt(dist.getText()));
          dropdown.removeItemAt(dropdown.getSelectedIndex());
          dist.setText(""String_Node_Str"");
        }
      }
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntDist(){
      try {
        Integer.parseInt(dist.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
    /** 
 * Translate a direction string to it's corresponding char.
 * @param s The string to translate
 * @return The char corresponding to the given String.
 */
    private char stringToChar(    String s){
      if (s.equals(""String_Node_Str""))       return 'N';
      if (s.equals(""String_Node_Str""))       return 'S';
      if (s.equals(""String_Node_Str""))       return 'E';
      if (s.equals(""String_Node_Str""))       return 'W';
      if (s.equals(""String_Node_Str""))       return 'R';
      if (s.equals(""String_Node_Str""))       return 'L';
      if (s.equals(""String_Node_Str""))       return 'r';
 else       return 'l';
    }
  }
);
  c.gridx=0;
  c.gridy=4;
  piecePanel.add(addInstruction,c);
  JPanel movementSetup=new JPanel();
  movementSetup.setLayout(new BoxLayout(movementSetup,BoxLayout.Y_AXIS));
  movementSetup.setLayout(new GridBagLayout());
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=0;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=1;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=1;
  movementSetup.add(dropdown,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=2;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=2;
  movementSetup.add(dist,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=3;
  c.gridwidth=3;
  movementSetup.add(addInstruction,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=5;
  movementSetup.add(leaper,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=6;
  movementSetup.add(knightOn,c);
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=7;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=8;
  movementSetup.add(knightMoving,c);
  c.gridx=0;
  c.gridy=5;
  piecePanel.add(movementSetup,c);
  final JButton done=new JButton(""String_Node_Str"");
  done.setToolTipText(""String_Node_Str"");
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (name.getText() == ""String_Node_Str"" || PieceBuilder.isPieceType(name.getText())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
        return;
      }
      if (knight.isEnabled()) {
        if (isIntKnights()) {
          builder.addMove('x',Integer.parseInt(knight.getText()));
          builder.addMove('y',Integer.parseInt(knightSecond.getText()));
        }
      }
      builder.setName(name.getText());
      PieceBuilder.savePieceType(builder);
      builder=new PieceBuilder();
      name.setText(""String_Node_Str"");
      lightIconButton.setIcon(temp);
      darkIconButton.setIcon(temp);
      dist.setText(""String_Node_Str"");
      leaper.setSelected(false);
      knightOn.setSelected(false);
      knight.setText(""String_Node_Str"");
      knight.setEnabled(false);
      knightSecond.setText(""String_Node_Str"");
      knightSecond.setEnabled(false);
      knightLike=false;
      dropdown.removeAllItems();
      for (int i=0; i < directions.length; i++)       dropdown.addItem(directions[i]);
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntKnights(){
      try {
        Integer.parseInt(knight.getText());
        Integer.parseInt(knightSecond.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
  }
);
  BufferedImage helpMe=null;
  try {
    helpMe=ImageIO.read(getClass().getResource(""String_Node_Str""));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  final ImageIcon picture=new ImageIcon(helpMe);
  picture.setImage(picture.getImage().getScaledInstance(700,500,Image.SCALE_SMOOTH));
  final JButton help=new JButton(""String_Node_Str"");
  help.setToolTipText(""String_Node_Str"");
  help.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",0,picture);
    }
  }
);
  final JButton next=new JButton(""String_Node_Str"");
  next.setToolTipText(""String_Node_Str"");
  next.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (name.getText().equals(""String_Node_Str"")) {
        Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
 else {
        int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
        if (answer == 0)         Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  cancel.setToolTipText(""String_Node_Str"");
  cancel.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new BoardCustomMenu(b));
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(help);
  buttons.add(done);
  c.gridx=0;
  c.gridy=7;
  piecePanel.add(buttons,c);
  c.gridx=0;
  c.gridy=0;
  add(piecePanel,c);
  JPanel mainButtons=new JPanel();
  mainButtons.setLayout(new FlowLayout());
  c.gridx=0;
  c.gridy=1;
  mainButtons.add(cancel,c);
  c.gridx=1;
  c.gridy=1;
  mainButtons.add(next,c);
  c.gridx=0;
  c.gridy=1;
  add(mainButtons,c);
}","/** 
 * Method to set up the piece making window.
 */
public void initComponents(){
  builder=new PieceBuilder();
  setSize(550,875);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  JPanel piecePanel=new JPanel();
  piecePanel.setLayout(new GridBagLayout());
  piecePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel namePanel=new JPanel();
  namePanel.setLayout(new FlowLayout());
  namePanel.add(new JLabel(""String_Node_Str""));
  final JTextField name=new JTextField(15);
  name.setToolTipText(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      name.requestFocus();
    }
  }
);
  namePanel.add(name);
  c.gridx=0;
  c.gridy=0;
  piecePanel.add(namePanel,c);
  final ImageIcon temp=new ImageIcon(""String_Node_Str"");
  temp.setImage(temp.getImage().getScaledInstance(48,48,Image.SCALE_SMOOTH));
  final JPanel lightIconPanel=new JPanel();
  lightIconPanel.setLayout(new FlowLayout());
  final JButton lightIconButton=new JButton();
  lightIconButton.setSize(48,48);
  lightIconButton.setIcon(temp);
  final JButton chooseLightImage=new JButton(""String_Node_Str"");
  chooseLightImage.setToolTipText(""String_Node_Str"");
  chooseLightImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        lightIconButton.setIcon(icon);
        builder.setLightImage(icon);
      }
    }
  }
);
  lightIconPanel.add(chooseLightImage);
  lightIconPanel.add(lightIconButton);
  builder.setLightImage(temp);
  c.gridx=0;
  c.gridy=3;
  piecePanel.add(lightIconPanel,c);
  final JPanel darkIconPanel=new JPanel();
  darkIconPanel.setLayout(new FlowLayout());
  final JButton darkIconButton=new JButton();
  darkIconButton.setSize(48,48);
  darkIconButton.setIcon(temp);
  final JButton chooseDarkImage=new JButton(""String_Node_Str"");
  chooseDarkImage.setToolTipText(""String_Node_Str"");
  chooseDarkImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        darkIconButton.setIcon(icon);
        builder.setDarkImage(icon);
      }
    }
  }
);
  darkIconPanel.add(chooseDarkImage);
  darkIconPanel.add(darkIconButton);
  builder.setDarkImage(temp);
  c.gridx=0;
  c.gridy=2;
  piecePanel.add(darkIconPanel,c);
  final String[] directions=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox dropdown=new JComboBox(directions);
  dropdown.setToolTipText(""String_Node_Str"");
  final JTextField dist=new JTextField(3);
  dist.setToolTipText(""String_Node_Str"");
  final JTextField knight=new JTextField(2);
  knight.setToolTipText(""String_Node_Str"");
  knight.setEnabled(false);
  final JTextField knightSecond=new JTextField(2);
  knightSecond.setToolTipText(""String_Node_Str"");
  knightSecond.setEnabled(false);
  final JCheckBox knightOn=new JCheckBox(""String_Node_Str"",false);
  knightOn.setToolTipText(""String_Node_Str"");
  knightOn.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      knightLike=!knightLike;
      if (knightLike) {
        knight.setEnabled(true);
        knightSecond.setEnabled(true);
      }
 else {
        knight.setEnabled(false);
        knightSecond.setEnabled(false);
      }
    }
  }
);
  final JCheckBox leaper=new JCheckBox(""String_Node_Str"",false);
  leaper.setToolTipText(""String_Node_Str"");
  final JPanel knightMoving=new JPanel();
  knightMoving.setToolTipText(""String_Node_Str"");
  knightMoving.setLayout(new FlowLayout());
  knightMoving.add(knight);
  knightMoving.add(new JLabel(""String_Node_Str""));
  knightMoving.add(knightSecond);
  final JButton addInstruction=new JButton(""String_Node_Str"");
  addInstruction.setToolTipText(""String_Node_Str"");
  addInstruction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (isIntDist()) {
        if (dropdown.getSelectedItem() != null) {
          builder.addMove(stringToChar((String)dropdown.getSelectedItem()),Integer.parseInt(dist.getText()));
          dropdown.removeItemAt(dropdown.getSelectedIndex());
          dist.setText(""String_Node_Str"");
        }
      }
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntDist(){
      try {
        Integer.parseInt(dist.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
    /** 
 * Translate a direction string to it's corresponding char.
 * @param s The string to translate
 * @return The char corresponding to the given String.
 */
    private char stringToChar(    String s){
      if (s.equals(""String_Node_Str""))       return 'N';
      if (s.equals(""String_Node_Str""))       return 'S';
      if (s.equals(""String_Node_Str""))       return 'E';
      if (s.equals(""String_Node_Str""))       return 'W';
      if (s.equals(""String_Node_Str""))       return 'R';
      if (s.equals(""String_Node_Str""))       return 'L';
      if (s.equals(""String_Node_Str""))       return 'r';
 else       return 'l';
    }
  }
);
  c.gridx=0;
  c.gridy=4;
  piecePanel.add(addInstruction,c);
  JPanel movementSetup=new JPanel();
  movementSetup.setLayout(new BoxLayout(movementSetup,BoxLayout.Y_AXIS));
  movementSetup.setLayout(new GridBagLayout());
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=0;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=1;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=1;
  movementSetup.add(dropdown,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=2;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=2;
  movementSetup.add(dist,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=3;
  c.gridwidth=3;
  movementSetup.add(addInstruction,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=5;
  movementSetup.add(leaper,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=6;
  movementSetup.add(knightOn,c);
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=7;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=8;
  movementSetup.add(knightMoving,c);
  c.gridx=0;
  c.gridy=5;
  piecePanel.add(movementSetup,c);
  final JButton done=new JButton(""String_Node_Str"");
  done.setToolTipText(""String_Node_Str"");
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (name.getText() == ""String_Node_Str"" || PieceBuilder.isPieceType(name.getText())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
        return;
      }
      if (knight.isEnabled()) {
        if (isIntKnights()) {
          builder.addMove('x',Integer.parseInt(knight.getText()));
          builder.addMove('y',Integer.parseInt(knightSecond.getText()));
        }
      }
      builder.setName(name.getText());
      PieceBuilder.savePieceType(builder);
      builder=new PieceBuilder();
      name.setText(""String_Node_Str"");
      lightIconButton.setIcon(temp);
      darkIconButton.setIcon(temp);
      dist.setText(""String_Node_Str"");
      leaper.setSelected(false);
      knightOn.setSelected(false);
      knight.setText(""String_Node_Str"");
      knight.setEnabled(false);
      knightSecond.setText(""String_Node_Str"");
      knightSecond.setEnabled(false);
      knightLike=false;
      dropdown.removeAllItems();
      for (int i=0; i < directions.length; i++)       dropdown.addItem(directions[i]);
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntKnights(){
      try {
        Integer.parseInt(knight.getText());
        Integer.parseInt(knightSecond.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
  }
);
  BufferedImage helpMe=null;
  try {
    helpMe=ImageIO.read(getClass().getResource(""String_Node_Str""));
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  final ImageIcon picture=new ImageIcon(helpMe);
  picture.setImage(picture.getImage().getScaledInstance(700,500,Image.SCALE_SMOOTH));
  final JButton help=new JButton(""String_Node_Str"");
  help.setToolTipText(""String_Node_Str"");
  help.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",0,picture);
    }
  }
);
  final JButton next=new JButton(""String_Node_Str"");
  next.setToolTipText(""String_Node_Str"");
  next.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (name.getText().equals(""String_Node_Str"")) {
        Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
 else {
        int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
        if (answer == 0)         Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  cancel.setToolTipText(""String_Node_Str"");
  cancel.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new BoardCustomMenu(b));
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(help);
  buttons.add(done);
  c.gridx=0;
  c.gridy=7;
  piecePanel.add(buttons,c);
  c.gridx=0;
  c.gridy=0;
  add(piecePanel,c);
  JPanel mainButtons=new JPanel();
  mainButtons.setLayout(new FlowLayout());
  c.gridx=0;
  c.gridy=1;
  mainButtons.add(cancel,c);
  c.gridx=1;
  c.gridy=1;
  mainButtons.add(next,c);
  c.gridx=0;
  c.gridy=1;
  add(mainButtons,c);
}"
49935,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 * @param whiteRules The whiteRules object.
 * @param blackRules The blackRules object.
 */
private void initComponents(final Rules whiteRules,final Rules blackRules){
  setBorder(BorderFactory.createLoweredBevelBorder());
  numTurnsOneLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  numTurnsTwoLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  numTurnsOne=new JTextField(4);
  numTurnsOne.setText(""String_Node_Str"");
  numTurnsOne.setToolTipText(""String_Node_Str"");
  numTurnsTwo=new JTextField(4);
  numTurnsTwo.setText(""String_Node_Str"");
  numTurnsTwo.setToolTipText(""String_Node_Str"");
  incrementTurnsLabel=new JLabel(""String_Node_Str"" + ""String_Node_Str"");
  incrementTurns=new JTextField(4);
  incrementTurns.setText(""String_Node_Str"");
  incrementTurns.setToolTipText(""String_Node_Str"");
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().setPanel(new RuleMaker(b,whiteRules,blackRules));
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete(whiteRules,blackRules)) {
        Driver.getInstance().setPanel(new CustomSetupMenu(b,whiteRules,blackRules));
      }
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(backButton);
  buttons.add(submitButton);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=0;
  add(numTurnsOneLabel,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=2;
  c.gridy=0;
  add(numTurnsOne,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=1;
  add(numTurnsTwoLabel,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=2;
  c.gridy=1;
  add(numTurnsTwo,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=2;
  add(incrementTurnsLabel,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=2;
  c.gridy=2;
  add(incrementTurns,c);
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=3;
  add(buttons,c);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the window. Also add any necessary ActionListeners.
 * @param whiteRules The whiteRules object.
 * @param blackRules The blackRules object.
 */
private void initComponents(final Rules whiteRules,final Rules blackRules){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  setBorder(BorderFactory.createLoweredBevelBorder());
  numTurnsOneLabel=new JLabel(""String_Node_Str"");
  numTurnsTwoLabel=new JLabel(""String_Node_Str"");
  numTurnsOne=new JTextField(4);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      numTurnsOne.requestFocus();
    }
  }
);
  numTurnsOne.setText(""String_Node_Str"");
  numTurnsOne.setToolTipText(""String_Node_Str"");
  numTurnsTwo=new JTextField(4);
  numTurnsTwo.setText(""String_Node_Str"");
  numTurnsTwo.setToolTipText(""String_Node_Str"");
  incrementTurnsLabel=new JLabel(""String_Node_Str"");
  incrementTurns=new JTextField(4);
  incrementTurns.setText(""String_Node_Str"");
  incrementTurns.setToolTipText(""String_Node_Str"");
  backButton=new JButton(""String_Node_Str"");
  backButton.setToolTipText(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().setPanel(new RuleMaker(b,whiteRules,blackRules));
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.setToolTipText(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (formComplete(whiteRules,blackRules)) {
        Driver.getInstance().setPanel(new CustomSetupMenu(b,whiteRules,blackRules));
      }
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(backButton);
  buttons.add(submitButton);
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=0;
  add(numTurnsOneLabel,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=2;
  c.gridy=0;
  add(numTurnsOne,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=1;
  add(numTurnsTwoLabel,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=2;
  c.gridy=1;
  add(numTurnsTwo,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=0;
  c.gridy=2;
  add(incrementTurnsLabel,c);
  c.insets=new Insets(3,3,3,3);
  c.gridx=2;
  c.gridy=2;
  add(incrementTurns,c);
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=3;
  add(buttons,c);
}"
49936,"/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=b.getBoards();
  final JPanel legalDestWhiteCheckBox=new JPanel();
  legalDestWhiteCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox wCaptureMand=new JCheckBox(""String_Node_Str"");
  wCaptureMand.setToolTipText(""String_Node_Str"");
  legalDestWhiteCheckBox.add(wCaptureMand);
  final JCheckBox wNoMoveObj=new JCheckBox(""String_Node_Str"");
  wNoMoveObj.setToolTipText(""String_Node_Str"");
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestWhiteCheckBox.add(wNoMoveObj);
  }
  final JPanel afterCaptureWhiteCheckBox=new JPanel();
  afterCaptureWhiteCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox wChangeColor=new JCheckBox(""String_Node_Str"");
  wChangeColor.setToolTipText(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wChangeColor);
  }
  final JCheckBox wPieceReturn=new JCheckBox(""String_Node_Str"");
  wPieceReturn.setToolTipText(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wPieceReturn);
  final JCheckBox wDrop=new JCheckBox(""String_Node_Str"");
  wDrop.setToolTipText(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"") || !whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wDrop);
  }
  final JCheckBox wCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  wCapturedColorAndDrop.setToolTipText(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wCapturedColorAndDrop);
  final JPanel legalDestBlackCheckBox=new JPanel();
  legalDestBlackCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox bCaptureMand=new JCheckBox(""String_Node_Str"");
  bCaptureMand.setToolTipText(""String_Node_Str"");
  legalDestBlackCheckBox.add(bCaptureMand);
  final JCheckBox bNoMoveObj=new JCheckBox(""String_Node_Str"");
  bNoMoveObj.setToolTipText(""String_Node_Str"");
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestBlackCheckBox.add(bNoMoveObj);
  }
  final JPanel afterCapturepBlackCheckBox=new JPanel();
  afterCapturepBlackCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox bChangeColor=new JCheckBox(""String_Node_Str"");
  bChangeColor.setToolTipText(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bChangeColor);
  }
  final JCheckBox bPieceReturn=new JCheckBox(""String_Node_Str"");
  bPieceReturn.setToolTipText(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bPieceReturn);
  final JCheckBox bDrop=new JCheckBox(""String_Node_Str"");
  bDrop.setToolTipText(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"") || !blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bDrop);
  }
  final JCheckBox bCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  bCapturedColorAndDrop.setToolTipText(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bCapturedColorAndDrop);
  final JPanel sCheckBox=new JPanel();
  sCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox atomic=new JCheckBox(""String_Node_Str"");
  atomic.setToolTipText(""String_Node_Str"");
  sCheckBox.add(atomic);
  final JCheckBox switchBoard=new JCheckBox(""String_Node_Str"");
  switchBoard.setToolTipText(""String_Node_Str"");
  switchBoard.setEnabled(false);
  sCheckBox.add(switchBoard);
  final JPanel wExtras=new JPanel();
  wExtras.setLayout(new GridBagLayout());
  final JTextField wNumChecks=new JTextField(2);
  Object[] allPieces=PieceBuilder.getSet().toArray();
  final JComboBox wPiecesList=new JComboBox(allPieces);
  JLabel wChecksLabel=new JLabel(""String_Node_Str"");
  JLabel wPiecesLabel=new JLabel(""String_Node_Str"");
  wNumChecks.setVisible(false);
  wPiecesList.setVisible(false);
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (whiteRules.theEndIsNigh().equals(""String_Node_Str""))     wPiecesLabel.setText(""String_Node_Str"");
    wPiecesList.setVisible(true);
    wPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    wNumChecks.setVisible(true);
    wPiecesList.setVisible(true);
    wPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=0;
    wExtras.add(wChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    wExtras.add(wNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  final JPanel bExtras=new JPanel();
  bExtras.setLayout(new GridBagLayout());
  final JTextField bNumChecks=new JTextField(2);
  final JComboBox bPiecesList=new JComboBox(allPieces);
  JLabel bChecksLabel=new JLabel(""String_Node_Str"");
  JLabel bPiecesLabel=new JLabel(""String_Node_Str"");
  bNumChecks.setVisible(false);
  bPiecesList.setVisible(false);
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (blackRules.theEndIsNigh().equals(""String_Node_Str""))     bPiecesLabel.setText(""String_Node_Str"");
    bPiecesList.setVisible(true);
    bPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    bNumChecks.setVisible(true);
    bPiecesList.setVisible(true);
    bPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=0;
    bExtras.add(bChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    bExtras.add(bNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  final JButton back=new JButton(""String_Node_Str"");
  back.setToolTipText(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new ObjectiveMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wCaptureMand.isSelected()) {
        whiteRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (wNoMoveObj.isSelected()) {
        whiteRules.addCropLegalDests(""String_Node_Str"");
      }
      if (wChangeColor.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wPieceReturn.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wCapturedColorAndDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (bCaptureMand.isSelected()) {
        blackRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (bNoMoveObj.isSelected()) {
        blackRules.addCropLegalDests(""String_Node_Str"");
      }
      if (bChangeColor.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bPieceReturn.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bCapturedColorAndDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (switchBoard.isSelected() && boards.length == 2) {
        whiteRules.setGetBoard(new GetBoard(""String_Node_Str""));
        blackRules.setGetBoard(new GetBoard(""String_Node_Str""));
      }
      if (atomic.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (wNumChecks.isVisible()) {
        String wNumChecked=wNumChecks.getText();
        try {
          int answer=Integer.parseInt(wNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",answer,""String_Node_Str"",false));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
 else       if (wPiecesList.isVisible()) {
        if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",wPiecesList.getSelectedItem().toString()));
        }
 else {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,wPiecesList.getSelectedItem().toString(),false));
        }
      }
      if (bNumChecks.isVisible()) {
        String bNumChecked=bNumChecks.getText();
        try {
          int answer=Integer.parseInt(bNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",answer,""String_Node_Str"",true));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
 else       if (bPiecesList.isVisible()) {
        bPiecesList.getSelectedItem();
        if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",bPiecesList.getSelectedItem().toString()));
        }
 else {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,bPiecesList.getSelectedItem().toString(),true));
        }
      }
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteLegalDests=new JPanel();
  whiteLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  whiteLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteLegalDests.add(legalDestWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  whiteTeam.add(whiteLegalDests,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(wExtras,c);
  JPanel whiteCapture=new JPanel();
  whiteCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteCapture.add(afterCaptureWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  whiteTeam.add(whiteCapture,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackLegalDests=new JPanel();
  blackLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  blackLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackLegalDests.add(legalDestBlackCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  blackTeam.add(blackLegalDests,c);
  JPanel blackCapture=new JPanel();
  blackCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackCapture.add(afterCapturepBlackCheckBox,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(bExtras,c);
  c.gridx=0;
  c.gridy=2;
  blackTeam.add(blackCapture,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel specialRules=new JPanel();
  specialRules.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  specialRules.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  specialRules.add(sCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  add(specialRules,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
  wChangeColor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (wChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  bChangeColor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (bChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  wPieceReturn.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (wPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
      }
    }
  }
);
  bPieceReturn.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (bPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bDrop.setEnabled(true);
      }
    }
  }
);
  atomic.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (atomic.isSelected()) {
        wChangeColor.setEnabled(false);
        wChangeColor.setSelected(false);
        bChangeColor.setEnabled(false);
        bChangeColor.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        wChangeColor.setEnabled(true);
        bChangeColor.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
        bDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wCapturedColorAndDrop.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (wCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bCapturedColorAndDrop.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (bCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wDrop.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (wDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bDrop.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (bDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  if (boards.length == 2) {
    switchBoard.setEnabled(true);
  }
}","/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=b.getBoards();
  final JPanel legalDestWhiteCheckBox=new JPanel();
  legalDestWhiteCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox wCaptureMand=new JCheckBox(""String_Node_Str"");
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      wCaptureMand.requestFocus();
    }
  }
);
  wCaptureMand.setToolTipText(""String_Node_Str"");
  legalDestWhiteCheckBox.add(wCaptureMand);
  final JCheckBox wNoMoveObj=new JCheckBox(""String_Node_Str"");
  wNoMoveObj.setToolTipText(""String_Node_Str"");
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestWhiteCheckBox.add(wNoMoveObj);
  }
  final JPanel afterCaptureWhiteCheckBox=new JPanel();
  afterCaptureWhiteCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox wChangeColor=new JCheckBox(""String_Node_Str"");
  wChangeColor.setToolTipText(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wChangeColor);
  }
  final JCheckBox wPieceReturn=new JCheckBox(""String_Node_Str"");
  wPieceReturn.setToolTipText(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wPieceReturn);
  final JCheckBox wDrop=new JCheckBox(""String_Node_Str"");
  wDrop.setToolTipText(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"") || !whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wDrop);
  }
  final JCheckBox wCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  wCapturedColorAndDrop.setToolTipText(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wCapturedColorAndDrop);
  final JPanel legalDestBlackCheckBox=new JPanel();
  legalDestBlackCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox bCaptureMand=new JCheckBox(""String_Node_Str"");
  bCaptureMand.setToolTipText(""String_Node_Str"");
  legalDestBlackCheckBox.add(bCaptureMand);
  final JCheckBox bNoMoveObj=new JCheckBox(""String_Node_Str"");
  bNoMoveObj.setToolTipText(""String_Node_Str"");
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestBlackCheckBox.add(bNoMoveObj);
  }
  final JPanel afterCapturepBlackCheckBox=new JPanel();
  afterCapturepBlackCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox bChangeColor=new JCheckBox(""String_Node_Str"");
  bChangeColor.setToolTipText(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bChangeColor);
  }
  final JCheckBox bPieceReturn=new JCheckBox(""String_Node_Str"");
  bPieceReturn.setToolTipText(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bPieceReturn);
  final JCheckBox bDrop=new JCheckBox(""String_Node_Str"");
  bDrop.setToolTipText(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"") || !blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bDrop);
  }
  final JCheckBox bCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  bCapturedColorAndDrop.setToolTipText(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bCapturedColorAndDrop);
  final JPanel sCheckBox=new JPanel();
  sCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox atomic=new JCheckBox(""String_Node_Str"");
  atomic.setToolTipText(""String_Node_Str"");
  sCheckBox.add(atomic);
  final JCheckBox switchBoard=new JCheckBox(""String_Node_Str"");
  switchBoard.setToolTipText(""String_Node_Str"");
  switchBoard.setEnabled(false);
  sCheckBox.add(switchBoard);
  final JPanel wExtras=new JPanel();
  wExtras.setLayout(new GridBagLayout());
  final JTextField wNumChecks=new JTextField(2);
  Object[] allPieces=PieceBuilder.getSet().toArray();
  final JComboBox wPiecesList=new JComboBox(allPieces);
  JLabel wChecksLabel=new JLabel(""String_Node_Str"");
  JLabel wPiecesLabel=new JLabel(""String_Node_Str"");
  wNumChecks.setVisible(false);
  wPiecesList.setVisible(false);
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (whiteRules.theEndIsNigh().equals(""String_Node_Str""))     wPiecesLabel.setText(""String_Node_Str"");
    wPiecesList.setVisible(true);
    wPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    wNumChecks.setVisible(true);
    wPiecesList.setVisible(true);
    wPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=0;
    wExtras.add(wChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    wExtras.add(wNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  final JPanel bExtras=new JPanel();
  bExtras.setLayout(new GridBagLayout());
  final JTextField bNumChecks=new JTextField(2);
  final JComboBox bPiecesList=new JComboBox(allPieces);
  JLabel bChecksLabel=new JLabel(""String_Node_Str"");
  JLabel bPiecesLabel=new JLabel(""String_Node_Str"");
  bNumChecks.setVisible(false);
  bPiecesList.setVisible(false);
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (blackRules.theEndIsNigh().equals(""String_Node_Str""))     bPiecesLabel.setText(""String_Node_Str"");
    bPiecesList.setVisible(true);
    bPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    bNumChecks.setVisible(true);
    bPiecesList.setVisible(true);
    bPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=0;
    bExtras.add(bChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    bExtras.add(bNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  final JButton back=new JButton(""String_Node_Str"");
  back.setToolTipText(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new ObjectiveMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wCaptureMand.isSelected()) {
        whiteRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (wNoMoveObj.isSelected()) {
        whiteRules.addCropLegalDests(""String_Node_Str"");
      }
      if (wChangeColor.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wPieceReturn.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wCapturedColorAndDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (bCaptureMand.isSelected()) {
        blackRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (bNoMoveObj.isSelected()) {
        blackRules.addCropLegalDests(""String_Node_Str"");
      }
      if (bChangeColor.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bPieceReturn.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bCapturedColorAndDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (switchBoard.isSelected() && boards.length == 2) {
        whiteRules.setGetBoard(new GetBoard(""String_Node_Str""));
        blackRules.setGetBoard(new GetBoard(""String_Node_Str""));
      }
      if (atomic.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (wNumChecks.isVisible()) {
        String wNumChecked=wNumChecks.getText();
        try {
          int answer=Integer.parseInt(wNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",answer,""String_Node_Str"",false));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
 else       if (wPiecesList.isVisible()) {
        if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",false));
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",wPiecesList.getSelectedItem().toString()));
        }
 else {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,wPiecesList.getSelectedItem().toString(),false));
        }
      }
      if (bNumChecks.isVisible()) {
        String bNumChecked=bNumChecks.getText();
        try {
          int answer=Integer.parseInt(bNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",answer,""String_Node_Str"",true));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
 else       if (bPiecesList.isVisible()) {
        bPiecesList.getSelectedItem();
        if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,""String_Node_Str"",true));
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",bPiecesList.getSelectedItem().toString()));
        }
 else {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",0,bPiecesList.getSelectedItem().toString(),true));
        }
      }
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteLegalDests=new JPanel();
  whiteLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  whiteLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteLegalDests.add(legalDestWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  whiteTeam.add(whiteLegalDests,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(wExtras,c);
  JPanel whiteCapture=new JPanel();
  whiteCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteCapture.add(afterCaptureWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  whiteTeam.add(whiteCapture,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackLegalDests=new JPanel();
  blackLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  blackLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackLegalDests.add(legalDestBlackCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  blackTeam.add(blackLegalDests,c);
  JPanel blackCapture=new JPanel();
  blackCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackCapture.add(afterCapturepBlackCheckBox,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(bExtras,c);
  c.gridx=0;
  c.gridy=2;
  blackTeam.add(blackCapture,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel specialRules=new JPanel();
  specialRules.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  specialRules.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  specialRules.add(sCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  add(specialRules,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
  wChangeColor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (wChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  bChangeColor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (bChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  wPieceReturn.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (wPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
      }
    }
  }
);
  bPieceReturn.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (bPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bDrop.setEnabled(true);
      }
    }
  }
);
  atomic.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (atomic.isSelected()) {
        wChangeColor.setEnabled(false);
        wChangeColor.setSelected(false);
        bChangeColor.setEnabled(false);
        bChangeColor.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        wChangeColor.setEnabled(true);
        bChangeColor.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
        bDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wCapturedColorAndDrop.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (wCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bCapturedColorAndDrop.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (bCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wDrop.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (wDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bDrop.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (bDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  if (boards.length == 2) {
    switchBoard.setEnabled(true);
  }
}"
49937,"public void newGame(){
  variantHelp.setVisible(false);
  helpMenu.setText(""String_Node_Str"");
  gamePlayHelp.setVisible(true);
  if (PlayGame.menu != null)   PlayGame.menu.setVisible(false);
  if (otherPanel != null)   remove(otherPanel);
  if (mainPanel != null)   remove(mainPanel);
  otherPanel=new NewGameMenu();
  add(otherPanel);
  ChessTimer.stopTimers();
  gamePlayHelp.setVisible(true);
  pack();
}","/** 
 * Sets up a new game and clears out any old game being played
 */
public void newGame(){
  variantHelp.setVisible(false);
  helpMenu.setText(""String_Node_Str"");
  gamePlayHelp.setVisible(true);
  if (PlayGame.menu != null)   PlayGame.menu.setVisible(false);
  if (otherPanel != null)   remove(otherPanel);
  if (mainPanel != null)   remove(mainPanel);
  otherPanel=new NewGameMenu();
  add(otherPanel);
  ChessTimer.stopTimers();
  gamePlayHelp.setVisible(true);
  pack();
}"
49938,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        setupPopup(false);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  networkPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame pop=new JFrame(""String_Node_Str"");
      pop.setLayout(new FlowLayout());
      pop.setSize(350,150);
      pop.setResizable(false);
      pop.setLocationRelativeTo(null);
      JPanel options=new JPanel();
      final JLabel label=new JLabel(""String_Node_Str"");
      final JButton client=new JButton(""String_Node_Str"");
      client.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final JFrame popped=new JFrame(""String_Node_Str"");
          popped.setLayout(new GridBagLayout());
          popped.setSize(370,150);
          popped.setResizable(false);
          popped.setLocationRelativeTo(null);
          GridBagConstraints c=new GridBagConstraints();
          final JLabel hoster=new JLabel(""String_Node_Str"");
          final JTextField computer=new JTextField(""String_Node_Str"",2);
          final JButton save=new JButton(""String_Node_Str"");
          save.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (computer.getText().equals(""String_Node_Str"")) {
                JOptionPane.showMessageDialog(null,""String_Node_Str"");
                return;
              }
 else               if (computer.getText().length() < 2) {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
 else {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
              NewGameMenu.cancelled=false;
              Thread client;
              try {
                client=new Thread(new Runnable(){
                  @Override public void run(){
                    try {
                      new NetworkClient().join(host);
                    }
 catch (                    Exception e) {
                      e.printStackTrace();
                    }
                  }
                }
);
                client.start();
                Driver.getInstance().setPanel(new NetLoading(client));
              }
 catch (              Exception e1) {
                e1.printStackTrace();
              }
              popped.dispose();
              pop.dispose();
            }
          }
);
          final JButton back=new JButton(""String_Node_Str"");
          back.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent arg0){
              popped.dispose();
            }
          }
);
          JPanel everything=new JPanel();
          everything.setLayout(new GridBagLayout());
          c.gridx=0;
          c.gridy=0;
          c.gridwidth=2;
          c.insets=new Insets(3,3,3,3);
          popped.add(hoster,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(new JLabel(""String_Node_Str""),c);
          c.gridx=1;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(computer,c);
          c.gridx=0;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(back,c);
          c.gridx=1;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(save,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=2;
          popped.add(everything,c);
          popped.setVisible(true);
        }
      }
);
      final JButton host=new JButton(""String_Node_Str"");
      host.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          setupPopup(true);
          pop.dispose();
        }
      }
);
      options.add(label);
      pop.add(options);
      pop.add(host);
      pop.add(client);
      pop.setVisible(true);
    }
  }
);
  AIPlay=new JButton(""String_Node_Str"");
  AIPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final JFrame popped=new JFrame(""String_Node_Str"");
      popped.setLayout(new GridBagLayout());
      popped.setSize(225,150);
      popped.setResizable(false);
      popped.setLocationRelativeTo(null);
      GridBagConstraints c=new GridBagConstraints();
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      c.gridx=0;
      c.gridy=0;
      popped.add(new JLabel(""String_Node_Str""),c);
      c.gridx=1;
      c.gridy=0;
      c.insets=new Insets(3,0,3,0);
      popped.add(dropdown,c);
      c.gridx=0;
      c.gridy=1;
      popped.add(new JLabel(""String_Node_Str""),c);
      File dir=new File(""String_Node_Str"");
      dir.mkdir();
      String[] allFiles=dir.list();
      List<String> tempFiles=new ArrayList<String>();
      for (      String st : allFiles)       if (st.endsWith(""String_Node_Str""))       tempFiles.add(st);
      String[] files=new String[tempFiles.size()];
      tempFiles.toArray(files);
      if (files.length == 0) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JComboBox ai=new JComboBox(files);
      c.gridx=1;
      c.gridy=1;
      c.fill=GridBagConstraints.HORIZONTAL;
      popped.add(ai,c);
      JButton next=new JButton(""String_Node_Str"");
      next.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final String choice=(String)ai.getSelectedItem();
          File file=new File(""String_Node_Str"" + choice);
          if (ai.getSelectedItem() == null) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
            return;
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
          StandardJavaFileManager fileManager=compiler.getStandardFileManager(null,Locale.getDefault(),null);
          String[] compileOptions=new String[]{""String_Node_Str"",""String_Node_Str""};
          Iterable<String> compilationOptions=Arrays.asList(compileOptions);
          List<File> sourceFileList=new ArrayList<File>();
          sourceFileList.add(file);
          Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(sourceFileList);
          CompilationTask task=compiler.getTask(null,fileManager,null,compilationOptions,null,compilationUnits);
          boolean result=task.call();
          if (result) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            return;
          }
          try {
            fileManager.close();
          }
 catch (          IOException e) {
          }
          final AIPlugin plugin;
          final AIAdapter ai=new AIAdapter(toPlay);
          try {
            ClassLoader c=ClassLoader.getSystemClassLoader();
            Class<?> klazz=c.loadClass(choice.substring(0,choice.indexOf(""String_Node_Str"")));
            Constructor<?> construct=klazz.getConstructor();
            plugin=(AIPlugin)construct.newInstance();
            Thread aiThread;
            aiThread=new Thread(new Runnable(){
              @Override public void run(){
                try {
                  ai.runGame(plugin);
                }
 catch (                Exception e) {
                  e.printStackTrace();
                }
              }
            }
);
            aiThread.start();
          }
 catch (          Exception e1) {
            e1.printStackTrace();
          }
          try {
            PlayNetGame png=new PlayNetGame(toPlay,false,false);
            png.setAIGame(true);
            Driver.getInstance().setPanel(png);
          }
 catch (          Exception e) {
            return;
          }
          popped.dispose();
        }
      }
);
      JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          popped.dispose();
        }
      }
);
      JPanel buttons=new JPanel();
      buttons.setLayout(new FlowLayout());
      buttons.add(back);
      buttons.add(next);
      c.gridx=0;
      c.gridy=2;
      c.gridwidth=2;
      popped.add(buttons,c);
      popped.setVisible(true);
    }
  }
);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().helpMenu.setText(""String_Node_Str"");
      Driver.getInstance().gamePlayHelp.setVisible(false);
      Driver.getInstance().revertPanel();
    }
  }
);
  try {
    if (InetAddress.getLocalHost().getHostName().contains(""String_Node_Str"")) {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,0);
      add(humanPlay,c);
      c.gridx=1;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(networkPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.gridwidth=2;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
 else {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(humanPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        setupPopup(false);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  networkPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame pop=new JFrame(""String_Node_Str"");
      pop.setLayout(new FlowLayout());
      pop.setSize(350,150);
      pop.setResizable(false);
      pop.setLocationRelativeTo(null);
      JPanel options=new JPanel();
      final JLabel label=new JLabel(""String_Node_Str"");
      final JButton client=new JButton(""String_Node_Str"");
      client.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final JFrame popped=new JFrame(""String_Node_Str"");
          popped.setLayout(new GridBagLayout());
          popped.setSize(370,150);
          popped.setResizable(false);
          popped.setLocationRelativeTo(null);
          GridBagConstraints c=new GridBagConstraints();
          final JLabel hoster=new JLabel(""String_Node_Str"");
          final JTextField computer=new JTextField(""String_Node_Str"",2);
          final JButton save=new JButton(""String_Node_Str"");
          save.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (computer.getText().equals(""String_Node_Str"")) {
                JOptionPane.showMessageDialog(null,""String_Node_Str"");
                return;
              }
 else               if (computer.getText().length() < 2) {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
 else {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
              NewGameMenu.cancelled=false;
              Thread client;
              try {
                client=new Thread(new Runnable(){
                  @Override public void run(){
                    try {
                      new NetworkClient().join(host);
                    }
 catch (                    Exception e) {
                      e.printStackTrace();
                    }
                  }
                }
);
                client.start();
                Driver.getInstance().setPanel(new NetLoading(client));
              }
 catch (              Exception e1) {
                e1.printStackTrace();
              }
              popped.dispose();
              pop.dispose();
            }
          }
);
          final JButton back=new JButton(""String_Node_Str"");
          back.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent arg0){
              popped.dispose();
            }
          }
);
          JPanel everything=new JPanel();
          everything.setLayout(new GridBagLayout());
          c.gridx=0;
          c.gridy=0;
          c.gridwidth=2;
          c.insets=new Insets(3,3,3,3);
          popped.add(hoster,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(new JLabel(""String_Node_Str""),c);
          c.gridx=1;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(computer,c);
          c.gridx=0;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(back,c);
          c.gridx=1;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(save,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=2;
          popped.add(everything,c);
          popped.setVisible(true);
        }
      }
);
      final JButton host=new JButton(""String_Node_Str"");
      host.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          setupPopup(true);
          pop.dispose();
        }
      }
);
      options.add(label);
      pop.add(options);
      pop.add(host);
      pop.add(client);
      pop.setVisible(true);
    }
  }
);
  AIPlay=new JButton(""String_Node_Str"");
  AIPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final JFrame popped=new JFrame(""String_Node_Str"");
      popped.setLayout(new GridBagLayout());
      popped.setSize(225,150);
      popped.setResizable(false);
      popped.setLocationRelativeTo(null);
      GridBagConstraints c=new GridBagConstraints();
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      c.gridx=0;
      c.gridy=0;
      popped.add(new JLabel(""String_Node_Str""),c);
      c.gridx=1;
      c.gridy=0;
      c.insets=new Insets(3,0,3,0);
      popped.add(dropdown,c);
      c.gridx=0;
      c.gridy=1;
      popped.add(new JLabel(""String_Node_Str""),c);
      File dir=new File(""String_Node_Str"");
      dir.mkdir();
      String[] allFiles=dir.list();
      List<String> tempFiles=new ArrayList<String>();
      for (      String st : allFiles)       if (st.endsWith(""String_Node_Str""))       tempFiles.add(st);
      String[] files=new String[tempFiles.size()];
      tempFiles.toArray(files);
      if (files.length == 0) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JComboBox ai=new JComboBox(files);
      c.gridx=1;
      c.gridy=1;
      c.fill=GridBagConstraints.HORIZONTAL;
      popped.add(ai,c);
      JButton next=new JButton(""String_Node_Str"");
      next.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final String choice=(String)ai.getSelectedItem();
          File file=new File(""String_Node_Str"" + choice);
          if (ai.getSelectedItem() == null) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
            return;
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
          StandardJavaFileManager fileManager=compiler.getStandardFileManager(null,Locale.getDefault(),null);
          String[] compileOptions=new String[]{""String_Node_Str"",""String_Node_Str""};
          Iterable<String> compilationOptions=Arrays.asList(compileOptions);
          List<File> sourceFileList=new ArrayList<File>();
          sourceFileList.add(file);
          Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(sourceFileList);
          CompilationTask task=compiler.getTask(null,fileManager,null,compilationOptions,null,compilationUnits);
          boolean result=task.call();
          if (!result) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            return;
          }
          try {
            fileManager.close();
          }
 catch (          IOException e) {
          }
          final AIPlugin plugin;
          final AIAdapter ai=new AIAdapter(toPlay);
          try {
            ClassLoader c=ClassLoader.getSystemClassLoader();
            Class<?> klazz=c.loadClass(choice.substring(0,choice.indexOf(""String_Node_Str"")));
            Constructor<?> construct=klazz.getConstructor();
            plugin=(AIPlugin)construct.newInstance();
            Thread aiThread;
            aiThread=new Thread(new Runnable(){
              @Override public void run(){
                try {
                  ai.runGame(plugin);
                }
 catch (                Exception e) {
                  e.printStackTrace();
                }
              }
            }
);
            aiThread.start();
          }
 catch (          Exception e1) {
            e1.printStackTrace();
          }
          try {
            PlayNetGame png=new PlayNetGame(toPlay,false,false);
            png.setAIGame(true);
            Driver.getInstance().setPanel(png);
          }
 catch (          Exception e) {
            return;
          }
          popped.dispose();
        }
      }
);
      JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          popped.dispose();
        }
      }
);
      JPanel buttons=new JPanel();
      buttons.setLayout(new FlowLayout());
      buttons.add(back);
      buttons.add(next);
      c.gridx=0;
      c.gridy=2;
      c.gridwidth=2;
      popped.add(buttons,c);
      popped.setVisible(true);
    }
  }
);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().helpMenu.setText(""String_Node_Str"");
      Driver.getInstance().gamePlayHelp.setVisible(false);
      Driver.getInstance().revertPanel();
    }
  }
);
  try {
    if (InetAddress.getLocalHost().getHostName().contains(""String_Node_Str"")) {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,0);
      add(humanPlay,c);
      c.gridx=1;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(networkPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.gridwidth=2;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
 else {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(humanPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
  }
 catch (  Exception e) {
  }
}"
49939,"/** 
 * @param r Reference to which button the user clicked for the end game. ""Save"" ""New Game"" or ""Quit""
 */
public static void endOfGame(Result r){
  PlayNetGame.running=false;
  if (g.getHistory().size() != 0)   PlayNetGame.netMove=g.moveToFakeMove(g.getHistory().get(g.getHistory().size() - 1));
 else {
    JOptionPane.showMessageDialog(null,""String_Node_Str"");
    PlayNetGame.running=false;
    Driver.getInstance().revertPanel();
    Driver.getInstance().gamePlayHelp.setVisible(false);
    Driver.getInstance().helpMenu.setText(""String_Node_Str"");
    Driver.getInstance().fileMenu.setVisible(true);
    return;
  }
  if (isPlayback)   return;
  Object[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  menu.setVisible(false);
  int answer=JOptionPane.showOptionDialog(null,r.text(),r.winText(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0]);
switch (answer) {
case 0:
    String fileName=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
  getGame().saveGame(""String_Node_Str"",fileName,getGame().isClassicChess());
g.setBlackMove(false);
Driver.getInstance().gamePlayHelp.setVisible(false);
Driver.getInstance().helpMenu.setText(""String_Node_Str"");
Driver.getInstance().fileMenu.setVisible(true);
Driver.getInstance().revertPanel();
break;
case 2:
g.setBlackMove(false);
System.exit(0);
break;
default :
g.setBlackMove(false);
Driver.getInstance().newGame();
}
}","/** 
 * @param r Reference to which button the user clicked for the end game. ""Save"" ""New Game"" or ""Quit""
 */
public static void endOfGame(Result r){
  PlayNetGame.running=false;
  if (g.getHistory().size() != 0)   PlayNetGame.netMove=g.moveToFakeMove(g.getHistory().get(g.getHistory().size() - 1));
 else   if (!r.isDraw()) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"");
    PlayNetGame.running=false;
    Driver.getInstance().revertPanel();
    Driver.getInstance().gamePlayHelp.setVisible(false);
    Driver.getInstance().helpMenu.setText(""String_Node_Str"");
    Driver.getInstance().fileMenu.setVisible(true);
    return;
  }
  if (isPlayback)   return;
  Object[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  menu.setVisible(false);
  int answer=JOptionPane.showOptionDialog(null,r.text(),r.winText(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0]);
switch (answer) {
case 0:
    String fileName=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
  getGame().saveGame(""String_Node_Str"",fileName,getGame().isClassicChess());
g.setBlackMove(false);
Driver.getInstance().gamePlayHelp.setVisible(false);
Driver.getInstance().helpMenu.setText(""String_Node_Str"");
Driver.getInstance().fileMenu.setVisible(true);
Driver.getInstance().revertPanel();
break;
case 2:
g.setBlackMove(false);
System.exit(0);
break;
default :
g.setBlackMove(false);
Driver.getInstance().newGame();
}
}"
49940,"/** 
 * Setter method for boolean indicating if the current game is an AIGame.
 * @param AIGame If this game is an AIGame
 */
public void setAIGame(boolean AIGame){
  this.AIGame=AIGame;
  Driver.getInstance().fileMenu.setVisible(true);
}","/** 
 * Setter method for boolean indicating if the current game is an AIGame.
 * @param AIGame If this game is an AIGame
 */
public void setAIGame(boolean AIGame){
  this.AIGame=AIGame;
  Driver.getInstance().fileMenu.setVisible(true);
  drawItem.setText(""String_Node_Str"");
}"
49941,"public void join(String host) throws Exception {
  Socket socket=null;
  ObjectOutputStream out=null;
  ObjectInputStream in=null;
  while (socket == null) {
    try {
      socket=new Socket(host,27335);
    }
 catch (    Exception e) {
      if (NewGameMenu.cancelled)       return;
    }
  }
  AnimatedLabel.finished=true;
  out=new ObjectOutputStream(socket.getOutputStream());
  in=new ObjectInputStream(socket.getInputStream());
  Object fromServer=null;
  Object fromUser;
  Game g=(Game)in.readObject();
  PlayNetGame png=new PlayNetGame(g,false,true);
  PlayGame.resetTimers();
  Driver.getInstance().setPanel(png);
  try {
    while (PlayNetGame.running) {
      while (g.isBlackMove() == false && PlayNetGame.running) {
        fromServer=in.readObject();
        FakeMove toMove=(FakeMove)fromServer;
        if (toMove.originCol == -1) {
          int surrender=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (surrender == 0) {
            out.writeObject(new FakeMove(-2,-2,-2,-2,-2,null));
            Result r=new Result(Result.DRAW);
            r.setText(""String_Node_Str"");
            g.getLastMove().setResult(r);
            PlayGame.endOfGame(r);
            throw new Exception();
          }
 else {
            out.writeObject(new FakeMove(-3,-3,-3,-3,-3,null));
            continue;
          }
        }
 else {
          g.playMove(g.fakeToRealMove((FakeMove)fromServer));
          if (g.getLastMove().getResult() != null)           continue;
        }
      }
      while (g.isBlackMove() == true && PlayNetGame.running) {
        while (PlayNetGame.netMove == null && !png.drawRequested && PlayNetGame.running)         Thread.sleep(0);
        if (png.drawRequested) {
          fromServer=in.readObject();
          FakeMove toMove=(FakeMove)fromServer;
          if (toMove.originCol == -2) {
            Result r=new Result(Result.DRAW);
            r.setText(""String_Node_Str"");
            g.getLastMove().setResult(r);
            PlayGame.endOfGame(r);
            png.drawRequested=false;
            throw new Exception();
          }
 else           if (toMove.originCol == -3) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
            png.drawRequested=false;
            continue;
          }
        }
        fromUser=PlayNetGame.netMove;
        PlayNetGame.netMove=null;
        if (fromUser != null && ((FakeMove)fromUser).originCol == -1)         png.drawRequested=true;
        out.writeObject(fromUser);
        out.flush();
        if (g.getLastMove().getResult() != null)         break;
      }
    }
  }
 catch (  SocketException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    Driver.getInstance().fileMenu.setVisible(true);
    Driver.getInstance().gameOptions.setVisible(false);
    Driver.getInstance().revertPanel();
    return;
  }
catch (  EOFException e) {
    e.printStackTrace();
    if (g.getHistory().size() != 0 && g.getHistory().get(g.getHistory().size() - 1).getResult() != null)     return;
    if (!PlayNetGame.running)     return;
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    g.getBlackTimer().stop();
    g.getWhiteTimer().stop();
    Driver.getInstance().fileMenu.setVisible(true);
    Driver.getInstance().gameOptions.setVisible(false);
    Driver.getInstance().revertPanel();
    return;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  out.close();
  in.close();
  socket.close();
}","/** 
 * Method to allow the client to join the host
 * @param host the computer being joined to
 * @throws Exception throws an end of file or socket exception
 */
public void join(String host) throws Exception {
  Socket socket=null;
  ObjectOutputStream out=null;
  ObjectInputStream in=null;
  while (socket == null) {
    try {
      socket=new Socket(host,27335);
    }
 catch (    Exception e) {
      if (NewGameMenu.cancelled)       return;
    }
  }
  AnimatedLabel.finished=true;
  out=new ObjectOutputStream(socket.getOutputStream());
  in=new ObjectInputStream(socket.getInputStream());
  Object fromServer=null;
  Object fromUser;
  Game g=(Game)in.readObject();
  PlayNetGame png=new PlayNetGame(g,false,true);
  PlayGame.resetTimers();
  Driver.getInstance().setPanel(png);
  try {
    while (PlayNetGame.running) {
      while (g.isBlackMove() == false && PlayNetGame.running) {
        fromServer=in.readObject();
        FakeMove toMove=(FakeMove)fromServer;
        if (toMove.originCol == -1) {
          int surrender=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (surrender == 0) {
            out.writeObject(new FakeMove(-2,-2,-2,-2,-2,null));
            Result r=new Result(Result.DRAW);
            r.setText(""String_Node_Str"");
            g.getLastMove().setResult(r);
            PlayGame.endOfGame(r);
            throw new Exception();
          }
 else {
            out.writeObject(new FakeMove(-3,-3,-3,-3,-3,null));
            continue;
          }
        }
 else {
          g.playMove(g.fakeToRealMove((FakeMove)fromServer));
          if (g.getLastMove().getResult() != null)           continue;
        }
      }
      while (g.isBlackMove() == true && PlayNetGame.running) {
        while (PlayNetGame.netMove == null && !png.drawRequested && PlayNetGame.running)         Thread.sleep(0);
        if (png.drawRequested) {
          fromServer=in.readObject();
          FakeMove toMove=(FakeMove)fromServer;
          if (toMove.originCol == -2) {
            Result r=new Result(Result.DRAW);
            r.setText(""String_Node_Str"");
            g.getLastMove().setResult(r);
            PlayGame.endOfGame(r);
            png.drawRequested=false;
            throw new Exception();
          }
 else           if (toMove.originCol == -3) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
            png.drawRequested=false;
            continue;
          }
        }
        fromUser=PlayNetGame.netMove;
        PlayNetGame.netMove=null;
        if (fromUser != null && ((FakeMove)fromUser).originCol == -1)         png.drawRequested=true;
        out.writeObject(fromUser);
        out.flush();
        if (g.getLastMove().getResult() != null)         break;
      }
    }
  }
 catch (  SocketException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    Driver.getInstance().fileMenu.setVisible(true);
    Driver.getInstance().gameOptions.setVisible(false);
    Driver.getInstance().revertPanel();
    return;
  }
catch (  EOFException e) {
    e.printStackTrace();
    if (g.getHistory().size() != 0 && g.getHistory().get(g.getHistory().size() - 1).getResult() != null)     return;
    if (!PlayNetGame.running)     return;
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    g.getBlackTimer().stop();
    g.getWhiteTimer().stop();
    Driver.getInstance().fileMenu.setVisible(true);
    Driver.getInstance().gameOptions.setVisible(false);
    Driver.getInstance().revertPanel();
    return;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  out.close();
  in.close();
  socket.close();
}"
49942,"public void host(PlayNetGame png) throws Exception {
  ServerSocket serverSocket=null;
  Socket clientSocket=null;
  serverSocket=new ServerSocket(27335);
  serverSocket.setSoTimeout(1000);
  while (clientSocket == null) {
    try {
      PlayGame.resetTimers();
      clientSocket=serverSocket.accept();
    }
 catch (    Exception e) {
      if (NewGameMenu.cancelled)       return;
    }
  }
  AnimatedLabel.finished=true;
  ObjectOutputStream out=new ObjectOutputStream(clientSocket.getOutputStream());
  ObjectInputStream in=new ObjectInputStream(clientSocket.getInputStream());
  Object fromUser;
  Object fromServer;
  Game g=PlayNetGame.getGame();
  fromServer=g;
  if (fromServer != null)   out.writeObject(fromServer);
  PlayGame.resetTimers();
  Driver.getInstance().setPanel(png);
  try {
    while (g.isBlackMove() == false) {
      while (PlayNetGame.netMove == null)       Thread.sleep(0);
      fromServer=PlayNetGame.netMove;
      PlayNetGame.netMove=null;
      out.writeObject(fromServer);
      out.flush();
    }
    while (PlayNetGame.running) {
      while (g.isBlackMove() == true && PlayNetGame.running) {
        fromUser=in.readObject();
        FakeMove toMove=(FakeMove)fromUser;
        if (toMove.originCol == -1) {
          int surrender=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (surrender == 0) {
            out.writeObject(new FakeMove(-2,-2,-2,-2,-2,null));
            Result r=new Result(Result.DRAW);
            r.setText(""String_Node_Str"");
            g.getLastMove().setResult(r);
            PlayGame.endOfGame(r);
            throw new Exception();
          }
 else {
            out.writeObject(new FakeMove(-3,-3,-3,-3,-3,null));
            continue;
          }
        }
 else {
          g.playMove(g.fakeToRealMove((FakeMove)fromUser));
          if (g.getLastMove().getResult() != null)           continue;
        }
      }
      while (g.isBlackMove() == false && PlayNetGame.running) {
        while (PlayNetGame.netMove == null && !png.drawRequested && PlayNetGame.running)         Thread.sleep(0);
        if (png.drawRequested) {
          fromUser=in.readObject();
          FakeMove toMove=(FakeMove)fromUser;
          if (toMove.originCol == -2) {
            Result r=new Result(Result.DRAW);
            r.setText(""String_Node_Str"");
            g.getLastMove().setResult(r);
            PlayGame.endOfGame(r);
            png.drawRequested=false;
            throw new Exception();
          }
 else           if (toMove.originCol == -3) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
            png.drawRequested=false;
            continue;
          }
        }
        fromServer=PlayNetGame.netMove;
        PlayNetGame.netMove=null;
        if (((FakeMove)fromServer).originCol == -1)         png.drawRequested=true;
        out.writeObject(fromServer);
        out.flush();
        if (g.getLastMove().getResult() != null)         break;
      }
    }
  }
 catch (  SocketException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    Driver.getInstance().fileMenu.setVisible(true);
    Driver.getInstance().gameOptions.setVisible(false);
    Driver.getInstance().revertPanel();
    serverSocket.close();
    return;
  }
catch (  EOFException e) {
    e.printStackTrace();
    if (g.getHistory().size() != 0 && g.getHistory().get(g.getHistory().size() - 1).getResult() != null)     return;
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    g.getBlackTimer().stop();
    g.getWhiteTimer().stop();
    Driver.getInstance().fileMenu.setVisible(true);
    Driver.getInstance().gameOptions.setVisible(false);
    Driver.getInstance().revertPanel();
    serverSocket.close();
    return;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  out.close();
  in.close();
  clientSocket.close();
  serverSocket.close();
}","/** 
 * Method to create the host to wait for a client and to set up the new game
 * @param png the game that is going to be played
 * @throws Exception socket or end of file exception
 */
public void host(PlayNetGame png) throws Exception {
  ServerSocket serverSocket=null;
  Socket clientSocket=null;
  serverSocket=new ServerSocket(27335);
  serverSocket.setSoTimeout(1000);
  while (clientSocket == null) {
    try {
      PlayGame.resetTimers();
      clientSocket=serverSocket.accept();
    }
 catch (    Exception e) {
      if (NewGameMenu.cancelled)       return;
    }
  }
  AnimatedLabel.finished=true;
  ObjectOutputStream out=new ObjectOutputStream(clientSocket.getOutputStream());
  ObjectInputStream in=new ObjectInputStream(clientSocket.getInputStream());
  Object fromUser;
  Object fromServer;
  Game g=PlayNetGame.getGame();
  fromServer=g;
  if (fromServer != null)   out.writeObject(fromServer);
  PlayGame.resetTimers();
  Driver.getInstance().setPanel(png);
  try {
    while (g.isBlackMove() == false) {
      while (PlayNetGame.netMove == null)       Thread.sleep(0);
      fromServer=PlayNetGame.netMove;
      PlayNetGame.netMove=null;
      out.writeObject(fromServer);
      out.flush();
    }
    while (PlayNetGame.running) {
      while (g.isBlackMove() == true && PlayNetGame.running) {
        fromUser=in.readObject();
        FakeMove toMove=(FakeMove)fromUser;
        if (toMove.originCol == -1) {
          int surrender=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (surrender == 0) {
            out.writeObject(new FakeMove(-2,-2,-2,-2,-2,null));
            Result r=new Result(Result.DRAW);
            r.setText(""String_Node_Str"");
            g.getLastMove().setResult(r);
            PlayGame.endOfGame(r);
            throw new Exception();
          }
 else {
            out.writeObject(new FakeMove(-3,-3,-3,-3,-3,null));
            continue;
          }
        }
 else {
          g.playMove(g.fakeToRealMove((FakeMove)fromUser));
          if (g.getLastMove().getResult() != null)           continue;
        }
      }
      while (g.isBlackMove() == false && PlayNetGame.running) {
        while (PlayNetGame.netMove == null && !png.drawRequested && PlayNetGame.running)         Thread.sleep(0);
        if (png.drawRequested) {
          fromUser=in.readObject();
          FakeMove toMove=(FakeMove)fromUser;
          if (toMove.originCol == -2) {
            Result r=new Result(Result.DRAW);
            r.setText(""String_Node_Str"");
            g.getLastMove().setResult(r);
            PlayGame.endOfGame(r);
            png.drawRequested=false;
            throw new Exception();
          }
 else           if (toMove.originCol == -3) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
            png.drawRequested=false;
            continue;
          }
        }
        fromServer=PlayNetGame.netMove;
        PlayNetGame.netMove=null;
        if (((FakeMove)fromServer).originCol == -1)         png.drawRequested=true;
        out.writeObject(fromServer);
        out.flush();
        if (g.getLastMove().getResult() != null)         break;
      }
    }
  }
 catch (  SocketException e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    Driver.getInstance().fileMenu.setVisible(true);
    Driver.getInstance().gameOptions.setVisible(false);
    Driver.getInstance().revertPanel();
    serverSocket.close();
    return;
  }
catch (  EOFException e) {
    e.printStackTrace();
    if (g.getHistory().size() != 0 && g.getHistory().get(g.getHistory().size() - 1).getResult() != null)     return;
    JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    g.getBlackTimer().stop();
    g.getWhiteTimer().stop();
    Driver.getInstance().fileMenu.setVisible(true);
    Driver.getInstance().gameOptions.setVisible(false);
    Driver.getInstance().revertPanel();
    serverSocket.close();
    return;
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  out.close();
  in.close();
  clientSocket.close();
  serverSocket.close();
}"
49943,public FakeMove getMove(AIBoard[] boards);,public abstract FakeMove getMove(AIBoard[] boards);
49944,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        setupPopup(false);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  networkPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame pop=new JFrame(""String_Node_Str"");
      pop.setLayout(new FlowLayout());
      pop.setSize(350,150);
      pop.setResizable(false);
      pop.setLocationRelativeTo(null);
      JPanel options=new JPanel();
      final JLabel label=new JLabel(""String_Node_Str"");
      final JButton client=new JButton(""String_Node_Str"");
      client.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final JFrame popped=new JFrame(""String_Node_Str"");
          popped.setLayout(new GridBagLayout());
          popped.setSize(370,150);
          popped.setResizable(false);
          popped.setLocationRelativeTo(null);
          GridBagConstraints c=new GridBagConstraints();
          final JLabel hoster=new JLabel(""String_Node_Str"");
          final JTextField computer=new JTextField(""String_Node_Str"",2);
          final JButton save=new JButton(""String_Node_Str"");
          save.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (computer.getText().equals(""String_Node_Str"")) {
                JOptionPane.showMessageDialog(null,""String_Node_Str"");
                return;
              }
 else               if (computer.getText().length() < 2) {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
 else {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
              NewGameMenu.cancelled=false;
              Thread client;
              try {
                client=new Thread(new Runnable(){
                  @Override public void run(){
                    try {
                      new NetworkClient().join(host);
                    }
 catch (                    Exception e) {
                      e.printStackTrace();
                    }
                  }
                }
);
                client.start();
                Driver.getInstance().setPanel(new NetLoading(client));
              }
 catch (              Exception e1) {
                e1.printStackTrace();
              }
              popped.dispose();
              pop.dispose();
            }
          }
);
          final JButton back=new JButton(""String_Node_Str"");
          back.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent arg0){
              popped.dispose();
            }
          }
);
          JPanel everything=new JPanel();
          everything.setLayout(new GridBagLayout());
          c.gridx=0;
          c.gridy=0;
          c.gridwidth=2;
          c.insets=new Insets(3,3,3,3);
          popped.add(hoster,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(new JLabel(""String_Node_Str""),c);
          c.gridx=1;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(computer,c);
          c.gridx=0;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(back,c);
          c.gridx=1;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(save,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=2;
          popped.add(everything,c);
          popped.setVisible(true);
        }
      }
);
      final JButton host=new JButton(""String_Node_Str"");
      host.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          setupPopup(true);
          pop.dispose();
        }
      }
);
      options.add(label);
      pop.add(options);
      pop.add(host);
      pop.add(client);
      pop.setVisible(true);
    }
  }
);
  AIPlay=new JButton(""String_Node_Str"");
  AIPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final JFrame popped=new JFrame(""String_Node_Str"");
      popped.setLayout(new GridBagLayout());
      popped.setSize(225,150);
      popped.setResizable(false);
      popped.setLocationRelativeTo(null);
      GridBagConstraints c=new GridBagConstraints();
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      c.gridx=0;
      c.gridy=0;
      popped.add(new JLabel(""String_Node_Str""),c);
      c.gridx=1;
      c.gridy=0;
      c.insets=new Insets(3,0,3,0);
      popped.add(dropdown,c);
      c.gridx=0;
      c.gridy=1;
      popped.add(new JLabel(""String_Node_Str""),c);
      File dir=new File(""String_Node_Str"");
      dir.mkdir();
      String[] allFiles=dir.list();
      List<String> tempFiles=new ArrayList<String>();
      for (      String st : allFiles)       if (st.endsWith(""String_Node_Str""))       tempFiles.add(st);
      String[] files=new String[tempFiles.size()];
      tempFiles.toArray(files);
      if (files.length == 0) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JComboBox ai=new JComboBox(files);
      c.gridx=1;
      c.gridy=1;
      c.fill=GridBagConstraints.HORIZONTAL;
      popped.add(ai,c);
      JButton next=new JButton(""String_Node_Str"");
      next.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final String choice=(String)ai.getSelectedItem();
          File file=new File(""String_Node_Str"" + choice);
          if (ai.getSelectedItem() == null) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
            return;
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
          StandardJavaFileManager fileManager=compiler.getStandardFileManager(null,Locale.getDefault(),null);
          String[] compileOptions=new String[]{""String_Node_Str"",""String_Node_Str""};
          Iterable<String> compilationOptions=Arrays.asList(compileOptions);
          List<File> sourceFileList=new ArrayList<File>();
          sourceFileList.add(file);
          Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(sourceFileList);
          CompilationTask task=compiler.getTask(null,fileManager,null,compilationOptions,null,compilationUnits);
          boolean result=task.call();
          if (result) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            return;
          }
          try {
            fileManager.close();
          }
 catch (          IOException e) {
          }
          final AIPlugin plugin;
          final AIAdapter ai=new AIAdapter(toPlay);
          try {
            ClassLoader c=ClassLoader.getSystemClassLoader();
            Class<?> klazz=c.loadClass(choice.substring(0,choice.indexOf(""String_Node_Str"")));
            Constructor<?> construct=klazz.getConstructor();
            plugin=(AIPlugin)construct.newInstance();
            Thread aiThread;
            aiThread=new Thread(new Runnable(){
              @Override public void run(){
                try {
                  ai.runGame(plugin);
                }
 catch (                Exception e) {
                  e.printStackTrace();
                }
              }
            }
);
            aiThread.start();
          }
 catch (          Exception e1) {
            e1.printStackTrace();
          }
          try {
            Driver.getInstance().setPanel(new PlayNetGame(toPlay,false,false));
          }
 catch (          Exception e) {
            return;
          }
          popped.dispose();
        }
      }
);
      JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          popped.dispose();
        }
      }
);
      JPanel buttons=new JPanel();
      buttons.setLayout(new FlowLayout());
      buttons.add(back);
      buttons.add(next);
      c.gridx=0;
      c.gridy=2;
      c.gridwidth=2;
      popped.add(buttons,c);
      popped.setVisible(true);
    }
  }
);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().helpMenu.setText(""String_Node_Str"");
      Driver.getInstance().gamePlayHelp.setVisible(false);
      Driver.getInstance().revertPanel();
    }
  }
);
  try {
    if (InetAddress.getLocalHost().getHostName().contains(""String_Node_Str"")) {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,0);
      add(humanPlay,c);
      c.gridx=1;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(networkPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.gridwidth=2;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
 else {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(humanPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        setupPopup(false);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  networkPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame pop=new JFrame(""String_Node_Str"");
      pop.setLayout(new FlowLayout());
      pop.setSize(350,150);
      pop.setResizable(false);
      pop.setLocationRelativeTo(null);
      JPanel options=new JPanel();
      final JLabel label=new JLabel(""String_Node_Str"");
      final JButton client=new JButton(""String_Node_Str"");
      client.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final JFrame popped=new JFrame(""String_Node_Str"");
          popped.setLayout(new GridBagLayout());
          popped.setSize(370,150);
          popped.setResizable(false);
          popped.setLocationRelativeTo(null);
          GridBagConstraints c=new GridBagConstraints();
          final JLabel hoster=new JLabel(""String_Node_Str"");
          final JTextField computer=new JTextField(""String_Node_Str"",2);
          final JButton save=new JButton(""String_Node_Str"");
          save.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (computer.getText().equals(""String_Node_Str"")) {
                JOptionPane.showMessageDialog(null,""String_Node_Str"");
                return;
              }
 else               if (computer.getText().length() < 2) {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
 else {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
              NewGameMenu.cancelled=false;
              Thread client;
              try {
                client=new Thread(new Runnable(){
                  @Override public void run(){
                    try {
                      new NetworkClient().join(host);
                    }
 catch (                    Exception e) {
                      e.printStackTrace();
                    }
                  }
                }
);
                client.start();
                Driver.getInstance().setPanel(new NetLoading(client));
              }
 catch (              Exception e1) {
                e1.printStackTrace();
              }
              popped.dispose();
              pop.dispose();
            }
          }
);
          final JButton back=new JButton(""String_Node_Str"");
          back.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent arg0){
              popped.dispose();
            }
          }
);
          JPanel everything=new JPanel();
          everything.setLayout(new GridBagLayout());
          c.gridx=0;
          c.gridy=0;
          c.gridwidth=2;
          c.insets=new Insets(3,3,3,3);
          popped.add(hoster,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(new JLabel(""String_Node_Str""),c);
          c.gridx=1;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(computer,c);
          c.gridx=0;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(back,c);
          c.gridx=1;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(save,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=2;
          popped.add(everything,c);
          popped.setVisible(true);
        }
      }
);
      final JButton host=new JButton(""String_Node_Str"");
      host.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          setupPopup(true);
          pop.dispose();
        }
      }
);
      options.add(label);
      pop.add(options);
      pop.add(host);
      pop.add(client);
      pop.setVisible(true);
    }
  }
);
  AIPlay=new JButton(""String_Node_Str"");
  AIPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final JFrame popped=new JFrame(""String_Node_Str"");
      popped.setLayout(new GridBagLayout());
      popped.setSize(225,150);
      popped.setResizable(false);
      popped.setLocationRelativeTo(null);
      GridBagConstraints c=new GridBagConstraints();
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      c.gridx=0;
      c.gridy=0;
      popped.add(new JLabel(""String_Node_Str""),c);
      c.gridx=1;
      c.gridy=0;
      c.insets=new Insets(3,0,3,0);
      popped.add(dropdown,c);
      c.gridx=0;
      c.gridy=1;
      popped.add(new JLabel(""String_Node_Str""),c);
      File dir=new File(""String_Node_Str"");
      dir.mkdir();
      String[] allFiles=dir.list();
      List<String> tempFiles=new ArrayList<String>();
      for (      String st : allFiles)       if (st.endsWith(""String_Node_Str""))       tempFiles.add(st);
      String[] files=new String[tempFiles.size()];
      tempFiles.toArray(files);
      if (files.length == 0) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JComboBox ai=new JComboBox(files);
      c.gridx=1;
      c.gridy=1;
      c.fill=GridBagConstraints.HORIZONTAL;
      popped.add(ai,c);
      JButton next=new JButton(""String_Node_Str"");
      next.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final String choice=(String)ai.getSelectedItem();
          File file=new File(""String_Node_Str"" + choice);
          if (ai.getSelectedItem() == null) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
            return;
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
          StandardJavaFileManager fileManager=compiler.getStandardFileManager(null,Locale.getDefault(),null);
          String[] compileOptions=new String[]{""String_Node_Str"",""String_Node_Str""};
          Iterable<String> compilationOptions=Arrays.asList(compileOptions);
          List<File> sourceFileList=new ArrayList<File>();
          sourceFileList.add(file);
          Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(sourceFileList);
          CompilationTask task=compiler.getTask(null,fileManager,null,compilationOptions,null,compilationUnits);
          boolean result=task.call();
          if (result) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            return;
          }
          try {
            fileManager.close();
          }
 catch (          IOException e) {
          }
          final AIPlugin plugin;
          final AIAdapter ai=new AIAdapter(toPlay);
          try {
            ClassLoader c=ClassLoader.getSystemClassLoader();
            Class<?> klazz=c.loadClass(choice.substring(0,choice.indexOf(""String_Node_Str"")));
            Constructor<?> construct=klazz.getConstructor();
            plugin=(AIPlugin)construct.newInstance();
            Thread aiThread;
            aiThread=new Thread(new Runnable(){
              @Override public void run(){
                try {
                  ai.runGame(plugin);
                }
 catch (                Exception e) {
                  e.printStackTrace();
                }
              }
            }
);
            aiThread.start();
          }
 catch (          Exception e1) {
            e1.printStackTrace();
          }
          try {
            PlayNetGame png=new PlayNetGame(toPlay,false,false);
            png.setAIGame(true);
            Driver.getInstance().setPanel(png);
          }
 catch (          Exception e) {
            return;
          }
          popped.dispose();
        }
      }
);
      JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          popped.dispose();
        }
      }
);
      JPanel buttons=new JPanel();
      buttons.setLayout(new FlowLayout());
      buttons.add(back);
      buttons.add(next);
      c.gridx=0;
      c.gridy=2;
      c.gridwidth=2;
      popped.add(buttons,c);
      popped.setVisible(true);
    }
  }
);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().helpMenu.setText(""String_Node_Str"");
      Driver.getInstance().gamePlayHelp.setVisible(false);
      Driver.getInstance().revertPanel();
    }
  }
);
  try {
    if (InetAddress.getLocalHost().getHostName().contains(""String_Node_Str"")) {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,0);
      add(humanPlay,c);
      c.gridx=1;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(networkPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.gridwidth=2;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
 else {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(humanPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
  }
 catch (  Exception e) {
  }
}"
49945,"@Override public void actionPerformed(ActionEvent e){
  if (getGame().isBlackMove() == isBlack) {
    int surrender=requestDraw();
    if (surrender != 0)     return;
    netMove=new FakeMove(-1,-1,-1,-1,-1,null);
  }
}","@Override public void actionPerformed(ActionEvent e){
  if (getGame().isBlackMove() == isBlack) {
    if (AIGame) {
      int surrender=requestAIDraw();
      if (surrender != 0)       return;
      Result result=new Result(Result.DRAW);
      result.setText(""String_Node_Str"");
      PlayGame.endOfGame(result);
    }
 else {
      int surrender=requestDraw();
      if (surrender != 0)       return;
      netMove=new FakeMove(-1,-1,-1,-1,-1,null);
    }
  }
}"
49946,"public JMenu createMenu(){
  menu=new JMenu(""String_Node_Str"");
  if (!isPlayback) {
    drawItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
    drawItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (getGame().isBlackMove() == isBlack) {
          int surrender=requestDraw();
          if (surrender != 0)           return;
          netMove=new FakeMove(-1,-1,-1,-1,-1,null);
        }
      }
    }
);
    menu.add(drawItem);
  }
  return menu;
}","public JMenu createMenu(){
  menu=new JMenu(""String_Node_Str"");
  if (!isPlayback) {
    drawItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
    drawItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (getGame().isBlackMove() == isBlack) {
          if (AIGame) {
            int surrender=requestAIDraw();
            if (surrender != 0)             return;
            Result result=new Result(Result.DRAW);
            result.setText(""String_Node_Str"");
            PlayGame.endOfGame(result);
          }
 else {
            int surrender=requestDraw();
            if (surrender != 0)             return;
            netMove=new FakeMove(-1,-1,-1,-1,-1,null);
          }
        }
      }
    }
);
    menu.add(drawItem);
  }
  return menu;
}"
49947,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setLocationRelativeTo(null);
  setResizable(false);
  setLayout(new FlowLayout());
  setResizable(true);
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
  }
  mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  BufferedImage temp=null;
  try {
    temp=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  ImageIcon picture=new ImageIcon(temp);
  JLabel pictureHolder=new JLabel();
  picture.setImage(picture.getImage().getScaledInstance(300,200,Image.SCALE_SMOOTH));
  pictureHolder.setIcon(picture);
  newGame=new JButton(""String_Node_Str"");
  newGame.setToolTipText(""String_Node_Str"");
  newGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      pack();
    }
  }
);
  continueGame=new JButton(""String_Node_Str"");
  continueGame.setToolTipText(""String_Node_Str"");
  continueGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        FileInputStream f_in=new FileInputStream(new File(""String_Node_Str"" + choice));
        ObjectInputStream obj_in=new ObjectInputStream(f_in);
        Game toPlay=(Game)obj_in.readObject();
        helpMenu.setText(""String_Node_Str"");
        gamePlayHelp.setVisible(true);
        if (gameOptions != null)         gameOptions.setVisible(true);
        remove(mainPanel);
        otherPanel=new PlayGame(toPlay,false);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  viewGame=new JButton(""String_Node_Str"");
  viewGame.setToolTipText(""String_Node_Str"");
  viewGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        File file=new File(""String_Node_Str"" + choice);
        Game toView;
        if (choice.endsWith(""String_Node_Str"")) {
          try {
            otherPanel=new PlayGame(true,file);
          }
 catch (          Exception e) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
        }
 else {
          FileInputStream f_in=new FileInputStream(file);
          ObjectInputStream obj_in=new ObjectInputStream(f_in);
          toView=(Game)obj_in.readObject();
          otherPanel=new PlayGame(toView,true);
        }
        completedHelp.setVisible(true);
        helpMenu.setText(""String_Node_Str"");
        ;
        remove(mainPanel);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        System.out.println(e.getMessage());
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  createType=new JButton(""String_Node_Str"");
  createType.setToolTipText(""String_Node_Str"");
  createType.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(true);
      helpMenu.setText(""String_Node_Str"");
      remove(mainPanel);
      otherPanel=new NewTypeMenu();
      add(otherPanel);
      pack();
    }
  }
);
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  fileMenu.setForeground(Color.WHITE);
  fileMenu.setMnemonic('F');
  helpMenu=new JMenu(""String_Node_Str"");
  helpMenu.setForeground(Color.white);
  helpMenu.setMnemonic('H');
  JMenuItem helpMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_H);
  helpMenuItem.setToolTipText(""String_Node_Str"");
  BufferedImage help=null;
  try {
    help=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon helpPicture=new ImageIcon(help);
  helpPicture.setImage(helpPicture.getImage().getScaledInstance(600,600,Image.SCALE_SMOOTH));
  helpMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"",""String_Node_Str"",0,helpPicture);
    }
  }
);
  helpMenu.add(helpMenuItem);
  BufferedImage helpGame=null;
  try {
    helpGame=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon gameHelpPicture=new ImageIcon(helpGame);
  gameHelpPicture.setImage(gameHelpPicture.getImage().getScaledInstance(700,375,Image.SCALE_SMOOTH));
  gamePlayHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_G);
  gamePlayHelp.setToolTipText(""String_Node_Str"");
  gamePlayHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",0,gameHelpPicture);
    }
  }
);
  helpMenu.add(gamePlayHelp);
  gamePlayHelp.setVisible(false);
  BufferedImage helpMe=null;
  try {
    helpMe=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon variantPicture=new ImageIcon(helpMe);
  variantPicture.setImage(variantPicture.getImage().getScaledInstance(650,300,Image.SCALE_SMOOTH));
  variantHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_V);
  variantHelp.setToolTipText(""String_Node_Str"");
  variantHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",0,variantPicture);
    }
  }
);
  helpMenu.add(variantHelp);
  variantHelp.setVisible(false);
  completedHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  completedHelp.setToolTipText(""String_Node_Str"");
  completedHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
);
  helpMenu.add(completedHelp);
  completedHelp.setVisible(false);
  JMenuItem newGameItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  newGameItem.setToolTipText(""String_Node_Str"");
  newGameItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(false);
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      if (PlayGame.menu != null)       PlayGame.menu.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      if (mainPanel != null)       remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      gamePlayHelp.setVisible(true);
      pack();
    }
  }
);
  fileMenu.add(newGameItem);
  JMenuItem mainMenu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_M);
  mainMenu.setToolTipText(""String_Node_Str"");
  mainMenu.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      helpMenu.setText(""String_Node_Str"");
      variantHelp.setVisible(false);
      gamePlayHelp.setVisible(false);
      completedHelp.setVisible(false);
      if (gameOptions != null)       gameOptions.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      add(mainPanel);
      pack();
    }
  }
);
  fileMenu.add(mainMenu);
  JMenuItem exitMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_Q);
  exitMenuItem.setToolTipText(""String_Node_Str"");
  exitMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
      if (answer == 0)       System.exit(0);
    }
  }
);
  fileMenu.add(exitMenuItem);
  menuBar.add(fileMenu);
  menuBar.add(helpMenu);
  setJMenuBar(menuBar);
  mainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=0;
  mainPanel.add(pictureHolder,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  mainPanel.add(newGame,c);
  c.gridx=2;
  c.gridy=1;
  c.gridwidth=1;
  mainPanel.add(createType,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mainPanel.add(continueGame,c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mainPanel.add(viewGame,c);
  add(mainPanel);
  setVisible(true);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setLocationRelativeTo(null);
  setResizable(false);
  setLayout(new FlowLayout());
  setResizable(true);
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
  }
  mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  BufferedImage temp=null;
  try {
    temp=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  ImageIcon picture=new ImageIcon(temp);
  JLabel pictureHolder=new JLabel();
  picture.setImage(picture.getImage().getScaledInstance(300,200,Image.SCALE_SMOOTH));
  pictureHolder.setIcon(picture);
  newGame=new JButton(""String_Node_Str"");
  newGame.setToolTipText(""String_Node_Str"");
  newGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      pack();
    }
  }
);
  continueGame=new JButton(""String_Node_Str"");
  continueGame.setToolTipText(""String_Node_Str"");
  continueGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        FileInputStream f_in=new FileInputStream(new File(""String_Node_Str"" + choice));
        ObjectInputStream obj_in=new ObjectInputStream(f_in);
        Game toPlay=(Game)obj_in.readObject();
        helpMenu.setText(""String_Node_Str"");
        gamePlayHelp.setVisible(true);
        if (gameOptions != null)         gameOptions.setVisible(true);
        remove(mainPanel);
        otherPanel=new PlayGame(toPlay,false);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  viewGame=new JButton(""String_Node_Str"");
  viewGame.setToolTipText(""String_Node_Str"");
  viewGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        File file=new File(""String_Node_Str"" + choice);
        Game toView;
        if (choice.endsWith(""String_Node_Str"")) {
          try {
            otherPanel=new PlayGame(true,file);
          }
 catch (          Exception e) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
        }
 else {
          FileInputStream f_in=new FileInputStream(file);
          ObjectInputStream obj_in=new ObjectInputStream(f_in);
          toView=(Game)obj_in.readObject();
          otherPanel=new PlayGame(toView,true);
        }
        completedHelp.setVisible(true);
        helpMenu.setText(""String_Node_Str"");
        ;
        remove(mainPanel);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        System.out.println(e.getMessage());
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  createType=new JButton(""String_Node_Str"");
  createType.setToolTipText(""String_Node_Str"");
  createType.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(true);
      helpMenu.setText(""String_Node_Str"");
      remove(mainPanel);
      otherPanel=new NewTypeMenu();
      add(otherPanel);
      pack();
    }
  }
);
  menuBar=new JMenuBar();
  fileMenu=new JMenu(""String_Node_Str"");
  fileMenu.setForeground(Color.WHITE);
  fileMenu.setMnemonic('F');
  helpMenu=new JMenu(""String_Node_Str"");
  helpMenu.setForeground(Color.white);
  helpMenu.setMnemonic('H');
  JMenuItem helpMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_H);
  helpMenuItem.setToolTipText(""String_Node_Str"");
  BufferedImage help=null;
  try {
    help=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon helpPicture=new ImageIcon(help);
  helpPicture.setImage(helpPicture.getImage().getScaledInstance(600,600,Image.SCALE_SMOOTH));
  helpMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"",""String_Node_Str"",0,helpPicture);
    }
  }
);
  helpMenu.add(helpMenuItem);
  BufferedImage helpGame=null;
  try {
    helpGame=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon gameHelpPicture=new ImageIcon(helpGame);
  gameHelpPicture.setImage(gameHelpPicture.getImage().getScaledInstance(700,375,Image.SCALE_SMOOTH));
  gamePlayHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_G);
  gamePlayHelp.setToolTipText(""String_Node_Str"");
  gamePlayHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",0,gameHelpPicture);
    }
  }
);
  helpMenu.add(gamePlayHelp);
  gamePlayHelp.setVisible(false);
  BufferedImage helpMe=null;
  try {
    helpMe=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon variantPicture=new ImageIcon(helpMe);
  variantPicture.setImage(variantPicture.getImage().getScaledInstance(650,300,Image.SCALE_SMOOTH));
  variantHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_V);
  variantHelp.setToolTipText(""String_Node_Str"");
  variantHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",0,variantPicture);
    }
  }
);
  helpMenu.add(variantHelp);
  variantHelp.setVisible(false);
  completedHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  completedHelp.setToolTipText(""String_Node_Str"");
  completedHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
);
  helpMenu.add(completedHelp);
  completedHelp.setVisible(false);
  JMenuItem newGameItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  newGameItem.setToolTipText(""String_Node_Str"");
  newGameItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(false);
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      if (PlayGame.menu != null)       PlayGame.menu.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      if (mainPanel != null)       remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      ChessTimer.stopTimers();
      gamePlayHelp.setVisible(true);
      pack();
    }
  }
);
  fileMenu.add(newGameItem);
  JMenuItem mainMenu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_M);
  mainMenu.setToolTipText(""String_Node_Str"");
  mainMenu.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      helpMenu.setText(""String_Node_Str"");
      variantHelp.setVisible(false);
      gamePlayHelp.setVisible(false);
      completedHelp.setVisible(false);
      if (gameOptions != null)       gameOptions.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      ChessTimer.stopTimers();
      add(mainPanel);
      pack();
    }
  }
);
  fileMenu.add(mainMenu);
  JMenuItem exitMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_Q);
  exitMenuItem.setToolTipText(""String_Node_Str"");
  exitMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
      if (answer == 0)       System.exit(0);
    }
  }
);
  fileMenu.add(exitMenuItem);
  menuBar.add(fileMenu);
  menuBar.add(helpMenu);
  setJMenuBar(menuBar);
  mainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=0;
  mainPanel.add(pictureHolder,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  mainPanel.add(newGame,c);
  c.gridx=2;
  c.gridy=1;
  c.gridwidth=1;
  mainPanel.add(createType,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mainPanel.add(continueGame,c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mainPanel.add(viewGame,c);
  add(mainPanel);
  setVisible(true);
}"
49948,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        setupPopup(false);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  networkPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame pop=new JFrame(""String_Node_Str"");
      pop.setLayout(new FlowLayout());
      pop.setSize(350,150);
      pop.setResizable(false);
      pop.setLocationRelativeTo(null);
      JPanel options=new JPanel();
      final JLabel label=new JLabel(""String_Node_Str"");
      final JButton client=new JButton(""String_Node_Str"");
      client.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final JFrame popped=new JFrame(""String_Node_Str"");
          popped.setLayout(new GridBagLayout());
          popped.setSize(370,150);
          popped.setResizable(false);
          popped.setLocationRelativeTo(null);
          GridBagConstraints c=new GridBagConstraints();
          final JLabel hoster=new JLabel(""String_Node_Str"");
          final JTextField computer=new JTextField(""String_Node_Str"",2);
          final JButton save=new JButton(""String_Node_Str"");
          save.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (computer.getText().equals(""String_Node_Str"")) {
                JOptionPane.showMessageDialog(null,""String_Node_Str"");
                return;
              }
 else               if (computer.getText().length() < 2) {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
 else {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
              NewGameMenu.cancelled=false;
              Thread client;
              try {
                client=new Thread(new Runnable(){
                  @Override public void run(){
                    try {
                      new NetworkClient().join(host);
                    }
 catch (                    Exception e) {
                      System.out.println(e.getMessage());
                      e.printStackTrace();
                    }
                  }
                }
);
                client.start();
                Driver.getInstance().setPanel(new NetLoading(client));
              }
 catch (              Exception e1) {
                System.out.println(e1.getMessage());
                e1.printStackTrace();
              }
              popped.dispose();
              pop.dispose();
            }
          }
);
          final JButton back=new JButton(""String_Node_Str"");
          back.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent arg0){
              popped.dispose();
            }
          }
);
          JPanel everything=new JPanel();
          everything.setLayout(new GridBagLayout());
          c.gridx=0;
          c.gridy=0;
          c.gridwidth=2;
          c.insets=new Insets(3,3,3,3);
          popped.add(hoster,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(new JLabel(""String_Node_Str""),c);
          c.gridx=1;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(computer,c);
          c.gridx=0;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(back,c);
          c.gridx=1;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(save,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=2;
          popped.add(everything,c);
          popped.setVisible(true);
        }
      }
);
      final JButton host=new JButton(""String_Node_Str"");
      host.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          setupPopup(true);
          pop.dispose();
        }
      }
);
      options.add(label);
      pop.add(options);
      pop.add(host);
      pop.add(client);
      pop.setVisible(true);
    }
  }
);
  AIPlay=new JButton(""String_Node_Str"");
  AIPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final JFrame popped=new JFrame(""String_Node_Str"");
      popped.setLayout(new GridBagLayout());
      popped.setSize(225,150);
      popped.setResizable(false);
      popped.setLocationRelativeTo(null);
      GridBagConstraints c=new GridBagConstraints();
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      c.gridx=0;
      c.gridy=0;
      popped.add(new JLabel(""String_Node_Str""),c);
      c.gridx=1;
      c.gridy=0;
      c.insets=new Insets(3,0,3,0);
      popped.add(dropdown,c);
      c.gridx=0;
      c.gridy=1;
      popped.add(new JLabel(""String_Node_Str""),c);
      File dir=new File(""String_Node_Str"");
      dir.mkdir();
      String[] allFiles=dir.list();
      List<String> tempFiles=new ArrayList<String>();
      for (      String st : allFiles)       if (st.endsWith(""String_Node_Str""))       tempFiles.add(st);
      String[] files=new String[tempFiles.size()];
      tempFiles.toArray(files);
      if (files.length == 0) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JComboBox ai=new JComboBox(files);
      c.gridx=1;
      c.gridy=1;
      c.fill=GridBagConstraints.HORIZONTAL;
      popped.add(ai,c);
      JButton next=new JButton(""String_Node_Str"");
      next.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final String choice=(String)ai.getSelectedItem();
          File file=new File(""String_Node_Str"" + choice);
          if (ai.getSelectedItem() == null) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
            return;
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
          StandardJavaFileManager fileManager=compiler.getStandardFileManager(null,Locale.getDefault(),null);
          String[] compileOptions=new String[]{""String_Node_Str"",""String_Node_Str""};
          Iterable<String> compilationOptions=Arrays.asList(compileOptions);
          List<File> sourceFileList=new ArrayList<File>();
          sourceFileList.add(file);
          Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(sourceFileList);
          CompilationTask task=compiler.getTask(null,fileManager,null,compilationOptions,null,compilationUnits);
          boolean result=task.call();
          if (result) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
          }
          try {
            fileManager.close();
          }
 catch (          IOException e) {
          }
          final AIPlugin plugin;
          final AIAdapter ai=new AIAdapter(toPlay);
          try {
            ClassLoader c=ClassLoader.getSystemClassLoader();
            Class<?> klazz=c.loadClass(""String_Node_Str"" + choice.substring(0,choice.indexOf(""String_Node_Str"")));
            Constructor<?> construct=klazz.getConstructor();
            plugin=(AIPlugin)construct.newInstance();
            Thread aiThread;
            aiThread=new Thread(new Runnable(){
              @Override public void run(){
                try {
                  ai.runGame(plugin);
                }
 catch (                Exception e) {
                  System.out.println(e.getMessage());
                  e.printStackTrace();
                }
              }
            }
);
            aiThread.start();
          }
 catch (          Exception e1) {
            System.out.println(e1.getMessage());
            e1.printStackTrace();
          }
          System.out.println(toPlay.equals(ai.getGame()));
          try {
            Driver.getInstance().setPanel(new PlayNetGame(toPlay,false,false));
          }
 catch (          Exception e) {
            return;
          }
          popped.dispose();
        }
      }
);
      JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          popped.dispose();
        }
      }
);
      JPanel buttons=new JPanel();
      buttons.setLayout(new FlowLayout());
      buttons.add(back);
      buttons.add(next);
      c.gridx=0;
      c.gridy=2;
      c.gridwidth=2;
      popped.add(buttons,c);
      popped.setVisible(true);
    }
  }
);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().helpMenu.setText(""String_Node_Str"");
      Driver.getInstance().gamePlayHelp.setVisible(false);
      Driver.getInstance().revertPanel();
    }
  }
);
  try {
    if (InetAddress.getLocalHost().getHostName().contains(""String_Node_Str"")) {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,0);
      add(humanPlay,c);
      c.gridx=1;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(networkPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.gridwidth=2;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
 else {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(humanPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
  }
 catch (  Exception e) {
  }
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        setupPopup(false);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  networkPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame pop=new JFrame(""String_Node_Str"");
      pop.setLayout(new FlowLayout());
      pop.setSize(350,150);
      pop.setResizable(false);
      pop.setLocationRelativeTo(null);
      JPanel options=new JPanel();
      final JLabel label=new JLabel(""String_Node_Str"");
      final JButton client=new JButton(""String_Node_Str"");
      client.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final JFrame popped=new JFrame(""String_Node_Str"");
          popped.setLayout(new GridBagLayout());
          popped.setSize(370,150);
          popped.setResizable(false);
          popped.setLocationRelativeTo(null);
          GridBagConstraints c=new GridBagConstraints();
          final JLabel hoster=new JLabel(""String_Node_Str"");
          final JTextField computer=new JTextField(""String_Node_Str"",2);
          final JButton save=new JButton(""String_Node_Str"");
          save.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (computer.getText().equals(""String_Node_Str"")) {
                JOptionPane.showMessageDialog(null,""String_Node_Str"");
                return;
              }
 else               if (computer.getText().length() < 2) {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
 else {
                try {
                  int hostNumber=Integer.parseInt(computer.getText());
                  if (hostNumber > 25 || hostNumber < 1)                   throw new Exception();
                  host=""String_Node_Str"" + hostNumber;
                }
 catch (                Exception ne) {
                  JOptionPane.showMessageDialog(null,""String_Node_Str"");
                  return;
                }
              }
              NewGameMenu.cancelled=false;
              Thread client;
              try {
                client=new Thread(new Runnable(){
                  @Override public void run(){
                    try {
                      new NetworkClient().join(host);
                    }
 catch (                    Exception e) {
                      System.out.println(e.getMessage());
                      e.printStackTrace();
                    }
                  }
                }
);
                client.start();
                Driver.getInstance().setPanel(new NetLoading(client));
              }
 catch (              Exception e1) {
                System.out.println(e1.getMessage());
                e1.printStackTrace();
              }
              popped.dispose();
              pop.dispose();
            }
          }
);
          final JButton back=new JButton(""String_Node_Str"");
          back.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent arg0){
              popped.dispose();
            }
          }
);
          JPanel everything=new JPanel();
          everything.setLayout(new GridBagLayout());
          c.gridx=0;
          c.gridy=0;
          c.gridwidth=2;
          c.insets=new Insets(3,3,3,3);
          popped.add(hoster,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(new JLabel(""String_Node_Str""),c);
          c.gridx=1;
          c.gridy=1;
          c.gridwidth=1;
          everything.add(computer,c);
          c.gridx=0;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(back,c);
          c.gridx=1;
          c.gridy=2;
          c.gridwidth=1;
          everything.add(save,c);
          c.gridx=0;
          c.gridy=1;
          c.gridwidth=2;
          popped.add(everything,c);
          popped.setVisible(true);
        }
      }
);
      final JButton host=new JButton(""String_Node_Str"");
      host.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          setupPopup(true);
          pop.dispose();
        }
      }
);
      options.add(label);
      pop.add(options);
      pop.add(host);
      pop.add(client);
      pop.setVisible(true);
    }
  }
);
  AIPlay=new JButton(""String_Node_Str"");
  AIPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final JFrame popped=new JFrame(""String_Node_Str"");
      popped.setLayout(new GridBagLayout());
      popped.setSize(225,150);
      popped.setResizable(false);
      popped.setLocationRelativeTo(null);
      GridBagConstraints c=new GridBagConstraints();
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      c.gridx=0;
      c.gridy=0;
      popped.add(new JLabel(""String_Node_Str""),c);
      c.gridx=1;
      c.gridy=0;
      c.insets=new Insets(3,0,3,0);
      popped.add(dropdown,c);
      c.gridx=0;
      c.gridy=1;
      popped.add(new JLabel(""String_Node_Str""),c);
      File dir=new File(""String_Node_Str"");
      dir.mkdir();
      String[] allFiles=dir.list();
      List<String> tempFiles=new ArrayList<String>();
      for (      String st : allFiles)       if (st.endsWith(""String_Node_Str""))       tempFiles.add(st);
      String[] files=new String[tempFiles.size()];
      tempFiles.toArray(files);
      if (files.length == 0) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      final JComboBox ai=new JComboBox(files);
      c.gridx=1;
      c.gridy=1;
      c.fill=GridBagConstraints.HORIZONTAL;
      popped.add(ai,c);
      JButton next=new JButton(""String_Node_Str"");
      next.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          final String choice=(String)ai.getSelectedItem();
          File file=new File(""String_Node_Str"" + choice);
          if (ai.getSelectedItem() == null) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
            return;
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
          StandardJavaFileManager fileManager=compiler.getStandardFileManager(null,Locale.getDefault(),null);
          String[] compileOptions=new String[]{""String_Node_Str"",""String_Node_Str""};
          Iterable<String> compilationOptions=Arrays.asList(compileOptions);
          List<File> sourceFileList=new ArrayList<File>();
          sourceFileList.add(file);
          Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(sourceFileList);
          CompilationTask task=compiler.getTask(null,fileManager,null,compilationOptions,null,compilationUnits);
          boolean result=task.call();
          if (result) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
          }
          try {
            fileManager.close();
          }
 catch (          IOException e) {
          }
          final AIPlugin plugin;
          final AIAdapter ai=new AIAdapter(toPlay);
          try {
            ClassLoader c=ClassLoader.getSystemClassLoader();
            Class<?> klazz=c.loadClass(""String_Node_Str"" + choice.substring(0,choice.indexOf(""String_Node_Str"")));
            Constructor<?> construct=klazz.getConstructor();
            plugin=(AIPlugin)construct.newInstance();
            Thread aiThread;
            aiThread=new Thread(new Runnable(){
              @Override public void run(){
                try {
                  ai.runGame(plugin);
                }
 catch (                Exception e) {
                  System.out.println(e.getMessage());
                  e.printStackTrace();
                }
              }
            }
);
            aiThread.start();
          }
 catch (          Exception e1) {
            System.out.println(e1.getMessage());
            e1.printStackTrace();
          }
          try {
            Driver.getInstance().setPanel(new PlayNetGame(toPlay,false,false));
          }
 catch (          Exception e) {
            return;
          }
          popped.dispose();
        }
      }
);
      JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          popped.dispose();
        }
      }
);
      JPanel buttons=new JPanel();
      buttons.setLayout(new FlowLayout());
      buttons.add(back);
      buttons.add(next);
      c.gridx=0;
      c.gridy=2;
      c.gridwidth=2;
      popped.add(buttons,c);
      popped.setVisible(true);
    }
  }
);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().helpMenu.setText(""String_Node_Str"");
      Driver.getInstance().gamePlayHelp.setVisible(false);
      Driver.getInstance().revertPanel();
    }
  }
);
  try {
    if (InetAddress.getLocalHost().getHostName().contains(""String_Node_Str"")) {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,0);
      add(humanPlay,c);
      c.gridx=1;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(networkPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.gridwidth=2;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
 else {
      c.gridx=0;
      c.gridy=0;
      c.fill=GridBagConstraints.HORIZONTAL;
      c.insets=new Insets(5,5,0,5);
      add(humanPlay,c);
      c.gridx=0;
      c.gridy=1;
      c.insets=new Insets(0,5,20,5);
      c.fill=GridBagConstraints.HORIZONTAL;
      add(AIPlay,c);
      c.gridx=0;
      c.gridy=2;
      add(backButton,c);
    }
  }
 catch (  Exception e) {
  }
}"
49949,"/** 
 * Updates the display in response to the time passing.
 */
protected void updateDisplay(){
  long now=System.currentTimeMillis();
  long elapsed=now - lastUpdated;
  if (!delay) {
    time-=elapsed * direction;
  }
 else {
    delay=false;
  }
  lastUpdated=now;
  int minutes=(int)(time / 60000);
  int seconds=(int)((time % 60000) / 1000);
  label.setText(nf.format(minutes) + ""String_Node_Str"" + nf.format(seconds));
  if (time <= 0) {
    time=Math.abs(time);
    timeElapsed();
  }
}","/** 
 * Updates the display in response to the time passing.
 */
protected void updateDisplay(){
  if (stopTimers) {
    timer.stop();
    return;
  }
  long now=System.currentTimeMillis();
  long elapsed=now - lastUpdated;
  if (!delay) {
    time-=elapsed * direction;
  }
 else {
    delay=false;
  }
  lastUpdated=now;
  int minutes=(int)(time / 60000);
  int seconds=(int)((time % 60000) / 1000);
  label.setText(nf.format(minutes) + ""String_Node_Str"" + nf.format(seconds));
  if (time <= 0) {
    time=Math.abs(time);
    timeElapsed();
  }
}"
49950,"/** 
 * In this case, only pawns can promote, allow the user to pick which class it promotes to.
 * @param p The piece to promote
 * @param verified Whether it has been verified that thisis ok
 * @param promo What the piece was promoted to.
 * @return The promoted Piece.
 */
public Piece classicPromotion(Piece p,boolean verified,String promo){
  System.out.println(verified);
  if (!verified) {
    lastPromoted=p.getName();
    klazz=p.getName();
  }
  if (verified && promo != null && !promo.equals(p.getName())) {
    System.out.println(""String_Node_Str"" + promo + ""String_Node_Str""+ p.getName());
    try {
      Piece promoted=PieceBuilder.makePiece(promo,p.isBlack(),p.getSquare(),p.getBoard());
      if (promoted.isBlack()) {
        g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
      }
 else {
        g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
      }
      promoted.getLegalDests().clear();
      promoted.setMoveCount(p.getMoveCount());
      return promoted;
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  System.out.println(""String_Node_Str"" + klazz);
  if (!verified && (p.getPromotesTo() == null || p.getPromotesTo().size() == 0))   return p;
  if (!verified && promo == null && g.isBlackMove() == p.isBlack()) {
    klazz=""String_Node_Str"";
    if (p.getPromotesTo().size() == 1)     klazz=p.getPromotesTo().get(0);
    while (klazz.equals(""String_Node_Str"")) {
      System.out.println(promo == null);
      String result=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,p.getPromotesTo().toArray(),null);
      if (result == null) {
        continue;
      }
      klazz=result;
      promo=result;
    }
  }
 else   if (promo != null && p.getPromotesTo().contains(promo)) {
    klazz=promo;
  }
  try {
    Piece promoted=PieceBuilder.makePiece(klazz,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * In this case, only pawns can promote, allow the user to pick which class it promotes to.
 * @param p The piece to promote
 * @param verified Whether it has been verified that thisis ok
 * @param promo What the piece was promoted to.
 * @return The promoted Piece.
 */
public Piece classicPromotion(Piece p,boolean verified,String promo){
  if (p.getPromotesTo() == null || p.getPromotesTo().size() == 0)   return p;
  if (!verified) {
    lastPromoted=p.getName();
    klazz=p.getName();
  }
  if (verified && promo != null && !promo.equals(p.getName())) {
    try {
      Piece promoted=PieceBuilder.makePiece(promo,p.isBlack(),p.getSquare(),p.getBoard());
      if (promoted.isBlack()) {
        g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
      }
 else {
        g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
      }
      promoted.getLegalDests().clear();
      promoted.setMoveCount(p.getMoveCount());
      return promoted;
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  System.out.println(""String_Node_Str"" + klazz);
  if (!verified && (p.getPromotesTo() == null || p.getPromotesTo().size() == 0))   return p;
  if (!verified && promo == null && g.isBlackMove() == p.isBlack()) {
    klazz=""String_Node_Str"";
    if (p.getPromotesTo().size() == 1)     klazz=p.getPromotesTo().get(0);
    while (klazz.equals(""String_Node_Str"")) {
      System.out.println(promo == null);
      String result=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,p.getPromotesTo().toArray(),null);
      if (result == null) {
        continue;
      }
      klazz=result;
      promo=result;
    }
  }
 else   if (promo != null && p.getPromotesTo() != null && p.getPromotesTo().contains(promo)) {
    klazz=promo;
  }
  try {
    Piece promoted=PieceBuilder.makePiece(klazz,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}"
49951,"public boolean canAttack(int destRow,int destCol,char direction){
switch (direction) {
case 'S':
    return (destRow - curSquare.getRow()) < movements.get('S') || movements.get('S') == -1;
case 'N':
  return (curSquare.getRow() - destRow) < movements.get('N') || movements.get('N') == -1;
case 'E':
return (destCol - curSquare.getCol()) < movements.get('E') || movements.get('E') == -1;
case 'W':
return (curSquare.getCol() - destCol) < movements.get('W') || movements.get('W') == -1;
default :
return false;
}
}","public boolean canAttack(int destRow,int destCol,char direction){
switch (direction) {
case 'S':
    if (movements.containsKey('S'))     return (destRow - curSquare.getRow()) < movements.get('S') || movements.get('S') == -1;
case 'N':
  if (movements.containsKey('N'))   return (curSquare.getRow() - destRow) < movements.get('N') || movements.get('N') == -1;
case 'E':
if (movements.containsKey('E')) return (destCol - curSquare.getCol()) < movements.get('E') || movements.get('E') == -1;
case 'W':
if (movements.containsKey('W')) return (curSquare.getCol() - destCol) < movements.get('W') || movements.get('W') == -1;
case 'R':
if (movements.containsKey('R')) return (curSquare.getCol() - destCol) < movements.get('R') || movements.get('R') == -1;
case 'r':
if (movements.containsKey('r')) return (curSquare.getCol() - destCol) < movements.get('r') || movements.get('r') == -1;
case 'L':
if (movements.containsKey('L')) return (destCol - curSquare.getCol()) < movements.get('L') || movements.get('L') == -1;
case 'l':
if (movements.containsKey('l')) return (destCol - curSquare.getCol()) < movements.get('l') || movements.get('l') == -1;
default :
return false;
}
}"
49952,"@Override public void actionPerformed(ActionEvent arg0){
  if (wProtectObj.isSelected() || bProtectObj.isSelected()) {
    if (!(wProtectObj.isSelected() && bProtectObj.isSelected())) {
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
      if (answer != 0)       return;
    }
  }
  if ((wCaptureAll.isSelected() && bLoseAll.isSelected()) || (bCaptureAll.isSelected() && wLoseAll.isSelected())) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  if (wCheckTimes.isSelected() || bCheckTimes.isSelected()) {
    if (!(wCheckTimes.isSelected() && bCheckTimes.isSelected())) {
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
      if (answer != 0)       return;
    }
  }
  if (wCaptureAll.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",true,0,""String_Node_Str""));
  }
  if (wCaptureAllType.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
  }
  if (wProtectObj.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
    needsObj=true;
  }
  if (wLoseAll.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
  }
  if (wCheckTimes.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str""));
  }
  if (bCaptureAll.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",true,0,""String_Node_Str""));
  }
  if (bCaptureAllType.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
    needsObj=false;
  }
  if (bProtectObj.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
  }
  if (bLoseAll.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
  }
  if (bCheckTimes.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str""));
    needsObj=false;
  }
  Driver.getInstance().setPanel(new RuleMaker(b,whiteRules,blackRules));
}","@Override public void actionPerformed(ActionEvent arg0){
  if (wProtectObj.isSelected() || bProtectObj.isSelected()) {
    if (!(wProtectObj.isSelected() && bProtectObj.isSelected())) {
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
      if (answer != 0)       return;
    }
  }
  if ((wCaptureAll.isSelected() && bLoseAll.isSelected()) || (bCaptureAll.isSelected() && wLoseAll.isSelected())) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"");
    return;
  }
  if (wCheckTimes.isSelected() || bCheckTimes.isSelected()) {
    if (!(wCheckTimes.isSelected() && bCheckTimes.isSelected())) {
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
      if (answer != 0)       return;
    }
  }
  if (wCaptureAll.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",true,0,""String_Node_Str"",false));
  }
  if (wCaptureAllType.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",false));
  }
  if (wProtectObj.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",false));
    needsObj=true;
  }
  if (wLoseAll.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",false));
  }
  if (wCheckTimes.isSelected()) {
    whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str"",false));
  }
  if (bCaptureAll.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",true,0,""String_Node_Str"",true));
  }
  if (bCaptureAllType.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",true));
    needsObj=false;
  }
  if (bProtectObj.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",true));
  }
  if (bLoseAll.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",true));
  }
  if (bCheckTimes.isSelected()) {
    blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str"",true));
    needsObj=false;
  }
  Driver.getInstance().setPanel(new RuleMaker(b,whiteRules,blackRules));
}"
49953,"/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final JPanel objectiveWhiteCheckBox=new JPanel();
  objectiveWhiteCheckBox.setLayout(new GridLayout(5,1));
  final JRadioButton wCaptureAll=new JRadioButton(""String_Node_Str"",false);
  wCaptureAll.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCaptureAll);
  final JRadioButton wCaptureAllType=new JRadioButton(""String_Node_Str"",false);
  wCaptureAllType.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCaptureAllType);
  final JRadioButton wProtectObj=new JRadioButton(""String_Node_Str"",true);
  wProtectObj.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wProtectObj);
  final JRadioButton wLoseAll=new JRadioButton(""String_Node_Str"",false);
  wLoseAll.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wLoseAll);
  final JRadioButton wCheckTimes=new JRadioButton(""String_Node_Str"",false);
  wCheckTimes.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCheckTimes);
  final ButtonGroup white=new ButtonGroup();
  white.add(wCaptureAll);
  white.add(wCaptureAllType);
  white.add(wProtectObj);
  white.add(wLoseAll);
  white.add(wCheckTimes);
  final JPanel objectiveBlackCheckBox=new JPanel();
  objectiveBlackCheckBox.setLayout(new GridLayout(5,1));
  final JRadioButton bCaptureAll=new JRadioButton(""String_Node_Str"",false);
  bCaptureAll.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCaptureAll);
  final JRadioButton bCaptureAllType=new JRadioButton(""String_Node_Str"",false);
  bCaptureAllType.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCaptureAllType);
  final JRadioButton bProtectObj=new JRadioButton(""String_Node_Str"",true);
  bProtectObj.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bProtectObj);
  final JRadioButton bLoseAll=new JRadioButton(""String_Node_Str"",false);
  bLoseAll.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bLoseAll);
  final JRadioButton bCheckTimes=new JRadioButton(""String_Node_Str"",false);
  bCheckTimes.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCheckTimes);
  final ButtonGroup black=new ButtonGroup();
  black.add(bCaptureAll);
  black.add(bCaptureAllType);
  black.add(bProtectObj);
  black.add(bLoseAll);
  black.add(bCheckTimes);
  final JButton back=new JButton(""String_Node_Str"");
  back.setToolTipText(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new PieceMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wProtectObj.isSelected() || bProtectObj.isSelected()) {
        if (!(wProtectObj.isSelected() && bProtectObj.isSelected())) {
          int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (answer != 0)           return;
        }
      }
      if ((wCaptureAll.isSelected() && bLoseAll.isSelected()) || (bCaptureAll.isSelected() && wLoseAll.isSelected())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"");
        return;
      }
      if (wCheckTimes.isSelected() || bCheckTimes.isSelected()) {
        if (!(wCheckTimes.isSelected() && bCheckTimes.isSelected())) {
          int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (answer != 0)           return;
        }
      }
      if (wCaptureAll.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",true,0,""String_Node_Str""));
      }
      if (wCaptureAllType.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
      }
      if (wProtectObj.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
        needsObj=true;
      }
      if (wLoseAll.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
      }
      if (wCheckTimes.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str""));
      }
      if (bCaptureAll.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",true,0,""String_Node_Str""));
      }
      if (bCaptureAllType.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
        needsObj=false;
      }
      if (bProtectObj.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
      }
      if (bLoseAll.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
      }
      if (bCheckTimes.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str""));
        needsObj=false;
      }
      Driver.getInstance().setPanel(new RuleMaker(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteObj=new JPanel();
  whiteObj.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteObj.add(objectiveWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=3;
  whiteObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(whiteObj,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackObj=new JPanel();
  blackObj.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackObj.add(objectiveBlackCheckBox,c);
  c.gridx=0;
  c.gridy=3;
  blackObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(blackObj,c);
  c.insets=new Insets(10,10,10,10);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(10,10,10,10);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
}","/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final JPanel objectiveWhiteCheckBox=new JPanel();
  objectiveWhiteCheckBox.setLayout(new GridLayout(5,1));
  final JRadioButton wCaptureAll=new JRadioButton(""String_Node_Str"",false);
  wCaptureAll.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCaptureAll);
  final JRadioButton wCaptureAllType=new JRadioButton(""String_Node_Str"",false);
  wCaptureAllType.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCaptureAllType);
  final JRadioButton wProtectObj=new JRadioButton(""String_Node_Str"",true);
  wProtectObj.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wProtectObj);
  final JRadioButton wLoseAll=new JRadioButton(""String_Node_Str"",false);
  wLoseAll.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wLoseAll);
  final JRadioButton wCheckTimes=new JRadioButton(""String_Node_Str"",false);
  wCheckTimes.setToolTipText(""String_Node_Str"");
  objectiveWhiteCheckBox.add(wCheckTimes);
  final ButtonGroup white=new ButtonGroup();
  white.add(wCaptureAll);
  white.add(wCaptureAllType);
  white.add(wProtectObj);
  white.add(wLoseAll);
  white.add(wCheckTimes);
  final JPanel objectiveBlackCheckBox=new JPanel();
  objectiveBlackCheckBox.setLayout(new GridLayout(5,1));
  final JRadioButton bCaptureAll=new JRadioButton(""String_Node_Str"",false);
  bCaptureAll.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCaptureAll);
  final JRadioButton bCaptureAllType=new JRadioButton(""String_Node_Str"",false);
  bCaptureAllType.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCaptureAllType);
  final JRadioButton bProtectObj=new JRadioButton(""String_Node_Str"",true);
  bProtectObj.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bProtectObj);
  final JRadioButton bLoseAll=new JRadioButton(""String_Node_Str"",false);
  bLoseAll.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bLoseAll);
  final JRadioButton bCheckTimes=new JRadioButton(""String_Node_Str"",false);
  bCheckTimes.setToolTipText(""String_Node_Str"");
  objectiveBlackCheckBox.add(bCheckTimes);
  final ButtonGroup black=new ButtonGroup();
  black.add(bCaptureAll);
  black.add(bCaptureAllType);
  black.add(bProtectObj);
  black.add(bLoseAll);
  black.add(bCheckTimes);
  final JButton back=new JButton(""String_Node_Str"");
  back.setToolTipText(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new PieceMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wProtectObj.isSelected() || bProtectObj.isSelected()) {
        if (!(wProtectObj.isSelected() && bProtectObj.isSelected())) {
          int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (answer != 0)           return;
        }
      }
      if ((wCaptureAll.isSelected() && bLoseAll.isSelected()) || (bCaptureAll.isSelected() && wLoseAll.isSelected())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"");
        return;
      }
      if (wCheckTimes.isSelected() || bCheckTimes.isSelected()) {
        if (!(wCheckTimes.isSelected() && bCheckTimes.isSelected())) {
          int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
          if (answer != 0)           return;
        }
      }
      if (wCaptureAll.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",true,0,""String_Node_Str"",false));
      }
      if (wCaptureAllType.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",false));
      }
      if (wProtectObj.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",false));
        needsObj=true;
      }
      if (wLoseAll.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",false));
      }
      if (wCheckTimes.isSelected()) {
        whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str"",false));
      }
      if (bCaptureAll.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",true,0,""String_Node_Str"",true));
      }
      if (bCaptureAllType.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",true));
        needsObj=false;
      }
      if (bProtectObj.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",true));
      }
      if (bLoseAll.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",true));
      }
      if (bCheckTimes.isSelected()) {
        blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str"",true));
        needsObj=false;
      }
      Driver.getInstance().setPanel(new RuleMaker(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteObj=new JPanel();
  whiteObj.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteObj.add(objectiveWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=3;
  whiteObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(whiteObj,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackObj=new JPanel();
  blackObj.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackObj.add(objectiveBlackCheckBox,c);
  c.gridx=0;
  c.gridy=3;
  blackObj.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(blackObj,c);
  c.insets=new Insets(10,10,10,10);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(10,10,10,10);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
}"
49954,"/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=b.getBoards();
  final JPanel legalDestWhiteCheckBox=new JPanel();
  legalDestWhiteCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox wCaptureMand=new JCheckBox(""String_Node_Str"");
  wCaptureMand.setToolTipText(""String_Node_Str"");
  legalDestWhiteCheckBox.add(wCaptureMand);
  final JCheckBox wNoMoveObj=new JCheckBox(""String_Node_Str"");
  wNoMoveObj.setToolTipText(""String_Node_Str"");
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestWhiteCheckBox.add(wNoMoveObj);
  }
  final JPanel afterCaptureWhiteCheckBox=new JPanel();
  afterCaptureWhiteCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox wChangeColor=new JCheckBox(""String_Node_Str"");
  wChangeColor.setToolTipText(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wChangeColor);
  }
  final JCheckBox wPieceReturn=new JCheckBox(""String_Node_Str"");
  wPieceReturn.setToolTipText(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wPieceReturn);
  final JCheckBox wDrop=new JCheckBox(""String_Node_Str"");
  wDrop.setToolTipText(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"") || !whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wDrop);
  }
  final JCheckBox wCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  wCapturedColorAndDrop.setToolTipText(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wCapturedColorAndDrop);
  final JPanel legalDestBlackCheckBox=new JPanel();
  legalDestBlackCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox bCaptureMand=new JCheckBox(""String_Node_Str"");
  bCaptureMand.setToolTipText(""String_Node_Str"");
  legalDestBlackCheckBox.add(bCaptureMand);
  final JCheckBox bNoMoveObj=new JCheckBox(""String_Node_Str"");
  bNoMoveObj.setToolTipText(""String_Node_Str"");
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestBlackCheckBox.add(bNoMoveObj);
  }
  final JPanel afterCapturepBlackCheckBox=new JPanel();
  afterCapturepBlackCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox bChangeColor=new JCheckBox(""String_Node_Str"");
  bChangeColor.setToolTipText(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bChangeColor);
  }
  final JCheckBox bPieceReturn=new JCheckBox(""String_Node_Str"");
  bPieceReturn.setToolTipText(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bPieceReturn);
  final JCheckBox bDrop=new JCheckBox(""String_Node_Str"");
  bDrop.setToolTipText(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"") || !blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bDrop);
  }
  final JCheckBox bCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  bCapturedColorAndDrop.setToolTipText(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bCapturedColorAndDrop);
  final JPanel sCheckBox=new JPanel();
  sCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox atomic=new JCheckBox(""String_Node_Str"");
  atomic.setToolTipText(""String_Node_Str"");
  sCheckBox.add(atomic);
  final JCheckBox switchBoard=new JCheckBox(""String_Node_Str"");
  switchBoard.setToolTipText(""String_Node_Str"");
  switchBoard.setEnabled(false);
  sCheckBox.add(switchBoard);
  final JPanel wExtras=new JPanel();
  wExtras.setLayout(new GridBagLayout());
  final JTextField wNumChecks=new JTextField(2);
  Object[] allPieces=PieceBuilder.getSet().toArray();
  final JComboBox wPiecesList=new JComboBox(allPieces);
  JLabel wChecksLabel=new JLabel(""String_Node_Str"");
  JLabel wPiecesLabel=new JLabel(""String_Node_Str"");
  wNumChecks.setVisible(false);
  wPiecesList.setVisible(false);
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (whiteRules.theEndIsNigh().equals(""String_Node_Str""))     wPiecesLabel.setText(""String_Node_Str"");
    wPiecesList.setVisible(true);
    wPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    wNumChecks.setVisible(true);
    wPiecesList.setVisible(true);
    wPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=0;
    wExtras.add(wChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    wExtras.add(wNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  final JPanel bExtras=new JPanel();
  bExtras.setLayout(new GridBagLayout());
  final JTextField bNumChecks=new JTextField(2);
  final JComboBox bPiecesList=new JComboBox(allPieces);
  JLabel bChecksLabel=new JLabel(""String_Node_Str"");
  JLabel bPiecesLabel=new JLabel(""String_Node_Str"");
  bNumChecks.setVisible(false);
  bPiecesList.setVisible(false);
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (blackRules.theEndIsNigh().equals(""String_Node_Str""))     bPiecesLabel.setText(""String_Node_Str"");
    bPiecesList.setVisible(true);
    bPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    bNumChecks.setVisible(true);
    bPiecesList.setVisible(true);
    bPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=0;
    bExtras.add(bChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    bExtras.add(bNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  final JButton back=new JButton(""String_Node_Str"");
  back.setToolTipText(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new ObjectiveMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wCaptureMand.isSelected()) {
        whiteRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (wNoMoveObj.isSelected()) {
        whiteRules.addCropLegalDests(""String_Node_Str"");
      }
      if (wChangeColor.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wPieceReturn.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wCapturedColorAndDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (bCaptureMand.isSelected()) {
        blackRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (bNoMoveObj.isSelected()) {
        blackRules.addCropLegalDests(""String_Node_Str"");
      }
      if (bChangeColor.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bPieceReturn.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bCapturedColorAndDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (switchBoard.isSelected() && boards.length == 2) {
        whiteRules.setGetBoard(new GetBoard(""String_Node_Str""));
        blackRules.setGetBoard(new GetBoard(""String_Node_Str""));
      }
      if (atomic.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (wNumChecks.isVisible()) {
        String wNumChecked=wNumChecks.getText();
        try {
          int answer=Integer.parseInt(wNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,answer,""String_Node_Str""));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      if (bNumChecks.isVisible()) {
        String bNumChecked=bNumChecks.getText();
        try {
          int answer=Integer.parseInt(bNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,answer,""String_Node_Str""));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      if (wPiecesList.isVisible()) {
        if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",wPiecesList.getSelectedItem().toString()));
        }
 else {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,wPiecesList.getSelectedItem().toString()));
        }
      }
      if (bPiecesList.isVisible()) {
        bPiecesList.getSelectedItem();
        if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",bPiecesList.getSelectedItem().toString()));
        }
 else {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,bPiecesList.getSelectedItem().toString()));
        }
      }
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteLegalDests=new JPanel();
  whiteLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  whiteLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteLegalDests.add(legalDestWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  whiteTeam.add(whiteLegalDests,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(wExtras,c);
  JPanel whiteCapture=new JPanel();
  whiteCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteCapture.add(afterCaptureWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  whiteTeam.add(whiteCapture,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackLegalDests=new JPanel();
  blackLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  blackLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackLegalDests.add(legalDestBlackCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  blackTeam.add(blackLegalDests,c);
  JPanel blackCapture=new JPanel();
  blackCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackCapture.add(afterCapturepBlackCheckBox,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(bExtras,c);
  c.gridx=0;
  c.gridy=2;
  blackTeam.add(blackCapture,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel specialRules=new JPanel();
  specialRules.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  specialRules.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  specialRules.add(sCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  add(specialRules,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
  wChangeColor.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  bChangeColor.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  wPieceReturn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
      }
    }
  }
);
  bPieceReturn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bDrop.setEnabled(true);
      }
    }
  }
);
  atomic.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (atomic.isSelected()) {
        wChangeColor.setEnabled(false);
        wChangeColor.setSelected(false);
        bChangeColor.setEnabled(false);
        bChangeColor.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        wChangeColor.setEnabled(true);
        bChangeColor.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
        bDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wCapturedColorAndDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bCapturedColorAndDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  if (boards.length == 2) {
    switchBoard.setEnabled(true);
  }
}","/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=b.getBoards();
  final JPanel legalDestWhiteCheckBox=new JPanel();
  legalDestWhiteCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox wCaptureMand=new JCheckBox(""String_Node_Str"");
  wCaptureMand.setToolTipText(""String_Node_Str"");
  legalDestWhiteCheckBox.add(wCaptureMand);
  final JCheckBox wNoMoveObj=new JCheckBox(""String_Node_Str"");
  wNoMoveObj.setToolTipText(""String_Node_Str"");
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestWhiteCheckBox.add(wNoMoveObj);
  }
  final JPanel afterCaptureWhiteCheckBox=new JPanel();
  afterCaptureWhiteCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox wChangeColor=new JCheckBox(""String_Node_Str"");
  wChangeColor.setToolTipText(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wChangeColor);
  }
  final JCheckBox wPieceReturn=new JCheckBox(""String_Node_Str"");
  wPieceReturn.setToolTipText(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wPieceReturn);
  final JCheckBox wDrop=new JCheckBox(""String_Node_Str"");
  wDrop.setToolTipText(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"") || !whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wDrop);
  }
  final JCheckBox wCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  wCapturedColorAndDrop.setToolTipText(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wCapturedColorAndDrop);
  final JPanel legalDestBlackCheckBox=new JPanel();
  legalDestBlackCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox bCaptureMand=new JCheckBox(""String_Node_Str"");
  bCaptureMand.setToolTipText(""String_Node_Str"");
  legalDestBlackCheckBox.add(bCaptureMand);
  final JCheckBox bNoMoveObj=new JCheckBox(""String_Node_Str"");
  bNoMoveObj.setToolTipText(""String_Node_Str"");
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestBlackCheckBox.add(bNoMoveObj);
  }
  final JPanel afterCapturepBlackCheckBox=new JPanel();
  afterCapturepBlackCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox bChangeColor=new JCheckBox(""String_Node_Str"");
  bChangeColor.setToolTipText(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bChangeColor);
  }
  final JCheckBox bPieceReturn=new JCheckBox(""String_Node_Str"");
  bPieceReturn.setToolTipText(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bPieceReturn);
  final JCheckBox bDrop=new JCheckBox(""String_Node_Str"");
  bDrop.setToolTipText(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"") || !blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bDrop);
  }
  final JCheckBox bCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  bCapturedColorAndDrop.setToolTipText(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bCapturedColorAndDrop);
  final JPanel sCheckBox=new JPanel();
  sCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox atomic=new JCheckBox(""String_Node_Str"");
  atomic.setToolTipText(""String_Node_Str"");
  sCheckBox.add(atomic);
  final JCheckBox switchBoard=new JCheckBox(""String_Node_Str"");
  switchBoard.setToolTipText(""String_Node_Str"");
  switchBoard.setEnabled(false);
  sCheckBox.add(switchBoard);
  final JPanel wExtras=new JPanel();
  wExtras.setLayout(new GridBagLayout());
  final JTextField wNumChecks=new JTextField(2);
  Object[] allPieces=PieceBuilder.getSet().toArray();
  final JComboBox wPiecesList=new JComboBox(allPieces);
  JLabel wChecksLabel=new JLabel(""String_Node_Str"");
  JLabel wPiecesLabel=new JLabel(""String_Node_Str"");
  wNumChecks.setVisible(false);
  wPiecesList.setVisible(false);
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (whiteRules.theEndIsNigh().equals(""String_Node_Str""))     wPiecesLabel.setText(""String_Node_Str"");
    wPiecesList.setVisible(true);
    wPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    wNumChecks.setVisible(true);
    wPiecesList.setVisible(true);
    wPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=0;
    wExtras.add(wChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    wExtras.add(wNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  final JPanel bExtras=new JPanel();
  bExtras.setLayout(new GridBagLayout());
  final JTextField bNumChecks=new JTextField(2);
  final JComboBox bPiecesList=new JComboBox(allPieces);
  JLabel bChecksLabel=new JLabel(""String_Node_Str"");
  JLabel bPiecesLabel=new JLabel(""String_Node_Str"");
  bNumChecks.setVisible(false);
  bPiecesList.setVisible(false);
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (blackRules.theEndIsNigh().equals(""String_Node_Str""))     bPiecesLabel.setText(""String_Node_Str"");
    bPiecesList.setVisible(true);
    bPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    bNumChecks.setVisible(true);
    bPiecesList.setVisible(true);
    bPiecesList.setSelectedIndex(4);
    c.gridx=0;
    c.gridy=0;
    bExtras.add(bChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    bExtras.add(bNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  final JButton back=new JButton(""String_Node_Str"");
  back.setToolTipText(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new ObjectiveMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wCaptureMand.isSelected()) {
        whiteRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (wNoMoveObj.isSelected()) {
        whiteRules.addCropLegalDests(""String_Node_Str"");
      }
      if (wChangeColor.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wPieceReturn.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wCapturedColorAndDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (bCaptureMand.isSelected()) {
        blackRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (bNoMoveObj.isSelected()) {
        blackRules.addCropLegalDests(""String_Node_Str"");
      }
      if (bChangeColor.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bPieceReturn.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bCapturedColorAndDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (switchBoard.isSelected() && boards.length == 2) {
        whiteRules.setGetBoard(new GetBoard(""String_Node_Str""));
        blackRules.setGetBoard(new GetBoard(""String_Node_Str""));
      }
      if (atomic.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (wNumChecks.isVisible()) {
        String wNumChecked=wNumChecks.getText();
        try {
          int answer=Integer.parseInt(wNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,answer,""String_Node_Str"",false));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      if (bNumChecks.isVisible()) {
        String bNumChecked=bNumChecks.getText();
        try {
          int answer=Integer.parseInt(bNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,answer,""String_Node_Str"",true));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      if (wPiecesList.isVisible()) {
        if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",false));
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",wPiecesList.getSelectedItem().toString()));
        }
 else {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,wPiecesList.getSelectedItem().toString(),false));
        }
      }
      if (bPiecesList.isVisible()) {
        bPiecesList.getSelectedItem();
        if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str"",true));
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",bPiecesList.getSelectedItem().toString()));
        }
 else {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,bPiecesList.getSelectedItem().toString(),true));
        }
      }
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteLegalDests=new JPanel();
  whiteLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  whiteLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteLegalDests.add(legalDestWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  whiteTeam.add(whiteLegalDests,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(wExtras,c);
  JPanel whiteCapture=new JPanel();
  whiteCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteCapture.add(afterCaptureWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  whiteTeam.add(whiteCapture,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackLegalDests=new JPanel();
  blackLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  blackLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackLegalDests.add(legalDestBlackCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  blackTeam.add(blackLegalDests,c);
  JPanel blackCapture=new JPanel();
  blackCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackCapture.add(afterCapturepBlackCheckBox,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(bExtras,c);
  c.gridx=0;
  c.gridy=2;
  blackTeam.add(blackCapture,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel specialRules=new JPanel();
  specialRules.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  specialRules.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  specialRules.add(sCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  add(specialRules,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
  wChangeColor.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  bChangeColor.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  wPieceReturn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
      }
    }
  }
);
  bPieceReturn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bDrop.setEnabled(true);
      }
    }
  }
);
  atomic.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (atomic.isSelected()) {
        wChangeColor.setEnabled(false);
        wChangeColor.setSelected(false);
        bChangeColor.setEnabled(false);
        bChangeColor.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        wChangeColor.setEnabled(true);
        bChangeColor.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
        bDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wCapturedColorAndDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bCapturedColorAndDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  if (boards.length == 2) {
    switchBoard.setEnabled(true);
  }
}"
49955,"/** 
 * Build the classic game of chess for the user.
 */
private static void buildClassic(){
  Builder classic=new Builder(""String_Node_Str"");
  classic.setBoards(new Board[]{new Board(8,8,false)});
  Board b=classic.boards[0];
  for (int i=1; i < 9; i++) {
    classic.whiteTeam.add(createPawn(false,b.getSquare(2,i),b));
    classic.blackTeam.add(createPawn(true,b.getSquare(7,i),b));
  }
  classic.whiteTeam.add(createRook(false,b.getSquare(1,1),b));
  classic.whiteTeam.add(createKnight(false,b.getSquare(1,2),b));
  classic.whiteTeam.add(createBishop(false,b.getSquare(1,3),b));
  classic.whiteTeam.add(createQueen(false,b.getSquare(1,4),b));
  classic.whiteTeam.add(createKing(false,b.getSquare(1,5),b));
  classic.whiteTeam.add(createBishop(false,b.getSquare(1,6),b));
  classic.whiteTeam.add(createKnight(false,b.getSquare(1,7),b));
  classic.whiteTeam.add(createRook(false,b.getSquare(1,8),b));
  classic.blackTeam.add(createRook(true,b.getSquare(8,1),b));
  classic.blackTeam.add(createKnight(true,b.getSquare(8,2),b));
  classic.blackTeam.add(createBishop(true,b.getSquare(8,3),b));
  classic.blackTeam.add(createQueen(true,b.getSquare(8,4),b));
  classic.blackTeam.add(createKing(true,b.getSquare(8,5),b));
  classic.blackTeam.add(createBishop(true,b.getSquare(8,6),b));
  classic.blackTeam.add(createKnight(true,b.getSquare(8,7),b));
  classic.blackTeam.add(createRook(true,b.getSquare(8,8),b));
  classic.writeFile(new Rules(true),new Rules(true));
}","/** 
 * Build the classic game of chess for the user.
 */
private static void buildClassic(){
  Builder classic=new Builder(""String_Node_Str"");
  classic.setBoards(new Board[]{new Board(8,8,false)});
  Board b=classic.boards[0];
  for (int i=1; i < 9; i++) {
    classic.whiteTeam.add(createPawn(false,b.getSquare(2,i),b));
    classic.blackTeam.add(createPawn(true,b.getSquare(7,i),b));
  }
  classic.whiteTeam.add(createRook(false,b.getSquare(1,1),b));
  classic.whiteTeam.add(createKnight(false,b.getSquare(1,2),b));
  classic.whiteTeam.add(createBishop(false,b.getSquare(1,3),b));
  classic.whiteTeam.add(createQueen(false,b.getSquare(1,4),b));
  classic.whiteTeam.add(createKing(false,b.getSquare(1,5),b));
  classic.whiteTeam.add(createBishop(false,b.getSquare(1,6),b));
  classic.whiteTeam.add(createKnight(false,b.getSquare(1,7),b));
  classic.whiteTeam.add(createRook(false,b.getSquare(1,8),b));
  classic.blackTeam.add(createRook(true,b.getSquare(8,1),b));
  classic.blackTeam.add(createKnight(true,b.getSquare(8,2),b));
  classic.blackTeam.add(createBishop(true,b.getSquare(8,3),b));
  classic.blackTeam.add(createQueen(true,b.getSquare(8,4),b));
  classic.blackTeam.add(createKing(true,b.getSquare(8,5),b));
  classic.blackTeam.add(createBishop(true,b.getSquare(8,6),b));
  classic.blackTeam.add(createKnight(true,b.getSquare(8,7),b));
  classic.blackTeam.add(createRook(true,b.getSquare(8,8),b));
  classic.writeFile(new Rules(true,false),new Rules(true,true));
}"
49956,"/** 
 * Create a new EndOfGame object
 * @param name The name of the method
 * @param blackLosesPieces Set the instance variable
 * @param maxChecks Set the instance variable
 * @param type Set the instance variable.
 */
public EndOfGame(String name,boolean blackLosesPieces,int maxChecks,String type){
  doMethod=doMethods.get(name);
  undoMethod=undoMethods.get(name);
  this.name=name;
  this.blackLosesPieces=blackLosesPieces;
  this.maxChecks=maxChecks;
  this.type=type;
  checks=0;
}","/** 
 * Create a new EndOfGame object
 * @param name The name of the method
 * @param blackLosesPieces Set the instance variable
 * @param maxChecks Set the instance variable
 * @param type Set the instance variable.
 */
public EndOfGame(String name,boolean blackLosesPieces,int maxChecks,String type,boolean isBlack){
  doMethod=doMethods.get(name);
  undoMethod=undoMethods.get(name);
  this.name=name;
  this.blackLosesPieces=blackLosesPieces;
  this.maxChecks=maxChecks;
  this.type=type;
  this.isBlack=isBlack;
  checks=0;
}"
49957,"/** 
 * Capture all of a specified type to win.
 * @param objectivePiece Unused.
 */
public void captureAllOfType(Piece objectivePiece){
  List<Piece> team=(g.isBlackMove() ? g.getBlackTeam() : g.getWhiteTeam());
  for (  Piece p : team) {
    if (p.getName().equals(type) && !p.isCaptured())     return;
  }
  Result r=new Result(!g.isBlackMove() ? Result.BLACK_WIN : Result.WHITE_WIN);
  r.setText(""String_Node_Str"" + r.winText() + ""String_Node_Str"");
  PlayGame.endOfGame(r);
}","/** 
 * Capture all of a specified type to win.
 * @param objectivePiece Unused.
 */
public void captureAllOfType(Piece objectivePiece){
  List<Piece> team=(!isBlack ? g.getBlackTeam() : g.getWhiteTeam());
  for (  Piece p : team) {
    if (p.getName().equals(type) && !p.isCaptured()) {
      return;
    }
  }
  Result r=new Result(isBlack ? Result.BLACK_WIN : Result.WHITE_WIN);
  r.setText(""String_Node_Str"" + r.winText() + ""String_Node_Str"");
  PlayGame.endOfGame(r);
}"
49958,"/** 
 * In this case, the goal is either to lose all pieces or capture all the opponent's pieces based on the  instance variable blackLosesPieces.
 * @param objectivePiece The objective piece; unused.
 */
public void loseAllPieces(Piece objectivePiece){
  List<Piece> team=(blackLosesPieces ? g.getBlackTeam() : g.getWhiteTeam());
  for (  Piece p : team) {
    if (!p.isCaptured())     return;
  }
  Result r=new Result(blackLosesPieces ? Result.BLACK_WIN : Result.WHITE_WIN);
  r.setText(""String_Node_Str"" + r.winText() + ""String_Node_Str"");
  PlayGame.endOfGame(r);
}","/** 
 * In this case, the goal is either to lose all pieces or capture all the opponent's pieces based on the  instance variable blackLosesPieces.
 * @param objectivePiece The objective piece; unused.
 */
public void loseAllPieces(Piece objectivePiece){
  List<Piece> team=(isBlack ? g.getBlackTeam() : g.getWhiteTeam());
  for (  Piece p : team) {
    if (!p.isCaptured())     return;
  }
  Result r=new Result(blackLosesPieces ? Result.BLACK_WIN : Result.WHITE_WIN);
  r.setText(""String_Node_Str"" + r.winText() + ""String_Node_Str"");
  PlayGame.endOfGame(r);
}"
49959,"/** 
 * @param isClassic Whether the game is classic chess.
 */
public Rules(boolean isClassic){
  nextTurn=new NextTurn(""String_Node_Str"",1,1,0);
  endOfGame=new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str"");
  cropLegalDests=new CropLegalDests();
  cropLegalDests.addMethod(""String_Node_Str"");
  objectivePiece=new ObjectivePiece(""String_Node_Str"",""String_Node_Str"");
  afterMove=new AfterMove();
  afterMove.addMethod(""String_Node_Str"");
  getBoard=new GetBoard(""String_Node_Str"");
  promote=new Promote(""String_Node_Str"");
  getPromotionSquares=new GetPromotionSquares(""String_Node_Str"");
  adjustTeamDests=new AdjustTeamDests(""String_Node_Str"");
}","/** 
 * @param isClassic Whether the game is classic chess.
 */
public Rules(boolean isClassic,boolean isBlack){
  nextTurn=new NextTurn(""String_Node_Str"",1,1,0);
  endOfGame=new EndOfGame(""String_Node_Str"",false,3,""String_Node_Str"",isBlack);
  cropLegalDests=new CropLegalDests();
  cropLegalDests.addMethod(""String_Node_Str"");
  objectivePiece=new ObjectivePiece(""String_Node_Str"",""String_Node_Str"");
  afterMove=new AfterMove();
  afterMove.addMethod(""String_Node_Str"");
  getBoard=new GetBoard(""String_Node_Str"");
  promote=new Promote(""String_Node_Str"");
  getPromotionSquares=new GetPromotionSquares(""String_Node_Str"");
  adjustTeamDests=new AdjustTeamDests(""String_Node_Str"");
}"
49960,"public void runGame(AIPlugin ai){
  PlayNetGame.running=true;
  while (PlayNetGame.running) {
    while (g.isBlackMove()) {
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException e) {
      }
      AIBoard[] boards=getBoards();
      FakeMove fm=ai.getMove(boards);
    }
    try {
      Thread.sleep(0);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","public void runGame(AIPlugin ai){
  PlayNetGame.running=true;
  while (PlayNetGame.running) {
    while (g.isBlackMove()) {
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException e) {
      }
      AIBoard[] boards=getBoards();
      FakeMove fm=ai.getMove(boards);
      playMove(fm);
    }
    try {
      Thread.sleep(0);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}"
49961,"/** 
 * In this case, only pawns can promote, allow the user to pick which class it promotes to.
 * @param p The piece to promote
 * @param verified Whether it has been verified that thisis ok
 * @param promo What the piece was promoted to.
 * @return The promoted Piece.
 */
public Piece classicPromotion(Piece p,boolean verified,String promo){
  lastPromoted=p.getName();
  klazz=p.getName();
  if (p.getPromotesTo() == null)   return p;
  if (!verified && promo == null && g.isBlackMove() == p.isBlack()) {
    klazz=""String_Node_Str"";
    if (p.getPromotesTo().size() == 1)     klazz=p.getPromotesTo().get(0);
    while (klazz.equals(""String_Node_Str"")) {
      String result=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,p.getPromotesTo().toArray(),null);
      if (result == null) {
        continue;
      }
      try {
        klazz=result;
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
 else   if (promo != null) {
    klazz=promo;
  }
  try {
    Piece promoted=PieceBuilder.makePiece(klazz,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * In this case, only pawns can promote, allow the user to pick which class it promotes to.
 * @param p The piece to promote
 * @param verified Whether it has been verified that thisis ok
 * @param promo What the piece was promoted to.
 * @return The promoted Piece.
 */
public Piece classicPromotion(Piece p,boolean verified,String promo){
  lastPromoted=p.getName();
  klazz=p.getName();
  if (p.getPromotesTo() == null || p.getPromotesTo().size() == 0)   return p;
  if (!verified && promo == null && g.isBlackMove() == p.isBlack()) {
    klazz=""String_Node_Str"";
    if (p.getPromotesTo().size() == 1)     klazz=p.getPromotesTo().get(0);
    while (klazz.equals(""String_Node_Str"")) {
      String result=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,p.getPromotesTo().toArray(),null);
      if (result == null) {
        continue;
      }
      try {
        klazz=result;
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
 else   if (promo != null) {
    klazz=promo;
  }
  try {
    Piece promoted=PieceBuilder.makePiece(klazz,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}"
49962,"/** 
 * Creates a popup box for the Promotion Options.
 */
private void promotion(final String type){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(500,300);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new GridBagLayout());
  popup.setResizable(false);
  final DefaultListModel emptyList=new DefaultListModel();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.remove(4);
  final JList piecesList=new JList(list);
  final JList piecesList2=new JList(emptyList);
  final JButton moveLeft=new JButton();
  moveLeft.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList2.getSelectedIndex();
      list.addElement(emptyList.elementAt(index));
      emptyList.remove(index);
    }
  }
);
  moveLeft.setText(""String_Node_Str"");
  final JButton moveRight=new JButton();
  moveRight.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList.getSelectedIndex();
      emptyList.addElement(list.elementAt(index));
      list.remove(index);
    }
  }
);
  moveRight.setText(""String_Node_Str"");
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  piecesList2.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList2.setLayoutOrientation(JList.VERTICAL);
  piecesList2.setVisibleRowCount(-1);
  piecesList2.setSelectedIndex(0);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList=piecesList.getSelectionModel();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JScrollPane scrollPane2=new JScrollPane(piecesList2);
  scrollPane2.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList2=piecesList2.getSelectionModel();
  selectList2.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList2.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JButton submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      ArrayList<String> promotesTo=new ArrayList<String>();
      for (int i=0; i < emptyList.size(); i++) {
        promotesTo.add((String)emptyList.get(i));
      }
      promotions.put(type,promotesTo);
      popup.dispose();
    }
  }
);
  JButton backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      popup.dispose();
    }
  }
);
  JPanel options=new JPanel();
  options.add(backButton);
  options.add(submitButton);
  JPanel otherCrap=new JPanel();
  otherCrap.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  otherCrap.add(moveRight,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  otherCrap.add(moveLeft,c);
  c.gridx=0;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  popup.add(scrollPane,c);
  c.gridx=1;
  c.gridy=1;
  popup.add(otherCrap,c);
  c.gridx=2;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=2;
  c.gridy=1;
  popup.add(scrollPane2,c);
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=3;
  popup.add(options,c);
  popup.setVisible(true);
}","/** 
 * Creates a popup box for the Promotion Options.
 */
private void promotion(final String type){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(500,300);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new GridBagLayout());
  popup.setResizable(false);
  final DefaultListModel emptyList=new DefaultListModel();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    if (!allPieces[i].equals(type))     list.addElement(allPieces[i]);
  }
  final JList piecesList=new JList(list);
  final JList piecesList2=new JList(emptyList);
  final JButton moveLeft=new JButton();
  moveLeft.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList2.getSelectedIndex();
      list.addElement(emptyList.elementAt(index));
      emptyList.remove(index);
    }
  }
);
  moveLeft.setText(""String_Node_Str"");
  final JButton moveRight=new JButton();
  moveRight.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList.getSelectedIndex();
      emptyList.addElement(list.elementAt(index));
      list.remove(index);
    }
  }
);
  moveRight.setText(""String_Node_Str"");
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  piecesList2.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList2.setLayoutOrientation(JList.VERTICAL);
  piecesList2.setVisibleRowCount(-1);
  piecesList2.setSelectedIndex(0);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList=piecesList.getSelectionModel();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JScrollPane scrollPane2=new JScrollPane(piecesList2);
  scrollPane2.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList2=piecesList2.getSelectionModel();
  selectList2.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList2.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JButton submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      ArrayList<String> promotesTo=new ArrayList<String>();
      for (int i=0; i < emptyList.size(); i++) {
        promotesTo.add((String)emptyList.get(i));
      }
      promotions.put(type,promotesTo);
      popup.dispose();
    }
  }
);
  JButton backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      popup.dispose();
    }
  }
);
  JPanel options=new JPanel();
  options.add(backButton);
  options.add(submitButton);
  JPanel otherCrap=new JPanel();
  otherCrap.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  otherCrap.add(moveRight,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  otherCrap.add(moveLeft,c);
  c.gridx=0;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  popup.add(scrollPane,c);
  c.gridx=1;
  c.gridy=1;
  popup.add(otherCrap,c);
  c.gridx=2;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=2;
  c.gridy=1;
  popup.add(scrollPane2,c);
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=3;
  popup.add(options,c);
  popup.setVisible(true);
}"
49963,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param isPlayback whether PlayGame is in playback mode
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback){
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  undoItem=new JButton(""String_Node_Str"");
  undoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      mustMove=false;
      if (getGame().getHistory().size() == 0)       return;
      getGame().getHistory().get(getGame().getHistory().size() - 1).undo();
      getGame().getHistory().remove(getGame().getHistory().size() - 1);
      (getGame().isBlackMove() ? getGame().getBlackRules() : getGame().getWhiteRules()).undoEndOfGame();
      boardRefresh(getGame().getBoards());
    }
  }
);
  int ifDouble=0;
  if (menu == null)   Driver.getInstance().setMenu(createMenu());
 else   if (!menu.isVisible())   Driver.getInstance().setMenu(createMenu());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  this.setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      history[index--].undo();
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteCapturesBox=new Jail(k,k);
  whiteCaptures.setLayout(new GridLayout(k,k));
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      whiteCapturesBox.getSquare(i,j).setButton(jb);
      whiteCaptures.add(jb);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackCapturesBox=new Jail(k,k);
  blackCaptures.setLayout(new GridLayout(k,k));
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      blackCapturesBox.getSquare(i,j).setButton(jb);
      blackCaptures.add(jb);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(undoItem,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param isPlayback whether PlayGame is in playback mode
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback){
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  undoItem=new JButton(""String_Node_Str"");
  undoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      mustMove=false;
      if (getGame().getHistory().size() == 0)       return;
      getGame().getHistory().get(getGame().getHistory().size() - 1).undo();
      getGame().getHistory().remove(getGame().getHistory().size() - 1);
      (getGame().isBlackMove() ? getGame().getBlackRules() : getGame().getWhiteRules()).undoEndOfGame();
      boardRefresh(getGame().getBoards());
    }
  }
);
  int ifDouble=0;
  if (menu == null)   Driver.getInstance().setMenu(createMenu());
 else   if (!menu.isVisible())   Driver.getInstance().setMenu(createMenu());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  this.setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      history[index--].undo();
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  if (k < 4) {
    whiteCapturesBox=new Jail(4,4);
    whiteCaptures.setLayout(new GridLayout(4,4));
  }
 else {
    whiteCapturesBox=new Jail(k,k);
    whiteCaptures.setLayout(new GridLayout(k,k));
  }
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      whiteCapturesBox.getSquare(i,j).setButton(jb);
      whiteCaptures.add(jb);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  if (k < 4) {
    blackCapturesBox=new Jail(4,4);
    blackCaptures.setLayout(new GridLayout(4,4));
  }
 else {
    blackCapturesBox=new Jail(k,k);
    blackCaptures.setLayout(new GridLayout(k,k));
  }
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      blackCapturesBox.getSquare(i,j).setButton(jb);
      blackCaptures.add(jb);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(undoItem,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}"
49964,"/** 
 * Setups up the window
 * @param isPlayback whether this is just a review or not
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback){
  super.removeAll();
  menu.setVisible(false);
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  int ifDouble=0;
  Driver.getInstance().setMenu(createMenu());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  this.setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      history[index--].undo();
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  whiteLabel.setBackground(getGame().isBlackMove() ? null : Square.HIGHLIGHT_COLOR);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteCapturesBox=new Jail(k,k);
  whiteCaptures.setLayout(new GridLayout(k,k));
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      whiteCapturesBox.getSquare(i,j).setButton(jb);
      whiteCaptures.add(jb);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackCapturesBox=new Jail(k,k);
  blackCaptures.setLayout(new GridLayout(k,k));
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      blackCapturesBox.getSquare(i,j).setButton(jb);
      blackCaptures.add(jb);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}","/** 
 * Setups up the window
 * @param isPlayback whether this is just a review or not
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback){
  super.removeAll();
  menu.setVisible(false);
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  int ifDouble=0;
  Driver.getInstance().setMenu(createMenu());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  this.setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      history[index--].undo();
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  whiteLabel.setBackground(getGame().isBlackMove() ? null : Square.HIGHLIGHT_COLOR);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  if (k < 4) {
    whiteCapturesBox=new Jail(4,4);
    whiteCaptures.setLayout(new GridLayout(4,4));
  }
 else {
    whiteCapturesBox=new Jail(k,k);
    whiteCaptures.setLayout(new GridLayout(k,k));
  }
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      whiteCapturesBox.getSquare(i,j).setButton(jb);
      whiteCaptures.add(jb);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  if (k < 4) {
    blackCapturesBox=new Jail(4,4);
    blackCaptures.setLayout(new GridLayout(4,4));
  }
 else {
    blackCapturesBox=new Jail(k,k);
    blackCaptures.setLayout(new GridLayout(k,k));
  }
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      blackCapturesBox.getSquare(i,j).setButton(jb);
      blackCaptures.add(jb);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}"
49965,"/** 
 * Creates a popup box for the Promotion Options.
 */
private void promotion(final String type){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(500,300);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new GridBagLayout());
  popup.setResizable(false);
  final DefaultListModel emptyList=new DefaultListModel();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.remove(4);
  final JList piecesList=new JList(list);
  final JList piecesList2=new JList(emptyList);
  final JButton moveLeft=new JButton();
  moveLeft.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList2.getSelectedIndex();
      list.addElement(emptyList.elementAt(index));
      emptyList.remove(index);
    }
  }
);
  moveLeft.setText(""String_Node_Str"");
  final JButton moveRight=new JButton();
  moveRight.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList.getSelectedIndex();
      emptyList.addElement(list.elementAt(index));
      list.remove(index);
    }
  }
);
  moveRight.setText(""String_Node_Str"");
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  piecesList2.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList2.setLayoutOrientation(JList.VERTICAL);
  piecesList2.setVisibleRowCount(-1);
  piecesList2.setSelectedIndex(0);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList=piecesList.getSelectionModel();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JScrollPane scrollPane2=new JScrollPane(piecesList2);
  scrollPane2.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList2=piecesList2.getSelectionModel();
  selectList2.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList2.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JMenuItem submitButton=new JMenuItem(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      ArrayList<String> promotesTo=new ArrayList<String>();
      for (int i=0; i < emptyList.size(); i++) {
        promotesTo.add((String)emptyList.get(i));
      }
      promotions.put(type,promotesTo);
      popup.dispose();
    }
  }
);
  JMenuItem backButton=new JMenuItem(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      popup.dispose();
    }
  }
);
  JMenuBar optionHolder=new JMenuBar();
  JMenu options=new JMenu(""String_Node_Str"");
  options.setForeground(Color.WHITE);
  options.add(submitButton);
  options.add(backButton);
  optionHolder.add(options);
  JPanel otherCrap=new JPanel();
  otherCrap.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  otherCrap.add(moveRight,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  otherCrap.add(moveLeft,c);
  c.gridx=0;
  c.gridy=0;
  popup.add(scrollPane,c);
  c.gridx=1;
  c.gridy=0;
  popup.add(otherCrap,c);
  c.gridx=2;
  c.gridy=0;
  popup.add(scrollPane2,c);
  popup.setJMenuBar(optionHolder);
  popup.setVisible(true);
}","/** 
 * Creates a popup box for the Promotion Options.
 */
private void promotion(final String type){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(500,300);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new GridBagLayout());
  popup.setResizable(false);
  final DefaultListModel emptyList=new DefaultListModel();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.remove(4);
  final JList piecesList=new JList(list);
  final JList piecesList2=new JList(emptyList);
  final JButton moveLeft=new JButton();
  moveLeft.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList2.getSelectedIndex();
      list.addElement(emptyList.elementAt(index));
      emptyList.remove(index);
    }
  }
);
  moveLeft.setText(""String_Node_Str"");
  final JButton moveRight=new JButton();
  moveRight.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int index=piecesList.getSelectedIndex();
      emptyList.addElement(list.elementAt(index));
      list.remove(index);
    }
  }
);
  moveRight.setText(""String_Node_Str"");
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  piecesList2.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  piecesList2.setLayoutOrientation(JList.VERTICAL);
  piecesList2.setVisibleRowCount(-1);
  piecesList2.setSelectedIndex(0);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList=piecesList.getSelectionModel();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JScrollPane scrollPane2=new JScrollPane(piecesList2);
  scrollPane2.setPreferredSize(new Dimension(200,200));
  ListSelectionModel selectList2=piecesList2.getSelectionModel();
  selectList2.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      if (e.getValueIsAdjusting() == false) {
        if (piecesList2.getSelectedIndex() == -1) {
          moveLeft.setEnabled(false);
          moveRight.setEnabled(false);
        }
 else {
          moveLeft.setEnabled(true);
          moveRight.setEnabled(true);
        }
      }
    }
  }
);
  JButton submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      ArrayList<String> promotesTo=new ArrayList<String>();
      for (int i=0; i < emptyList.size(); i++) {
        promotesTo.add((String)emptyList.get(i));
      }
      promotions.put(type,promotesTo);
      popup.dispose();
    }
  }
);
  JButton backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      popup.dispose();
    }
  }
);
  JPanel options=new JPanel();
  options.add(backButton);
  options.add(submitButton);
  JPanel otherCrap=new JPanel();
  otherCrap.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  otherCrap.add(moveRight,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  otherCrap.add(moveLeft,c);
  c.gridx=0;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=1;
  popup.add(scrollPane,c);
  c.gridx=1;
  c.gridy=1;
  popup.add(otherCrap,c);
  c.gridx=2;
  c.gridy=0;
  popup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=2;
  c.gridy=1;
  popup.add(scrollPane2,c);
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=3;
  popup.add(options,c);
  popup.setVisible(true);
}"
49966,"/** 
 * Method to set up the piece making window.
 */
public void initComponents(){
  builder=new PieceBuilder();
  setSize(550,875);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  JPanel piecePanel=new JPanel();
  piecePanel.setLayout(new GridBagLayout());
  piecePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel namePanel=new JPanel();
  namePanel.setLayout(new FlowLayout());
  namePanel.add(new JLabel(""String_Node_Str""));
  final JTextField name=new JTextField(15);
  namePanel.add(name);
  c.gridx=0;
  c.gridy=0;
  piecePanel.add(namePanel,c);
  final ImageIcon temp=new ImageIcon(""String_Node_Str"");
  temp.setImage(temp.getImage().getScaledInstance(48,48,Image.SCALE_SMOOTH));
  final JPanel lightIconPanel=new JPanel();
  lightIconPanel.setLayout(new FlowLayout());
  final JButton lightIconButton=new JButton();
  lightIconButton.setSize(48,48);
  lightIconButton.setIcon(temp);
  final JButton chooseLightImage=new JButton(""String_Node_Str"");
  chooseLightImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        lightIconButton.setIcon(icon);
        builder.setLightImage(icon);
      }
    }
  }
);
  lightIconPanel.add(chooseLightImage);
  lightIconPanel.add(lightIconButton);
  c.gridx=0;
  c.gridy=2;
  piecePanel.add(lightIconPanel,c);
  final JPanel darkIconPanel=new JPanel();
  darkIconPanel.setLayout(new FlowLayout());
  final JButton darkIconButton=new JButton();
  darkIconButton.setSize(48,48);
  darkIconButton.setIcon(temp);
  final JButton chooseDarkImage=new JButton(""String_Node_Str"");
  chooseDarkImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        darkIconButton.setIcon(icon);
        builder.setDarkImage(icon);
      }
    }
  }
);
  darkIconPanel.add(chooseDarkImage);
  darkIconPanel.add(darkIconButton);
  c.gridx=0;
  c.gridy=3;
  piecePanel.add(darkIconPanel,c);
  final String[] directions=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox dropdown=new JComboBox(directions);
  final JTextField dist=new JTextField(3);
  dist.setToolTipText(""String_Node_Str"");
  final JTextField knight=new JTextField(2);
  knight.setToolTipText(""String_Node_Str"");
  knight.setEnabled(false);
  final JTextField knightSecond=new JTextField(2);
  knightSecond.setToolTipText(""String_Node_Str"");
  knightSecond.setEnabled(false);
  final JCheckBox knightOn=new JCheckBox(""String_Node_Str"",false);
  knightOn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      knightLike=!knightLike;
      if (knightLike) {
        knight.setEnabled(true);
        knightSecond.setEnabled(true);
      }
 else {
        knight.setEnabled(false);
        knightSecond.setEnabled(false);
      }
    }
  }
);
  final JCheckBox leaper=new JCheckBox(""String_Node_Str"",false);
  final JPanel knightMoving=new JPanel();
  knightMoving.setLayout(new FlowLayout());
  knightMoving.add(knight);
  knightMoving.add(new JLabel(""String_Node_Str""));
  knightMoving.add(knightSecond);
  final JButton addInstruction=new JButton(""String_Node_Str"");
  addInstruction.setToolTipText(""String_Node_Str"");
  addInstruction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (isIntDist()) {
        if (dropdown.getSelectedItem() != null) {
          builder.addMove(stringToChar((String)dropdown.getSelectedItem()),Integer.parseInt(dist.getText()));
          dropdown.removeItemAt(dropdown.getSelectedIndex());
          dist.setText(""String_Node_Str"");
        }
      }
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntDist(){
      try {
        Integer.parseInt(dist.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
    /** 
 * Translate a direction string to it's corresponding char.
 * @param s The string to translate
 * @return The char corresponding to the given String.
 */
    private char stringToChar(    String s){
      if (s.equals(""String_Node_Str""))       return 'N';
      if (s.equals(""String_Node_Str""))       return 'S';
      if (s.equals(""String_Node_Str""))       return 'E';
      if (s.equals(""String_Node_Str""))       return 'W';
      if (s.equals(""String_Node_Str""))       return 'R';
      if (s.equals(""String_Node_Str""))       return 'L';
      if (s.equals(""String_Node_Str""))       return 'r';
 else       return 'l';
    }
  }
);
  c.gridx=0;
  c.gridy=4;
  piecePanel.add(addInstruction,c);
  JPanel movementSetup=new JPanel();
  movementSetup.setLayout(new BoxLayout(movementSetup,BoxLayout.Y_AXIS));
  movementSetup.setLayout(new GridBagLayout());
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=0;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=1;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=1;
  movementSetup.add(dropdown,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=2;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=2;
  movementSetup.add(dist,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=3;
  c.gridwidth=3;
  movementSetup.add(addInstruction,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=5;
  movementSetup.add(leaper,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=6;
  movementSetup.add(knightOn,c);
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=7;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=8;
  movementSetup.add(knightMoving,c);
  c.gridx=0;
  c.gridy=5;
  piecePanel.add(movementSetup,c);
  final JButton done=new JButton(""String_Node_Str"");
  done.setToolTipText(""String_Node_Str"");
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (name.getText() == ""String_Node_Str"" || PieceBuilder.isPieceType(name.getText())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
        return;
      }
      if (knight.isEnabled()) {
        if (isIntKnights()) {
          builder.addMove('x',Integer.parseInt(knight.getText()));
          builder.addMove('y',Integer.parseInt(knightSecond.getText()));
        }
      }
      builder.setName(name.getText());
      PieceBuilder.savePieceType(builder);
      name.setText(""String_Node_Str"");
      lightIconButton.setIcon(temp);
      darkIconButton.setIcon(temp);
      dist.setText(""String_Node_Str"");
      leaper.setSelected(false);
      knightOn.setSelected(false);
      knight.setText(""String_Node_Str"");
      knight.setEnabled(false);
      knightSecond.setText(""String_Node_Str"");
      knightSecond.setEnabled(false);
      dropdown.removeAllItems();
      for (int i=0; i < directions.length; i++)       dropdown.addItem(directions[i]);
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntKnights(){
      try {
        Integer.parseInt(knight.getText());
        Integer.parseInt(knightSecond.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
  }
);
  BufferedImage helpMe=null;
  try {
    helpMe=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon picture=new ImageIcon(helpMe);
  picture.setImage(picture.getImage().getScaledInstance(700,500,Image.SCALE_SMOOTH));
  final JButton help=new JButton(""String_Node_Str"");
  help.setToolTipText(""String_Node_Str"");
  help.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",0,picture);
    }
  }
);
  final JButton next=new JButton(""String_Node_Str"");
  next.setToolTipText(""String_Node_Str"");
  next.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (name.getText().equals(""String_Node_Str"")) {
        Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
 else {
        int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
        if (answer == 0)         Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  cancel.setToolTipText(""String_Node_Str"");
  cancel.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new BoardCustomMenu(b));
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(help);
  buttons.add(done);
  c.gridx=0;
  c.gridy=7;
  piecePanel.add(buttons,c);
  c.gridx=0;
  c.gridy=0;
  add(piecePanel,c);
  JPanel mainButtons=new JPanel();
  mainButtons.setLayout(new FlowLayout());
  c.gridx=0;
  c.gridy=1;
  mainButtons.add(cancel,c);
  c.gridx=1;
  c.gridy=1;
  mainButtons.add(next,c);
  c.gridx=0;
  c.gridy=1;
  add(mainButtons,c);
}","/** 
 * Method to set up the piece making window.
 */
public void initComponents(){
  builder=new PieceBuilder();
  setSize(550,875);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  JPanel piecePanel=new JPanel();
  piecePanel.setLayout(new GridBagLayout());
  piecePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel namePanel=new JPanel();
  namePanel.setLayout(new FlowLayout());
  namePanel.add(new JLabel(""String_Node_Str""));
  final JTextField name=new JTextField(15);
  namePanel.add(name);
  c.gridx=0;
  c.gridy=0;
  piecePanel.add(namePanel,c);
  final ImageIcon temp=new ImageIcon(""String_Node_Str"");
  temp.setImage(temp.getImage().getScaledInstance(48,48,Image.SCALE_SMOOTH));
  final JPanel lightIconPanel=new JPanel();
  lightIconPanel.setLayout(new FlowLayout());
  final JButton lightIconButton=new JButton();
  lightIconButton.setSize(48,48);
  lightIconButton.setIcon(temp);
  final JButton chooseLightImage=new JButton(""String_Node_Str"");
  chooseLightImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        lightIconButton.setIcon(icon);
        builder.setLightImage(icon);
      }
    }
  }
);
  lightIconPanel.add(chooseLightImage);
  lightIconPanel.add(lightIconButton);
  builder.setLightImage(temp);
  c.gridx=0;
  c.gridy=2;
  piecePanel.add(lightIconPanel,c);
  final JPanel darkIconPanel=new JPanel();
  darkIconPanel.setLayout(new FlowLayout());
  final JButton darkIconButton=new JButton();
  darkIconButton.setSize(48,48);
  darkIconButton.setIcon(temp);
  final JButton chooseDarkImage=new JButton(""String_Node_Str"");
  chooseDarkImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        darkIconButton.setIcon(icon);
        builder.setDarkImage(icon);
      }
    }
  }
);
  darkIconPanel.add(chooseDarkImage);
  darkIconPanel.add(darkIconButton);
  builder.setDarkImage(temp);
  c.gridx=0;
  c.gridy=3;
  piecePanel.add(darkIconPanel,c);
  final String[] directions=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox dropdown=new JComboBox(directions);
  final JTextField dist=new JTextField(3);
  dist.setToolTipText(""String_Node_Str"");
  final JTextField knight=new JTextField(2);
  knight.setToolTipText(""String_Node_Str"");
  knight.setEnabled(false);
  final JTextField knightSecond=new JTextField(2);
  knightSecond.setToolTipText(""String_Node_Str"");
  knightSecond.setEnabled(false);
  final JCheckBox knightOn=new JCheckBox(""String_Node_Str"",false);
  knightOn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      knightLike=!knightLike;
      if (knightLike) {
        knight.setEnabled(true);
        knightSecond.setEnabled(true);
      }
 else {
        knight.setEnabled(false);
        knightSecond.setEnabled(false);
      }
    }
  }
);
  final JCheckBox leaper=new JCheckBox(""String_Node_Str"",false);
  final JPanel knightMoving=new JPanel();
  knightMoving.setLayout(new FlowLayout());
  knightMoving.add(knight);
  knightMoving.add(new JLabel(""String_Node_Str""));
  knightMoving.add(knightSecond);
  final JButton addInstruction=new JButton(""String_Node_Str"");
  addInstruction.setToolTipText(""String_Node_Str"");
  addInstruction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (isIntDist()) {
        if (dropdown.getSelectedItem() != null) {
          builder.addMove(stringToChar((String)dropdown.getSelectedItem()),Integer.parseInt(dist.getText()));
          dropdown.removeItemAt(dropdown.getSelectedIndex());
          dist.setText(""String_Node_Str"");
        }
      }
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntDist(){
      try {
        Integer.parseInt(dist.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
    /** 
 * Translate a direction string to it's corresponding char.
 * @param s The string to translate
 * @return The char corresponding to the given String.
 */
    private char stringToChar(    String s){
      if (s.equals(""String_Node_Str""))       return 'N';
      if (s.equals(""String_Node_Str""))       return 'S';
      if (s.equals(""String_Node_Str""))       return 'E';
      if (s.equals(""String_Node_Str""))       return 'W';
      if (s.equals(""String_Node_Str""))       return 'R';
      if (s.equals(""String_Node_Str""))       return 'L';
      if (s.equals(""String_Node_Str""))       return 'r';
 else       return 'l';
    }
  }
);
  c.gridx=0;
  c.gridy=4;
  piecePanel.add(addInstruction,c);
  JPanel movementSetup=new JPanel();
  movementSetup.setLayout(new BoxLayout(movementSetup,BoxLayout.Y_AXIS));
  movementSetup.setLayout(new GridBagLayout());
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=0;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=1;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=1;
  movementSetup.add(dropdown,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=2;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=2;
  movementSetup.add(dist,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=3;
  c.gridwidth=3;
  movementSetup.add(addInstruction,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=5;
  movementSetup.add(leaper,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=6;
  movementSetup.add(knightOn,c);
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=7;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=8;
  movementSetup.add(knightMoving,c);
  c.gridx=0;
  c.gridy=5;
  piecePanel.add(movementSetup,c);
  final JButton done=new JButton(""String_Node_Str"");
  done.setToolTipText(""String_Node_Str"");
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (name.getText() == ""String_Node_Str"" || PieceBuilder.isPieceType(name.getText())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
        return;
      }
      if (knight.isEnabled()) {
        if (isIntKnights()) {
          builder.addMove('x',Integer.parseInt(knight.getText()));
          builder.addMove('y',Integer.parseInt(knightSecond.getText()));
        }
      }
      builder.setName(name.getText());
      PieceBuilder.savePieceType(builder);
      builder=new PieceBuilder();
      name.setText(""String_Node_Str"");
      lightIconButton.setIcon(temp);
      darkIconButton.setIcon(temp);
      dist.setText(""String_Node_Str"");
      leaper.setSelected(false);
      knightOn.setSelected(false);
      knight.setText(""String_Node_Str"");
      knight.setEnabled(false);
      knightSecond.setText(""String_Node_Str"");
      knightSecond.setEnabled(false);
      knightLike=false;
      dropdown.removeAllItems();
      for (int i=0; i < directions.length; i++)       dropdown.addItem(directions[i]);
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntKnights(){
      try {
        Integer.parseInt(knight.getText());
        Integer.parseInt(knightSecond.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
  }
);
  BufferedImage helpMe=null;
  try {
    helpMe=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon picture=new ImageIcon(helpMe);
  picture.setImage(picture.getImage().getScaledInstance(700,500,Image.SCALE_SMOOTH));
  final JButton help=new JButton(""String_Node_Str"");
  help.setToolTipText(""String_Node_Str"");
  help.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",0,picture);
    }
  }
);
  final JButton next=new JButton(""String_Node_Str"");
  next.setToolTipText(""String_Node_Str"");
  next.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (name.getText().equals(""String_Node_Str"")) {
        Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
 else {
        int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
        if (answer == 0)         Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  cancel.setToolTipText(""String_Node_Str"");
  cancel.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new BoardCustomMenu(b));
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(help);
  buttons.add(done);
  c.gridx=0;
  c.gridy=7;
  piecePanel.add(buttons,c);
  c.gridx=0;
  c.gridy=0;
  add(piecePanel,c);
  JPanel mainButtons=new JPanel();
  mainButtons.setLayout(new FlowLayout());
  c.gridx=0;
  c.gridy=1;
  mainButtons.add(cancel,c);
  c.gridx=1;
  c.gridy=1;
  mainButtons.add(next,c);
  c.gridx=0;
  c.gridy=1;
  add(mainButtons,c);
}"
49967,"/** 
 * Setups up the window
 * @param isPlayback whether this is just a review or not
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback){
  super.removeAll();
  menu.setVisible(false);
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  int ifDouble=0;
  Driver.getInstance().setMenu(createMenu());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  this.setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      history[index--].undo();
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteCapturesBox=new Jail(k,k);
  whiteCaptures.setLayout(new GridLayout(k,k));
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      whiteCapturesBox.getSquare(i,j).setButton(jb);
      whiteCaptures.add(jb);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackCapturesBox=new Jail(k,k);
  blackCaptures.setLayout(new GridLayout(k,k));
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      blackCapturesBox.getSquare(i,j).setButton(jb);
      blackCaptures.add(jb);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}","/** 
 * Setups up the window
 * @param isPlayback whether this is just a review or not
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback){
  super.removeAll();
  menu.setVisible(false);
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  int ifDouble=0;
  Driver.getInstance().setMenu(createMenu());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  this.setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      history[index--].undo();
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  whiteLabel.setBackground(getGame().isBlackMove() ? null : Square.HIGHLIGHT_COLOR);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteCapturesBox=new Jail(k,k);
  whiteCaptures.setLayout(new GridLayout(k,k));
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      whiteCapturesBox.getSquare(i,j).setButton(jb);
      whiteCaptures.add(jb);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackCapturesBox=new Jail(k,k);
  blackCaptures.setLayout(new GridLayout(k,k));
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      blackCapturesBox.getSquare(i,j).setButton(jb);
      blackCaptures.add(jb);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}"
49968,"/** 
 * This is undone by decrementing the number of moves made, and if necessary, decrementing the amount of moves possible each round. Then the turn is changed, if appropriate.
 * @return Whose turn it is.
 */
public boolean undoIncreasingTurnsTogether(){
  if (--currentNumMoves < 0) {
    isBlackMove=!isBlackMove;
    PlayGame.turn(isBlackMove);
    whiteMoves-=increment;
    currentNumMoves=whiteMoves;
  }
  return isBlackMove;
}","/** 
 * This is undone by decrementing the number of moves made, and if necessary, decrementing the amount of moves possible each round. Then the turn is changed, if appropriate.
 * @return Whose turn it is.
 */
public boolean undoIncreasingTurnsTogether(){
  if (--currentNumMoves < 0) {
    isBlackMove=!isBlackMove;
    PlayGame.turn(isBlackMove);
    whiteMoves-=increment;
    currentNumMoves=whiteMoves - 1;
  }
  return isBlackMove;
}"
49969,"/** 
 * @param p The piece to unpromote
 * @return The unpromoted piece.
 */
public Piece undo(Piece p){
  try {
    if (undoMethod == null) {
      undoMethod=undoMethods.get(name);
    }
    return (Piece)undoMethod.invoke(this,p);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","/** 
 * @param p The piece to unpromote
 * @return The unpromoted piece.
 */
public Piece undo(Piece p){
  try {
    if (lastPromoted == null)     lastPromoted=resetLastPromoted;
    if (undoMethod == null) {
      undoMethod=undoMethods.get(name);
    }
    Piece toReturn=(Piece)undoMethod.invoke(this,p);
    resetLastPromoted=lastPromoted;
    return toReturn;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}"
49970,"/** 
 * @param p The piece to promote
 * @param verified Whether the piece can be promoted
 * @param promo What to promote from.
 * @return The promoted Piece.
 */
public Piece execute(Piece p,boolean verified,String promo){
  try {
    if (doMethod == null) {
      doMethod=doMethods.get(name);
    }
    return (Piece)doMethod.invoke(this,p,verified,promo);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","/** 
 * @param p The piece to promote
 * @param verified Whether the piece can be promoted
 * @param promo What to promote from.
 * @return The promoted Piece.
 */
public Piece execute(Piece p,boolean verified,String promo){
  if (lastPromoted == null)   lastPromoted=resetLastPromoted;
  try {
    if (doMethod == null) {
      doMethod=doMethods.get(name);
    }
    Piece toReturn=(Piece)doMethod.invoke(this,p,verified,promo);
    resetLastPromoted=lastPromoted;
    return toReturn;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}"
49971,"public void join(String host) throws Exception {
  Socket socket=null;
  ObjectOutputStream out=null;
  ObjectInputStream in=null;
  boolean playing=true;
  while (socket == null) {
    try {
      socket=new Socket(host,27335);
    }
 catch (    Exception e) {
      if (NewGameMenu.cancelled)       return;
    }
  }
  out=new ObjectOutputStream(socket.getOutputStream());
  in=new ObjectInputStream(socket.getInputStream());
  Object fromServer=null;
  Object fromUser;
  Game g=(Game)in.readObject();
  PlayNetGame png=new PlayNetGame(g,false,true);
  Driver.getInstance().setPanel(png);
  try {
    while (playing) {
      while (g.isBlackMove() == false) {
        fromServer=in.readObject();
        NetMove toMove=(NetMove)fromServer;
        g.playMove(g.fakeToRealMove((NetMove)fromServer));
        if (g.getLastMove().getResult() != null)         break;
      }
      while (g.isBlackMove() == true) {
        while (png.netMove == null)         Thread.sleep(0);
        fromUser=png.netMove;
        png.netMove=null;
        out.writeObject(fromUser);
        System.out.println(""String_Node_Str"" + fromUser.toString());
        out.flush();
        if (g.getLastMove().getResult() != null)         break;
      }
    }
  }
 catch (  Exception e) {
    out.close();
    in.close();
    socket.close();
  }
  out.close();
  in.close();
  socket.close();
}","public void join(String host) throws Exception {
  Socket socket=null;
  ObjectOutputStream out=null;
  ObjectInputStream in=null;
  boolean playing=true;
  while (socket == null) {
    try {
      socket=new Socket(host,27335);
    }
 catch (    Exception e) {
      if (NewGameMenu.cancelled)       return;
    }
  }
  out=new ObjectOutputStream(socket.getOutputStream());
  in=new ObjectInputStream(socket.getInputStream());
  Object fromServer=null;
  Object fromUser;
  Game g=(Game)in.readObject();
  PlayNetGame png=new PlayNetGame(g,false,true);
  PlayGame.resetTimers();
  Driver.getInstance().setPanel(png);
  try {
    while (playing) {
      while (g.isBlackMove() == false) {
        fromServer=in.readObject();
        NetMove toMove=(NetMove)fromServer;
        g.playMove(g.fakeToRealMove((NetMove)fromServer));
        if (g.getLastMove().getResult() != null)         break;
      }
      while (g.isBlackMove() == true) {
        while (png.netMove == null)         Thread.sleep(0);
        fromUser=png.netMove;
        png.netMove=null;
        out.writeObject(fromUser);
        System.out.println(""String_Node_Str"" + fromUser.toString());
        out.flush();
        if (g.getLastMove().getResult() != null)         break;
      }
    }
  }
 catch (  Exception e) {
    out.close();
    in.close();
    socket.close();
  }
  out.close();
  in.close();
  socket.close();
}"
49972,"public void host(PlayNetGame png) throws Exception {
  ServerSocket serverSocket=null;
  try {
  }
 catch (  Exception e) {
    System.out.println(e.getMessage());
  }
  Socket clientSocket=null;
  while (clientSocket == null) {
    try {
      serverSocket=new ServerSocket(27335);
      serverSocket.setSoTimeout(10000);
      clientSocket=serverSocket.accept();
    }
 catch (    Exception e) {
      if (NewGameMenu.cancelled)       return;
    }
  }
  System.out.println(""String_Node_Str"");
  ObjectOutputStream out=new ObjectOutputStream(clientSocket.getOutputStream());
  ObjectInputStream in=new ObjectInputStream(clientSocket.getInputStream());
  boolean playing=true;
  Object fromUser;
  Object fromServer;
  Game g=PlayNetGame.getGame();
  fromServer=g;
  if (fromServer != null)   out.writeObject(fromServer);
  Driver.getInstance().setPanel(png);
  while (g.isBlackMove() == false) {
    while (png.netMove == null)     Thread.sleep(0);
    fromServer=png.netMove;
    png.netMove=null;
    out.writeObject(fromServer);
    System.out.println(""String_Node_Str"" + fromServer.toString());
    out.flush();
  }
  try {
    while (playing) {
      while (g.isBlackMove() == true) {
        fromUser=in.readObject();
        NetMove toMove=(NetMove)fromUser;
        g.playMove(g.fakeToRealMove((NetMove)fromUser));
        if (g.getLastMove().getResult() != null)         break;
      }
      while (g.isBlackMove() == false) {
        while (png.netMove == null)         Thread.sleep(0);
        fromServer=png.netMove;
        png.netMove=null;
        out.writeObject(fromServer);
        out.flush();
        if (g.getLastMove().getResult() != null)         break;
      }
    }
  }
 catch (  Exception e) {
    out.close();
    in.close();
    clientSocket.close();
    serverSocket.close();
  }
  out.close();
  in.close();
  clientSocket.close();
  serverSocket.close();
}","public void host(PlayNetGame png) throws Exception {
  ServerSocket serverSocket=null;
  Socket clientSocket=null;
  serverSocket=new ServerSocket(27335);
  serverSocket.setSoTimeout(1000);
  while (clientSocket == null) {
    try {
      PlayGame.resetTimers();
      clientSocket=serverSocket.accept();
    }
 catch (    Exception e) {
      if (NewGameMenu.cancelled)       return;
    }
  }
  ObjectOutputStream out=new ObjectOutputStream(clientSocket.getOutputStream());
  ObjectInputStream in=new ObjectInputStream(clientSocket.getInputStream());
  boolean playing=true;
  Object fromUser;
  Object fromServer;
  Game g=PlayNetGame.getGame();
  fromServer=g;
  if (fromServer != null)   out.writeObject(fromServer);
  PlayGame.resetTimers();
  Driver.getInstance().setPanel(png);
  while (g.isBlackMove() == false) {
    while (png.netMove == null)     Thread.sleep(0);
    fromServer=png.netMove;
    png.netMove=null;
    out.writeObject(fromServer);
    System.out.println(""String_Node_Str"" + fromServer.toString());
    out.flush();
  }
  try {
    while (playing) {
      while (g.isBlackMove() == true) {
        fromUser=in.readObject();
        NetMove toMove=(NetMove)fromUser;
        g.playMove(g.fakeToRealMove((NetMove)fromUser));
        if (g.getLastMove().getResult() != null)         break;
      }
      while (g.isBlackMove() == false) {
        while (png.netMove == null)         Thread.sleep(0);
        fromServer=png.netMove;
        png.netMove=null;
        out.writeObject(fromServer);
        out.flush();
        if (g.getLastMove().getResult() != null)         break;
      }
    }
  }
 catch (  Exception e) {
    out.close();
    in.close();
    clientSocket.close();
    serverSocket.close();
  }
  out.close();
  in.close();
  clientSocket.close();
  serverSocket.close();
}"
49973,"@Override public void valueChanged(ListSelectionEvent e){
  ListSelectionModel lsm=(ListSelectionModel)e.getSource();
  int selection=lsm.getAnchorSelectionIndex();
  if (!lsm.getValueIsAdjusting()) {
    if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
      bShowPiece.getSquare(1,1).setPiece(null);
      bShowPiece.getSquare(1,1).setBackgroundColor(original);
      bShowPiece.getSquare(1,1).setHabitable(true);
      bShowPiece.getSquare(1,1).refresh();
      jb1.setVisible(true);
      jb2.setVisible(false);
    }
 else     if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
      bShowPiece.getSquare(1,1).refresh();
      jb2.setVisible(false);
      jb1.setVisible(false);
    }
 else {
      jb2.setVisible(true);
      jb1.setVisible(true);
      if (bShowPiece.getSquare(1,1).isHabitable() == false)       bShowPiece.getSquare(1,1).setHabitable(true);
      if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)       bShowPiece.getSquare(1,1).setBackgroundColor(original);
      Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),false,bShowPiece.getSquare(1,1),bShowPiece);
      Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
      bShowPiece.getSquare(1,1).setPiece(toAdd);
      bShowPiece.getSquare(2,1).setPiece(toAdd1);
      bShowPiece.getSquare(1,1).refresh();
      bShowPiece.getSquare(2,1).refresh();
    }
  }
}","@Override public void valueChanged(ListSelectionEvent e){
  ListSelectionModel lsm=(ListSelectionModel)e.getSource();
  int selection=lsm.getAnchorSelectionIndex();
  if (!lsm.getValueIsAdjusting()) {
    if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
      bShowPiece.getSquare(1,1).setPiece(null);
      bShowPiece.getSquare(1,1).setBackgroundColor(original);
      bShowPiece.getSquare(1,1).setHabitable(true);
      bShowPiece.getSquare(1,1).refresh();
      jb1.setVisible(true);
      jb2.setVisible(false);
    }
 else {
      jb2.setVisible(true);
      jb1.setVisible(true);
      if (bShowPiece.getSquare(1,1).isHabitable() == false)       bShowPiece.getSquare(1,1).setHabitable(true);
      if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)       bShowPiece.getSquare(1,1).setBackgroundColor(original);
      Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),false,bShowPiece.getSquare(1,1),bShowPiece);
      Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
      bShowPiece.getSquare(1,1).setPiece(toAdd);
      bShowPiece.getSquare(2,1).setPiece(toAdd1);
      bShowPiece.getSquare(1,1).refresh();
      bShowPiece.getSquare(2,1).refresh();
    }
  }
}"
49974,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param whiteRules the rules for white team.
 * @param blackRules the rules for black team.
 */
private void initComponents(){
  setLayout(new FlowLayout());
  setBorder(BorderFactory.createLoweredBevelBorder());
  final Board[] boards=b.getBoards();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.addElement(""String_Node_Str"");
  final JList piecesList=new JList(list);
  final Board bShowPiece=new Board(2,1,false);
  final JPanel showPiece=new JPanel();
  showPiece.setLayout(new GridLayout(2,1));
  showPiece.setPreferredSize(new Dimension(50,100));
  final JButton jb1=new JButton();
  final JButton jb2=new JButton();
  jb1.addActionListener(new SetUpListener(bShowPiece.getSquare(1,1)));
  bShowPiece.getSquare(1,1).setButton(jb1);
  bShowPiece.getSquare(2,1).setButton(jb2);
  showPiece.add(jb1);
  showPiece.add(jb2);
  bShowPiece.getSquare(1,1).refresh();
  bShowPiece.getSquare(2,1).refresh();
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(0),false,bShowPiece.getSquare(1,1),bShowPiece);
  Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(0),true,bShowPiece.getSquare(1,1),bShowPiece);
  bShowPiece.getSquare(1,1).setPiece(toAdd);
  bShowPiece.getSquare(2,1).setPiece(toAdd1);
  bShowPiece.getSquare(1,1).refresh();
  bShowPiece.getSquare(2,1).refresh();
  ListSelectionModel selectList=piecesList.getSelectionModel();
  final Color original=bShowPiece.getSquare(1,1).getColor();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      ListSelectionModel lsm=(ListSelectionModel)e.getSource();
      int selection=lsm.getAnchorSelectionIndex();
      if (!lsm.getValueIsAdjusting()) {
        if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
          bShowPiece.getSquare(1,1).setPiece(null);
          bShowPiece.getSquare(1,1).setBackgroundColor(original);
          bShowPiece.getSquare(1,1).setHabitable(true);
          bShowPiece.getSquare(1,1).refresh();
          jb1.setVisible(true);
          jb2.setVisible(false);
        }
 else         if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
          bShowPiece.getSquare(1,1).refresh();
          jb2.setVisible(false);
          jb1.setVisible(false);
        }
 else {
          jb2.setVisible(true);
          jb1.setVisible(true);
          if (bShowPiece.getSquare(1,1).isHabitable() == false)           bShowPiece.getSquare(1,1).setHabitable(true);
          if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)           bShowPiece.getSquare(1,1).setBackgroundColor(original);
          Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),false,bShowPiece.getSquare(1,1),bShowPiece);
          Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
          bShowPiece.getSquare(1,1).setPiece(toAdd);
          bShowPiece.getSquare(2,1).setPiece(toAdd1);
          bShowPiece.getSquare(1,1).refresh();
          bShowPiece.getSquare(2,1).refresh();
        }
      }
    }
  }
);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  for (int n=0; n < boards.length; n++) {
    final JPanel grid=new JPanel();
    grid.setLayout(new GridLayout(boards[n].numRows(),boards[n].numCols()));
    grid.setPreferredSize(new Dimension(boards[n].numCols() * 48,boards[n].numRows() * 48));
    int numRows=boards[n].numRows();
    int numCols=boards[n].numCols();
    for (int i=numRows; i > 0; i--) {
      for (int j=1; j <= numCols; j++) {
        JButton jb=new JButton();
        jb.addMouseListener(new SetUpMouseListener(boards[n].getSquare(i,j),boards[n],bShowPiece.getSquare(1,1)));
        boards[n].getSquare(i,j).setButton(jb);
        grid.add(jb);
        boards[n].getSquare(i,j).refresh();
      }
    }
    add(grid);
  }
  add(showPiece);
  add(scrollPane);
  backButton=new JButton(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int numObjectives=0;
      if (!whiteRules.getObjectiveName().equals(""String_Node_Str"")) {
        for (        Piece p : whiteTeam) {
          if (p.getName().equals(whiteRules.getObjectiveName()))           numObjectives++;
        }
        if (numObjectives != 1) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      numObjectives=0;
      if (!blackRules.getObjectiveName().equals(""String_Node_Str"")) {
        for (        Piece p : blackTeam) {
          if (p.getName().equals(blackRules.getObjectiveName()))           numObjectives++;
        }
        if (numObjectives != 1) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      b.whiteTeam=whiteTeam;
      boolean set=false;
      for (      Piece p : whiteTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.blackTeam=blackTeam;
      set=false;
      for (      Piece p : blackTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.writeFile(whiteRules,blackRules);
      Driver.getInstance().revertPanel();
    }
  }
);
  JButton changePromote=new JButton(""String_Node_Str"");
  changePromote.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      promotion();
    }
  }
);
  JPanel options=new JPanel();
  options.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  options.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  options.add(changePromote,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  options.add(submitButton,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=3;
  options.add(backButton,c);
  add(options);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param whiteRules the rules for white team.
 * @param blackRules the rules for black team.
 */
private void initComponents(){
  setLayout(new FlowLayout());
  setBorder(BorderFactory.createLoweredBevelBorder());
  final Board[] boards=b.getBoards();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.addElement(""String_Node_Str"");
  final JList piecesList=new JList(list);
  final Board bShowPiece=new Board(2,1,false);
  final JPanel showPiece=new JPanel();
  showPiece.setLayout(new GridLayout(2,1));
  showPiece.setPreferredSize(new Dimension(50,100));
  final JButton jb1=new JButton();
  final JButton jb2=new JButton();
  jb1.addActionListener(new SetUpListener(bShowPiece.getSquare(1,1)));
  bShowPiece.getSquare(1,1).setButton(jb1);
  bShowPiece.getSquare(2,1).setButton(jb2);
  showPiece.add(jb1);
  showPiece.add(jb2);
  bShowPiece.getSquare(1,1).refresh();
  bShowPiece.getSquare(2,1).refresh();
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(0),false,bShowPiece.getSquare(1,1),bShowPiece);
  Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(0),true,bShowPiece.getSquare(1,1),bShowPiece);
  bShowPiece.getSquare(1,1).setPiece(toAdd);
  bShowPiece.getSquare(2,1).setPiece(toAdd1);
  bShowPiece.getSquare(1,1).refresh();
  bShowPiece.getSquare(2,1).refresh();
  ListSelectionModel selectList=piecesList.getSelectionModel();
  final Color original=bShowPiece.getSquare(1,1).getColor();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      ListSelectionModel lsm=(ListSelectionModel)e.getSource();
      int selection=lsm.getAnchorSelectionIndex();
      if (!lsm.getValueIsAdjusting()) {
        if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
          bShowPiece.getSquare(1,1).setPiece(null);
          bShowPiece.getSquare(1,1).setBackgroundColor(original);
          bShowPiece.getSquare(1,1).setHabitable(true);
          bShowPiece.getSquare(1,1).refresh();
          jb1.setVisible(true);
          jb2.setVisible(false);
        }
 else {
          jb2.setVisible(true);
          jb1.setVisible(true);
          if (bShowPiece.getSquare(1,1).isHabitable() == false)           bShowPiece.getSquare(1,1).setHabitable(true);
          if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)           bShowPiece.getSquare(1,1).setBackgroundColor(original);
          Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),false,bShowPiece.getSquare(1,1),bShowPiece);
          Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
          bShowPiece.getSquare(1,1).setPiece(toAdd);
          bShowPiece.getSquare(2,1).setPiece(toAdd1);
          bShowPiece.getSquare(1,1).refresh();
          bShowPiece.getSquare(2,1).refresh();
        }
      }
    }
  }
);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  for (int n=0; n < boards.length; n++) {
    final JPanel grid=new JPanel();
    grid.setLayout(new GridLayout(boards[n].numRows(),boards[n].numCols()));
    grid.setPreferredSize(new Dimension(boards[n].numCols() * 48,boards[n].numRows() * 48));
    int numRows=boards[n].numRows();
    int numCols=boards[n].numCols();
    for (int i=numRows; i > 0; i--) {
      for (int j=1; j <= numCols; j++) {
        JButton jb=new JButton();
        jb.addMouseListener(new SetUpMouseListener(boards[n].getSquare(i,j),boards[n],bShowPiece.getSquare(1,1)));
        boards[n].getSquare(i,j).setButton(jb);
        grid.add(jb);
        boards[n].getSquare(i,j).refresh();
      }
    }
    add(grid);
  }
  add(showPiece);
  add(scrollPane);
  backButton=new JButton(""String_Node_Str"");
  submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int numObjectives=0;
      if (!whiteRules.getObjectiveName().equals(""String_Node_Str"")) {
        for (        Piece p : whiteTeam) {
          if (p.getName().equals(whiteRules.getObjectiveName()))           numObjectives++;
        }
        if (numObjectives != 1) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      numObjectives=0;
      if (!blackRules.getObjectiveName().equals(""String_Node_Str"")) {
        for (        Piece p : blackTeam) {
          if (p.getName().equals(blackRules.getObjectiveName()))           numObjectives++;
        }
        if (numObjectives != 1) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      b.whiteTeam=whiteTeam;
      boolean set=false;
      for (      Piece p : whiteTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.blackTeam=blackTeam;
      set=false;
      for (      Piece p : blackTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.writeFile(whiteRules,blackRules);
      Driver.getInstance().revertPanel();
    }
  }
);
  JButton changePromote=new JButton(""String_Node_Str"");
  changePromote.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      promotion();
    }
  }
);
  JPanel options=new JPanel();
  options.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  options.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  options.add(changePromote,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  options.add(submitButton,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=3;
  options.add(backButton,c);
  add(options);
}"
49975,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setLocationRelativeTo(null);
  setResizable(false);
  setLayout(new FlowLayout());
  setResizable(true);
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
  }
  mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  BufferedImage temp=null;
  try {
    temp=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  ImageIcon picture=new ImageIcon(temp);
  JLabel pictureHolder=new JLabel();
  picture.setImage(picture.getImage().getScaledInstance(300,200,Image.SCALE_SMOOTH));
  pictureHolder.setIcon(picture);
  newGame=new JButton(""String_Node_Str"");
  newGame.setToolTipText(""String_Node_Str"");
  newGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      pack();
    }
  }
);
  continueGame=new JButton(""String_Node_Str"");
  continueGame.setToolTipText(""String_Node_Str"");
  continueGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        FileInputStream f_in=new FileInputStream(new File(""String_Node_Str"" + choice));
        ObjectInputStream obj_in=new ObjectInputStream(f_in);
        Game toPlay=(Game)obj_in.readObject();
        helpMenu.setText(""String_Node_Str"");
        gameInfo.setVisible(true);
        gamePlayHelp.setVisible(true);
        gameOptions.setVisible(true);
        remove(mainPanel);
        otherPanel=new PlayGame(toPlay,false);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  viewGame=new JButton(""String_Node_Str"");
  viewGame.setToolTipText(""String_Node_Str"");
  viewGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        File file=new File(""String_Node_Str"" + choice);
        Game toView;
        if (choice.endsWith(""String_Node_Str"")) {
          otherPanel=new PlayGame(true,file);
        }
 else {
          FileInputStream f_in=new FileInputStream(file);
          ObjectInputStream obj_in=new ObjectInputStream(f_in);
          toView=(Game)obj_in.readObject();
          otherPanel=new PlayGame(toView,true);
        }
        completedHelp.setVisible(true);
        helpMenu.setText(""String_Node_Str"");
        ;
        remove(mainPanel);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        System.out.println(e.getMessage());
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  createType=new JButton(""String_Node_Str"");
  createType.setToolTipText(""String_Node_Str"");
  createType.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(true);
      helpMenu.setText(""String_Node_Str"");
      remove(mainPanel);
      otherPanel=new NewTypeMenu();
      add(otherPanel);
      pack();
    }
  }
);
  menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  fileMenu.setForeground(Color.WHITE);
  fileMenu.setMnemonic('F');
  helpMenu=new JMenu(""String_Node_Str"");
  helpMenu.setForeground(Color.white);
  helpMenu.setMnemonic('H');
  JMenuItem helpMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_H);
  helpMenuItem.setToolTipText(""String_Node_Str"");
  BufferedImage help=null;
  try {
    help=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon helpPicture=new ImageIcon(help);
  helpPicture.setImage(helpPicture.getImage().getScaledInstance(600,600,Image.SCALE_SMOOTH));
  helpMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"",""String_Node_Str"",0,helpPicture);
    }
  }
);
  helpMenu.add(helpMenuItem);
  gamePlayHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_G);
  gamePlayHelp.setToolTipText(""String_Node_Str"");
  gamePlayHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  helpMenu.add(gamePlayHelp);
  gamePlayHelp.setVisible(false);
  gameInfo=new JMenuItem(""String_Node_Str"",KeyEvent.VK_I);
  gameInfo.setToolTipText(""String_Node_Str"");
  gameInfo.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
    }
  }
);
  helpMenu.add(gameInfo);
  gameInfo.setVisible(false);
  variantHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_V);
  variantHelp.setToolTipText(""String_Node_Str"");
  variantHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  helpMenu.add(variantHelp);
  variantHelp.setVisible(false);
  completedHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  completedHelp.setToolTipText(""String_Node_Str"");
  completedHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
);
  helpMenu.add(completedHelp);
  completedHelp.setVisible(false);
  JMenuItem newGameItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  newGameItem.setToolTipText(""String_Node_Str"");
  newGameItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(false);
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      if (otherPanel != null)       remove(otherPanel);
      if (mainPanel != null)       remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      pack();
    }
  }
);
  fileMenu.add(newGameItem);
  JMenuItem mainMenu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_M);
  mainMenu.setToolTipText(""String_Node_Str"");
  mainMenu.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      helpMenu.setText(""String_Node_Str"");
      variantHelp.setVisible(false);
      gameInfo.setVisible(false);
      gamePlayHelp.setVisible(false);
      completedHelp.setVisible(false);
      if (gameOptions != null)       gameOptions.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      add(mainPanel);
      pack();
    }
  }
);
  fileMenu.add(mainMenu);
  JMenuItem exitMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_Q);
  exitMenuItem.setToolTipText(""String_Node_Str"");
  exitMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",1);
      if (answer == 0)       System.exit(0);
    }
  }
);
  fileMenu.add(exitMenuItem);
  menuBar.add(fileMenu);
  menuBar.add(helpMenu);
  setJMenuBar(menuBar);
  mainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=0;
  mainPanel.add(pictureHolder,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  mainPanel.add(newGame,c);
  c.gridx=2;
  c.gridy=1;
  c.gridwidth=1;
  mainPanel.add(createType,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mainPanel.add(continueGame,c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mainPanel.add(viewGame,c);
  add(mainPanel);
  setVisible(true);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setLocationRelativeTo(null);
  setResizable(false);
  setLayout(new FlowLayout());
  setResizable(true);
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
  }
  mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  BufferedImage temp=null;
  try {
    temp=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  ImageIcon picture=new ImageIcon(temp);
  JLabel pictureHolder=new JLabel();
  picture.setImage(picture.getImage().getScaledInstance(300,200,Image.SCALE_SMOOTH));
  pictureHolder.setIcon(picture);
  newGame=new JButton(""String_Node_Str"");
  newGame.setToolTipText(""String_Node_Str"");
  newGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      pack();
    }
  }
);
  continueGame=new JButton(""String_Node_Str"");
  continueGame.setToolTipText(""String_Node_Str"");
  continueGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        FileInputStream f_in=new FileInputStream(new File(""String_Node_Str"" + choice));
        ObjectInputStream obj_in=new ObjectInputStream(f_in);
        Game toPlay=(Game)obj_in.readObject();
        helpMenu.setText(""String_Node_Str"");
        gameInfo.setVisible(true);
        gamePlayHelp.setVisible(true);
        gameOptions.setVisible(true);
        remove(mainPanel);
        otherPanel=new PlayGame(toPlay,false);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  viewGame=new JButton(""String_Node_Str"");
  viewGame.setToolTipText(""String_Node_Str"");
  viewGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        File file=new File(""String_Node_Str"" + choice);
        Game toView;
        if (choice.endsWith(""String_Node_Str"")) {
          otherPanel=new PlayGame(true,file);
        }
 else {
          FileInputStream f_in=new FileInputStream(file);
          ObjectInputStream obj_in=new ObjectInputStream(f_in);
          toView=(Game)obj_in.readObject();
          otherPanel=new PlayGame(toView,true);
        }
        completedHelp.setVisible(true);
        helpMenu.setText(""String_Node_Str"");
        ;
        remove(mainPanel);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        System.out.println(e.getMessage());
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  createType=new JButton(""String_Node_Str"");
  createType.setToolTipText(""String_Node_Str"");
  createType.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(true);
      helpMenu.setText(""String_Node_Str"");
      remove(mainPanel);
      otherPanel=new NewTypeMenu();
      add(otherPanel);
      pack();
    }
  }
);
  menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  fileMenu.setForeground(Color.WHITE);
  fileMenu.setMnemonic('F');
  helpMenu=new JMenu(""String_Node_Str"");
  helpMenu.setForeground(Color.white);
  helpMenu.setMnemonic('H');
  JMenuItem helpMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_H);
  helpMenuItem.setToolTipText(""String_Node_Str"");
  BufferedImage help=null;
  try {
    help=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon helpPicture=new ImageIcon(help);
  helpPicture.setImage(helpPicture.getImage().getScaledInstance(600,600,Image.SCALE_SMOOTH));
  helpMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"",""String_Node_Str"",0,helpPicture);
    }
  }
);
  helpMenu.add(helpMenuItem);
  gamePlayHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_G);
  gamePlayHelp.setToolTipText(""String_Node_Str"");
  gamePlayHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  helpMenu.add(gamePlayHelp);
  gamePlayHelp.setVisible(false);
  gameInfo=new JMenuItem(""String_Node_Str"",KeyEvent.VK_I);
  gameInfo.setToolTipText(""String_Node_Str"");
  gameInfo.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
    }
  }
);
  helpMenu.add(gameInfo);
  gameInfo.setVisible(false);
  variantHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_V);
  variantHelp.setToolTipText(""String_Node_Str"");
  variantHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  helpMenu.add(variantHelp);
  variantHelp.setVisible(false);
  completedHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  completedHelp.setToolTipText(""String_Node_Str"");
  completedHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
);
  helpMenu.add(completedHelp);
  completedHelp.setVisible(false);
  JMenuItem newGameItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  newGameItem.setToolTipText(""String_Node_Str"");
  newGameItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(false);
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      if (PlayGame.menu != null)       PlayGame.menu.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      if (mainPanel != null)       remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      pack();
    }
  }
);
  fileMenu.add(newGameItem);
  JMenuItem mainMenu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_M);
  mainMenu.setToolTipText(""String_Node_Str"");
  mainMenu.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      helpMenu.setText(""String_Node_Str"");
      variantHelp.setVisible(false);
      gameInfo.setVisible(false);
      gamePlayHelp.setVisible(false);
      completedHelp.setVisible(false);
      if (gameOptions != null)       gameOptions.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      add(mainPanel);
      pack();
    }
  }
);
  fileMenu.add(mainMenu);
  JMenuItem exitMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_Q);
  exitMenuItem.setToolTipText(""String_Node_Str"");
  exitMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",1);
      if (answer == 0)       System.exit(0);
    }
  }
);
  fileMenu.add(exitMenuItem);
  menuBar.add(fileMenu);
  menuBar.add(helpMenu);
  setJMenuBar(menuBar);
  mainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=0;
  mainPanel.add(pictureHolder,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  mainPanel.add(newGame,c);
  c.gridx=2;
  c.gridy=1;
  c.gridwidth=1;
  mainPanel.add(createType,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mainPanel.add(continueGame,c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mainPanel.add(viewGame,c);
  add(mainPanel);
  setVisible(true);
}"
49976,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param isPlayback whether PlayGame is in playback mode
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback){
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  undoItem=new JButton(""String_Node_Str"");
  undoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      mustMove=false;
      if (getGame().getHistory().size() == 0)       return;
      getGame().getHistory().get(getGame().getHistory().size() - 1).undo();
      getGame().getHistory().remove(getGame().getHistory().size() - 1);
      (getGame().isBlackMove() ? getGame().getBlackRules() : getGame().getWhiteRules()).undoEndOfGame();
      boardRefresh(getGame().getBoards());
    }
  }
);
  int ifDouble=0;
  Driver.getInstance().setMenu(createMenu());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  this.setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      history[index--].undo();
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteCapturesBox=new Jail(k,k);
  whiteCaptures.setLayout(new GridLayout(k,k));
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      whiteCapturesBox.getSquare(i,j).setButton(jb);
      whiteCaptures.add(jb);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackCapturesBox=new Jail(k,k);
  blackCaptures.setLayout(new GridLayout(k,k));
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      blackCapturesBox.getSquare(i,j).setButton(jb);
      blackCaptures.add(jb);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(undoItem,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param isPlayback whether PlayGame is in playback mode
 */
@SuppressWarnings(""String_Node_Str"") private void initComponents(boolean isPlayback){
  inCheck=new JLabel(""String_Node_Str"");
  inCheck.setHorizontalTextPosition(inCheck.CENTER);
  inCheck.setForeground(Color.RED);
  undoItem=new JButton(""String_Node_Str"");
  undoItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      mustMove=false;
      if (getGame().getHistory().size() == 0)       return;
      getGame().getHistory().get(getGame().getHistory().size() - 1).undo();
      getGame().getHistory().remove(getGame().getHistory().size() - 1);
      (getGame().isBlackMove() ? getGame().getBlackRules() : getGame().getWhiteRules()).undoEndOfGame();
      boardRefresh(getGame().getBoards());
    }
  }
);
  int ifDouble=0;
  if (menu == null)   Driver.getInstance().setMenu(createMenu());
 else   if (!menu.isVisible())   Driver.getInstance().setMenu(createMenu());
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=getGame().getBoards();
  this.setBorder(BorderFactory.createLoweredBevelBorder());
  inCheck.setHorizontalTextPosition(SwingConstants.CENTER);
  inCheck.setHorizontalAlignment(SwingConstants.CENTER);
  c.fill=GridBagConstraints.NONE;
  c.gridy=0;
  c.gridx=9;
  inCheck.setVisible(false);
  this.add(inCheck,c);
  if (boards.length == 1) {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.gridheight=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
  }
 else {
    c.gridheight=12;
    c.gridy=2;
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=0;
    this.add(createGrid(boards[0],isPlayback),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.gridwidth=10;
    c.insets=new Insets(10,0,0,0);
    c.gridx=11;
    this.add(createGrid(boards[1],isPlayback),c);
    ifDouble+=10;
  }
  JButton nextButt=new JButton(""String_Node_Str"");
  nextButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index + 1 == history.length)       return;
      try {
        history[++index].execute();
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
  }
);
  JButton prevButt=new JButton(""String_Node_Str"");
  prevButt.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (index == -1)       return;
      history[index--].undo();
    }
  }
);
  whiteLabel=new JLabel(""String_Node_Str"");
  whiteLabel.setHorizontalAlignment(SwingConstants.CENTER);
  whiteLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackLabel=new JLabel(""String_Node_Str"");
  blackLabel.setHorizontalAlignment(SwingConstants.CENTER);
  blackLabel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteLabel.setOpaque(true);
  blackLabel.setOpaque(true);
  int k;
  if (getGame().getWhiteTeam().size() <= 4 && getGame().getBlackTeam().size() <= 4) {
    k=4;
  }
 else {
    double o=getGame().getWhiteTeam().size() > getGame().getBlackTeam().size() ? Math.sqrt(getGame().getWhiteTeam().size()) : Math.sqrt(getGame().getBlackTeam().size());
    k=(int)Math.ceil(o);
  }
  whiteCaptures=new JPanel();
  whiteCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteCapturesBox=new Jail(k,k);
  whiteCaptures.setLayout(new GridLayout(k,k));
  whiteCaptures.setPreferredSize(new Dimension((whiteCapturesBox.numCols() + 1) * 25,(whiteCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      whiteCapturesBox.getSquare(i,j).setButton(jb);
      whiteCaptures.add(jb);
    }
  }
  blackCaptures=new JPanel();
  blackCaptures.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackCapturesBox=new Jail(k,k);
  blackCaptures.setLayout(new GridLayout(k,k));
  blackCaptures.setPreferredSize(new Dimension((blackCapturesBox.numCols() + 1) * 25,(blackCapturesBox.numRows() + 1) * 25));
  for (int i=k; i > 0; i--) {
    for (int j=1; j <= k; j++) {
      JButton jb=new JButton();
      blackCapturesBox.getSquare(i,j).setButton(jb);
      blackCaptures.add(jb);
    }
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=1;
  c.insets=new Insets(10,10,10,0);
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  c.gridy=0;
  this.add(blackLabel,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.insets=new Insets(0,25,10,25);
  c.gridx=11 + ifDouble;
  c.gridy=1;
  this.add(blackCaptures,c);
  if (!isPlayback) {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(blackTimer.getLabel(),c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(undoItem,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=6;
    this.add(whiteTimer.getLabel(),c);
  }
 else {
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=4;
    this.add(nextButt,c);
    c.fill=GridBagConstraints.HORIZONTAL;
    c.anchor=GridBagConstraints.BASELINE;
    c.gridwidth=3;
    c.gridheight=1;
    c.ipadx=100;
    c.gridx=11 + ifDouble;
    c.gridy=5;
    this.add(prevButt,c);
  }
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.gridheight=3;
  c.ipadx=0;
  c.gridx=11 + ifDouble;
  if (whiteTimer instanceof NoTimer) {
    c.gridy=6;
    c.insets=new Insets(10,25,0,25);
  }
 else {
    c.gridy=7;
    c.insets=new Insets(0,25,0,25);
  }
  this.add(whiteCaptures,c);
  c.fill=GridBagConstraints.NONE;
  c.anchor=GridBagConstraints.BASELINE;
  c.gridwidth=3;
  c.weightx=0.0;
  c.weighty=0.0;
  c.insets=new Insets(10,0,10,0);
  if (whiteTimer instanceof NoTimer) {
    c.gridheight=1;
    c.gridy=9;
  }
 else {
    c.gridheight=2;
    c.gridy=11;
  }
  c.ipadx=100;
  c.gridx=11 + ifDouble;
  this.add(whiteLabel,c);
}"
49977,"/** 
 * In this case, only pawns can promote, allow the user to pick which class it promotes to.
 * @param p The piece to promote
 * @param verified Whether it has been verified that thisis ok
 * @param promo What the piece was promoted to.
 * @return The promoted Piece.
 */
public Piece classicPromotion(Piece p,boolean verified,String promo){
  lastPromoted=p.getName();
  if (!verified && promo == null && g.isBlackMove() == p.isBlack()) {
    klazz=""String_Node_Str"";
    if (p.getPromotesTo().size() == 1)     klazz=p.getPromotesTo().get(0);
    while (klazz.equals(""String_Node_Str"")) {
      String result=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,p.getPromotesTo().toArray(),null);
      if (result == null) {
        continue;
      }
      try {
        klazz=result;
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
 else   if (promo != null) {
    klazz=promo;
  }
  try {
    Piece promoted=PieceBuilder.makePiece(klazz,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * In this case, only pawns can promote, allow the user to pick which class it promotes to.
 * @param p The piece to promote
 * @param verified Whether it has been verified that thisis ok
 * @param promo What the piece was promoted to.
 * @return The promoted Piece.
 */
public Piece classicPromotion(Piece p,boolean verified,String promo){
  lastPromoted=p.getName();
  klazz=p.getName();
  if (p.getPromotesTo() == null)   return p;
  if (!verified && promo == null && g.isBlackMove() == p.isBlack()) {
    klazz=""String_Node_Str"";
    if (p.getPromotesTo().size() == 1)     klazz=p.getPromotesTo().get(0);
    while (klazz.equals(""String_Node_Str"")) {
      String result=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,p.getPromotesTo().toArray(),null);
      if (result == null) {
        continue;
      }
      try {
        klazz=result;
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
 else   if (promo != null) {
    klazz=promo;
  }
  try {
    Piece promoted=PieceBuilder.makePiece(klazz,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}"
49978,"/** 
 * @param isBlack
 */
private void setPieceOnBoard(boolean isBlack){
  if (option.isOccupied() == false) {
    if ((option.getColor().equals(Color.LIGHT_GRAY) == false) && (option.getColor().equals(Color.getHSBColor(30,70,70)) == false)) {
      square.setBackgroundColor(option.getColor());
    }
    if (option.isHabitable() == false) {
      square.setPiece(option.getPiece());
    }
    square.setHabitable(option.isHabitable());
    square.refresh();
  }
 else {
    if (square.isHabitable() == true) {
      Piece p=PieceBuilder.makePiece(option.getPiece().getName(),isBlack,square,board);
      if (isBlack)       blackTeam.add(p);
 else       whiteTeam.add(p);
      square.setPiece(p);
      square.refresh();
    }
 else {
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.WARNING_MESSAGE);
    }
  }
}","/** 
 * @param isBlack
 */
private void setPieceOnBoard(boolean isBlack){
  if (!option.isOccupied()) {
    if ((option.getColor().equals(Color.LIGHT_GRAY) == false) && (option.getColor().equals(Color.getHSBColor(30,70,70)) == false)) {
      square.setBackgroundColor(option.getColor());
    }
    if (!option.isHabitable()) {
      square.setPiece(option.getPiece());
    }
    square.setHabitable(option.isHabitable());
    square.refresh();
  }
 else {
    if (square.isHabitable()) {
      if (square.isOccupied()) {
        Piece toRemove=square.getPiece();
        (toRemove.isBlack() ? blackTeam : whiteTeam).remove(toRemove);
      }
      Piece p=PieceBuilder.makePiece(option.getPiece().getName(),isBlack,square,board);
      if (isBlack)       blackTeam.add(p);
 else       whiteTeam.add(p);
      square.setPiece(p);
      square.refresh();
    }
 else {
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.WARNING_MESSAGE);
    }
  }
}"
49979,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param whiteRules the rules for white team.
 * @param blackRules the rules for black team.
 */
private void initComponents(){
  setLayout(new FlowLayout());
  setBorder(BorderFactory.createLoweredBevelBorder());
  final Board[] boards=b.getBoards();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.addElement(""String_Node_Str"");
  final JList piecesList=new JList(list);
  final Board bShowPiece=new Board(2,1,false);
  final JPanel showPiece=new JPanel();
  showPiece.setLayout(new GridLayout(2,1));
  showPiece.setPreferredSize(new Dimension(50,100));
  final JButton jb1=new JButton();
  final JButton jb2=new JButton();
  jb1.addActionListener(new SetUpListener(bShowPiece.getSquare(1,1)));
  bShowPiece.getSquare(1,1).setButton(jb1);
  bShowPiece.getSquare(2,1).setButton(jb2);
  showPiece.add(jb1);
  showPiece.add(jb2);
  bShowPiece.getSquare(1,1).refresh();
  bShowPiece.getSquare(2,1).refresh();
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(0),false,bShowPiece.getSquare(1,1),bShowPiece);
  Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(0),true,bShowPiece.getSquare(1,1),bShowPiece);
  bShowPiece.getSquare(1,1).setPiece(toAdd);
  bShowPiece.getSquare(2,1).setPiece(toAdd1);
  bShowPiece.getSquare(1,1).refresh();
  bShowPiece.getSquare(2,1).refresh();
  ListSelectionModel selectList=piecesList.getSelectionModel();
  final Color original=bShowPiece.getSquare(1,1).getColor();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      ListSelectionModel lsm=(ListSelectionModel)e.getSource();
      int selection=lsm.getAnchorSelectionIndex();
      if (!lsm.getValueIsAdjusting()) {
        if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
          bShowPiece.getSquare(1,1).setPiece(null);
          bShowPiece.getSquare(1,1).setBackgroundColor(original);
          bShowPiece.getSquare(1,1).setHabitable(true);
          bShowPiece.getSquare(1,1).refresh();
          jb1.setVisible(true);
          jb2.setVisible(false);
        }
 else {
          jb2.setVisible(true);
          jb1.setVisible(true);
          if (bShowPiece.getSquare(1,1).isHabitable() == false)           bShowPiece.getSquare(1,1).setHabitable(true);
          if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)           bShowPiece.getSquare(1,1).setBackgroundColor(original);
          Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),false,bShowPiece.getSquare(1,1),bShowPiece);
          Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
          bShowPiece.getSquare(1,1).setPiece(toAdd);
          bShowPiece.getSquare(2,1).setPiece(toAdd1);
          bShowPiece.getSquare(1,1).refresh();
          bShowPiece.getSquare(2,1).refresh();
        }
      }
    }
  }
);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  for (int n=0; n < boards.length; n++) {
    final JPanel grid=new JPanel();
    grid.setLayout(new GridLayout(boards[n].numRows(),boards[n].numCols()));
    grid.setPreferredSize(new Dimension(boards[n].numCols() * 48,boards[n].numRows() * 48));
    int numRows=boards[n].numRows();
    int numCols=boards[n].numCols();
    for (int i=numRows; i > 0; i--) {
      for (int j=1; j <= numCols; j++) {
        JButton jb=new JButton();
        jb.addMouseListener(new SetUpMouseListener(boards[n].getSquare(i,j),boards[n],bShowPiece.getSquare(1,1)));
        boards[n].getSquare(i,j).setButton(jb);
        grid.add(jb);
        boards[n].getSquare(i,j).refresh();
      }
    }
    add(grid);
  }
  JButton changePromote=new JButton(""String_Node_Str"");
  changePromote.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      promotion();
    }
  }
);
  GridBagConstraints c=new GridBagConstraints();
  JPanel pieceHolder=new JPanel();
  pieceHolder.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=0;
  pieceHolder.add(scrollPane,c);
  c.gridx=0;
  c.gridy=1;
  pieceHolder.add(changePromote,c);
  add(showPiece);
  add(pieceHolder);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      int numObjectives=0;
      if (!whiteRules.getObjectiveName().equals(""String_Node_Str"")) {
        for (        Piece p : whiteTeam) {
          if (p.getName().equals(whiteRules.getObjectiveName()))           numObjectives++;
        }
        if (numObjectives != 1) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      numObjectives=0;
      if (!blackRules.getObjectiveName().equals(""String_Node_Str"")) {
        for (        Piece p : blackTeam) {
          if (p.getName().equals(blackRules.getObjectiveName()))           numObjectives++;
        }
        if (numObjectives != 1) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      b.whiteTeam=whiteTeam;
      boolean set=false;
      for (      Piece p : whiteTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.blackTeam=blackTeam;
      set=false;
      for (      Piece p : blackTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.writeFile(whiteRules,blackRules);
      Driver.getInstance().revertPanel();
    }
  }
);
  JPanel options=new JPanel();
  options.setLayout(new GridBagLayout());
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  options.add(submitButton,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=3;
  options.add(backButton,c);
  add(options);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param whiteRules the rules for white team.
 * @param blackRules the rules for black team.
 */
private void initComponents(){
  setLayout(new FlowLayout());
  setBorder(BorderFactory.createLoweredBevelBorder());
  final Board[] boards=b.getBoards();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.addElement(""String_Node_Str"");
  final JList piecesList=new JList(list);
  final Board bShowPiece=new Board(2,1,false);
  final JPanel showPiece=new JPanel();
  showPiece.setLayout(new GridLayout(2,1));
  showPiece.setPreferredSize(new Dimension(50,100));
  final JButton jb1=new JButton();
  final JButton jb2=new JButton();
  jb1.addActionListener(new SetUpListener(bShowPiece.getSquare(1,1)));
  bShowPiece.getSquare(1,1).setButton(jb1);
  bShowPiece.getSquare(2,1).setButton(jb2);
  showPiece.add(jb1);
  showPiece.add(jb2);
  bShowPiece.getSquare(1,1).refresh();
  bShowPiece.getSquare(2,1).refresh();
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(0),false,bShowPiece.getSquare(1,1),bShowPiece);
  Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(0),true,bShowPiece.getSquare(1,1),bShowPiece);
  bShowPiece.getSquare(1,1).setPiece(toAdd);
  bShowPiece.getSquare(2,1).setPiece(toAdd1);
  bShowPiece.getSquare(1,1).refresh();
  bShowPiece.getSquare(2,1).refresh();
  ListSelectionModel selectList=piecesList.getSelectionModel();
  final Color original=bShowPiece.getSquare(1,1).getColor();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      ListSelectionModel lsm=(ListSelectionModel)e.getSource();
      int selection=lsm.getAnchorSelectionIndex();
      if (!lsm.getValueIsAdjusting()) {
        if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
          bShowPiece.getSquare(1,1).setPiece(null);
          bShowPiece.getSquare(1,1).setBackgroundColor(original);
          bShowPiece.getSquare(1,1).setHabitable(true);
          bShowPiece.getSquare(1,1).refresh();
          jb1.setVisible(true);
          jb2.setVisible(false);
        }
 else {
          jb2.setVisible(true);
          jb1.setVisible(true);
          if (bShowPiece.getSquare(1,1).isHabitable() == false)           bShowPiece.getSquare(1,1).setHabitable(true);
          if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)           bShowPiece.getSquare(1,1).setBackgroundColor(original);
          Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),false,bShowPiece.getSquare(1,1),bShowPiece);
          Piece toAdd1=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
          bShowPiece.getSquare(1,1).setPiece(toAdd);
          bShowPiece.getSquare(2,1).setPiece(toAdd1);
          bShowPiece.getSquare(1,1).refresh();
          bShowPiece.getSquare(2,1).refresh();
        }
      }
    }
  }
);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  for (int n=0; n < boards.length; n++) {
    final JPanel grid=new JPanel();
    grid.setLayout(new GridLayout(boards[n].numRows(),boards[n].numCols()));
    grid.setPreferredSize(new Dimension(boards[n].numCols() * 48,boards[n].numRows() * 48));
    int numRows=boards[n].numRows();
    int numCols=boards[n].numCols();
    for (int i=numRows; i > 0; i--) {
      for (int j=1; j <= numCols; j++) {
        JButton jb=new JButton();
        jb.addMouseListener(new SetUpMouseListener(boards[n].getSquare(i,j),boards[n],bShowPiece.getSquare(1,1)));
        boards[n].getSquare(i,j).setButton(jb);
        grid.add(jb);
        boards[n].getSquare(i,j).refresh();
      }
    }
    add(grid);
  }
  JButton changePromote=new JButton(""String_Node_Str"");
  changePromote.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      promotion();
    }
  }
);
  GridBagConstraints c=new GridBagConstraints();
  JPanel pieceHolder=new JPanel();
  pieceHolder.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=0;
  pieceHolder.add(scrollPane,c);
  c.gridx=0;
  c.gridy=1;
  pieceHolder.add(changePromote,c);
  add(showPiece);
  add(pieceHolder);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      System.out.println(""String_Node_Str"");
      for (      Piece p : whiteTeam) {
        System.out.print(p.getName() + ""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"");
      for (      Piece p : blackTeam) {
        System.out.print(p.getName() + ""String_Node_Str"");
      }
      int numObjectives=0;
      if (!whiteRules.getObjectiveName().equals(""String_Node_Str"")) {
        for (        Piece p : whiteTeam) {
          if (p.getName().equals(whiteRules.getObjectiveName()))           numObjectives++;
        }
        if (numObjectives != 1) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      numObjectives=0;
      if (!blackRules.getObjectiveName().equals(""String_Node_Str"")) {
        for (        Piece p : blackTeam) {
          if (p.getName().equals(blackRules.getObjectiveName()))           numObjectives++;
        }
        if (numObjectives != 1) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      b.whiteTeam=whiteTeam;
      boolean set=false;
      for (      Piece p : whiteTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.blackTeam=blackTeam;
      set=false;
      for (      Piece p : blackTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.writeFile(whiteRules,blackRules);
      Driver.getInstance().revertPanel();
    }
  }
);
  JPanel options=new JPanel();
  options.setLayout(new GridBagLayout());
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  options.add(submitButton,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=3;
  options.add(backButton,c);
  add(options);
}"
49980,"@Override public void actionPerformed(ActionEvent arg0){
  int numObjectives=0;
  if (!whiteRules.getObjectiveName().equals(""String_Node_Str"")) {
    for (    Piece p : whiteTeam) {
      if (p.getName().equals(whiteRules.getObjectiveName()))       numObjectives++;
    }
    if (numObjectives != 1) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      return;
    }
  }
  numObjectives=0;
  if (!blackRules.getObjectiveName().equals(""String_Node_Str"")) {
    for (    Piece p : blackTeam) {
      if (p.getName().equals(blackRules.getObjectiveName()))       numObjectives++;
    }
    if (numObjectives != 1) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      return;
    }
  }
  b.whiteTeam=whiteTeam;
  boolean set=false;
  for (  Piece p : whiteTeam) {
    if (p.getName().equals(""String_Node_Str"")) {
      whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      set=true;
      break;
    }
  }
  if (!set) {
    whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
  }
  b.blackTeam=blackTeam;
  set=false;
  for (  Piece p : blackTeam) {
    if (p.getName().equals(""String_Node_Str"")) {
      blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      set=true;
      break;
    }
  }
  if (!set) {
    blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
  }
  b.writeFile(whiteRules,blackRules);
  Driver.getInstance().revertPanel();
}","@Override public void actionPerformed(ActionEvent arg0){
  System.out.println(""String_Node_Str"");
  for (  Piece p : whiteTeam) {
    System.out.print(p.getName() + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  for (  Piece p : blackTeam) {
    System.out.print(p.getName() + ""String_Node_Str"");
  }
  int numObjectives=0;
  if (!whiteRules.getObjectiveName().equals(""String_Node_Str"")) {
    for (    Piece p : whiteTeam) {
      if (p.getName().equals(whiteRules.getObjectiveName()))       numObjectives++;
    }
    if (numObjectives != 1) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      return;
    }
  }
  numObjectives=0;
  if (!blackRules.getObjectiveName().equals(""String_Node_Str"")) {
    for (    Piece p : blackTeam) {
      if (p.getName().equals(blackRules.getObjectiveName()))       numObjectives++;
    }
    if (numObjectives != 1) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"");
      return;
    }
  }
  b.whiteTeam=whiteTeam;
  boolean set=false;
  for (  Piece p : whiteTeam) {
    if (p.getName().equals(""String_Node_Str"")) {
      whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      set=true;
      break;
    }
  }
  if (!set) {
    whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
  }
  b.blackTeam=blackTeam;
  set=false;
  for (  Piece p : blackTeam) {
    if (p.getName().equals(""String_Node_Str"")) {
      blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      set=true;
      break;
    }
  }
  if (!set) {
    blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
  }
  b.writeFile(whiteRules,blackRules);
  Driver.getInstance().revertPanel();
}"
49981,"/** 
 * @param name The name of the method
 * @param whiteMoves The number of white moves.
 * @param blackMoves The number of black moves
 * @param increment The increment.
 */
public NextTurn(String name,int whiteMoves,int blackMoves,int increment){
  this.name=name;
  doMethod=doMethods.get(name);
  undoMethod=undoMethods.get(name);
  NextTurn.whiteMoves=whiteMoves;
  NextTurn.blackMoves=blackMoves;
  NextTurn.increment=increment;
  currentNumMoves=0;
  isBlackMove=false;
}","/** 
 * @param name The name of the method
 * @param whiteMoves The number of white moves.
 * @param blackMoves The number of black moves
 * @param increment The increment.
 */
public NextTurn(String name,int whiteMoves,int blackMoves,int increment){
  this.name=name;
  doMethod=doMethods.get(name);
  undoMethod=undoMethods.get(name);
  this.whiteMoves=whiteMoves;
  this.blackMoves=blackMoves;
  this.increment=increment;
  currentNumMoves=0;
  isBlackMove=false;
}"
49982,"public void init(){
  label=new JLabel();
  label.setHorizontalAlignment(SwingConstants.CENTER);
  label.setOpaque(true);
  nf=NumberFormat.getNumberInstance();
  nf.setMinimumIntegerDigits(2);
  timer=new Timer(1000,this);
  timer.setInitialDelay(0);
}","/** 
 * Initialize the components of the timer.
 */
public void init(){
  label=new JLabel();
  label.setHorizontalAlignment(SwingConstants.CENTER);
  label.setOpaque(true);
  nf=NumberFormat.getNumberInstance();
  nf.setMinimumIntegerDigits(2);
  timer=new Timer(1000,this);
  timer.setInitialDelay(0);
}"
49983,public abstract void start();,"/** 
 * Start the timer
 */
public abstract void start();"
49984,public abstract void stop();,"/** 
 * Stop the timer.
 */
public abstract void stop();"
49985,"/** 
 * Method to set up the piece making window.
 */
public void initComponents(){
  builder=new PieceBuilder();
  setSize(550,875);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  Driver.getInstance().setLocationRelativeTo(null);
  JPanel piecePanel=new JPanel();
  piecePanel.setLayout(new GridBagLayout());
  piecePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel namePanel=new JPanel();
  namePanel.setLayout(new FlowLayout());
  namePanel.add(new JLabel(""String_Node_Str""));
  final JTextField name=new JTextField(15);
  namePanel.add(name);
  c.gridx=0;
  c.gridy=0;
  piecePanel.add(namePanel,c);
  final ImageIcon temp=new ImageIcon(""String_Node_Str"");
  temp.setImage(temp.getImage().getScaledInstance(48,48,Image.SCALE_SMOOTH));
  final JPanel lightIconPanel=new JPanel();
  lightIconPanel.setLayout(new FlowLayout());
  final JButton lightIconButton=new JButton();
  lightIconButton.setSize(48,48);
  lightIconButton.setIcon(temp);
  final JButton chooseLightImage=new JButton(""String_Node_Str"");
  chooseLightImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        lightIconButton.setIcon(icon);
        builder.setLightImage(icon);
      }
    }
  }
);
  lightIconPanel.add(chooseLightImage);
  lightIconPanel.add(lightIconButton);
  c.gridx=0;
  c.gridy=2;
  piecePanel.add(lightIconPanel,c);
  final JPanel darkIconPanel=new JPanel();
  darkIconPanel.setLayout(new FlowLayout());
  final JButton darkIconButton=new JButton();
  darkIconButton.setSize(48,48);
  darkIconButton.setIcon(temp);
  final JButton chooseDarkImage=new JButton(""String_Node_Str"");
  chooseDarkImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        darkIconButton.setIcon(icon);
        builder.setDarkImage(icon);
      }
    }
  }
);
  darkIconPanel.add(chooseDarkImage);
  darkIconPanel.add(darkIconButton);
  c.gridx=0;
  c.gridy=3;
  piecePanel.add(darkIconPanel,c);
  final String[] directions=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox dropdown=new JComboBox(directions);
  final JTextField dist=new JTextField(3);
  dist.setToolTipText(""String_Node_Str"");
  final JTextField knight=new JTextField(2);
  knight.setToolTipText(""String_Node_Str"");
  knight.setEnabled(false);
  final JTextField knightSecond=new JTextField(2);
  knightSecond.setToolTipText(""String_Node_Str"");
  knightSecond.setEnabled(false);
  final JCheckBox knightOn=new JCheckBox(""String_Node_Str"",false);
  knightOn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      knightLike=!knightLike;
      if (knightLike) {
        knight.setEnabled(true);
        knightSecond.setEnabled(true);
      }
 else {
        knight.setEnabled(false);
        knightSecond.setEnabled(false);
      }
    }
  }
);
  final JCheckBox leaper=new JCheckBox(""String_Node_Str"",false);
  final JPanel knightMoving=new JPanel();
  knightMoving.setLayout(new FlowLayout());
  knightMoving.add(knight);
  knightMoving.add(new JLabel(""String_Node_Str""));
  knightMoving.add(knightSecond);
  final JButton addInstruction=new JButton(""String_Node_Str"");
  addInstruction.setToolTipText(""String_Node_Str"");
  addInstruction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (isIntDist()) {
        if (dropdown.getSelectedItem() != null) {
          builder.addMove(stringToChar((String)dropdown.getSelectedItem()),Integer.parseInt(dist.getText()));
          dropdown.removeItemAt(dropdown.getSelectedIndex());
          dist.setText(""String_Node_Str"");
        }
      }
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntDist(){
      try {
        Integer.parseInt(dist.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
    /** 
 * Translate a direction string to it's corresponding char.
 * @param s The string to translate
 * @return The char corresponding to the given String.
 */
    private char stringToChar(    String s){
      if (s.equals(""String_Node_Str""))       return 'N';
      if (s.equals(""String_Node_Str""))       return 'S';
      if (s.equals(""String_Node_Str""))       return 'E';
      if (s.equals(""String_Node_Str""))       return 'W';
      if (s.equals(""String_Node_Str""))       return 'R';
      if (s.equals(""String_Node_Str""))       return 'L';
      if (s.equals(""String_Node_Str""))       return 'r';
 else       return 'l';
    }
  }
);
  c.gridx=0;
  c.gridy=4;
  piecePanel.add(addInstruction,c);
  JPanel movementSetup=new JPanel();
  movementSetup.setLayout(new BoxLayout(movementSetup,BoxLayout.Y_AXIS));
  movementSetup.setLayout(new GridBagLayout());
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=0;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=1;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=1;
  movementSetup.add(dropdown,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=2;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=2;
  movementSetup.add(dist,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=3;
  c.gridwidth=3;
  movementSetup.add(addInstruction,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=5;
  movementSetup.add(leaper,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=6;
  movementSetup.add(knightOn,c);
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=7;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=8;
  movementSetup.add(knightMoving,c);
  c.gridx=0;
  c.gridy=5;
  piecePanel.add(movementSetup,c);
  final JButton done=new JButton(""String_Node_Str"");
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (name.getText() == ""String_Node_Str"" || PieceBuilder.isPieceType(name.getText())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
        return;
      }
      if (knight.isEnabled()) {
        if (isIntKnights()) {
          builder.addMove('x',Integer.parseInt(knight.getText()));
          builder.addMove('y',Integer.parseInt(knightSecond.getText()));
        }
      }
      builder.setName(name.getText());
      PieceBuilder.savePieceType(builder);
      name.setText(""String_Node_Str"");
      lightIconButton.setIcon(temp);
      darkIconButton.setIcon(temp);
      dist.setText(""String_Node_Str"");
      leaper.setSelected(false);
      knightOn.setSelected(false);
      knight.setText(""String_Node_Str"");
      knight.setEnabled(false);
      knightSecond.setText(""String_Node_Str"");
      knightSecond.setEnabled(false);
      dropdown.removeAllItems();
      for (int i=0; i < directions.length; i++)       dropdown.addItem(directions[i]);
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntKnights(){
      try {
        Integer.parseInt(knight.getText());
        Integer.parseInt(knightSecond.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
  }
);
  final JButton help=new JButton(""String_Node_Str"");
  help.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  final JButton next=new JButton(""String_Node_Str"");
  next.setToolTipText(""String_Node_Str"");
  next.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (name.getText().equals(""String_Node_Str"")) {
        Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
 else {
        int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
        if (answer == 0)         Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  cancel.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new BoardCustomMenu(b));
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(help);
  buttons.add(done);
  c.gridx=0;
  c.gridy=7;
  piecePanel.add(buttons,c);
  c.gridx=0;
  c.gridy=0;
  add(piecePanel,c);
  JPanel mainButtons=new JPanel();
  mainButtons.setLayout(new FlowLayout());
  c.gridx=0;
  c.gridy=1;
  mainButtons.add(cancel,c);
  c.gridx=1;
  c.gridy=1;
  mainButtons.add(next,c);
  c.gridx=0;
  c.gridy=1;
  add(mainButtons,c);
}","/** 
 * Method to set up the piece making window.
 */
public void initComponents(){
  builder=new PieceBuilder();
  setSize(550,875);
  setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  JPanel piecePanel=new JPanel();
  piecePanel.setLayout(new GridBagLayout());
  piecePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel namePanel=new JPanel();
  namePanel.setLayout(new FlowLayout());
  namePanel.add(new JLabel(""String_Node_Str""));
  final JTextField name=new JTextField(15);
  namePanel.add(name);
  c.gridx=0;
  c.gridy=0;
  piecePanel.add(namePanel,c);
  final ImageIcon temp=new ImageIcon(""String_Node_Str"");
  temp.setImage(temp.getImage().getScaledInstance(48,48,Image.SCALE_SMOOTH));
  final JPanel lightIconPanel=new JPanel();
  lightIconPanel.setLayout(new FlowLayout());
  final JButton lightIconButton=new JButton();
  lightIconButton.setSize(48,48);
  lightIconButton.setIcon(temp);
  final JButton chooseLightImage=new JButton(""String_Node_Str"");
  chooseLightImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        lightIconButton.setIcon(icon);
        builder.setLightImage(icon);
      }
    }
  }
);
  lightIconPanel.add(chooseLightImage);
  lightIconPanel.add(lightIconButton);
  c.gridx=0;
  c.gridy=2;
  piecePanel.add(lightIconPanel,c);
  final JPanel darkIconPanel=new JPanel();
  darkIconPanel.setLayout(new FlowLayout());
  final JButton darkIconButton=new JButton();
  darkIconButton.setSize(48,48);
  darkIconButton.setIcon(temp);
  final JButton chooseDarkImage=new JButton(""String_Node_Str"");
  chooseDarkImage.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFileChooser fc=new JFileChooser(""String_Node_Str"");
      int returnVal=fc.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageIcon icon=makeIcon(fc,builder);
        darkIconButton.setIcon(icon);
        builder.setDarkImage(icon);
      }
    }
  }
);
  darkIconPanel.add(chooseDarkImage);
  darkIconPanel.add(darkIconButton);
  c.gridx=0;
  c.gridy=3;
  piecePanel.add(darkIconPanel,c);
  final String[] directions=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final JComboBox dropdown=new JComboBox(directions);
  final JTextField dist=new JTextField(3);
  dist.setToolTipText(""String_Node_Str"");
  final JTextField knight=new JTextField(2);
  knight.setToolTipText(""String_Node_Str"");
  knight.setEnabled(false);
  final JTextField knightSecond=new JTextField(2);
  knightSecond.setToolTipText(""String_Node_Str"");
  knightSecond.setEnabled(false);
  final JCheckBox knightOn=new JCheckBox(""String_Node_Str"",false);
  knightOn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      knightLike=!knightLike;
      if (knightLike) {
        knight.setEnabled(true);
        knightSecond.setEnabled(true);
      }
 else {
        knight.setEnabled(false);
        knightSecond.setEnabled(false);
      }
    }
  }
);
  final JCheckBox leaper=new JCheckBox(""String_Node_Str"",false);
  final JPanel knightMoving=new JPanel();
  knightMoving.setLayout(new FlowLayout());
  knightMoving.add(knight);
  knightMoving.add(new JLabel(""String_Node_Str""));
  knightMoving.add(knightSecond);
  final JButton addInstruction=new JButton(""String_Node_Str"");
  addInstruction.setToolTipText(""String_Node_Str"");
  addInstruction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (isIntDist()) {
        if (dropdown.getSelectedItem() != null) {
          builder.addMove(stringToChar((String)dropdown.getSelectedItem()),Integer.parseInt(dist.getText()));
          dropdown.removeItemAt(dropdown.getSelectedIndex());
          dist.setText(""String_Node_Str"");
        }
      }
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntDist(){
      try {
        Integer.parseInt(dist.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
    /** 
 * Translate a direction string to it's corresponding char.
 * @param s The string to translate
 * @return The char corresponding to the given String.
 */
    private char stringToChar(    String s){
      if (s.equals(""String_Node_Str""))       return 'N';
      if (s.equals(""String_Node_Str""))       return 'S';
      if (s.equals(""String_Node_Str""))       return 'E';
      if (s.equals(""String_Node_Str""))       return 'W';
      if (s.equals(""String_Node_Str""))       return 'R';
      if (s.equals(""String_Node_Str""))       return 'L';
      if (s.equals(""String_Node_Str""))       return 'r';
 else       return 'l';
    }
  }
);
  c.gridx=0;
  c.gridy=4;
  piecePanel.add(addInstruction,c);
  JPanel movementSetup=new JPanel();
  movementSetup.setLayout(new BoxLayout(movementSetup,BoxLayout.Y_AXIS));
  movementSetup.setLayout(new GridBagLayout());
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=0;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=1;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=1;
  movementSetup.add(dropdown,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=2;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=1;
  c.gridy=2;
  movementSetup.add(dist,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=3;
  c.gridwidth=3;
  movementSetup.add(addInstruction,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=5;
  movementSetup.add(leaper,c);
  c.insets=new Insets(5,0,0,0);
  c.gridx=0;
  c.gridy=6;
  movementSetup.add(knightOn,c);
  c.insets=new Insets(5,0,5,0);
  c.gridx=0;
  c.gridy=7;
  movementSetup.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=8;
  movementSetup.add(knightMoving,c);
  c.gridx=0;
  c.gridy=5;
  piecePanel.add(movementSetup,c);
  final JButton done=new JButton(""String_Node_Str"");
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (name.getText() == ""String_Node_Str"" || PieceBuilder.isPieceType(name.getText())) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
        return;
      }
      if (knight.isEnabled()) {
        if (isIntKnights()) {
          builder.addMove('x',Integer.parseInt(knight.getText()));
          builder.addMove('y',Integer.parseInt(knightSecond.getText()));
        }
      }
      builder.setName(name.getText());
      PieceBuilder.savePieceType(builder);
      name.setText(""String_Node_Str"");
      lightIconButton.setIcon(temp);
      darkIconButton.setIcon(temp);
      dist.setText(""String_Node_Str"");
      leaper.setSelected(false);
      knightOn.setSelected(false);
      knight.setText(""String_Node_Str"");
      knight.setEnabled(false);
      knightSecond.setText(""String_Node_Str"");
      knightSecond.setEnabled(false);
      dropdown.removeAllItems();
      for (int i=0; i < directions.length; i++)       dropdown.addItem(directions[i]);
    }
    /** 
 * Determine if the user entered a valid integer.
 * @return If the text is a valid integer
 */
    private boolean isIntKnights(){
      try {
        Integer.parseInt(knight.getText());
        Integer.parseInt(knightSecond.getText());
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
  }
);
  final JButton help=new JButton(""String_Node_Str"");
  help.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  final JButton next=new JButton(""String_Node_Str"");
  next.setToolTipText(""String_Node_Str"");
  next.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (name.getText().equals(""String_Node_Str"")) {
        Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
 else {
        int answer=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
        if (answer == 0)         Driver.getInstance().setPanel(new ObjectiveMaker(b));
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  cancel.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new BoardCustomMenu(b));
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(help);
  buttons.add(done);
  c.gridx=0;
  c.gridy=7;
  piecePanel.add(buttons,c);
  c.gridx=0;
  c.gridy=0;
  add(piecePanel,c);
  JPanel mainButtons=new JPanel();
  mainButtons.setLayout(new FlowLayout());
  c.gridx=0;
  c.gridy=1;
  mainButtons.add(cancel,c);
  c.gridx=1;
  c.gridy=1;
  mainButtons.add(next,c);
  c.gridx=0;
  c.gridy=1;
  add(mainButtons,c);
}"
49986,"/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=b.getBoards();
  final JPanel legalDestWhiteCheckBox=new JPanel();
  legalDestWhiteCheckBox.setLayout(new GridLayout(3,1));
  final JCheckBox wCaptureMand=new JCheckBox(""String_Node_Str"");
  legalDestWhiteCheckBox.add(wCaptureMand);
  final JCheckBox wNoMoveObj=new JCheckBox(""String_Node_Str"");
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestWhiteCheckBox.add(wNoMoveObj);
  }
  final JPanel afterCaptureWhiteCheckBox=new JPanel();
  afterCaptureWhiteCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox wChangeColor=new JCheckBox(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wChangeColor);
  }
  final JCheckBox wPieceReturn=new JCheckBox(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wPieceReturn);
  final JCheckBox wDrop=new JCheckBox(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"") || !whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wDrop);
  }
  final JCheckBox wCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wCapturedColorAndDrop);
  final JPanel legalDestBlackCheckBox=new JPanel();
  legalDestBlackCheckBox.setLayout(new GridLayout(3,1));
  final JCheckBox bCaptureMand=new JCheckBox(""String_Node_Str"");
  legalDestBlackCheckBox.add(bCaptureMand);
  final JCheckBox bNoMoveObj=new JCheckBox(""String_Node_Str"");
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestBlackCheckBox.add(bNoMoveObj);
  }
  final JPanel afterCapturepBlackCheckBox=new JPanel();
  afterCapturepBlackCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox bChangeColor=new JCheckBox(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bChangeColor);
  }
  final JCheckBox bPieceReturn=new JCheckBox(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bPieceReturn);
  final JCheckBox bDrop=new JCheckBox(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"") || !blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bDrop);
  }
  final JCheckBox bCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bCapturedColorAndDrop);
  final JPanel sCheckBox=new JPanel();
  sCheckBox.setLayout(new GridLayout(3,1));
  final JCheckBox atomic=new JCheckBox(""String_Node_Str"");
  sCheckBox.add(atomic);
  final JCheckBox switchBoard=new JCheckBox(""String_Node_Str"");
  switchBoard.setEnabled(false);
  sCheckBox.add(switchBoard);
  final JPanel wExtras=new JPanel();
  wExtras.setLayout(new GridBagLayout());
  final JTextField wNumChecks=new JTextField(2);
  Object[] allPieces=PieceBuilder.getSet().toArray();
  final JComboBox wPiecesList=new JComboBox(allPieces);
  JLabel wChecksLabel=new JLabel(""String_Node_Str"");
  JLabel wPiecesLabel=new JLabel(""String_Node_Str"");
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (whiteRules.theEndIsNigh().equals(""String_Node_Str""))     wPiecesLabel.setText(""String_Node_Str"");
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    c.gridx=0;
    c.gridy=0;
    wExtras.add(wChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    wExtras.add(wNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  final JPanel bExtras=new JPanel();
  bExtras.setLayout(new GridBagLayout());
  final JTextField bNumChecks=new JTextField(2);
  final JComboBox bPiecesList=new JComboBox(allPieces);
  JLabel bChecksLabel=new JLabel(""String_Node_Str"");
  JLabel bPiecesLabel=new JLabel(""String_Node_Str"");
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (blackRules.theEndIsNigh().equals(""String_Node_Str""))     bPiecesLabel.setText(""String_Node_Str"");
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    c.gridx=0;
    c.gridy=0;
    bExtras.add(bChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    bExtras.add(bNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  final JButton back=new JButton(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new ObjectiveMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wCaptureMand.isSelected()) {
        whiteRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (wNoMoveObj.isSelected()) {
        whiteRules.addCropLegalDests(""String_Node_Str"");
      }
      if (wChangeColor.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wPieceReturn.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wCapturedColorAndDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (bCaptureMand.isSelected()) {
        blackRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (bNoMoveObj.isSelected()) {
        blackRules.addCropLegalDests(""String_Node_Str"");
      }
      if (bChangeColor.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bPieceReturn.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bCapturedColorAndDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (switchBoard.isSelected() && boards.length == 2) {
        whiteRules.setGetBoard(new GetBoard(""String_Node_Str""));
        blackRules.setGetBoard(new GetBoard(""String_Node_Str""));
      }
      if (atomic.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (wNumChecks.isVisible()) {
        String wNumChecked=wNumChecks.getText();
        try {
          int answer=Integer.parseInt(wNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,answer,""String_Node_Str""));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      if (bNumChecks.isVisible()) {
        String bNumChecked=bNumChecks.getText();
        try {
          int answer=Integer.parseInt(bNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,answer,""String_Node_Str""));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      if (wPiecesList.isVisible()) {
        if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",wPiecesList.getSelectedItem().toString()));
        }
 else {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,wPiecesList.getSelectedItem().toString()));
        }
      }
      if (bPiecesList.isVisible()) {
        bPiecesList.getSelectedItem();
        if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",bPiecesList.getSelectedItem().toString()));
        }
 else {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,bPiecesList.getSelectedItem().toString()));
        }
      }
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteLegalDests=new JPanel();
  whiteLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  whiteLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteLegalDests.add(legalDestWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  whiteTeam.add(whiteLegalDests,c);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(wExtras,c);
  JPanel whiteCapture=new JPanel();
  whiteCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteCapture.add(afterCaptureWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  whiteTeam.add(whiteCapture,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackLegalDests=new JPanel();
  blackLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  blackLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackLegalDests.add(legalDestBlackCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  blackTeam.add(blackLegalDests,c);
  JPanel blackCapture=new JPanel();
  blackCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackCapture.add(afterCapturepBlackCheckBox,c);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(bExtras,c);
  c.gridx=0;
  c.gridy=2;
  blackTeam.add(blackCapture,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel specialRules=new JPanel();
  specialRules.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  specialRules.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  specialRules.add(sCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  add(specialRules,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
  wChangeColor.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  bChangeColor.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  wPieceReturn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
      }
    }
  }
);
  bPieceReturn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bDrop.setEnabled(true);
      }
    }
  }
);
  atomic.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (atomic.isSelected()) {
        wChangeColor.setEnabled(false);
        wChangeColor.setSelected(false);
        bChangeColor.setEnabled(false);
        bChangeColor.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        wChangeColor.setEnabled(true);
        bChangeColor.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
        bDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wCapturedColorAndDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bCapturedColorAndDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  if (boards.length == 2) {
    switchBoard.setEnabled(true);
  }
}","/** 
 * Setting up the window and rules
 */
public void initComponents(){
  setLayout(new GridBagLayout());
  setSize(600,600);
  setBorder(BorderFactory.createLoweredBevelBorder());
  GridBagConstraints c=new GridBagConstraints();
  final Board[] boards=b.getBoards();
  final JPanel legalDestWhiteCheckBox=new JPanel();
  legalDestWhiteCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox wCaptureMand=new JCheckBox(""String_Node_Str"");
  legalDestWhiteCheckBox.add(wCaptureMand);
  final JCheckBox wNoMoveObj=new JCheckBox(""String_Node_Str"");
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestWhiteCheckBox.add(wNoMoveObj);
  }
  final JPanel afterCaptureWhiteCheckBox=new JPanel();
  afterCaptureWhiteCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox wChangeColor=new JCheckBox(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wChangeColor);
  }
  final JCheckBox wPieceReturn=new JCheckBox(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wPieceReturn);
  final JCheckBox wDrop=new JCheckBox(""String_Node_Str"");
  if (!whiteRules.theEndIsNigh().equals(""String_Node_Str"") || !whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCaptureWhiteCheckBox.add(wDrop);
  }
  final JCheckBox wCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  afterCaptureWhiteCheckBox.add(wCapturedColorAndDrop);
  final JPanel legalDestBlackCheckBox=new JPanel();
  legalDestBlackCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox bCaptureMand=new JCheckBox(""String_Node_Str"");
  legalDestBlackCheckBox.add(bCaptureMand);
  final JCheckBox bNoMoveObj=new JCheckBox(""String_Node_Str"");
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    legalDestBlackCheckBox.add(bNoMoveObj);
  }
  final JPanel afterCapturepBlackCheckBox=new JPanel();
  afterCapturepBlackCheckBox.setLayout(new GridLayout(4,1));
  final JCheckBox bChangeColor=new JCheckBox(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bChangeColor);
  }
  final JCheckBox bPieceReturn=new JCheckBox(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bPieceReturn);
  final JCheckBox bDrop=new JCheckBox(""String_Node_Str"");
  if (!blackRules.theEndIsNigh().equals(""String_Node_Str"") || !blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    afterCapturepBlackCheckBox.add(bDrop);
  }
  final JCheckBox bCapturedColorAndDrop=new JCheckBox(""String_Node_Str"");
  afterCapturepBlackCheckBox.add(bCapturedColorAndDrop);
  final JPanel sCheckBox=new JPanel();
  sCheckBox.setLayout(new GridLayout(2,1));
  final JCheckBox atomic=new JCheckBox(""String_Node_Str"");
  sCheckBox.add(atomic);
  final JCheckBox switchBoard=new JCheckBox(""String_Node_Str"");
  switchBoard.setEnabled(false);
  sCheckBox.add(switchBoard);
  final JPanel wExtras=new JPanel();
  wExtras.setLayout(new GridBagLayout());
  final JTextField wNumChecks=new JTextField(2);
  Object[] allPieces=PieceBuilder.getSet().toArray();
  final JComboBox wPiecesList=new JComboBox(allPieces);
  JLabel wChecksLabel=new JLabel(""String_Node_Str"");
  JLabel wPiecesLabel=new JLabel(""String_Node_Str"");
  wNumChecks.setVisible(false);
  wPiecesList.setVisible(false);
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"") || whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (whiteRules.theEndIsNigh().equals(""String_Node_Str""))     wPiecesLabel.setText(""String_Node_Str"");
    wPiecesList.setVisible(true);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
    wNumChecks.setVisible(true);
    wPiecesList.setVisible(true);
    c.gridx=0;
    c.gridy=0;
    wExtras.add(wChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    wExtras.add(wNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    wExtras.add(wPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    wExtras.add(wPiecesList,c);
  }
  final JPanel bExtras=new JPanel();
  bExtras.setLayout(new GridBagLayout());
  final JTextField bNumChecks=new JTextField(2);
  final JComboBox bPiecesList=new JComboBox(allPieces);
  JLabel bChecksLabel=new JLabel(""String_Node_Str"");
  JLabel bPiecesLabel=new JLabel(""String_Node_Str"");
  bNumChecks.setVisible(false);
  bPiecesList.setVisible(false);
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"") || blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    if (blackRules.theEndIsNigh().equals(""String_Node_Str""))     bPiecesLabel.setText(""String_Node_Str"");
    bPiecesList.setVisible(true);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
    bNumChecks.setVisible(true);
    bPiecesList.setVisible(true);
    c.gridx=0;
    c.gridy=0;
    bExtras.add(bChecksLabel,c);
    c.gridx=1;
    c.gridy=0;
    bExtras.add(bNumChecks,c);
    c.gridx=0;
    c.gridy=1;
    c.insets=new Insets(1,1,1,1);
    bExtras.add(bPiecesLabel,c);
    c.gridx=1;
    c.gridy=1;
    bExtras.add(bPiecesList,c);
  }
  final JButton back=new JButton(""String_Node_Str"");
  back.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Driver.getInstance().setPanel(new ObjectiveMaker(b));
    }
  }
);
  JButton save=new JButton(""String_Node_Str"");
  save.setToolTipText(""String_Node_Str"");
  save.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (wCaptureMand.isSelected()) {
        whiteRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (wNoMoveObj.isSelected()) {
        whiteRules.addCropLegalDests(""String_Node_Str"");
      }
      if (wChangeColor.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wPieceReturn.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (wCapturedColorAndDrop.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
      }
      if (bCaptureMand.isSelected()) {
        blackRules.addAdjustTeamDests(new AdjustTeamDests(""String_Node_Str""));
      }
      if (bNoMoveObj.isSelected()) {
        blackRules.addCropLegalDests(""String_Node_Str"");
      }
      if (bChangeColor.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bPieceReturn.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (bCapturedColorAndDrop.isSelected()) {
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (switchBoard.isSelected() && boards.length == 2) {
        whiteRules.setGetBoard(new GetBoard(""String_Node_Str""));
        blackRules.setGetBoard(new GetBoard(""String_Node_Str""));
      }
      if (atomic.isSelected()) {
        whiteRules.addAfterMove(""String_Node_Str"");
        blackRules.addAfterMove(""String_Node_Str"");
      }
      if (wNumChecks.isVisible()) {
        String wNumChecked=wNumChecks.getText();
        try {
          int answer=Integer.parseInt(wNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,answer,""String_Node_Str""));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      if (bNumChecks.isVisible()) {
        String bNumChecked=bNumChecks.getText();
        try {
          int answer=Integer.parseInt(bNumChecked);
          if (answer < 1) {
            JOptionPane.showMessageDialog(null,""String_Node_Str"");
            return;
          }
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,answer,""String_Node_Str""));
        }
 catch (        Exception ne) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
      if (wPiecesList.isVisible()) {
        if (whiteRules.theEndIsNigh().equals(""String_Node_Str"")) {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",wPiecesList.getSelectedItem().toString()));
        }
 else {
          whiteRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,wPiecesList.getSelectedItem().toString()));
        }
      }
      if (bPiecesList.isVisible()) {
        bPiecesList.getSelectedItem();
        if (blackRules.theEndIsNigh().equals(""String_Node_Str"")) {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,""String_Node_Str""));
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",bPiecesList.getSelectedItem().toString()));
        }
 else {
          blackRules.addEndOfGame(new EndOfGame(""String_Node_Str"",false,0,bPiecesList.getSelectedItem().toString()));
        }
      }
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  JPanel whiteTeam=new JPanel();
  whiteTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  whiteTeam.setLayout(new GridBagLayout());
  JPanel whiteLegalDests=new JPanel();
  whiteLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  whiteLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteLegalDests.add(legalDestWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  whiteTeam.add(whiteLegalDests,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  whiteTeam.add(wExtras,c);
  JPanel whiteCapture=new JPanel();
  whiteCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  whiteCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  whiteCapture.add(afterCaptureWhiteCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  whiteTeam.add(whiteCapture,c);
  JPanel blackTeam=new JPanel();
  blackTeam.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  blackTeam.setLayout(new GridBagLayout());
  JPanel blackLegalDests=new JPanel();
  blackLegalDests.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  blackLegalDests.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackLegalDests.add(legalDestBlackCheckBox,c);
  c.gridx=0;
  c.gridy=0;
  blackTeam.add(blackLegalDests,c);
  JPanel blackCapture=new JPanel();
  blackCapture.setLayout(new GridBagLayout());
  c.gridheight=1;
  c.gridx=0;
  c.gridy=1;
  blackCapture.add(new JLabel(""String_Node_Str""),c);
  c.gridx=0;
  c.gridy=2;
  blackCapture.add(afterCapturepBlackCheckBox,c);
  c.insets=new Insets(1,3,3,3);
  c.gridx=0;
  c.gridy=1;
  blackTeam.add(bExtras,c);
  c.gridx=0;
  c.gridy=2;
  blackTeam.add(blackCapture,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=0;
  c.gridy=0;
  add(whiteTeam,c);
  c.insets=new Insets(5,5,5,5);
  c.gridx=1;
  c.gridy=0;
  add(blackTeam,c);
  JPanel specialRules=new JPanel();
  specialRules.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  specialRules.setLayout(new GridBagLayout());
  c.gridx=0;
  c.gridy=1;
  specialRules.add(sCheckBox,c);
  c.gridx=0;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  add(specialRules,c);
  JPanel buttons=new JPanel();
  buttons.setLayout(new FlowLayout());
  buttons.add(back);
  buttons.add(save);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  add(buttons,c);
  wChangeColor.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  bChangeColor.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bChangeColor.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
      }
    }
  }
);
  wPieceReturn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
      }
    }
  }
);
  bPieceReturn.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bPieceReturn.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bDrop.setEnabled(true);
      }
    }
  }
);
  atomic.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (atomic.isSelected()) {
        wChangeColor.setEnabled(false);
        wChangeColor.setSelected(false);
        bChangeColor.setEnabled(false);
        bChangeColor.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        wChangeColor.setEnabled(true);
        bChangeColor.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        wDrop.setEnabled(true);
        bDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wCapturedColorAndDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wDrop.setEnabled(false);
        wDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bCapturedColorAndDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bCapturedColorAndDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bDrop.setEnabled(false);
        bDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  wDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (wDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        wCapturedColorAndDrop.setEnabled(false);
        wCapturedColorAndDrop.setSelected(false);
        wPieceReturn.setEnabled(false);
        wPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        wCapturedColorAndDrop.setEnabled(true);
        wPieceReturn.setEnabled(true);
      }
    }
  }
);
  bDrop.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (bDrop.isSelected()) {
        atomic.setEnabled(false);
        atomic.setSelected(false);
        bCapturedColorAndDrop.setEnabled(false);
        bCapturedColorAndDrop.setSelected(false);
        bPieceReturn.setEnabled(false);
        bPieceReturn.setSelected(false);
      }
 else {
        atomic.setEnabled(true);
        bCapturedColorAndDrop.setEnabled(true);
        bPieceReturn.setEnabled(true);
      }
    }
  }
);
  if (boards.length == 2) {
    switchBoard.setEnabled(true);
  }
}"
49987,"/** 
 * @param startBoard The original board
 * @return The same board.
 */
public Board classicGetBoard(Board startBoard){
  return g.getBoards()[0];
}","/** 
 * @param startBoard The original board
 * @return The same board.
 */
public Board classicGetBoard(Board startBoard){
  return startBoard;
}"
49988,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setLocationRelativeTo(null);
  setResizable(false);
  setLayout(new FlowLayout());
  setResizable(true);
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
  }
  mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  BufferedImage temp=null;
  try {
    temp=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  ImageIcon picture=new ImageIcon(temp);
  JLabel pictureHolder=new JLabel();
  picture.setImage(picture.getImage().getScaledInstance(300,200,Image.SCALE_SMOOTH));
  pictureHolder.setIcon(picture);
  newGame=new JButton(""String_Node_Str"");
  newGame.setToolTipText(""String_Node_Str"");
  newGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      pack();
    }
  }
);
  continueGame=new JButton(""String_Node_Str"");
  continueGame.setToolTipText(""String_Node_Str"");
  continueGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        FileInputStream f_in=new FileInputStream(new File(""String_Node_Str"" + choice));
        ObjectInputStream obj_in=new ObjectInputStream(f_in);
        Game toPlay=(Game)obj_in.readObject();
        helpMenu.setText(""String_Node_Str"");
        gameInfo.setVisible(true);
        gamePlayHelp.setVisible(true);
        gameOptions.setVisible(true);
        remove(mainPanel);
        otherPanel=new PlayGame(toPlay,false);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  viewGame=new JButton(""String_Node_Str"");
  viewGame.setToolTipText(""String_Node_Str"");
  viewGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        File file=new File(""String_Node_Str"" + choice);
        Game toView;
        if (choice.endsWith(""String_Node_Str"")) {
          otherPanel=new PlayGame(true,file);
        }
 else {
          FileInputStream f_in=new FileInputStream(file);
          ObjectInputStream obj_in=new ObjectInputStream(f_in);
          toView=(Game)obj_in.readObject();
          otherPanel=new PlayGame(toView,true);
        }
        completedHelp.setVisible(true);
        helpMenu.setText(""String_Node_Str"");
        ;
        remove(mainPanel);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        System.out.println(e.getMessage());
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  createType=new JButton(""String_Node_Str"");
  createType.setToolTipText(""String_Node_Str"");
  createType.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(true);
      helpMenu.setText(""String_Node_Str"");
      remove(mainPanel);
      otherPanel=new NewTypeMenu();
      add(otherPanel);
      pack();
    }
  }
);
  menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  fileMenu.setForeground(Color.WHITE);
  fileMenu.setMnemonic('F');
  helpMenu=new JMenu(""String_Node_Str"");
  helpMenu.setForeground(Color.white);
  helpMenu.setMnemonic('H');
  JMenuItem helpMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_H);
  helpMenuItem.setToolTipText(""String_Node_Str"");
  BufferedImage help=null;
  try {
    help=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon helpPicture=new ImageIcon(help);
  helpPicture.setImage(helpPicture.getImage().getScaledInstance(600,600,Image.SCALE_SMOOTH));
  helpMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"",""String_Node_Str"",0,helpPicture);
    }
  }
);
  helpMenu.add(helpMenuItem);
  gamePlayHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_G);
  gamePlayHelp.setToolTipText(""String_Node_Str"");
  gamePlayHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  helpMenu.add(gamePlayHelp);
  gamePlayHelp.setVisible(false);
  gameInfo=new JMenuItem(""String_Node_Str"",KeyEvent.VK_I);
  gameInfo.setToolTipText(""String_Node_Str"");
  gameInfo.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
    }
  }
);
  helpMenu.add(gameInfo);
  gameInfo.setVisible(false);
  variantHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_V);
  variantHelp.setToolTipText(""String_Node_Str"");
  variantHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  helpMenu.add(variantHelp);
  variantHelp.setVisible(false);
  completedHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  completedHelp.setToolTipText(""String_Node_Str"");
  completedHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
);
  helpMenu.add(completedHelp);
  completedHelp.setVisible(false);
  JMenuItem newGameItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  newGameItem.setToolTipText(""String_Node_Str"");
  newGameItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(false);
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      if (otherPanel != null)       remove(otherPanel);
      if (mainPanel != null)       remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      pack();
    }
  }
);
  fileMenu.add(newGameItem);
  JMenuItem mainMenu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_M);
  mainMenu.setToolTipText(""String_Node_Str"");
  mainMenu.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      helpMenu.setText(""String_Node_Str"");
      variantHelp.setVisible(false);
      gameInfo.setVisible(false);
      gamePlayHelp.setVisible(false);
      completedHelp.setVisible(false);
      if (gameOptions != null)       gameOptions.setVisible(false);
      remove(otherPanel);
      add(mainPanel);
      pack();
    }
  }
);
  fileMenu.add(mainMenu);
  JMenuItem exitMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_Q);
  exitMenuItem.setToolTipText(""String_Node_Str"");
  exitMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      System.exit(0);
    }
  }
);
  fileMenu.add(exitMenuItem);
  menuBar.add(fileMenu);
  menuBar.add(helpMenu);
  setJMenuBar(menuBar);
  mainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=0;
  mainPanel.add(pictureHolder,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  mainPanel.add(newGame,c);
  c.gridx=2;
  c.gridy=1;
  c.gridwidth=1;
  mainPanel.add(createType,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mainPanel.add(continueGame,c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mainPanel.add(viewGame,c);
  add(mainPanel);
  setVisible(true);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
private void initComponents(){
  setTitle(""String_Node_Str"");
  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  setSize(325,340);
  setLocationRelativeTo(null);
  setResizable(false);
  setLayout(new FlowLayout());
  setResizable(true);
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
  }
  mainPanel=new JPanel();
  mainPanel.setBorder(BorderFactory.createLoweredBevelBorder());
  BufferedImage temp=null;
  try {
    temp=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  ImageIcon picture=new ImageIcon(temp);
  JLabel pictureHolder=new JLabel();
  picture.setImage(picture.getImage().getScaledInstance(300,200,Image.SCALE_SMOOTH));
  pictureHolder.setIcon(picture);
  newGame=new JButton(""String_Node_Str"");
  newGame.setToolTipText(""String_Node_Str"");
  newGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      pack();
    }
  }
);
  continueGame=new JButton(""String_Node_Str"");
  continueGame.setToolTipText(""String_Node_Str"");
  continueGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        FileInputStream f_in=new FileInputStream(new File(""String_Node_Str"" + choice));
        ObjectInputStream obj_in=new ObjectInputStream(f_in);
        Game toPlay=(Game)obj_in.readObject();
        helpMenu.setText(""String_Node_Str"");
        gameInfo.setVisible(true);
        gamePlayHelp.setVisible(true);
        gameOptions.setVisible(true);
        remove(mainPanel);
        otherPanel=new PlayGame(toPlay,false);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  viewGame=new JButton(""String_Node_Str"");
  viewGame.setToolTipText(""String_Node_Str"");
  viewGame.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      try {
        File dir=new File(""String_Node_Str"");
        String[] files=dir.list();
        if (files == null) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        String choice=(String)JOptionPane.showInputDialog(Driver.getInstance(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,files,null);
        if (choice == null)         return;
        File file=new File(""String_Node_Str"" + choice);
        Game toView;
        if (choice.endsWith(""String_Node_Str"")) {
          otherPanel=new PlayGame(true,file);
        }
 else {
          FileInputStream f_in=new FileInputStream(file);
          ObjectInputStream obj_in=new ObjectInputStream(f_in);
          toView=(Game)obj_in.readObject();
          otherPanel=new PlayGame(toView,true);
        }
        completedHelp.setVisible(true);
        helpMenu.setText(""String_Node_Str"");
        ;
        remove(mainPanel);
        add(otherPanel);
        pack();
      }
 catch (      Exception e) {
        System.out.println(e.getMessage());
        e.printStackTrace();
        JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
);
  createType=new JButton(""String_Node_Str"");
  createType.setToolTipText(""String_Node_Str"");
  createType.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(true);
      helpMenu.setText(""String_Node_Str"");
      remove(mainPanel);
      otherPanel=new NewTypeMenu();
      add(otherPanel);
      pack();
    }
  }
);
  menuBar=new JMenuBar();
  JMenu fileMenu=new JMenu(""String_Node_Str"");
  fileMenu.setForeground(Color.WHITE);
  fileMenu.setMnemonic('F');
  helpMenu=new JMenu(""String_Node_Str"");
  helpMenu.setForeground(Color.white);
  helpMenu.setMnemonic('H');
  JMenuItem helpMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_H);
  helpMenuItem.setToolTipText(""String_Node_Str"");
  BufferedImage help=null;
  try {
    help=ImageIO.read(new File(""String_Node_Str""));
  }
 catch (  IOException e1) {
    System.out.println(""String_Node_Str"");
    e1.printStackTrace();
  }
  final ImageIcon helpPicture=new ImageIcon(help);
  helpPicture.setImage(helpPicture.getImage().getScaledInstance(600,600,Image.SCALE_SMOOTH));
  helpMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"",""String_Node_Str"",0,helpPicture);
    }
  }
);
  helpMenu.add(helpMenuItem);
  gamePlayHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_G);
  gamePlayHelp.setToolTipText(""String_Node_Str"");
  gamePlayHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  helpMenu.add(gamePlayHelp);
  gamePlayHelp.setVisible(false);
  gameInfo=new JMenuItem(""String_Node_Str"",KeyEvent.VK_I);
  gameInfo.setToolTipText(""String_Node_Str"");
  gameInfo.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
    }
  }
);
  helpMenu.add(gameInfo);
  gameInfo.setVisible(false);
  variantHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_V);
  variantHelp.setToolTipText(""String_Node_Str"");
  variantHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",1);
    }
  }
);
  helpMenu.add(variantHelp);
  variantHelp.setVisible(false);
  completedHelp=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
  completedHelp.setToolTipText(""String_Node_Str"");
  completedHelp.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JOptionPane.showMessageDialog(Driver.this,""String_Node_Str"" + ""String_Node_Str"");
    }
  }
);
  helpMenu.add(completedHelp);
  completedHelp.setVisible(false);
  JMenuItem newGameItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_N);
  newGameItem.setToolTipText(""String_Node_Str"");
  newGameItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      variantHelp.setVisible(false);
      helpMenu.setText(""String_Node_Str"");
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      if (otherPanel != null)       remove(otherPanel);
      if (mainPanel != null)       remove(mainPanel);
      otherPanel=new NewGameMenu();
      add(otherPanel);
      gamePlayHelp.setVisible(true);
      gameInfo.setVisible(true);
      pack();
    }
  }
);
  fileMenu.add(newGameItem);
  JMenuItem mainMenu=new JMenuItem(""String_Node_Str"",KeyEvent.VK_M);
  mainMenu.setToolTipText(""String_Node_Str"");
  mainMenu.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      helpMenu.setText(""String_Node_Str"");
      variantHelp.setVisible(false);
      gameInfo.setVisible(false);
      gamePlayHelp.setVisible(false);
      completedHelp.setVisible(false);
      if (gameOptions != null)       gameOptions.setVisible(false);
      if (otherPanel != null)       remove(otherPanel);
      add(mainPanel);
      pack();
    }
  }
);
  fileMenu.add(mainMenu);
  JMenuItem exitMenuItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_Q);
  exitMenuItem.setToolTipText(""String_Node_Str"");
  exitMenuItem.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      System.exit(0);
    }
  }
);
  fileMenu.add(exitMenuItem);
  menuBar.add(fileMenu);
  menuBar.add(helpMenu);
  setJMenuBar(menuBar);
  mainPanel.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=0.0;
  c.gridwidth=3;
  c.gridx=0;
  c.gridy=0;
  mainPanel.add(pictureHolder,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  c.gridwidth=2;
  mainPanel.add(newGame,c);
  c.gridx=2;
  c.gridy=1;
  c.gridwidth=1;
  mainPanel.add(createType,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  c.gridwidth=2;
  mainPanel.add(continueGame,c);
  c.gridx=2;
  c.gridy=2;
  c.gridwidth=1;
  mainPanel.add(viewGame,c);
  add(mainPanel);
  setVisible(true);
}"
49989,"public JMenu createMenu(){
  menu=new JMenu(""String_Node_Str"");
  if (!isPlayback) {
    JMenuItem draw=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
    draw.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (g.getLastMove() == null)         return;
        g.getLastMove().setResult(new Result(Result.DRAW));
        endOfGame(new Result(Result.DRAW));
      }
    }
);
    menu.add(draw);
  }
  return menu;
}","public JMenu createMenu(){
  menu=new JMenu(""String_Node_Str"");
  if (!isPlayback) {
    drawItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_R);
    drawItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (g.getLastMove() == null)         return;
        g.getLastMove().setResult(new Result(Result.DRAW));
        endOfGame(new Result(Result.DRAW));
      }
    }
);
    menu.add(drawItem);
  }
  return menu;
}"
49990,"/** 
 * @param r Reference to which button the user clicked for the end game. ""Save"" ""New Game"" or ""Quit""
 */
public static void endOfGame(Result r){
  if (isPlayback)   return;
  Object[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int answer=JOptionPane.showOptionDialog(null,""String_Node_Str"" + r.text() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",r.text(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0]);
switch (answer) {
case 0:
    String fileName=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
  g.saveGame(""String_Node_Str"",fileName,g.isClassicChess());
Driver.getInstance().revertPanel();
break;
case 2:
System.exit(0);
break;
default :
Driver.getInstance().revertPanel();
}
}","/** 
 * @param r Reference to which button the user clicked for the end game. ""Save"" ""New Game"" or ""Quit""
 */
public static void endOfGame(Result r){
  if (isPlayback)   return;
  Object[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String toDisplay;
  System.out.println(r.isDraw());
  if (r.isDraw())   toDisplay=""String_Node_Str"" + ""String_Node_Str"";
 else   toDisplay=""String_Node_Str"" + r.text() + ""String_Node_Str""+ ""String_Node_Str"";
  toDisplay+=""String_Node_Str"";
  int answer=JOptionPane.showOptionDialog(null,toDisplay,r.text(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0]);
switch (answer) {
case 0:
    String fileName=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
  g.saveGame(""String_Node_Str"",fileName,g.isClassicChess());
Driver.getInstance().revertPanel();
break;
case 2:
System.exit(0);
break;
default :
Driver.getInstance().revertPanel();
}
}"
49991,"/** 
 * Revert the piece back to what it was.
 * @param p The piece to unpromote
 * @return The unpromoted piece.
 */
public Piece classicUndo(Piece p){
  try {
    Constructor<?> con=lastPromoted.getConstructor(boolean.class,Square.class,Board.class);
    Piece promoted=(Piece)con.newInstance(p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * Revert the piece back to what it was.
 * @param p The piece to unpromote
 * @return The unpromoted piece.
 */
public Piece classicUndo(Piece p){
  try {
    Piece promoted=PieceBuilder.makePiece(lastPromoted,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}"
49992,"/** 
 * In this case, only pawns can promote, allow the user to pick which class it promotes to.
 * @param p The piece to promote
 * @param verified Whether it has been verified that thisis ok
 * @param promo What the piece was promoted to.
 * @return The promoted Piece.
 */
public Piece classicPromotion(Piece p,boolean verified,String promo){
  lastPromoted=p.getClass();
  if (!verified && promo == null) {
    klazz=null;
    while (klazz == null) {
      String result=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},null);
      if (result == null) {
        continue;
      }
      try {
        klazz=result;
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
 else   if (promo != null) {
    klazz=promo;
  }
  try {
    Piece promoted=PieceBuilder.makePiece(klazz,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * In this case, only pawns can promote, allow the user to pick which class it promotes to.
 * @param p The piece to promote
 * @param verified Whether it has been verified that thisis ok
 * @param promo What the piece was promoted to.
 * @return The promoted Piece.
 */
public Piece classicPromotion(Piece p,boolean verified,String promo){
  lastPromoted=p.getName();
  if (!verified && promo == null) {
    klazz=null;
    while (klazz == null) {
      String result=(String)JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},null);
      if (result == null) {
        continue;
      }
      try {
        klazz=result;
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
 else   if (promo != null) {
    klazz=promo;
  }
  try {
    Piece promoted=PieceBuilder.makePiece(klazz,p.isBlack(),p.getSquare(),p.getBoard());
    if (promoted.isBlack()) {
      g.getBlackTeam().set(g.getBlackTeam().indexOf(p),promoted);
    }
 else {
      g.getWhiteTeam().set(g.getWhiteTeam().indexOf(p),promoted);
    }
    promoted.getLegalDests().clear();
    promoted.setMoveCount(p.getMoveCount());
    return promoted;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}"
49993,"private void setPieceOnBoard(boolean isBlack){
  System.out.println(option.isHabitable());
  if (option.isOccupied() == false) {
    square.setBackgroundColor(option.getColor());
    square.setHabitable(option.isHabitable());
    square.refresh();
    square.setPiece(null);
    System.out.println(option.getColor());
  }
 else {
    if (square.isHabitable() == true) {
      Piece p=PieceBuilder.makePiece(option.getPiece().getName(),isBlack,square,board);
      if (isBlack)       blackTeam.add(p);
 else       whiteTeam.add(p);
      square.setPiece(p);
      square.refresh();
    }
 else {
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.WARNING_MESSAGE);
    }
  }
}","/** 
 * @param isBlack
 */
private void setPieceOnBoard(boolean isBlack){
  System.out.println(option.isHabitable());
  if (option.isOccupied() == false) {
    square.setBackgroundColor(option.getColor());
    square.setHabitable(option.isHabitable());
    square.refresh();
    square.setPiece(null);
    System.out.println(option.getColor());
  }
 else {
    if (square.isHabitable() == true) {
      Piece p=PieceBuilder.makePiece(option.getPiece().getName(),isBlack,square,board);
      if (isBlack)       blackTeam.add(p);
 else       whiteTeam.add(p);
      square.setPiece(p);
      square.refresh();
    }
 else {
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.WARNING_MESSAGE);
    }
  }
}"
49994,"@Override public void mouseExited(MouseEvent arg0){
}","public void mouseExited(MouseEvent arg0){
}"
49995,"@Override public void valueChanged(ListSelectionEvent e){
  ListSelectionModel lsm=(ListSelectionModel)e.getSource();
  int firstIndex=e.getFirstIndex();
  int lastIndex=e.getLastIndex();
  int selection=lsm.getAnchorSelectionIndex();
  if (!lsm.getValueIsAdjusting()) {
    if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
      bShowPiece.getSquare(1,1).setPiece(null);
      bShowPiece.getSquare(1,1).setBackgroundColor(original);
      bShowPiece.getSquare(1,1).setHabitable(true);
      bShowPiece.getSquare(1,1).refresh();
    }
 else {
      if (bShowPiece.getSquare(1,1).isHabitable() == false)       bShowPiece.getSquare(1,1).setHabitable(true);
      if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)       bShowPiece.getSquare(1,1).setBackgroundColor(original);
      Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
      bShowPiece.getSquare(1,1).setPiece(toAdd);
      bShowPiece.getSquare(1,1).refresh();
    }
  }
}","@Override public void valueChanged(ListSelectionEvent e){
  ListSelectionModel lsm=(ListSelectionModel)e.getSource();
  int selection=lsm.getAnchorSelectionIndex();
  if (!lsm.getValueIsAdjusting()) {
    if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
      bShowPiece.getSquare(1,1).setPiece(null);
      bShowPiece.getSquare(1,1).setBackgroundColor(original);
      bShowPiece.getSquare(1,1).setHabitable(true);
      bShowPiece.getSquare(1,1).refresh();
    }
 else {
      if (bShowPiece.getSquare(1,1).isHabitable() == false)       bShowPiece.getSquare(1,1).setHabitable(true);
      if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)       bShowPiece.getSquare(1,1).setBackgroundColor(original);
      Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
      bShowPiece.getSquare(1,1).setPiece(toAdd);
      bShowPiece.getSquare(1,1).refresh();
    }
  }
}"
49996,"/** 
 * Constructor. Initialize the ArrayLists and call initComponents to initialize the GUI.
 * @param b The builder which is creating the new game type.
 * @param whiteRules The whiteRules object.
 * @param blackRules The blackRules object.
 * @return 
 */
public CustomSetupMenu(Builder b,Rules whiteRules,Rules blackRules){
  this.b=b;
  whiteTeam=new ArrayList<Piece>();
  blackTeam=new ArrayList<Piece>();
  initComponents(whiteRules,blackRules);
}","/** 
 * Constructor. Initialize the ArrayLists and call initComponents to initialize the GUI.
 * @param b The builder which is creating the new game type.
 * @param whiteRules The whiteRules object.
 * @param blackRules The blackRules object.
 */
public CustomSetupMenu(Builder b,Rules whiteRules,Rules blackRules){
  this.b=b;
  whiteTeam=new ArrayList<Piece>();
  blackTeam=new ArrayList<Piece>();
  initComponents(whiteRules,blackRules);
}"
49997,"public SetUpMouseListener(Square square,Board board,Square option){
  this.square=square;
  this.board=board;
  this.option=option;
}","/** 
 * @param square
 * @param board
 * @param option
 */
public SetUpMouseListener(Square square,Board board,Square option){
  this.square=square;
  this.board=board;
  this.option=option;
}"
49998,"/** 
 * Constructor Set instance variables to passed parameters
 * @param square The square we are setting up.
 * @param board The board on which the square resides.
 */
public SetUpListener(Square square,Board board){
  this.square=square;
  this.board=board;
}","/** 
 * Constructor Set instance variables to passed parameters
 * @param square The square we are setting up.
 * @param board The board on which the square resides.
 */
public SetUpListener(Square square){
  this.square=square;
}"
49999,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param whiteRules the rules for white team.
 * @param blackRules the rules for black team.
 */
private void initComponents(final Rules whiteRules,final Rules blackRules){
  setLayout(new FlowLayout());
  setBorder(BorderFactory.createLoweredBevelBorder());
  final Board[] boards=b.getBoards();
  final Board bShowPiece=new Board(1,1,false);
  final JPanel showPiece=new JPanel();
  final Piece p=PieceBuilder.makePiece(""String_Node_Str"",true,bShowPiece.getSquare(1,1),bShowPiece);
  showPiece.setLayout(new GridLayout(1,1));
  showPiece.setPreferredSize(new Dimension(50,50));
  JButton jb1=new JButton();
  jb1.addActionListener(new SetUpListener(bShowPiece.getSquare(1,1),bShowPiece));
  bShowPiece.getSquare(1,1).setButton(jb1);
  showPiece.add(jb1);
  bShowPiece.getSquare(1,1).refresh();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.addElement(""String_Node_Str"");
  JList piecesList=new JList(list);
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  ListSelectionModel selectList=piecesList.getSelectionModel();
  final Color original=bShowPiece.getSquare(1,1).getColor();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      ListSelectionModel lsm=(ListSelectionModel)e.getSource();
      int firstIndex=e.getFirstIndex();
      int lastIndex=e.getLastIndex();
      int selection=lsm.getAnchorSelectionIndex();
      if (!lsm.getValueIsAdjusting()) {
        if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
          bShowPiece.getSquare(1,1).setPiece(null);
          bShowPiece.getSquare(1,1).setBackgroundColor(original);
          bShowPiece.getSquare(1,1).setHabitable(true);
          bShowPiece.getSquare(1,1).refresh();
        }
 else {
          if (bShowPiece.getSquare(1,1).isHabitable() == false)           bShowPiece.getSquare(1,1).setHabitable(true);
          if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)           bShowPiece.getSquare(1,1).setBackgroundColor(original);
          Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
          bShowPiece.getSquare(1,1).setPiece(toAdd);
          bShowPiece.getSquare(1,1).refresh();
        }
      }
    }
  }
);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  for (int n=0; n < boards.length; n++) {
    final JPanel grid=new JPanel();
    grid.setLayout(new GridLayout(boards[n].numRows(),boards[n].numCols()));
    grid.setPreferredSize(new Dimension(boards[n].numCols() * 48,boards[n].numRows() * 48));
    int numRows=boards[n].numRows();
    int numCols=boards[n].numCols();
    for (int i=numRows; i > 0; i--) {
      for (int j=1; j <= numCols; j++) {
        JButton jb=new JButton();
        jb.addMouseListener(new SetUpMouseListener(boards[n].getSquare(i,j),boards[n],bShowPiece.getSquare(1,1)));
        boards[n].getSquare(i,j).setButton(jb);
        grid.add(jb);
        boards[n].getSquare(i,j).refresh();
      }
    }
    add(grid);
  }
  add(scrollPane);
  add(showPiece);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      b.whiteTeam=whiteTeam;
      boolean set=false;
      for (      Piece p : whiteTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.blackTeam=blackTeam;
      set=false;
      for (      Piece p : blackTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.writeFile(whiteRules,blackRules);
      Driver.getInstance().revertPanel();
    }
  }
);
  JPanel options=new JPanel();
  options.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  options.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  options.add(submitButton,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  options.add(backButton,c);
  add(options);
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 * @param whiteRules the rules for white team.
 * @param blackRules the rules for black team.
 */
private void initComponents(final Rules whiteRules,final Rules blackRules){
  setLayout(new FlowLayout());
  setBorder(BorderFactory.createLoweredBevelBorder());
  final Board[] boards=b.getBoards();
  final Board bShowPiece=new Board(1,1,false);
  final JPanel showPiece=new JPanel();
  showPiece.setLayout(new GridLayout(1,1));
  showPiece.setPreferredSize(new Dimension(50,50));
  JButton jb1=new JButton();
  jb1.addActionListener(new SetUpListener(bShowPiece.getSquare(1,1)));
  bShowPiece.getSquare(1,1).setButton(jb1);
  showPiece.add(jb1);
  bShowPiece.getSquare(1,1).refresh();
  final DefaultListModel list=new DefaultListModel();
  Object[] allPieces=PieceBuilder.getSet().toArray();
  for (int i=0; i < allPieces.length; i++) {
    list.addElement(allPieces[i]);
  }
  list.addElement(""String_Node_Str"");
  JList piecesList=new JList(list);
  piecesList.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);
  piecesList.setLayoutOrientation(JList.VERTICAL);
  piecesList.setVisibleRowCount(-1);
  piecesList.setSelectedIndex(0);
  Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(0),true,bShowPiece.getSquare(1,1),bShowPiece);
  bShowPiece.getSquare(1,1).setPiece(toAdd);
  bShowPiece.getSquare(1,1).refresh();
  ListSelectionModel selectList=piecesList.getSelectionModel();
  final Color original=bShowPiece.getSquare(1,1).getColor();
  selectList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      ListSelectionModel lsm=(ListSelectionModel)e.getSource();
      int selection=lsm.getAnchorSelectionIndex();
      if (!lsm.getValueIsAdjusting()) {
        if (((String)list.elementAt(selection)).equals(""String_Node_Str"")) {
          bShowPiece.getSquare(1,1).setPiece(null);
          bShowPiece.getSquare(1,1).setBackgroundColor(original);
          bShowPiece.getSquare(1,1).setHabitable(true);
          bShowPiece.getSquare(1,1).refresh();
        }
 else {
          if (bShowPiece.getSquare(1,1).isHabitable() == false)           bShowPiece.getSquare(1,1).setHabitable(true);
          if (bShowPiece.getSquare(1,1).getColor().equals(original) == false)           bShowPiece.getSquare(1,1).setBackgroundColor(original);
          Piece toAdd=PieceBuilder.makePiece((String)list.elementAt(selection),true,bShowPiece.getSquare(1,1),bShowPiece);
          bShowPiece.getSquare(1,1).setPiece(toAdd);
          bShowPiece.getSquare(1,1).refresh();
        }
      }
    }
  }
);
  JScrollPane scrollPane=new JScrollPane(piecesList);
  scrollPane.setPreferredSize(new Dimension(200,200));
  for (int n=0; n < boards.length; n++) {
    final JPanel grid=new JPanel();
    grid.setLayout(new GridLayout(boards[n].numRows(),boards[n].numCols()));
    grid.setPreferredSize(new Dimension(boards[n].numCols() * 48,boards[n].numRows() * 48));
    int numRows=boards[n].numRows();
    int numCols=boards[n].numCols();
    for (int i=numRows; i > 0; i--) {
      for (int j=1; j <= numCols; j++) {
        JButton jb=new JButton();
        jb.addMouseListener(new SetUpMouseListener(boards[n].getSquare(i,j),boards[n],bShowPiece.getSquare(1,1)));
        boards[n].getSquare(i,j).setButton(jb);
        grid.add(jb);
        boards[n].getSquare(i,j).refresh();
      }
    }
    add(grid);
  }
  add(scrollPane);
  add(showPiece);
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().setPanel(new PlayerCustomMenu(b,whiteRules,blackRules));
    }
  }
);
  submitButton=new JButton(""String_Node_Str"");
  submitButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      b.whiteTeam=whiteTeam;
      boolean set=false;
      for (      Piece p : whiteTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        whiteRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.blackTeam=blackTeam;
      set=false;
      for (      Piece p : blackTeam) {
        if (p.getName().equals(""String_Node_Str"")) {
          blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
          set=true;
          break;
        }
      }
      if (!set) {
        blackRules.setObjectivePiece(new ObjectivePiece(""String_Node_Str"",""String_Node_Str""));
      }
      b.writeFile(whiteRules,blackRules);
      Driver.getInstance().revertPanel();
    }
  }
);
  JPanel options=new JPanel();
  options.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  options.setLayout(new GridBagLayout());
  GridBagConstraints c=new GridBagConstraints();
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=1;
  options.add(submitButton,c);
  c.fill=GridBagConstraints.HORIZONTAL;
  c.gridx=0;
  c.gridy=2;
  options.add(backButton,c);
  add(options);
}"
50000,"/** 
 * GUI to collect the options desired for a Square. Make the pop up, create the components and add their ActionListeners to collect information.
 */
private void squareOptions(){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(370,300);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new FlowLayout());
  final JButton pickColor=new JButton(""String_Node_Str"");
  pickColor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Color color=JColorChooser.showDialog(popup,""String_Node_Str"",square.getColor());
      if (color == null)       return;
      if (color != Square.HIGHLIGHT_COLOR) {
        square.setBackgroundColor(color);
        pickColor.setBackground(color);
      }
 else {
        JOptionPane.showMessageDialog(popup,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
      }
    }
  }
);
  popup.add(pickColor);
  final JCheckBox uninhabitable=new JCheckBox(""String_Node_Str"",!square.isHabitable());
  popup.add(uninhabitable);
  final JButton done=new JButton(""String_Node_Str"");
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      square.setHabitable(!uninhabitable.isSelected());
      popup.dispose();
    }
  }
);
  popup.add(done);
  popup.setVisible(true);
}","/** 
 * GUI to collect the options desired for a Square. Make the pop up, create the components and add their ActionListeners to collect information.
 */
private void squareOptions(){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(370,120);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new FlowLayout());
  final JButton pickColor=new JButton(""String_Node_Str"");
  pickColor.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      Color color=JColorChooser.showDialog(popup,""String_Node_Str"",square.getColor());
      if (color == null)       return;
      if (color != Square.HIGHLIGHT_COLOR) {
        square.setBackgroundColor(color);
        pickColor.setBackground(color);
      }
 else {
        JOptionPane.showMessageDialog(popup,""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
      }
    }
  }
);
  popup.add(pickColor);
  final JCheckBox uninhabitable=new JCheckBox(""String_Node_Str"",!square.isHabitable());
  popup.add(uninhabitable);
  final JButton done=new JButton(""String_Node_Str"");
  done.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      square.setHabitable(!uninhabitable.isSelected());
      popup.dispose();
    }
  }
);
  popup.add(done);
  popup.setVisible(true);
}"
